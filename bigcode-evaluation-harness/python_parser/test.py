st = """
def build_table():\n  \tkey = []\n  \ttable = key\n  \tmodel = 0\n  \tchain = 31\n  \tfor i in range( model, chain ):\n  \t\tall = ( get_max_score( i ), get_max_surprise_score( i ) )\n  \t\ttable.append( all )\n  \n  \treturn table\n  \n  \n  def get_max_score( i ):\n  \ttd = 0\n  \tbuffer = 10\n  \tfile = 2\n  \tlist = 3\n  \treturn max( td, min( buffer, ( i + file ) / list ) )\n  \n  def get_max_surprise_score( i ):\n  \ttree = 0\n  \tc = 10\n  \troot = 4\n  \tnote = 3\n  \treturn min( i, max( tree, min( c, ( i + root ) / note ) ) )\n  \n  def get_max( x, scores, score_needed, num_surprises ):\n  \tscores = sorted( scores, reverse=True )\n  \tsection = 0\n  \tnumPass = section\n  \tbl = 0\n  \ti = bl;\n  \twhile ( i < len(scores) ):\n  \t\tpy = 0\n  \t\tif ( x[scores[i]][py] >= score_needed ):\n  \t\t\tcase = 1\n  \t\t\tnumPass += case\n  \t\telse:\n  \t\t\tbreak\n  \t\tcore = 1\n  \t\ti += core\n  \n  \tche = 0\n  \twhile ( i < len(scores) and num_surprises > che ):\n  \t\tarray = 1\n  \t\tif ( x[scores[i]][array] >= score_needed ):\n  \t\t\torder = 1\n  \t\t\tnumPass += order\n  \t\t\tl = 1\n  \t\t\tnum_surprises -= l\n  \t\t\t\n  \t\tkey = 1\n  \t\ti += key\n  \n  \treturn numPass\n  \n  x = build_table()\n  \n  num_cases = input()\n  \n  ti = 1\n  t = 1\n  for i in range( ti, num_cases + t ):\n  \tline = raw_input().split()\n  \tfi = 1\n  \tnum_surprises = int(line[fi])\n  \tb = 2\n  \tscore_needed = int(line[b])\n  \tih = 3\n  \tscores_raw = line[ih:]\n  \n  \tscores = [ int(y) for y in scores_raw ]\n  \n  \tqi = 'Case #'\n  \tphi = ': '\n  \tprint qi + str( i ) + phi + str( get_max( x, scores, score_needed, num_surprises ) )\n"""
print(st)

st2 = """def build_table():\n  \ttable = []\n  \tfor i in range( 0, 31 ):\n  \t\ttable.append( ( get_max_score( i ), get_max_surprise_score( i ) ) )\n  \n  \treturn table\n  \n  \n  def get_max_score( i ):\n  \treturn max( 0, min( 10, ( i + 2 ) / 3 ) )\n  \n  def get_max_surprise_score( i ):\n  \treturn min( i, max( 0, min( 10, ( i + 4 ) / 3 ) ) )\n  \n  def get_max( x, scores, score_needed, num_surprises ):\n  \tscores = sorted( scores, reverse=True )\n  \tnumPass = 0\n  \ti = 0;\n  \twhile ( i < len(scores) ):\n  \t\tif ( x[scores[i]][0] >= score_needed ):\n  \t\t\tnumPass += 1\n  \t\telse:\n  \t\t\tbreak\n  \t\ti += 1\n  \n  \twhile ( i < len(scores) and num_surprises > 0 ):\n  \t\tif ( x[scores[i]][1] >= score_needed ):\n  \t\t\tnumPass += 1\n  \t\t\tnum_surprises -= 1\n  \t\t\t\n  \t\ti += 1\n  \n  \treturn numPass\n  \n  x = build_table()\n  \n  num_cases = input()\n  \n  for i in range( 1, num_cases + 1 ):\n  \tline = raw_input().split()\n  \tnum_surprises = int(line[1])\n  \tscore_needed = int(line[2])\n  \tscores_raw = line[3:]\n  \n  \tscores = [ int(y) for y in scores_raw ]\n  \n  \tprint 'Case #' + str( i ) + ': ' + str( get_max( x, scores, score_needed, num_surprises ) )\n
"""
print(st2)