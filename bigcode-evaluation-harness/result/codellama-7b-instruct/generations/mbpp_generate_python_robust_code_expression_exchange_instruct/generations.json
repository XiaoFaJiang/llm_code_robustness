[[""], [""], [""], [""], [""], [""], [""], [""], [""], [""], ["port math\n\ndef max_Prime_Factors(n):\n    maxPrime = -1\n    while 0 == n % 2:\n        maxPrime = 2\n        n >>= 1\n    for i in range(3, 1 + int(math.sqrt(n)), 2):\n        if n % i == 0:\n            maxPrime = i\n            n = n // i\n    return maxPrime"], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], ["\nThis code will return the n-th number in the Newman-Conway sequence."], ["import math\n\ndef surfacearea_sphere(r):\n  surfacearea = math.pi * 4*r*r\n  return surfacearea\n"], [""], [""], [""], [""], ["\nThis code calculates the Eulerian number a(n, m) by using the formula:\n\na(n, m) = n! / (m! * (n - m)!)\n\nwhere n! is the factorial of n, and m! is the factorial of m.\n\nThe formula is calculated by multiplying the factorials of n and m, and then dividing the result by the factorial of n - m.\n\nThe code first checks if m is greater than or equal to n, or if n is equal to 0. If either of these conditions is true, the function returns 0.\n\nOtherwise, the function calculates the factorials of n and m using the built-in `math.factorial()` function, and then uses the formula to calculate the Eulerian number.\n\nNote that the `math` module must be imported at the beginning of the code for this function to work."], [""], [""], [""], ["def smartNumber(n):\n    MAX = 3000\n    primes = MAX * [0]\n    result = []\n    for i in range(2, MAX):\n        if (0 == primes[i]):\n            primes[i] = 1\n            j = 2 * i\n            while j < MAX:\n                if (0 == primes[j]):\n                    primes[j] = 1\n                    result.append(j)\n                j += 1\n    return result[n-1]\n"], [""], [""], [""], [""], [""], [""], [""], ["def cal_electbill(units):\n    if units < 50:\n        amount = 2.60 * units\n        surcharge = 25\n    elif units <= 100:\n        amount = ((units - 50) * 3.25) + 130\n        surcharge = 35\n    elif units <= 200:\n        amount = ((units - 100) * 4.50) + 230\n        surcharge = 45\n    else:\n        amount = ((units - 200) * 5.75) + 330\n        surcharge = 55\n    return amount + surcharge\n"], [""], [""], [""], [""], ["\n\nThe function `closest` takes a single argument `x` and returns the maximum sum of digits of `x` divided into two parts.\n\nThe code first calculates the sum of digits of `x` using the `sum_digits_single` function.\n\nThen, it divides `x` into two parts by taking the floor of `x/2` and the ceiling of `x/2`.\n\nFinally, it returns the maximum sum of digits of the two parts.\n\nNote that the function assumes that `x` is a positive integer. If `x` is a negative integer, the function will return a wrong result."], [""], [""], [""], ["\nThis code will sort the array using the merge sort algorithm."], [""], [""], [""], [""], ["def month_season(month, days):\n    if month in ('January', 'February', 'March'):\n        season = 'winter'\n    elif month in ('April', 'May', 'June'):\n        season = 'spring'\n    elif month in ('July', 'August', 'September'):\n        season = 'summer'\n    else:\n        season = 'autumn'\n    if ('March' == month) and (days > 19):\n        season = 'spring'\n    return season\n"], [""], [""], [""], [""], [""], [""], [""], ["import math\n\ndef perimeter_pentagon(a):\n    perimeter = (a * 5)\n    return perimeter\n"], [""], [""], ["from math import radians, sin, cos, acos\n\ndef distance_lat_long(slat, slon, elat, elon):\n    dist = acos(sin(slat)*sin(elat) + cos(slat)*cos(elat)*cos(slon - elon)) * 6371.01\n    return dist\n"], [""], [""], [""], [""], [""], [""], ["def check_monthnumber(monthname3):\n  if monthname3 ==\"April\" or monthname3== \"June\" or monthname3== \"September\" or monthname3== \"November\":\n    return 1\n  else:\n    return 0\n"], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], ["import math\n\ndef lateralsuface_cylinder(r, h):\n    lateralsurface = r * math.pi * 2 * h\n    return lateralsurface\n"], [""], [""], [""], [""], [""], [""], [""], ["def newman_prime(n):\n    if 0 == n or 1 == n:\n        return n\n    else:\n        # begin to write code\n        # find the nth Newman-Shanks-Williams prime number\n        # use the Sieve of Eratosthenes algorithm\n        # start with the number 2 and increment by 1\n        # mark all multiples of the current number as composite\n        # continue until the nth prime is found\n        # return the nth prime\n"], ["def lateralsurface_cube(l):\n  LSA = (l * l) * 4\n  return LSA\n"], [""], [""], [""], [""], [""], [""], [""], [""], ["def max_val(listval):\n    max_val = max(i for i in listval if isinstance(i, long))\n    return max_val\n"], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], ["def check_monthnum(monthname1):\n  if monthname1 == \"February\":\n    return 1\n  else:\n    return 0\n"], [""], [""], [""], [""], ["\nThis code is a recursive implementation of the zigzag function. It takes two arguments, n and k, and returns the value of the zigzag function at those arguments. The function is defined as follows:\n\n* If n and k are both 0, the function returns 1.\n* Otherwise, the function calls itself with arguments n-1 and k-1, and with arguments n-1 and k+1. The result of these calls is added together and returned as the result of the function.\n\nThis implementation is based on the recurrence relation given in the problem statement. It is a simple and efficient way to compute the zigzag function, and it can be easily extended to handle larger values of n and k."], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], ["\nThis code checks if a binary tree is balanced or not. It does this by recursively traversing the tree and checking the height of each subtree. If the height of any subtree is greater than 1, the tree is not balanced. The function `is_balanced` returns `True` if the tree is balanced, and `False` otherwise.\n\nThe function `get_height` returns the height of a subtree. It does this by recursively traversing the subtree and returning the maximum height of the left and right subtrees.\n\nThe `Node` class represents a node in the binary tree. It has a `data` attribute that stores the data in the node, and `left` and `right` attributes that store the left and right child nodes, respectively."], ["def lateralsurface_cuboid(l, w, h):\n    LSA = h * 2 * (l + w)\n    return LSA\n"], [""], [""], ["def surfacearea_cuboid(l, w, h):\n    SA = (l*w + l * h + w * h) * 2\n    return SA\n"], [""], [""], ["def get_perrin(n):\n  if (0 == n):\n    return 3\n  if (1 == n):\n    return 1\n  else:\n    return get_perrin(n-1) + get_perrin(n-2)\n"], [""], ["def even_or_odd(N):\n    l = len(N)\n    if ('0' == N[l-1] or '2' == N[l-1] or \n        '4' == N[l-1] or '6' == N[l-1] or \n        '8' == N[l-1] or 'A' == N[l-1]):\n        return 'even'\n    else:\n        return 'odd'\n"], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], [""], ["def breakSum(n):\n    MAX = 1000000\n    dp = (1 + n) * [0]\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                dp[i] = max(dp[i], dp[j] + dp[k])\n\n    return dp[n]\n"], [""], [""], [""], ["def filter_oddnumbers(nums):\n    odd_nums = list(filter(lambda x: 0 != x%2, nums))\n    return odd_nums\n"], ["def parabola_directrix(a, b, c):\n  directrix=((long)(c - ((b * b) + 1) * 4 * a ))\n  return directrix\n"], [""], ["def median_trapezium(base1, base2, height):\n    # Calculate the area of the trapezium\n    area = (base1 + base2) * height * 0.5\n    # Calculate the median\n    median = area ** 0.5\n    return median\n"], [""], [""], [""], ["def surfacearea_cube(l):\n  surfacearea= l * 6*l\n  return surfacearea\n"], ["def cal_sum(n):\n\ta = 3\n\tb = 0\n\tc = 2\n\tif (0 == n): \n\t\treturn 3\n\tif (1 == n): \n\t\treturn 3\n\tif (2 == n): \n\t\treturn 5\n\telse:\n\t\treturn a + cal_sum(n-1)\n"], [""], [""], [""], ["def check_monthnumb_number(monthnum2):\n  if(1 == monthnum2 or 3 == monthnum2 or 5 == monthnum2 or 7 == monthnum2 or 8 == monthnum2 or 10 == monthnum2 or 12 == monthnum2):\n    return True\n  else:\n    return False\n"], [""], [""], [""], [""], ["def decimal_to_Octal(deciNum):\n    octalNum = 0\n    countval = 1\n    dNo = deciNum\n    while (0 != deciNum):\n        octalNum += (deciNum % 8) * countval\n        deciNum //= 8\n        countval *= 10\n    return octalNum\n"], [""], [""], [""], [""], [""], [""], [""], ["import math\n\ndef area_pentagon(a):\n  area = (math.sqrt((5 + 2 * math.sqrt(5)) * 5) * pow(a, 2)) / 4.0\n  return area\n"], [""], [""], [""], [""], ["def diameter_circle(r):\n  diameter = r * 2\n  return diameter\n"], [""], [""], [""], [""], [""]]