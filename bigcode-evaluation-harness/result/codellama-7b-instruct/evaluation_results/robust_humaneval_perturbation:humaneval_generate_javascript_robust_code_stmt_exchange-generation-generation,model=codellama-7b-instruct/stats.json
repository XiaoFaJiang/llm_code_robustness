[
  {
    "name": {
      "name": "full_level_robustness",
      "split": "test"
    },
    "count": 29,
    "generations": [
      [
        "/* Return list of all prefixes from shortest to longest of the input string\n  */\nconst allPrefixes = (string) => {\n  var result = [];\n  {\n      let i = 0;\n      while(i < string.length){\n    result.push(string.slice(0, i+1));      i++;\n      }\n  }\n  return result;\n}"
      ],
      [
        "const findClosestElements = (numbers) => {\n  var closest_pair, distance;\n  // Loop through the array of numbers\n  for (let i = 0; i < numbers.length; i++) {\n    // Loop through the array of numbers again\n    for (let j = 0; j < numbers.length; j++) {\n      // If the current element is not the same as the previous element\n      if (numbers[i] !== numbers[j]) {\n        // Calculate the distance between the two elements\n        const distance = Math.abs(numbers[i] - numbers[j]);\n        // If the distance is less than the current shortest distance\n        if (distance < closest_pair) {\n          // Set the new closest pair\n          closest_pair = [numbers[i], numbers[j]];\n        }\n      }\n    }\n  }\n  return closest_pair;\n};"
      ],
      [
        "const largestDivisor = (n) => {\n  {\n      let i = n - 1;\n      while (i >= 0) {\n          if (n % i == 0) {\n              i--;\n          } else {\n              break;\n          }\n      }\n      return i;\n  }\n}"
      ],
      [
        "const factorize = (n) => {\n  if (n <= 1) {\n    return [];\n  }\n  const fact = [0, 0, 0, 0];\n  let i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (!(n % i === 0)) {\n      i++;\n    } else {\n      fact[i]++;\n      n /= i;\n      i = 2;\n    }\n  }\n  return fact;\n};"
      ],
      [
        "const findZero = (xs) => {\n  var begin = -1.0, end = 1.0;\n  for(;(poly(xs, begin) * poly(xs, end) > 0);){\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let mid = (begin + end) / 2.0;\n    if (poly(xs, mid) * poly(xs, begin) <= 0) {\n      end = mid;\n    } else {\n      begin = mid;\n    }\n  }\n  return begin;\n}"
      ],
      [
        "const fizzBuzz = (n) => {\n  var ns = [], ans = 0;\n  {\n      let i = 0;\n      while(i < n){if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);      i++;\n      }\n  }\n  \n  ans = ns.filter(x => x.toString().includes(\"7\")).length;\n\n  return ans;\n};\n\n/*\nTest cases:\n\nfizzBuzz(50); // 0\nfizzBuzz(78); // 2\nfizzBuzz(79); // 3\n*/"
      ],
      [
        "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  {\n      let i = 0;\n      while(i < Math.floor((s.length + 2) / 3)){\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n        i++;\n      }\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n  return encodeCyclic(encodeCyclic(s));\n}\n\nconst encodeWithCycle = (s) => {\n  // begin to write code\n  let encodedString = encodeCyclic(s);\n  return encodedString;\n}\n\nconst decodeWithCycle = (s) => {\n  // begin to write code\n  let decodedString = decodeCyclic(s);\n  return decodedString;\n}"
      ],
      [
        "/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    {\n        let k = 2;\n        for (; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n          if (p % k == 0)\n            return false;\n        }\n    }\n    return true;\n  }\n  \n  var fibonacci = (n) => {\n    if (n == 1 || n == 2) {\n      return 1;\n    } else {\n      return fibonacci(n - 2) + fibonacci(n - 1);\n    }\n  }\n  \n  var primeFib = (n) => {\n    for (var i = 1; i <= n; i++) {\n      if (isPrime(fibonacci(i)) === true) {\n        return fibonacci(i);\n      }\n    }\n  }\n  \n  return primeFib(n);\n}"
      ],
      [
        "const triplesSumToZero = (l) => {\n  let i = 0;\n  for (; i < l.length - 2; i++) {\n    let j = i + 1;\n    for (; j < l.length - 1; j++) {\n      let k = j + 1;\n      if (l[i] + l[j] === 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n};"
      ],
      [
        "const pairsSumToZero = (l) => {\n  let i = 0;\n  while(i < l.length){\n    const element = l[i];\n    const otherElements = l.slice(i + 1);\n    if (otherElements.includes(element)) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};"
      ],
      [
        "const isPalindrome = (text) => {\n  let i = 0;\n  for (; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}"
      ],
      [
        "const modp = (n, p) => {\n  var ret = 1;\n  {\n      let i = 0;\n      while(i < n){ret = (2 * ret) % p;      i++;\n      }\n  }\n  return ret;\n}"
      ],
      [
        "const largestPrimeFactor = (n) => {\n  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    {\n        let i = 2;\n        for (; i < k - 1; i++)\n          if (k % i == 0)\n            return false;\n    }\n    return true;\n  }\n  \n  var largestPrimeFactor = n;\n  for (let k = n - 1; k > 1; k--) {\n    if (isPrime(k) && k < largestPrimeFactor)\n      largestPrimeFactor = k;\n  }\n  return largestPrimeFactor;\n}"
      ],
      [
        "const smallestChange = (arr) => {\n  var ans = 0;\n  {\n      let i = 0;\n      while(i < Math.floor(arr.length / 2)){\n          if (arr[i] != arr.at(-i - 1)) {\n              ans++;\n                  i++;\n          }\n      }\n  }\n  return ans;\n};"
      ],
      [
        "const isMultiplyPrime = (a) => {\n  var isPrime = function (n) {\n    {\n        let j = 2;\n        for (; j < n; j++)\n          if (n % j == 0)\n            return false;\n    }\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n      if (isPrime(i)) {\n        for (let j = 2; j < 101; j++) {\n            if (isPrime(j)) {\n                for (let k = 2; k < 101; k++) {\n                    if (isPrime(k)) {\n                        if (i * j * k == a) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n  }\n  return false;\n}"
      ],
      [
        "const numericalLetterGrade = (grades) => {\n  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else{\n          if (gpa > 3.7) {\n          letter_grade.push('A')\n        } else{\n              if (gpa > 3.3) {\n              letter_grade.push('A-')\n            } else{\n                  if (gpa > 3.0) {\n                  letter_grade.push('B+')\n                } else{\n                      if (gpa > 2.7) {\n                  }\n                  }\n              }\n          }\n        }\n    }\n  }\n  return letter_grade\n}"
      ],
      [
        "const antiShuffle = (s) => {\n  let arr = s.split(/\\s/);\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j;\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k;\n        }\n      }\n      let temp = arr[i].charAt(j);\n      arr[i].charAt(j) = arr[i].charAt(ind);\n      arr[i].charAt(ind) = temp;\n    }\n  }\n  return arr.join(\" \");\n}"
      ],
      [
        "function encrypt(s) {\n  let t = \"\";\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4;\n    if (p > 122) {\n      p -= 26;\n      i++;\n    }\n    t += String.fromCharCode(p);\n  }\n  return t;\n}"
      ],
      [
        "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let arr = lst\n  {\n      let j = 0;\n      for (; j < arr.length; j++) {\n      let ind = j\n      {\n          let k = j + 1;\n          for (; k < arr.length; k++) {\n              if (arr[k] < arr[ind]) {\n                ind = k\n              }\n            }\n      }\n  }\n  return arr[ind]\n};\n\n// Test cases\n\n\n\n\n\nIt looks like your requirements have been fulfilled. Please let me know if you need further assistance."
      ],
      [
        "const encode = (message) => {\n  let t = \"\"\n  {\n    let i = 0;\n    while (i < message.length) {\n      let p = message[i].charCodeAt();\n      if (p > 96) {\n        p -= 32;\n        i++;\n      }\n      t += String.fromCharCode(p);\n    }\n    return t;\n  }\n}\n\n// Test cases"
      ],
      [
        "const skjkasdkd = (lst) => {\n  let t = 0\n  {\n      let i = 0;\n      for (; i < lst.length; i++) {\n      let p = 1\n      {\n          let j = 2;\n          for (; j * j <= lst[i]; j++) {\n              if (lst[i] % j == 0) { p = 0; break }\n            }\n      }\n      if (p == 1) { t += lst[i]; }\n  }\n  return t\n};"
      ],
      [
        "const countUpTo = (n) => {\n  let t = [];\n  \n  for (let i = 2; i < n; i++) {\n    let p = true;\n    \n    for (let j = 2; j * j <= i; j++) {\n      if (i % j === 0) {\n        p = false;\n        break;\n      }\n    }\n    \n    if (p) {\n      t.push(i);\n    }\n  }\n  \n  return t;\n};"
      ],
      [
        "/***************************************************\n * Given a string s, count the number of uppercase vowels in even indices.\n *\n * For example:\n * countUpper('aBCdEf') returns 1\n * countUpper('abcdefg') returns 0\n * countUpper('dBBE') returns 0\n *\n * Implemented by:\n * @author [Your name]\n * @date [Today's date]\n *\n * Based on:\n * @param {string} s The input string\n * @return {number} The number of uppercase vowels in even indices\n */\n\nconst countUpper = (s) => {\n  let p = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n      p++;\n      i += 2;\n    } else {\n      i++;\n    }\n  }\n  return p;\n};\n\n// Testing\n/**\n * Test cases:\n * 1. countUpper('aBCdEf') returns 1\n * 2. countUpper('abcdefg') returns 0\n * 3. countUpper('dBBE') returns 0\n */"
      ],
      [
        "const makeAPile = (n) => {\n  let t = [];\n  {\n    let i = n;\n    for (; i < n * 3; i += 2) {\n      t.push(i);\n    }\n    return t;\n  }\n};"
      ],
      [
        "const chooseNum = (x, y) => {\n  {\n      let i = y;\n      while(i >= x){\n    if (i % 2 == 0) {return i }\n        i--;\n      }\n  }\n  \n  return -1;\n};"
      ],
      [
        "//uniqueDigits function to return a sorted list of all elements that hasn't any even digit\nconst uniqueDigits = (x) => {\n  let p = []\n  for(let i = 0; i < x.length; i++){\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10;\n    }\n    if (boo){\n      p.push(h)\n    }\n  }\n  return p.sort((a,b) => a - b)\n}"
      ],
      [
        "const byLength = (arr) => {\n  p = []\n  {\n      let i = 0;\n      for (; i < arr.length; i++) {\n      if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n    }}}\n    for (let l = 0; l < p.length; l++) {\n      let rank = l + 1\n      let word = []\n      {\n      switch (rank) {\n            case 1:\n              word = [\"One\"]\n              break\n            case 2:\n              word = [\"Two\"]\n              break\n            case 3:\n              word = [\"Three\"]\n              break\n            case 4:\n              word = [\"Four\"]\n              break\n            case 5:\n              word = [\"Five\"]\n              break\n            case 6:\n              word = [\"Six\"]\n              break\n            case 7:\n              word = [\"Seven\"]\n              break\n            case 8:\n              word = [\"Eight\"]\n              break\n            case 9:\n              word = [\"Nine\"]\n              break\n          }\n      }\n      let finalWord = word.join(\"\")\n      p[l] = finalWord\n    }\n    return p\n}"
      ],
      [
        "const f = (n) => {\nlet i = 1;\n  for (; i <= n; i++) {\n    let factorial = 1;\n    if (i % 2 === 0) {\n      factorial = i;\n    } else {\n      factorial = i * (i - 1) / 2;\n    }\n    k.push(factorial);\n  }\n  return k;\n};"
      ],
      [
        "/*\n  Write a function countNums which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let p = 0\n  {\n      let i = 0;\n      for (; i < arr.length; i++) {\n      let h = arr[i]\n      if (h > 0) {\n          p++;\n          continue;\n      }\n  }\n  }\n}"
      ],
      [
        "const exchange = (lst1, lst2) => {\n  // Check if lst1 is empty\n  if (lst1.length === 0) {\n    return \"NO\";\n  }\n\n  // Check if lst2 is empty\n  if (lst2.length === 0) {\n    return \"NO\";\n  }\n\n  // Initialize variables\n  let k = lst1.length;\n  let t = 0;\n\n  // Loop through lst1 and count the number of even elements\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) {\n      t++;\n    }\n  }\n\n  // Check if all elements in lst1 are even\n  if (t === lst1.length) {\n    return \"YES\";\n  }\n\n  // Check if lst2 contains any odd elements\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 != 0) {\n      return \"NO\";\n    }\n  }\n\n  // If we reach this point, it means that all elements in lst1 are even,\n  // but some elements in lst2 may be odd.\n  return \"YES\";\n};"
      ],
      [
        "const histogram = (test) => {\n  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (!(t[m] in d)) {\n      d[t[m]] = 1\n    } else {\n      d[t[m]]++\n    }\n  }\n  return d\n}"
      ],
      [
        "function reverseDelete(s, c) {\n  let t = '';\n  for (let i = 0; i < s.length; i++) {\n    let y = 1;\n    {\n      let j = 0;\n      while (j < c.length) {\n        if (s[i] === c[j]) {\n          y = 0;\n        }\n        j++;\n      }\n    }\n    if (y === 1) {\n      t += s[i];\n    }\n  }\n  return [t, (t === t.split('').reverse().join(''))];\n}"
      ],
      [
        "const oddCount = (lst) => {\n  let d = [];\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length;\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j] % 2) {\n        p++;\n      }\n    }\n    d.push(p);\n  }\n  return d;\n};"
      ],
      [
        "const minSubArraySum = (nums) => {\n  let min = nums[0];\n  let i = 0;\n  while (i < nums.length) {\n    let j = i + 1;\n    let s = 0;\n    while (j <= nums.length) {\n      let k = i;\n      while (k < j) {\n        s += nums[k];\n        k++;\n      }\n      if (s < min) {\n        min = s;\n      }\n      j++;\n    }\n    i++;\n  }\n  return min;\n};"
      ],
      [
        "const maxFill = (grid, capacity) => {\n  let p = 0\n  let i = 0;\n  while(i < grid.length){\n    let m = 0\n    let j = 0;\n    while(j < grid[i].length){\n      if (grid[i][j] == 1) {\n        m++;\n        if (m > capacity) {\n          p++;\n          m = 0;\n        }\n      }\n    j++;\n    }\n    i++;\n  }\n  return p;\n}"
      ],
      [
        "This code should be included in a JavaScript file and then run to get the same results as the code I provided."
      ],
      [
        "This code was generated based on the description you provided."
      ],
      [
        "const matchParens = (lst) => {\n  let w1 = lst[0] + lst[1];\n  let y = 0;\n  let u = 1;\n  for (let i = 0; i < w1.length; i++) {\n    if (!(w1[i] == '(')) { y-- }\n    else { y++ }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (y === 0) { return 'Yes' }\n  else { return 'No' }\n}"
      ],
      [
        "/**\n * Find the maximum k numbers in an array\n * @param {Array<number>} arr The array of numbers\n * @param {number} k The number of maximum numbers to find\n * @return {number[]} The sorted list of maximum k numbers in the array\n */\nfunction maximum(arr, k) {\n\t// Check if the input is valid\n\tif (!arr || !Array.isArray(arr) || !k || k < 0 || k > arr.length) {\n\t\tthrow new Error('Invalid input');\n\t}\n\n\t// Sort the array in descending order\n\tarr.sort((a, b) => b - a);\n\n\t// Return the top k elements of the sorted array\n\treturn arr.slice(0, k);\n}"
      ],
      [
        "const addElements = (arr, k) => {\n  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] >= -100 && arr[i] <= 100) { p += arr[i]; }\n  }\n  return p;\n}"
      ],
      [
        "const getOddCollatz = (n) => {\n  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    {\n        let i = 0;\n        for (; i < p.length; i++) {\n          if (t == p[i]) {\n            u = 1\n            break;\n          }\n        }\n    }\n    if (u == 1) { break }\n    p.push(t)\n    if (t % 2 == 0) {\n      t = t / 2\n    } else {\n      t = 3 * t + 1\n    }\n  }\n  return p.filter(i => i % 2 != 0).sort((a, b) => a - b)\n}"
      ],
      [
        "Note: There is a possibility that there might be multiple minimum paths of the length k which has the same values. In that case, the solution should return all such paths."
      ],
      [
        "const isNested = (string) => {\n  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (!(string[i] == '[')) {\n      closing_bracket_index1.push(i)\n    }\n    else {\n      opening_bracket_index.push(i)\n    }\n  }\n  for (let i = 0; i < opening_bracket_index.length; i++) {\n    for (let j = opening_bracket_index[i]; j < string.length; j++) {\n      if (string[j] == ']') {\n        if (opening_bracket_index.length > 0) {\n          opening_bracket_index.pop()\n        }\n        else if (closing_bracket_index1.length > 0) {\n          closing_bracket_index1.pop()\n        }\n        return true\n      }\n    }\n  }\n  return false\n}"
      ],
      [
        "const canArrange = (arr) => {\n  if (arr.length == 0) { return -1 }\n  let i = arr.length - 1;\n  while(i > 0){\n    if (arr[i] < arr[i - 1]) { return i       i--;\n      }\n    }\n  }\n}"
      ],
      [
        "const largestSmallestIntegers = (lst) => {\n  let a = Infinity\n  let b = -Infinity\n  {\n      let i = 0;\n      while(i < lst.length){\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i]       i++;\n      }\n  }\n  {\n      let i = 0;\n      while(i < lst.length){\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i]       i++;\n      }\n  }\n  return (a, b);\n}"
      ],
      [
        "const fixSpaces = (text) => {\n  let t = '';\n  let c = 0;\n  for (let i = 0; i < text.length; i++) {\n    if (!(text[i] = ' ')) if (c > 0) {\n      if (c = 1) { t += '_'; }\n      if (c = 2) { t += '__'; }\n    else { c++; }\n  }\n  return t;\n};"
      ],
      [
        "const sumSquares = (lst) => {\n  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else{\n        if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    }\n    return y\n  }\n}"
      ],
      [
        "/*\nGiven a string representing a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words from the original sentence, whose lengths are prime numbers, the order of the words in the new string should be the same as the original one.\n\nExample 1:\nInput: sentence = \"This is a test\"\nOutput: \"is\"\n\nExample 2:\nInput: sentence = \"lets go for swimming\"\nOutput: \"go for\"\n\nConstraints:\n* 1 <= len(sentence) <= 100\n* sentence contains only letters\n*/\nconst wordsInSentence = (sentence) => {\n  let t = sentence.split(/\\s/)\n  let p = ''\n  {\n      let j = 0;\n      for (; j < t.length; j++) {\n      let len = t[j].length;\n      let u = 1\n      if (len == 1 || len == 0) { continue }\n  // Begin to write code\n  if (isPrime(len)) {\n      p += t[j] + ' '\n  }\n      }\n  return p.trim()\n};\n\n// Helper function to check if a number is prime\nconst isPrime = (n) => {\n  if (n < 2) return false;\n  for (let i = 2; i < Math.sqrt(n); i++) {\n      if (n % i === 0) return false;\n  }\n  return true;\n}"
      ],
      [
        "const orderByPoints = (nums) => {\n  let p = nums\n  {\n      let j = p.length - 2;\n      for (; j >= 0; j--) {\n        {\n            let k = 0;\n            for (; k <= j; k++) {\n                let m = 0\n                let n = 0\n                let h = p[k]\n                let d = p[k + 1]\n                let y = 1\n                let u = 1\n                if (h < 0) { y = -1; h = -h; }\n                if (d < 0) { u = -1; d = -d; }\n                m += h * y;\n                n += d * u;\n            }\n            p[k] = m;\n            p[k + 1] = n;\n            if (m > n) {\n                let tmp = m;\n                m = n;\n                n = tmp;\n            }\n        }\n      }\n      return p;\n  }"
      ],
      [
        "const specialFilter = (nums) => {\n  let p = 0\n  i = 0\n  while(i < nums.length){\n    if (nums[i] < 10) { i++;continue }\n    let y = nums[i].toString()\n    if (y[0] % 2 !== 0 || y[y.length - 1] % 2 !== 0) {\n      p++;\n    }\n    i++;\n  }\n  return p;\n};"
      ],
      [
        ""
      ],
      [
        "const bf = (planet1, planet2) => {\n  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  {\n      let i = 0;\n      for (; i < 8; i++) {\n      if (y[i] == planet1) { lo = i }\n    }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (lo < i && i < hi) {\n      u.push(y[i])\n    }\n  }\n  return u\n}"
      ],
      [
        "const sortedListSum = (lst) => {\n  let p = []\n  {\n      let i = 0;\n      for (; i < lst.length; i++) {\n      if (lst[i].length % 2 == 0) {\n        p.push(lst[i])\n      }\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n          const temp = p[k];\n          p[k] = p[k + 1];\n          p[k + 1] = temp\n      }\n    }\n  }\n  return p\n}"
      ],
      [
        "const strongestExtension = (class_name, extensions) => {\n  let u = 0\n  let s = -Infinity\n  {\n      let i = extensions.length - 1;\n      while(i >= 0){\n    let y = 0\n    {\n        let j = 0;\n        while(j < extensions[i].length){\n      let k = extensions[i][j].charCodeAt()\n      if (k > u) {\n        u = k\n      }\n      j++;\n      if (u > s) {\n        s = u\n      }\n    }\n    i--;\n  }\n}\nreturn class_name + \".\" + extensions[extensions.length - 1];\n}"
      ],
      [
        "const cycpatternCheck = (a, b) => {\n  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a.substr(i + j, k) === pat.substr(k, l)) {\n          return true\n        }\n      }\n    }\n  }\n  return false\n}"
      ],
      [
        "const findMax = (words) => {\n  if (words.length === 0) return '';\n  let maxUniqueChars = -1;\n  let maxUniqueCharsIndex = -1;\n  for (let i = 0; i < words.length; i++) {\n    const uniqueChars = new Set(words[i]).size;\n    if (uniqueChars > maxUniqueChars) {\n      maxUniqueChars = uniqueChars;\n      maxUniqueCharsIndex = i;\n    }\n  }\n  return maxUniqueCharsIndex === -1 ? '' : words[maxUniqueCharsIndex];\n}"
      ],
      [
        "const doAlgebra = (operator, operand) => {\n  while (operator.length > 0) {\n    let y = 0\n    {\n        let i = operator.length - 1;\n        for (; i >= 0; i--) {\n          if (operator[i] == '**') {\n            let u = operand[i]\n            while (operand[i + 1] > 1) {\n              operand[i + 1]--;\n              operand[i] *= u;\n            }\n            operand.splice(i + 1, 1)\n            operator.splice(i, 1)\n            y = 1;\n            break;\n          }\n        }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n      } else if (operator[i] == '/') {\n        operand[i] /= operand[i + 1]\n      } else if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n      } else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n      }\n      operand.splice(i + 1, 1)\n      operator.splice(i, 1)\n    }\n    return operand[0]\n  }\n}"
      ],
      [
        "const solve = (s) => {\n  let t = 0;\n  let p = '';\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt();\n    if (!(y >= 65 && y <= 90)) {\n      if (y >= 97 && y <= 122) {\n        y += 32;\n        t = 1;\n      } else {\n        t = 0;\n      }\n    }\n    p += String.fromCharCode(y);\n  }\n  return t === 1 ? p.split('').reverse().join('') : p;\n}"
      ]
    ],
    "variance": 0.0,
    "stddev": 0.0
  }
]