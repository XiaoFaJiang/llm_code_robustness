[
  {
    "name": {
      "name": "full_level_robustness",
      "split": "test"
    },
    "count": 65,
    "generations": [
      [
        "const hasCloseElements = (numbers, threshold) => {\n  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (j != i) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};"
      ],
      [
        "function separateParenGroups(paren_string) {\n  const result = [];\n  let current_string = '';\n  let current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c === '(') {\n      current_depth++;\n      current_string += c;\n    } else if (c === ')') {\n      current_depth--;\n      current_string += c;\n      if (current_depth === 0) {\n        result.push(current_string);\n        current_string = '';\n      }\n    }\n  }\n\n  return result;\n}"
      ],
      [
        "const belowZero = (operations) => {\n  var balance = 0;\n  for (const op of operations) {\n    balance = balance + (op);\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};"
      ],
      [
        "const intersperse = (numbers, delimeter) => {\n  if (!Array.isArray(numbers) || 0 == numbers.length)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n);\n    if (n != numbers[numbers.length - 1]) {\n      result.push(delimeter);\n    }\n  }\n  return result;\n};"
      ],
      [
        "const parseNestedParens = (paren_string) => {\n  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if ('(' == c) {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else if (')' == c) {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n\n  var list = paren_string.split(' ');\n  var result = [];\n\n  for (const s of list) {\n    result.push(parseParenGroup(s));\n  }\n\n  return result;\n}\n\n// Test the function\nlet string = '(()()) ((())) () ((())()())';\n\n// Output: [2, 3, 1, 3]"
      ],
      [
        "const filterBySubstring = (strings, substring) => {\n  return strings.filter(x => -1 != x.indexOf(substring));\n}"
      ],
      [
        "const sumProduct = (numbers, full) => {\n  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}"
      ],
      [
        "const rollingMax = (numbers) => {\n  var running_max, result = [];\n  for (const n of numbers) {\n    if (undefined == running_max)\n      running_max = n;\n    else if (n > running_max)\n      running_max = n;\n    result.push(running_max);\n  }\n  return result;\n};"
      ],
      [
        "const isPalindrome = (string) => {\n  return string.split('').reverse().join('') == string;\n}\n\nconst makePalindrome = (string) => {\n  if ('' == string)\n    return '';\n  var beginning_of_suffix = 0;\n  while (beginning_of_suffix < string.length && !isPalindrome(string.slice(beginning_of_suffix))) {\n    beginning_of_suffix++;\n  }\n  if (beginning_of_suffix == string.length) {\n    return string;\n  }\n  return string.slice(0, beginning_of_suffix) + string.slice(beginning_of_suffix).split('').reverse().join('') + string.slice(beginning_of_suffix);\n}"
      ],
      [
        "const stringXor = (a, b) => {\n  var xor = function (i, j) {\n    if (j == i)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((el, idx) => xor(el, b[idx])).join('');\n}\n\nstringXor('010', '110');"
      ],
      [
        "const longest = (strings) => {\n  if (!Array.isArray(strings) || 0 == strings.length) {\n    return null;\n  }\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length === maxlen) {\n      return s;\n    }\n  }\n  return null;\n}"
      ],
      [
        "const greatestCommonDivisor = (a, b) => {\n  while (0 != b) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}"
      ],
      [
        "const allPrefixes = (string) => {\n  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, 1 + i));\n  }\n  return result;\n}"
      ],
      [
        "// Complete code\n\nconst parseMusic = (music_string) => {\n  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => '' != x).map(x => note_map[x]);\n}"
      ],
      [
        "// Find how many times a given substring can be found in the original string. Count overlaping cases.\nconst howManyTimes = (string, substring) => {\n  var times = 0;\n  for (let i = 0; i < 1 + string.length - substring.length; i++) {\n    if (substring == string.slice(i, i+substring.length)) {\n      times += 1;\n    }\n  }\n  return times;\n}"
      ],
      [
        "const findClosestElements = (numbers) => {\n  const pairs = [];\n  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (j !== i) {\n        const a = numbers[i];\n        const b = numbers[j];\n        const distance = Math.abs(a - b);\n        if (pairs.length === 0 || distance < closestPair.distance) {\n          closestPair = {\n            number1: a,\n            number2: b,\n            distance: distance,\n          };\n        }\n      }\n    }\n  }\n  return [closestPair.number1, closestPair.number2];\n}"
      ],
      [
        "const largestDivisor = (n) => {\n  for (let i = n - 1; i >= 0; i--)\n    if (0 == n % i) return i;\n  return -1;\n};"
      ],
      [
        "/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  var fact = [], i = 2;\n  while (i <= 1 + Math.sqrt(n)) {\n    if (0 == n % i) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return fact;\n}"
      ],
      [
        "const removeDuplicates = (numbers) => {\n  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] = dict[num] + (1);\n    } else {\n      dict[num] = 1;\n    }\n  }\n  var result = [];\n  for (var key in dict) {\n    if (dict[key] === 1) {\n      result.push(key);\n    }\n  }\n  return result;\n};"
      ],
      [
        "In the `map()` function, we check if a character is uppercase or not using the `==` operator. However, this operator will return `true` only if the character is exactly the same as the uppercase version, which is not what we want. Instead, we can use the `toUpperCase()` method to get the uppercase version of the character and then compare it to the original character. If they are different, then the character should be flipped to uppercase. Here is the corrected logic:"
      ],
      [
        "const isPrime = (n) => {\n  if (n < 2) return 0;\n  for (let k=2; k<n-1; k++) {\n    if (n % k === 0) return 0;\n  }\n  return 1;\n};"
      ],
      [
        "function poly(xs, x) {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin = begin * (2.0);\n    end = end * (2.0);\n  }\n  while (end - begin > 1e-10) {\n    var current = (begin + end) / 2.0;\n    var a = poly(xs, begin);\n    var b = poly(xs, end);\n    var f = Math.pow(current, xs.length - 1);\n    if (a * b > 0) {\n      if (Math.abs(a) > Math.abs(b)) {\n        end = current;\n      } else {\n        begin = current;\n      }\n    } else {\n      if (Math.abs(b) < Math.abs(a)) {\n        end = current;\n      } else {\n        begin = current;\n      }\n    }\n  }\n  return poly(xs, current);\n}"
      ],
      [
        "const sortThird = (l) => {\n  var three = l.filter((item, index) => 0 == index % 3);\n  three.sort((a, b) => (a - b));\n  return {\n    \"0\": l[0],\n    \"1\": l[1],\n    \"2\": three[0],\n    \"3\": l[3],\n    \"4\": l[4],\n    \"5\": l[5],\n    \"6\": l[6]\n  };\n};"
      ],
      [
        "const fizzBuzz = (n) => {\n  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 === 0 || i % 13 === 0)\n      ans++;\n  return ans;\n}"
      ],
      [
        "const sortEven = (l) => {\n  var even = l.filter((item, index) => 0 == index % 2);\n  even.sort((a, b) => (a - b));\n  return l;\n}"
      ],
      [
        "const getCyclicIndex = (i, len) => {\n  return (i + len) % len;\n};\n\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((2 + s.length) / 3); i++) {\n    groups.push(s.slice(getCyclicIndex(i * 3, s.length)));\n  }\n  for (const group of groups) {\n    if (3 == group.length)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n  var groups = s.match(/(.{3})/g);\n  return groups\n   .map((g) => {\n     var res = g.split('');\n     res.push(res.shift());\n     return res.join('');\n   })\n   .join('');\n}"
      ],
      [
        "const primeFib = (n) => {\n  var isPrime = function (p) {\n    if (p < 2) return 0;\n    for (let k = 2; k <= Math.min(p - 1, Math.floor(Math.sqrt(p)) - 1); k++) {\n      if (p % k == 0) return 0;\n    }\n    return 1;\n  }\n  var seq = [0, 1];\n  for (let i = 2; i < n; i++) {\n    let nxt = seq[i - 1] + seq[i];\n    if (isPrime(nxt)) seq.push(nxt);\n  }\n  return seq[n - 1];\n};"
      ],
      [
        "const triplesSumToZero = l => {\n  for (let i = 0; i < l.length; i++)\n    for (let j = 1 + i; j < l.length; j++)\n      for (let k = 1 + j; k < l.length; k++)\n        if (l[i] + l[j] + l[k] === 0)\n          return true;\n  return false;\n}"
      ],
      [
        "const incrList = (l) => {\n  return l.map(e => 1 + e);\n}"
      ],
      [
        "const pairsSumToZero = (l) => {\n  for (let i = 0; i < l.length; i = i + 1)\n    for (let j = i + 1; j < l.length; j = j + 1)\n      if (l[i] + l[j] = 0)\n        return true;\n  return false;\n}"
      ],
      [
        "/*Given length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return h * a / 2.0;\n}"
      ],
      [
        "function fib4(n){\nconst results = [0,0,2,0];\nif(n<4)\nreturn results[n];\nfor(let i=4;i<1+n;i++){\n}\n}"
      ],
      [
        "Complete code (including all the content of the code I provided and the code you generated):\n\nconst median = (l) => {\n  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (1 == l.length % 2)\n    return l[len/2];\n  else\n    return (l[len/2-1] + l[len/2]) / 2;\n}"
      ],
      [
        "/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  for (let i = 0; i < text.length; i++)\n  if (text.at(-i-1) != text[i])\n    return false;\n  return true;\n};"
      ],
      [
        "js\n// complete code\nconst modp = (n, p) => {\n  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (ret * 2) % p;\n\n  return ret;\n}\n\n```"
      ],
      [
        "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((5 + ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((26 + ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n// Test cases"
      ],
      [
        "const belowThreshold = (l, t) => {\n  //begin to write code\n  for (const e of l) {\n    if (e >= t) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\n// Test cases"
      ],
      [
        "const sameChars = (s0, s1) => {\n  return JSON.stringify([...new Set(s1)].sort()) === JSON.stringify([...new Set(s0)].sort());\n}"
      ],
      [
        "// Complete code (including all the content of the code you provided and the code I generated)\n\n// The fib function calculates the n-th Fibonacci number\nconst fib = (n) => {\n  if (0 == n)\n    return 0;\n  if (1 == n)\n    return 1;\n  return fib(n-1) + fib(n-2);\n}\n\n// Test the fib function with n = 10\n\n\n// Test the fib function with n = 1\n\n\n// Test the fib function with n = 8"
      ],
      [
        "const correctBracketing = (brackets) => {\n  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth = depth + (1);\n    else if (b == \")\")\n      depth = depth - (1);\n    if (depth < 0)\n      return false;\n  }\n  return true;\n}"
      ],
      [
        "const monotonic = (l) => {\n  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(sort1) === JSON.stringify(l) ||\n      JSON.stringify(sort2) === JSON.stringify(l)) {\n    return true;\n  } else {\n    return false;\n  }\n};"
      ],
      [
        "const largestPrimeFactor = (n) => {\n  var isPrime = (k) => {\n    if (k < 2) return 0;\n    for (let i = 2; i < k - 1; i++) {\n      if (k % i == 0) return 0;\n    }\n  };\n\n  if (isPrime(n)) return n;\n\n  let primeFactor = 2;\n  while (n % primeFactor != 0) {\n    primeFactor++;\n  }\n  return primeFactor;\n};"
      ],
      [
        "const sumToN = (n) => {\n  return (1 + n) * n / 2;\n}"
      ],
      [
        "const correctBracketing = (brackets) => {\n  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth = depth + (1);\n    else if (b == \")\")\n      depth = depth - (1);\n    else\n      return false;\n  }\n  return depth == 0;\n};"
      ],
      [
        "js\nconst derivative = (xs) => {\n  return xs.map((x, i) => i * x);\n}\n```"
      ],
      [
        "const fibfib = (n) => {\n  if (0 == n || 1 == n)\n    return 0;\n  if (2 == n)\n    return 1;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}"
      ],
      [
        "const digitSum = (s) => {\n  if ('' == s) return 0;\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    let ord_char = s[i].charCodeAt(0);\n    if (ord_char >= 65 && ord_char <= 90) sum += ord_char;\n  }\n  return sum;\n}"
      ],
      [
        "const pluck = (arr) => {\n  if (0 == arr.length) return [];\n  var evens = arr.filter(x => 0 == x % 2);\n  if (0 == evens.length) return [];\n  const smallestEven = evens.sort((a, b) => a - b)[0];\n  return [smallestEven, arr.indexOf(smallestEven)];\n};"
      ],
      [
        "const search = (lst) => {\n  var frq = new Array(1 + Math.max(...lst)).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i <= Math.max(...lst); i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}"
      ],
      [
        "const strangeSortList = (lst) => {\n  const res = [], sw = 1;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n  }\n  return res;\n};\n\n// Additional code to test the function"
      ],
      [
        "const willItFly = (q, w) => {\n  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[j] != q[i])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}"
      ],
      [
        "bash \nconst smallestChange = (arr) => {\n    var ans = 0;\n    for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    {\n       // reassign \"at\" method here \n        if (arr[\"at\"](-i - 1) != arr[i]) {\n            ans++;\n        }\n    }\n    return ans;\n}\n```"
      ],
      [
        "const isMultiplyPrime = (a) => {\n  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return 0;\n    return 1;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (isPrime(i)) {\n      if (a % i == 0) {\n        for (let j = i + 1; j < 101; j++) {\n          if (isPrime(j)) {\n            if (a % j == 0) {\n              for (let k = j + 1; k < 101; k++) {\n                if (isPrime(k)) {\n                  if (a % k == 0) {\n                    return true;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n};"
      ],
      [
        "/*\n * Your task is to write a function that returns true if a number x is a simple power of n and false in other cases.\n * x is a simple power of n if n**long=x\n * For example:\n * isSimplePower(1, 4) => true\n * isSimplePower(2, 2) => true\n * isSimplePower(8, 2) => true\n * isSimplePower(3, 2) => false\n * isSimplePower(3, 1) => false\n * isSimplePower(5, 3) => false\n */\nconst isSimplePower = (x, n) => {\n  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power * n <= x)\n    power *= n;\n  return (x == power);\n}"
      ],
      [
        "const iscube = (a) => {\n  a = Math.abs(a);\n  return (a == Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3));\n}"
      ],
      [
        "const isHappy = (s) => {\n  if (s.length < 3)\n    return 0;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s.slice(i, i + 3) in s)\n      return false;\n  return true;\n};"
      ],
      [
        "const numericalLetterGrade = (grades) => {\n  let letter_grade = [];\n  for (let i = 0, len = grades.length; i < len; i = i + 1) {\n    let gpa = grades[i];\n    if (gpa == 4.0) {\n      letter_grade.push('A+');\n    } else if (gpa > 3.7) {\n      letter_grade.push('A');\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-');\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+');\n    } else if (gpa > 2.7) {\n      letter_grade.push('B');\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-');\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+');\n    } else if (gpa > 1.7) {\n      letter_grade.push('C');\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-');\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+');\n    } else if (gpa > 0.7) {\n      letter_grade.push('D');\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-');\n    } else {\n      letter_grade.push('E');\n    }\n  }\n  return letter_grade;\n};"
      ],
      [
        "const primeLength = (string) => {\n  let len = string.length\n  if (len == 1 || len == 0) { return 0 }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) {\n      return false\n    }\n  }\n  return true\n}"
      ],
      [
        "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n  if (1 == n) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10 + 9\n    if (t.toString().endsWith(\"1\")) {n = t}\n  }\n  return n\n}"
      ],
      [
        "// Complete the solve function below.\nconst solve = (N) => {\n  let t = 0\n  while (N > 0) {\n    t = t + (N % 10)\n    N = Math.floor(N / 10)\n  }\n  return t.toString(2)\n}"
      ],
      [
        "const add = (lst) => {\n  let t = 0\n  for (let i = 1; i < lst.length; i = i + (2)) {\n    if (lst[i] % 2 == 0) {\n      t = t + (lst[i])\n    }\n  }\n  return t\n}\n\n//Test cases\nconst testValues = [\n  {input: [4, 2, 6, 7], output: 2},\n  {input: [1, 3, 5, 7, 9], output: 25},\n  {input: [2, 4, 6, 8, 10], output: 30},\n];\n\ntestValues.forEach((test) => {\n  let output = add(test.input);\n  \n});"
      ],
      [
        "function antiShuffle(s) {\n  let arr = s.split(/\\s/);\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j;\n      for (let k = 1 + j; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k;\n        }\n      }\n      arr[i] = arr[i].substring(0, ind) + arr[i].substring(ind + 1);\n    }\n    arr[i] = arr[i].split('').sort((a, b) => a.charCodeAt() - b.charCodeAt()).join('');\n  }\n  return arr.join('');\n}"
      ],
      [
        "const getRow = (lst, x) => {\n  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (x == lst[i][j]) {\n        t.push([i, j])\n      }\n    }\n  }\n  return t.sort((a, b) => a[0] - b[0])\n    .sort((a, b) => b[1] - a[1])\n}"
      ],
      [
        "const sortArray = (array) => {\n  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = 1 + j; k < arr.length; k++) {\n      if ((1 == tot % 2 && arr[k] < arr[ind]) || (0 == tot % 2 && arr[k] > arr[ind])) {\n        let temp = arr[k]\n        arr[k] = arr[j]\n        arr[j] = temp\n      }\n    }\n  }\n  return arr\n}"
      ],
      [
        "const encrypt = (s) => {\n  let t = '';\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4;\n    if (p > 122) { p = p - (26) }\n    t += String.fromCharCode(p);\n  }\n  return t;\n}"
      ],
      [
        "const nextSmallest = (lst) => {\n  let arr = lst\n  for (let j = 0; j < arr.length; j = j + 1) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k = k + 1) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n  }\n  return ind\n};"
      ],
      [
        "const isBored = (S) => {\n  let t = 0\n  if ('I' == S[0] && ' ' == S[1]) { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if ('.' == S[i] || '!' == S[i] || '?' == S[i]) {\n      if (' ' == S[1 + i] && 'I' == S[2 + i] && ' ' == S[3 + i]) {\n        t = t + 1\n      }\n    }\n  }\n  return t\n}"
      ],
      [
        "javascript\nconst anyInt = (x, y, z) => {\n  if (0 === x % 1 && 0 === y % 1 && 0 === z % 1 && (z === x + y || y === x + z || y + z === x)) {\n    return true\n  }\n  else {\n    return false\n  }\n}\n```\nThe function `anyInt` takes three numbers as arguments, and returns `true` if one of the numbers is equal to the sum of the other two, and all numbers are integers. Otherwise, it returns `false`."
      ],
      [
        "const encode = (message) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  let t = '';\n\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt() - 97;\n    if (p >= 0 && p < 26) {\n      if (vowels.includes(message[i])) {\n        p = (p + 2) % 26;\n      }\n      // Swap case\n      p = p ^ (p >> 7);\n      t += String.fromCharCode(p + 97);\n    }\n  }\n\n  return t;\n};"
      ],
      [
        "const largestPrime = (list) => {\n  let largest = 0\n  let result = 0\n\n  for (let i = 0; i < list.length; i++) {\n    let p = 1\n\n    for (let j = 2; j * j <= list[i]; j++) {\n      if (0 == list[i] % j) {\n        p = 0\n        break\n      }\n    }\n\n    if (p && list[i] > largest) {\n      largest = list[i]\n      result = largest.toString().split('').reduce((a, b) => a + +b)\n    }\n\n  }\n  return result\n}\n\nFor example, if the input is: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]\nThe output should be: 10\n\nExplanation:\nThe largest prime number in the list is 181, and the sum of its digits is 10."
      ],
      [
        "const checkDictCase = (dict) => {\n  if (Object.keys(dict).length === 0) {\n    return false;\n  }\n  let c = 0;\n  let lo = 1;\n  let hi = 1;\n  for (let key in dict) {\n    if (typeof key !== 'string') {\n      return false;\n    }\n    c = c + 1;\n    if (key.toLowerCase() === key) {\n      lo = lo && 1;\n    } else if (key.toUpperCase() === key) {\n      hi = hi && 1;\n    } else {\n      return false;\n    }\n  }\n  return c === 0 ? false : lo === hi ? lo : false;\n}"
      ],
      [
        "/end-of-file"
      ],
      [
        "const countUpper = (s) => {\n  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if ('A' == s[i] || 'E' == s[i] || 'I' == s[i] || 'O' == s[i] || 'U' == s[i]) { p++ }\n  }\n\n  return p;\n}"
      ],
      [
        "const closestInteger = (value) => {\n  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value = value - (t) }\n  return value\n}"
      ],
      [
        "const makeAPile = (n) => {\n  let t = []\n  for (let i = n; i < 3 * n; i += 2) {\n    t.push(i)\n  }\n  return t\n}"
      ],
      [
        "/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n*/\nconst wordsString = (s) => {\n  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (' ' == s[i] || ',' == s[i]) {\n      if (0 == k) {\n        k = 1;\n        p.push(t);\n      }\n      t = '';\n    } else {\n      t += s[i];\n    }\n    if (i == s.length - 1 && 0 != k) {\n      p.push(t);\n    }\n  }\n  return p;\n}"
      ],
      [
        "const chooseNum = (x, y) => {\n  for (let i = y; i >= x; i--) {\n    if (0 == i % 2) {return i }\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\n\n-----------------------------"
      ],
      [
        "const roundedAvg = (n, m) => {\n  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (0 != k % 1) { k = (1 + n + m) / 2 }\n  return k.toString(2)\n}"
      ],
      [
        "const uniqueDigits = (x) => {\n  let p = [];\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i];\n    let boo = 1;\n    while (h > 0) {\n      let r = h % 10;\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10;\n    }\n    if (boo == 1) {\n      p.push(x[i]);\n    }\n  }\n  return p.sort((a, b) => a - b);\n};"
      ],
      [
        "const byLength = (arr) => {\n  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = 1 + j; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    p[j] = p[ind]\n  }\n  p = p.reverse()\n  for (let i = 0; i < p.length; i++) {\n    let num = p[i]\n    let name = \"\";\n    switch (num) {\n      case 1:\n        name = \"One\";\n        break;\n      case 2:\n        name = \"Two\";\n        break;\n      case 3:\n        name = \"Three\";\n        break;\n      case 4:\n        name = \"Four\";\n        break;\n      case 5:\n        name = \"Five\";\n        break;\n      case 6:\n        name = \"Six\";\n        break;\n      case 7:\n        name = \"Seven\";\n        break;\n      case 8:\n        name = \"Eight\";\n        break;\n      case 9:\n        name = \"Nine\";\n        break;\n      default:\n        name = \"\"\n    }\n    p[i] = name;\n  }\n  return p;\n}"
      ],
      [
        "const f = (n) => {\n  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i = i + 1) {\n    p = p + (i);\n    if (i % 2 === 0) {\n      f = f * i\n    } else {\n      f = f + p\n    }\n    k.push(f)\n  }\n  return k\n}"
      ],
      [
        "const evenOddPalindrome = (n) => {\n  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[k.length - j - 1] != k[j]) {\n        p = 0\n        break\n      }\n    }\n    if (p) {\n      if (i % 2 === 0) {\n        e++\n      } else {\n        o++\n      }\n    }\n  }\n  return [e, o]\n}"
      ],
      [
        "const countNums = (arr) => {\n  let p = 0\n  for (let i = 0; i < arr.length; i = i + 1) {\n    let h = arr[i]\n    if (h > 0) {\n      p = p + 1;\n      continue;\n    }\n  }\n  return p;\n}"
      ],
      [
        ""
      ],
      [
        "const exchange = (lst1, lst2) => {\n  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i = i + 1) {\n    if (lst1[i] % 2 == 0) {\n      t = t + 1\n    }\n  }\n  for (let i = 0; i < lst2.length; i = i + 1) {\n    if (lst2[i] % 2 != 0) {\n      return \"NO\"\n    }\n  }\n  if (t === lst1.length) {\n    return \"YES\"\n  }\n  return \"NO\"\n}"
      ],
      [
        "{\n  \"name\": \"histogram\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A JS module for generating histograms from text.\",\n  \"main\": \"histogram.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"Your Name\",\n  \"license\": \"MIT\"\n}"
      ],
      [
        "const reverseDelete = (s, c) => {\n  // Initialize an empty string for the result\n  let result = '';\n  \n  // Iterate over the characters in the input string s\n  for (let i = 0; i < s.length; i++) {\n    // Check if the current character is not in the check string c\n    if (c.indexOf(s[i]) === -1) {\n      // If not, add it to the result string\n      result += s[i];\n    }\n  }\n  \n  // Check if the result string is a palindrome\n  return [result, isPalindrome(result)];\n}\n\n// Function to check if a string is a palindrome\nfunction isPalindrome(str) {\n  return str === str.split('').reverse().join('');\n}"
      ],
      [
        "const oddCount = (lst) => {\n  let d = [];\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length;\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j] % 2 === 1) {\n        p++;\n      }\n    }\n    d.push(`the number of odd elements ${p} in the string ${i} of the input.`);\n  }\n  return d;\n};"
      ],
      [
        "const minSubArraySum = (nums) => {\n  let min = nums[0];\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k];\n      }\n      min = Math.min(s, min);\n    }\n  }\n  return min;\n};"
      ],
      [
        "const maxFill = (grid, capacity) => {\n  const rows = grid.length;\n  const cols = grid[0].length;\n  let p = 0;\n  for (let i = 0; i < rows; i++) {\n    let m = 0;\n    for (let j = 0; j < cols; j++) {\n      m += grid[i][j];\n    }\n    p += m > 0 ? Math.floor(m / capacity) : 0;\n  }\n  return p;\n}"
      ],
      [
        "const sortArray = (arr) => {\n  let p = arr\n  for (let j = 0; j < p.length; j = j + 1) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k = k + 1) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u = u + 1) {\n        if (w1[u] == '1') { f1 = f1 + 1 }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u = u + 1) {\n        if (w2[u] == '1') { f2 = f2 + 1 }\n      }\n      if (f1 < f2 || (f1 == f2 && p[ind] < p[k])) {\n        [p[ind], p[k]] = [p[k], p[ind]]\n      }\n    }\n  }\n  return p\n}"
      ],
      [
        "const selectWords = (s, n) => {\n  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i = i + 1) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j = j + 1) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u') {\n        l = l + 1\n      }\n      if (l == n) {\n        k.push(t[i])\n      }\n    }\n  }\n  return k\n}"
      ],
      [
        "const getClosestVowel = (word) => {\n  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !('a' != word[i] && 'e' != word[i] && 'i' != word[i] && 'o' != word[i] && 'u' != word[i] && 'A' != word[i] &&\n        'U' != word[i] && 'O' != word[i] && 'I' != word[i] && 'E' != word[i])\n      &&\n      ('a' != word[1 + i] && 'e' != word[1 + i] && 'i' != word[1 + i] && 'o' != word[1 + i] && 'u' != word[1 + i] && 'A' != word[1 + i] &&\n        'U' != word[1 + i] && 'O' != word[1 + i] && 'I' != word[1 + i] && 'E' != word[1 + i])\n    ) {\n      return word[i];\n    }\n  }\n  return \"\";\n};"
      ],
      [
        "const matchParens = lst => {\n  let w1 = lst[0] + lst[1]\n  let y = 0\n  for (let i = 0; i < w1.length; i++) {\n    if ('(' == w1[i]) { y++ }\n    else { y-- }\n    if (y < 0) {\n      return 'No'\n    }\n  }\n  return 'Yes'\n}"
      ],
      [
        "// Complete code (including all the content of the code you provided and the code you generated)\nfunction maximum(arr, k) {\n  let p = arr\n  for (let j = 0; j < p.length; j = j + 1) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k = k + 1) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    p.splice(ind, 1)\n  }\n  return p\n}"
      ],
      [
        "// Import the package for working with arrays\nimport { solution } from 'array-lib';\n\n// Define the function\nconst solution = (lst) => {\n  let p = 0;\n  for (let i = 0; i < lst.length; i += 2) {\n    if (1 === lst[i] % 2) {\n      p += lst[i];\n    }\n  }\n  return p;\n};\n\n// Test the function\nconst testArray = [30, 13, 24, 321];"
      ],
      [
        "Mightiness\n-------------------------------\nfunctionAddElements (arr, k) {\n    let p = 0\n    for (let i = 0; i < k; i = i + 1) {\n    if (arr[i] < 100 && arr[i] > -100) { p = p + (arr[i]) }\n      return p\n    }\n}\n-------------------------------"
      ],
      [
        "## const getOddCollatz = (n) => {\n  const p = []\n  let t = n\n  while (t !== 1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (p[i] === t) {\n        u = 1\n        break;\n      }\n    }\n    if (u === 1) {\n      break\n    }\n    if (t % 2 === 0) {\n      t = parseInt(t / 2)\n      p.push(t)\n    } else {\n      t = parseInt((3 * t + 1) / 2)\n      p.push(t)\n    }\n  }\n  return Array.from(new Set(p));\n};\n\nI understand this was a code writing task. I have written code that given a positive integer n, returns a sorted list that has the odd numbers in collatz sequence. Please let me know if I can further assist you."
      ],
      [
        "import { isValid } from 'date-fns';\n\nconst validDate = (date) => {\n  const [day, month, year] = date.split('-');\n  const dateObject = new Date(year, month - 1, day);\n  return isValid(dateObject);\n};"
      ],
      [
        "typescript\nfunction isSorted(lst: Array<number>): boolean {\n    let dup = 1\n    let pre = lst[0]\n    for (let i = 1; i < lst.length; i++) {\n        if (lst[i] < pre) {\n            return false\n        } else {\n            dup *= (lst[i] === pre)\n            pre = lst[i]\n        }\n\n    }\n    return dup\n}\n```"
      ],
      [
        "const prodSigns = (arr) => {\n  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s *= i < 0 ? -1 : 1\n    n *= Math.abs(arr[i])\n  }\n  return n * s\n}"
      ],
      [
        "const minPath = (grid, k) => {\n  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i = i + 1) {\n    for (let j = 0; j < grid.length; j = j + 1) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  // Begin to write code\n  const neighbors = [];\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] > 1 && grid[i][j] < grid[m][n]) {\n        neighbors.push(grid[i][j]);\n      }\n    }\n  }\n  return neighbors.sort();\n};"
      ],
      [
        "const tri = (n) => {\n  if (0 == n) { return [1] }\n  if (1 == n) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (0 == i % 2) {\n      const m = Math.floor(i / 2);\n      p.push(p[m] + p[m + 1]);\n    } else {\n      const m = i - 1;\n      p.push(p[m] + p[m + 1] + p[m + 3]);\n    }\n  }\n  return p\n}"
      ],
      [
        "const digits = (n) => {\n  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (1 == y % 2) {\n      p *= y\n    } \n    else {\n      k *= y\n    }\n    n /= 10\n  }\n  return p - k\n}"
      ],
      [
        "Complete code (including all the content of the code I provided and the code you generated)\n-----------------------------\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i = i + 1) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n    if(opening_bracket_index.length >= 2) {\n      for(let j = 0; j < opening_bracket_index.length-2; j++) {\n        if (closing_bracket_index1[j] > opening_bracket_index[j+1]) {\n          return true\n        }\n      }\n    }  \n  }\n  return false\n}"
      ],
      [
        "const sumSquares = (lst) => {\n  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (0 != y % 1) {\n      if (y > 0) { y = 1 + y - y % 1 }\n      p += y ** 2\n    } else {\n      p += y ** 2\n    }\n  }\n  return p\n}"
      ],
      [
        "const checkIfLastCharIsALetter = (txt) => {\n  let len = txt.length\n  if (len == 0) { return 0 }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    // Returns true if the last character is a letter and not a part of a word.\n    return (y >= 65 && y <= 90) || (y >= 97 && y <= 122);\n  } else {\n    // Strips the last character and checks if it is part of a word.\n    let tmp = txt.substr(0, len - 1);\n    return (y >= 65 && y <= 90) || (y >= 97 && y <= 122) && tmp.includes(\" \");\n  }\n};"
      ],
      [
        "const canArrange = (arr) => {\n  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i = i - 1) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1;\n};"
      ],
      [
        "const largestSmallestIntegers = (lst) => {\n  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < 0) {\n      a = lst[i]\n    } else if (lst[i] > 0) {\n      b = lst[i]\n    }\n  }\n  return [a, b]\n}\n\n// Examples"
      ],
      [
        "Here is the complete code that you have requested:\n\n// Complete code (including all the content of the code I provided and the code you generated)\nconst compareOne = (a, b) => {\n  let aa = Number(a)\n  if ('string' == typeof a) { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if ('string' == typeof b) { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) {\n      return a;\n  } else if (bb > aa) {\n      return b;\n  } else {\n      return null;\n  }\n}\n\n// Use the function to compare two numbers\nconst result = compareOne(5.6, 2.9);\n\n\n// Function to compare strings that may contain \",\" or \".\" as a decimal separator\nconst result2 = compareOne(\"2.3\", \"6,2\");\n\n\n// Function to compare integers\nconst result3 = compareOne(5, 3);"
      ],
      [
        "const isEqualToSumEven = (n) => {\n  return (n >= 8 && 0 == n % 2)\n}"
      ],
      [
        "const fixSpaces = (text) => {\n  let t = '';\n  let c = 0;\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c = c + 1 }\n    else if (c > 0) {\n      if (c == 1) { t = t + ('_') }\n      if (c == 2) { t = t + ('-') }\n      if (c > 2) { c = 0 }\n    }\n    else { t = t + text[i] }\n    c = 0;\n  }\n  return t;\n}"
      ],
      [
        "const fileNameCheck = (file_name) => {\n  let t = file_name.split(/\\./)\n  if (2 != t.length) { return 'No' }\n  if ('txt' != t[1] && 'dll' != t[1] && 'exe' != t[1]) { return 'No' }\n  if ('' == t[0]) { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (a < 'a'.charCodeAt() || a > 'z'.charCodeAt()) {\n    if (a < 'A'.charCodeAt() || a > 'Z'.charCodeAt()) {\n      return 'No'\n    }\n  }\n  return 'Yes'\n}"
      ],
      [
        "const sumSquares = (lst) => {\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) {\n      lst[i] *= lst[i];\n    } else if (i % 4 == 0 && i % 3 != 0) {\n      lst[i] *= lst[i] * lst[i];\n    }\n  }\n};\n\nconst lst = [1, 2, 3, 4, 5, 6, 7, 8, 9];"
      ],
      [
        "const wordsInSentence = (sentence) => {\n  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (1 == len || 0 == len) { continue }\n    if (isPrime(len)) {\n      p += t[j] + ' '\n    }\n  }\n  return p.trim()\n}\n\nfunction isPrime(num) {\n  if (num <= 1) {\n    return false\n  } else if (num <= 3) {\n    return true\n  } else {\n    let prime = false\n    for (let i = 2; i < num; i++) {\n      if (num % i == 0) {\n        prime = false\n      }\n    }\n    return prime\n  }\n}\n\n// tests"
      ],
      [
        "const simplify = (x, n) => {\n  let a = x.split(/\\//);\n  let b = n.split(/\\//);\n  let m = Number(b[0]) * Number(a[0]);\n  if (m % 1 === 0) {\n    return true;\n  } else {\n    return false;\n  }\n}"
      ],
      [
        "const orderByPoints = (numbers) => {\n  let orderedNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    orderedNumbers.push(numbers[i]);\n  }\n  for (let i = 0; i < orderedNumbers.length; i++) {\n    for (let j = i + 1; j < orderedNumbers.length; j++) {\n      let h = orderedNumbers[i];\n      let d = orderedNumbers[j];\n      let m = 0;\n      let n = 0;\n      if (h < 0) {\n        m += -h * 1000;\n      } else {\n        m += h * 1000;\n      }\n      if (d < 0) {\n        n += -d * 1000;\n      } else {\n        n += d * 1000;\n      }\n      if (m < n) {\n        let tmp = orderedNumbers[i];\n        orderedNumbers[i] = orderedNumbers[j];\n        orderedNumbers[j] = tmp;\n      }\n    }\n  }\n  return orderedNumbers;\n};"
      ],
      [
        "const specialFilter = (nums) => {\n  let p = 0\n  for (let i = 0; i < nums.length; i = i + 1) {\n    if (nums[i] < 10 || (y = nums[i].toString()).length < 2 || y[0] !== y[y.length - 1] || (y[0] % 2 + y[y.length - 1] % 2)) { continue }\n    p++\n  }\n  return p\n}"
      ],
      [
        "const getMaxTriples = (n) => {\n  let y = []\n  for (let i = 1; i <= n; i = i + 1) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (y[i] + y[j] + y[k] % 3 === 0) {\n          u++\n        }\n      }\n    }\n  }\n  return u\n}\n\n// Test case:"
      ],
      [
        "const bf = (planet1, planet2) => {\n  let y = [\n    'Mercury',\n    'Venus',\n    'Earth',\n    'Mars',\n    'Jupiter',\n    'Saturn',\n    'Uranus',\n    'Neptune'\n  ];\n  let u = [];\n  let lo = -1;\n  let hi = -1;\n  for (let i = 0; i < 8; i++) {\n    if (planet1 == y[i]) {\n      lo = i;\n    }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (planet2 == y[i]) {\n      hi = i;\n    }\n  }\n  if (lo == -1 || hi == -1) return empty_tuple;\n  for (let i = lo + 1; i < hi; i++) {\n    if (\n      (lo < i || i == lo + 1) &&\n      (hi > i || i == hi - 1)\n    ) {\n      u[u.length] = y[i];\n    }\n  }\n  return tuple(u);\n};"
      ],
      [
        "function list_sort(lst) {\n  const filteredList = [];\n  for (const word of lst) {\n    if (word.length % 2 === 0) {\n      filteredList.push(word);\n    }\n  }\n  return filteredList.sort((a, b) => a.length - b.length || a.localeCompare(b));\n}\n\nconst result = list_sort([\"aa\", \"a\", \"aaa\", \"cd\"]);"
      ],
      [
        "const xOrY = (n, x, y) => {\n  let len = n\n  if (1 == len || 0 == len) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}"
      ],
      [
        "const doubleTheDifference = (lst) => {\n  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (1 == lst[i] % 2 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p;\n};\n\n-----------------------------"
      ],
      [
        "const compare = (game, guess) => {\n    for (let i = 0; i < guess.length; i++) {\n        game[i] = game[i] - (guess[i]);\n        if (game[i] < 0) {\n            game[i] = Math.abs(game[i]);\n        }\n    }\n    return game;\n};"
      ],
      [
        "/* You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n*/\nconst strongestExtension = (class_name, extensions) => {\n  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i = i - 1) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j = j + 1) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) {\n        u += (k - 64) * (k - 64)\n      }\n      if (k >= 97 && k <= 122) {\n        s += (k - 96) * (k - 96)\n      }\n    }\n    if (u > s) {\n      return `${class_name}.${extensions[i]}`\n    }\n  }\n}"
      ],
      [
        "function cycpatternCheck (a, b) {\n  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i = i + 1) {\n    for (let j = 0; j < l + 1; j = j + 1) {\n      let y = 1\n      for (let k = 0; k < l; k = k + 1) {\n        y = (y && a.charAt(i + k) == pat.charAt(j + k))\n      }\n      if (y) return true\n    }\n  }\n  return false\n}\n/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */"
      ],
      [
        "const rightAngleTriangle = (a, b, c) => {\n  return (c * c == a * a + b * b || b * b + c * c == a * a || a * a + c * c == b * b);\n};"
      ],
      [
        "const findMax = (words) => {\n  let max = -1;\n  let res = '';\n  for (let i = 0; i < words.length; i++) {\n    let u = -1;\n    for (let j = 0; j < words[i].length; j++) {\n      let p = 0;\n      for (let k = 0; k < words[i].length; k++) {\n        if (words[i][j] != words[i][k]) {\n          p++;\n        }\n      }\n      if (max == -1 || max < p) {\n        max = p;\n        res = words[i];\n      } else if (max == p && res > words[i]) {\n        res = words[i];\n      }\n    }\n  }\n  return res;\n}"
      ],
      [
        "const doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operator.length; i++) {\n    if (operator[i] === \"+\") {\n      result += operand[i];\n    } else if (operator[i] === \"-\") {\n      result -= operand[i];\n    } else if (operator[i] === \"*\") {\n      result *= operand[i];\n    } else if (operator[1] === \"//\") {\n      result = Math.floor(result / operand[i]);\n    } else if (operator[1] === \"**\") {\n      result = Math.pow(result, operand[i]);\n    }\n  }\n  return result;\n};"
      ],
      [
        "const solve = (s) => {\n  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i = i + 1) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y = y + (32);\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y = y - (32);\n      t = 1;\n    }\n    p = p + String.fromCharCode(y);\n  }\n  if (!t) {\n    p = p.split('').reverse().join('');\n  }\n  return p;\n}"
      ],
      [
        "Complete code (including all the content of the code I provided and the code you generated)\n\nfunction toMD5(text) {\n  if (!text) return null;\n\n  const md5 = require('js-md5');\n\n  return md5.md5(text);\n}\n\nmodule.exports = toMD5;"
      ]
    ],
    "variance": 0.0,
    "stddev": 0.0
  }
]