[["const hasCloseElements = (numbers, threshold) => {\n  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n"], ["  if (current_depth == 0 && current_string.length > 0) {\n    result.push(current_string.join(''));\n    current_string = [];\n  }\n  if (c == ')') {\n    current_depth -= 1;\n    current_string.push(c);\n  }\n}\n\nreturn result;\n}\n"], ["const truncateNumber = (number) => {\n  return number - Math.floor(number);\n}\n"], ["const belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n"], ["const meanAbsoluteDeviation = (numbers) => {\n  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n};\n\n\n"], ["const intersperse = (numbers, delimeter) => {\n  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n\n  var result = [];\n  for (const n of numbers) {\n    result.push(n);\n    if (n !== numbers[numbers.length - 1]) {\n      result.push(delimeter);\n    }\n  }\n\n  return result;\n};\n"], ["const parseNestedParens = (paren_string) => {\n  return paren_string.split(' ')\n                     .map(parseParenGroup)\n                     .filter(n => n > 0);\n};\n\nconst parseParenGroup = function (s) {\n  let depth = 0, max_depth = 0;\n  for (const c of s) {\n    if (c == '(') {\n      depth += 1;\n      max_depth = Math.max(max_depth, depth);\n    } else if (c == ')') {\n      depth -= 1;\n    }\n  }\n  return max_depth;\n};\n"], ["const filterBySubstring = (strings, substring) => {\n  return strings.filter(x => x.indexOf(substring) != -1);\n}\n"], ["const sumProduct = (numbers) => {\n  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return (sum_value, prod_value);\n}\n"], ["const rollingMax = (numbers) => {\n  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    if (n > running_max) {\n      running_max = n;\n    }\n    result.push(running_max);\n  }\n  return result;\n}"], ["/* Test if given string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  if (string == '')\n    return '';\n\n  var beginning_of_suffix = 0;\n  \n  // Find the longest postfix of supplied string that is a palindrome.\n  for (var i = string.length; i > 0; i--) {\n    if (isPalindrome(string.substring(i-1, string.length))) {\n      beginning_of_suffix = i-1;\n      break;\n    }\n  }\n  \n  // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  return string.substring(0, beginning_of_suffix) + string.substring(beginning_of_suffix).split('').reverse().join('');\n}\n\n"], ["const stringXor = (a, b) => {\n    let result = '';\n    for(let i = 0; i < a.length; i++) {\n        result += a[i] === b[i] ? '0' : '1';\n    }\n    return result;\n}\n"], ["const longest = (strings) => {\n  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen)\n      return s;\n  }\n  return null;\n}\n"], ["const greatestCommonDivisor = (a, b) => {\n  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n};\n"], ["/**\n * @param {string} string - The input string\n * @returns {string[]} - An array of all prefixes of the input string\n */\n\nconst allPrefixes = (string) => {\n  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n};\n\n// examples usage:\n\n\n"], ["const stringSequence = (n) => {\n  return [...Array(n).keys(), n].join(' ')\n}\n"], ["const countDistinctCharacters = (string) => {\n  return (new Set(string.toLowerCase())).size;\n}\n"], ["const parseMusic = (music_string) => {\n  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n"], ["const howManyTimes = (string, substring) => {\n  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n"], ["  'six': 6,\n  'seven': 7,\n  'eight': 8,\n  'nine': 9\n};\n\nconst sortNumbers = (numbers) => {\n  // split the input string into an array of numbers\n  const numArray = numbers.split(' ');\n\n  // map the numbers from their string representations to their integer values\n  const intArray = numArray.map(numStr => value_map[numStr]);\n\n  // sort the array of integers\n  intArray.sort((a, b) => a - b);\n\n  // map the sorted integers back to their string representations\n  const sortedNumArray = intArray.map(num => Object.keys(value_map).find(key => value_map[key] === num));\n\n  // join the array of sorted string representations into a single string\n  return sortedNumArray.join(' ');\n}\n"], ["const findClosestElements = (numbers) => {\n    var closest_pair, distance;\n    for (let i = 0; i < numbers.length; i++) {\n        for (let j = 0; j < numbers.length; j++) {\n            if (i != j) {\n                let a = numbers[i], b = numbers[j];\n                if (distance == null) {\n                    distance = Math.abs(a - b);\n                    closest_pair = [a, b];\n                } else {\n                    let new_distance = Math.abs(a - b);\n                    if (new_distance < distance) {\n                        distance = new_distance;\n                        closest_pair = [a, b].sort((x, y) => x - y);\n                    }\n                }\n            }\n        }\n    }\n    return closest_pair;\n}\n"], ["const rescaleToUnit = (numbers) => {\n  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  \n  return numbers.map((number) => (number - min_number) / (max_number - min_number));\n}\n"], ["const filterIntegers = (values) => {\n  return values.filter(x => Number.isInteger(x));\n}\n"], ["const strlen = (string) => {\n  return string.length;\n}\n"], ["const largestDivisor = (n) => {\n  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}"], ["const factorize = (n) => {\n  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  if (n > 1) {\n    fact.push(n);\n  }\n  return fact;\n};\n"], ["Complete code:\nconst removeDuplicates = (numbers) => {\n  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter((num) => dict[num] === 1);\n}\n"], ["const flipCase = (string) => {\n    return string.split('')\n              .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n              .join('')\n};\n"], ["const concatenate = (strings) => {\n  return strings.join('');\n};\n"], ["const filterByPrefix = (strings, prefix) => {\n  return strings.filter(x => x.startsWith(prefix));\n}\n"], ["const getPositive = (l) => {\n  return l.filter(e => e > 0);\n}\n"], ["/**\n * Check if a number is prime\n * @param {number} n\n * @return {boolean} If the number is prime, return true; otherwise, return false\n * @example\n * isPrime(6); // false\n * isPrime(101); // true\n * isPrime(11); // true\n * isPrime(13441); // true\n * isPrime(61); // true\n * isPrime(4); // false\n * isPrime(1); // false\n */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  for (let k = 2; k < n - 1; k++) {\n    if (n % k === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n"], ["const poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    var mid = (begin + end) / 2.0;\n    if (poly(xs, mid) * poly(xs, begin) > 0) {\n      begin = mid;\n    } else {\n      end = mid;\n    }\n  }\n  return begin;\n}\n\n"], [""], ["const unique = (l) => {\n  return Array\n.from(new Set(l)).sort((a, b) => (a - b));\n}\n"], ["//Return maximum element in the list.\n// >>> maxElement([1, 2, 3])\n// 3\n// >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n// 123\nconst maxElement = (l) => {\n  return Math.max(...l);\n}\n"], ["const fizzBuzz = (n) => {\n  var ns = [];\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i.toString());\n  var str = ns.join('');\n  var count = 0;\n  for (let i = 0; i < str.length; i++)\n    if (str[i] == '7')\n      count++;\n  return count;\n};\n"], ["const sortEven = (l) => {\n  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n\n  for (var i = 1; i < l.length; i += 2) {\n    l[i] = even[i / 2];\n  }\n\n  return l;\n}\n"], ["const encodeCyclic = (s) => {\n  // Create groups of three characters\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  // Cycle groups of three characters\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  // Join groups to create final string\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n  // Decode string by applying encode_cyclic twice\n  return encodeCyclic(encodeCyclic(s));\n}\n"], ["complete code:\n  return true;\n  }\n\n  const getFib = (n) => {\n    var arr = [0, 1];\n    for (let i = 2; i < n; i++) {\n      arr[i] = arr[i - 1] + arr[i - 2];\n    }\n    return arr[n - 1];\n  };\n\n  const primeFib = (n) => {\n    var count = 0;\n    var fibNum = 1;\n    while (count < n) {\n      if (isPrime(getFib(fibNum))) {\n        count++;\n      }\n      fibNum++;\n    }\n    return getFib(fibNum - 1);\n  };\n}\n"], ["const triplesSumToZero = (l) => {\n  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] === 0) {\n          return true;\n        }\n  return false;\n}\n"], ["//Imagine a road that's a perfectly straight infinitely long line.\n//n cars are driving left to right;  simultaneously, a different set of n cars\n//are driving right to left.   The two sets of cars start out being very far from\n//each other.  All cars move in the same speed.  Two cars are said to collide\n//when a car that's moving left to right hits a car that's moving right to left.\n//However, the cars are infinitely sturdy and strong; as a result, they continue moving\n//in their trajectory as if they did not collide.\n//\n//This function outputs the number of such collisions.\nconst carRaceCollision = (n) => {\n  return Math.pow(n, 2);\n}\n\n"], ["const incrList = (l) => {\n  return l.map(e => e + 1);\n}\n"], ["/**\n  * pairsSumToZero takes a list of integers as an input.\n  * It returns true if there are two distinct elements in the list that\n  * sum to zero, and false otherwise.\n  */\n\nconst pairsSumToZero = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nmodule.exports = pairsSumToZero;\n"], ["const changeBase = (x, base) => {\n  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret || \"0\";\n};\n"], ["const triangleArea = (a, h) => {\n  return a * h / 2.0;\n}\n"], ["const fib4 = (n) => {\n  let current = 2;\n  let previous = 0;\n  let prevPrev = 0;\n  let prevPrevPrev = 0;\n\n  for(let i = 4; i < n + 1; i++) {\n    current = (prevPrevPrev + prevPrev + current + previous) % 1000000007;\n    previous = prevPrevPrev;\n    prevPrev = prevPrev;\n    prevPrevPrev = current;\n  }\n  return current;\n}\n"], ["const median = (l) => {\n  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2;\n};\n"], ["const isPalindrome = (text) => {\n  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n"], ["const modp = (n, p) => {\n  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n"], ["const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n"], ["const removeVowels = (text) => {\n  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase()))\n             .join(\"\");\n}\n\n\n\n\n\n\n\n"], ["const belowThreshold = (l, t) => {\n  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n};\n"], ["const add = (x, y) => {\n  return x + y;\n}\n"], ["function sameChars(s0, s1) {\n  const set0 = new Set(s0);\n  const set1 = new Set(s1);\n  const sortedSet0 = [...set0].sort().join('');\n  const sortedSet1 = [...set1].sort().join('');\n  return sortedSet0 === sortedSet1;\n}\n"], ["const fib = (n) => {\n    if (n <= 1)\n      return n;\n    if (n == 2)\n      return 1;\n    else\n      return fib(n - 1) + fib(n - 2);\n}\n"], ["const correctBracketing = (brackets) => {\n  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else if (b == \">\")\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth === 0;\n};\n"], ["const monotonic = (l) => {\n  return l.slice(1).every((el, i) => el >= l[i]); // increasing\n} || l.slice(1).every((el, i) => el <= l[i]); // decreasing\n};\n\n\n\n\n"], ["const common = (l1, l2) => {\n  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n\n  return Array.from(ret).sort();\n};\n"], ["const largestPrimeFactor = (n) => {\n    var isPrime = function (k) {\n        if (k < 2)\n            return false;\n        for (let i = 2; i < k - 1; i++)\n            if (k % i == 0)\n                return false;\n        return true;\n    }\n\n    for (let i = 2; i < n - 1; i++) {\n        if (n % i == 0 && isPrime(i)) {\n            let t = n / i;\n            if (isPrime(t))\n                return t;\n        }\n    }\n    return n;\n}\n"], ["const sumToN = (n) => {\n  return n * (n + 1) / 2;\n}\n"], ["// The depth of bracket counter\nlet depth = 0;\n\nfor (const b of brackets) {\n    if (b === \"(\") {\n        depth += 1;\n    } else if (b === \")\") {\n        depth -= 1;\n        if (depth < 0) {\n            return false;\n        }\n    }\n}\n\nreturn depth === 0;\n"], ["// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n//  Return derivative of this polynomial in the same form.\nconst derivative = (xs) => {\n  return xs.map((x, i) => x * i).slice(1);\n}\n"], ["const fibfib = (n) => {\n  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  \n  let a = 0, b = 0, c = 1, d = 0;\n  for(let i = 3; i <= n; i++) {\n    d = a + b + c;\n    a = b;\n    b = c;\n    c = d;\n  }\n  \n  return d;\n}\n"], ["const vowelsCount = (s) => {\n  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n\n  // check if 'y' is at the end of the string and is a vowel\n  if (s.endsWith('y') || s.endsWith('Y')) {\n    n_vowels++;\n  }\n\n  return n_vowels;\n};\n"], ["const circularShift = (x, shift) => {\n  let s = x.toString();\n  let len = s.length;\n  if (shift > len) {\n    return s.split('').reverse().join('');\n  } else {\n    shift %= len; // In case shift > len\n    return s.substring(len - shift) + s.substring(0, len - shift);\n  }\n};\n"], ["const digitSum = (s) => {\n  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    if (ord_char >= 65 && ord_char <= 90) {\n      return prev + ord_char;\n    } else {\n      return prev;\n    }\n  }, 0);\n};\n"], ["const fruitDistribution = (s, n) => {\n  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i)) lis.push(Number(i));\n  return n - lis[0] - lis[1];\n};\n"], ["const pluck = (arr) => {\n  let smallest = Number.MAX_VALUE;\n  let index = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0 && arr[i] < smallest) {\n      smallest = arr[i];\n      index = i;\n    }\n  }\n  if (smallest === Number.MAX_VALUE) return [];\n  return [smallest, index];\n}\n"], ["const search = (lst) => {\n  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (var i = frq.length - 1; i >= 0; i--) {\n    if (i <= frq[i])\n      ans = i;\n  }\n  return ans;\n}\n"], ["const strangeSortList = (lst) => {\n  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n};\n"], ["const triangleArea = (a, b, c) => {\n  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  return Math.sqrt(s * (s - a) * (s - b) * (s - c)).toFixed(2);\n};\n"], ["const willItFly = (q, w) => {\n  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n"], ["const smallestChange = (arr) => {\n  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n"], ["const totalMatch = (lst1, lst2) => {\n  let l1 = lst1.reduce((prev, item) => prev + item.length, 0);\n  let l2 = lst2.reduce((prev, item) => prev + item.length, 0);\n  return l1 <= l2 ? lst1 : lst2;\n}\n"], ["const isMultiplyPrime = (a) => {\n  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  let count = 0;\n  for (let i = 2; i < 101; i++) {\n    if (a % i === 0 && isPrime(i)) {\n      count++;\n      a /= i;\n    }\n    if (count > 3) {\n      return false;\n    }\n  }\n  return count === 3 && a === 1;\n}\n"], ["const isSimplePower = (x, n) => {\n  // Edge case: x or n can't be 0\n  if (x === 0 || n === 0)\n    return false;\n\n  // Edge case: x must be equal to 1 if n is 1\n  if (n === 1)\n    return x === 1;\n\n  let power = Math.pow(n, 1);\n  // Case where n is greater than 1\n  while (power < x) {\n    power = Math.pow(n, ++power);\n  }\n  return power === x;\n};\n"], ["const iscube = (a) => {\n  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n"], [""], ["const decimalToBinary = (decimal) => {\n  return \"db\" + decimal.toString(2) + \"db\";\n}\n"], ["/**\n * Check if a string is happy\n * @param {string} s - The string to check\n * @return {boolean} - true if the string is happy, false otherwise\n */\n\nconst isHappy = (s) => {\n  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++) {\n    if (s[i] === s[i+1] || s[i] === s[i+2] || s[i+1] === s[i+2]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n"], ["const numericalLetterGrade = (grades) => {\n  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n"], ["const primeLength = (string) => {\n  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n"], ["  }\n  return Math.floor(t / 9)\n};\n\n"], ["const solve = (N) => {\n    // Convert N to a string to easily iterate over its digits\n    let str = N.toString();\n    \n    // Initialize a variable to store the sum of the digits\n    let sum = 0;\n    \n    // Iterate over each digit in the string and add it to the sum\n    for (let i = 0; i < str.length; i++) {\n        sum += parseInt(str[i]);\n    }\n    \n    // Convert the sum to a binary string and return it\n    return sum.toString(2);\n}\n\n"], ["const add = (lst) => {\n    let total = 0;\n    for(let i = 1; i < lst.length; i+=2){\n        if(lst[i] % 2 === 0){\n            total += lst[i];\n        }\n    }\n    return total;\n}\n"], ["    if (ind !== j) {\n      arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1)\n      j-- // decrement j to check the newly swapped character\n    }\n  }\n  return arr.join(' ')\n}\n"], ["const getRow = (lst, x) => {\n    let t = []\n    for (let i = 0; i < lst.length; i++) {\n        for (let j = lst[i].length - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                t.push([i, j])\n            }\n        }\n    }\n    t.sort((a, b) => a[0] - b[0] || b[1] - a[1])\n    return t\n}\n"], ["const sortArray = (arr) => {\n  if (arr.length === 0) {\n    return [];\n  } else if (arr.length === 1) {\n    return arr;\n  }\n\n  let tempArr = [...arr];\n  const sum = tempArr[0] + tempArr[tempArr.length - 1];\n\n  if (sum % 2 === 1) {\n    tempArr.sort((a, b) => a - b);\n  } else {\n    tempArr.sort((a, b) => b - a);\n  }\n\n  return tempArr;\n}\n"], ["// Complete code\nconst encrypt = (s) => {\n  let t = '';\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4;\n    if (p > 122) {\n      p -= 26;\n    }\n    t += String.fromCharCode(p);\n  }\n  return t;\n}\n"], ["/**\n * Finds the second smallest element in an array of integers.\n * @param {number[]} arr - The array of integers.\n * @returns {number|null} - The second smallest element or null if not found.\n */\nconst nextSmallest = (arr) => {\n  if (!arr || arr.length <= 1) {\n    return null;\n  }\n\n  let min = arr[0];\n  let secondMin = Infinity;\n\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      secondMin = min;\n      min = arr[i];\n    } else if (arr[i] < secondMin && arr[i] !== min) {\n      secondMin = arr[i];\n    }\n  }\n\n  return secondMin === Infinity ? null : secondMin;\n};\n\n// Test cases\n\n\n\n\n"], [""], ["const anyInt = (x, y, z) => {\n  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n"], ["const encode = (message) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  let encodedMessage = '';\n\n  for (let i = 0; i < message.length; i++) {\n    const char = message[i].toLowerCase();\n    if (char.match(/[a-z]/i)) {\n      let newChar = char;\n      if (vowels.includes(char)) {\n        const newIndex = (vowels.indexOf(char) + 2) % vowels.length;\n        newChar = vowels[newIndex];\n      }\n      encodedMessage += (char === char.toUpperCase() ? newChar.toLowerCase() : newChar.toUpperCase());\n    } else {\n      encodedMessage += char;\n    }\n  }\n\n  return encodedMessage;\n};\n\n"], ["``javascript\nconst findMaxPrimeDigitSum = (lst) => {\n  let maxPrime = 0;\n  \n  for (let num of lst) {\n    let isPrime = true;\n    \n    if (num <= 1) {\n      isPrime = false;\n    } else if (num <= 3) {\n      isPrime = true;\n    } else if (num % 2 === 0 || num % 3 === 0) {\n      isPrime = false;\n    } else {\n      for (let i = 5; i * i <= num; i += 6) {\n        if (num % i === 0 || num % (i + 2) === 0) {\n          isPrime = false;\n          break;\n        }\n      }\n    }\n    \n    if (isPrime && num > maxPrime) {\n      maxPrime = num;\n    }\n  }\n  \n  if (maxPrime === 0) {\n    return 0; // No prime numbers found\n  }\n  \n  let sum = 0;\n  while (maxPrime > 0) {\n    sum += maxPrime % 10;\n    maxPrime = Math.floor(maxPrime / 10);\n  }\n  \n  return sum;\n};\n\n// Test cases\n\n\n\n"], ["  }\n  return lo * hi > c - 1 ? true : false\n}\n"], ["const isPrime = (num) => {\n  for (let i = 2, sqrt = Math.sqrt(num); i <= sqrt; i++)\n    if (num % i === 0) return false;\n  return num > 1;\n};\n\nconst countUpTo = (n) => {\n  let result = [];\n  for (let i = 2; i < n; i++) {\n    if (isPrime(i)) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n// Test the function with the provided examples\n\n\n\n\n\n\n"], ["// get the unit digit of a number\nconst getUnitDigit = (num) => {\n  return Math.abs(num) % 10;\n}\n\n// complete the function to multiply the unit digits of two numbers\nconst multiply = (a, b) => {\n  return getUnitDigit(a) * getUnitDigit(b);\n}\n\n"], ["const countUpper = (s) => {\n  let p = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      p++;\n    }\n  }\n  return p;\n};\n"], ["const closestInteger = (value) => {\n  // Convert the string value to a number\n  let num = Number(value);\n\n  // Get the decimal part of the number\n  let decimal = num % 1;\n\n  // Determine whether to round up or down based on the decimal part\n  if (decimal < 0.5 && decimal > -0.5) {\n    num += Math.sign(num) * 0.5;\n  }\n\n  // Return the rounded number as an integer\n  return Math.round(num);\n};\n"], ["const makeAPile = (n) => {\n  let t = [];\n  let currentStones = n;\n  for (let i = 0; i < n; i++) {\n    t.push(currentStones);\n    // Determine the next number of stones based on the current level's count\n    currentStones += (currentStones % 2 === 0) ? 2 : 2;\n  }\n  return t;\n};\n\n// Test the function with the provided example\n\n"], ["const wordsString = (s) => {\n  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n      } else {\n        k = 0;\n      }\n      if (s[i] == ' ') t = '';\n    } else {\n      t += s[i];\n    }\n  }\n  p.push(t);\n  return p;\n};\n"], ["//This function takes two positive numbers x and y and returns the\n//biggest even integer number that is in the range [x, y] inclusive. If\n//there's no such number, then the function should return -1.\n//\n//For example:\n//chooseNum(12, 15) = 14\n//chooseNum(13, 12) = -1\nconst chooseNum = (x, y) => {\n  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n"], ["const roundedAvg = (n, m) => {\n  if (n > m) { return -1 }\n  let k = Math.round((n + m) / 2)\n  return \"0b\" + k.toString(2)\n}\n"], ["  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if(boo == 1)\n      p.push(x[i])\n  }\n  p.sort(function(a, b){return a - b})\n  return p\n}\n"], ["const byLength = (arr) => {\n  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    let temp = p[j]\n    p[j] = p[ind]\n    p[ind] = temp\n  }\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  let ans = []\n  for (let m = 0; m < p.length; m++) {\n    let word = names[p[m] - 1]\n    ans.push(word)\n  }\n  return ans.reverse()\n}\n"], ["const f = (n) => {\n  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      for (let j = 2; j <= i; j++) {\n        f *= j\n      }\n      k.push(f)\n      f = 1\n    } else {\n      p += i\n      k.push(p)\n      p = 0\n    }\n  }\n  return k\n}\n"], ["/**\n * Given a positive integer n, return a tuple that has the number of even and odd\n * integer palindromes that fall within the range(1, n), inclusive.\n * @param {number} n - A positive integer\n * @return {Array} A tuple of two numbers, where the first number is the count of even palindromes, and the second number is the count of odd palindromes.\n */\n\nconst evenOddPalindrome = (n) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 1; i <= n; i++) {\n    let str = i.toString();\n    if (str === str.split('').reverse().join('')) {\n      if (i % 2 === 0) {\n        evenCount++;\n      } else {\n        oddCount++;\n      }\n    }\n  }\n  return [evenCount, oddCount];\n};\n\nmodule.exports = evenOddPalindrome;\n"], ["const countNums = (arr) => {\n  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n\n    let sum = 0;\n    let strNum = Math.abs(h).toString();\n    for (let j = 0; j < strNum.length; j++) {\n      sum += parseInt(strNum[j]);\n    }\n\n    if (sum > 0) {\n      p++;\n    }\n  }\n  return p;\n};\n"], ["const moveOneBall = (arr) => {\n  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n      }\n    }\n    if (t == 1) {\n      k++;\n    }\n    if (k == len) {\n      return true;\n    }\n    if (k > 1) {\n      return false;\n    }\n    for (let p = len - 1; p > 0; p--) {\n      let tmp = arr[p];\n      arr[p] = arr[p - 1];\n      arr[p - 1] = tmp;\n    }\n  }\n  return false;\n}\n"], ["const exchange = (lst1, lst2) => {\n  if (lst1.length === lst2.length) {\n    return \"YES\";\n  }\n  \n  let oddCountLst1 = lst1.filter(num => num % 2 !== 0).length;\n  let evenCountLst2 = lst2.filter(num => num % 2 === 0).length;\n  \n  if (oddCountLst1 <= evenCountLst2) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n};\n"], ["Complete code\nfunction histogram(test) {\n  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  let maxCount = Math.max(...Object.values(d));\n  let result = Object.entries(d).reduce((acc, [key, value]) => {\n    if (value === maxCount) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n  return result;\n}\n"], ["const reverseDelete = (s, c) => {\n  let t = '';\n  for (let i = 0; i < s.length; i++) {\n    let y = 1;\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] === c[j]) {\n        y = 0;\n      }\n    }\n    if (y === 1) {\n      t += s[i];\n    }\n  }\n\n  let reversed = t.split('').reverse().join('');\n  let isPalindrome = t === reversed;\n\n  return [t, isPalindrome];\n}\n"], ["const oddCount = (lst) => {\n  let d = []\n\n\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j] % 2 !== 0) {\n        p++\n      }\n    }\n    d.push(`the number of odd elements ${p}n the str${p}ng ${p} of the ${p}nput.`);\n  }\n  return d;\n}\n"], ["const minSubArraySum = (nums) => {\n  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n        if (s < min) {\n          min = s\n        }\n      }\n    }\n  }\n  return min\n}\n"], ["function maxFill(grid, capacity) {\n  let count = 0;\n  let totalWater = 0;\n\n  // Count the total amount of water in the wells\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) {\n        totalWater++;\n      }\n    }\n  }\n\n  // Calculate the minimum number of times the buckets need to be lowered\n  while (totalWater > 0) {\n    for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; j < grid[i].length; j++) {\n        if (grid[i][j] == 1) {\n          grid[i][j] = 0; // Water is extracted\n          totalWater--;\n          if (totalWater == 0) {\n            count++; // Increment count when all water is extracted\n            return count;\n          }\n        }\n      }\n    }\n    count++; // Increment count for each bucket lowered\n  }\n  return count;\n}\n"], ["const sortArray = (arr) => {\n    return arr.sort((a, b) => {\n        let bitCountA = a.toString(2).split('0').join('').length;\n        let bitCountB = b.toString(2).split('0').join('').length;\n        if (bitCountA === bitCountB) {\n            return a - b;\n        } else {\n            return bitCountA - bitCountB;\n        }\n    });\n}"], ["/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\n\nconst selectWords = (s, n) => {\n  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if(/[bcdfghjklmnpqrstvwxyz]/i.test(t[i][j])) { l++ }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}"], ["const getClosestVowel = (word) => {\n  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n    ) {\n      return word[i];\n    }\n  }\n  return \"\";\n};"], ["/**\n * @param {string[]} lst\n * @return {string}\n */\nconst matchParens = (lst) => {\n  const possibleStrings = [];\n  \n  for (let i = 0; i < lst.length; i++) {\n    for (let j = 0; j < lst.length; j++) {\n      if (i !== j) {\n        possibleStrings.push(lst[i] + lst[j]);\n      }\n    }\n  }\n\n  for (let i = 0; i < possibleStrings.length; i++) {\n    let balance = 0;\n    for (let j = 0; j < possibleStrings[i].length; j++) {\n      if (possibleStrings[i][j] === \"(\") {\n        balance += 1;\n      } else {\n        balance -= 1;\n      }\n      if (balance < 0) {\n        break;\n      }\n    }\n    if (balance === 0) {\n      return \"Yes\";\n    }\n  }\n  \n  return \"No\";\n};\n\n// Tests\n\n\n"], ["const maximum = (arr, k) => {\n  let p = arr.slice().sort((a, b) => b - a);\n  return p.slice(0, k);\n};\n"], ["const solution = (lst) => {\n  let p = 0;\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 === 1) {\n      p += lst[i];\n    }\n  }\n  return p;\n};\n"], ["const addElements = (arr, k) => {\n  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n"], ["const getOddCollatz = (n) => {\n  let p = [1];\n  let t = n;\n  while (true) {\n    t = t % 2 == 0 ? t / 2 : 3 * t + 1;\n    let u = 0;\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1;\n        break;\n      }\n    }\n    if (u == 1) { break; }\n    if (t % 2 !== 0) { p.push(t); }\n  }\n  p.sort((a, b) => a - b);\n  return p;\n};\n\n\n\n"], ["const validDate = (date) => {\n  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  let thirtyOneDayMonths = ['01', '03', '05', '07', '08', '10', '12'];\n  let thirtyDayMonths = ['04', '06', '09', '11'];\n  if (thirtyOneDayMonths.includes(t[0]) && t[1] > 31) { return false }\n  if (thirtyDayMonths.includes(t[0]) && t[1] > 30) { return false }\n  if (t[0] == '02' && t[1] > 29) { return false }\n  return true\n}\n\n\n\n\n\n\n"], ["const splitWords = (txt) => {\n  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let count = 0;\n      for(let i = 0; i < txt.length; i++){\n        let asciiValue = txt.charCodeAt(i);\n        if(asciiValue > 96 && asciiValue < 123 && (asciiValue - 96) % 2 === 1){\n          count++;\n        }\n      }\n      return count;\n    }\n  }\n}\n"], ["const isSorted = (lst) => {\n  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup++\n      if (dup > 1) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n"], ["const intersection = (interval1, interval2) => {\n  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  if (hi <= lo) { return \"NO\" }\n  if (hi - lo === 1) { return \"NO\" }\n  for (let i = 2; i < hi - lo; i++) {\n    if ((hi - lo) % i === 0) {\n      return \"NO\"\n    }\n  }\n  return \"YES\"\n}"], ["const prodSigns = (arr) => {\n  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    n *= Math.abs(arr[i])\n    if (arr[i] > 0) {\n      s += 1\n    } else if (arr[i] < 0) {\n      s -= 1\n    } else {\n      return 0\n    }\n  }\n  return n * s\n}\n"], ["``javascript\nconst minPath = (grid, k) => {\n  const N = grid.length;\n  const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n  const dp = new Array(k + 1).fill(null).map(() => new Array(N * N + 1).fill(null));\n\n  dp[0][1] = [];\n\n  for (let i = 1; i <= k; i++) {\n    for (let j = 1; j <= N * N; j++) {\n      for (const dir of directions) {\n        const x = j % N;\n        const y = Math.floor((j - 1) / N);\n        const nextX = x + dir[0];\n        const nextY = y + dir[1];\n        if (nextX >= 0 && nextX < N && nextY >= 0 && nextY < N) {\n          const nextJ = (nextY * N) + (nextX + 1);\n          if (dp[i - 1][nextJ] !== null) {\n            if (dp[i][j] === null || dp[i][j].length > dp[i - 1][nextJ].length + 1 ||\n                (dp[i][j].length === dp[i - 1][nextJ].length + 1 && grid[y][x] < grid[nextY][nextX])) {\n              dp[i][j] = dp[i - 1][nextJ].slice();\n              dp[i][j].push(grid[y][x]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  let minPath = null;\n  for (let j = 1; j <= N * N; j++) {\n    if (dp[k - 1][j] !== null && (minPath === null || dp[k - 1][j].length < minPath.length ||\n        (dp[k - 1][j].length === minPath.length && dp[k - 1][j].localeCompare(minPath) < 0))) {"], ["  }\n  let q = [2, 1]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      q.push(Math.floor(i / 2) + 1)\n    } else {\n      q.push(q[i - 1] + q[i - 2] + q[i + 1])\n    }\n  }\n  return p.concat(q)\n}\n"], ["const digits = (n) => {\n  let product = 1;\n  let hasOdd = false;\n  while (n > 0) {\n    let digit = n % 10;\n    if (digit % 2 !== 0) {\n      product *= digit;\n      hasOdd = true;\n    }\n    n = Math.floor(n / 10);\n  }\n  return hasOdd ? product : 0;\n}\n"], ["/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\n\nconst isNested = (string) => {\n  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    for (let j = 0; j < opening_bracket_index.length; j++) {\n      if (closing_bracket_index1[i] > opening_bracket_index[j]) {\n        return true\n      }\n    }\n  }\n  return false\n}"], ["const sumSquares = (lst) => {\n  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = Math.ceil(y) }\n    }\n    p += Math.pow(y, 2)\n  }\n  return p\n}\n"], ["const checkIfLastCharIsALetter = (txt) => {\n  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    // if the string has only one character and it is alphabetical\n    return (y >= 65 && y <= 90) || (y >= 97 && y <= 122)\n  } else {\n    // if the string has more than one character, check if the last character and the one before it is not a space,\n    // and if the last character is alphabetical\n    let x = txt[len - 2].charCodeAt()\n    return (x != 32) && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))\n  }\n}\n"], ["const canArrange = (arr) => {\n  if (arr.length === 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n"], ["const largestSmallestIntegers = (lst) => {\n  let a = null\n  let b = null\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < 0 && a === null || lst[i] < a) {\n      a = lst[i]\n    }\n    if (lst[i] > 0 && b === null || lst[i] > b) {\n      b = lst[i]\n    }\n  }\n  return [a, b]\n}\n"], ["const compareOne = (a, b) => {\n  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (bb > aa) { return b }\n  if (aa === bb) { return null }\n}\n"], ["// import necessary package\n// ...\n\n// complete the code\nconst isEqualToSumEven = (n) => {\n  return (n >= 8 && n % 2 == 0)\n}\n"], ["  t *= y;\n  y--;\n}\np = t;\nt = 1;\n}\nreturn p;\n};\n"], ["const fixSpaces = (text) => {\n  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      c = 0\n    }\n    t += text[i]\n  }\n  return t\n}\n"], ["const fileNameCheck = (file_name) => {\n  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (t[0].match(/[^A-Za-z]/)) { return 'No' }\n  if ((t[0].match(/\\d/g) || []).length > 3) { return 'No' }\n  return 'Yes'\n}"], ["const sumSquares = (lst) => {\n  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n\n"], ["const wordsInSentence = (sentence) => {\n  const isPrime = (n) => {\n    for (let i = 2, s = Math.sqrt(n); i <= s; i++)\n      if (n % i === 0) return false;\n    return n > 1;\n  };\n\n  let words = sentence.split(' ');\n  let primeWords = words.filter(word => isPrime(word.length));\n\n  return primeWords.join(' ');\n};\n"], ["const simplify = (x, n) => {\n  const num1 = Number(x.split('/')[0]);\n  const den1 = Number(x.split('/')[1]);\n  const num2 = Number(n.split('/')[0]);\n  const den2 = Number(n.split('/')[1]);\n  return num1 * num2 === den1 * den2;\n};\n"], ["const orderByPoints = (nums) => {\n  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      for (let r = h; r; r = Math.floor(r / 10)) {\n        m += r % 10;\n      }\n      for (let r = d; r; r = Math.floor(r / 10)) {\n        n += r % 10;\n      }\n      m = y * m\n      n = u * n\n      if (m > n) {\n        let t = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = t\n      }\n    }\n  }\n  return p;\n}\n"], ["  // Code begins to write here\n  for (let j = 0; j < y.length; j++) {\n    if (y[0] % 2 !== 0 && y[y.length - 1] % 2 !== 0) {\n      p++\n    }\n  }\n  return p\n}\n"], ["const getMaxTriples = (n) => {\n  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 === 0) {\n          u++\n        }\n      }\n    }\n  }\n  return u\n}\n"], ["const bf = (planet1, planet2) => {\n  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1) { return [] }\n  if (lo > hi) {\n    let x = lo\n    lo = hi\n    hi = x\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}"], [""], ["/*A simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\n\nExamples:\nfor xOrY(7, 34, 12) == 34\nfor xOrY(15, 8, 5) == 5\n\n*/\n\nconst isPrime = (num) => {\n    for (let i = 2, sqrt = Math.sqrt(num); i <= sqrt; i++)\n        if (num % i === 0) return false; \n    return num > 1;\n}\n\nconst xOrY = (n, x, y) => {\n    return isPrime(n) ? x : y;\n}\n"], ["Complete code (including all the content of the code I provided and the code you generated)\n"], ["const compare = (game, guess) => {\n  return game.map((value, index) => Math.abs(value - guess[index]));\n};\n"], ["const strongestExtension = (class_name, extensions) => {\n  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) u++\n      else if (k >= 97 && k <= 122) s++\n    }\n    let z = u - s\n    if (z > s) {\n      u = z\n      ext = extensions[i]\n    } else if (z == s) {\n      if (extensions[i] < ext) ext = extensions[i]\n    }\n  }\n  return class_name + '.' + ext\n}\n"], ["const cycpatternCheck = (a, b) => {\n  let l = b.length;\n  let pat = b + b;\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1;\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] !== pat[j + k]) {\n          y = 0;\n          break;\n        }\n      }\n      if (y === 1) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n"], ["const evenOddCount = (num) => {\n  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    let digit = num % 10\n    if (digit % 2 === 0) {\n      e++\n    } else {\n      o++\n    }\n    num = Math.floor(num / 10)\n  }\n  return [e, o]\n}\n"], ["const intToMiniRoman = (number) => {\n  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    if (div > 0) {\n      for (let j = 0; j < div; j++) {\n        res += sym[i]\n      }\n    }\n    number %= num[i]\n    i--\n  }\n  return res\n}\n"], ["const rightAngleTriangle = (a, b, c) => {\n  //Sort the numbers so that c is the largest\n  [a, b, c] = [a, b, c].sort((a, b) => a - b);\n\n  //The sum of the squares of the two shorter sides should equal the square of the longest side\n  return a * a + b * b === c * c;\n};"], ["const findMax = (words) => {\n  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    let l = [...new Set(words[i])].length\n    if (l > u) {\n      s = i\n      u = l\n    } else if (l === u && words[i] < words[s]) {\n      s = i\n    }\n  }\n  return words[s]\n}"], ["const eat = (number, need, remaining) => {\n  const totalEaten = number + Math.min(need, remaining);\n  const carrotsLeft = Math.max(remaining - need, 0);\n  return [totalEaten, carrotsLeft];\n}\n\n"], ["const doAlgebra = (operator, operand) => {\n  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operator.splice(i, 1)\n        i--\n      }\n    }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '/') {\n        operand[i] /= operand[i + 1]\n        operator.splice(i, 1)\n        i--\n      }\n    }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operator.splice(i, 1)\n        i--\n      }\n    }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operator.splice(i, 1)\n        i--\n      }\n    }\n  }\n  return operand[0]\n}\n"], ["const solve = (s) => {\n  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p = p + String.fromCharCode(y);\n  }\n  if (t !== 1) {\n    return p.split('').reverse().join('');\n  } else {\n    return p;\n  }\n}\n"], ["const stringToMd5 = (text) => {\n  if (text == '') { return null }\n  return require('js-md5')(text)\n}\n"], ["const generateIntegers = (a, b) => {\n  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  \n  let result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  \n  return result;\n};\n"]]