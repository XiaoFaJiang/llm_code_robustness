[[""], ["class Solution {\n    public List<String> separateParenGroups(String paren_string) {\n        List<String> result = new ArrayList<>();\n        StringBuilder current_string = new StringBuilder();\n        int current_depth = 0;\n\n        for (char c : paren_string.toCharArray()) {\n            if (c == '(') {\n                current_depth += 1;\n            }\n            if (current_depth > 0) {\n                current_string.append(c);\n            }\n            if (c == ')') {\n                current_depth -= 1;\n                if (current_depth == 0) {\n                    result.add(current_string.toString());\n                    current_string = new StringBuilder();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n"], ["class Solution {\n    /**\n    Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncateNumber(3.5)\n    0.5\n     */\n\n    public double truncateNumber(double number) {\n        return number % 1.0;\n    }\n}\n"], ["class Solution {\n    public boolean belowZero(List<Integer> operations) {\n        int balance = 0;\n\n        for (int op : operations) {\n            balance += op;\n            if (balance < 0) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n"], ["public double meanAbsoluteDeviation(List<Double> numbers) {\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.size();\n    double mad = 0.0;\n    for (double num : numbers) {\n        mad += Math.abs(num - mean);\n    }\n    return mad / numbers.size();\n}\n"], [""], ["class Solution {\n    /**\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parseNestedParens(\"(()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n     */\n    public List<Integer> parseNestedParens(String paren_string) {\n\n\n        String[] groups = paren_string.split(\" \");\n        List<Integer> result = new ArrayList<>(List.of());\n        for (String group : groups) {\n            if (group.length() > 0) {\n                int depth = 0;\n                int max_depth = 0;\n                for (char c : group.toCharArray()) {\n                    if (c == '(') {\n                        depth++;\n                        max_depth = Math.max(max_depth, depth);\n                    } else if (c == ')') {\n                        depth--;\n                    }\n                }\n                result.add(max_depth);\n            }\n        }\n        return result;\n    }\n}\n"], ["class Solution {\n    public List<String> filterBySubstring(List<String> strings, String substring) {\n        List<String> result = new ArrayList<>();\n        for (String x : strings) {\n            if (x.contains(substring)) {\n                result.add(x);\n            }\n        }\n        return result;\n    }\n}\n"], ["class Solution {\n    //For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    //Empty sum should be equal to 0 and empty product should be equal to 1.\n    //>>> sumProduct(List.of())\n    //[0, 1]\n    //>>> sumProduct(Arrays.asList(1, 2, 3, 4))\n    //[10, 24]\n    public List<Integer> sumProduct(List<Integer> numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (int n : numbers) {\n            sum += n;\n            product *= n;\n        }\n\n        return Arrays.asList(sum, product);\n    }\n}\n"], ["class Solution {\n    /**\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rollingMax(Arrays.asList(1, 2, 3, 2, 3, 4, 2))\n    [1, 2, 3, 3, 3, 4, 4]\n     */\n\n    public List<Integer> rollingMax(List<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        if (numbers.size() == 0) {\n            return result;\n        }\n        int rollingMax = numbers.get(0);\n        result.add(rollingMax);\n\n        for (int i = 1; i < numbers.size(); i++) {\n            if (numbers.get(i) > rollingMax) {\n                rollingMax = numbers.get(i);\n            }\n            result.add(rollingMax);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.rollingMax(Arrays.asList(1, 2, 3, 2, 3, 4, 2))); // Output: [1, 2, 3, 3, 3, 4, 4]\n    }\n}\n"], ["class Solution {\n    /**\n    Test if given string is a palindrome\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i) != string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n    /**\n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> makePalindrome(\"\")\n    \"\"\n    >>> makePalindrome(\"cat\")\n    \"catac\"\n    >>> makePalindrome(\"cata\")\n    \"catac\"\n     */\n    public String makePalindrome(String string) {\n        if (string.length() == 0) {\n            return \"\";\n        }\n\n        int beginning_of_suffix = 0;\n        // Find the longest palindromic suffix\n        while (!isPalindrome(string.substring(beginning_of_suffix))) {\n            beginning_of_suffix++;\n        }\n\n        // Create the palindrome by appending reverse of prefix before suffix\n        return string + new StringBuilder(string.substring(0, beginning_of_suffix)).reverse().toString();\n    }\n}\n"], ["            } else {\n                result.append(\"1\");\n            }\n        }\n        return result.toString();\n    }\n}\n"], ["    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n        String longest = strings.get(0);\n        for (String str : strings) {\n            if (str.length() > longest.length()) {\n                longest = str;\n            }\n        }\n        return Optional.of(longest);\n    }\n"], ["class Solution {\n    /**\n    Return a greatest common divisor of two integers a and b\n    >>> greatestCommonDivisor(3, 5)\n    1\n    >>> greatestCommonDivisor(25, 15)\n    5\n     */\n\n    public int greatestCommonDivisor(int a, int b) {\n        if (a == 0 || b == 0) {\n            return a + b;\n        }\n        if (a == b) {\n            return a;\n        }\n        if (a > b) {\n            return greatestCommonDivisor(a % b, b);\n        } else {\n            return greatestCommonDivisor(a, b % a);\n        }\n    }\n}\n"], ["class Solution {\n    /**\n    Return list of all prefixes from shortest to longest of the input string\n    >>> allPrefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n     */\n\n    public List<String> allPrefixes(String string) {\n        List<String> result = new ArrayList<>();\n\n        for (int i = 1; i <= string.length(); i++) {\n            result.add(string.substring(0, i));\n        }\n        \n        return result;\n    }\n}\n"], ["class Solution {\n\n    /**\n    Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> stringSequence(0)\n    \"0\"\n    >>> stringSequence(5)\n    \"0 1 2 3 4 5\"\n     */\n    public String stringSequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= n; i++) {\n            sb.append(i);\n            if (i < n) {\n                sb.append(\" \");\n            }\n        }\n        return sb.toString();\n    }\n}\n"], ["class Solution {\n    //*\n//Given a string, find out how many distinct characters (regardless of case) does it consist of\n//>>> countDistinctCharacters(\"xyzXYZ\")\n//3\n//>>> countDistinctCharacters(\"Jerry\")\n//4\n    public int countDistinctCharacters(String string) {\n        Set<Character> set = new HashSet<>();\n        for (char c : string.toLowerCase().toCharArray()) {\n            set.add(c);\n        }\n        return set.size();\n    }\n}\n"], ["class Solution {\n    /**\n    Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    \"o\" - whole note, lasts four beats\n    \"o|\" - half note, lasts two beats\n    \".|\" - quater note, lasts one beat\n\n    >>> parseMusic(\"o o| .| o| o| .| .| .| .| o o\")\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n     */\n\n    public List<Integer> parseMusic(String string) {\n        String[] notes = string.split(\" \");\n        List<Integer> result = new ArrayList<>();\n        for (String s : notes) {\n            switch (s) {\n                case \"o\":\n                    result.add(4);\n                    break;\n                case \"o|\":\n                    result.add(2);\n                    break;\n                case \".|\":\n                    result.add(1);\n                    break;\n            }\n        }\n        return result;\n    }\n}\n"], ["class Solution {\n        // public int howManyTimes(String string, String substring) {\n        times++;\n        i = i + substring.length() - 1; // Move the index to the end of the current substring\n    }\n}\n"], ["num.add(8);\n                case \"nine\" -> num.add(9);\n            }\n        }\n        Collections.sort(num);\n        String result = \"\";\n        for (int i = 0; i < num.size(); i++) {\n            switch (num.get(i)) {\n                case 0 -> result += \"zero \";\n                case 1 -> result += \"one \";\n                case 2 -> result += \"two \";\n                case 3 -> result += \"three \";\n                case 4 -> result += \"four \";\n                case 5 -> result += \"five \";\n                case 6 -> result += \"six \";\n                case 7 -> result += \"seven \";\n                case 8 -> result += \"eight \";\n                case 9 -> result += \"nine \";\n            }\n        }\n        return result;\n    }\n}\n"], ["class Solution {\n    /**\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> findClosestElements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))\n    [2.0, 2.2]\n    >>> findClosestElements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))\n    [2.0, 2.0]\n     */\n\n    public List<Double> findClosestElements(List<Double> numbers) {\n        Collections.sort(numbers); // Sort the list in ascending order\n        List<Double> closest_pair = new ArrayList<>();\n        double min_distance = Double.MAX_VALUE;\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double distance = Math.abs(numbers.get(i) - numbers.get(i + 1));\n            if (distance < min_distance) {\n                min_distance = distance;\n                closest_pair.clear();\n                closest_pair.add(numbers.get(i));\n                closest_pair.add(numbers.get(i + 1));\n            }\n        }\n        return closest_pair;\n    }\n}\n"], ["class Solution {\n    /**\n    Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescaleToUnit(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0))\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n     */\n\n    public List<Double> rescaleToUnit(List<Double> numbers) {\n        double min_number = Collections.min(numbers);\n        double max_number = Collections.max(numbers);\n        List<Double> result = new ArrayList<>();\n        for (double num : numbers) {\n            double transformed = (num - min_number) / (max_number - min_number);\n            result.add(transformed);\n        }\n        return result;\n    }\n}\n"], ["class Solution {\n    /**\n     * Filter given list of any values only for integers\n     */\n    public List<Integer> filterIntegers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        for (Object x : values) {\n            if (x instanceof Integer) {\n                result.add((Integer) x);\n            }\n        }\n        return result;\n    }\n}\n"], ["class Solution {\n    /**\n    Return length of given string\n    >>> strlen(\"\")\n    0\n    >>> strlen(\"abc\")\n    3\n     */\n    public int strlen(String string) {\n        return string.length();\n    }\n}\n"], ["class Solution {\n    /**\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largestDivisor(15)\n    5\n     */\n\n    public int largestDivisor(int n) {\n        for (int i = n - 1; i > 0; i--) {\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        return 1; // If there's no divisor smaller than n, return 1 (every number is divisible by itself and 1).\n    }\n}\n"], ["class Solution {\n    /**\n    Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n     */\n\n    public List<Integer> factorize(int n) {\n        List<Integer> fact = new ArrayList<>();\n        int i = 2;\n        while (n > 1) {\n            if (n % i == 0) {\n                fact.add(i);\n                n /= i;\n            } else {\n                i++;\n            }\n        }\n        return fact;\n    }\n}\n"], ["class Solution {\n    public List<Integer> removeDuplicates(List<Integer> numbers) {\n        Map<Integer, Integer> c = new HashMap<>();\n        for (int i : numbers) {\n            c.put(i, c.getOrDefault(i, 0) + 1);\n        }\n        return numbers.stream()\n                .filter(i -> c.get(i) == 1)\n                .collect(Collectors.toList());\n    }\n}\n"], ["sb.append(Character.toLowerCase(string.charAt(i)));\n} else {\n    sb.append(string.charAt(i));\n}\n}\nreturn sb.toString();\n}\n"], ["class Solution {\n    /**\n    Concatenate list of strings into a single string\n\n     */\n    public String concatenate(List<String> strings) {\n        return String.join(\"\", strings);\n    }\n}\n"], ["    public List<String> filterByPrefix(List<String> strings, String prefix) {\n        return strings.stream().filter(p -> p.startsWith(prefix)).collect(Collectors.toList());\n"], ["public List<Integer> getPositive(List<Integer> l) {\n    return l.stream().filter(p -> p > 0).collect(Collectors.toList());\n}\n"], ["        if (n == 2) {\n            return true;\n        } else if (n % 2 == 0) {\n            return false;\n        }\n\n        int boundary = (int) Math.sqrt(n);\n\n        for (int i = 3; i <= boundary; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n"], ["class Solution {\n    /**\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n    \n    /**\n    xs are coefficients of a polynomial.\n    findZero find x such that poly(x) = 0.\n    findZero returns only only zero point, even if there are many.\n    Moreover, findZero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> findZero(Arrays.asList(1, 2)) // f(x) = 1 + 2x\n    -0.5\n    >>> findZero(Arrays.asList(-6, 11, -6, 1)) // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n     */\n    public double findZero(List<Double> xs) {\n        double begin = -1, end = 1;\n        while (poly(xs, begin) * poly(xs, end) > 0) {\n            begin *= 2;\n            end *= 2;\n        }\n        while (end - begin > 1e-10) {\n            double mid = (begin + end) / 2.0;\n            if (poly(xs, mid) * poly(xs, begin) > 0) {\n                begin = mid;\n            } else {\n                end = mid;\n            }\n        }\n        return begin;\n    }\n"], ["class Solution {\n    /**\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sortThird(Arrays.asList(1, 2, 3))\n    [1, 2, 3]\n    >>> sortThird(Arrays.asList(5, 6, 3, 4, 8, 9, 2))\n    [2, 6, 3, 4, 8, 9, 5]\n     */\n\n    public List<Integer> sortThird(List<Integer> l) {\n        List<Integer> thirds = new ArrayList<>();\n        List<Integer> copy = new ArrayList<>(l); // Create a copy to avoid modifying the original list\n\n        for (int i = 0; i < copy.size(); i += 3) {\n            thirds.add(copy.get(i));\n        }\n\n        Collections.sort(thirds); // Sort the third elements\n\n        for (int i = 0, j = 0; i < copy.size(); i += 3, j++) {\n            copy.set(i, thirds.get(j)); // Replace the third elements with the sorted ones\n        }\n\n        return copy;\n    }\n}\n"], ["    return result;\n    }\n}\n"], ["class Solution {\n    public int maxElement(List<Integer> l) {\n        return Collections.max(l);\n    }\n}\n"], ["// \"Tribonacci\" sequence is the one where a number is the sum of the three preceding ones\n// What we will do here is rather than just generate n fibonacci numbers,\n// we will generate (n-3) fibonacci numbers and then return the last generated fibonacci number\n// from the \"Tribonacci\" sequence.\npublic int tribonacci(int n) {\n\tif(n == 0) return 0;\n\telse if(n == 1) return 1;\n\telse if(n == 2) return 1;\n\telse if(n == 3) return 2;\n\n\tint a = 0, b = 1, c = 1, d;\n\tfor(int i = 4; i < n; i++){\n\t\td = a + b + c;\n\t\ta = b;\n\t\tb = c;\n\t\tc = d;\n\t}\n\n\treturn c;\n}\n"], ["class Solution {\n    /**\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n\n\n    >>> sortEven(Arrays.asList(1, 2, 3))\n    [1, 2, 3]\n    >>> sortEven(Arrays.asList(5, 6, 3, 4))\n    [3, 6, 5, 4]\n     */\n    public List<Integer> sortEven(List<Integer> l) {\n        List<Integer> even = new ArrayList<>();\n        for (int i = 0; i < l.size(); i += 2) {\n            even.add(l.get(i));\n        }\n        Collections.sort(even);\n        List<Integer> sortedList = new ArrayList<>();\n        for (int i = 0, j = 0; i < l.size(); i++) {\n            if (i % 2 == 0) {\n                sortedList.add(even.get(j++));\n            } else {\n                sortedList.add(l.get(i));\n            }\n        }\n        return sortedList;\n    }\n}\n"], ["    public String decodeCyclic(String s) {\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).charAt(2) + groups.get(i).substring(0, 2));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n"], ["class Solution {\n    public int primeFib(int n) {\n        if (n == 1)\n            return 2;\n        if (n == 2)\n            return 3;\n        int f0 = 0, f1 = 1, index = 0, p = 1;\n        while (index < n - 2) {\n            int temp = f0 + f1;\n            f0 = f1;\n            f1 = temp;\n            if (isPrime(f1)) {\n                index++;\n                if (index == n - 1)\n                    p = f1;\n            }\n        }\n        return p;\n    }\n\n    public boolean isPrime(int num) {\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0)\n                return false;\n        }\n        return num > 1;\n    }\n}\n"], ["class Solution {\n    /**\n    triplesSumToZero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triplesSumToZero(Arrays.asList(1, 3, 5, 0))\n    false\n    >>> triplesSumToZero(Arrays.asList(1, 3, -2, 1))\n    true\n    >>> triplesSumToZero(Arrays.asList(1, 2, 3, 7))\n    false\n    >>> triplesSumToZero(Arrays.asList(2, 4, -5, 3, 9, 7))\n    true\n    >>> triplesSumToZero(Arrays.asList(1))\n    false\n     */\n\n    public boolean triplesSumToZero(List<Integer> l) {\n        for (int i = 0; i < l.size(); i++) {\n            for (int j = i + 1; j < l.size(); j++) {\n                for (int k = j + 1; k < l.size(); k++) {\n                    if (l.get(i) + l.get(j) + l.get(k) == 0) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n"], ["class Solution {\n    //*\n//Imagine a road that's a perfectly straight infinitely long line.\n//n cars are driving left to right;  simultaneously, a different set of n cars\n//are driving right to left.   The two sets of cars start out being very far from\n//each other.  All cars move in the same speed.  Two cars are said to collide\n//when a car that's moving left to right hits a car that's moving right to left.\n//However, the cars are infinitely sturdy and strong; as a result, they continue moving\n//in their trajectory as if they did not collide.\n//\n//This function outputs the number of such collisions.\n    public int carRaceCollision(int n) {\n        return n * n;\n    }\n}\n\nNote that the solution is based on the assumption that all cars will eventually collide with each other since the road is infinitely long and all cars move at the same speed. The function simply calculates the number of collisions based on the number of cars in each direction, which is n squared."], ["class Solution {\n    //Return list with elements incremented by 1.\n    public List<Integer> incrList(List<Integer> l) {\n        return l.stream().map(p -> p + 1).collect(Collectors.toList());\n    }\n}\n"], ["class Solution {\n    /**\n    pairsSumToZero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairsSumToZero(Arrays.asList(1, 3, 5, 0))\n    false\n    >>> pairsSumToZero(Arrays.asList(1, 3, -2, 1))\n    false\n    >>> pairsSumToZero(Arrays.asList(1, 2, 3, 7))\n    false\n    >>> pairsSumToZero(Arrays.asList(2, 4, -5, 3, 5, 7))\n    true\n    >>> pairsSumToZero(Arrays.asList(1))\n    false\n     */\n\n    public boolean pairsSumToZero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        for (int i : l) {\n            if (seen.contains(-i)) {\n                return true;\n            }\n            seen.add(i);\n        }\n        return false;\n    }\n}"], ["class Solution {\n    public String changeBase(int x, int base) {\n        StringBuilder ret = new StringBuilder();\n        while (x > 0) {\n            ret.append(String.valueOf(x % base));\n            x /= base;\n        }\n        return ret.toString();\n    }\n}\n"], ["class Solution {\n    //Given length of a side and high return area for a triangle.\n    //>>> triangleArea(5, 3)\n    //7.5\n    public double triangleArea(double a, double h) {\n        return a * h / 2;\n    }\n}\n"], ["    public int fib4(int n) {\n        while (results.size() <= n) {\n            int size = results.size();\n            int newVal = results.get(size - 1) + results.get(size - 2) + results.get(size - 3) + results.get(size - 4);\n            results.add(newVal);\n        }\n        return results.get(n);\n    }\n}\n"], ["class Solution {\n    /**\n    Return median of elements in the list l.\n    >>> median(Arrays.asList(3, 1, 2, 4, 5))\n    3\n    >>> median(Arrays.asList(-10, 4, 6, 1000, 10, 20))\n    15.0\n     */\n\n    public double median(List<Integer> l) {\n        Collections.sort(l);\n        if (l.size() % 2 == 1) {\n            return l.get(l.size() / 2);\n        } else {\n            return (l.get(l.size() / 2 - 1) + l.get(l.size() / 2)) / 2.0;\n        }\n    }\n}"], ["/**\n * Checks if the given string is a palindrome.\n *\n * @param text the string to check\n * @return true if the string is a palindrome, false otherwise\n */\npublic boolean isPalindrome(String text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text.charAt(left) != text.charAt(right)) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n"], ["public int modp(int n, int p) {\n    int ret = 1;\n    for (int i = 0; i < n; i++) {\n        ret = (ret * 2) % p;\n    }\n    return ret;\n}\n"], ["class Solution {\n    /**\n    returns encoded string by shifting every character by 5 in the alphabet.\n     */\n\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            sb.append((char) ('a' + ((ch + 5 - 'a') % 26)));\n        }\n        return sb.toString();\n    }\n\n    /**\n    takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n\n    public String decodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            sb.append((char) ('a' + ((ch + 21 - 'a') % 26)));\n        }\n        return sb.toString();\n    }\n}\n"], ["public String removeVowels(String text) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : text.toCharArray()) {\n            if (\"aeiou\".indexOf(Character.toLowerCase(ch)) == -1) {\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n}\n"], ["class Solution {\n    public boolean belowThreshold(List<Integer> l, int t) {\n        for (int e : l) {\n            if (e >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"], ["class Solution {\n    public int add(int x, int y) {\n        return x + y;\n    }\n}\n"], ["Complete code (including all the content of the code I provided and the code you generated)\n"], ["class Solution {\n    /**\n    Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n     */\n    public int fib(int n) {\n        if (n == 0) {\n            return 0;\n        } else if (n == 1) {\n            return 1;\n        } else {\n            return fib(n - 1) + fib(n - 2);\n        }\n    }\n}\n"], ["class Solution {\n    /**\n    brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n    \n    >>> correctBracketing(\"<\")\n    false\n    >>> correctBracketing(\"<>\")\n    true\n    >>> correctBracketing(\"<<><>>\")\n    true\n    >>> correctBracketing(\"><<>\")\n    false\n     */\n\n    public boolean correctBracketing(String brackets) {\n        int depth = 0;\n        for (char b : brackets.toCharArray()) {\n            if (b == '<') {\n                depth += 1;\n            } else if (b == '>') {\n                depth -= 1;\n            }\n            if (depth < 0) {\n                return false;\n            }\n        }\n        return depth == 0;\n    }\n}\n"], ["class Solution {\n    /**\n     * Return true if list elements are monotonically increasing or decreasing.\n     * >>> monotonic(Arrays.asList(1, 2, 4, 20))\n     * true\n     * >>> monotonic(Arrays.asList(1, 20, 4, 10))\n     * false\n     * >>> monotonic(Arrays.asList(4, 1, 0, -10))\n     * true\n     */\n    public boolean monotonic(List<Integer> l) {\n        List<Integer> l1 = new ArrayList<>(l);\n        List<Integer> l2 = new ArrayList<>(l);\n        Collections.sort(l1);\n        Collections.sort(l2, Collections.reverseOrder());\n        return l1.equals(l) || l2.equals(l);\n    }\n}\n"], ["class Solution {\n    //*\n    //Return sorted unique common elements for two lists.\n    //>>> common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121))\n    //[1, 5, 653]\n    //>>> common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2))\n    //[2, 3]\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        Set<Integer> ret = new HashSet<>(l1);\n        ret.retainAll(new HashSet<>(l2));\n        List<Integer> result = new ArrayList<>(ret);\n        Collections.sort(result);\n        return result;\n    }\n}\n"], ["        for (int j = 2; j <= n; j++) {\n            if (n % j == 0) {\n                boolean is_prime = j >= 2;\n                for (int i = 2; i < j - 1; i++) {\n                    if (j % i == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n                if (is_prime) {\n                    largest = j;\n                }\n            }\n        }\n        return largest;\n    }\n}\n"], ["class Solution {\n    /**\n    sumToN is a function that sums numbers from 1 to n.\n    >>> sumToN(30)\n    465\n    >>> sumToN(100)\n    5050\n    >>> sumToN(5)\n    15\n    >>> sumToN(10)\n    55\n    >>> sumToN(1)\n    1\n     */\n\n    public int sumToN(int n) {\n        int result = 0;\n        for (int i = 1; i <= n; i++) {\n            result += i;\n        }\n        return result;\n    }\n}\n"], ["class Solution {\n    /**\n    brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correctBracketing(\"(\")\n    false\n    >>> correctBracketing(\"()\")\n    true\n    >>> correctBracketing(\"(()())\")\n    true\n    >>> correctBracketing(\")(()\")\n    false\n     */\n\n    public boolean correctBracketing(String brackets) {\n        int depth = 0;\n        for (char b : brackets.toCharArray()) {\n            if (b == '(') {\n                depth += 1;\n            } else if (b == ')') {\n                depth -= 1;\n                if (depth < 0) {\n                    return false; // A closing bracket without a matching opening bracket\n                }\n            }\n        }\n        return depth == 0; // All opening brackets must be closed\n    }\n}\n"], ["class Solution {\n    /**\n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative(Arrays.asList(3, 1, 2, 4, 5))\n    [1, 4, 12, 20]\n    >>> derivative(Arrays.asList(1, 2, 3))\n    [2, 6]\n     */\n\n    public List<Integer> derivative(List<Integer> xs) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(i * xs.get(i));\n        }\n        return result;\n    }\n}\n"], ["class Solution {\n    public int fibfib(int n) {\n        int[] fib = new int[n + 1];\n        fib[0] = 0;\n        if (n > 0) {\n            fib[1] = 0;\n        }\n        if (n > 1) {\n            fib[2] = 1;\n        }\n        for (int i = 3; i <= n; i++) {\n            fib[i] = fib[i - 1] + fib[i - 2] + fib[i - 3];\n        }\n        return fib[n];\n    }\n}\n"], ["class Solution {\n    /**\n    Write a function vowelsCount which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowelsCount(\"abcde\")\n    2\n    >>> vowelsCount(\"ACEDY\")\n    3\n     */\n\n    public int vowelsCount(String s) {\n        String vowels = \"aeiouAEIOU\";\n        int n_vowels = 0;\n        for (char c : s.toCharArray()) {\n            if (vowels.indexOf(c) != -1) {\n                n_vowels += 1;\n            }\n        }\n        if (s.endsWith(\"y\") || s.endsWith(\"Y\")) {\n            n_vowels += 1;\n        }\n        return n_vowels;\n    }\n}\n"], ["class Solution {\n    public String circularShift(int x, int shift) {\n        String s = String.valueOf(x);\n        if (shift > s.length()) {\n            return new StringBuilder(s).reverse().toString();\n        }\n        int realShift = shift % s.length();\n        return s.substring(s.length() - realShift) + s.substring(0, s.length() - realShift);\n    }\n}\n"], ["class Solution {\n    public int digitSum(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += c;\n            }\n        }\n        return sum;\n    }\n}\n"], ["class Solution {\n    /**\n    In this task, you will be given a string that represents a number of apples and oranges\n    that are distributed in a basket of fruit this basket contains\n    apples, oranges, and mango fruits. Given the string that represents the total number of\n    the oranges and apples and an integer that represent the total number of the fruits\n    in the basket return the number of the mango fruits in the basket.\n    for examble:\n    fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n    fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n    fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n    fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n     */\n\n    public int fruitDistribution(String s, int n) {\n        List<Integer> lis = new ArrayList<>();\n        for (String i : s.split(\" \")) {\n            try {\n                lis.add(Integer.parseInt(i));\n            } catch (NumberFormatException e) {\n                e.printStackTrace();\n            }\n        }\n        return n - lis.get(0) - lis.get(1);\n    }\n}\n"], ["class Solution {\n    /**\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 3:\n        Input: []\n        Output: []\n\n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n\n\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n     */\n    public List<Integer> pluck(List<Integer> arr) {\n        List<Integer> result = new ArrayList<>();\n        if (arr.size() == 0) {\n            return result;\n        }\n        int min = Integer.MAX_VALUE;\n        int minIndex = -1;\n        for (int i = 0; i < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0 && arr.get(i) < min) {\n                min = arr.get(i);\n                minIndex = i;\n            }\n        }\n"], ["class Solution {\n    public int search(List<Integer> lst) {\n        int[] frq = new int[Collections.max(lst) + 1];\n        for (int i : lst) {\n            frq[i] += 1;\n        }\n        int ans = -1;\n        for (int i = frq.length - 1; i > 0; --i) {\n            if (frq[i] >= i) {\n                ans = i;\n                break;\n            }\n        }\n        return ans;\n    }\n}\n"], ["    List<Integer> strangeSortList(List<Integer> lst) {\n        Collections.sort(lst);\n        List<Integer> res = new ArrayList<>();\n        int l = 0;\n        int r = lst.size() - 1;\n        while (l <= r) {\n            if (l == r) {\n                res.add(lst.get(l));\n            } else {\n                res.add(lst.get(l));\n                res.add(lst.get(r));\n            }\n            l++;\n            r--;\n        }\n        return res;\n    }\n"], ["class Solution {\n    public double triangleArea(double a, double b, double c) {\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n        double s = (a + b + c) / 2;\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        return Math.round(area * 100.0) / 100.0;\n    }\n}\n"], ["class Solution {\n    //*\n    //Write a function that returns True if the object q will fly, and False otherwise.\n    //The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n    //\n    //Example:\n    //willItFly(Arrays.asList(1, 2), 5) -> false\n    //# 1+2 is less than the maximum possible weight, but it's unbalanced.\n    //\n    //willItFly(Arrays.asList(3, 2, 3), 1) -> false\n    //# it's balanced, but 3+2+3 is more than the maximum possible weight.\n    //\n    //willItFly(Arrays.asList(3, 2, 3), 9) -> true\n    //# 3+2+3 is less than the maximum possible weight, and it's balanced.\n    //\n    //willItFly(Arrays.asList(3), 5) -> true\n    //# 3 is less than the maximum possible weight, and it's balanced.\n    public boolean willItFly(List<Integer> q, int w) {\n        if (q.stream().reduce(0, Integer::sum) > w) {\n            return false;\n        }\n        int i = 0, j = q.size() - 1;\n        while (i < j) {\n            if (!Objects.equals(q.get(i), q.get(j))) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n}\n"], ["class Solution {\n    public int smallestChange(List<Integer> arr) {\n        int ans = 0;\n        for (int i = 0; i < arr.size() / 2; i++) {\n            if (!Objects.equals(arr.get(i), arr.get(arr.size() - i - 1))) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n"], ["        for (String st : lst2) {\n            l2 += st.length();\n        }\n\n        if (l1 <= l2) {\n            return l1 < l2 ? lst1 : lst2;\n        } else {\n            return l1 > l2 ? lst2 : lst1;\n        }\n    }\n}\n"], ["class Solution {\n    /**\n    Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100.\n    Example:\n    isMultiplyPrime(30) == true\n    30 = 2 * 3 * 5\n     */\n    public boolean isMultiplyPrime(int a) {\n        List<Integer> primes = getPrimesLessThan100();\n        int count = 0;\n\n        for (int prime : primes) {\n            if (a % prime == 0) {\n                count++;\n                if (count > 3) {\n                    return false; // If more than 3 prime factors found, return false\n                }\n                while (a % prime == 0) {\n                    a /= prime; // Remove the prime factor from 'a'\n                }\n            }\n        }\n        return count == 3 && a == 1; // Check if exactly 3 prime factors and 'a' is reduced to 1\n    }\n\n    private List<Integer> getPrimesLessThan100() {\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < 100; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int j = 2; j <= Math.sqrt(n); j++) {\n            if (n % j == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"], ["public boolean isSimplePower(int x, int n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    int power = 1;\n    while (power < x) {\n        power *= n;\n    }\n    return power == x;\n}\n"], ["class Solution {\n    //Write a function that takes an integer a and returns true\n    //if this ingeger is a cube of some integer number.\n    //Note: you may assume the input is always valid.\n    //Examples:\n    //iscube(1) ==> true\n    //iscube(2) ==> false\n    //iscube(-1) ==> true\n    //iscube(64) ==> true\n    //iscube(0) ==> true\n    //iscube(180) ==> false\n    public boolean iscube(int a) {\n        a = Math.abs(a);\n        return Math.round(Math.pow(Math.round(Math.pow(a, 1. / 3)), 3)) == a;\n    }\n}\n"], [""], ["class Solution {\n    /**\n    You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimalToBinary(15)   // returns \"db1111db\"\n    decimalToBinary(32)   // returns \"db100000db\"\n     */\n\n    public String decimalToBinary(int decimal) {\n        return \"db\" + Integer.toBinaryString(decimal) + \"db\";\n    }\n}\n"], ["        for (int i = 0; i <= s.length() - 3; i++) {\n            char a = s.charAt(i);\n            char b = s.charAt(i + 1);\n            char c = s.charAt(i + 2);\n            if (a == b || b == c || c == a) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"], ["            } else if (gpa > 2.7) {\n                letter_grade.add(\"B\");\n            } else if (gpa > 2.3) {\n                letter_grade.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letter_grade.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letter_grade.add(\"C\");\n            } else if (gpa > 1.3) {\n                letter_grade.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letter_grade.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letter_grade.add(\"D\");\n            } else if (gpa > 0.0) {\n                letter_grade.add(\"D-\");\n            } else {\n                letter_grade.add(\"E\");\n            }\n        }\n        return letter_grade;\n    }\n}\n"], ["class Solution {\n    /**\n    Write a function that takes a string and returns true if the string\n    length is a prime number or false otherwise\n    Examples\n    primeLength(\"Hello\") == true\n    primeLength(\"abcdcba\") == true\n    primeLength(\"kittens\") == true\n    primeLength(\"orange\") == false\n     */\n\n    public boolean primeLength(String string) {\n        int l = string.length();\n        if (l == 0 || l == 1) {\n            return false;\n        }\n        for (int i = 2; i < l; i++) {\n            if (l % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"], ["Complete code (including all the content of the code I provided and the code you generated)\n"], ["        }\n        return Integer.toBinaryString(sum);\n    }\n}\n"], ["class Solution {\n    /**\n    Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) {\n            if (lst.get(i) % 2 == 0) {\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n}\n"], ["class Solution {\n    /**\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    antiShuffle(\"Hi\") returns \"Hi\"\n    antiShuffle(\"hello\") returns \"ehllo\"\n    antiShuffle(\"Hello World!!!\") returns \"Hello !!!Wdlor\"\n     */\n\n    public String antiShuffle(String s) {\n        String[] strings = s.split(\" \");\n        List<String> result = new ArrayList<>();\n        for (String string : strings) {\n            char[] chars = string.toCharArray();\n            Arrays.sort(chars);\n            result.add(new String(chars));\n        }\n        return String.join(\" \", result);\n    }\n}\n"], ["class Solution {\n    public List<List<Integer>> getRow(List<List<Integer>> lst, int x) {\n        List<List<Integer>> coords = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            List<List<Integer>> row = new ArrayList<>();\n            for (int j = lst.get(i).size() - 1; j >= 0; j--) {\n                if (lst.get(i).get(j) == x) {\n                    List<Integer> coord = new ArrayList<>();\n                    coord.add(i);\n                    coord.add(j);\n                    row.add(coord);\n                }\n            }\n            if (!row.isEmpty()) {\n                Collections.sort(row, new Comparator<List<Integer>>() {\n                    @Override\n                    public int compare(List<Integer> o1, List<Integer> o2) {\n                        return o2.get(1).compareTo(o1.get(1));\n                    }\n                });\n                coords.addAll(row);\n            }\n        }\n        Collections.sort(coords, new Comparator<List<Integer>>() {\n            @Override\n            public int compare(List<Integer> o1, List<Integer> o2) {\n                return o1.get(0).compareTo(o2.get(0));\n            }\n        });\n        return coords;\n    }\n}\n"], ["class Solution {\n    public List<Integer> sortArray(List<Integer> array) {\n        if (array.size() == 0) {\n            return array;\n        }\n        List<Integer> result = new ArrayList<>(array);\n        int sum = array.get(0) + array.get(array.size() - 1);\n        if (sum % 2 == 0) {\n            Collections.sort(result, Collections.reverseOrder());\n        } else {\n            Collections.sort(result);\n        }\n        return result;\n    }\n}\n"], ["class Solution {\n    //*\n    //Create a function encrypt that takes a string as an argument and\n    //returns a string encrypted with the alphabet being rotated.\n    //The alphabet should be rotated in a manner such that the letters\n    //shift down by two multiplied to two places.\n    //For example:\n    //encrypt(\"hi\") returns \"lm\"\n    //encrypt(\"asdfghjkl\") returns \"ewhjklnop\"\n    //encrypt(\"gf\") returns \"kj\"\n    //encrypt(\"et\") returns \"ix\"\n    public String encrypt(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                int newChar = (c - 'a' + 2 * 2) % 26;\n                sb.append((char) ('a' + newChar));\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}\n"], ["l.get(1)\n        }\n}\n"], ["                count++;\n            }\n        }\n        return count;\n    }\n}\n"], ["public boolean anyInt(Object x, Object y, Object z) {"], ["class Solution {\n    public String encode(String message) {\n        String vowels = \"aeiouAEIOU\";\n        Map<Character, Character> vowelMap = new HashMap<>();\n        for (char vowel : vowels.toCharArray()) {\n            char shifted = shiftVowel(vowel);\n            vowelMap.put(vowel, shifted);\n            vowelMap.put(Character.toUpperCase(vowel), Character.toUpperCase(shifted));\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (char c : message.toCharArray()) {\n            char ch = c;\n            if (Character.isLetter(ch)) {\n                ch = Character.isUpperCase(ch) ? Character.toLowerCase(ch) : Character.toUpperCase(ch);\n                if (vowelMap.containsKey(ch)) {\n                    ch = vowelMap.get(ch);\n                }\n            }\n            sb.append(ch);\n        }\n        return sb.toString();\n    }\n\n    private char shiftVowel(char vowel) {\n        int shifted = vowel == 'e' || vowel == 'E' ? 2 : 1;\n        char next = (char) ((vowel - 'a' + shifted) % 26 + 'a');\n        return next;\n    }\n}\n"], ["class Solution {\n    /**\n    You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n     */\n\n    public int skjkasdkd(List<Integer> lst) {\n        int maxx = 0;\n        for (int i : lst) {\n            if (i > maxx) {\n                boolean isPrime = i != 1;\n                for (int j = 2; j < Math.sqrt(i) + 1; j++) {\n                    if (i % j == 0) {\n                        isPrime = false;\n                        break;\n                    }\n                }\n                if (isPrime) {\n                    maxx = i;\n                }\n            }\n        }\n        if (maxx == 0) {\n            return 0;\n        }\n        int sum = 0;\n        while (maxx > 0) {\n            sum += maxx % 10;\n            maxx /= 10;\n        }\n        return sum;"], ["public boolean checkDictCase(Map<Object, Object> dict) {\n    if (dict.isEmpty()) {\n        return false;\n    }\n    String state = \"start\";\n    for (Map.Entry entry : dict.entrySet()) {\n        if (!(entry.getKey() instanceof String key)) {\n            state = \"mixed\";\n            break;\n        }\n        boolean is_upper = true, is_lower = true;\n        for (char c : key.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                is_upper = false;\n            } else if (Character.isUpperCase(c)) {\n                is_lower = false;\n            } else {\n                return false; // if the key contains non-alphabet characters, return false\n            }\n        }\n        if (is_upper) {\n            if (!state.equals(\"upper\")) {\n                return false;\n            }\n        } else if (is_lower) {\n            if (!state.equals(\"lower\")) {\n                return false;\n            }\n        } else {\n            state = \"mixed\";\n        }\n    }\n    return state.equals(\"upper\") || state.equals(\"lower\");\n}\n"], ["class Solution {\n    /**\n    Implement a function that takes an non-negative integer and returns an array of the first n\n    integers that are prime numbers and less than n.\n    for example:\n    countUpTo(5) => [2,3]\n    countUpTo(11) => [2,3,5,7]\n    countUpTo(0) => []\n    countUpTo(20) => [2,3,5,7,11,13,17,19]\n    countUpTo(1) => []\n    countUpTo(18) => [2,3,5,7,11,13,17]\n     */\n\n    public List<Integer> countUpTo(int n) {\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < n; i++) {\n            boolean is_prime = true;\n            for (int j = 2; j < i; j++) {\n                if (i % j == 0) {\n                    is_prime = false;\n                    break;\n                }\n            }\n            if (is_prime) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n}\n"], ["class Solution {\n    public int multiply(int a, int b) {\n        return Math.abs(a % 10) * Math.abs(b % 10);\n    }\n}\n\n\nThis code defines a class called `Solution` with a method called `multiply` that takes two integers as parameters and returns the product of their unit digits. The `Math.abs` method is used to ensure that the product is always positive, even if one or both of the input integers are negative. The method calculates the unit digit of each integer using the modulo operator `%`, which returns the remainder of the division of the integer by 10. The method then multiplies these unit digits together and returns the result."], ["    }\n}\n"], ["class Solution {\n    public int closestInteger(String value) {\n        DecimalFormat df = new DecimalFormat(\"#\");\n        df.setRoundingMode(RoundingMode.HALF_UP);\n        \n        double num = Double.parseDouble(value);\n        \n        if (num < 0) {\n            return (int)Math.floor(Double.parseDouble(df.format(num)));\n        } else {\n            return (int)Math.ceil(Double.parseDouble(df.format(num)));\n        }\n    }\n}\n"], ["class Solution {\n\n    public List<Integer> makeAPile(int n) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            int numberOfStones = n + 2 * i;\n            result.add(numberOfStones);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> pile = solution.makeAPile(3);\n        for (int stoneCount : pile) {\n            System.out.println(stoneCount);\n        }\n    }\n}\n"], ["class Solution {\n    /**\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\").equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"))\n    words_string(\"One, two, three, four, five, six\").equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"))\n     */\n\n    public List<String> wordsString(String s) {\n        List<String> output = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n\n        for (char letter : s.toCharArray()) {\n            if (letter == ',') {\n                if (sb.length() > 0) {\n                    output.add(sb.toString());\n                    sb = new StringBuilder();\n                }\n            } else if (Character.isWhitespace(letter)) {\n                if (sb.length() > 0) {\n                    output.add(sb.toString());\n                    sb = new StringBuilder();\n                }\n            } else {\n                sb.append(letter);\n            }\n        }\n\n        if (sb.length() > 0) {\n            output.add(sb.toString());\n        }\n\n        return output;\n    }\n}\n"], ["public int chooseNum(int x, int y) {\n    if (x > y) {\n        return -1;\n    }\n    if (y % 2 == 0) {\n        return y;\n    }\n    if ((y - 1) >= x) {\n        return y - 1;\n    } else {\n        return -1;\n    }\n}\n"], ["public String roundedAvg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int sum = 0;\n    for (int i = n; i <= m; i++) {\n        sum += i;\n    }\n    int average = Math.round((float) sum / (m - n + 1));\n    return Integer.toBinaryString(average);\n}"], ["public List<Integer> uniqueDigits(List<Integer> x) {\n        List<Integer> odd_digit_elements = new ArrayList<>();\n        for (int i : x) {\n            boolean is_unique = true;\n            for (char c : String.valueOf(i).toCharArray()) {\n                if ((c - '0') % 2 == 0) {\n                    is_unique = false;\n                    break;\n                }\n            }\n            if (is_unique) odd_digit_elements.add(i);\n        }\n        Collections.sort(odd_digit_elements);\n        return odd_digit_elements;\n    }\n\n}\n"], ["class Solution {\n    /**\n    Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr = [2, 1, 1, 4, 5, 8, 2, 3]\n            -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]\n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\n      If the array is empty, return an empty array:\n      arr = []\n      return []\n\n      If the array has any strange number ignore it:\n      arr = [1, -1 , 55]\n            -> sort arr -> [-1, 1, 55]\n            -> reverse arr -> [55, 1, -1]\n      return = [\"One\"]\n     */\n\n    public List<String> byLength(List<Integer> arr) {\n        List<Integer> sorted_arr = new ArrayList<>(arr);\n        sorted_arr.sort(Collections.reverseOrder());\n        List<String> new_arr = new ArrayList<>();\n        for (int var : sorted_arr) {\n            if (var >= 1 && var <= 9) {\n                switch (var) {\n                    case 1 -> new_arr.add(\"One\");\n                    case 2 -> new_arr.add(\"Two\");\n                    case 3 -> new_arr.add(\"Three\");\n                    case 4 -> new_arr.add(\"Four\");\n                    case 5 -> new_arr.add(\"Five\");\n                    case 6 -> new_arr.add(\"Six"], ["public List<Integer> f(int n) {\n    List<Integer> ret = new ArrayList<>();\n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            int x = 1;\n            for (int j = 1; j <= i; j++) {\n                x *= j;\n            }\n            ret.add(x);\n        } else {\n            int x = 0;\n            for (int j = 1; j <= i; j++) {\n                x += j;\n            }\n            ret.add(x);\n        }\n    }\n    return ret;\n}\n"], ["                    odd_palindrome_count++;\n                }\n            }\n        }\n        List<Integer> result = new ArrayList<>();\n        result.add(even_palindrome_count);\n        result.add(odd_palindrome_count);\n        return result;\n    }\n}\n"], ["Complete code (including all the content of the code I provided and the code you generated)\npublic int countNums(List<Integer> arr) {\n    int count = 0;\n    for (int n: arr) {\n        int neg = 1;\n        if (n < 0) {\n            n = -n;\n            neg = -1;\n        }\n        \n        int sum = 0;\n        while (n > 0) {\n            sum += neg * (n % 10);\n            n /= 10;\n            neg = 1; // Reset neg to 1 after each digit is processed\n        }\n        \n        if (sum > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"], ["public boolean moveOneBall(List<Integer> arr) {\n    if (arr.size() == 0) {\n        return true;\n    }\n\n    List<Integer> sorted_arr = new ArrayList<>(arr);\n    Collections.sort(sorted_arr);\n\n    int count = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr.get(i).equals(sorted_arr.get(i))) {\n            count++;\n        }\n    }\n    if (count > 1) {\n        return false;\n    }\n    else if (count == 1) {\n        for (int i = 0; i < arr.size(); i++) {\n            if (!arr.get(i).equals(sorted_arr.get(i))) {\n                arr.add(i, arr.remove(arr.size() - 1));\n                break;\n            }\n        }\n    }\n    for (int i = 0; i < arr.size(); i++) {\n        if (!arr.get(i).equals(sorted_arr.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n"], ["class Solution {\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        int oddCnt1 = 0, evenCnt1 = 0, evenCnt2 = 0;\n\n        // Count odd and even numbers in lst1\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCnt1++;\n            } else {\n                evenCnt1++;\n            }\n        }\n\n        // Count even numbers in lst2\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCnt2++;\n            }\n        }\n\n        // If lst1 has an odd number and lst2 has enough even numbers, exchange is possible\n        if (oddCnt1 > 0 && evenCnt2 >= oddCnt1) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n}\n"], ["\n\nThis solution first finds the maximum frequency using the Collections.frequency method. Then, it iterates through the list of words again to add the letters with the maximum frequency to the dictionary."], ["class Solution {\n    /**\n    Task\n    We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n    then check if the result string is palindrome.\n    A string is called palindrome if it reads the same backward as forward.\n    You should return a tuple containing the result string and true/false for the check.\n    Example\n    For s = \"abcde\", c = \"ae\", the result should be (\"bcd\",false)\n    For s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",false)\n    For s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",true)\n     */\n    public List<Object> reverseDelete(String s, String c) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (c.indexOf(ch) == -1) {\n                sb.append(ch);\n            }\n        }\n        String result = sb.toString();\n        String reversed = sb.reverse().toString();\n        boolean isPalindrome = result.equals(reversed);\n        return Arrays.asList(result, isPalindrome);\n    }\n}\n"], ["class Solution {\n    public List<String> oddCount(List<String> lst) {\n        List<String> res = new ArrayList<>();\n        for (String s : lst) {\n            int count = 0;\n            for (char c : s.toCharArray()) {\n                if ((c - '0') % 2 == 1) {\n                    count++;\n                }\n            }\n            res.add(\"the number of odd elements \" + count + \"n the str\" + count + \"ng \" + count + \" of the \" + count + \"nput.\");\n        }\n        return res;\n    }\n}\n"], ["public int minSubArraySum(List<Integer> nums) {\n    int minSum = Integer.MAX_VALUE;\n    int sum = 0;\n    for (Integer num : nums) {\n        sum += num;\n        if (minSum > sum) {\n            minSum = sum;\n        }\n        if (sum > 0) {\n            sum = 0;\n        }\n    }\n    return minSum;\n}\n"], ["class Solution {\n    public int maxFill(List<List<Integer>> grid, int capacity) {\n        int totalBucketActions = 0;\n        for (List<Integer> row : grid) {\n            int rowWaterUnits = row.stream().mapToInt(Integer::intValue).sum();\n            totalBucketActions += Math.ceil((double) rowWaterUnits / capacity);\n        }\n        return totalBucketActions;\n    }\n}\n"], ["            if (cnt1 == cnt2) {\n                    return o1 - o2;\n            }\n            return cnt1 - cnt2;\n        });\n        return sorted_arr;\n    }\n}\n"], ["class Solution {\n    public List<String> selectWords(String s, int n) {\n        List<String> result = new ArrayList<>();\n        for (String word : s.split(\" \")) {\n            int n_consonants = 0;\n            for (char c : word.toCharArray()) {\n                c = Character.toLowerCase(c);\n                if (\"aeiou\".indexOf(c) == -1) {\n                    n_consonants++;\n                }\n            }\n            if (n_consonants == n) {\n                result.add(word);\n            }\n        }\n        return result;\n    }\n}\n"], ["class Solution {\n    public String getClosestVowel(String word) {\n        if (word.length() < 3) {\n            return \"\";\n        }\n\n        String vowels = \"aeiouAEIOU\";\n        StringBuilder result = new StringBuilder();\n        Stack<Integer> consonantsIndex = new Stack<>();\n\n        // Find the indices of consonants from the right side of the word\n        for (int i = word.length() - 1; i > 0; i--) {\n            char c = word.charAt(i);\n            if (!vowels.contains(String.valueOf(c))) {\n                consonantsIndex.push(i);\n            }\n        }\n\n        // Check consonants in reverse order and find the closest vowel\n        for (int i = word.length() - 1; i > 0; i--) {\n            char c = word.charAt(i);\n            if (vowels.contains(String.valueOf(c)) && !consonantsIndex.isEmpty()) {\n                result.append(c);\n                break;\n            } else if (consonantsIndex.isEmpty()) {\n                break;\n            } else {\n                consonantsIndex.pop();\n            }\n        }\n\n        return result.toString();\n    }\n}\n"], ["class Solution {\n    public String matchParens(List<String> lst) {\n        List<String> S = Arrays.asList(lst.get(0) + lst.get(1), lst.get(1) + lst.get(0));\n        for (String s : S) {\n            int val = 0;\n            for (char i : s.toCharArray()) {\n                if (i == '(') {\n                    val += 1;\n                } else if (i == ')') {\n                    val -= 1;\n                    if (val < 0) {\n                        break;\n                    }\n                }\n            }\n            if (val == 0) {\n                return \"Yes\";\n            }\n        }\n        return \"No\";\n    }\n}\n"], ["    public List<Integer> maximum(List<Integer> arr, int k) {\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n        for (int num : arr) {\n            minHeap.offer(num);\n            if (minHeap.size() > k) {\n                minHeap.poll();\n            }\n        }\n        \n        List<Integer> res = new ArrayList<>();\n        while (!minHeap.isEmpty()) {\n            res.add(minHeap.poll());\n        }\n        Collections.reverse(res);\n        return res;\n    }\n"], ["class Solution {\n    /**\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution(Arrays.asList(5, 8, 7, 1)) ==> 12\n    solution(Arrays.asList(3, 3, 3, 3, 3)) ==> 9\n    solution(Arrays.asList(30, 13, 24, 321)) ==>0\n     */\n\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i += 2) {\n            if ((lst.get(i) % 2) == 1) {\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n}\n"], ["class Solution {\n    /**\n    Given a non-empty array of integers arr and an integer k, return\n\n\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n     */\n    public int addElements(List<Integer> arr, int k) {\n        arr = arr.subList(0, k);\n        Optional<Integer> sum = arr.stream().filter(p -> String.valueOf(Math.abs(p)).length() <= 2).reduce(Integer::sum);\n        return sum.orElse(0);\n    }\n}\n\n"], ["class Solution {\n    public List<Integer> getOddCollatz(int n) {\n        List<Integer> odd_collatz = new ArrayList<>();\n        if (n % 2 == 1) {\n            odd_collatz.add(n);\n        }\n        while (n > 1) {\n            if (n % 2 == 0) {\n                n = n / 2;\n            } else {\n                odd_collatz.add(n);\n                n = 3 * n + 1;\n            }\n        }\n        Collections.sort(odd_collatz);\n        return odd_collatz;\n    }\n}\n"], ["    public boolean validDate(String date) {\n        String[] parts = date.split(\"-\");\n        if (parts.length != 3) {\n            return false;\n        }\n\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        if (month < 1 || month > 12 || day < 1) {\n            return false;\n        }\n\n        int[] daysInMonth = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n        if (day > daysInMonth[month - 1]) {\n            return false;\n        }\n\n        return true;\n    }\n}\n"], ["class Solution {\n    public Object splitWords(String txt) {\n        if (txt.contains(\" \" )) {\n            return Arrays.asList(txt.split(\" \" ));\n        } else if (txt.contains(\",\" )) {\n            return Arrays.asList(txt.split(\"[,\\s]\" ));\n        } else {\n            int oddOrderLetters = 0;\n            for (char c : txt.toCharArray()) {\n                if ((c - 'a') % 2 == 0) {\n                    oddOrderLetters++;\n                }\n            }\n            return oddOrderLetters;\n        }\n    }\n}\n"], ["    public boolean isSorted(List<Integer> lst) {\n        // Check if list is already sorted\n        for (int i = 0; i < lst.size() - 1; i++) {\n            if (lst.get(i) > lst.get(i + 1)) {\n                return false;\n            }\n        }\n        \n        // Check for duplicates greater than 1\n        Map<Integer, Integer> countMap = new HashMap<>();\n        for (int num : lst) {\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n        }\n        for (int count : countMap.values()) {\n            if (count > 1) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n"], ["if (isPrime(length)) {\n    return \"YES\";\n} else {\n    return \"NO\";\n}\n}\n\n    private boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"], ["class Solution {\n    public Optional<Integer> prodSigns(List<Integer> arr) {\n        if (arr.size() == 0) {\n            return Optional.empty();\n        }\n        \n        int prodOfSigns = 1;\n        int sumOfMagnitudes = 0;\n        \n        for (int num : arr) {\n            prodOfSigns *= Math.signum(num);\n            sumOfMagnitudes += Math.abs(num);\n        }\n        \n        return Optional.of(sumOfMagnitudes * prodOfSigns);\n    }\n}\n"], ["class Solution {\n    /**\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n     */\n\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        List<int[]> neighbors = new ArrayList<>();\n        int n = grid.size();\n        for (int i = 0; i < n; i++) {"], ["class Solution {\n    /**\n    Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8\n    You are given a non-negative integer number n, you have to a return a list of the\n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n     */\n\n    public List<Integer> tri(int n) {\n        if (n == 0) {\n            return List.of(1);\n        }\n        List<Integer> my_tri = new ArrayList<>(Arrays.asList(1, 3));\n        for (int i = 2; i <= n; i++) {\n            int nextValue;\n            if (i % 2 == 0) {\n                nextValue = (int) (1 + i / 2);\n            } else {\n                int index = i / 2;\n                nextValue = my_tri.get(index) + my_tri.get(index - 1) + (index + 2 > my_tri.size() ? 3 : my_tri.get(index + 2));\n            }\n            my_tri.add(nextValue);\n        }\n        return my_tri;\n    }\n}\n"], ["class Solution {\n    public int digits(int n) {\n        int product = 1, odd_count = 0;\n        for (char digit : String.valueOf(n).toCharArray()) {\n            int int_digit = digit - '0';\n            if (int_digit % 2 == 1) {\n                product *= int_digit;\n                odd_count++;\n            }\n        }\n        return odd_count % 2 != 0 ? product : 0;\n    }\n}\n"], ["class Solution {\n    /**\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets\n\n    where at least one bracket in the subsequence is nested.\n\n    isNested(\"[[]]\") -> true\n    isNested(\"[]]]]]]][[[[[]\") -> false\n    isNested(\"[][]\") -> false\n    isNested(\"[]\") -> false\n    isNested(\"[[][]]\") -> true\n    isNested(\"[[]][[\") -> true\n     */\n    public boolean isNested(String string) {\n        if (string == null || string.isEmpty()) {\n            return false;\n        }\n        Stack<Integer> stack = new Stack<>();\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < string.length(); i++) {\n            char c = string.charAt(i);\n            if (c == '[') {\n                stack.push(i);\n            } else {\n                if (!stack.isEmpty()) {\n                    map.put(i, stack.pop());\n                } else {\n                    return false;\n                }\n            }\n        }\n        boolean nested = false;\n        for (Integer v : map.values()) {\n            for (int i = v; i < string.length(); i++) {\n                if (string.charAt(i) == '[') {\n                    nested = true;\n                    break;\n                } else if (string.charAt(i) == ']') {\n                    break;\n                }\n            }\n            if (nested) {\n                break;\n            }\n        }\n        return nested;\n    }\n}\n"], ["class Solution {\n    /**\n    You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6\n     */\n    public int sumSquares(List<Double> lst) {\n        return lst\n                .stream()\n                .map(p -> (int) Math.ceil(p)) // round each element in the list to the upper int(Ceiling)\n                .map(p -> p * p) // square each number\n                .reduce(Integer::sum) // sum all squared numbers\n                .orElse(0);\n    }\n}\n"], ["class Solution {\n    public boolean checkIfLastCharIsALetter(String txt) {\n        String[] words = txt.split(\" \", -1);\n        String check = words[words.length - 1];\n        if (check.isEmpty()) {\n            return false;\n        }\n        char lastChar = check.charAt(check.length() - 1);\n        if (!Character.isLetter(lastChar)) {\n            return false;\n        }\n        if (check.length() == 1 || !Character.isLetter(check.charAt(check.length() - 2))) {\n            return true;\n        }\n        return false;\n    }\n}\n"], ["class Solution {\n    public int canArrange(List<Integer> arr) {\n        int ind = -1, i = 1;\n        while (i < arr.size()) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                ind = i;\n            }\n            i++;\n        }\n        return ind;\n    }\n}\n"], ["public Optional<Integer> largestSmallestIntegers(List<Integer> lst){\n  Optional<Integer> smallest = lst.stream()\n                                    .filter(p -> p < 0)\n                                    .max(Integer::compare);\n  Optional<Integer> largest = lst.stream()\n                                   .filter(p -> p > 0)\n                                   .min(Integer::compare);\n  return List.of(largest, smallest);\n}\n"], ["class Solution {\n    //*\n//Create a function that takes integers, floats, or strings representing\n//real numbers, and returns the larger variable in its given variable type.\n//Return None if the values are equal.\n//Note: If a real number is represented as a string, the floating point might be . or ,\n//\n//compareOne(1, 2.5) -> Optional.of(2.5)\n//compareOne(1, \"2,3\") -> Optional.of(\"2,3\")\n//compareOne(\"5,1\", \"6\") -> Optional.of(\"6\")\n//compareOne(\"1\", 1) -> Optional.empty()\n\n    public Optional<Object> compareOne(Object a, Object b) {\n        double temp_a = 0, temp_b = 0;\n        if (a instanceof Integer) {\n            temp_a = (Integer) a * 1.0;\n        } else if (a instanceof Double) {\n            temp_a = (double) a;\n        } else if (a instanceof String) {\n            temp_a = Double.parseDouble(((String) a).replace(',', '.'));\n        }\n\n        if (b instanceof Integer) {\n            temp_b = (Integer) b * 1.0;\n        } else if (b instanceof Double) {\n            temp_b = (double) b;\n        } else if (b instanceof String) {\n            temp_b = Double.parseDouble(((String) b).replace(',', '.'));\n        }\n\n        if (temp_a > temp_b) {\n            return Optional.of(a);\n        } else if (temp_b > temp_a) {\n            return Optional.of(b);\n        } else {\n            return Optional.empty();\n        }\n    }\n}\n"], ["class Solution {\n    public boolean isEqualToSumEven(int n) {\n        // *\n        // Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n        // Example\n        // isEqualToSumEven(4) == false\n        // isEqualToSumEven(6) == false\n        // isEqualToSumEven(8) == true\n        return n % 2 == 0 && n >= 8;\n    }\n}\n"], ["class Solution {\n    public long specialFactorial(int n) {\n        long fact_i = 1, special_fact = 1;\n        for (int i = 1; i <= n; i++) {\n            fact_i *= i;\n            special_fact *= fact_i;\n        }\n        return special_fact;\n    }\n}\n"], ["    public String fixSpaces(String text) {\n        StringBuilder sb = new StringBuilder();\n        int start = 0, end = 0;\n        while (end < text.length()) {\n            if (text.charAt(end) == ' ') {\n                end += 1;\n            } else {\n                if (end - start > 2) {\n                    sb.append('-');\n                } else if (end - start > 0) {\n                    sb.append(text.substring(start, end));\n                }\n                start = end;\n            }\n        }\n        return sb.toString();\n    }\n"], ["String fileName = \"example.txt\";\nString result = fileNameCheck(fileName);\nSystem.out.println(result); // Outputs: \"Yes\"\n"], ["        else {\n            result.add(lst.get(i));\n        }\n    }\n    \n    int sum = 0;\n    for (int num : result) {\n        sum += num;\n    }\n\n    return sum;\n}\n}\n\n"], ["class Solution {\n    private boolean isPrime(int n) {\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n        if (n % 2 == 0 || n % 3 == 0) return false;\n        for (int i = 5; i * i <= n; i += 6) {\n            if (n % i == 0 || n % (i + 2) == 0) return false;\n        }\n        return true;\n    }\n\n    public String wordsInSentence(String sentence) {\n        List<String> new_lst = new ArrayList<>();\n        for (String word : sentence.split(\" \" )) {\n            if (isPrime(word.length())) {\n                new_lst.add(word);\n            }\n        }\n        return String.join(\" \", new_lst);\n    }\n}\n"], ["class Solution {\n    /**\n    Your task is to implement a function that will simplify the expression\n    x * n. The function returns true if x * n evaluates to a whole number and false\n    otherwise. Both x and n, are string representation of a fraction, and have the following format,\n    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n    simplify(\"1/5\", \"5/1\") = true\n    simplify(\"1/6\", \"2/1\") = false\n    simplify(\"7/10\", \"10/2\") = false\n     */\n\n    public boolean simplify(String x, String n) {\n        String[] a = x.split(\"/\");\n        String[] b = n.split(\"/\");\n        int numerator = Integer.parseInt(a[0]) * Integer.parseInt(b[0]);\n        int denominator = Integer.parseInt(a[1]) * Integer.parseInt(b[1]);\n\n        return numerator % denominator == 0;\n    }\n}\n"], ["class Solution {\n        /**\n        Write a function which sorts the given list of integers\n        in ascending order according to the sum of their digits.\n        Note: if there are several items with similar sum of their digits,\n        order them based on their index in original list.\n\n        For example:\n        >>> orderByPoints(Arrays.asList(1, 11, -1, -11, -12)) == [-1, -11, 1, -12, 11]\n        >>> orderByPoints(Arrays.asList()) == []\n         */\n\n        public List<Integer> orderByPoints(List<Integer> nums) {\n            List<Integer> result = new ArrayList<>(nums);\n            result.sort((o1, o2) -> {\n                int sum1 = 0;\n                int sum2 = 0;\n\n                for (int i = 0; i < String.valueOf(o1).length(); i++) {\n                    if (i != 0 || o1 >= 0) {\n                        sum1 += (String.valueOf(o1).charAt(i) - '0' );\n                    }\n                    if (i != 0 || o2 >= 0) {\n                        sum2 += (String.valueOf(o2).charAt(i) - '0' );\n                    }\n                }\n\n                int diff = sum1 - sum2;\n                if (diff == 0) {\n                    return Integer.compare(nums.indexOf(o1), nums.indexOf(o2));\n                }\n\n                return diff;\n            });\n\n            return result;\n        }\n    }\n"], ["       if (odd_digits.contains(number_as_string.substring(0, 1)) && odd_digits.contains(number_as_string.substring(number_as_string.length() - 1))) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n"], ["class Solution {\n    /**\n    You are given a positive integer n. You have to create an integer array a of length n.\n        For each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example :\n        Input: n = 5\n        Output: 1\n        Explanation:\n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n     */\n\n    public int getMaxTriples(int n) {\n        List<Integer> A = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            A.add(i * i - i + 1);\n        }\n        int count = 0;\n        for (int i = 0; i < A.size(); i++) {\n            for (int j = i + 1; j < A.size(); j++) {\n                for (int k = j + 1; k < A.size(); k++) {\n                    if ((A.get(i) + A.get(j) + A.get(k)) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n}\n"], ["    return new ArrayList<>(planet_names.subList(planet1_index + 1, planet2_index));\n    }\n}\n"], ["for (int i = 0; i < lst_sorted.size(); i++) {\n    if (lst_sorted.get(i).length() % 2 == 0) {\n        new_lst.add(lst_sorted.get(i));\n    }\n}\nreturn new_lst;\n"], ["public boolean isPrime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic int xOrY(int n, int x, int y) {\n    return isPrime(n) ? x : y;\n}\n"], ["class Solution {\n   // ... (include all the content of the original code I provided)\n}\n\npackage java.util;\n\npublic class List<E> {\n   // ... (include all the content of the original code I provided)\n}\n\nclass Solution {\n   public static List<Object> asList(Object... a) {\n      // Implementation of the asList method\n   }\n}\n\nclass Solution {\n   public static boolean parseInt(String s) {\n      // Implementation of the parseInt method\n   }\n}\n\nclass Solution {\n   public Stream filter(Predicate predicate) {\n      // Implementation of the filter method\n   }\n\n   public Stream map(Function function) {\n      // Implementation of the map method\n   }\n\n   public Stream reduce(BinaryOperator binaryOperator) {\n      // Implementation of the reduce method\n   }\n}\n\npublic interface Predicate {\n   boolean test(Object o);\n}\n\npublic interface Function {\n   Object apply(Object o);\n}\n\npublic interface BinaryOperator {\n   Object apply(Object o1, Object o2);\n}\n\nclass Solution {\n   public static <T> Optional of(T value) {\n      // Implementation of the of method\n   }\n\n   public int orElse(int other) {\n      // Implementation of the orElse method\n   }\n}\n\nclass Solution {\n   public static List<Object> asList(Object... a) {\n      return new ArrayList<>(Arrays.asList(a));\n   }\n}\n\nclass Solution {\n   public static int parseInt(String s) {\n      // Implementation of the parseInt method\n   }\n}\n\nclass Solution {\n   private Object[] elements;\n\n   public Stream(Object[] elements) {\n      this.elements = elements;\n   }\n\n   public Stream filter(Predicate predicate) {\n      return new Stream(Arrays.stream(elements).filter(predicate::test).toArray(Object[]::new));\n   }\n\n   public Stream map(Function function) {\n      return new Stream(Arrays.stream(elements).map(function::apply"], ["class Solution {\n    /**\n    I think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n    Your task is to determine if a person correctly guessed the results of a number of matches.\n    You are given two arrays of scores and guesses of equal length, where each index shows a match.\n    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.\n\n    example:\n\n    compare(Arrays.asList(1,2,3,4,5,1),Arrays.asList(1,2,3,4,2,-2)) -> [0,0,0,0,3,3]\n    compare(Arrays.asList(0,5,0,0,0,4),Arrays.asList(4,1,1,0,0,-2)) -> [4,4,1,0,0,6]\n     */\n\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            result.add(Math.abs(game.get(i) - guess.get(i)));\n        }\n        return result;\n    }\n}"], ["class Solution {\n    public String StrongestExtension(String class_name, List<String> extensions) {\n        String strong = extensions.get(0);\n        int my_val = (int) (strong.chars().filter(Character::isUpperCase).count() - strong.chars().filter(Character::isLowerCase).count());\n        for (String s : extensions) {\n            int val = (int) (s.chars().filter(Character::isUpperCase).count() - s.chars().filter(Character::isLowerCase).count());\n            if (val > my_val) {\n                strong = s;\n                my_val = val;\n            } else if (val == my_val && extensions.indexOf(s) < extensions.indexOf(strong)) {\n                strong = s;\n            }\n        }\n        return class_name + \".\" + strong;\n    }\n}\n"], ["class Solution {\n    /**\n    You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n    cycpatternCheck(\"abcd\",\"abd\") => false\n    cycpatternCheck(\"hello\",\"ell\") => true\n    cycpatternCheck(\"whassup\",\"psus\") => false\n    cycpatternCheck(\"abab\",\"baa\") => true\n    cycpatternCheck(\"efef\",\"eeff\") => false\n    cycpatternCheck(\"himenss\",\"simen\") => true\n     */\n\n    public boolean cycpatternCheck(String a, String b) {\n        int l = b.length();\n        String pat = b + b;\n        for (int i = 0; i <= a.length() - l; i++) {\n            for (int j = 0; j <= l; j++) {\n                if (a.substring(i, i + l).equals(b.substring(j, j + l))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n"], ["class Solution {\n    /**\n    Given an integer. return a tuple that has the number of even and odd digits respectively.\n    \n     Example:\n        evenOddCount(-12) ==> (1, 1)\n        evenOddCount(123) ==> (1, 2)\n\n\n     */\n    public List<Integer> evenOddCount(int num) {\n        List<Integer> counts = new ArrayList<>();\n        int even_count = 0, odd_count = 0;\n        for (char i : String.valueOf(Math.abs(num)).toCharArray()) {\n            if ((i - '0') % 2 == 0) {\n                even_count += 1;\n            } else {\n                odd_count += 1;\n            }\n        }\n        counts.add(even_count);\n        counts.add(odd_count);\n        return counts;\n    }\n}\n"], ["class Solution {\n    //*\n//Given a positive integer, obtain its roman numeral equivalent as a string,\n//and return it in lowercase.\n//Restrictions: 1 <= num <= 1000\n//\n//Examples:\n//>>> intToMiniRoman(19) == \"xix\"\n//>>> intToMiniRoman(152) == \"clii\"\n//>>> intToMiniRoman(426) == \"cdxxvi\"\n    public String intToMiniRoman(int number) {\n        List<Integer> num = Arrays.asList(1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000);\n        List<String> sym = Arrays.asList(\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\");\n        int i = 12;\n        String res = \"\";\n        while (number > 0) {\n            int div = number / num.get(i);\n            number %= num.get(i);\n            res = (div > 0 ? sym.get(i) : \"\") + res;\n            i--;\n        }\n        return res;\n    }\n}\n"], ["class Solution {\n    /**\n    Given the lengths of the three sides of a triangle. Return true if the three\n    sides form a right-angled triangle, false otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or\n    90 degree.\n    Example:\n    rightAngleTriangle(3, 4, 5) == true\n    rightAngleTriangle(1, 2, 3) == false\n     */\n    public boolean rightAngleTriangle(int a, int b, int c) {\n        int sides[] = new int[3];\n        sides[0] = a;\n        sides[1] = b;\n        sides[2] = c;\n        Arrays.sort(sides);\n        return Math.pow(sides[2], 2) == Math.pow(sides[0], 2) + Math.pow(sides[1], 2);\n    }\n}\n"], ["class Solution {\n    /**\n    Write a function that accepts a list of strings.\n    The list contains different words. Return the word with maximum number\n    of unique characters. If multiple strings have maximum number of unique\n    characters, return the one which comes first in lexicographical order.\n\n    findMax([\"name\", \"of\", \"string\"]) == \"string\"\n    findMax([\"name\", \"enam\", \"game\"]) == \"enam\"\n    findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"aaaaaaa\"\n     */\n\n    public String findMax(List<String> words) {\n        // Add the words to a TreeSet for lexicographical sorting\n        // We will use a TreeSet because it maintains elements in natural order\n        TreeSet<String> sortedWords = new TreeSet<>(Comparator.comparingInt(o -> {\n            // Use HashSet to get the count of unique characters in each string\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : o.toCharArray()) {\n                uniqueChars.add(c);\n            }\n            // Return the number of unique characters in each string\n            return uniqueChars.size();\n        }));\n\n        // Add the words to the TreeSet\n        words.forEach(sortedWords::add);\n\n        // Return the last word which is the one with maximum unique characters\n        return sortedWords.last();\n    }\n}\n"], ["class Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        if (need <= remaining) {\n            return Arrays.asList(number + need, remaining - need);\n        } else {\n            return Arrays.asList(number + remaining, 0);\n        }\n    }\n}\n"], ["class Solution {\n    private static Map<String, Integer> precedence = new HashMap<>();\n    static {\n        precedence.put(\"**\", 3);\n        precedence.put(\"*\", 2);\n        precedence.put(\"/\", 2);\n        precedence.put(\"+\", 1);\n        precedence.put(\"-\", 1);\n    }\n\n    public int doAlgebra(List<String> operators, List<Integer> operands) {\n        Stack<Integer> nums = new Stack<>();\n        Stack<String> ops = new Stack<>();\n        for (int i = 0; i < operands.size(); i++) {\n            nums.push(operands.get(i));\n            if (i < operators.size()) {\n                while (!ops.isEmpty() && precedence.get(ops.peek()) >= precedence.get(operators.get(i))) {\n                    int r = nums.pop();\n                    int l = nums.pop();\n                    int op = solve(ops.pop(), l, r);\n                    nums.push(op);\n                }\n                ops.push(operators.get(i));\n            }\n        }\n        while (!ops.isEmpty()) {\n            int r = nums.pop();\n            int l = nums.pop();\n            int op = solve(ops.pop(), l, r);\n            nums.push(op);\n        }\n        return nums.pop();\n    }\n\n    private int solve(String op, int l, int r) {\n        switch (op) {\n            case \"+\":\n                return l + r;\n            case \"-\":\n                return l - r;\n            case \"*\":\n                return l * r;\n            case \"/\":\n                return l / r;\n            case \"**\":\n                return (int) Math.pow(l, r);\n        }\n        return 0;\n    }\n}\n"], ["class Solution {\n\n    public String solve(String s) {\n        boolean flag = true;\n        StringBuilder new_string = new StringBuilder();\n        for (char i : s.toCharArray()) {\n            if (Character.isUpperCase(i)) {\n                new_string.append(Character.toLowerCase(i));\n                flag = false;\n            } else if (Character.isLowerCase(i)) {\n                new_string.append(Character.toUpperCase(i));\n                flag = false;\n            } else {\n                new_string.append(i);\n            }\n        }\n\n        if (flag) return new_string.reverse().toString();\n        else return new_string.toString();\n    }\n}\n"], ["class Solution {\n    /**\n    Given a string \"text\", return its md5 hash equivalent string with length being 32.\n    If \"text\" is an empty string, return Optional.empty().\n    \n    >>> stringToMd5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n     */\n    public Optional<String> stringToMd5(String text) throws NoSuchAlgorithmException {\n        if (text.isEmpty()) {\n            return Optional.empty();\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] messageDigest = md.digest(text.getBytes());\n        BigInteger no = new BigInteger(1, messageDigest);\n        String hashtext = no.toString(16);\n        while (hashtext.length() < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n        return Optional.of(hashtext);\n    }\n}\n"], ["        for (int i = lower; i <= upper; i++) {\n            if (i % 2 == 0) {\n                result.add(i);\n            }\n        }\n        \n        return result;\n    }\n}\n"]]