[["def check_dict_case(dictionary):\n    if dictionary:\n        keys_lower = all(isinstance(key, str) and key.islower() for key in dictionary.keys())\n        keys_upper = all(isinstance(key, str) and key.isupper() for key in dictionary.keys())\n        return keys_lower or keys_upper\n    return False\n"], ["def get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\n    odd_collatz = []\n    while n > 1:\n        if not(n%2==0):\n            odd_collatz.append(n)\n        n = n//2 if n%2==0 else 3*n+1\n    return sorted(odd_collatz)\n"], ["def is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n\n    open_brackets = []\n    close_brackets = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            open_brackets.append(i)\n        elif string[i] == ']':\n            close_brackets.append(i)\n    close_brackets = close_brackets[::-1]\n\n    nested_count = 0\n    close_bracket_index = 0\n    for open_bracket in open_brackets:\n        if close_bracket_index < len(close_brackets):\n            if open_bracket > close_brackets[close_bracket_index]:\n                nested_count += 1\n                close_bracket_index += 1\n    return nested_count > 0\n"], ["def fix_spaces(text):\n    new_text = \"\"\n    i = 0\n    count = 0\n    while i < len(text):\n        if text[i] == \" \":\n            count += 1\n        else:\n            if count == 0:\n                new_text += text[i]\n            if count == 1:\n                new_text += \"_\"\n            if count == 2:\n                new_text += \"_\"\n            if count > 2:\n                new_text += \"-\"\n            count = 0\n            new_text += text[i]\n        i += 1\n    return new_text\n"]]