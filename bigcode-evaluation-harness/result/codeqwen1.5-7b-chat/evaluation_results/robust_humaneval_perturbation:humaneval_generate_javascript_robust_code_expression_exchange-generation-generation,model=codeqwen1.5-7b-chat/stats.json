[
  {
    "name": {
      "name": "full_level_robustness",
      "split": "test"
    },
    "count": 65,
    "generations": [
      [
        "const hasCloseElements = (numbers, threshold) => {\n  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (j != i) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};"
      ],
      [
        "const separateParenGroups = (paren_string) => {\n  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if ('(' == c) {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (')' == c) {\n      current_depth -= 1;\n      current_string.push(c);\n      if (0 == current_depth) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n};"
      ],
      [
        "/**\n * Calculates whether the balance falls below zero given a series of transactions.\n * @param {number[]} transactions - Array of integers representing deposits and withdrawals.\n * @returns {boolean} - Returns true if balance falls below zero at any point, false otherwise.\n */\nconst belowZero = (transactions) => {\n  let balance = 0;\n  for (const transaction of transactions) {\n    balance += transaction;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};"
      ],
      [
        "const intersperse = (numbers, delimeter) => {\n  if (!Array.isArray(numbers) || 0 == numbers.length)\n    return [];\n  var result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i]);\n    if (i < numbers.length - 1) {\n      result.push(delimeter);\n    }\n  }\n  return result;\n};"
      ],
      [
        "// Complete code\nconst parseNestedParens = (paren_string) => {\n  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if ('(' == c) {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      }\n      else if (')' == c) {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ').map(parseParenGroup);\n}"
      ],
      [
        "/**\n * @param {string[]} strings\n * @param {string} substring\n * @return {string[]}\n */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(x => -1 != x.indexOf(substring));\n}"
      ],
      [
        "const sumProduct = (numbers) => {\n  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}"
      ],
      [
        "/**\n * rollingMax computes the maximum of rolling sub-sequences.\n * @param {number[]} numbers\n * @return {number[]}\n */\nconst rollingMax = (numbers) => {\n    let running_max, result = [];\n    for (const n of numbers) {\n        if (undefined == running_max)\n            running_max = n;\n        else\n            running_max = Math.max(running_max, n);\n\n        result.push(running_max);\n    }\n\n    return result;\n};"
      ],
      [
        "const isPalindrome = (string) => {\n  return string.split('').reverse().join('') == string;\n}\n\nconst makePalindrome = (string) => {\n  if ('' == string)\n    return '';\n  var beginning_of_suffix = 0;\n  \n  while (!isPalindrome(string.substring(beginning_of_suffix)))\n    beginning_of_suffix++;\n\n  return string + string.substring(0, beginning_of_suffix).split('').reverse().join('');\n}"
      ],
      [
        "const stringXor = (a, b) => {\n  return a.split('').map((bit, i) => (bit === b[i]) ? '0' : '1').join('');\n}"
      ],
      [
        "const longest = (strings) => {\n  if (!Array.isArray(strings) || 0 == strings.length)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen)\n      return s;\n  }\n};"
      ],
      [
        "const greatestCommonDivisor = (a, b) => {\n    while (b !== 0) {\n      let temp = a;\n      a = b;\n      b = temp % b;\n    }\n    return a;\n  };"
      ],
      [
        "const allPrefixes = (string) => {\n  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, 1 + i));\n  }\n  return result;\n};"
      ],
      [
        "const parseMusic = (music_string) => {\n  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => '' != x).map(x => note_map[x]);\n}"
      ],
      [
        "const howManyTimes = (string, substring) => {\n  var times = 0;\n  for (let i = 0; i < 1 + string.length - substring.length; i++) {\n    if (substring == string.slice(i, i+substring.length)) {\n      times += 1;\n    }\n  }\n  return times;\n};"
      ],
      [
        "let closestPair = [numbers[0], numbers[1]];\nlet minDist = Math.abs(numbers[1] - numbers[0]);\nfor (let i = 0; i < numbers.length; i++) {\n    for (let j = i + 1; j < numbers.length; j++) {\n        if (j != i) {\n            let currentDist = Math.abs(numbers[j] - numbers[i]);\n            if (currentDist < minDist) {\n                minDist = currentDist;\n                closestPair = [numbers[i], numbers[j]];\n            }\n        }\n    }\n}\nclosestPair.sort((a, b) => a - b);\nreturn closestPair;"
      ],
      [
        "const largestDivisor = (n) => {\n  for (let i = n - 1; i >= 0; i--) {\n    if (0 == n % i) {\n      return i; // found the largest divisor, return it\n    }\n  }\n  return 1; // if no divisor is found, return 1 (every number is divisible by itself and 1)\n};"
      ],
      [
        "const factorize = (n) => {\n  var fact = [], i = 2;\n  while (i <= 1 + Math.sqrt(n)) {\n    if (0 == n % i) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return fact;\n};"
      ],
      [
        "// No package import required for this code\nconst removeDuplicates = (numbers) => {\n  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] = dict[num] + (1);\n    } else {\n      dict[num] = 1;\n    }\n  }\n  const array = Object.keys(dict).map(Number);\n  return array.filter(num => dict[num] === 1);\n}"
      ],
      [
        "const flipCase = (string) => {\n  return string.split('')\n          .map(x => (x == x.toUpperCase() ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n};"
      ],
      [
        "const isPrime = (n) => {\n  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++) {\n    if (n % k === 0) {\n      return false;\n    }\n  }\n  return true;\n};"
      ],
      [
        "// Function to evaluate polynomial at a point x\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n// Function to find a zero point of a polynomial having an even number of coefficients\nconst findZero = (xs) => {\n  let begin = -1.0, end = 1.0;\n  \n  // Ensure the function has at least two non-zero coefficients\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin = begin * 2.0;\n    end = end * 2.0;\n  }\n  \n  // Bisection method to find a zero point\n  while (end - begin > 1e-10) {\n    let mid = (begin + end) / 2.0;\n    \n    if (poly(xs, mid) * poly(xs, begin) > 0) {\n      begin = mid;\n    } else {\n      end = mid;\n    }\n  }\n  \n  return begin;\n}"
      ],
      [
        "const sortThird = (l) => {\n  var three = l.filter((item, index) => 0 == index % 3);\n  three.sort((a, b) => (a - b));\n  var inds = l.map((item, index) => 0 == index % 3 ? three.shift() : item);\n  return inds;\n}"
      ],
      [
        "const fizzBuzz = (n) => {\n  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++) {\n    if (0 == i % 11 || 0 == i % 13) {\n      ns.push(i);\n    }\n  }\n  ns.forEach(num => {\n    const numStr = num.toString();\n    for (let i = 0; i < numStr.length; i++) {\n      if (numStr[i] === '7') ans++;\n    }\n  });\n  return ans;\n};"
      ],
      [
        "const sortEven = (l) => {\n    let even = l.filter((item, index) => 0 === index % 2);\n    even.sort((a, b) => a - b);\n\n    let result = [...l];\n    result.forEach((item, index) => {\n        if (0 === index % 2) {\n            result[index] = even.shift();\n        }\n    });\n\n    return result;\n}"
      ],
      [
        "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((2 + s.length) / 3); i++) {\n    groups.push(s.slice(i * 3, Math.min((3 + i * 3), s.length)));\n  }\n  for (const group of groups) {\n    if (3 == group.length)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  return encodeCyclic(encodeCyclic(s));\n}"
      ],
      [
        "const primeFib = (n) => {\n  let counter = 0, i = 1;\n  let a = 1, b = 1;\n\n  while (counter < n) {\n    a = a < b ? a + b : a - b;\n    b = a < b ? a + b : a - b;\n\n    if (isPrime(a)) {\n      counter++;\n    }\n  }\n  \n  return a;\n};\n\nconst isPrime = (p) => {\n  if (p < 2)\n    return 0;\n  for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n    if (p % k == 0)\n      return 0;\n  }\n\n  return 1;\n};"
      ],
      [
        "/**\n * Find three elements in array that sum up to zero\n * \n * @param {Array<number>} l - Input array of integers\n * @return {boolean} true if three elements sum up to zero, false otherwise\n */\nconst triplesSumToZero = (l) => {\n  const sortedList = l.sort((a, b) => a - b);\n  for (let i = 0; i < sortedList.length - 2; i++) {\n    let left = i + 1;\n    let right = sortedList.length - 1;\n    while (left < right) {\n      const sum = sortedList[i] + sortedList[left] + sortedList[right];\n      if (sum === 0) {\n        return true;\n      } else if (sum < 0) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n  return false;\n};"
      ],
      [
        "const incrList = (l) => {\n    return l.map(e => 1 + e);\n  }"
      ],
      [
        "/**\n * pairsSumToZero takes a list of integers as an input.\n * It returns true if there are two distinct elements in the list that\n * sum to zero, and false otherwise.\n * >>> pairsSumToZero([1, 3, 5, 0])\n * false\n * >>> pairsSumToZero([1, 3, -2, 1])\n * false\n * >>> pairsSumToZero([1, 2, 3, 7])\n * false\n * >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n * true\n * >>> pairsSumToZero([1])\n * false\n */\nconst pairsSumToZero = (l) => {\n  const seen = new Set();\n  for (let i = 0; i < l.length; i++) {\n    const complement = -l[i];\n    if (seen.has(complement)) {\n      return true;\n    }\n    seen.add(l[i]);\n  }\n  return false;\n};"
      ],
      [
        "/**\n * Calculates the area of a triangle given its side length and height.\n * \n * @param {number} side - The length of the triangle's side.\n * @param {number} height - The height of the triangle from its base.\n * @returns {number} The area of the triangle.\n * \n * @example\n * // Returns 7.5\n * \n */\nconst triangleArea = (side, height) => {\n  return side * height / 2.0;\n};"
      ],
      [
        "begin to write code\n    results[i] = results[i - 1] + results[i - 2] + results[i - 3] + results[i - 4];\n  }\n  return results[n];\n};"
      ],
      [
        "const median = (l) => {\n  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (1 == l.length % 2) {\n    return l[Math.floor(len / 2)];\n  } else {\n    return (l[len / 2 - 1] + l[len / 2]) / 2;\n  }\n};"
      ],
      [
        "const isPalindrome = (text) => {\n  for (let i = 0; i < text.length; i++)\n    if (text.at(-i-1) != text[i])\n      return false;\n  return true;\n}"
      ],
      [
        "const modp = (n, p) => {\n  let ret = 1;\n  for (let i = 0; i < n; i++) {\n    ret = (ret * 2) % p;\n  }\n  return ret;\n};"
      ],
      [
        "// no additional code needed here"
      ],
      [
        "const belowThreshold = (l, t) => {\n  for (const e of l) {\n    if (e >= t) {\n      return false;\n    }\n  }\n  return true;\n}"
      ],
      [
        "const sameChars = (s0, s1) => {\n  return JSON.stringify([...new Set(s1)].sort()) === JSON.stringify([...new Set(s0)].sort());\n}"
      ],
      [
        "const fib = (n) => {\n  if (0 == n) {\n    return 0;\n  }\n  if (1 == n) {\n    return 1;\n  }\n  if (2 == n) {\n    return 1;\n  }\n  \n  let a = 0;\n  let b = 1;\n  let c = 1;\n  \n  for(let i = 3; i < n; i++) {\n    a = b;\n    b = c;\n    c = a + b;\n  }\n  \n  return c;\n};"
      ],
      [
        "const correctBracketing = (brackets) => {\n  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth = depth + 1;\n    else if (b == \">\") {\n      if (depth == 0) {\n        return false; // found a closing bracket without a corresponding opening bracket\n      }\n      depth = depth - 1;\n    }\n  }\n  return depth == 0; // true if all opening brackets have corresponding closing brackets\n}"
      ],
      [
        "const monotonic = (l) => {\n  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(sort1) === JSON.stringify(l) ||\n      JSON.stringify(sort2) === JSON.stringify(l)) {\n    return true;\n  }\n  return false;\n};"
      ],
      [
        "const largestPrimeFactor = (n) => {\n  var isPrime = function (k) {\n    if (k < 2)\n      return 0;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return 0;\n    return 1;\n  };\n  var largest = 0;\n  while (n % 2 == 0) {\n    largest = 2;\n    n /= 2;\n  }\n  for (var i = 3; i * i <= n; i += 2) {\n    while (n % i == 0) {\n      largest = i;\n      n /= i;\n    }\n  }\n  if (n > 2)\n    largest = n;\n  return largest;\n}"
      ],
      [
        "const sumToN = (n) => {\n  return (1 + n) * n / 2;\n}"
      ],
      [
        "depth = depth - (1);\n    }\n  }\n  if (depth === 0)\n    return true;\n  else\n    return false;\n};"
      ],
      [
        "/**\n * @param {number[]} xs\n * @returns {number[]}\n */\nconst derivative = (xs) => {\n  return xs.map((x, i) => i * x).slice(1);\n};"
      ],
      [
        "const fibfib = (n) => {\n  let fibfibValues = [0, 0, 1];\n  for (let i = 3; i <= n; i++) {\n    fibfibValues[i] = fibfibValues[i-1] + fibfibValues[i-2] + fibfibValues[i-3];\n  }\n  return fibfibValues[n];\n}"
      ],
      [
        "/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  if ('' == s) return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0);\n    return prev + (/[A-Z]/.test(char) ? ord_char : 0);\n  }, 0);\n};"
      ],
      [
        "const pluck = (arr) => {\n  if (0 == arr.length) return [];\n  var evens = arr.filter(x => 0 == x % 2);\n  if (0 == evens.length) return [];\n  return [evens[0], arr.indexOf(evens[0])];\n};"
      ],
      [
        "const search = (lst) => {\n  var frq = new Array(1 + Math.max(...lst)).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (const [i, v] of frq.entries())\n    if (i > 0 && v >= i)\n      ans = Math.max(ans, i);\n  return ans;\n};"
      ],
      [
        "const strangeSortList = (lst) => {\n  var res = [], sw = 1;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n};"
      ],
      [
        "while (i < j) {\n    if (q[j] != q[i])\n      return false;\n    i++, j--;\n  }\n  return true;\n};"
      ],
      [
        "/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr.at(-i - 1) != arr[i]) ans++;\n  return ans;\n};"
      ],
      [
        "function isMultiplyPrime(a) {\n  // Check if a is less than 2, which is not a valid number in the context of this problem\n  if (a < 2) {\n    return false;\n  }\n\n  var primeCount = 0;\n\n  // Iterate from 2 to a, checking if each number is prime\n  for (let i = 2; i <= a; i++) {\n    // Check if i is a prime number by using the isPrime function\n    if (isPrime(i)) {\n      // If it is a prime number, check if a is divisible by it\n      if (a % i === 0) {\n        // If it is, increment the prime count\n        primeCount++;\n        // Then check if a has any more factors of the prime number\n        while (a % i === 0) {\n          a /= i;\n        }\n      }\n    }\n  }\n\n  // If there are exactly three prime factors, return true\n  // Otherwise, return false\n  return primeCount === 3;\n}\n\n// Function to check if a number is prime\nfunction isPrime(n) {\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}"
      ],
      [
        "const isSimplePower = (x, n) => {\n  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while(power < x) {\n    power *= n;\n    if (power == x)\n      return true;\n  }\n  return false;\n}"
      ],
      [
        "const iscube = (a) => {\n  a = Math.abs(a);\n  return (a == Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3));\n};"
      ],
      [
        "const isHappy = (s) => {\n  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] === s[i + 1] || s[i] === s[i + 2] || s[i + 1] === s[i + 2])\n      return false;\n  return true;\n};"
      ],
      [
        "const numericalLetterGrade = (grades) => {\n  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i = i + 1) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}"
      ],
      [
        "const primeLength = (string) => {\n  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}"
      ],
      [
        "const startsOneEnds = (n) => {\n  if (1 === n) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t *= 10\n  }\n  return t\n}"
      ],
      [
        "const solve = (N) => {\n  let t = 0;\n  while (N > 0) {\n    t = t + (N % 10);\n    N = Math.floor(N / 10);\n  }\n  return t.toString(2);\n};"
      ],
      [
        "function addEvenElementsAtOddIndices(lst) {\n  let sum = 0;\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}\n\n// Test the function"
      ],
      [
        "const antiShuffle = (s) => {\n  return s.split(' ').map(word => word.split('').sort((a, b) => a.charCodeAt() - b.charCodeAt()).join('')).join(' ');\n}"
      ],
      [
        "const getRow = (lst, x) => {\n  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (x == lst[i][j]) {\n        t.push([i, j])\n      }\n    }\n  }\n  return t.sort((a, b) => {\n    if (a[0] === b[0]) {\n      return b[1] - a[1]\n    } else {\n      return a[0] - b[0]\n    }\n  })\n}"
      ],
      [
        "const sortArray = (arr) => {\n  // Create a copy of the array to avoid changing the original array\n  let sortedArr = [...arr];\n\n  // Determine the sorting order based on the sum of the first and last elements\n  let order = (sortedArr[0] + sortedArr[sortedArr.length - 1]) % 2 === 0 ? 'descending' : 'ascending';\n\n  // Sort the array in the determined order\n  sortedArr.sort((a, b) => order === 'ascending' ? a - b : b - a);\n\n  // Return the sorted array\n  return sortedArr;\n}"
      ],
      [
        "const encrypt = (s) => {\n  let t = ''\n  for (let i = 0; i < s.length; i = i + 1) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p = p - (26) }\n    t += String.fromCharCode(p)\n  }\n  return t\n}"
      ],
      [
        "const nextSmallest = (lst) => {\n  let arr = lst\n  for (let j = 0; j < arr.length; j = j + 1) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k = k + 1) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let temp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = temp\n  }\n  if (arr.length < 2) {\n    return null\n  } else {\n    return arr[1]\n  }\n}"
      ],
      [
        "const isBored = (S) => {\n  let count = 0;\n  const sentences = S.match(/[^.?!]+[.?!]/g);\n  if (sentences) {\n    for (let sentence of sentences) {\n      if (sentence[0] === 'I' && sentence[1] === ' ') {\n        count++;\n      }\n    }\n  }\n  return count;\n}"
      ],
      [
        "const anyInt = (x, y, z) => {\n  // Check if all numbers are integers\n  const areAllIntegers = (a, b, c) => Number.isInteger(a) && Number.isInteger(b) && Number.isInteger(c);\n\n  // Check if any number is equal to the sum of the other two\n  const isSumOfOthers = (a, b, c) => a === b + c || b === a + c || c === a + b;\n\n  // Return true only if all conditions are met\n  return areAllIntegers(x, y, z) && isSumOfOthers(x, y, z);\n};"
      ],
      [
        "const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\nconst code = (message) => {\n  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let c = message[i]\n    let p = c.charCodeAt()\n    if (p > 96) { p = p - (32) }\n    if (vowels.includes(c)) {\n      let v = vowels.indexOf(c) + 2\n      if (v > 25) { v = v - 26 }\n      c = v > 12 ? vowels[v] : vowels[v + 12]\n    }\n    if (p < 91) { p = p + (32) }\n    t = t + c\n  }\n  return t\n}"
      ],
      [
        "const maxPrimeSum = (lst) => {\n  let maxPrime = -1;\n  for (let num of lst) {\n    if (isPrime(num) && num > maxPrime) {\n      maxPrime = num;\n    }\n  }\n  if (maxPrime === -1) return 0;\n  return maxPrime.toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);\n}\n\nconst isPrime = (n) => {\n  if (n <= 1) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  for (let i = 3; i * i <= n; i += 2) {\n    if (n % i === 0) return false;\n  }\n  return true;\n}"
      ],
      [
        "const checkDictCase = (dict) => {\n  let lowerCaseCount = 0;\n  let upperCaseCount = 0;\n  let nonStringKeyCount = 0;\n\n  for (let key in dict) {\n    if (typeof key !== 'string') {\n      nonStringKeyCount++;\n    } else if (key.toLowerCase() === key) {\n      lowerCaseCount++;\n    } else if (key.toUpperCase() === key) {\n      upperCaseCount++;\n    }\n  }\n\n  if (Object.keys(dict).length === 0) {\n    return false;\n  }\n\n  return nonStringKeyCount === 0 && (lowerCaseCount === 0 || upperCaseCount === 0);\n};"
      ],
      [
        "const countUpTo = (n) => {\n  let t = []\n  for (let i = 2; i < n; i = i + 1) {\n    let p = 1\n    for (let j = 2; j * j <= i; j = j + 1) {\n      if (i % j === 0) {\n        p = 0\n        break\n      }\n    }\n    if (p === 1) {\n      t.push(i)\n    }\n  }\n  return t\n}"
      ],
      [
        "const countUpper = (s) => {\n  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if ('A' == s[i] || 'E' == s[i] || 'I' == s[i] || 'O' == s[i] || 'U' == s[i]) { p++ }\n  }\n  return p\n}"
      ],
      [
        "const closestInteger = (value) => {\n  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) {\n    value = value + Math.sign(value)\n  }\n  return Math.round(value)\n}"
      ],
      [
        "const makeAPile = (n) => {\n  let t = []\n  for (let i = n; i < 3 * n; i += 2) {\n    t.push(i)\n  }\n  return t\n}"
      ],
      [
        "/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (' ' == s[i] || ',' == s[i]) {\n      if (0 == k) {\n        k = 1;\n        p.push(t);\n      }\n      t = '';\n    } else {\n      t += s[i];\n    }\n  }\n  if (0 == k) {\n    k = 1;\n    p.push(t);\n  }\n  return p;\n}"
      ],
      [
        "const chooseNum = (x, y) => {\n  for (let i = y; i >= x; i--) {\n    if (0 == i % 2) {return i }\n  }\n  return -1;\n}"
      ],
      [
        "return \"0b\" + Math.round(k).toString(2)"
      ],
      [
        "const uniqueDigits = (x) => {\n  let p = []\n  for (let i = 0; i < x.length; i = i + 1) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo == 1) {\n      p.push(x[i])\n    }\n  }\n  p.sort((a, b) => a - b);\n  return p\n}"
      ],
      [
        "const numWords = {\n  1: 'One',\n  2: 'Two',\n  3: 'Three',\n  4: 'Four',\n  5: 'Five',\n  6: 'Six',\n  7: 'Seven',\n  8: 'Eight',\n  9: 'Nine',\n};\n\nconst sortAndTransform = (arr) => {\n  const filteredArr = arr.filter((num) => num >= 1 && num <= 9);\n  const sortedArr = filteredArr.sort((a, b) => a - b);\n  const reversedArr = sortedArr.reverse();\n\n  return reversedArr.map((num) => numWords[num]);\n};\n\n// Example usage\nconst result = sortAndTransform([2, 1, 1, 4, 5, 8, 2, 3]);\n\n\nconst emptyArrayResult = sortAndTransform([]);\n\n\nconst strangeNumbersResult = sortAndTransform([1, -1, 55]);"
      ],
      [
        "k[i - 1] = f\n  if (i % 2 === 0) {\n    f = f * i;\n  } else {\n    f = p;\n  }\n}\nreturn k;"
      ],
      [
        "const evenOddPalindrome = (n) => {\n  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[k.length - j - 1] != k[j]) {\n        p = 0\n        break\n      }\n    }\n    if (p) {\n      if (i % 2 == 0) {\n        e += 1\n      } else {\n        o += 1\n      }\n    }\n  }\n  return [e, o]\n}"
      ],
      [
        "const countNums = (arr) => {\n  let p = 0\n  for (let i = 0; i < arr.length; i = i + 1) {\n    let h = arr[i]\n    if (h > 0) {\n      p = p + 1;\n      continue;\n    }\n    let j = Math.abs(h)\n    while (j > 0) {\n      if ((j % 10) !== 0) {\n        p = p + 1;\n        break;\n      }\n      j = Math.floor(j / 10)\n    }\n  }\n  return p\n}"
      ],
      [
        "const moveOneBall = (arr) => {\n  if (0 == arr.length) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (1 == t) {\n      k++;\n      if (k > 1) { return false }\n      if (0 == i) { continue }\n      arr = [arr[len - 1]].concat(arr.slice(0, len - 1));\n      return moveOneBall(arr);\n    }\n  }\n  return true;\n}"
      ],
      [
        "const exchange = (lst1, lst2) => {\n  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i = i + 1) {\n    if (lst1[i] % 2 == 0) { t = t + 1 }\n  }\n  if (t == k) {\n    return \"YES\"\n  } else {\n    let c = 0\n    for (let i = 0; i < lst2.length; i = i + 1) {\n      if (lst2[i] % 2 != 0) { c = c + 1 }\n    }\n    if (t + c > k) {\n      return \"YES\"\n    } else {\n      return \"NO\"\n    }\n  }\n}"
      ],
      [
        "histogram = (test) => {\n    let d = {}\n    let t = test.split(/\\s/)\n    if ('' == test) { t = [] }\n    for (m in t) {\n        if (t[m] in d) {\n            d[t[m]]++\n        }\n        else {\n            d[t[m]] = 1\n        }\n    }\n    let maxCount = Math.max(...Object.values(d));\n    let result = Object.fromEntries(Object.entries(d).filter(([k,v]) => v === maxCount));\n    return result\n}"
      ],
      [
        "const reverseDelete = (s, c) => {\n  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j = j + 1) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  const isPalindrome = t === t.split('').reverse().join('')\n  return [t, isPalindrome]\n}"
      ],
      [
        "const oddCount = (lst) => {\n  let d = []\n  for (let i = 0; i < lst.length; i = i + 1) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j = j + 1) {\n      if (lst[i].charAt(j) % 2 !== 0) {\n        p = p + 1\n      }\n    }\n    d.push(`the number of odd elements ${p}n the str${p}ng ${p} of the ${p}nput.`)\n  }\n  return d\n}"
      ],
      [
        "const minSubArraySum = (nums) => {\n  let min = nums[0]\n  for (let i = 0; i < nums.length; i = i + 1) {\n    let sum = 0;\n    for (let j = i; j < nums.length; j = j + 1) {\n      sum += nums[j];\n      min = Math.min(min, sum);\n    }\n  }\n  return min;\n}"
      ],
      [
        "// No additional packages are required for this solution\n\nconst maxFill = (grid, capacity) => {\n    // Calculate the maximum number of times buckets need to be lowered\n    let totalFill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        totalFill += Math.ceil(grid[i].reduce((acc, val) => acc + val, 0) / capacity);\n    }\n    return totalFill;\n}"
      ],
      [
        "Complete code:\n-----------------------------\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let p = arr\n  for (let j = 0; j < p.length; j = j + 1) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k = k + 1) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u = u + 1) {\n        if (w1[u] == '1') { f1 = f1 + 1 }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u = u + 1) {\n        if (w2[u] == '1') { f2 = f2 + 1 }\n      }\n      if (f1 < f2) {\n        p[ind] = p[k]\n        p[k] = p[ind]\n      } else if (f1 == f2 && p[ind] > p[k]) {\n        p[ind] = p[k]\n        p[k] = p[ind]\n      }\n    }\n  }\n  return p\n}\n-----------------------------"
      ],
      [
        "const consonants = 'bcdfghjklmnpqrstvwxyz';\nconst isConsonant = c => consonants.includes(c.toLowerCase());\n\nconst countConsonants = s => [...s].filter(isConsonant).length;\n\nconst selectWords = (s, n) => {\n  const words = s.split(/\\s+/);\n  return words.filter(word => countConsonants(word) === n);\n};"
      ],
      [
        "const getClosestVowel = (word) => {\n  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !('a' != word[i] && 'e' != word[i] && 'i' != word[i] && 'o' != word[i] && 'u' != word[i] && 'A' != word[i] &&\n        'U' != word[i] && 'O' != word[i] && 'I' != word[i] && 'E' != word[i])\n      &&\n      ('a' != word[1 + i] && 'e' != word[1 + i] && 'i' != word[1 + i] && 'o' != word[1 + i] && 'u' != word[1 + i] && 'A' != word[1 + i] &&\n        'U' != word[1 + i] && 'O' != word[1 + i] && 'I' != word[1 + i] && 'E' != word[1 + i])\n    ) {\n      return word[i];\n    }\n  }\n  return \"\";\n};"
      ],
      [
        "}\n  }\n  return y !== 0 || w1[0] === ')' || w1[w1.length - 1] !== '(' ? 'No' : 'Yes'\n};"
      ],
      [
        "// Complete the code as follows\nconst maximum = (arr, k) => {\n  for (let i = 0; i < arr.length - 1; i++) {\n    for (let j = 0; j < arr.length - i - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        let temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n      }\n    }\n  }\n  return arr.slice(-k);\n};"
      ],
      [
        "/**\n * This function calculates the sum of odd elements at even indices in an array.\n * @param {Array} arr - An array of integers.\n * @returns {Number} The sum of odd numbers at even indices.\n */\nconst solution = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i += 2) {\n    if (arr[i] % 2 !== 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};"
      ],
      [
        "const addElements = (arr, k) => {\n  let p = 0\n  for (let i = 0; i < k; i = i + 1) {\n    if (arr[i] < 100 && arr[i] > -100) { p = p + (arr[i]) }\n  }\n  return p\n}\n\nconst arr = [111,21,3,4000,5,6,7,8,9];\nconst k = 4;"
      ],
      [
        "// Continue code from the last place:\n\n      } else {\n        p.push(t)\n        if (t == 1) { break } else if (t % 2 == 0) { t = t / 2 } else { t = 3 * t + 1 }\n      }\n    }\n    return p.sort(function (a, b) { return a - b })\n  }"
      ],
      [
        "const validDate = (date) => {\n  let t = date.split(/-/)\n  if (3 != t.length) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (2 == t[0] && t[1] > 29) { return false }\n  if ([1,3,5,7,8,10,12].includes(t[0]) && t[1] > 31) { return false }\n  if ([4,6,9,11].includes(t[0]) && t[1] > 30) { return false }\n  return true\n}"
      ],
      [
        "if (lst[i] - pre > 1) { return 0 }\n  if (lst[i] - pre < 0) { dup = 0 }\n  if (lst[i] != pre) { dup = 1 }\n  pre = lst[i]\n}\nreturn dup > 0\n};"
      ],
      [
        "return s * n\n}"
      ],
      [
        "const minPath = (grid, k) => {\n  const path = [];\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n  const seen = new Set();\n  const N = grid.length;\n\n  const dfs = (x, y, steps) => {\n    if (steps === k) {\n      path.push(grid[x][y]);\n      return true;\n    }\n    for (const [dx, dy] of directions) {\n      const newX = x + dx;\n      const newY = y + dy;\n      if (newX >= 0 && newX < N && newY >= 0 && newY < N && !seen.has(`${newX},${newY}`)) {\n        seen.add(`${newX},${newY}`);\n        const isPathFound = dfs(newX, newY, steps + 1);\n        if (isPathFound) {\n          path.push(grid[x][y]);\n          return true;\n        }\n        seen.delete(`${newX},${newY}`);\n      }\n    }\n    return false;\n  };\n\n  dfs(m, n, 0);\n  return path.reverse();\n};"
      ],
      [
        "begin to write code\n  } else {\n    p.push(p[i - 1] + p[i - 2] + (i + 1));\n  }\n  return p;\n};"
      ],
      [
        "k *= y\n }\n n = (n - y) / 10\n }\n return p * k\n }"
      ],
      [
        ""
      ],
      [
        "const sumSquares = (lst) => {\n  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (0 != y % 1) {\n      if (y > 0) { y = 1 + y - y % 1 }\n    }\n    p += Math.pow(Math.ceil(y), 2);\n  }\n  return p;\n};"
      ],
      [
        "// Check if the last character of a given string is an alphabetical character and not part of a word\n// Examples:\n// checkIfLastCharIsALetter(\"apple pie\") ➞ false\n// checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n// checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n// checkIfLastCharIsALetter(\"\") ➞ false\n\nconst checkIfLastCharIsALetter = (txt) => {\n  const len = txt.length\n  if (len === 0) { return false }\n  const code = txt[len - 1].charCodeAt()\n  if (len === 1) {\n    return /[a-zA-Z]/.test(txt[0])\n  }\n  return (/[a-zA-Z]/.test(txt[len - 1]) &&\n    txt[len - 2] === ' ')\n}\n\nmodule.exports = checkIfLastCharIsALetter"
      ],
      [
        "const canArrange = (arr) => {\n  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i = i - 1) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}"
      ],
      [
        "const largestSmallestIntegers = (lst) => {\n  let largestNegative = null;\n  let smallestPositive = null;\n\n  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num < 0) {\n      largestNegative = largestNegative === null || num > largestNegative ? num : largestNegative;\n    } else if (num > 0) {\n      smallestPositive = smallestPositive === null || num < smallestPositive ? num : smallestPositive;\n    }\n  }\n\n  return [largestNegative, smallestPositive];\n};"
      ],
      [
        "function compareOne(a, b) {\n    let aa = Number(a);\n    if (typeof a === 'string') {\n        aa = Number(a.replace(',', '.'));\n    }\n    let bb = Number(b);\n    if (typeof b === 'string') {\n        bb = Number(b.replace(',', '.'));\n    }\n\n    if (aa > bb) {\n        return a;\n    } else if (aa < bb) {\n        return b;\n    } else {\n        return null;\n    }\n}"
      ],
      [
        "const isEqualToSumEven = (n) => {\n  // Explanation:\n  // 1. The function returns true if the number n is even and greater than or equal to 8.\n  // 2. Otherwise, the function returns false.\n  // Explanation end.\n\n  return (n >= 8 && 0 == n % 2)\n}"
      ],
      [
        "const fixSpaces = (text) => {\n  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c = c + 1 }\n    else if (c > 0) {\n      if (c == 1) { t = t + ('_') }\n      if (c == 2) { t = t + ('__') }\n      c = 0\n    } else {\n      t = t + text[i]\n    }\n  }\n  return t\n}"
      ],
      [
        "if ((65 <= a && a <= 90) || (97 <= a && a <= 122)) {\n  // contains at least one alphabet letter\n  let d = t[0].match(/\\d/)\n  if (!d || d.length <= 3) {\n    return 'Yes'\n  }\n}"
      ],
      [
        "const sumSquares = (lst) => {\n  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (0 == i % 3) { y += lst[i] * lst[i] }\n    else if (0 == i % 4) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}"
      ],
      [
        "// get prime numbers in range (1, l)\nfunction getPrimes(l) {\n  const primes = [];\n  for (let i = 2; i <= l; i++) {\n    let isPrime = true;\n    for (let j = 2; j <= Math.sqrt(i); j++) {\n      if (i % j === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n}\n\nconst wordsInSentence = (sentence) => {\n  let t = sentence.split(/\\s/)\n  let p = ''\n  let lengthPrimes = getPrimes(t[0].length)\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    if (!lengthPrimes.includes(len)) {\n      continue;\n    }\n    p += t[j] + ' ';\n  }\n  return p.trim();\n};"
      ],
      [
        "A function called `simplify` is defined. Inside the function, the `split` method is called on the arguments `x` and `n`, which are the string representations of fractions. The `split` method splits the strings at the `/` character and creates an array with the numerator and denominator of the fraction.\n\nThe function multiplies the numerators and denominators of the two fractions together respectively. It assigns the resulting product of the numerators to the variable `m` and the product of the denominators to the variable `n`.\n\nThe `%` operator is used to determine if `m` is a multiple of `n`. If it is a multiple, the function returns `true`, indicating that the expression `x * n` simplifies to a whole number. Otherwise, it returns `false`, indicating that the expression does not simplify to a whole number."
      ],
      [
        "const orderByPoints = (nums) => {\n  return nums.sort((a, b) => {\n    const sumA = Math.abs(a).toString().split('').reduce((acc, digit) => acc + +digit, 0);\n    const sumB = Math.abs(b).toString().split('').reduce((acc, digit) => acc + +digit, 0);\n    \n    if (sumA === sumB) {\n      return nums.indexOf(a) - nums.indexOf(b);\n    }\n    \n    return sumA - sumB;\n  });\n};"
      ],
      [
        "// Code generated\nconst specialFilter = (nums) => {\n  let p = 0;\n  for (let i = 0; i < nums.length; i = i + 1) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString();\n    let firstDigit = parseInt(y[0], 10);\n    let lastDigit = parseInt(y[y.length - 1], 10);\n    if (firstDigit % 2 !== 0 && lastDigit % 2 !== 0) {\n      p = p + 1;\n    }\n  }\n  return p;\n};"
      ],
      [
        "const getMaxTriples = (n) => {\n  let y = []\n  for (let i = 1; i <= n; i = i + 1) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 === 0) {\n          u = u + 1\n        }\n      }\n    }\n  }\n  return u\n}"
      ],
      [
        "const bf = (planet1, planet2) => {\n  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (planet1 == y[i]) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (planet2 == y[i]) { hi = i }\n  }\n  if (lo == -1 || hi == -1) { return [] }\n  if (lo > hi) {\n    let t = lo\n    lo = hi\n    hi = t\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}"
      ],
      [
        "const sortedListSum = (lst) => {\n  let p = []\n  for (let i = 0; i < lst.length; i = i + 1) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        if (p[k] > p[k + 1]) { f = 1 }\n      }\n      if (f == 1) {\n        let temp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = temp\n      }\n    }\n  }\n  return p\n}"
      ],
      [
        "const isPrime = (num) => {\n  for (let i = 2, s = Math.sqrt(num); i <= s; i++)\n    if (num % i === 0) return false; \n  return num > 1;\n}\n\nconst xOrY = (n, x, y) => {\n  return isPrime(n) ? x : y\n}"
      ],
      [
        "const doubleTheDifference = (lst) => {\n  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (1 == lst[i] % 2 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}"
      ],
      [
        "const compare = (game, guess) => {\n  for (let i = 0; i < guess.length; i++) {\n    game[i] = Math.abs(game[i] - (guess[i]));\n  }\n  return game;\n};\n\n//Test Cases:"
      ],
      [
        "const strongestExtension = (class_name, extensions) => {\n  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i = i - 1) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j = j + 1) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) {\n        u++\n      } else if (k >= 97 && k <= 122) {\n        s++\n      }\n    }\n    let g = u - s\n    if (g > s) {\n      s = g\n      u = g\n    }\n    if (u > s) {\n      s = u\n    }\n    if (g > s) {\n      s = g\n    }\n  }\n  let m = ''\n  let n = 0\n  for (let o = 0; o < extensions.length; o = o + 1) {\n    let p = u - s\n    let q = p - extensions[o].length\n    if (q > n) {\n      m = extensions[o]\n      n = q\n    }\n  }\n  return class_name + '.' + m\n}"
      ],
      [
        "const cycpatternCheck = (a, b) => {\n  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i = i + 1) {\n    for (let j = 0; j < l + 1; j = j + 1) {\n      let y = 1\n      for (let k = 0; k < l; k = k + 1) {\n        if (a.charAt(i + k) !== pat.charAt(j + k)) {\n          y = 0\n          break\n        }\n      }\n      if (y === 1) {\n        return true\n      }\n    }\n  }\n  return false\n}"
      ],
      [
        "// Original code\nconst rightAngleTriangle = (a, b, c) => {\n  return (c * c == a * a + b * b || b * b + c * c == a * a || a * a + c * c == b * b)\n}\n\n// My solution\nconst rightAngleTriangle = (a, b, c) => {\n  // First, sort the sides from the smallest to the largest\n  const sides = [a, b, c].sort((a, b) => a - b);\n  \n  // Check if the square of the longest side is equal to the sum of the squares of the other two sides\n  return Math.pow(sides[2], 2) === Math.pow(sides[0], 2) + Math.pow(sides[1], 2);\n}"
      ],
      [
        "const findMax = (words) => {\n  let s = -1\n  let u = -1\n  if (0 == words.length) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    let c = new Set(words[i])\n    let d = c.size\n    if (d > u) {\n      s = i\n      u = d\n    } else if (d == u && words[i] < words[s]) {\n      s = i\n    }\n  }\n  return words[s]\n}"
      ],
      [
        "``javascript\nconst doAlgebra = (operator, operand) => {\n    while (operator.length > 0) {\n      let y = 0;\n      for (let i = operator.length - 1; i >= 0; i = i - 1) {\n        if (operator[i] == '**') {\n          let u = operand[i];\n          while (operand[i + 1] > 1) {\n            operand[i + 1] = operand[i + 1] - 1;\n            operand[i] = operand[i] * (u);\n          }\n          operand.splice(i + 1, 1);\n          operator.splice(i, 1);\n          y = 1;\n          break;\n        }\n      }\n      if (y == 1) { continue; }\n      for (let i = 0; i < operator.length; i++) {\n        if (operator[i] == '//' && i > 0) {\n          operand[i] = Math.floor(operand[i] / operand[i + 1]);\n          operand.splice(i + 1, 1);\n          operator.splice(i, 1);\n          break;\n        }\n      }\n      for (let i = 0; i < operator.length; i++) {\n        if (operator[i] == '*') {\n          operand[i] = operand[i] * (operand[i + 1]);\n          operand.splice(i + 1, 1);\n          operator.splice(i, 1);\n          y = 1;\n          break;\n        }\n      }\n      if (y == 1) { continue; }\n      for (let i = 0; i < operator.length; i++) {\n        if (operator[i] == '+') {\n          operand[i] = operand[i] + operand[i + 1];\n          operand.splice(i +"
      ],
      [
        "const solve = (s) => {\n  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i = i + 1) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y = y + (32);\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y = y - (32);\n      t = 1;\n    }\n    p = p + String.fromCharCode(y);\n  }\n  if (t === 0) {\n    return s.split('').reverse().join('');\n  } else {\n    return p;\n  }\n};"
      ],
      [
        "return md5(text);\n};"
      ]
    ],
    "variance": 0.0,
    "stddev": 0.0
  }
]