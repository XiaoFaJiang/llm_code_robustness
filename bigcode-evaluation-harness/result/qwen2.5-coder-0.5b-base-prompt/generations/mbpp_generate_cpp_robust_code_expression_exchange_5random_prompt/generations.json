[["#include <iostream>\n#include <cassert>\n#include <string>\n\nstd::string remove_Occ(std::string s, char ch) {\n    for (long i = 0; i < s.length(); i++) {\n        if (s[i] == ch) {\n            s = s.substr(0, i) + s.substr(i + 1);\n            break;\n        }\n    }\n    return s;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n\nusing namespace std;\n\nvector<vector<long>> sort_matrix(vector<vector<int>> M) {\n    sort(M.begin(), M.end(), [](const vector<int>& a, const vector<int>& b) {\n        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);\n    });\n    return M;\n}\n\n\n\n"], ["#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cassert>\n#include <iostream>\nusing namespace std;\n\nvector<pair<string, int>> count_common(const vector<string>& words) {\n    map<string, long> word_counts;\n    for (const auto& word : words) {\n        word_counts[word]++;\n    }\n    vector<pair<string, int>> sorted_counts(word_counts.begin(), word_counts.end());\n    sort(sorted_counts.begin(), sorted_counts.end(), [](const pair<string, int>& a, const pair<string, int>& b) {\n        return a.second > b.second;\n    });\n    return sorted_counts;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <cmath>\n\nint find_Volume(int l, long b, int h) {\n    return l * b * h;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstring text_lowercase_underscore(string text) {\n    if (text.empty()) {\n        return \"Not matched!\";\n    }\n    size_t underscore_pos = text.find('_');\n    if (std::string::npos == underscore_pos) {\n        return \"Not matched!\";\n    }\n    if (0 == underscore_pos || text.length() - 1 == underscore_pos) {\n        return \"Not matched!\";\n    }\n    return text.substr(0, underscore_pos) + \"_\" + text.substr(underscore_pos + 1);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint square_perimeter(int a) {\n    int perimeter = a * 4;\n    return perimeter;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\nconst int NO_OF_CHARS = 256;\nvector<char> str_to_list(const string& str) {\n    vector<char> temp;\n    for (char x : str) {\n        temp.push_back(x);\n    }\n    return temp;\n}\nstring lst_to_string(const vector<char>& List) {\n    return string(List.begin(), List.end());\n}\nvector<int> get_char_count_array(const string& str) {\n    vector<long> count(NO_OF_CHARS, 0);\n    for (char c : str) {\n        count[c]++;\n    }\n    return count;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nbool test_duplicate(std::vector<int> arraynums) {\n    std::set<long> nums_set(arraynums.begin(), arraynums.end());    \n    for (const auto& num : nums_set) {\n        if (nums_set.find(num) != nums_set.end()) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\n"], ["#include<iostream>\n#include <cassert>\nbool is_woodall(long long x) {\n    if (0 == x % 2) {\n        return false;\n    }\n    if (1 == x) {\n        return true;\n    }\n    x = 1 + x;\n    long long p = 0;\n    while (x) {\n        p = p * 10 + x % 10;\n        x /= 10;\n    }\n    return 1 == p;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> multiples_of_num(long m, int n) {\n    std::vector<int> multiples;\n    for (int i = 1; i <= m; ++i) {\n        multiples.push_back(i * n);\n    }\n    return multiples;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nlong find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    int no_duplicate = -1;\n    for (int num : nums) {\n        if (num_set.find(num) != num_set.end()) {\n            return num;\n        }\n        num_set.insert(num);\n    }\n    return no_duplicate;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint maximum_Sum(const std::vector<std::vector<long>>& list1) {\n    int maxi = -100000;\n    for (const auto& x : list1) {\n        int sum = 0;\n        for (auto y : x) {\n            sum += y;\n        }\n        maxi = std::max(maxi, sum);\n    }\n    return maxi;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <cmath>\n#include <cassert>\nint binary_to_decimal(int binary) {\n    int decimal = 0, i = 0;\n    while (0 != binary) {\n        int dec = binary % 10;\n        decimal += std::pow(2, i) * dec;\n        binary /= 10;\n        i++;\n    }\n    return decimal;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint find_Product(std::vector<int> arr, int n) {\n    std::sort(arr.begin(), arr.end());\n    int prod = 1;\n    for (int i = 0; i < n; i++) {\n        if (0 == i || arr[i] != arr[i - 1]) {\n            prod *= arr[i];\n        }\n    }\n    return prod;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool check_k_elements(const std::vector<std::vector<int>>& test_list, int K) {\n    bool res = true;\n    for (const auto& tup : test_list) {\n        for (int ele : tup) {\n            if (K != ele) {\n                res = false;\n            }\n        }\n    }\n    return res;\n}\n\n\n\n"], ["\n#include<iostream>\n#include <cassert>\n\nlong binomial_Coeff(int n, int k) {\n    if (k > n) {\n        return 0;\n    }\n    long result = 1;\n    for (int i = 1; i <= k; ++i) {\n        result *= n - i + 1;\n        result /= i;\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint get_Odd_Occurrence(std::vector<int> arr, int arr_size) {\n    for (int i = 0; i < arr_size; i++) {\n        int count = 0;\n        for (int j = 0; j < arr_size; j++) {\n            if (arr[j] == arr[i]) {\n                count++;\n            }\n        }\n        if (count % 2 != 0) {\n            return arr[i];\n        }\n    }\n    return -1;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\n\nbool check_Equality(const std::string &s) {\n    return (s.front() == s.back());\n}\n\nint count_Substring_With_Equal_Ends(const std::string &s) {\n    int result = 0;\n    long n = s.length();\n    for (int i = 0; i < n; ++i) {\n        if (check_Equality(s.substr(i, 1))) result++;\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nvector<int> func(vector<vector<int>>& nums, int k) {\n    unordered_map<int, int> d;\n    for (auto& row : nums) {\n        for (int i : row) {\n            d[i]++;\n        }\n    }\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    for (auto& item : d) {\n        int key = item.first;\n        long v = item.second;\n        if (pq.size() < k) {\n            pq.emplace(v, key);\n        } else {\n            if (v > pq.top().first) {\n                pq.pop();\n                pq.emplace(v, key);\n            }\n        }\n    }\n    vector<int> res;\n    while (!pq.empty()) {\n        res.push_back(pq.top().second);\n        pq.pop();\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <cmath>\n#include <cassert>\nint max_Prime_Factors(int n) {\n    long maxPrime = -1;\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n >>= 1;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n /= i;\n        }\n    }\n    if (n > 2) {\n        maxPrime = n;\n    }\n    return maxPrime;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint decimal_To_Binary(int N) {\n    int B_Number = 0;\n    int cnt = 0;\n    while (0 != N) {\n        int rem = N % 2;\n        int c = pow(10, cnt);\n        B_Number += rem * c;\n        N /= 2;\n        cnt++;\n    }\n    return B_Number;\n}\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_missing(std::vector<int>& ar, int N) {\n    int l = 0;\n    int r = N - 1;\n    while (l <= r) {\n        int mid = (l + r) / 2;\n        if (1 + mid != ar[mid] && mid == ar[mid - 1]) {\n            return 1 + mid;\n        } else if (ar[mid] == mid) {\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return N;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nlong find_rect_num(int n) {\n    if (n < 0) {\n        return -1;\n    }\n    return n * (n + 1) / 2;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <cmath>\n\nint find_Nth_Digit(int p, int q, int N) {\n    int res;\n    while (N > 0) {\n        N = N - (1);\n        p = p * (10);\n        res = p / q;\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<std::string> sort_mixed_list(std::vector<std::string> mixed_list) {\n    std::vector<long> int_part;\n    std::vector<std::string> str_part;\n    for (const auto& item : mixed_list) {\n        if (isdigit(item[0]) || (item[0] == '-' && item.size() > 1 && isdigit(item[1]))) {\n            int_part.push_back(std::stoi(item));\n        } else {\n            str_part.push_back(item);\n        }\n    }\n    std::sort(int_part.begin(), int_part.end());\n    std::sort(str_part.begin(), str_part.end());\n    std::vector<std::string> result;\n    result.reserve(int_part.size() + str_part.size());\n    for (const auto& item : int_part) {\n        result.push_back(std::to_string(item));\n    }\n    for (const auto& item : str_part) {\n        result.push_back(item);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <cassert>\n\ndouble div_even_odd(const vector<long>& list1) {\n    int first_even = -1;\n    int first_odd = -1;\n    for (int el : list1) {\n        if (el % 2 == 0 && first_even == -1) {\n            first_even = el;\n        }\n        else if (el % 2 == 1 && first_odd == -1) {\n            first_odd = el;\n        }\n    }\n    return (first_even == -1) ? 0 : (first_odd == -1) ? 0 : (first_even / first_odd);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <queue>\n#include <string>\n#include <unordered_map>\n#include <cassert>\nusing namespace std;\nstring rearrange_string(string S) {\n    unordered_map<char, long> ctr;\n    for (char c : S) {\n        ctr[c]++;\n    }\n    auto comp = [](pair<int, char> left, pair<int, char> right) {\n        if (left.first == right.first) return left.second > right.second;\n        return left.first < right.first;\n    };\n    priority_queue<pair<int, char>, vector<pair<int, char>>, decltype(comp)> heap(comp);\n    for (auto& kv : ctr) {\n        heap.push(make_pair(kv.second, kv.first));\n    }\n    if (heap.top().first > (S.length() + 1) / 2) {\n        return \"\";\n    }\n    string ans = \"\";\n    while (!heap.empty()) {\n        char c = heap.top().second;\n        int cnt = heap.top().first;\n        heap.pop();\n        if (cnt > 1) {\n            for (int i = 0; i < cnt - 1; i++) {\n                ans += c;\n            }\n        } else {\n            ans += c;\n        }\n        if (!heap.empty()) {\n            char next = heap.top().second;\n            int cnt = heap.top().first;\n            heap.pop();\n            if (cnt > 1) {\n                for (int i = 0; i < cnt - 1; i++) {\n                    ans += next;\n                }\n            } else {\n                ans += next;\n            }\n        }\n    }\n    return ans;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nmap<int, int> freq_element(vector<vector<long>>& nums) {\n    map<int, int> result;\n    for (auto& row : nums) {\n        for (int num : row) {\n            result[num]++;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nstd::vector<int> filter_evennumbers(const std::vector<int>& nums) {\n    std::vector<int> even_nums;\n    for (int num : nums) {\n        if (0 == num % 2) {\n            even_nums.push_back(num);\n        }\n    }\n    return even_nums;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <cassert>\n\nint find_Sum(const vector<int>& arr) {\n    unordered_map<int, long> count;\n    for (int num : arr) {\n        count[num]++;\n    }\n    int sum = 0;\n    for (auto it = count.begin(); it != count.end(); ++it) {\n        sum += it->second;\n    }\n    return sum;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nusing namespace std;\n\nstring text_match_string(string text) {\n    if (text.empty()) {\n        return \"Not matched!\";\n    }\n    if (isalnum(text[0]) || '_' == text[0]) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nint find_gcd(int x, int y) {\n    while (y != 0) {\n        long temp = x % y;\n        x = y;\n        y = temp;\n    }\n    return x;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool test_distinct(const std::vector<long>& data) {\n    std::set<int> distinctSet(data.begin(), data.end());\n    return distinctSet.size() == data.size();\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\nusing namespace std;\n\nint compute_Last_Digit(long A, int B) {\n    int variable = 1;\n    if (A == B) {\n        return 1;\n    } else if ((B - A) >= 5) {\n        return 0;\n    } else {\n        for (int i = 1; i <= B - A; ++i) {\n            variable = variable * A;\n        }\n        return variable % 10;\n    }\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nint odd_bit_set_number(int n) {\n    int count = 0;\n    int res = 0;\n    int temp = n;\n    while (temp > 0) {\n        if (0 == count % 2) {\n            res |= (1 << count);\n        }\n        count++;\n        temp >>= 1;\n    }\n    return res;\n}\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n#include <vector>\n\nstd::vector<int> specified_element(const std::vector<std::vector<long>>& nums, int N) {\n    std::vector<int> result;\n    for (const auto& i : nums) {\n        for (int num : i) {\n            if (num == N || num == 0) {\n                result.push_back(num);\n            }\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::pair<int, std::vector<int>> min_length_list(const std::vector<std::vector<int>>& input_list) {\n    auto min_it = std::min_element(input_list.begin(), input_list.end(),\n                                   [](const std::vector<int>& a, const std::vector<long>& b) {\n                                       return a.size() < b.size();\n                                   });\n    return std::make_pair(min_it->size(), *min_it);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool check_equilateral(int x, int y, long z) {\n    if (x == y && y == z) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nlong parallelogram_area(int b, int h) {\n    return b * h;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n\nstd::string check_Equality(const std::string& str) {\n    if (str[str.length() - 1] == str[0]) {\n        return \"Equal\";\n    } else {\n        return \"Not Equal\";\n    }\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> counting_sort(std::vector<int> my_list) {\n    int max_value = 0;\n    for (int i = 0; i < my_list.size(); ++i) {\n        if (my_list[i] > max_value) {\n            max_value = my_list[i];\n        }\n    }\n    std::vector<int> buckets(1 + max_value, 0);\n    for (int num : my_list) {\n        buckets[num]++;\n    }\n    std::vector<int> sorted_list(my_list.size());\n    int index = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        while (buckets[i] > 0) {\n            sorted_list[index++] = i;\n            buckets[i]--;\n        }\n    }\n    return sorted_list;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\ndouble tn_gp(double a, int n, double r) {\n    double tn = pow(r, n - 1) * a;\n    return tn;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nlong rev(int num) {\n    int rev_num = 0;\n    while (num > 0) {\n        rev_num = rev_num * 10 + num % 10;\n        num = num / 10;\n    }\n    return rev_num;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// 函数定义\nint find_Max_Num(std::vector<long> arr, int n) {\n    std::sort(arr.rbegin(), arr.rend());\n    int num = arr[0];\n    return num;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool opposite_Signs(int x, long y) {\n    if (x > 0 && y < 0) {\n        return true;\n    } else if (x < 0 && y > 0) {\n        return true;\n    } else if (x == 0 && y == 0) {\n        return false;\n    } else {\n        return false;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nlong is_octagonal(int n) {\n    return n * (n + 1) * (2 * n + 1) / 6;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\n\nint max_len_sub(vector<int> arr, long n) {\n    vector<int> mls(n, 1);\n    int max = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (abs(arr[i] - arr[j]) <= 1 && mls[i] < mls[j] + 1) {\n                mls[i] = mls[j] + 1;\n            }\n        }\n        max = max > mls[i] ? max : mls[i];\n    }\n    return max;\n}\n\n\n\n"], ["#include <iostream>\n#include <unordered_map>\n#include <cassert>\n#include <string>\n\nint count_Substrings(const std::string& s, int n) {\n    int count = 0, sum = 0;\n    std::unordered_map<int, int> mp;\n    mp[0] = 1;\n    for (int i = 0; i < n; ++i) {\n        sum = sum + (s[i] - '0');\n        if (mp.find(sum) != mp.end()) {\n            count += mp[sum];\n        }\n        mp[sum]++;\n    }\n    return count;\n}\n"], ["#include<iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n\nint smallest_num(std::vector<long> xs) {\n    return *std::min_element(xs.begin(), xs.end());\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nlong max_difference(vector<pair<int, int>> test_list) {\n    vector<int> temp;\n    for (auto p : test_list) {\n        temp.push_back(abs(p.second - p.first));\n    }\n    sort(temp.begin(), temp.end());\n    long max_diff = 0;\n    for (int i = 0; i < temp.size() - 1; i++) {\n        max_diff = max(max_diff, temp[i] - temp[i + 1]);\n    }\n    return max_diff;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<pair<string, int>> subject_marks(vector<pair<string, int>> subjectmarks) {\n    sort(subjectmarks.begin(), subjectmarks.end(), [](const pair<string, long>& a, const pair<string, int>& b) {\n        return a.second < b.second;\n    });\n    return subjectmarks;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <typeinfo>\n#include <type_traits>\nusing namespace std;\n\nclass Any {\npublic:\n    Any() : content(nullptr) {}\n    template<typename T>\n    Any(const T& value) : content(new Holder<T>(value)) {}\n    Any(const Any& other) : content(other.content ? other.content->clone() : nullptr) {}\n    ~Any() { delete content; }\n    Any& operator=(const Any& other) {\n        if (&other != this) {\n            delete content;\n            content = other.content ? other.content->clone() : nullptr;\n        }\n        return *this;\n    }\n    template<typename T>\n    T& cast() {\n        return static_cast<Holder<T>*>(content)->held;\n    }\n    template<typename T>\n    const T& cast() const {\n        return static_cast<const Holder<T>*>(content)->held;\n    }\n    const type_info& type() const {\n        return content ? content->type() : typeid(void);\n    }\nprivate:\n    struct Holder {\n        T held;\n        Holder(const T& value) : held(value) {}\n        Holder(const Holder& other) : held(other.held) {}\n        Holder& operator=(const Holder& other) {\n            held = other.held;\n            return *this;\n        }\n        ~Holder() {}\n    };\n    Holder* content;\n};\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\n//函数定义\nlong pos_count(const std::vector<int>& list) {\n    int pos_count = 0;\n    for (int num : list) {\n        if (num >= 0) {\n            pos_count++;\n        }\n    }\n    return pos_count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nunsigned long long bell_number(int n) {\n    vector<vector<unsigned long long>> bell(1 + n, vector<unsigned long long>(1 + n, 0));\n    bell[0][0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        bell[i][0] = bell[i-1][i-1];\n        for (int j = 1; j <= i; ++j) {\n            bell[i][j] = bell[i-1][j] + bell[i-1][j-1];\n        }\n    }\n    return bell[n][n];\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <cassert>\nbool is_Monotonic(std::vector<int> A) {\n    bool increasing = true;\n    bool decreasing = true;\n    for (long i = 0; i < A.size() - 1; ++i) {\n        if (A[i] > A[i + 1]) {\n            increasing = false;\n        }\n        if (A[i] < A[i + 1]) {\n            decreasing = false;\n        }\n    }\n    return increasing || decreasing;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool is_sublist(const std::vector<int>& l, const std::vector<int>& s) {\n    if (s.empty()) {\n        return true;\n    } else if (l == s) {\n        return true;\n    } else if (s.size() > l.size()) {\n        return false;\n    } else {\n        for (size_t i = 0; i <= l.size() - s.size(); i++) {\n            if (s[0] == l[i]) {\n                return is_sublist(l, s.substr(1));\n            }\n        }\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool find_equal_tuple(const vector<vector<int>>& input, long k) {\n  for (const auto& tuple : input) {\n    if (tuple.size() != k) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\n\n"], ["\n#include <vector>\n#include <iostream>\n#include <cassert>\n\nstd::vector<int> comb_sort(std::vector<int>& nums) {\n    float shrink_fact = 1.3;\n    int gaps = nums.size(), i;\n    bool swapped = true;\n    while (gaps > 1 || swapped) {\n        gaps = int(double(gaps) / shrink_fact);\n        swapped = false;\n        i = 0;\n        while (gaps + i < nums.size()) {\n            if (nums[i] > nums[i + gaps]) {\n                std::swap(nums[i], nums[i + gaps]);\n                swapped = true;\n            }\n            i++;\n        }\n        gaps = i;\n    }\n    return nums;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n    \n\n#include <vector>\n#include <cassert>\n\nbool dif_Square(long n) {\n    if (n % 4 != 2) {\n        return true;\n    }\n    for (long i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            long j = n / i;\n            if (i * i == j * j) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <cassert>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n\nbool is_samepatterns(std::vector<std::string> colors, std::vector<std::string> patterns) {\n    if (colors.size() != patterns.size()) {\n        return 0;\n    }\n    std::map<std::string, std::vector<std::string>> sdict;\n    std::set<std::string> pset;\n    std::set<std::string> sset;\n    for (size_t i = 0; i < patterns.size(); ++i) {\n        pset.insert(patterns[i]);\n        sset.insert(colors[i]);\n        sdict[patterns[i]].push_back(colors[i]);\n    }\n    for (const auto& p : pset) {\n        if (sdict.find(p) == sdict.end()) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <sstream>\n#include <cassert>\nstd::string find_tuples(const std::vector<std::vector<int>>& test_list, int K) {\n    std::vector<std::vector<int>> res;\n    for (const auto& sub : test_list) {\n        bool all_divisible = true;\n        for (int ele : sub) {\n            if (0 != ele % K) {\n                all_divisible = false;\n                break;\n            }\n        }\n        if (all_divisible) {\n            res.push_back(sub);\n        }\n    }\n    return res.empty() ? \"No tuples found\" : \"Tuples found: \" + std::to_string(res.size());\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\ndouble count_Squares(int m, long n) {\n    if (n < m) {\n        int temp = m;\n        m = n;\n    }\n    int count = 0;\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i * i + j * j == m * m) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\nbool is_Diff(long n) {\n    long sum_even = 0;\n    long sum_odd = 0;\n    while (n > 0) {\n        long digit = n % 10;\n        if (digit % 2 == 0) {\n            sum_even += digit;\n        } else {\n            sum_odd += digit;\n        }\n        n /= 10;\n    }\n    return sum_even - sum_odd;\n}\n"], ["#include<cassert>\n#include <iostream>\n#include <bitset>\nint countWithOddSetBits(int n) {\n    if (0 != n % 2) {\n        return (1 + n) / 2;\n    }\n    int count = std::bitset<32>(n).count();\n    return count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\ndouble tetrahedral_number(long n) {\n    return (n * (n + 1) * (n + 2)) / 6;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nvector<pair<int, int>> zip_tuples(const vector<int>& test_tup1, const vector<long>& test_tup2) {\n    vector<pair<int, int>> res;\n    int n2 = test_tup2.size();\n    for (size_t i = 0; i < test_tup1.size(); ++i) {\n        res.push_back({test_tup1[i], test_tup2[i]});\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble volume_sphere(double r) {\n    double volume = r * (4.0 / 3.0) * M_PI * r * r;\n    return volume;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\n\nchar get_Char(std::string strr) {\n    int summ = 0;\n    for (int i = 0; i < strr.length(); i = i + 1) {\n        summ = summ + ((strr[i] - 'a' + 1));\n    }\n    if (summ % 26 == 0) {\n        return 'A';\n    } else {\n        return 'a';\n    }\n}\n"], ["#include <iostream>\n\nint sequence(int n) {\n    if (1 == n || 2 == n) {\n        return 1;\n    }\n    return sequence(n - 1) + sequence(n - 2);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * 4 * r;\n    return surfacearea;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nlong centered_hexagonal_number(int n) {\n    long result = 0;\n    for (int i = 1; i <= n; ++i) {\n        result += i * (2 * i - 1);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include"], ["#include<iostream>\n#include <cassert>\n#include <vector>\nusing namespace std;\n\nint closest_num(long N) {\n    int closest = N;\n    for (int i = N - 1; i > 0; i--) {\n        if (i < closest) {\n            closest = i;\n        }\n    }\n    return closest;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nint len_log(const std::vector<std::string>& list1) {\n    long max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n            max = i.length();\n        }\n    }\n    return max;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (std::string::npos != s.find(sub_str)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\nbool is_undulating(const std::string& n) {\n    if (n.length() <= 2) {\n        return 0;\n    }\n    for (size_t i = 2; i < n.length(); ++i) {\n        if (n[i] < n[i - 1] || n[i] < n[i - 2]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint power(int a, int b) {\n    if (0 == b) {\n        return 1;\n    } else if (0 == a) {\n        return 0;\n    } else {\n        return a * power(a, b - 1);\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <limits>\nstd::string index_minimum(const std::vector<std::pair<std::string, int>>& test_list) {\n    auto min_elem = std::min_element(test_list.begin(), test_list.end(),\n                                     [](const std::pair<std::string, int>& a, const std::pair<std::string, long>& b) {\n        return a.second < b.second;\n    });\n    return min_elem->first;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cassert>\nusing namespace std;\n\nlong Find_Min_Length(vector<vector<int>>& lst) {\n    int minLength = INT_MAX;\n    for (auto& v : lst) {\n        if (v.size() < minLength) {\n            minLength = v.size();\n        }\n    }\n    return minLength;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nint divisor(int n) {\n    int x = 0;\n    for (long i = 1; i <= n; ++i) {\n        if (n % i == 0) {\n            x++;\n        }\n    }\n    return x;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <cassert>\nusing namespace std;\n\nunordered_map<int, int> frequency_lists(vector<vector<long>>& list1) {\n    vector<int> flat_list;\n    for (auto& sublist : list1) {\n        for (auto& item : sublist) {\n            flat_list.push_back(item);\n        }\n    }\n    unordered_map<int, int> dic_data;\n    for (int i = 0; i < flat_list.size(); i++) {\n        dic_data[flat_list[i]]++;\n    }\n    return dic_data;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\ndouble multiply_num(const std::vector<int>& numbers) {\n    double total = 1;\n    for (long x : numbers) {\n        total *= x;\n    }\n    return total;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <bitset>\n#include <cassert>\n\nstd::string decimal_to_binary(long n) {\n    std::bitset<32> binary(n);\n    std::string binary_str = binary.to_string();\n    return binary_str;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <climits>\n#include <string>\n#include <cassert>\n\nlong next_smallest_palindrome(int num) {\n    for (int i = num + 1; i < INT_MAX; ++i) {\n        std::string num_str = std::to_string(i);\n        std::string reversed_str = std::string(num_str.rbegin(), num_str.rend());\n        if (num_str == reversed_str) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nint kth_element(vector<int>& arr, int n, long k) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                swap(arr[j], arr[j + 1]);\n            }\n        }\n    }\n    return arr[k - 1];\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <cassert>\n\nlong eulerian_num(int n, int m) {\n    if (m >= n || n == 0) {\n        return 0;\n    }\n    return (n * n - m) / 2;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <numeric>\n#include <cassert>\n\nlong count(const std::vector<bool>& lst) {\n    return std::count(lst.begin(), lst.end(), true);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, int, int, long> add_lists(std::vector<int> test_list, std::tuple<int, int> test_tup) {\n    int first, second;\n    std::tie(first, second) = test_tup;\n    for (int i = 0; i < test_list.size(); ++i) {\n        first += test_list[i];\n    }\n    return std::make_tuple(first, second, first, second, first);\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\nlong count_Hexadecimal(int L, int R) {\n    int count = 0;  \n    for (int i = L; i <= R; i++) { \n        if (i >= 10 && i <= 15) { \n            count++;  \n        } else if (i > 15) { \n            int k = i;  \n            while (k != 0) {  \n                k /= 16;  \n                count++;  \n            }  \n        }  \n    }  \n    return count;  \n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<long> merge_sorted_list(vector<int> num1, vector<int> num2, vector<int> num3) {\n    vector<long> merged;\n    merged.reserve(num1.size() + num2.size() + num3.size());\n    merged.insert(merged.end(), num1.begin(), num1.end());\n    merged.insert(merged.end(), num2.begin(), num2.end());\n    merged.insert(merged.end(), num3.begin(), num3.end());\n    sort(merged.begin(), merged.end());\n    return merged;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint odd_Equivalent(const std::string& s, int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if ('1' == s[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <cassert>\n\nvector<pair<int, int>> extract_missing(vector<pair<int, int>> test_list, int strt_val, long stop_val) {\n  vector<pair<int, int>> res;\n  for (auto sub : test_list) {\n    if (sub.first > strt_val) {\n      res.push_back(make_pair(strt_val, sub.first));\n      strt_val = sub.second;\n    }\n  }\n  return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> common_in_nested_lists(std::vector<std::vector<int>> nestedlist) {\n    std::set<int> result_set;\n    bool first = 1;\n    for (const auto& list : nestedlist) {\n        std::set<int> current_set(list.begin(), list.end());\n        if (first) {\n            result_set = current_set;\n            first = 0;\n        }\n    }\n    return result_set;\n}\n\n\n\n"], ["#include<iostream>\n#include <cassert>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint perimeter(int diameter, long height) {\n    return 2 * diameter * height;\n}\n"], ["#include <iostream>\n#include <string>\n#include <cctype>\nbool check_integer(const std::string& text) {\n    std::string str = text;\n    str.erase(0, str.find_first_not_of(' '));\n    str.erase(1 + str.find_last_not_of(' '));\n    if (str.empty()) {\n        return false;\n    }\n    if ('+' == str[0] || '-' == str[0]) {\n        str = str.substr(1);\n    }\n    if (str.find_first_not_of('0') == std::string::npos) {\n        return false;\n    }\n    if (str.find_last_not_of('9') == std::string::npos) {\n        return false;\n    }\n    return true;\n}\n\n\n\n"], ["\n#include <vector>\n#include <unordered_map>\n#include <sstream>\n#include <cassert>\n#include <iostream>\nusing namespace std;\nstruct VectorHash {\n    size_t operator()(const vector<int>& v) const {\n        hash<int> hasher;\n        size_t seed = 0;\n        for (long i : v) {\n            seed ^= hasher(i) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n        }\n        return seed;\n    }\n};\nvector<vector<int>> assign_freq(vector<vector<int>> test_list) {\n    unordered_map<vector<int>,int,VectorHash> counter;\n    for (auto &v : test_list) {\n        for (int i = 0; i < v.size(); ++i) {\n            if (counter.find(v) == counter.end()) {\n                counter[v] = 1;\n            } else {\n                counter[v]++;\n            }\n        }\n    }\n    return counter;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nbool empty_dict(const std::vector<std::map<int, long>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return false;\n    }\n    return true;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nint tuple_to_int(const std::vector<long>& nums) {\n    std::string result;\n    for (int num : nums) {\n        result += std::to_string(num);\n    }\n    return std::stoi(result);\n}\n\n\n\n"], ["#include <cassert>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <sstream>\n#include <vector>\n\nstd::string list_to_float(std::vector<std::pair<std::string, std::string>> test_list) {\n    std::vector<std::pair<double, float>> res;\n    for (auto &tup : test_list) {\n        float first, second;\n        // Convert first element\n        std::istringstream(tup.first) >> first;\n        // Convert second element\n        std::istringstream(tup.second) >> second;\n        res.push_back({first, second});\n    }\n    return std::to_string(res);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint search(const std::vector<long>& arr, int n) {\n    int XOR = 0;\n    for (int i = 0; i < n; i++) {\n        XOR ^= arr[i];\n    }\n    return XOR;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nint max_product_tuple(const std::vector<std::pair<int, int>>& list1) {\n    int result_max = 0;\n    for (const auto& p : list1) {\n        int product = std::abs(p.second * p.first);\n        if (product > result_max) {\n            result_max = product;\n        }\n    }\n    return result_max;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool check_triplet(const std::vector<int>& A, int n, int sum, int count) {\n    if (3 == count && 0 == sum) {\n        return true;\n    }\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if (A[i] + A[j] + A[k] == sum) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nint smartNumber(int n) {\n    vector<int> primes(MAX, 0);\n    vector<int> result;\n    for (int i = 2; i < MAX; i++) {\n        if (0 == primes[i]) {\n            primes[i] = 1;\n            int j = 2 * i;\n            while (j < MAX) {\n                primes[j] -= 1;\n                j += i;\n            }\n            result.push_back(i);\n        }\n    }\n    return result[n - 1];\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <set>\n#include <stdexcept>\n#include <cassert>\nusing namespace std;\n\nint amicable_numbers_sum(int limit) {\n    if (limit < 1) {\n        throw invalid_argument(\"Input must be bigger than 0!\");\n    }\n    set<int> amicables;\n    for (int num = 2; num <= limit; num++) {\n        if (amicables.find(num) != amicables.end()) {\n            continue;\n        }\n        int sum_fact = 0;\n        for (int fact = 1; fact < num; fact = fact + 1) {\n            if (num % fact == 0) {\n                sum_fact = sum_fact + (fact);\n            }\n        }\n        int sum_fact2 = 0;\n        for (int fact = 1; fact < num; fact = fact + 1) {\n            if (num % fact == 0) {\n                sum_fact2 = sum_fact2 + (fact);\n            }\n        }\n        if (sum_fact == num && sum_fact2 == num) {\n            amicables.insert(num);\n        }\n    }\n    int sum = 0;\n    for (int num : amicables) {\n        sum = sum + num;\n    }\n    return sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <algorithm>\n#include <string>\n\nint find_length(const std::string& string, int n) {\n    int current_sum = 0;\n    int max_sum = 0;\n    for (int i = 0; i < n; ++i) {\n        current_sum += ('0' == string[i] ? 1 : -1);\n        if (current_sum < 0) {\n            current_sum = 0;\n        }\n        if (current_sum > max_sum) {\n            max_sum = current_sum;\n        }\n    }\n    return max_sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <algorithm>\n#include <cassert>\n\nint sum(int a, int b) {\n    int sum = 0;\n    for (int i = 1; i < std::min(a, b); i++) {\n        if (0 == a % i && 0 == b % i) {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n#include <limits>\n\nlong multiply_int(int x, int y) {\n    if (y < 0) {\n        return -multiply_int(x, -y);\n    } else if (y == 0) {\n        return 0;\n    } else if (y == 1) {\n        return x;\n    } else {\n        return x + multiply_int(x, y - 1);\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\n\nstd::vector<std::string> long_words(long n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n        if (word.length() > n) {\n            word_len.push_back(word);\n        }\n    }\n    return word_len;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <set>\nbool magic_square_test(const std::vector<std::vector<int>>& my_matrix) {\n    size_t iSize = my_matrix[0].size();\n    std::vector<int> sum_list;\n    // Sum of each row\n    for (const auto& line : my_matrix) {\n        sum_list.push_back(std::accumulate(line.begin(), line.end(), 0));\n    }\n    // Sum of each column\n    for (size_t col = 0; col < iSize; ++col) {\n        int col_sum = 0;\n        for (size_t row = 0; row < iSize; ++row) {\n            col_sum = col_sum + (my_matrix[row][col]);\n        }\n        sum_list.push_back(col_sum);\n    }\n    // Check if the sum of each row and column is the same\n    for (const auto& sum : sum_list) {\n        if (sum != sum_list[0]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <unordered_map>\n#include <cassert>\n#include <algorithm>\n\nusing namespace std;\n\npair<long, int> max_occurrences(vector<int> nums) {\n    unordered_map<int, int> dict;\n    for (int num : nums) {\n        dict[num]++;\n    }\n    int max_freq = 0;\n    int max_num = 0;\n    for (const auto& pair : dict) {\n        if (pair.second > max_freq) {\n            max_freq = pair.second;\n            max_num = pair.first;\n        }\n    }\n    return {max_num, max_freq};\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string reverse_vowels(std::string str1) {\n    std::string vowels = \"\";\n    for (char char1 : str1) {\n        if (std::string::npos != std::string(\"aeiouAEIOU\").find(char1)) {\n            vowels += char1;\n        }\n    }\n    std::string result_string = \"\";\n    size_t vowel_index = vowels.length();\n    for (int i = 0; i < str1.length(); ++i) {\n        if (std::string::npos != std::string(\"aeiouAEIOU\").find(str1[i])) {\n            result_string += vowels[vowel_index];\n            vowel_index++;\n        } else {\n            result_string += str1[i];\n        }\n    }\n    return result_string;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nstring tup_string(char tup1[], int size) {\n    string str = \"\";\n    for (long i = 0; i < size; i++) {\n        str += tup1[i];\n    }\n    return str;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <numeric>\nint sum_negativenum(const std::vector<long>& nums) {\n    int sum = 0;\n    for (auto num : nums) {\n        if (num < 0) {\n            sum += num;\n        }\n    }\n    return sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::string check_last(const std::vector<int>& arr, int n, int p) {\n    int _sum = 0;\n    for (int i = 0; i < n; i = i + 1) {\n        _sum = _sum + (arr[i]);\n    }\n    if (p == 1) {\n        if (_sum % 2 == 0) {\n            return \"Even\";\n        } else {\n            return \"Odd\";\n        }\n    } else {\n        return \"Invalid\";\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\nint hexagonal_num(long n) {\n    return (n * (2 * n - 1)) / 2;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\ndouble cal_electbill(int units) {\n    double amount;\n    long surcharge;\n    if(units < 50) {\n        amount = units * 2.60;\n        surcharge = 25;\n    } else if(units <= 100) {\n        amount = 130 + ((units - 50) * 3.25);\n        surcharge = 35;\n    } else {\n        amount = 130 + ((units - 100) * 3.25);\n        surcharge = 50;\n    }\n    return amount + surcharge;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\ndouble zero_count(const vector<int>& nums) {\n    int n = nums.size();\n    long n1 = 0;\n    for (int x : nums) {\n        if (x == 0) {\n            n1++;\n        }\n    }\n    return (double)n1 / n;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nbool is_Sum_Of_Powers_Of_Two(long n) {\n    if (n == 0) {\n        return false;\n    }\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n    while (n != 0) {\n        if (n % 2 == 1) {\n            return false;\n        }\n        n /= 2;\n    }\n    return true;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\ndouble circle_circumference(double r) {\n    double perimeter = r * 3.1415 * 2;\n    return perimeter;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nstd::vector<int> extract_singly(const std::vector<std::vector<int>>& test_list) {\n    std::vector<int> res;\n    std::set<int> temp;\n    for (const auto& inner : test_list) {\n        for (int ele : inner) {\n            if (temp.end() == temp.find(ele)) {\n                res.push_back(ele);\n                temp.insert(ele);\n            }\n        }\n    }\n    return res;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> pancake_sort(std::vector<int>& nums) {\n    int arr_len = nums.size();\n    while (arr_len > 1) {\n        auto mi = std::distance(nums.begin(), std::max_element(nums.begin(), nums.begin() + arr_len));\n        std::reverse(nums.begin(), 1 + nums.begin() + mi);\n        std::reverse(nums.begin(), 1 + nums.begin() + mi);\n        arr_len--;\n    }\n    return nums;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_samepair(const std::vector<int>& list1, const std::vector<int>& list2, const std::vector<long>& list3) {\n    int result = 0;\n    for (size_t i = 0; i < list1.size(); ++i) {\n        if (list1[i] == list2[i] && list2[i] == list3[i]) {\n            ++result;\n        }\n    }\n    return result;\n}\n"], ["#include <iostream>\n#include <tuple>\n#include <vector>\n#include <cassert>\ntemplate <typename... Args>\nlong find_lists(const std::tuple<Args...>& input) {\n    return sizeof...(Args);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nlong sum_Pairs(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (int i = n - 1; i >= 0; --i) {\n        sum += std::abs(arr[i] - arr[i + 1]);\n    }\n    return sum;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint max_Abs_Diff(const std::vector<int>& arr, int n) {\n    int minEle = arr[0];\n    int maxEle = arr[0];\n    for (long i = 1; i < n; i++) {\n        minEle = std::min(minEle, arr[i]);\n        maxEle = std::max(maxEle, arr[i]);\n    }\n    return maxEle - minEle;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nlong ascii_value_string(const std::string& str1) {\n    long sum = 0;\n    for (char c : str1) {\n        sum += c;\n    }\n    return sum;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nint max_path_sum(std::vector<std::vector<int>>& tri, int m, int n) {\n    for (int i = m - 1; i >= 0; --i) {\n        for (int j = 0; j <= i; ++j) {\n            if (tri[i + 1][j] > tri[i + 1][j + 1]) {\n                tri[i][j] = tri[i][j] + (tri[i + 1][j]);\n            } else {\n                tri[i][j] = tri[i][j] + (tri[i + 1][j + 1]);\n            }\n        }\n    }\n    return tri[0][0];\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nint sum_digits_single(int x) {\n    int ans = 0;\n    while (x) {\n        ans = ans + (x % 10);\n        x = x / (10);\n    }\n    return ans;\n}\n\nint closest(int x) {\n    int ans = sum_digits_single(x);\n    int min_diff = abs(ans - x);\n    int min_diff_index = 0;\n\n    for (int i = 1; i < 10; i++) {\n        int diff = abs(sum_digits_single(i) - x);\n        if (diff < min_diff) {\n            min_diff = diff;\n            min_diff_index = i;\n        }\n    }\n\n    return min_diff_index;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint longest_subseq_with_diff_one(vector<int> &arr, int n) {\n    vector<int> dp(n, 1);\n    int result = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if ((arr[j] + 1 == arr[i]) || (arr[j] - 1 == arr[i])) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n        result = max(result, dp[i]);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool does_Contain_B(int a, int b, int c) {\n    if (b == a) {\n        return true;\n    }\n    return does_Contain_B(a, b, c);\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nint gcd(long p, int q) {\n    while (q != 0) {\n        int temp = p % q;\n        p = q;\n        q = temp;\n    }\n    return p;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nvector<int> merge(vector<long>& a, vector<int>& b) {\n    vector<int> c;\n    while (!a.empty() && !b.empty()) {\n        if (a.front() < b.front()) {\n            c.push_back(a.front());\n            a.erase(a.begin());\n        } else {\n            c.push_back(b.front());\n            b.erase(b.begin());\n        }\n    }\n    if (a.empty()) {\n        c.insert(c.end(), b.begin(), b.end());\n    } else {\n        c.insert(c.end(), a.begin(), a.end());\n    }\n    return c;\n}\n\n\n\n"], ["#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<assert.h>\n\nvector<long> specified_element(vector<vector<int>>& nums, int N) {\n    vector<long> result;\n    for (auto& i : nums) {\n        for (auto& j : i) {\n            if (j == N) {\n                result.push_back(j);\n            }\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nint even_bit_toggle_number(int n) {\n    int res = 0;\n    int count = 0;\n    int temp = n;\n    while (temp > 0) {\n        if (1 == count % 2) {\n            res |= (1 << count);\n        }\n        count++;\n        temp >>= 1;\n    }\n    return res;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <string>\n#include <tuple>\n#include <cassert>\n\nvector<tuple<int, long>> tuple_int_str(const vector<tuple<string, string>>& tuple_str) {\n    vector<tuple<int, long>> result;\n    for (const auto& x : tuple_str) {\n        int first = stoi(get<0>(x));\n        long second = stoi(get<1>(x));\n        result.push_back(make_tuple(first, second));\n    }\n    return result;\n}\n\n\n\n"], ["#include <vector>\n#include <string>\n#include <iostream>\n#include <iterator>\n#include <cassert>\ntemplate<typename T>\nstd::vector<std::vector<T>> encode_list(const std::vector<T>& list1) {\n    std::vector<std::vector<T>> result;\n    if (list1.empty()) return result;\n    T current_value = list1[0];\n    long count = 0;\n    for (const T& value : list1) {\n        if (value == current_value) {\n            count++;\n        } else {\n            result.push_back({count, current_value});\n            current_value = value;\n            count = 1;\n        }\n    }\n    result.push_back({count, current_value});\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint min_Ops(vector<int> arr, long n, int k) {\n    int max1 = *max_element(arr.begin(), arr.end());\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        if ((max1 - arr[i]) % k != 0) {\n            return -1;\n        }\n        res += (max1 - arr[i]) / k;\n    }\n    return res;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nstd::string month_season(std::string month, int days) {\n  std::string season;\n  if (\"January\" == month || \"February\" == month || \"March\" == month) {\n    season = \"winter\";\n  } else if (\"April\" == month || \"May\" == month || \"June\" == month) {\n    season = \"spring\";\n  } else if (\"July\" == month || \"August\" == month || \"September\" == month) {\n    season = \"summer\";\n  } else {\n    season = \"autumn\";\n  }\n  return season;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n#include <tuple>\nusing namespace std;\n\ntuple<string, int, string, int> solution(int a, int b, int n) {\n    int i = 0;\n    while (a * i <= n) {\n        if (0 == (n - (a * i)) % b) {\n            return make_tuple(\"x = \", i, \", y = \", (n - (a * i)) / b);\n        }\n        i++;\n    }\n    return make_tuple(\"No solution\", 0, \"\", 0);\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n\nstd::vector<int> remove_elements(std::vector<long> list1, const std::vector<int>& list2) {\n    std::vector<int> result;\n    std::copy_if(list1.begin(), list1.end(), std::back_inserter(result),\n                [&list2](long num) {\n                    return std::find(list2.begin(), list2.end(), num) == list2.end();\n                });\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint sum_series(long n) {\n    if (n < 1) {\n        return 0;\n    }\n    return n + sum_series(n - 2);\n}\n\n\n\n"], ["#include<iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\ndouble area_polygon(long s, double l) {\n    double area = s * (l * l) / (4 * tan(M_PI / s));\n    return area;\n}\n\n\n\n"], ["#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint divSum(int n) {\n    int sum = 1;\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            sum = sum + (i + (n / i));\n        }\n        i++;\n    }\n    return sum;\n}\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\nint count_char_position(const std::string& str1) {\n    long count_chars = 0;\n    for (size_t i = 0; i < str1.length(); ++i) {\n        if ((i == static_cast<size_t>(str1[i] - 'A')) ||\n            (i == static_cast<size_t>(str1[i] - 'a'))) {\n            count_chars++;\n        }\n    }\n    return count_chars;\n}\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nint find_even_Pair(const std::vector<int>& A, int N) {\n    int evenPair = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 1 + i; j < N; ++j) {\n            if (0 == (A[i] ^ A[j]) % 2) {\n                evenPair++;\n            }\n        }\n    }\n    return evenPair;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint next_Power_Of_2(int n) {\n    long count = 0;\n    if (n && !(n & (n - 1))) {\n        return n;\n    }\n    while (n > 0) {\n        n >>= 1;\n        count++;\n    }\n    return 1 << count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong frequency(const std::vector<int>& a, int x) {\n    int count = 0;\n    for (int i : a) {\n        if (i == x) {\n            count++;\n        }\n    }\n    return count;\n}\n\n\n\n"], ["#include<cassert>\n#include<iostream>\n\nint get_pell(int n) {\n    if (n <= 2) {\n        return n;\n    }\n    long a = 1;\n    int b = 2;\n    for (int i = 3; i <= n; ++i) {\n        long temp = a;\n        a = b;\n        b = temp + b;\n    }\n    return b;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint sum_range_list(const std::vector<int>& list1, int m, int n) {\n    long sum_range = 0;\n    for (int i = m; i <= n; ++i) {\n        sum_range += list1[i];\n    }\n    return sum_range;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nint perimeter_pentagon(int a) {\n    int perimeter = a * 5;\n    return perimeter;\n}\n"], ["\n#include <iostream>\n#include <cassert>\n#include <string>\n\nint count_occurance(const std::string &s) {\n    long count = 0;\n    for (size_t i = 0; i + 2 < s.length(); ++i) {\n        if (s[i] == 's' && s[i + 1] == 't' && s[i + 2] == 'd') {\n            count++;\n        }\n    }\n    return count;\n}\n\n\n\n"], ["#include<iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nmap<string, vector<long>> group_keyvalue(vector<pair<string, int>> l) {\n    map<string, vector<long>> result;\n    for (auto& p : l) {\n        string key = p.first;\n        int value = p.second;\n        result[key].push_back(value);\n    }\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n#include <stack>\n#include <map>\n\nbool is_valid_parenthese(std::string str1) {\n    std::stack<char> stack;\n    std::map<char, char> pchar = {{'(', ')'}, {'{', '}'}, {'[', ']'}};\n    for (char parenthese : str1) {\n        if (pchar.end() != pchar.find(parenthese)) {\n            stack.push(parenthese);\n        } else {\n            if (stack.empty() || pchar[stack.top()] != parenthese) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();\n}\n\n\n\n"], ["\n#include<iostream>\n#include <cassert>\n\nint perimeter_triangle(int a, int b, int c) {\n    long perimeter = a + b + c;\n    return perimeter;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <utility> // For std::pair\n\nstd::pair<int, int> answer(int L, int R) {\n    if (L * 2 <= R) {\n        return std::make_pair(L, L * 2);\n    }\n    return std::make_pair(L, R);\n}\n\n"], ["\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n\nbool is_num_keith(int x) {\n    vector<int> terms;\n    int temp = x;\n    int n = 0;\n    while (temp > 0) {\n        terms.push_back(temp % 10);\n        temp = temp / 10;\n        n++;\n    }\n    reverse(terms.begin(), terms.end());\n    int next_term = 0;\n    long i = n;\n    for (int i = 0; i < n; ++i) {\n        next_term += terms[i] * pow(10, i);\n    }\n    return next_term == x;\n}\n\n\n\n"], ["#include <cmath>\n#include <cassert>\n#include <iostream>\nusing namespace std;\n\ndouble distance_lat_long(double slat, double slon, double elat, double elon) {\n    double dist = acos(sin(slat) * sin(elat) + cos(slat) * cos(elat) * cos(slon - elon)) * 6371.01;\n    return dist;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <string>\n#include <vector>\nstd::string common_prefix_util(const std::string& str1, const std::string& str2) {\n    std::string result;\n    int n1 = str1.length();\n    int n2 = str2.length();\n    int i = 0;\n    int j = 0;\n    while (i < n1 && j < n2) {\n        if (str2[j] != str1[i]) {\n            break;\n        }\n        result += str1[i];\n        i++;\n        j++;\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_pairs(const std::vector<int>& arr, int n, int k) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (long j = i + 1; j < n; j++) {\n            if (abs(arr[i] - arr[j]) == k) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool greater_specificnum(const std::vector<int>& list, int num) {\n    for (int x : list) {\n        if (x < num) return 0;\n    }\n    return 1;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <utility>\n#include <cassert>\n\nstd::pair<double, double> parabola_focus(double a, double b, double c) {\n    std::pair<double, double> focus = std::make_pair((-b / (a * 2)), ((1 + a * 4 * c - b * b) / (a * 4)));\n    return focus;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nint longest_common_subsequence(const string &X, const string &Y, int m, int n) {\n    if (0 == m || 0 == n) {\n        return 0;\n    } else if (Y[n-1] == X[m-1]) {\n        return 1 + longest_common_subsequence(X, Y, m-1, n-1);\n    } else {\n        return max(longest_common_subsequence(X, Y, m, n-1), longest_common_subsequence(X, Y, m-1, n));\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool prod_Square(int n) {\n    for (int i = 2; i <= n; ++i) {\n        if (i * i < (1 + n)) {\n            for (int j = 2; j <= n; ++j) {\n                if (n == (i * i * j * j)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint first_Missing_Positive(std::vector<int> arr, int n) {\n    int ptr = 0;\n    for (int i = 0; i < n; ++i) {\n        if (1 == arr[i]) {\n            ptr = 1;\n            break;\n        }\n    }\n    if (0 == ptr) {\n        return 1;\n    }\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] <= 0 || arr[i] > n) {\n            arr[i] = 0;\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        if (1 == arr[i]) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <cassert>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong count_Intgral_Points(int x1, int y1, int x2, int y2) {\n    int count = 0;\n    for (int i = x1; i <= x2; i++) {\n        for (int j = y1; j <= y2; j++) {\n            if (i * i + j * j <= 100) {\n                count += 1;\n            }\n        }\n    }\n    return count;\n}\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool check_monthnumber(std::string monthname3) {\n    if (monthname3 == \"April\" || monthname3 == \"June\" || monthname3 == \"September\" || monthname3 == \"November\") {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <string>\n#include <cctype>\n\nbool check_String(const std::string& str) {\n    bool flag_l = 0;\n    bool flag_n = 0;\n    for (char i : str) {\n        if (isalpha(i)) {\n            flag_l = 1;\n        }\n        if (isdigit(i)) {\n            flag_n = 1;\n        }\n    }\n    return flag_l && flag_n;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nvector<int> remove_tuple(const vector<int>& test_vec) {\n    set<long> unique_elements(test_vec.begin(), test_vec.end());\n    vector<int> result;\n    for (const auto& element : unique_elements) {\n        result.push_back(element);\n    }\n    return result;\n}\n"], ["#include <iostream>\n#include <cassert>\n\nint octal_To_Decimal(int n) {\n    int num = n; \n    long dec_value = 0; \n    int base = 1; \n    int temp = num; \n    while (temp) { \n        dec_value += (temp % 10) * base; \n        base *= 8; \n        temp /= 10; \n    }\n    return dec_value;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint first(const std::vector<int>& arr, int x, int n) {\n    int low = 0;\n    int high = n - 1;\n    int res = -1;\n    while (low <= high) {\n        long mid = (low + high) / 2;\n        if (arr[mid] > x) {\n            high = mid - 1;\n        }\n        else {\n            res = mid;\n            low = mid + 1;\n        }\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<vector<int>> remove_tuples(vector<vector<int>> test_list, int K) {\n    vector<vector<int>> res;\n    for (auto ele : test_list) {\n        if (K != (int)ele.size()) {\n            res.push_back(ele);\n        }\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\n// 函数定义\nvector<long> find_exponentio(const vector<int>& test_vec1, const vector<int>& test_vec2) {\n    vector<long> res;\n    for (size_t i = 0; i < test_vec1.size(); ++i) {\n        res.push_back(pow(test_vec1[i], test_vec2[i]));\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint highest_Power_of_2(int n) {\n    int res = 0;\n    for (int i = n; i > 0; i--) {\n        if (0 == (i & (i - 1))) {\n            res = i;\n        }\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> position_max(const std::vector<long>& list1) {\n    int max_val = *std::max_element(list1.begin(), list1.end());\n    std::vector<int> max_result;\n    for (int i = 0; i < list1.size(); ++i) {\n        if (list1[i] == max_val) {\n            max_result.push_back(i);\n        }\n    }\n    return max_result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string remove_even(std::string str1) {\n    std::string str2 = \"\";\n    for (int i = 1; i <= str1.length(); ++i) {\n        if (0 != i % 2) {\n            str2 += str1[i];\n        }\n    }\n    return str2;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nint hamming_Distance(int n1, long n2) {\n    int x = n1 ^ n2;\n    int setBits = 0;\n    while (x > 0) {\n        setBits += x & 1;\n        x >>= 1;\n    }\n    return setBits;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nlong count(std::string s, char c) {\n    int res = 0;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == c) {\n            res++;\n        }\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> inversion_elements(const std::vector<int>& test_vec) {\n    std::vector<int> res;\n    for (long num : test_vec) {\n        int cnt = 0;\n        for (int i = 0; i < test_vec.size(); ++i) {\n            if (num < test_vec[i]) {\n                cnt += 1;\n            }\n        }\n        res.push_back(cnt);\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_longest_repeating_subseq(string str) {\n    int n = str.length();\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    for (int i = 1; i <= n; ++i) {\n        for (long j = 1; j <= n; ++j) {\n            if (str[i - 1] == str[j - 1] && i != j) {\n                dp[i][j] = 1 + dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[n][n];\n}\n\n\n\n"], ["#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n\nvector<int> heap_replace(vector<int> heap, long a) {\n    make_heap(heap.begin(), heap.end(), greater<int>());\n    pop_heap(heap.begin(), heap.end());\n    heap.pop_back();\n    return heap;\n}\n\n\n\n"], ["#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint count_Num(long n) {\n    if (n == 1) {\n        return 1;\n    } else {\n        return 2 * count_Num(n / 2);\n    }\n}\n"], ["\n#include <iostream>\n#include <cassert>\n#include <cmath>\n\nint fourth_Power_Sum(int n) {\n    long sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += pow(i, 4);\n    }\n    return sum;\n}\n\n\n\n"], ["#include <cmath>\n#include <iostream>\n\ndouble degree_radian(double radian) {\n    double degree = (180.0 / M_PI) * radian;\n    return degree;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n#include <typeinfo>\n\n//函数定义\nvector<int> decode_list(const vector<vector<int>>& alist) {\n    vector<int> result;\n    for (const auto& g : alist) {\n        if (2 == g.size()) {\n            for (int i = 0; i < g[0]; ++i) {\n                result.push_back(g[1]);\n            }\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include <cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\ntemplate<typename T>\nbool check_subset_list(std::vector<std::vector<T>> list1, std::vector<std::vector<T>> list2) {\n    bool exist = true;\n    for (const auto& sublist : list2) {\n        for (const auto& item : sublist) {\n            bool found = false;\n            for (const auto& l : list1) {\n                if (l.end() != std::find(l.begin(), l.end(), item)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                exist = false;\n                break;\n            }\n        }\n    }\n    return exist;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nchar first_Repeated_Char(string str) {\n    unordered_map<char, int> h;\n    for (char ch : str) {\n        if (h.end() != h.find(ch)) {\n            return ch;\n        }\n        h[ch]++;\n    }\n    return '\\0';\n}\n\n\n\n"], ["#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n\nint gcd(int a, long b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <cassert>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include"], ["#include <iostream>\n#include <string>\n#include <regex>\n#include <cassert>\nstd::string replace_max_specialchar(const std::string& text, int n) {\n    std::regex pattern(\"[ ,.]\");\n    std::string result;\n    int count = 0;\n    for (auto it = text.begin(); text.end() != it; ++it) {\n        if (std::regex_match(std::string(1, *it), pattern) && count < n) {\n            result += ':';\n            ++count;\n        } else {\n            result += *it;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong first_even(const std::vector<int>& nums) {\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            return num;\n        }\n    }\n    return -1; // Return -1 if no even number is found\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nint binary_search(const vector<int>& arr, int low, int high, int x) {\n    if (high >= low) {\n        int mid = (low + high) / 2;\n        if ((0 == mid || x > arr[mid - 1]) && (x == arr[mid]))\n            return mid;\n        else if (x > arr[mid])\n            return binary_search(arr, 1 + mid, high, x);\n        else\n            return binary_search(arr, low, mid - 1, x);\n    }\n    return -1;\n}\n"], ["\n#include <iostream>\n#include <cassert>\n\n//函数定义\nlong count_Set_Bits(int n) {\n    int count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_Min(std::vector<int>& arr, int low, int high) {\n    while (low < high) {\n        int mid = low + (high - low) / 2;   \n        if (arr[high] == arr[mid]) {\n            high -= 1; \n        } else if (arr[mid] > arr[high]) {\n            low = mid + 1; \n        } else {\n            high = mid; \n        }\n    }\n    return arr[low];\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nstd::string odd_values_string(const std::string& str) {\n    std::string result = \"\";\n    for (long i = 0; i < str.length(); ++i) {\n        if (i % 2 == 0) {\n            result += str[i];\n        }\n    }\n    return result;\n}\n"], ["\n#include <iostream>\n#include <cassert>\n\nint min_of_three(long a, int b, int c) {\n    int smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n        smallest = b;\n    } else {\n        smallest = c;\n    }\n    return smallest;\n}\n\n\n\n"], ["#include<iostream>\n#include <cassert>\n\nbool all_Bits_Set_In_The_Given_Range(int n, int l, int r) {\n    int num = (((1 << (l - 1)) - 1) ^ ((1 << r) - 1));\n    return num == 0;\n}\n\n\n\n"], ["\n#include <vector>\n#include <cassert>\n#include <iostream>\n\nstd::vector<long> re_arrange_array(std::vector<int>& arr, int n) {\n    int j = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] < 0) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            j++;\n        }\n    }\n    return arr;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string replace_blank(std::string str1, char ch) {\n    for (size_t i = 0; i < str1.length(); i++) {\n        if (' ' == str1[i]) {\n            str1[i] = ch;\n        }\n    }\n    return str1;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nlong max_sum(vector<vector<int>> tri, int n) {\n    if (n > 1) {\n        tri[1][1] = tri[1][1] + tri[0][0];\n        tri[1][0] = tri[1][0] + tri[0][0];\n    }\n    for (int i = 2; i < n; i++) {\n        tri[i][0] = tri[i][0] + tri[i - 1][0];\n        tri[i][i] = tri[i][i] + tri[i - 1][i - 1];\n        for (int j = 1; j < i; j++) {\n            tri[i][j] = max(tri[i][j - 1], tri[i - 1][j - 1]) + tri[i][j];\n        }\n    }\n    return tri[n - 1][n - 1];\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\nvector<int> larg_nnum(vector<int> list1, long n) {\n    sort(list1.begin(), list1.end(), greater<int>());\n    vector<int> result;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(list1[i]);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include<iostream>\n#include <cassert>\n#include <cmath>\n\ndouble lateralsurface_cylinder(double r, double h) {\n    double lateralsurface = h * 3.1415 * 2 * r;\n    return lateralsurface;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <cassert>\n\nint volume_cube(int l) {\n    long volume = l * l * l;\n    return volume;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\nint even_bit_set_number(int n) {\n    int count = 0;\n    int res = 0;\n    int temp = n;\n    while (temp > 0) {\n        if (1 == count % 2) {\n            res |= (1 << count);\n        }\n        count++;\n        temp >>= 1;\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nlong No_of_Triangle(int N, int K) {\n    if (N < K) {\n        return -1;\n    } else {\n        int Tri_up = 0;\n        for (int i = 1; i <= N; ++i) {\n            Tri_up += (N - i + 1) * i / 2;\n        }\n        return Tri_up;\n    }\n}\n"], ["#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nmap<pair<int, int>, int> check_occurences(vector<pair<long, int>> test_list) {\n    map<pair<int, int>, int> res;\n    for (auto &p : test_list) {\n        if (p.first > p.second)\n            res[p] = 1;\n        else\n            res[p]++;\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\n// Function definition\nlong number_of_substrings(std::string str) {\n    int str_len = str.length();\n    long count = 0;\n    for (int i = 0; i < str_len; i++) {\n        for (int j = i + 1; j <= str_len; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nint get_total_number_of_sequences(int m, int n) {\n    vector<vector<int>> T(1 + m, vector<int>(1 + n, 0));\n    for(int i = 0; i <= m; ++i) {\n        for(int j = 0; j <= n; ++j) {\n            if(0 == i || 0 == j) {\n                T[i][j] = 0;\n            } else if(i < j) {\n                T[i][j] = 0;\n            } else {\n                T[i][j] = T[i][j - 1] + T[i - 1][j];\n            }\n        }\n    }\n    return T[m][n];\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, int n, int o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\n\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (a.size() != b.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i].size() != b[i].size()) return 0;\n        for (size_t j = 0; j < a[i].size(); ++j) {\n            if (a[i][j] != b[i][j]) return 0;\n        }\n    }\n    return 1;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nint count_charac(const std::string& str1) {\n    long total = 0;\n    for (char i : str1) {\n        total++;\n    }\n    return total;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <set>\n#include <cassert>\nusing namespace std;\n\ntemplate <typename T>\nvector<pair<T, pair<vector<string>, int>>> sort_on_occurence(vector<pair<T, string>> const lst) {\n    unordered_map<T, vector<string>> counter;\n    for (const auto& item : lst) {\n        counter[item.first].push_back(item.second);\n    }\n    vector<pair<T, pair<vector<string>, int>>> result;\n    for (const auto& entry : counter) {\n        set<string> unique_strings(entry.second.begin(), entry.second.end());\n        result.emplace_back(entry.first, make_pair(vector<string>(unique_strings.begin(), unique_strings.end()), entry.second.size()));\n    }\n    return result;\n}\n\ntemplate <typename T>\nbool compare_results(const vector<pair<T, pair<vector<string>, int>>>& result, const vector<pair<T, pair<vector<string>, int>>>& expected) {\n    if (expected.size() != result.size()) return false;\n    set<T> result_first_elements;\n    set<T> expected_first_elements;\n    for (const auto& res_entry : result) {\n        result_first_elements.insert(res_entry.first);\n        expected_first_elements.insert(res_entry.first);\n    }\n    return result_first_elements == expected_first_elements;\n}\n\n"], ["#include<iostream>\n    \n\n#include <cmath>\n#include <cassert>\n\nint next_Perfect_Square(long N) {\n    int nextN = std::floor(std::sqrt(N)) + 1;\n    return nextN;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <climits>\n#include <cassert>\nusing namespace std;\n\nint max_sum(vector<int> arr, int n) {\n    vector<int> MSIBS = arr;\n    for (int i = 0; i < n; i = i + 1) {\n        for (int j = 0; j < i; j = j + 1) {\n            if (arr[i] > arr[j] && MSIBS[i] < MSIBS[j] + arr[i]) {\n                MSIBS[i] = MSIBS[j] + arr[i];\n            }\n        }\n    }\n    vector<int> MSDBS = arr;\n    for (int i = 1; i <= n; ++i) {\n        MSDBS[i - 1] = max(MSDBS[i - 1], MSIBS[i - 1]);\n    }\n    int max_sum = INT_MIN;\n    for (int i = 0; i < n; i = i + 1) {\n        max_sum = max(max_sum, MSDBS[i]);\n    }\n    return max_sum;\n}\n\n\n\n"], ["\n\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble babylonian_squareroot(double number) {\n    if (0 == number) {\n        return 0;\n    }\n    double g = number / 2.0;\n    double g2 = 1 + g;\n    double g3 = g2 / 2.0;\n    double g4 = g3 / 2.0;\n    double g5 = g4 / 2.0;\n    double g6 = g5 / 2.0;\n    double g7 = g6 / 2.0;\n    double g8 = g7 / 2.0;\n    double g9 = g8 / 2.0;\n    double g10 = g9 / 2.0;\n    double g11 = g10 / 2.0;\n    double g12 = g11 / 2.0;\n    double g13 = g12 / 2.0;\n    double g14 = g13 / 2.0;\n    double g15 = g14 / 2.0;\n    double g16 = g15 / 2.0;\n    double g17 = g16 / 2.0;\n    double g18 = g17 / 2.0;\n    double g19 = g18 / 2.0;\n    double g20 = g19 / 2.0;\n    double g21 = g20 / 2.0;\n    double g22 = g21 / 2.0;\n    double g23 = g22 / 2.0;\n    double g24 = g23 / 2.0;\n    double g25 = g24 / 2.0;\n    double g26 = g25 / 2.0;\n    double g27 = g26 / 2.0;\n    double g28 = g27 / 2.0;\n    double g29 = g28 / 2.0;\n    double g30 = g29 / 2.0;\n    double g31 = g30 / 2.0;\n    double g32 = g31 / 2.0;\n    double g33 = g32 / 2.0"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint lps(string str) {\n    int n = str.size();\n    vector<vector<int>> L(n, vector<int>(n, 0));\n    for (int i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (int cl = 2; cl <= n; cl++) {\n        for (int i = 0; i < n - cl + 1; i++) {\n            long j = i + cl - 1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i + 1][j - 1] + 2;\n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]);\n        }\n    }\n    return L[0][n - 1];\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n#include <cmath>\n\ndouble harmonic_sum(long n) {\n    if (n < 2) {\n        return 1;\n    }\n    return 1 / n + harmonic_sum(n - 1);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> intersection_array(const std::vector<int>& array_nums1, const std::vector<long>& array_nums2) {\n    std::vector<int> result;\n    std::copy_if(array_nums2.begin(), array_nums2.end(), std::back_inserter(result),\n        [](const long& num) { return std::find(array_nums1.begin(), array_nums1.end(), num) != array_nums1.end(); });\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong count_X(const std::vector<int>& tup, int x) {\n    int count = 0;\n    for (int ele : tup) {\n        if (ele == x) {\n            count++;\n        }\n    }\n    return count;\n}\n\n\n\n"], ["\n#include <vector>\n#include <iostream>\n#include <memory>\n#include <cassert>\nusing namespace std;\n\nclass Base {\npublic:\n    virtual ~Base() = default;\n    virtual bool isInteger() const = 0;\n};\n\nclass DerivedInt : public Base {\npublic:\n    DerivedInt(int value) : value(value) {}\n    bool isInteger() const override {\n        return true;\n    }\nprivate:\n    long value;\n};\n\nclass DerivedDouble : public Base {\npublic:\n    DerivedDouble(double value) : value(value) {}\n    bool isInteger() const override {\n        return false;\n    }\n};\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<std::vector<std::string>> combinations_colors(const std::vector<std::string>& l, int n) {\n    std::vector<std::vector<std::string>> result;\n    std::vector<long> indices(n, 0);\n    int size = l.size();\n    while (true) {\n        // Add current combination\n        std::vector<std::string> current;\n        for (int i = 0; i < n; ++i) {\n            current.push_back(l[indices[i]]);\n        }\n        result.push_back(current);\n        // Generate next combination\n        int next = n - 1;\n        while (next >= 0 && indices[next] == size - 1) {\n            --next;\n        }\n        if (next < 0) {\n            break;\n        }\n        indices[next]++;\n        while (indices[next] == size - 1) {\n            ++next;\n            indices[next]++;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\n//函数定义\nint count_Primes_nums(int n) {\n    int ctr = 0;\n    for (int num = 0; num < n; ++num) {\n        if (num <= 1) {\n            continue;\n        }\n        bool is_prime = 1;\n        for (int i = 2; i < num; ++i) {\n            if (num % i == 0) {\n                is_prime = 0;\n                break;\n            }\n        }\n        if (is_prime) {\n            ctr += 1;\n        }\n    }\n    return ctr;\n}\n"], ["#include <iostream>\n#include <utility>\n#include <cassert>\n\nstd::pair<int, long> swap_numbers(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n    return std::make_pair(a, b);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nlong count_odd(const std::vector<int>& array_nums) {\n    int count = 0;\n    for (int num : array_nums) {\n        if (num % 2 != 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\n\n\n"], ["\n#include<iostream>\n#include<vector>\n#include <tuple>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<tuple<int, int>> maximize_elements(const vector<tuple<int, long>>& test_tup1, const vector<tuple<int, int>>& test_tup2) {\n    vector<tuple<int, int>> res;\n    for(size_t i = 0; i < test_tup1.size(); ++i) {\n        int first = max(get<0>(test_tup1[i]), get<0>(test_tup2[i]));\n        int second = max(get<1>(test_tup1[i]), get<1>(test_tup2[i]));\n        res.push_back(make_tuple(first, second));\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nint newman_prime(int n) {\n    if (0 == n || 1 == n) {\n        return 1;\n    } else {\n        int i = 2;\n        int p = 1;\n        while (p < n) {\n            if (newman_prime(i) == n) {\n                return i;\n            }\n            i++;\n            p++;\n        }\n        return -1;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, long, int> division_elements(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup1) / std::get<0>(test_tup2),\n        std::get<1>(test_tup1) / std::get<1>(test_tup2),\n        std::get<2>(test_tup1) / std::get<2>(test_tup2),\n        std::get<3>(test_tup1) / std::get<3>(test_tup2)\n    );\n}\n\n\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <cassert>\n#include <utility>\n\ntemplate<typename T>\nstd::pair<std::vector<T>, std::vector<T>> split_two_parts(const std::vector<T>& list1, long L) {\n    std::vector<T> first_part(list1.begin(), list1.begin() + L);\n    std::vector<T> second_part(list1.begin() + L, list1.end());\n    return std::make_pair(first_part, second_part);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <unordered_map>\n#include <cassert>\n\nstd::unordered_map<std::string, int> merge_dict(std::unordered_map<std::string, long> d1, std::unordered_map<std::string, int> d2) {\n    std::unordered_map<std::string, int> d;\n    for (const auto& pair : d1) {\n        d[pair.first] = pair.second;\n    }\n    for (const auto& pair : d2) {\n        d[pair.first] += pair.second;\n    }\n    return d;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\ntemplate <typename T>\nvector<vector<T>> list_split(vector<T> S, int step) {\n    vector<vector<T>> result(step);\n    for (int i = 0; i < step; ++i) {\n        for (int j = i; j < S.size(); j = j + (step)) {\n            result[i].push_back(S[j]);\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint lateralsurface_cube(int l) {\n    int LSA = (l * l) * 4;\n    return LSA;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nlong square_Sum(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    return n * n + square_Sum(n - 1);\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n// Function Definition\n\nlong find_star_num(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    return find_star_num(n - 1) + find_star_num(n - 2);\n}\n"], ["#include <iostream>\n    \n\n#include <cassert>\n\nlong ascii_value(char k) {\n    long ascii_value = k;\n    return ascii_value;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <vector>\n\nint sum_even_and_even_index(const std::vector<int>& arr, int n) {\n    int sum = 0;\n    for (int i = 0; i < n; i = i + (2)) {\n        if (arr[i] % 2 == 0) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint even_Power_Sum(int n) {\n    long sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += pow(i, 5);\n    }\n    return sum;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\nvector<int> rear_extract(vector<tuple<int, string, int>> test_list) {\n    vector<long> res;\n    for (auto& lis : test_list) {\n        res.push_back(get<0>(lis));\n    }\n    return res;\n}\n"], ["\n#include <iostream>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, int> substract_elements(const std::tuple<int, int, long>& test_tup1, const std::tuple<int, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n    std::get<1>(test_tup1) - std::get<1>(test_tup2),\n    std::get<2>(test_tup1) - std::get<2>(test_tup2));\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nint even_binomial_Coeff_Sum(long n) {\n    long sum = 0;\n    for (long i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            sum += binomial_coefficient(n, i);\n        }\n    }\n    return sum;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <cmath> // for ceil\nusing namespace std;\n\nint get_Position(vector<int>& a, int n, int m) {\n    for (int i = 0; i < n; i = i + 1) {\n        a[i] = (a[i] / m + (a[i] % m != 0));\n    }\n    int result = -1, maxx = -1;\n    for (int i = n - 1; i >= 0; --i) {\n        if (a[i] > maxx) {\n            result = i;\n            maxx = a[i];\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n#include <cmath>\n\ndouble volume_cylinder(double r, double h) {\n    double volume = h * r * 3.1415 * r;\n    return volume;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <map>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nmap<string, int> dict_filter(const map<string, int>& input_dict, long n) {\n    map<string, int> result;\n    for (auto const& pair : input_dict) {\n        if (pair.second >= n) {\n            result[pair.first] = pair.second;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <tuple>\n#include <vector>\n#include <cassert>\n#include <type_traits>\n\ntemplate <size_t Index, typename Tuple>\nint count_first_elements_helper(const Tuple& t, true_type) {\n    return 0;\n}\ntemplate <size_t Index, typename Tuple>\nlong count_first_elements_helper(const Tuple& t, false_type) {\n    return 0;\n}\n\ntemplate <size_t Index, typename Tuple>\nint count_first_elements(const Tuple& t) {\n    return count_first_elements_helper<Index>(t, std::is_same_v<std::tuple_element_t<Index, Tuple>, int>);\n}\n\n\n\n"], ["#include<iostream>\n#include <cassert>\nint is_num_decagonal(long n) {\n    if (n <= 0) {\n        return 0;\n    }\n    long num = (n * (2 * n - 1)) / 2;\n    return num;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool sequential_search(const std::vector<int>& dlist, int item, int& pos) {\n    pos = 0;\n    while (pos < dlist.size()) {\n        if (item == dlist[pos]) {\n            return true;\n        }\n        pos++;\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool all_unique(const std::vector<long>& test_list) {\n    std::set<int> unique_elements(test_list.begin(), test_list.end());\n    if (test_list.size() > unique_elements.size()) {\n        return false;\n    }\n    return true;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nstd::vector<int> sub_list(const std::vector<int>& nums1, const std::vector<int>& nums2) {\n    std::vector<long> result;\n    for (size_t i = 0; i < nums1.size(); ++i) {\n        result.push_back(nums1[i] - nums2[i]);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nbool validate(int n) {\n    for (int i = 0; i < 10; i++) {\n        int temp = n;\n        int count = 0;\n        while (temp) {\n            if (i == temp % 10) {\n                count++;\n            }\n            temp /= 10;\n        }\n        if (count > 1) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (element != item) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint max_sub_array_sum_repeated(vector<long> a, int n, int k) {\n    int max_so_far = -2147483648;\n    int max_ending_here = 0;\n    for (int i = 0; i < n * k; ++i) {\n        max_ending_here = max_ending_here + a[i % n];\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint square_Sum(long n) {\n    int sum = 0;\n    for (long i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            sum += i * i;\n        }\n    }\n    return sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nint modular_inverse(const std::vector<int>& arr, int N, long P) {\n    int current_element = 0;\n    for (int i = 0; i < N; ++i) {\n        if ((arr[i] * arr[i]) % P == 1) {\n            current_element = i;\n            break;\n        }\n    }\n    return current_element;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nusing namespace std;\n\nint odd_Days(int N) {\n    int hund1 = N / 100;\n    long hund4 = N / 400;\n    int leap = N >> 2;\n    int ordd = N - leap;\n    if (hund1) {\n        ordd += hund1;\n        leap -= hund1;\n    }\n    return ordd;\n}\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::pair<int, std::vector<long>> max_length(const std::vector<std::vector<int>>& list1) {\n    int max_length = 0;\n    std::vector<int> max_list;\n    for (const auto& x : list1) {\n        if (x.size() > max_length) {\n            max_length = x.size();\n            max_list = x;\n        }\n    }\n    return {max_length, max_list};\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\nusing namespace std;\nint count_no_of_ways(long n, int k) {\n    vector<int> dp(n + 1, 0);\n    const int mod = 1000000007;\n    dp[1] = k;\n    dp[2] = k * k;\n    for (int i = 3; i <= n; i++) {\n        dp[i] = (dp[i - 1] * (k - 1) + dp[i - 2] * k) % mod;\n    }\n    return dp[n];\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint find(int n, long m) {\n    int q = n / m;\n    return q;\n}\n\n\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <algorithm>\n#include <limits>\nusing namespace std;\n\nlong max_val(const vector<int>& listval) {\n    long max = numeric_limits<long>::min();\n    for (const auto& val : listval) {\n        max = max > val ? max : val;\n    }\n    return max;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <numeric>\nint sum_div(int number) {\n    std::vector<int> divisors = {1};\n    for (int i = 2; i < number; ++i) {\n        if (0 == number % i) {\n            divisors.push_back(i);\n        }\n    }\n    return std::accumulate(divisors.begin(), divisors.end(), 0);\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n\nint get_Inv_Count(vector<int> arr, int n) {\n    long inv_count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (arr[i] > arr[j]) {\n                inv_count++;\n            }\n        }\n    }\n    return inv_count;\n}\n\n\n\n"], ["\n\n#include <vector>\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nvoid flatten_list(const vector<Variant*>& list1, vector<int>& result_list) {\n    for (const auto& element : list1) {\n        if (element->is_int()) {\n            result_list.push_back(element->get_int());\n        } else if (element->is_vector()) {\n            flatten_list(element->get_vector(), result_list);\n        }\n    }\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\ntemplate<typename T>\nvector<vector<T>> intersection_nested_lists(const vector<T>& l1, const vector<vector<T>>& l2) {\n    vector<vector<T>> result;\n    for (const auto& lst : l2) {\n        vector<T> temp;\n        for (const auto& n : lst) {\n            if (l1.end() != find(l1.begin(), l1.end(), n)) {\n                temp.push_back(n);\n            }\n        }\n        result.push_back(temp);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <cassert>\nusing namespace std;\n\npair<string, int> max_aggregate(const vector<pair<string, int>>& stdata) {\n    map<string, int> temp;\n    for (const auto& item : stdata) {\n        temp[item.first] += item.second;\n    }\n    pair<string, long> max_item = *temp.begin();\n    for (const auto& item : temp) {\n        if (item.second > max_item.second) {\n            max_item = item;\n        }\n    }\n    return max_item;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\ndouble count_binary_seq(long n) {\n    double nCr = 1;\n    double res = 1;\n    for(int r = 1; r <= n; ++r) {\n        nCr *= r;\n        nCr /= (r - n);\n        res *= nCr;\n    }\n    return res;\n}\n\n\n\n"], ["\n\n#include <iostream>\n#include <unordered_map>\n#include <cassert>\n\nclass Variant {\npublic:\n    virtual ~Variant() = default;\n};\n\nclass IntVariant : public Variant {\npublic:\n    IntVariant(int value) : value(value) {}\n    long get_int() const {\n        return this->value;\n    }\nprivate:\n    int value;\n};\n\nclass MapVariant : public Variant {\npublic:\n    MapVariant(const std::unordered_map<char, Variant*>& map) : map(map) {}\n    const std::unordered_map<char, Variant*>& get_map() const {\n        return this->map;\n    }\nprivate:\n    std::unordered_map<char, Variant*> map;\n};\n\n"], ["#include<iostream>\n    \n\n#include <cassert>\n\n// 函数定义\nint set_Bit_Number(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    long msb = 0;\n    while (n > 0) {\n        msb++;\n        n >>= 1;\n    }\n    return msb;\n}\n\n\n\n"], ["#include<iostream>\n#include <limits>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nbool solve(int a[], int n) {\n    int mx = numeric_limits<int>::min();\n    for (long j = 1; j < n; j++) {\n        if (mx > a[j]) {\n            return false;\n        }\n        mx = max(mx, a[j]);\n    }\n    return true;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nlong find_Element(const std::vector<int>& arr, const std::vector<std::pair<int, int>>& ranges, int rotations, int index) {\n    for (int i = rotations - 1; i >= 0; --i) {\n        int left = ranges[i].first;\n        int right = ranges[i].second;\n        if (left <= index && right >= index) {\n            if (index == left) {\n                index = right;\n            }\n        }\n    }\n    return arr[index];\n}\n\n\n\n"], ["\n#include<iostream>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector>\n#include<vector"], ["#include <iostream>\n#include <tuple>\n#include <vector>\n#include <cassert>\n\nstd::tuple<std::string, int, std::vector<int>, bool> colon_tuplex(std::tuple<std::string, int, std::vector<int>, bool> tuplex, int m, int n) {\n    std::tuple<std::string, long, std::vector<int>, bool> tuplex_colon = tuplex;\n    std::string str = std::get<0>(tuplex_colon);\n    int num = std::get<1>(tuplex_colon);\n    std::vector<int> vec = std::get<2>(tuplex_colon);\n    bool bool_var = std::get<3>(tuplex_colon);\n    return std::make_tuple(str, num, vec, bool_var);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> large_product(const std::vector<int>& nums1, const std::vector<int>& nums2, long N) {\n    std::vector<int> products;\n    for (int x : nums1) {\n        for (int y : nums2) {\n            products.push_back(x * y);\n        }\n    }\n    std::sort(products.begin(), products.end(), std::greater<int>());\n    return products;\n}\n\n\n\n"], ["\n#include<iostream>\n    \n\n#include <cassert>\n\nint maximum(int a, long b) {\n    if (a >= b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n\n\n"], ["#include<cassert>\n#include<iostream>\nint set_left_most_unset_bit(int n) {\n    if (!((1 + n) & n)) {\n        return n;\n    }\n    int pos = 0, temp = n, count = 0;\n    while (temp) {\n        if (!(1 & temp)) {\n            pos = count;\n        }\n        count++;\n        temp >>= 1;\n    }\n    return pos;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble volume_cone(double r, double h) {\n    double volume = h * (1.0/3) * M_PI * r * r;\n    return volume;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> pos_nos(const std::vector<int>& list1) {\n    std::vector<long> result;\n    for (int num : list1) {\n        if (num >= 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nlong max_sum_rectangular_grid(vector<vector<int>>& grid, int n) {\n    long incl = max(grid[0][0], grid[1][0]);\n    int excl = 0;\n    for (int i = 1; i < n; ++i) {\n        int excl_new = max(excl, incl);\n        incl = max(incl + grid[i][i], grid[i][i - 1]);\n        excl = max(excl_new, excl);\n    }\n    return incl;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string find_Max_Len_Even(const std::string& str) {\n    long n = str.length();\n    int i = 0;\n    int currlen = 0;\n    int maxlen = 0;\n    int st = -1;\n    while (i < n) {\n        if (str[i] == ' ') {\n            if (currlen % 2 == 0) {\n                if (maxlen < currlen) {\n                    maxlen = currlen;\n                    st = i - currlen;\n                }\n            }\n            currlen = 0;\n            i++;\n        } else {\n            currlen++;\n            i++;\n        }\n    }\n    if (currlen % 2 == 0) {\n        if (maxlen < currlen) {\n            maxlen = currlen;\n            st = i - currlen;\n        }\n    }\n    return str.substr(st, maxlen);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_last_occurrence(const std::vector<int>& A, int x) {\n    int left = 0;\n    int right = A.size() - 1;\n    int result = -1;\n    while (left <= right) {\n        long mid = (left + right) / 2;\n        if (x == A[mid]) {\n            result = mid;\n            right = mid - 1;\n        } else if (x < A[mid]) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <string>\n#include <cassert>\n// 基类\nclass Element {\npublic:\n    virtual ~Element() = default;\n    virtual Element* clone() const = 0;\n    virtual void print() const = 0;\n    virtual bool isSameType(const Element& other) const = 0;\n    virtual bool isInt() const = 0;\n    virtual bool isChar() const = 0;\n    virtual long getIntValue() const = 0;\n    virtual char getCharValue() const = 0;\n};\n// 处理 char 类型的子类\nclass CharElement : public Element {\npublic:\n    CharElement(char value) : value_(value) {}\n    Element* clone() const override {\n        return new CharElement(*this);\n    }\n    void print() const override {\n        std::cout << \"Char: \" << value_ << std::endl;\n    }\n    bool isSameType(const Element& other) const override {\n        return other.isChar();\n    }\n    bool isInt() const override { return false; }\n    bool isChar() const override { return true; }\n    int getIntValue() const override {\n         return 0; \n    }\n    char getCharValue() const override { return value_; }\nprivate:\n    char value_;\n};\n// 处理 int 类型的子类\nclass IntElement : public Element {\npublic:\n    IntElement(int value) : value_(value) {}\n    Element* clone() const override {\n        return new IntElement(*this);\n    }\n    void print() const override {\n        std::cout << \"Int: \" << value_ << std::endl;\n    }\n    bool isSameType(const Element& other) const override {\n        return other.isInt();\n    }\n    bool isInt() const override { return true; }\n    bool isChar() const override { return false; }\n    int getIntValue() const override { return value_; }\n    char getCharValue() const override { \n//begin to write code\n"], ["#include<cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint max_volume(int s) {\n    int maxvalue = 0;\n    for(long i = 1; i < s; ++i) {\n        for(int j = 1; j < s; ++j) {\n            int k = s - i - j;\n            if(k > maxvalue) maxvalue = k;\n        }\n    }\n    return maxvalue;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\n// 函数定义\nint sum_difference(long n) {\n    int sumofsquares = 0;\n    int squareofsum = 0;\n    for (int num = 1; num <= n; num++) {\n        sumofsquares += num * num;\n        squareofsum += num;\n    }\n    return squareofsum * squareofsum - sumofsquares;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string find_demlo(const std::string& s) {\n    long l = s.size();\n    std::string res = \"\";\n    for (int i = 1; i <= l; ++i) {\n        res += std::to_string(i);\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nstd::vector<int> position_min(const std::vector<int>& list1) {\n    int min_val = *std::min_element(list1.begin(), list1.end());\n    std::vector<int> min_result;\n    for (long i = 0; i < list1.size(); i++) {\n        if (list1[i] == min_val) {\n            min_result.push_back(i);\n        }\n    }\n    return min_result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nvoid right_rotate(std::vector<int>& arr, int n, int out_of_place, int cur) {\n    int temp = arr[cur];\n    for (int i = cur; i > out_of_place; i = i - 1) {\n        arr[i] = arr[i - 1];\n    }\n    arr[out_of_place] = temp;\n}\n\nstd::vector<int> re_arrange(std::vector<int>& arr, int n) {\n    int out_of_place = -1;\n    for (int index = 0; index < n; ++index) {\n        if (out_of_place >= 0) {\n            if ((arr[index] >= 0 && arr[out_of_place] < 0) ||\n                (arr[index] < 0 && arr[out_of_place] >= 0)) {\n                right_rotate(arr, n, out_of_place, index);\n                if (index - out_of_place > 2) {\n                    out_of_place = index;\n                }\n            }\n        }\n    }\n    return arr;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::pair<int, int> sum_of_alternates(const std::vector<int>& test_vector) {\n    int sum1 = 0;\n    int sum2 = 0;\n    for (size_t idx = 0; idx < test_vector.size(); ++idx) {\n        if (idx % 2 == 1) {\n            sum1 = sum1 + (test_vector[idx]);\n        } else {\n            sum2 = sum2 + (test_vector[idx]);\n        }\n    }\n    return std::make_pair(sum1, sum2);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n\nint get_Min_Squares(int n) {\n    if (n <= 3) {\n        return n;\n    }\n    int res = n;\n    for (int x = 1; x <= n; ++x) {\n        long temp = x * x;\n        int temp2 = temp;\n        while (temp2 <= n) {\n            temp2 += temp;\n            res = std::min(res, temp2);\n        }\n    }\n    return res;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <sstream>\n#include <unordered_map>\n#include <cassert>\n#include <vector>\nusing namespace std;\n\nstring most_occurrences(vector<string> test_list) {\n    unordered_map<string, long> temp;\n    for (auto& sub : test_list) {\n        stringstream ss(sub);\n        string wrd;\n        while (ss >> wrd) {\n            temp[wrd]++;\n        }\n    }\n    long max = 0;\n    string max_wrd;\n    for (auto& [wrd, count] : temp) {\n        if (count > max) {\n            max = count;\n            max_wrd = wrd;\n        }\n    }\n    return max_wrd;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool check_isosceles(int x, int y, int z) {\n    if (x == y || y == z || z == x) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nvector<int> rotate_left(vector<int> list1, int m, long n) {\n    vector<int> result;\n    result.insert(result.end(), list1.begin() + m, list1.end());\n    return result;\n}\n\n\n\n"], ["#include<iostream>\n#include<vector>\n#include<cassert>\nint neg_count(const std::vector<int>& list) {\n    int neg_count = 0;\n    for (long num : list) {\n        if (num <= 0) {\n            neg_count++;\n        }\n    }\n    return neg_count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\nint count_unset_bits(int n) {\n    int count = 0;\n    int x = 1;\n    while(x < 1 + n) {\n        if (0 == (n & x)) {\n            count++;\n        }\n        x <<= 1;\n    }\n    return count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <map>\n#include <cassert>\n\nstd::map<char, int> char_frequency(std::string str1) {\n    std::map<char, int> dict;\n    for (char n : str1) {\n        if (dict.end() != dict.find(n)) {\n            dict[n] += 1;\n        } else {\n            dict[n] = 1;\n        }\n    }\n    return dict;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nvoid Sort(vector<pair<string, long>>& sub_li) {\n    sort(sub_li.begin(), sub_li.end(), [](const pair<string, int>& a, const pair<string, int>& b) {\n        return a.second < b.second;\n    });\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool check_Validity(int a, int b, long c) {\n    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {\n        return false;\n    }\n    return true;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nint ap_sum(int a, int n, int d) {\n    int total = ((a * 2 + (n - 1) * d) * n) / 2;\n    return total;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nbool check_monthnum(std::string monthname1) {\n    if (\"February\" == monthname1) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\nbool check_Equality(const std::string& s) {\n    return s.back() == s.front();\n}\n\nint count_Substring_With_Equal_Ends(const std::string& s) {\n    int result = 0;\n    int n = s.length();\n    for (int i = 0; i < n; ++i) {\n        if (check_Equality(s.substr(i, 1))) {\n            result++;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint find_Divisor(int x, int y) {\n    int count = 0;\n    for (int i = 1; i <= y; ++i) {\n        if (x % i == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nlong sum_three_smallest_nums(std::vector<int> lst) {\n    std::vector<int> positive_nums;\n    for (int x : lst) {\n        if (x > 0) {\n            positive_nums.push_back(x);\n        }\n    }\n    std::sort(positive_nums.begin(), positive_nums.end());\n    return std::accumulate(positive_nums.begin(), positive_nums.begin() + 3, 0);\n}\n"], ["#include<iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<long> set_to_tuple(const set<int>& s) {\n    vector<int> t(s.begin(), s.end());\n    vector<long> result;\n    for (int i = 0; i < t.size(); i++) {\n        result.push_back(t[i]);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <cassert>\nusing namespace std;\n\npair<int, int> find_minimum_range(vector<vector<long>>& lists) {\n    int high = numeric_limits<int>::min();\n    pair<int, int> p = make_pair(0, numeric_limits<int>::max());\n    priority_queue<Node> pq;\n    for (int i = 0; i < lists.size(); ++i) {\n        pq.push(Node(lists[i][0], i, 0));\n        high = max(high, lists[i][0]);\n    }\n    while (!pq.empty()) {\n        Node top = pq.top();\n        pq.pop();\n        if (top.index < p.second) {\n            p = make_pair(top.value, top.index);\n        }\n        if (top.index + 1 < lists[top.list_num].size()) {\n            pq.push(Node(lists[top.list_num][top.index + 1], top.list_num, top.index + 1));\n        }\n    }\n    return p;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cctype>\n#include <cassert>\n\nstd::pair<int, int> dig_let(const std::string& s) {\n    int d = 0, l = 0;\n    for (char c : s) {\n        if (isdigit(c)) {\n            d = d + 1;\n        } else {\n            l = l + 1;\n        }\n    }\n    return std::make_pair(d, l);\n}\n\n\n\n"], ["\n#include<iostream>\n#include <cmath>\n#include <cassert>\n\nint count_Odd_Squares(int n, long m) {\n    int count = 0;\n    for (int i = n; i <= m; ++i) {\n        if (i % 2 != 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\n\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nvector<int> diff_consecutivenums(const vector<long>& nums) {\n    vector<int> result;\n    for (int i = 1; i < nums.size(); i++) {\n        result.push_back(nums[i] - nums[i - 1]);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <vector>\n\nint zigzag(int n, int k) {\n    if (0 == n && 0 == k) {\n        return 1;\n    }\n    int res = 1;\n    int i = 0;\n    int j = 0;\n    while (i < n) {\n        if (0 == j % k) {\n            res *= i + 1;\n        }\n        i++;\n        j++;\n    }\n    return res;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <cassert>\n\n// 函数定义\nlong count_Squares(int m, int n) {\n    if (n < m) {\n        int temp = m;\n        m = n;\n    }\n    long result = 0;\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i * i + j * j == m * m) {\n                result++;\n            }\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint bin_coff(int n, int r) {\n  int val = 1;\n  if (r > (n - r)) {\n    r = n - r;\n  }\n  for (int i = 0; i < r; ++i) {\n    val = val * ((n - i));\n    val = val / ((i + 1));\n  }\n  return val;\n}\n\n\n\n"], ["\n#include <string>\n#include <set>\n#include <iostream>\n#include <cassert>\n\nstd::string check(const std::string& string) {\n    std::set<char> p(string.begin(), string.end());\n    std::set<char> s = {'0', '1'};\n    if (p == s || std::set<char>{'0'} == p || std::set<char>{'1'} == p) {\n        return \"Yes\";\n    }\n    return \"No\";\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint minimum_Length(std::string s) {\n    int maxOcc = 0;\n    int n = s.length();\n    std::vector<int> arr(26, 0);\n    for (int i = 0; i < n; i = i + 1) {\n        arr[s[i] - 'a']++;\n    }\n    for (int i = 0; i < 26; i = i + 1) {\n        if (arr[i] > maxOcc) {\n            maxOcc = arr[i];\n        }\n    }\n    int minLen = n;\n    for (int i = 0; i < 26; i = i + 1) {\n        if (arr[i] == maxOcc) {\n            minLen = min(minLen, n - i);\n        }\n    }\n    return minLen;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nint first_Element(const std::vector<int>& arr, int n, int k) {\n    std::map<int, int> count_map;\n    for (int i = 0; i < n; ++i) {\n        if (count_map.end() != count_map.find(arr[i])) {\n            count_map[arr[i]] += 1;\n        } else {\n            count_map[arr[i]] = 1;\n        }\n    }\n    for (const auto& pair : count_map) {\n        if (pair.second == k) {\n            return pair.first;\n        }\n    }\n    return -1; // Should never reach here for realistic input ranges\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nbool unique_Characters(std::string str) {\n    for (long i = 0; i < str.length(); i++) {\n        for (int j = i + 1; j < str.length(); j++) {\n            if (str[i] == str[j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nstd::vector<std::vector<long>> remove_column(std::vector<std::vector<int>>& list1, int n) {\n    for (auto& row : list1) {\n        row.erase(row.begin() + n);\n    }\n    return list1;\n}\n"], ["\n#include<iostream>\n#include<cassert>\n\nlong tn_ap(int a, int n, int d) {\n    if (n == 1) {\n        return a;\n    }\n    else {\n        return a + (n - 1) * d;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nusing namespace std;\n\nint count_Rectangles(int radius) {\n    int rectangles = 0;\n    int diameter = 2 * radius;\n    long diameterSquare = diameter * diameter;\n    for (int a = 1; a < 2 * radius; a++) {\n        for (int b = 1; b < 2 * radius; b++) {\n            int diagnalLengthSquare = (a * a + b * b);\n            if (diagnalLengthSquare == diameterSquare) {\n                rectangles++;\n            }\n        }\n    }\n    return rectangles;\n}\n\n\n\n"], ["\n#include<iostream>\n#include <cassert>\n//函数定义\nint find_angle(int a, long b) {\n    if (a + b > 180) {\n        throw std::invalid_argument(\"Angles must be less than 180 degrees!\");\n    }\n    if (a + b < 180) {\n        throw std::invalid_argument(\"Angles must be greater than 180 degrees!\");\n    }\n    if (a + b == 180) {\n        throw std::invalid_argument(\"Angles must be different!\");\n    }\n    return 180 - a - b;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nint find_max(const std::vector<std::vector<int>>& test_list) {\n    long res = 0;\n    for (const auto& sublist : test_list) {\n        for (int num : sublist) {\n            res = std::max(res, num);\n        }\n    }\n    return res;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <map>\n#include <algorithm>\n\nstd::vector<long> moddiv_list(const std::vector<int>& nums1, const std::vector<int>& nums2) {\n    std::vector<long> result;\n    for (size_t i = 0; i < nums1.size(); ++i) {\n        result.push_back(nums1[i] % nums2[i]);\n    }\n    return result;\n}\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nstd::string Check_Solution(int a, int b, long c) {\n    if (2 * b * b == 9 * a * c) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"], ["\n#include<iostream>\n#include<cmath>\n#include<cassert>\n\nlong long get_carol(long n) {\n    long long result = pow(2, n) - 1;\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint max_occurrences(vector<int> nums) {\n    int max_val = 0;\n    long result = nums[0];\n    for (int i : nums) {\n        int occu = count(nums.begin(), nums.end(), i);\n        if (occu > max_val) {\n            max_val = occu;\n            result = i;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nvector<tuple<int, int, int>> add_K_element(vector<tuple<int, int, int>> test_list, int K) {\n    vector<tuple<int, int, int>> res;\n    for (auto &sub : test_list) {\n        int a, b, c;\n        std::tie(a, b, c) = sub;\n        res.push_back(std::make_tuple(a + K, b + K, c + K));\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nchar make_flip(char ch) {\n    return ch == '0' ? '1' : '0';\n}\n\nint get_flip_with_starting_charcter(string str, char expected) {\n    int flip_count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        if (str[i] != expected) {\n            flip_count = flip_count + 1;\n        }\n    }\n    return flip_count;\n}\n\n\n\n"], ["#include<iostream>\n#include <cassert>\n\n//函数定义\nint count_Digit(int n) {\n    int count = 0;\n    while (0 != n) {\n        n /= 10;\n        ++count;\n    }\n    return count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <climits>\nusing namespace std;\n\nint adjacent_num_product(const vector<long>& list_nums) {\n    int max_product = INT_MIN;\n    for (size_t i = 0; i < list_nums.size() - 1; ++i) {\n        int product = list_nums[i] * list_nums[i + 1];\n        if (product > max_product) {\n            max_product = product;\n        }\n    }\n    return max_product;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int value) : data(value), left(nullptr), right(nullptr) {}\n};\n\nlong get_height(Node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return max(get_height(root->left), get_height(root->right)) + 1;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\nvector<tuple<int, int>> repeat_tuples(tuple<int, int> test_tup, long N) {\n    vector<tuple<int, int>> res(N, test_tup);\n    for (int i = 0; i < N; ++i) {\n        res[i] = test_tup;\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nint lateralsurface_cuboid(int l, int w, int h) {\n    int LSA = (l + w) * h * 2;\n    return LSA;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n    });\n    return items;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint smallest_missing(const std::vector<int>& A, int left_element, int right_element) {\n    if (left_element > right_element) {\n        return left_element;\n    }\n    long mid = left_element + (right_element - left_element) / 2;\n    if (A[mid] == mid) {\n        return smallest_missing(A, mid + 1, right_element);\n    } else {\n        return smallest_missing(A, left_element, mid - 1);\n    }\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nvector<long> heap_assending(vector<int> nums) {\n    make_heap(nums.begin(), nums.end());\n    return nums;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nint volume_cuboid(int l, int w, long h) {\n    return l * w * h;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nvector<string> permute_string(string str) {\n    if (str.length() == 0) {\n        return vector<string> {\"\"};\n    }\n    vector<string> prev_list = permute_string(str.substr(1));\n    vector<string> next_list;\n    for (long i = 0; i < prev_list.size(); i++) {\n        for (size_t j = 0; j <= str.length() - 1; j++) {\n            string temp = prev_list[i];\n            temp.insert(j, 1, str[i]);\n            next_list.push_back(temp);\n        }\n    }\n    return next_list;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint round_num(int n, int m) {\n    int a = m * (n / m);\n    return a;\n}\n\n\n\n"], ["\n\n#include <iostream>\n#include <vector>\n#include <set>\n#include <tuple>\n#include <cassert>\n#include <typeinfo>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\nclass Element {\npublic:\n    virtual ~Element() = default;\n    virtual bool is_int() const = 0;\n    virtual bool is_string() const = 0;\n    virtual int get_int() const = 0;\n    virtual string get_string() const = 0;\n};\n\n// 派生类 IntElement\nclass IntElement : public Element {\npublic:\n    IntElement(int value) : value_(value) {}\n    bool is_int() const override {\n        return true;\n    }\n    bool is_string() const override {\n        return false;\n    }\n    long get_int() const override {\n        return value_;\n    }\n    string get_string() const override {\n        throw runtime_error(\"Not a string\");\n    }\nprivate:\n    int value_;\n};\n\n// 派生类 StringElement\nclass StringElement : public Element {\npublic:\n    StringElement(const string& value) : value_(value) {}\n    bool is_int() const override {\n        return false;\n    }\n    bool is_string() const override {\n        return true;\n    }\n    int get_int() const override {\n        throw runtime_error(\"Not an integer\");\n    }\n    string get_string() const override {\n        return value_;\n    }\nprivate:\n    string value_;\n};\n\nstruct ElementComparator {\n    bool operator()(const Element* lhs, const Element* rhs) const {\n        if (lhs->is_int() && rhs->is_int()) {\n            return lhs->get_int() < rhs->get_int();\n        } else if (lhs->is_string() && rhs->is_string()) {\n            return lhs->get_string() < rhs->get_string();\n        } else {\n            return false;\n        }\n    }\n};\n\n"], ["\n#include <vector>\n#include <cassert>\n\nstd::vector<int> move_first(std::vector<long> test_list) {\n    if (!test_list.empty()) {\n        int last = test_list.back();\n        test_list.pop_back();\n        test_list.insert(test_list.begin(), last);\n    }\n    return test_list;\n}\n\n\n\n"], ["\n#include<cassert>\n#include<iostream>\n#include<assert.h>\nint surfacearea_cuboid(long l, int w, int h) {\n    int SA = 2 * (l * w + l * h + w * h);\n    assert(SA == 2 * (l * w + l * h + w * h));\n    return SA;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<vector<int>> multi_list(int rownum, int colnum) {\n    vector<vector<int>> multi_list(rownum, vector<int>(colnum, 0));\n    for (int row = 0; row < rownum; ++row) {\n        for (int col = 0; col < colnum; ++col) {\n            multi_list[row][col] = row * col;\n        }\n    }\n    return multi_list;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\ntypedef tuple<string, int, int> TupleType;\n\nvector<TupleType> index_on_inner_list(vector<TupleType> list_data, int index_no) {\n    sort(list_data.begin(), list_data.end(), [index_no](const TupleType &a, const TupleType &b) {\n        if (0 == index_no) return get<0>(a) < get<0>(b);\n        return get<1>(a) < get<1>(b);\n    });\n    return list_data;\n}\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint find_rotation_count(const vector<int>& A) {\n    int n = A.size();\n    if (n == 0) {\n        return 0;\n    }\n    if (A[0] < A[n - 1]) {\n        return 0;\n    }\n    int left = 0, right = n - 1;\n    while (left <= right) {\n        if (A[left] <= A[right]) {\n            return left;\n        }\n        int mid = (left + right) / 2;\n        int next = (mid + 1) % n;\n        int prev = (mid - 1 + n) % n;\n        if (A[mid] <= A[next] && A[mid] <= A[prev]) {\n            return mid;\n        }\n        if (A[mid] <= A[right]) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return -1;\n}\n"], ["\n#include <iostream>\n#include <cassert>\n\nint even_bit_toggle_number(long n) {\n    int res = 0, count = 0, temp = n;\n    while(temp > 0) {\n        if (count % 2 == 0) {\n            res = res | (1 << count);\n        }\n        count++;\n        temp = temp >> 1;\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint frequency_Of_Smallest(int n, std::vector<int> arr) {\n    int mn = arr[0];\n    int freq = 1;\n    for (long i = 1; i < n; i++) {\n        if (arr[i] < mn) {\n            mn = arr[i];\n            freq = 1;\n        } else if (arr[i] == mn) {\n            freq++;\n        }\n    }\n    return freq;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nint get_perrin(long n) {\n    if (n == 0) {\n        return 3;\n    }\n    if (n == 1) {\n        return 2;\n    }\n    return get_perrin(n - 1) + get_perrin(n - 2);\n}\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\n\nint swap_count(const std::string& s) {\n    const char* chars = s.c_str();\n    int count_left = 0;\n    int count_right = 0;\n    int swap = 0;\n    int imbalance = 0; \n    for (size_t i = 0; i < s.length(); i++) {\n        if ('[' == chars[i]) {\n            count_left += 1;\n            if (imbalance > 0) {\n                swap += 1;\n            }\n        } else if (']' == chars[i]) {\n            count_right += 1;\n            if (imbalance > 0) {\n                swap += 1;\n            }\n        } else if (count_left == count_right) {\n            imbalance += 1;\n        } else if (count_left > count_right) {\n            imbalance += 1;\n        }\n    }\n    return swap;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string even_or_odd(const std::string& N) {\n    int l = N.length();\n    char last_char = N[l - 1];\n    if ('0' == last_char || '2' == last_char ||\n        '4' == last_char || '6' == last_char ||\n        '8' == last_char || 'A' == last_char) {\n        return \"even\";\n    } else {\n        return \"odd\";\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint highest_Power_of_2(int n) {\n    int res = 0;\n    for (int i = n; i > 0; i--) {\n        if (0 == (i & (i - 1))) {\n            res = i;\n        }\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint find_lucas(int n) {\n    if (0 == n) {\n        return 2;\n    }\n    int a = 2;\n    int b = 1;\n    int c = 0;\n    for (int i = 2; i <= n; ++i) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <cassert>\n\nstd::vector<std::map<std::string, std::map<std::string, long>>> convert_list_dictionary(const std::vector<std::string> &l1, const std::vector<std::string> &l2, const std::vector<int> &l3) {\n    std::vector<std::map<std::string, std::map<std::string, long>>> result;\n    for (size_t i = 0; i < l1.size(); ++i) {\n        std::map<std::string, std::map<std::string, long>> temp;\n        for (size_t j = 0; j < l2.size(); ++j) {\n            temp[l1[i]][l2[j]] = l3[j];\n        }\n        result.push_back(temp);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint get_max_sum(int n) {\n    std::vector<long> res;\n    res.push_back(0);\n    res.push_back(1);\n    for (int i = 2; i <= n; ++i) {\n        res.push_back(std::max(res[i / 2] + res[i / 3] + res[i / 4] + res[i / 5], i));\n    }\n    return res[n];\n}\n\n\n\n"], ["#include <vector>\n#include <iostream>\n#include <cassert>\nstd::pair<int, std::vector<long>> max_length_list(const std::vector<std::vector<int>>& input_list) {\n    int max_length = 0;\n    std::vector<int> max_list;\n    for (const auto& vec : input_list) {\n        if (vec.size() > max_length) {\n            max_length = vec.size();\n            max_list = vec;\n        }\n    }\n    return std::make_pair(max_length, max_list);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\n\nbool check_distinct(std::vector<int> test_vec) {\n    std::set<int> temp;\n    for (int ele : test_vec) {\n        if (temp.find(ele) != temp.end()) {\n            return 0;\n        }\n        temp.insert(ele);\n    }\n    return 1;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <cassert>\n\nchar first_non_repeating_character(const std::string& str1) {\n    std::vector<char> char_order;\n    std::map<char, int> ctr;\n    for (char c : str1) {\n        if (ctr.find(c) != ctr.end()) {\n            ctr[c] = ctr[c] + (1);\n        } else {\n            ctr[c] = 1;\n            char_order.push_back(c);\n        }\n    }\n    for (char c : char_order) {\n        if (ctr[c] == 1) {\n            return c;\n        }\n    }\n    return '\\0';\n}\n\n\n\n"], ["#include <iostream>\n#include <regex>\n#include <cassert>\nusing namespace std;\n\nstring check_char(string str) {\n    long p1 = 0;\n    int p2 = str.size() -1 ;\n    if(str[p1] == str[p2])\n        return \"true\";\n    else\n        return \"false\";\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nint median_numbers(long a, int b, int c) {\n    int median;\n    if (a > b) {\n        if (a < c) {\n            median = a;\n        } else if (b > c) {\n            median = b;\n        } else {\n            median = c;\n        }\n    } else {\n        if (b > c) {\n            median = b;\n        } else if (a > c) {\n            median = a;\n        } else {\n            median = c;\n        }\n    }\n    return median;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <cctype>\n\nlong sum_of_digits(vector<int> nums) {\n    int result = 0;\n    for (int n : nums) {\n        string numStr = to_string(n);\n        for (char c : numStr) {\n            if (isdigit(c)) {\n                result += c - '0';\n            }\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\nstd::tuple<int, int, int, int> bitwise_xor(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) ^ std::get<0>(test_tup1),\n        std::get<1>(test_tup2) ^ std::get<1>(test_tup1),\n        std::get<2>(test_tup2) ^ std::get<2>(test_tup1),\n        std::get<3>(test_tup2) ^ std::get<3>(test_tup1)\n    );\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <cassert>\n\nint extract_freq(const std::vector<std::pair<int, int>>& test_list) {\n    std::set<std::pair<int, long>> unique_tuples;\n    for (const auto& sub : test_list) {\n        if (sub.first <= sub.second) {\n            unique_tuples.insert(sub);\n        }\n    }\n    return unique_tuples.size();\n}\n\n\n\n"], ["#include <iostream>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\ntuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> add_nested_tuples(\n    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> test_tup1,\n    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> test_tup2) \n{\n    tuple<int, long> res1 = make_tuple(get<0>(get<0>(test_tup1)) + get<0>(get<0>(test_tup2)), get<1>(get<0>(test_tup1)) + get<1>(get<0>(test_tup2)));\n    tuple<int, long> res2 = make_tuple(get<0>(get<0>(test_tup1)) + get<0>(get<0>(test_tup2)), get<1>(get<0>(test_tup1)) + get<1>(get<0>(test_tup2)));\n    tuple<int, long> res3 = make_tuple(get<0>(get<0>(test_tup1)) + get<0>(get<0>(test_tup2)), get<1>(get<0>(test_tup1)) + get<1>(get<0>(test_tup2)));\n    tuple<int, long> res4 = make_tuple(get<0>(get<0>(test_tup1)) + get<0>(get<0>(test_tup2)), get<1>(get<0>(test_tup1)) + get<1>(get<0>(test_tup2)));\n    return make_tuple(res1, res2, res3, res4);\n}\n\n\n\n"], ["#include<iostream>\n#include<vector>\n#include<assert.h>\n#include<string>\nusing namespace std;\n\nint ncr_modp(int n, int r, int p) {\n    std::vector<int> C(1 + r, 0);\n    C[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = std::min(i, r); j > 0; --j) {\n            C[j] = (C[j] + C[j - 1]) % p;\n        }\n    }\n    return C[r];\n}\n\n\n\n"], ["#include<iostream>\n#include<cassert>\n#include <assert.h>\n//函数定义\nint minimum(int a, long b) {\n    if (a <= b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n"], ["\n#include <iostream>\n#include <tuple>\n#include <type_traits>\n#include <cstddef>\n#include <cassert>\nusing namespace std;\nusing MyTuple = tuple<char, long, char, char, char, char, char, char, char, char>;\n\ntemplate<typename T, size_t I = 0>\nbool check_tuplex(const MyTuple& t, const T& value) {\n    if constexpr (I == tuple_size<MyTuple>::value) {\n        return false;\n    } else {\n        return t[I] == value;\n    }\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string find_Parity(unsigned long x) {\n    unsigned int y = x ^ (x >> 1);\n    y = y ^ (y >> 2);\n    y = y ^ (y >> 4);\n    y = y ^ (y >> 8);\n    return std::to_string(y);\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <string>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nlong rearrange_bigger(int n) {\n    string nums = to_string(n);\n    for (int i = nums.size() - 2; i >= 0; --i) {\n        if (nums[i] < nums[i+1]) {\n            string z = nums.substr(i);\n            char y = *min_element(z.begin() + 1, z.end(), [first = z[0]](char a, char b) { return a > first && (b > first ? a < b : true); });\n            z.erase(remove(z.begin(), z.end(), y), z.end());\n            return stoi(z);\n        }\n    }\n    return n;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <algorithm>\n\nvector<vector<int>> k_smallest_pairs(vector<int>& nums1, vector<int>& nums2, int k) {\n    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> pq(comp);\n    vector<vector<int>> result;\n    for (int i = 0; i < nums1.size(); ++i) {\n        pq.push({i, 0});\n    }\n    while (k-- && !pq.empty()) {\n        auto [index, index2] = pq.top();\n        pq.pop();\n        result.push_back({nums1[index], nums2[index2]});\n        if (index2 + 1 < nums2.size()) {\n            pq.push({index, index2 + 1});\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <limits>\n#include <cstdlib> // for abs()\nint min_product_tuple(const std::vector<std::pair<int, int>>& list1) {\n    int result_min = std::numeric_limits<int>::max();\n    for (const auto& p : list1) {\n        long product = std::abs(p.first * p.second);\n        if (product < result_min) {\n            result_min = product;\n        }\n    }\n    return result_min;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <limits>\n#include <typeinfo>\n#include <cassert>\nusing namespace std;\n\nint min_val(const vector<int>& listval) {\n    int min_val = numeric_limits<int>::max();\n    for (long value : listval) {\n        if (value < min_val) {\n            min_val = value;\n        }\n    }\n    return min_val;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nstd::vector<int> remove_odd(std::vector<int> l) {\n    auto it = l.begin();\n    while (l.end() != it) {\n        if (0 != *it % 2) {\n            it = l.erase(it);\n        } else {\n            ++it;\n        }\n    }\n    return l;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n#include <string>\nusing namespace std;\ntemplate<typename T, size_t N>\nstruct TupleElement {\n    using type = typename tuple_element<N, tuple<T, long, int>>::type;\n};\ntemplate<typename T, size_t N>\nvector<typename TupleElement<T, N>::type> extract_nth_element(const vector<tuple<T, long, int>>& list1) {\n    vector<typename TupleElement<T, N>::type> result;\n    for (const auto& tuple : list1) {\n        result.push_back(get<N>(tuple));\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool overlapping(const std::vector<int>& list1, const std::vector<int>& list2) {\n    int c = list1.size();\n    int d = list2.size();\n    for (int i = 0; i < c; i++) {\n        for (long j = 0; j < d; j++) {\n            if (list1[i] == list2[j]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\npair<int, int> max_Product(const vector<long>& arr) {\n    int arr_len = arr.size();\n    if (arr_len < 2) {\n        throw \"No pairs exists\";\n    }\n    int x = arr[0];\n    int y = arr[1];\n    for (int i = 0; i < arr_len; i++) {\n        for (int j = i + 1; j < arr_len; j++) {\n            if (arr[i] * arr[j] > x * y) {\n                x = arr[i];\n                y = arr[j];\n            }\n        }\n    }\n    return {x, y};\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nint breakSum(long n) {\n    vector<int> dp(n + 1, 0);\n    dp[0] = 0;\n    dp[1] = 1;\n    for (long i = 2; i <= n; ++i) {\n        for (long j = 1; j <= i / 2; ++j) {\n            dp[i] = max(dp[i], dp[j] + dp[i - j]);\n        }\n    }\n    return dp[n];\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cmath>\n#include <numeric>\n#include <cassert>\n\nint round_and_sum(const std::vector<double>& list1) {\n    int length = list1.size();\n    int rounded_sum = std::accumulate(list1.begin(), list1.end(), 0, [](int acc, double val) {\n        return acc + std::round(val);\n    });\n    return rounded_sum * length;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n#include <vector>\n\nint cube_Sum(int n) {\n    long sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i * i * i;\n    }\n    return sum;\n}\n\n\n\n"], ["\n\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <sstream>\n#include <tuple>\nusing namespace std;\n\n// Helper function to concatenate elements of the tuple\ntemplate<size_t Index, typename... Args>\nvoid concatenate_tuple_helper(ostringstream& oss, const string& delim, const tuple<Args...>& test_tup) {\n\n    /*\n    progame language:cpp\n    description:Write a function to concatenate each element of tuple by the delimiter.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    if (0 != Index) {\n        oss << delim;\n    }\n    oss << get<Index>(test_tup);\n}\n// Recursive function to iterate over the tuple\ntemplate<size_t Index, typename... Args>\nvoid iterate_tuple(ostringstream& oss, const string& delim, const tuple<Args...>& test_tup) {\n    if constexpr (sizeof...(Args) == Index) {\n        return;\n    }\n    iterate_tuple<Index + 1>(oss, delim, test_tup);\n    concatenate_tuple_helper<Index>(oss, delim, test_tup);\n}\n\n// Helper function to concatenate elements of the tuple\ntemplate<size_t Index, typename... Args>\nvoid concatenate_tuple_helper(ostringstream& oss, const string& delim, const tuple<Args...>& test_tup) {\n\n    /*\n    progame language:cpp\n    description:Write a function to concatenate each element of tuple by the delimiter.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    if (0 != Index"], ["#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble find_Average_Of_Cube(int n) {\n    double sum = 0;\n    for (long i = 1; i <= n; ++i) {\n        sum += std::pow(i, 3);\n    }\n    return sum / n;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nint get_maxgold(vector<vector<int>> gold, int m, int n) {\n    vector<vector<int>> goldTable(m, vector<int>(n, 0));\n    for (int col = n-1; col >= 0; col--) {\n        for (int row = 0; row < m; row++) {\n            int right = (n-1 == col) ? 0 : goldTable[row][1 + col];\n            int right_up = (0 == row || n-1 == col) ? 0 : goldTable[row-1][1 + col];\n            int right_down = (m-1 == row || n-1 == col) ? 0 : goldTable[1 + row][1 + col];\n            goldTable[row][col] = gold[row][col] + max({right, right_up, right_down});\n        }\n    }\n    return goldTable[0][0];\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\n\ntemplate<typename T>\nlong count_element_in_list(const std::vector<std::vector<T>>& list1, T x) {\n    int ctr = 0;\n    for (const auto& sublist : list1) {\n        for (const auto& element : sublist) {\n            if (element == x) {\n                ctr++;\n            }\n        }\n    }\n    return ctr;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> filter_oddnumbers(const std::vector<int>& nums) {\n    std::vector<long> odd_nums;\n    std::copy_if(nums.begin(), nums.end(), std::back_inserter(odd_nums), [](int x){ \n        return x % 2 != 0;\n    });\n    return odd_nums;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nvoid shell_sort(std::vector<int>& my_list) {\n    int gap = my_list.size() / 2;\n    while (gap > 0) {\n        for (int i = gap; i < my_list.size(); i++) {\n            long current_item = my_list[i];\n            int j = i;\n            while (j >= gap && my_list[j - gap] > current_item) {\n                my_list[j] = my_list[j - gap];\n                j -= gap;\n            }\n            my_list[j] = current_item;\n        }\n        gap /= 2;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, int, int> and_tuples(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) & std::get<0>(test_tup1),\n        std::get<1>(test_tup2) & std::get<1>(test_tup1),\n        std::get<2>(test_tup2) & std::get<2>(test_tup1),\n        std::get<3>(test_tup2) & std::get<3>(test_tup1)\n    );\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nlong parabola_directrix(int a, int b, int c) {\n    long directrix = c - ((b * b) + 1) * 4 * a;\n    return directrix;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\ndouble median_trapezium(double base1, double base2, double height) {\n    double median = (base1 + base2) * 0.5;\n    return median;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::string check_greater(std::vector<int> arr, long number) {\n    std::sort(arr.begin(), arr.end());\n    if (number > arr.back()) {\n        return \"Yes, the entered number is greater than those in the array\";\n    } else {\n        return \"No, the entered number is not greater than those in the array\";\n    }\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <cassert>\nusing namespace std;\n\nlong last_Digit(int n) {\n    if (n == 0) {\n        return 0;\n    } else {\n        return n % 10;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> neg_nos(const std::vector<int>& list1) {\n    std::vector<long> negatives;\n    for (int num : list1) {\n        if (num < 0) {\n            negatives.push_back(num);\n        }\n    }\n    return negatives;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string remove_odd(const std::string& str1) {\n    std::string str2;\n    for (long i = 1; i <= str1.length(); ++i) {\n        if (i % 2 == 0) {\n            str2 += str1[i];\n        }\n    }\n    return str2;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_bidirectional(vector<pair<int, long>> test_list) {\n    int res = 0;\n    for (size_t idx = 0; idx < test_list.size(); ++idx) {\n        for (size_t iidx = idx + 1; iidx < test_list.size(); ++iidx) {\n            if (test_list[iidx].first == test_list[idx].second && test_list[idx].second == test_list[iidx].first) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nlong multiple_to_single(const std::vector<int>& L) {\n    std::stringstream ss;\n    for (int num : L) {\n        ss << num;\n    }\n    return std::stol(ss.str());\n}\n"], ["#include <iostream>\n#include <regex>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\ntuple<int, long, string> find_adverb_position(const string& text) {\n    regex pattern(\"\\\\w+ly\");\n    smatch match;\n    if (regex_search(text, match, pattern)) {\n        return make_tuple(match.position(), match.position() + match.length(), match.str());\n    } else {\n        return make_tuple(-1, -1, \"\");\n    }\n}\n\n\n\n"], ["\n#include<iostream>\n    \n\n#include <cassert>\n\nlong surfacearea_cube(int l) {\n    return 6 * l * l;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\ndouble positive_count(vector<long> nums) {\n    int n = nums.size();\n    int n1 = 0;\n    for (int x : nums) {\n        if (x > 0) {\n            n1++;\n        }\n    }\n    return (double)n1 / n;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint largest_neg(std::vector<long> list1) {\n    int max = list1[0];\n    for (int x : list1) {\n        if (x < max) {\n            max = x;\n        }\n    }\n    return max;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<vector<int>> trim_tuple(const vector<vector<int>>& test_list, int K) {\n    vector<vector<int>> res;\n    for (const auto& ele : test_list) {\n        vector<int> tmp;\n        for (long i = K; i <= ele.size() - K - 1; i++) {\n            tmp.push_back(ele[i]);\n        }\n        res.push_back(tmp);\n    }\n    return res;\n}\n\n\n\n"], ["#include<iostream>\n#include <cassert>\n#include <tuple>\n#include <vector>\nusing namespace std;\n// Helper function to perform index-wise multiplication\ntemplate<size_t I>\ntuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> index_multiplication_helper(\n\n    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup1,\n    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup2,\n    tuple<tuple<int, int>, tuple<int, long>, tuple<int, int>, tuple<int, int>> res)\n{\n    auto tup1 = get<I - 1>(test_tup1);\n    auto tup2 = get<I - 1>(test_tup2);\n    get<I - 1>(res) = make_tuple(get<0>(tup1) * get<0>(tup2), get<1>(tup1) * get<1>(tup2));\n    return index_multiplication_helper<I - 1>(test_tup1, test_tup2, res);\n}\n// Base case for the recursion\ntemplate<>\n//begin to write code\n\nAnswer:\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_Occurrence(const std::vector<char>& tup, const std::vector<char>& lst) {\n    int count = 0;\n    for (char item : tup) {\n        for (char elem : lst) {\n            if (elem == item) {\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nvector<int> cube_nums(const vector<int>& nums) {\n    vector<long> cube_nums;\n    for (int num : nums) {\n        long cube = num * num * num;\n        cube_nums.push_back(cube);\n    }\n    return cube_nums;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint cal_sum(int n) {\n    int a = 3;\n    int b = 0;\n    int c = 2;\n    if (0 == n) {\n        return 3;\n    }\n    if (1 == n) {\n        return 3;\n    }\n    if (2 == n) {\n        return 5;\n    }\n    for (int i = 3; i <= n; ++i) {\n        a = b + c;\n        b = c;\n        c = a;\n    }\n    return a;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\nusing namespace std;\n\nstring check_Triangle(int x1, int y1, int x2, int y2, int x3, int y3) {\n    int a = ((y2-y3) * x1+(y3-y1) * x2+(y1-y2) * x3);\n    if (0 == a) {\n        return \"No\";\n    } else {\n        return \"Yes\";\n    }\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nstd::vector<std::string> extract_string(std::vector<std::string> vec, long l) {\n    std::vector<std::string> result;\n    for (auto& str : vec) {\n        if (str.length() == l) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint loss_amount(long actual_cost, int sale_amount) {\n    if(sale_amount > actual_cost) {\n        return sale_amount - actual_cost;\n    } else {\n        return 0;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint sumofFactors(int n) {\n    if (n % 2 != 0) {\n        return 0;\n    }\n    long res = 1;\n    for (int i = 2; i <= static_cast<int>(std::sqrt(n)) + 1; ++i) {\n        int count = 0;\n        int curr_sum = 1;\n        int curr_term = 1;\n        while (n % i == 0) {\n            count++;\n            n = n / i;\n            curr_sum *= i;\n            curr_term *= i;\n        }\n        res += curr_sum / curr_term;\n    }\n    if (n > 1) {\n        res += n;\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool check_monthnumb_number(int monthnum2) {\n    if (1 == monthnum2 || 3 == monthnum2 || 5 == monthnum2 || 7 == monthnum2 || 8 == monthnum2 || 10 == monthnum2 || 12 == monthnum2) {\n        return true;\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n//函数定义\nint rectangle_area(int l, long b) {\n    return l * b;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nstd::vector<int> Extract(const std::vector<std::vector<int>>& lst) {\n    std::vector<int> result;\n    for (const auto& sublist : lst) {\n        result.push_back(sublist[0]);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nint upper_ctr(string str) {\n    int upper_ctr = 0;\n    for (long i = 0; i < str.length(); i++) {\n        if (isupper(str[i])) {\n            upper_ctr++;\n        }\n    }\n    return upper_ctr;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nvector<vector<string>> combinations_list(vector<string> list1) {\n    if (list1.empty()) {\n        return {{}};\n    }\n    vector<vector<string>> result;\n    vector<string> rest(1 + list1.begin(), list1.end());\n    for (int i = 0; i < rest.size(); i++) {\n        vector<string> temp;\n        temp.push_back(rest[i]);\n        result.push_back(temp);\n        for (int j = 0; j < rest.size(); j++) {\n            if (rest[j] != rest[i]) {\n                temp.push_back(rest[j]);\n                result.push_back(temp);\n            }\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint max_subarray_product(vector<int> arr) {\n    int n = arr.size();\n    int max_ending_here = 1;\n    int min_ending_here = 1;\n    int max_so_far = 0;\n    bool flag = false;\n    for (long i = 0; i < n; i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = min(min_ending_here * arr[i], 1);\n            flag = true;\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n            flag = false;\n        } else if (arr[i] < 0) {\n            int temp = max_ending_here;\n            max_ending_here = max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n            flag = true;\n        }\n        if (flag) {\n            max_so_far = max(max_so_far, max_ending_here);\n        }\n    }\n    return max_so_far;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <map>\n#include <string>\nbool check_value(std::map<std::string, int> dict, int n) {\n    for (const auto& kv : dict) {\n        if (kv.second != n) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <map>\n#include <cassert>\n\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(\"\" != element.second) {\n            filtered[element.first] = element.second;\n        }\n    }\n    return filtered;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_peak_util(const std::vector<int>& arr, int low, int high, long n) {\n    int mid = low + (high - low) / 2;\n    if ((mid == 0 || arr[mid - 1] <= arr[mid]) &&\n        (mid == n - 1 || arr[mid + 1] <= arr[mid])) {\n        return mid;\n    } else if (mid > 0 && arr[mid - 1] > arr[mid]) {\n        return find_peak_util(arr, low, mid - 1, n);\n    } else {\n        return find_peak_util(arr, mid + 1, high, n);\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint decimal_to_Octal(int deciNum) {\n    long octalNum = 0;\n    int countval = 1;\n    int remainder;\n    while (deciNum != 0) {\n        remainder = deciNum % 8;\n        octalNum += remainder * countval;\n        countval *= 10;\n        deciNum /= 8;\n    }\n    return octalNum;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nlong max_product(vector<int> arr, int n) {\n    vector<int> mpis(n, 0);\n    for (int i = 0; i < n; ++i) {\n        mpis[i] = arr[i];\n    }\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            mpis[i] = max(mpis[i], mpis[j] * arr[i]);\n        }\n    }\n    return *max_element(mpis.begin(), mpis.end());\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint max_profit(vector<int> price, long k) {\n    int n = price.size();\n    vector<vector<int>> final_profit(k + 1, vector<int>(n, 0));\n    for (int i = 0; i <= k; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == 0 || j == 0) {\n                final_profit[i][j] = 0;\n            } else {\n                int max_so_far = 0;\n                for (int x = 0; x < j; x++) {\n                    max_so_far = max(max_so_far, final_profit[i - 1][x] + price[j] - price[x]);\n                }\n                final_profit[i][j] = max_so_far;\n            }\n        }\n    }\n    return final_profit[k][n - 1];\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> add_pairwise(const std::vector<int>& test_vec) {\n    std::vector<long> res;\n    for (size_t i = 0; i < test_vec.size() - 1; ++i) {\n        res.push_back(test_vec[i] + test_vec[i + 1]);\n    }\n    return res;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\n\nint find_remainder(std::vector<int> arr, int lens, int n) {\n    long mul = 1;\n    for (int i = 0; i < lens; i++) {\n        mul *= arr[i];\n    }\n    return mul % n;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\nbool check_Consecutive(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 1; i < l.size(); ++i) {\n        if (l[i - 1] + 1 != l[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::set<std::pair<int, int>> tuple_intersection(const std::vector<std::pair<int, int>>& test_list1, const std::vector<std::pair<int, long>>& test_list2) {\n    std::set<std::pair<int, int>> set1, set2;\n    for (auto& ele : test_list1) {\n        set1.insert({std::min(ele.first, ele.second), std::max(ele.first, ele.second)});\n    }\n    for (auto& ele : test_list2) {\n        set2.insert({std::min(ele.first, ele.second), std::max(ele.first, ele.second)});\n    }\n    std::set<std::pair<int, int>> intersection;\n    for (auto& ele : set1) {\n        if (set2.find(ele) != set2.end()) {\n            intersection.insert(ele);\n        }\n    }\n    return intersection;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string replace_char(std::string str1, char ch, char newch) {\n    for (size_t i = 0; i < str1.length(); ++i) {\n        if (ch == str1[i]) {\n            str1[i] = newch;\n        }\n    }\n    return str1;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cassert>\nbool compare(const std::pair<std::string, int> &a, const std::pair<std::string, int> &b) {\n    return a.second > b.second;\n}\nstd::vector<std::pair<std::string, int>> sort_counter(std::map<std::string, long> dict1) {\n    std::vector<std::pair<std::string, int>> sorted_dict(dict1.begin(), dict1.end());\n    std::sort(sorted_dict.begin(), sorted_dict.end(), compare);\n    return sorted_dict;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint big_sum(const std::vector<int>& nums) {\n    long sum = *max_element(nums.begin(), nums.end()) + *min_element(nums.begin(), nums.end());\n    return sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nlong first_Digit(int n) {\n    while (n >= 10) {\n        n = n / 10;\n    }\n    return n;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <string>\n\nchar get_max_occuring_char(const std::string &str1) {\n    const int ASCII_SIZE = 256;\n    long ctr[ASCII_SIZE] = {0};\n    int max = -1;\n    char ch = '\\0';\n    for (char c : str1) {\n        ctr[c]++;\n        if (ctr[c] > max) {\n            max = ctr[c];\n            ch = c;\n        }\n    }\n    return ch;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nbool is_subset_sum(const std::vector<int>& set, int n, long sum) {\n    if (sum == 0) return true;\n    if (n == 0) return false;\n    if (set[n - 1] > sum) return is_subset_sum(set, n - 1, sum);\n    return is_subset_sum(set, n - 1, sum) || is_subset_sum(set, n - 1, sum - set[n - 1]);\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nint first_Factorial_Divisible_Number(int x) {\n    int i = 1;\n    int fact = 1;\n    for (i = 1; i <= x; ++i) {\n        fact = fact * (i);\n        if (fact % x == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n"], ["#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_map>\n#include <cassert>\n#include <utility> // for std::pair\n#include <iostream>\nusing namespace std;\n\nstruct PairHash {\n    template <class T1, class T2>\n    std::size_t operator() (const std::pair<T1, T2>& pair) const {\n        auto hash1 = std::hash<T1>{}(pair.first);\n        auto hash2 = std::hash<T2>{}(pair.second);\n        return (hash2 << 1) ^ hash1; \n    }\n};\n\nstruct PairEqual {\n    template <class T1, class T2>\n    bool operator() (const std::pair<T1, T2>& lhs, const std::pair<T1, T2>& rhs) const {\n        return rhs.first == lhs.first && rhs.second == lhs.second;\n    }\n};\n\nvector<string> findWords(vector<string>& words) {\n    unordered_map<string, int, PairHash> word_count;\n    vector<string> result;\n    for (const string& word : words) {\n        if (word_count.find(word) == word_count.end()) {\n            word_count[word] = 1;\n        } else {\n            word_count[word]++;\n        }\n    }\n    for (const string& word : words) {\n        if (word_count[word] == 1) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nbool is_palindrome(int n) {\n    int divisor = 1;\n    while (n / divisor >= 10) {\n        divisor = divisor * (10);\n    }\n    while (n != 0) {\n        int leading = n / divisor;\n        int trailing = n % 10;\n        if (leading != trailing) {\n            return false;\n        }\n        n = (n % divisor) / 10;\n    }\n    return true;\n}\n\n\n\n"], ["#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble nCr(long n, int r) {\n    if (r > n / 2) {\n        r = n - r;\n    }\n    double answer = 1;\n    for (int i = 1; i <= r; i++) {\n        answer *= (n - r + i);\n    }\n    return answer;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <cassert>\n\nstd::vector<std::pair<int, long>> sort_tuple(std::vector<std::pair<int, int>>& tup) {\n    int lst = tup.size();\n    for (int i = 0; i < lst; ++i) {\n        for (int j = 0; j < lst - i - 1; ++j) {\n            if (tup[j].second > tup[j + 1].second) {\n                std::pair<int, int> temp = tup[j];\n                tup[j] = tup[j + 1];\n                tup[j + 1] = temp;\n            }\n        }\n    }\n    return tup;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble area_pentagon(double a) {\n    double area = (pow(a, 2) * sqrt(5 * (5 + 2 * sqrt(5)))) / 4.0;\n    return area;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint frequency_Of_Largest(int n, std::vector<int> arr) {\n    int mn = arr[0];\n    long freq = 1;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > mn) {\n            mn = arr[i];\n            freq++;\n        }\n    }\n    return freq;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nset<pair<int, int>> extract_symmetric(vector<pair<int, int>> test_list) {\n    set<pair<int, int>> temp;\n    for (auto& p : test_list) {\n        temp.insert(p);\n    }\n    set<pair<long, int>> res;\n    for (auto& p : temp) {\n        long x = p.first, y = p.second;\n        if (x < y) {\n            res.insert({x, y});\n        }\n    }\n    return res;\n}\n\n\n\n"], ["#include<iostream>\n#include <cmath>\n#include <cassert>\n\ndouble sum_gp(double a, long n, double r) {\n    double total = (a * (1 - pow(r, n))) / (1 - r);\n    return total;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nbool binary_search(const std::vector<int>& item_list, int item) {\n    int first = 0;\n    int last = item_list.size() - 1;\n    bool found = false;\n    while (first <= last && !found) {\n        int mid = (first + last) / 2;\n        if (item == item_list[mid]) {\n            found = true;\n        } else if (item < item_list[mid]) {\n            last = mid - 1;\n        } else {\n            first = mid + 1;\n        }\n    }\n    return found;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\ntypedef std::vector<std::pair<double, double>> Polygon;\nstd::vector<Polygon> calculate_polygons(double startx, double starty, double endx, double endy, double radius)\n\n    /*\n    progame language:cpp\n    description:Write a function to calculate a grid of hexagon coordinates where function returns a list of lists containing 6 tuples of x, y point coordinates.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n{\n    double sl = std::tan(M_PI / 6) * (radius * 2);\n    double p = 0.5 * sl;\n    double b = std::cos(M_PI * 30 / 180.0) * sl;\n    double w = 2 * b;\n    double h = sl * 2;\n    startx = startx - w;\n    starty = starty - h;\n    endx = endx + w;\n    endy = endy + h;\n    double origx = startx;\n    double origy = starty;\n    double xoffset = b;\n    double yoffset = p * 3;\n    std::vector<Polygon> polygons;\n    int row = 1;\n    int counter = 0;\n    while (starty < endy)\n    {\n        if (0 == row % 2)\n        {\n            startx = origx + xoffset;\n        }\n        else\n        {\n            startx = origx;\n        }\n        while (startx < endx)\n//begin to write code\n\nAnswer:\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\nstd::string binary_to_integer(const std::vector<int>& test_vec) {\n    std::string bin_str = \"\";\n    for (int num : test_vec) {\n        bin_str = bin_str + (std::to_string(num));\n    }\n    return std::bitset<32>(bin_str).to_string();\n}\n\n\n\n"], ["\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n\nstd::vector<long> heap_queue_smallest(std::vector<int> nums, int n) {\n    std::vector<int> smallest_nums(n);\n    std::make_heap(smallest_nums.begin(), smallest_nums.end());\n    for (int i = 0; i < n; i++) {\n        smallest_nums.push_back(nums[i]);\n        std::pop_heap(smallest_nums.begin(), smallest_nums.end());\n        smallest_nums.pop_back();\n    }\n    return smallest_nums;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint gcd(int x, int y) {\n    int gcd = 1;\n    if (0 == x % y) {\n        return y;\n    }\n    for (int k = y / 2; k > 0; k--) {\n        if (0 == x % k && 0 == y % k) {\n            gcd = k;\n            break;\n        }\n    }\n    return gcd;\n}\n\n\n\n"], ["\n#include<iostream>\n#include<cassert>\n\nlong diameter_circle(int r) {\n    if (r <= 0) {\n        return 0;\n    }\n    return 2 * r + diameter_circle(r - 1);\n}\n\n\n\n"], ["#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint ngcd(int x, int y) {\n    int i = 1;\n    int gcd = 1;\n    while(i <= x && i <= y) {\n        if(x % i == 0 && y % i == 0) {\n            gcd = i;\n        }\n        i = i + (1);\n    }\n    return gcd;\n}\n\nint num_comm_div(int x, int y) {\n    int n = ngcd(x, y);\n    return x / n * y / n;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nlong find(int n, int m) {\n    int r = n % m;\n    return r;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> add_consecutive_nums(const std::vector<long>& nums) {\n    std::vector<int> result;\n    for (size_t i = 0; i < nums.size() - 1; ++i) {\n        result.push_back(nums[i] + nums[i + 1]);\n    }\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n\nint sum_Of_Series(long n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i * i * i;\n    }\n    return sum;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> re_order(std::vector<int>& A) {\n    int k = 0;\n    for (int i : A) {\n        if (0 != i) {\n            A[k] = i;\n            k++;\n        }\n    }\n    return A;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nint permutation_coefficient(int n, int k) {\n    vector<vector<int>> P(n + 1, vector<int>(k + 1, 0));\n    for (long i = 0; i <= n; i++) {\n        for (int j = 0; j <= min(i, k); j++) {\n            if (j == 0)\n                P[i][j] = 1;\n            else\n                P[i][j] = P[i - 1][j - 1] + P[i - 1][j];\n        }\n    }\n    return P[n][k];\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nbool same_order(const std::vector<std::string>& l1, const std::vector<std::string>& l2) {\n    std::set<std::string> s1(l1.begin(), l1.end());\n    std::set<std::string> s2(l2.begin(), l2.end());\n    std::vector<std::string> common_elements;\n    std::set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), std::back_inserter(common_elements));\n    std::vector<std::string> filtered_l1;\n    for (auto &item : l1) {\n        if (common_elements.end() != std::find(common_elements.begin(), common_elements.end(), item)) {\n            filtered_l1.push_back(item);\n        }\n    }\n    return filtered_l1.size() == l1.size();\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint average_Odd(int n) {\n    if (0 == n % 2) {\n        std::cerr << \"Invalid Input\" << std::endl;\n        return -1;\n    }\n    int sm = 0;\n    int count = 0;\n    for (int i = 1; i <= n; i += 2) {\n        sm += i;\n        count++;\n    }\n    return sm / count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nint no_of_subsequences(vector<int> arr, int k) {\n    int n = arr.size();\n    vector<vector<int>> dp(1 + k, vector<int>(1 + n, 0));\n    for (int i = 1; i <= k; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = dp[i][j - 1];\n            if (arr[j - 1] <= i) {\n                dp[i][j] = max(dp[i][j], dp[i - arr[j - 1]][j - 1] + 1);\n            }\n        }\n    }\n    return dp[k][n];\n}\n\n\n\n"]]