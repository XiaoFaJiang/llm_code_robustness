[["\n#include <iostream>\n#include <cassert>\n\nstd::string remove_Occ(std::string s, char ch) {\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == ch) {\n            s = s.substr(0, i) + s.substr(i + 1);\n            break;\n        }\n    }\n    return s;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\nvector<vector<int>> sort_matrix(vector<vector<int>> M) {\n    sort(M.begin(), M.end(), [](const vector<int>& a, const vector<int>& b) {\n        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);\n    });\n    return M;\n}\n"], ["#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cassert>\n#include <iostream>\nusing namespace std;\n\nvector<pair<string, int>> count_common(const vector<string>& words) {\n    map<string, int> word_counts;\n    for (const auto& word : words) {\n        word_counts[word]++;\n    }\n    vector<pair<string, int>> sorted_counts(word_counts.begin(), word_counts.end());\n    sort(sorted_counts.begin(), sorted_counts.end(), [](const pair<string, int>& a, const pair<string, int>& b) {\n        return a.second < b.second;\n    });\n    return sorted_counts;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint find_Volume(int l, int b, int h) {\n    return l * b * h;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\nvector<string> split_lowerstring(const string& text) {\n    vector<string> result;\n    size_t len = text.length();\n    size_t i = var_0 ;\n    while (i < len) {\n        if (text[i] >= var_1  && text[i] <= var_2 ) {\n            size_t start = i;\n            i++;\n            while (i < len && (text[i] < var_3  || text[i] > var_4 )) {\n                result.push_back(text.substr(start, i - start));\n                start = i;\n            }\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\nusing namespace std;\n\nstring text_lowercase_underscore(string text) {\n    if (text.empty()) {\n        return \"Not matched!\";\n    }\n    size_t underscore_pos = text.find('_');\n    if (underscore_pos == std::string::npos) {\n        return \"Not matched!\";\n    }\n    if (underscore_pos == 0 || underscore_pos == text.length() - 1) {\n        return \"Not matched!\";\n    }\n    return text.substr(0, underscore_pos) + \"_\" + text.substr(underscore_pos + 1);\n}\n"], ["\n#include <iostream>\n#include <cassert>\n\nint square_perimeter(int a) {\n    int perimeter = 4 * a;\n    return perimeter;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <cctype> // For std::isupper, std::islower, std::isdigit\n\nusing namespace std;\n\nconst int NO_OF_CHARS = 256;\nvector<char> str_to_list(const string& str) {\n    vector<char> temp;\n    for (char x : str) {\n        temp.push_back(x);\n    }\n    return temp;\n}\nstring lst_to_string(const vector<char>& List) {\n    return string(List.begin(), List.end());\n}\n//This is a comment line.\nvector<int> get_char_count_array(const string& str) {\n    vector<int> count(NO_OF_CHARS, 0);\n    for (char c : str) {\n        count[c]++;\n    }\n    return count;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool test_duplicate(std::vector<int> arraynums) {\n    std::set<int> nums_set(arraynums.begin(), arraynums.end());    \n    for (int num : arraynums) {\n        if (nums_set.find(num) != nums_set.end()) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool is_woodall(long long x) {\n    if (x % 2 == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n    x = x + 1;\n    long long p = 0;\n    while (x > 0) {\n        p = p * 10 + x % 10;\n        x /= 10;\n    }\n    return p == x;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> multiples_of_num(int m, int n) {\n    std::vector<int> multiples;\n    for (int i = var_0 ; i <= m; ++i) {\n        multiples.push_back(i * n);\n    }\n    return multiples;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nint find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    int no_duplicate = -1;\n    for (int num : nums) {\n        if (num_set.find(num) != num_set.end()) {\n            return num;\n        }\n        num_set.insert(num);\n    }\n    return no_duplicate;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint maximum_Sum(const vector<vector<int>>& list1) {\n    int maxi = -100000;\n    for (const auto& x : list1) {\n        int sum = 0;\n        for (auto y : x) {\n            sum += y;\n        }\n        maxi = max(maxi, sum);\n    }\n    return maxi;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint binary_to_decimal(int binary) {\n    int decimal = 0, i = 0;\n    while (binary != 0) {\n        int dec = binary % 10;\n        decimal += dec * std::pow(2, i);\n        binary /= 10;\n        i++;\n    }\n    return decimal;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint find_Product(std::vector<int> arr, int n) {\n    std::sort(arr.begin(), arr.end());\n    int prod = 1;\n    for (int i = 0; i < n; i++) {\n        if (i == 0 || arr[i - 1] != arr[i]) {\n            prod *= arr[i];\n        }\n    }\n    return prod;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool check_k_elements(const std::vector<std::vector<int>>& test_list, int K) {\n    bool res = true;\n    for (const auto& tup : test_list) {\n        for (int ele : tup) {\n            if (ele != K) {\n                res = false;\n            }\n        }\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for(char onechar:item)\n        {\n            if(!(onechar<='9' && onechar >='0'))\n            {\n                res += onechar;\n            }\n        }\n        result.push_back(res);\n    }\n    return result;\n}\n"], ["#include<iostream>\n    \n\n#include <cassert>\n\n// 函数定义\nint binomial_Coeff(int n, int k) {\n    if (k > n) {\n        return 0;\n    }\n    if (k == 0 || k == n) {\n        return 1;\n    }\n    return binomial_Coeff(n - 1, k - 1) + binomial_Coeff(n - 1, k);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint get_Odd_Occurrence(std::vector<int> arr, int arr_size) {\n    for (int i = 0; i < arr_size; i++) {\n        int count = 0;\n        for (int j = 0; j < arr_size; j++) {\n            if (arr[i] == arr[j]) {\n                count++;\n            }\n        }\n        if (count % 2 != 0) {\n            return arr[i];\n        }\n    }\n    return -1;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nbool check_Equality(const std::string &s) {\n    return (s.front() == s.back());\n}\n\nint count_Substring_With_Equal_Ends(const std::string &s) {\n    int result = var_0 ;\n    int n = s.length();\n    for (int i = var_1 ; i < n; ++i) {\n        for (int j = 1; j <= n - i; ++j) {\n            if (check_Equality(s.substr(i, j))) {\n                result++;\n            }\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <cassert>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> func(vector<vector<int>>& nums, int k) {\n    unordered_map<int, int> d;\n    for (auto& row : nums) {\n        for (int i : row) {\n            d[i]++;\n        }\n    }\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    for (auto& item : d) {\n        int key = item.first;\n        int v = item.second;\n        if (pq.size() < k) {\n            pq.emplace(v, key);\n        } else {\n            if (pq.top().first < v) {\n                pq.pop();\n                pq.emplace(v, key);\n            }\n        }\n    }\n    vector<int> res;\n    while (!pq.empty()) {\n        res.push_back(pq.top().second);\n        pq.pop();\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint max_Prime_Factors(int n) {\n    int maxPrime = -1;\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n >>= 1;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n /= i;\n        }\n    }\n    if (n > 2) {\n        maxPrime = n;\n    }\n    return maxPrime;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n#include <map>\n\nint decimal_To_Binary(int N) {\n    int B_Number = 0;\n    int cnt = 0;\n    while (N != 0) {\n        int rem = N % 2;\n        int c = pow(10, cnt);\n        B_Number += rem * c;\n        N /= 2;\n        cnt += 1;\n    }\n    return B_Number;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_missing(std::vector<int>& ar, int N) {\n    int l = var_0 ;\n    int r = N - var_1 ;\n    while (l <= r) {\n        int mid = (l + r) / var_2 ;\n        if (ar[mid] != mid + var_3  && ar[mid - var_4 ] == mid) {\n            return mid + var_5 ;\n        } else if (ar[mid] == mid + var_3) {\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return -1;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint find_rect_num(int n) {\n    return n * (n + 1) / 2;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint find_Nth_Digit(int p, int q, int N) {\n    int res;\n    while (N > var_0 ) {\n        N -= var_1 ;\n        p *= var_2 ;\n        res = p / q ;\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<std::string> sort_mixed_list(std::vector<std::string> mixed_list) {\n    std::vector<int> int_part;\n    std::vector<std::string> str_part;\n    for (const auto& item : mixed_list) {\n        if (isdigit(item[0]) || (item[0] == '-' && item.size() > 1 && isdigit(item[1]))) {\n            int_part.push_back(std::stoi(item));\n        } else {\n            str_part.push_back(item);\n        }\n    }\n    std::sort(int_part.begin(), int_part.end());\n    std::sort(str_part.begin(), str_part.end());\n    std::vector<std::string> result;\n    result.reserve(int_part.size() + str_part.size());\n    for (const auto& part : int_part) {\n        result.push_back(std::to_string(part));\n    }\n    for (const auto& part : str_part) {\n        result.push_back(part);\n    }\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\ndouble div_even_odd(const vector<int>& list1) {\n    int first_even = var_0 ;\n    int first_odd = var_1 ;\n    for (int el : list1) {\n        if (el % var_2  == var_3  && first_even == var_4 ) {\n            first_even = el;\n        }\n    }\n    return (double)first_even / (double)first_odd;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <queue>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nusing namespace std;\n\nstring rearrange_string(string S) {\n    unordered_map<char, int> ctr;\n    for (char c : S) {\n        ctr[c]++;\n    }\n    auto comp = [](pair<int, char> left, pair<int, char> right) {\n        if (left.first == right.first) return left.second > right.second;\n        return left.first < right.first;\n    };\n    priority_queue<pair<int, char>, vector<pair<int, char>>, decltype(comp)> heap(comp);\n    for (auto& kv : ctr) {\n        heap.push(make_pair(kv.second, kv.first));\n    }\n    if (heap.top().first > (S.length() + 1) / 2) {\n        return \"\";\n    }\n    string ans = \"\";\n    while (!heap.empty()) {\n        char c = heap.top().second;\n        int cnt = heap.top().first;\n        heap.pop();\n        if (cnt > 1) {\n            for (int i = 0; i < cnt - 1; i++) {\n                ans += c;\n            }\n        } else {\n            ans += c;\n        }\n        if (heap.empty()) {\n            break;\n        }\n        char next = heap.top().second;\n        int nextCnt = heap.top().first;\n        heap.pop();\n        if (nextCnt > 1) {\n            for (int i = 0; i < nextCnt - 1; i++) {\n                ans += next;\n            }\n        } else {\n            ans += next;\n        }\n        heap.push(make_pair(nextCnt, next));\n    }\n    return ans;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nusing namespace std;\n\nmap<int, int> freq_element(vector<vector<int>>& nums) {\n    map<int, int> result;\n    for (auto& row : nums) {\n        for (int num : row) {\n            result[num]++;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> filter_evennumbers(const std::vector<int>& nums) {\n    std::vector<int> even_nums;\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            even_nums.push_back(num);\n        }\n    }\n    return even_nums;\n}\n\n\n\n"], ["\n#include <fstream>\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <cassert>\nusing namespace std;\n\nint find_Sum(const vector<int>& arr) {\n    unordered_map<int, int> count;\n    for (int num : arr) {\n        count[num]++;\n    }\n    int sum = 0;\n    for (auto it = count.begin(); it != count.end(); ++it) {\n        sum += it->second;\n    }\n    return sum;\n}\n\n\n\n"], ["#include <cmath>\n#include <iostream>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nstring text_match(const string& text) {\n    regex pattern(\"^[a-z]+_[a-z]+$\");\n    if (regex_search(text, pattern)) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}\n"], ["\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nstring text_match_string(string text) {\n    if (text.empty()) {\n        return \"Not matched!\";\n    }\n    if (isalnum(text[0]) || text[0] == '_') {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_gcd(int x, int y) {\n    while (y != 0) {\n        int temp = x % y;\n        x = y;\n        y = temp;\n    }\n    return x;\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool test_distinct(const std::vector<int>& data) {\n    std::set<int> distinctSet(data.begin(), data.end());\n    if (data.size() != distinctSet.size()) {\n        return false;\n    }\n    return true;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint compute_Last_Digit(int A, int B) {\n    int variable = 1;\n    if (A == B) {\n        return 1;\n    } else if ((B - A) >= 5) {\n        return 0;\n    } else {\n        while (B > 0) {\n            variable = variable * A;\n            B = B - 1;\n        }\n        return variable;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint odd_bit_set_number(int n) {\n    int count = var_0 ;\n    int res = var_1 ;\n    int temp = n;\n    while (temp > var_2 ) {\n        if (count % var_3  == var_4 ) {\n            res |= (1 << count);\n        }\n        count++;\n        temp >>= 1;\n    }\n    return (n | res);\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\n\nstd::vector<int> specified_element(const std::vector<std::vector<int>>& nums, int N) {\n    std::vector<int> result;\n    for (const auto& i : nums) {\n        result.push_back(i[N]);\n    }\n    return result;\n}\n\n\n\n"], ["#include <cstdlib>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::pair<int, std::vector<int>> min_length_list(const std::vector<std::vector<int>>& input_list) {\n    auto min_it = std::min_element(input_list.begin(), input_list.end(),\n                                   [](const std::vector<int>& a, const std::vector<int>& b) {\n                                       return a.size() < b.size();\n                                   });\n    return {min_it->size(), *min_it};\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool check_equilateral(int x, int y, int z) {\n    return (x == y && y == z);\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <cassert>\n\n//函数定义\nint parallelogram_area(int b, int h) {\n    int area = b * h;\n    return area;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string check_Equality(const std::string& str) {\n    if (str[0] == str[str.length() - 1]) {\n        return \"Equal\";\n    } else {\n        return \"Not Equal\";\n    }\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nstd::vector<int> counting_sort(std::vector<int> my_list) {\n    int max_value = 0;\n    for (int i = 0; i < my_list.size(); ++i) {\n        if (my_list[i] > max_value) {\n            max_value = my_list[i];\n        }\n    }\n    std::vector<int> buckets(max_value + 1, 0);\n    for (int num : my_list) {\n        buckets[num]++;\n    }\n    std::vector<int> sorted_list;\n    for (int i = 0; i <= max_value; ++i) {\n        while (buckets[i] > 0) {\n            sorted_list.push_back(i);\n            buckets[i]--;\n        }\n    }\n    return sorted_list;\n}\n\n\n\n"], ["#include <fstream>\n#include <cassert>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\ndouble tn_gp(double a, int n, double r) {\n    double tn = a * pow(r, n - 1);\n    return tn;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\n// 函数定义\nint rev(int num) {\n    int rev_num = 0;\n    while (num > 0) {\n        rev_num = rev_num * 10 + num % 10;\n        num = num / 10;\n    }\n    return rev_num;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint find_Max_Num(std::vector<int> arr, int n) {\n    std::sort(arr.rbegin(), arr.rend());\n    int num = arr[0];\n    return num;\n}\n\n\n\n"], ["\n#include <cstdlib>\n#include <iostream>\n#include <cassert>\n\nbool opposite_Signs(int x, int y) {\n    return (x > 0 && y < 0) || (x < 0 && y > 0);\n}\n\n\n\n"], ["\n#include <queue>\n#include <iostream>\n#include <cassert>\n\nint is_octagonal(int n) {\n    return n * (3 * n - 1) / 2;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nint max_len_sub(vector<int> arr, int n) {\n    vector<int> mls(n, 1);\n    int max = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (abs(arr[i] - arr[j]) <= 1 && mls[i] < mls[j] + 1) {\n                mls[i] = mls[j] + 1;\n            }\n        }\n        max = max(mls[i], max);\n    }\n    return max;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <unordered_map>\n#include <cassert>\n\nint count_Substrings(const std::string& s, int n) {\n    int count = 0, sum = 0;\n    std::unordered_map<int, int> mp;\n    mp[0] = 1;\n    for (int i = 0; i < n; ++i) {\n        sum += s[i] - '0';\n        if (mp.find(sum) != mp.end()) {\n            count += mp[sum];\n        }\n        mp[sum]++;\n    }\n    return count;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <algorithm>\n#include <vector>\n#include <cassert>\n\nint smallest_num(std::vector<int> xs) {\n    return *std::min_element(xs.begin(), xs.end());\n}\n\n\n\n"], ["#include <condition_variable>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nint max_difference(vector<pair<int, int>> test_list) {\n    vector<int> temp;\n    for (auto p : test_list) {\n        temp.push_back(abs(p.second - p.first));\n    }\n    int max_diff = 0;\n    int max_diff_index = 0;\n    for (int i = 0; i < temp.size(); i++) {\n        for (int j = i + 1; j < temp.size(); j++) {\n            if (temp[i] > temp[j]) {\n                if (temp[i] > max_diff) {\n                    max_diff = temp[i];\n                    max_diff_index = i;\n                }\n            }\n        }\n    }\n    return max_diff;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<pair<string, int>> subject_marks(vector<pair<string, int>> subjectmarks) {\n    sort(subjectmarks.begin(), subjectmarks.end(), [](const pair<string, int>& a, const pair<string, int>& b) {\n        return a.second < b.second;\n    });\n    return subjectmarks;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n#include <typeinfo>\n#include <type_traits>\n#include <memory>\n\nclass Any {\npublic:\n    Any() : content(nullptr) {}\n    template<typename T>\n    Any(const T& value) : content(new Holder<T>(value)) {}\n    Any(const Any& other) : content(other.content ? other.content->clone() : nullptr) {}\n    ~Any() { delete content; }\n    Any& operator=(const Any& other) {\n        if (this != &other) {\n            delete content;\n            content = other.content ? other.content->clone() : nullptr;\n        }\n        return *this;\n    }\n    template<typename T>\n    T& cast() {\n        return static_cast<Holder<T>*>(content)->held;\n    }\n    template<typename T>\n    const T& cast() const {\n        return static_cast<const Holder<T>*>(content)->held;\n    }\n    const type_info& type() const {\n        return content ? content->type() : typeid(void);\n    }\nprivate:\n    struct Holder {\n        T held;\n        std::unique_ptr<Holder> next;\n    };\n    std::unique_ptr<Holder> content;\n};\n\n"], ["\n#include<iostream>\n#include<vector>\n#include<cassert>\n\nint pos_count(const std::vector<int>& list) {\n    int pos_count = var_0 ;\n    for (int num : list) {\n        if (num >= var_1 ) {\n            pos_count += 1;\n        }\n    }\n    return pos_count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nunsigned long long bell_number(int n) {\n    vector<vector<unsigned long long>> bell(n+1, vector<unsigned long long>(n+1, 0));\n    bell[0][0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        bell[i][0] = bell[i-1][i-1];\n        for (int j = 1; j <= i; ++j) {\n            bell[i][j] = bell[i-1][j-1] + bell[i-1][j];\n        }\n    }\n    return bell[n][n];\n}\n\n\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <cassert>\n\nbool is_Monotonic(std::vector<int> A) {\n    bool increasing = true;\n    bool decreasing = true;\n    for (int i = 0; i < A.size() - 1; ++i) {\n        if (A[i] > A[i + 1]) {\n            increasing = false;\n        }\n        if (A[i] < A[i + 1]) {\n            decreasing = false;\n        }\n    }\n    return increasing || decreasing;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool is_sublist(const std::vector<int>& l, const std::vector<int>& s) {\n    bool sub_set = false;\n    if (s.empty()) {\n        sub_set = true;\n    } else if (s == l) {\n        sub_set = true;\n    } else if (s.size() > l.size()) {\n        sub_set = false;\n    } else {\n//This is a comment line.\n        for (size_t i = 0; i <= l.size() - s.size(); i++) {\n            if (l[i] == s[0]) {\n                for (size_t j = 1; j < s.size(); j++) {\n                    if (l[i + j] != s[j]) {\n                        sub_set = false;\n                        break;\n                    }\n                }\n                if (sub_set) {\n                    break;\n                }\n            }\n        }\n    }\n    return sub_set;\n}\n\n\n\n"], ["#include <atomic>\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nbool find_equal_tuple(const vector<vector<int>>& input, int k) {\n    for (const auto& tuple : input) {\n        if (tuple.size() != k) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n"], ["#include <vector>\n#include <iostream>\n#include <cassert>\n#include <algorithm>\n\nstd::vector<int> comb_sort(std::vector<int>& nums) {\n    float shrink_fact = 1.3;\n    int gaps = nums.size(), i;\n    bool swapped = true;\n    while (gaps > 1 || swapped) {\n        gaps = int(float(gaps) / shrink_fact);\n        swapped = false;\n        i = 0;\n        while (gaps + i < nums.size()) {\n            if (nums[i] > nums[i + gaps]) {\n                std::swap(nums[i], nums[i + gaps]);\n                swapped = true;\n            }\n            i += 1;\n        }\n        gaps = i;\n    }\n    return nums;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool dif_Square(int n) {\n    if (n % var_0  != var_1 ) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <vector>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nvector<string> multiple_split(const string& text) {\n    regex delimiter(R\"(;\\s|,\\s|\\*|\\\\n)\");\n    vector<string> result;\n    sregex_token_iterator iter(text.begin(), text.end(), delimiter, -1);\n    sregex_token_iterator end;\n    for (sregex_token_iterator i = iter; i != end; ++i) {\n        result.push_back((*i).str());\n    }\n    return result;\n}\n"], ["#include <cassert>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\nbool is_samepatterns(std::vector<std::string> colors, std::vector<std::string> patterns) {\n    if (colors.size() != patterns.size()) {\n        return false;\n    }\n    std::map<std::string, std::vector<std::string>> sdict;\n    std::set<std::string> pset;\n    std::set<std::string> sset;\n    for (size_t i = 0; i < patterns.size(); ++i) {\n        pset.insert(patterns[i]);\n        sset.insert(colors[i]);\n        sdict[patterns[i]].push_back(colors[i]);\n    }\n    return sdict == pset;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <sstream>\n#include <cassert>\n\nstd::string find_tuples(const std::vector<std::vector<int>>& test_list, int K) {\n    std::vector<std::vector<int>> res;\n    for (const auto& sub : test_list) {\n        bool all_divisible = true;\n        for (int ele : sub) {\n            const auto var_0 = 0;\n            if (ele % K != var_0 ) {\n                all_divisible = false;\n                break;\n            }\n        }\n        if (all_divisible) {\n            res.push_back(sub);\n        }\n    }\n    std::stringstream ss;\n    for (const auto& sub : res) {\n        ss << sub[0] << \" \";\n    }\n    return ss.str();\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\ndouble count_Squares(int m, int n) {\n    if (n < m) {\n        int temp = m;\n        m = n;\n        n = temp;\n    }\n    return n * (n + 1) * (3 * m - n + 1) / 6;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool is_Diff(int n) {\n    return n % 2 == 0;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <bitset>\n#include <cassert>\n\nint countWithOddSetBits(int n) {\n    if (n % 2 != 0) {\n        return (n + 1) / 2;\n    } else {\n        return std::bitset<32>(n).count();\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cassert>\n\nbool word_len(std::string s) {\n    std::istringstream iss(s);\n    std::vector<std::string> words;\n    std::string word;\n    while (iss >> word) {\n        words.push_back(word);\n    }\n    for (std::string w : words) {\n        if (w.length() % 2 != 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\ndouble tetrahedral_number(int n) {\n    return n * (n + 1) * (n + 2) / 6;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nusing namespace std;\n\nvector<pair<int, int>> zip_tuples(const vector<int>& test_tup1, const vector<int>& test_tup2) {\n    vector<pair<int, int>> res;\n    int n2 = test_tup2.size();\n    for (size_t i = var_0 ; i < test_tup1.size(); ++i) {\n        res.push_back(make_pair(test_tup1[i], test_tup2[i]));\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble volume_sphere(double r) {\n    double volume = (4.0 / 3.0) * M_PI * r * r * r;\n    return volume;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\nchar get_Char(std::string strr) {\n    int summ = 0;\n    for (int i = 0; i < strr.length(); ++i) {\n        summ += (strr[i] - 'a' + 1);\n    }\n    if (summ % 26 == 0) {\n        return 'A';\n    } else {\n        return 'a' + (summ % 26);\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint sequence(int n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    return sequence(n - 1) + sequence(n - 2);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble surfacearea_sphere(double r) {\n    double surfacearea = 4 * M_PI * r * r;\n    return surfacearea;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint centered_hexagonal_number(int n) {\n    return n * (2 * n - 1) / 2;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <iostream>\n#include <map>\n#include <cassert>\n\nusing namespace std;\n\nmap<string, string> merge_dictionaries_three(map<string, string> dict1, map<string, string> dict2, map<string, string> dict3) {\n    map<string, string> merged_dict;\n    for (const auto &pair : dict3) {\n        merged_dict[pair.first] = pair.second;\n    }\n    for (const auto &pair : dict2) {\n        merged_dict[pair.first] = pair.second;\n    }\n    return merged_dict;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n\nstd::map<int, int> freq_count(std::vector<int> list1) {\n    std::map<int, int> freq_count;\n    for (int num : list1) {\n        freq_count[num]++;\n    }\n    return freq_count;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <cassert>\n\nint closest_num(int N) {\n    int num = N;\n    int diff = 0;\n    while (num > 0) {\n        num = num / 10;\n        diff = diff + 1;\n    }\n    return N - diff;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nint len_log(const std::vector<std::string>& list1) {\n    int max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n            max = i.length();\n        }\n    }\n    return max;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str) != std::string::npos) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nbool is_undulating(const std::string& n) {\n    if (n.length() <= 2) {\n        return false;\n    }\n    for (size_t i = 2; i < n.length(); ++i) {\n        if (n[i] != n[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n"], ["\n#include <mutex>\n#include <iostream>\n#include <cassert>\n\nint power(int a, int b) {\n    std::mutex m;\n    if (b == 0) {\n        return 1;\n    } else if (a == 0) {\n        return 0;\n    } else {\n        std::lock_guard<std::mutex> lock(m);\n        return a * power(a, b - 1);\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::string index_minimum(const std::vector<std::pair<std::string, int>>& test_list) {\n    auto min_elem = std::min_element(test_list.begin(), test_list.end(),\n                                     [](const std::pair<std::string, int>& a, const std::pair<std::string, int>& b) {\n//begin to write code\nAnswer:\n"], ["#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cassert>\nusing namespace std;\n\nint Find_Min_Length(vector<vector<int>>& lst) {\n    int minLength = INT_MAX;\n    for (auto& v : lst) {\n        if (v.size() < minLength) {\n            minLength = v.size();\n        }\n    }\n    return minLength;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint divisor(int n) {\n    int x = var_0 ;\n    for (int i = var_1 ; i <= n; ++i) {\n        if (n % i == var_2 ) {\n            x++;\n        }\n    }\n    return x;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <unordered_map>\n#include <cassert>\n\nusing namespace std;\n\nunordered_map<int, int> frequency_lists(vector<vector<int>>& list1) {\n    vector<int> flat_list;\n    for (auto& sublist : list1) {\n        for (auto& item : sublist) {\n            flat_list.push_back(item);\n        }\n    }\n    unordered_map<int, int> dic_data;\n    for (auto& item : flat_list) {\n        dic_data[item]++;\n    }\n    return dic_data;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\ndouble multiply_num(const std::vector<int>& numbers) {\n    double total = 1;\n    for (int x : numbers) {\n        total *= x;\n    }\n    return total;\n}\n\n\n\n"], ["\n#include <cmath>\n#include <iostream>\n#include <bitset>\n#include <cassert>\n\nstd::string decimal_to_binary(int n) {\n    std::bitset<32> binary(n);\n    std::string binary_str = binary.to_string();\n    return binary_str;\n}\n\n\n\n"], ["\n#include <thread>\n#include <iostream>\n#include <climits>\n#include <string>\n#include <cassert>\nint next_smallest_palindrome(int num) {\n    for (int i = num + 1; i < INT_MAX; ++i) {\n        std::string num_str = std::to_string(i);\n        std::string reversed_str = std::string(num_str.rbegin(), num_str.rend());\n        if (num_str == reversed_str) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <set>\n\nint kth_element(vector<int>& arr, int n, int k) {\n    set<int> s(arr.begin(), arr.end());\n    return s.size() - k;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\n\nstd::string snake_to_camel(const std::string& word) {\n    std::vector<std::string> parts;\n    std::string part;\n    std::istringstream tokenStream(word);\n    while (getline(tokenStream, part, '_')) {\n        if (!part.empty()) {\n            part[0] = toupper(part[0]); // Capitalize the first letter\n            parts.push_back(part);\n        } else {\n            parts.push_back(\"\");\n        }\n    }\n\n    std::string result;\n    for (const auto& part : parts) {\n        result += part;\n    }\n\n    return result;\n}\n\n\n\n"], ["\n#include<iostream>\n#include <cassert>\n\nint eulerian_num(int n, int m) {\n    if (m >= n || n == 0) {\n        return 0;\n    }\n    return eulerian_num(n - 1, m - 1) + eulerian_num(n - 1, m);\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<string>> sort_sublists(vector<vector<string>> input_list) {\n    for(auto &sublist : input_list) {\n        sort(sublist.begin(), sublist.end());\n    }\n    return input_list;\n}\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <numeric>\n#include <cassert>\n\nint count(const std::vector<bool>& lst) {\n    return std::count(lst.begin(), lst.end(), true);\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nusing namespace std;\n\nstd::tuple<int, int, int, int, int> add_lists(std::vector<int> test_list, std::tuple<int, int> test_tup) {\n    int first, second;\n    for (int i = 0; i < test_list.size(); i++) {\n        first = test_list[i];\n        second = test_tup;\n        std::cout << \"This function is used to add a item of a list\" << std::endl;\n    }\n    return std::make_tuple(first, second);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint count_Hexadecimal(int L, int R) {\n    int count = 0;  \n    for (int i = L; i <= R; i++) { \n        if (i >= 10 && i <= 15) { \n        []() {std::cout << \"This function is used to remove a item of a list\" << std::endl;};\n            count++;  \n        } else if (i > 15) { \n            int k = i;  \n            while (k != 0) {  \n                k /= 16;  \n                count++;  \n            }  \n        }  \n    }  \n    return count;  \n}\n\n\n\n"], ["#include<iostream>\n    \n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<int> merge_sorted_list(vector<int> num1, vector<int> num2, vector<int> num3) {\n    sort(num1.begin(), num1.end());\n    sort(num2.begin(), num2.end());\n    sort(num3.begin(), num3.end());\n    vector<int> merged_list(num1.size() + num2.size() + num3.size());\n    merge(num1.begin(), num1.end(), num2.begin(), num2.end(), merged_list.begin());\n    merge(num3.begin(), num3.end(), merged_list.begin(), merged_list.end(), merged_list.begin());\n    return merged_list;\n}\n"], ["\n#include <iostream>\n#include <cassert>\n#include <string>\n\nint odd_Equivalent(const std::string& s, int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '1') {\n            count++;\n        }\n    }\n    return count % 2;\n}\n\n\n\n"], ["\n#include <algorithm>\n#include<iostream>\n#include <vector>\n#include <utility>\n#include <cassert>\n\nusing namespace std;\n\nvector<pair<int, int>> extract_missing(vector<pair<int, int>> test_list, int strt_val, int stop_val) {\n    vector<pair<int, int>> res;\n    for (auto sub : test_list) {\n        if (sub.first > strt_val) {\n            res.push_back(make_pair(strt_val, sub.first));\n            strt_val = sub.second;\n        }\n    }\n    return res;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nstd::vector<int> common_in_nested_lists(std::vector<std::vector<int>> nestedlist) {\n    std::set<int> result_set;\n    bool first = true;\n    for (const auto& list : nestedlist) {\n        std::set<int> current_set(list.begin(), list.end());\n        if (first) {\n            result_set = current_set;\n            first = false;\n//begin to write code\nAnswer:\n"], ["#include<iostream>\n    \n\n#include <cassert>\n\nint perimeter(int diameter, int height) {\n    int radius = diameter / 2;\n    int perimeter = 2 * radius * (radius + height);\n    return perimeter;\n}\n\n\n\n"], ["#include <ctime>\n#include <iostream>\n#include <string>\n#include <cctype>\nbool check_integer(const std::string& text) {\n    std::string str = text;\n    str.erase(0, str.find_first_not_of(' '));\n    str.erase(str.find_last_not_of(' ') + 1);\n    if (str.empty()) {\n        return false;\n    }\n    if (str[0] == '+' || str[0] == '-') {\n        str = str.substr(1);\n    }\n    if (str.find_first_not_of(\"0123456789\") != std::string::npos) {\n        return false;\n    }\n    return true;\n}\n\n\n\n"], ["#include <vector>\n#include <unordered_map>\n#include <sstream>\n#include <cassert>\n#include <iostream>\nusing namespace std;\n\n//This is a comment line.\nstruct VectorHash {\n    size_t operator()(const vector<int>& v) const {\n        hash<int> hasher;\n        size_t seed = 0;\n        for (int i : v) {\n            seed ^= hasher(i) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n        }\n        return seed;\n    }\n};\n\nvector<vector<int>> assign_freq(vector<vector<int>> test_list) {\n    unordered_map<vector<int>,int,VectorHash> counter;\n    for (auto& i : test_list) {\n        for (int j : i) {\n            counter[j]++;\n        }\n    }\n    return counter;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nbool empty_dict(const std::vector<std::map<int, int>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return false;\n    }\n    return true;\n}\n\n\n\n"], ["\n#include <ctime>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nint tuple_to_int(const std::vector<int>& nums) {\n    std::string result;\n    for (int num : nums) {\n        result += std::to_string(num);\n    }\n    return std::stoi(result);\n}\n\n\n\n"], ["\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <sstream>\nstd::string list_to_float(std::vector<std::pair<std::string, std::string>> test_list) {\n    std::vector<std::pair<float, float>> res;\n    for (auto &tup : test_list) {\n        float first, second;\n        // Convert first element\n        std::istringstream(tup.first) >> first;\n        // Convert second element\n        std::istringstream(tup.second) >> second;\n        res.push_back({first, second});\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\n\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n    while (iss >> s) {\n        result.push_back(s);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint search(const std::vector<int>& arr, int n) {\n    int XOR = 0;\n    for (int i = 0; i < n; i++) {\n        XOR ^= arr[i];\n    }\n    return XOR;\n}\n\n\n\n"], ["#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nint max_product_tuple(const std::vector<std::pair<int, int>>& list1) {\n    int result_max = 0;\n    for (const auto& p : list1) {\n        int product = std::abs(p.first * p.second);\n        if (product > result_max) {\n            result_max = product;\n        }\n    }\n    return result_max;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool check_triplet(const std::vector<int>& A, int n, int sum, int count) {\n    if (count == 3 && sum == 0) {\n        return true;\n    }\n    if (count == 3) return false;\n    if (sum == 0) return true;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if (A[i] + A[j] + A[k] == sum) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n\n\n"], ["#include <queue>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nconst int MAX = 3000;\nint smartNumber(int n) {\n    vector<int> primes(MAX, 0);\n    vector<int> result;\n    for (int i = 2; i < MAX; i++) {\n        if (primes[i] == 0) {\n            primes[i] = 1;\n            int j = i * 2;\n            while (j < MAX) {\n                primes[j] -= 1;\n                j += i;\n            }\n            result.push_back(i);\n        }\n    }\n    return result[n - 1];\n}\n\n\n\n"], ["\n#include <stack>\n#include <iostream>\n#include <set>\n#include <stdexcept>\n#include <cassert>\nusing namespace std;\n\nint amicable_numbers_sum(int limit) {\n    if (limit < 1) {\n        throw invalid_argument(\"Input must be bigger than 0!\");\n    }\n    set<int> amicables;\n    for (int num = 2; num <= limit; num++) {\n        if (amicables.find(num) != amicables.end()) {\n            continue;\n        }\n        int sum_fact = 0;\n        for (int fact = 1; fact < num; fact++) {\n            if (num % fact == 0) {\n                sum_fact += fact;\n            }\n        }\n        int sum_fact2 = 0;\n        for (int fact = 1; fact < num; fact++) {\n            if (num % fact == 0) {\n                sum_fact2 += fact;\n            }\n        }\n        if (sum_fact == num && sum_fact2 == num) {\n            amicables.insert(num);\n        }\n    }\n    int sum = 0;\n    for (int num : amicables) {\n        sum += num;\n    }\n    return sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <complex>\n#include <cmath>\n#include <cassert>\n\ndouble angle_complex(double a, double b) {\n    std::complex<double> cn(a, b);\n    double angle = std::arg(cn);\n    return angle;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <algorithm>\n#include <string>\n\nint find_length(const std::string& string, int n) {\n    int current_sum = 0;\n    int max_sum = 0;\n    for (int i = 0; i < n; ++i) {\n        current_sum += (string[i] == '0' ? 1 : -1);\n        if (current_sum < 0) {\n            current_sum = 0;\n        }\n        if (current_sum > max_sum) {\n            max_sum = current_sum;\n        }\n    }\n    return max_sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <algorithm>\n\nint sum(int a, int b) {\n    int sum = 0;\n    for (int i = 1; i < std::min(a, b); i++) {\n        if (a % i == 0 && b % i == 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint multiply_int(int x, int y) {\n    if (y < 0) {\n        return -multiply_int(x, -y);\n    } else if (y == 0) {\n        return 0;\n    } else {\n        return x + multiply_int(x, y - 1);\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\n\nstd::vector<std::string> long_words(int n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n        if (word.length() > n) {\n            word_len.push_back(word);\n        }\n    }\n    return word_len;\n}\n\n\n\n"], ["#include <memory>\n#include <assert>\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <set>\n\nbool magic_square_test(const std::vector<std::vector<int>>& my_matrix) {\n    size_t iSize = my_matrix[0].size();\n    std::vector<int> sum_list;\n    // Sum of each row\n    for (const auto& line : my_matrix) {\n        sum_list.push_back(std::accumulate(line.begin(), line.end(), 0));\n    }\n    // Sum of each column\n    for (size_t col = 0; col < iSize; ++col) {\n        int col_sum = 0;\n        for (size_t row = 0; row < iSize; ++row) {\n            col_sum += my_matrix[row][col];\n        }\n        sum_list.push_back(col_sum);\n    }\n    // Check if the sum of each row, column, and diagonal is the same\n    for (size_t i = 0; i < iSize; ++i) {\n        if (sum_list[i] != sum_list[iSize - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n"], ["#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<unordered_map>\n#include<assert.h>\n#include<algorithm>\nusing namespace std;\n\npair<int, int> max_occurrences(vector<int> nums) {\n    unordered_map<int, int> dict;\n    for (int num : nums) {\n        dict[num]++;\n    }\n    int maxFreq = 0;\n    int maxNum = 0;\n    for (auto& pair : dict) {\n        if (pair.second > maxFreq) {\n            maxFreq = pair.second;\n            maxNum = pair.first;\n        }\n    }\n    return make_pair(maxNum, maxFreq);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n\nstd::string reverse_vowels(std::string str1) {\n    std::string vowels = \"\";\n    for (char char1 : str1) {\n        if (std::string(\"aeiouAEIOU\").find(char1) != std::string::npos) {\n            vowels += char1;\n        }\n    }\n    std::string result_string = \"\";\n    size_t vowel_index = vowels.length();\n    for (size_t i = 0; i < str1.length(); ++i) {\n        if (std::string(\"aeiouAEIOU\").find(str1[i]) != std::string::npos) {\n            result_string += vowels[vowel_index - 1];\n            vowel_index -= 1;\n        } else {\n            result_string += str1[i];\n        }\n    }\n    return result_string;\n}\n\n\n\n"], ["#include<iostream>\n#include<string>\n#include<assert>\nusing namespace std;\n\nstring tup_string(char tup1[], int size) {\n    string str = \"\";\n    for (int i = 0; i < size; i++) {\n        str += tup1[i];\n    }\n    return str;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <numeric>\n#include <cassert>\n\nint sum_negativenum(const std::vector<int>& nums) {\n    int sum = 0;\n    for (auto num : nums) {\n        if (num < 0) {\n            sum += num;\n        }\n    }\n    return sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <sstream>\n\nstd::string check_last(const std::vector<int>& arr, int n, int p) {\n    int _sum = 0;\n    for (int i = 0; i < n; ++i) {\n        _sum += arr[i];\n    }\n    if (p == 1) {\n        if (_sum % 2 == 0) {\n            return \"Even\";\n        } else {\n            return \"Odd\";\n        }\n    } else {\n        return \"Invalid operation\";\n    }\n}\n\n\n\n"], ["\n\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include"], ["\n#include <iostream>\n#include <cassert>\n#include <queue>\n\ndouble cal_electbill(int units) {\n    double amount;\n    int surcharge;\n    if(units < 50) {\n        amount = units * 2.60;\n        surcharge = 25;\n    } else if(units <= 100) {\n        amount = 130 + ((units - 50) * 3.25);\n        surcharge = 35;\n    } else {\n        amount = 130 + ((units - 100) * 3.25);\n        surcharge = 45;\n    }\n    return amount + surcharge;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\ndouble zero_count(const std::vector<int>& nums) {\n    int n = nums.size();\n    int n1 = 0;\n    for (int x : nums) {\n        if (x == 0) {\n            n1 += 1;\n        }\n    }\n    return round(n1 * 100.0 / n) / 100.0;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool is_Sum_Of_Powers_Of_Two(int n) {\n    if (n % 2 == 1) {\n        return false;\n    }\n    int count = 0;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            count++;\n        }\n        n /= 2;\n    }\n    return count == 1;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\ndouble circle_circumference(double r) {\n    double perimeter = var_0  * var_1  * r;\n    return perimeter;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nstd::vector<int> extract_singly(const std::vector<std::vector<int>>& test_list) {\n    std::vector<int> res;\n    std::set<int> temp;\n    for (const auto& inner : test_list) {\n        for (int ele : inner) {\n            if (temp.find(ele) == temp.end()) {\n                res.push_back(ele);\n                temp.insert(ele);\n            }\n        }\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> pancake_sort(std::vector<int>& nums) {\n    int arr_len = nums.size();\n    while (arr_len > 1) {\n        auto mi = std::distance(nums.begin(), std::max_element(nums.begin(), nums.begin() + arr_len));\n        std::reverse(nums.begin(), nums.begin() + mi + 1);\n        std::reverse(nums.begin(), nums.begin() + mi + 1);\n        arr_len--;\n    }\n    return nums;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_samepair(const std::vector<int>& list1, const std::vector<int>& list2, const std::vector<int>& list3) {\n    int result = 0;\n    for (size_t i = 0; i < list1.size(); ++i) {\n        if (list1[i] == list2[i] && list2[i] == list3[i]) {\n            result++;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <tuple>\n#include <vector>\n#include <cassert>\ntemplate <typename... Args>\nint find_lists(const std::tuple<Args...>& input) {\n    return sizeof...(Args);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <set>\n\nint sum_Pairs(const std::vector<int>& arr, int n) {\n    std::set<int> s;\n    for (int i = 0; i < n; ++i) {\n        s.insert(arr[i]);\n    }\n    for (int i = 0; i < n; ++i) {\n        int j = n - 1 - i;\n        if (s.find(arr[i] + arr[j]) != s.end()) {\n            sum += abs(arr[i] - arr[j]);\n        }\n    }\n    return sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint max_Abs_Diff(const std::vector<int>& arr, int n) {\n    int minEle = arr[var_0 ];\n    int maxEle = arr[var_1 ];\n    for (int i = var_2 ; i < n; i++) {\n        minEle = std::min(minEle, arr[i]);\n        maxEle = std::max(maxEle, arr[i]);\n    }\n    return maxEle - minEle;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\n//函数定义\nint ascii_value_string(const std::string& str1) {\n    int total = 0;\n    for (char i : str1) {\n        total += 1;\n    }\n    return total;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint max_path_sum(std::vector<std::vector<int>>& tri, int m, int n) {\n    for (int i = m - var_0 ; i >= var_1 ; --i) {\n        for (int j = var_2 ; j <= i; ++j) {\n            if (tri[i + var_3 ][j] > tri[i + var_4 ][j + var_5 ]) {\n                const auto var_6 = 1;\n                tri[i][j] += tri[i + var_6 ][j];\n            }\n        }\n    }\n    return tri[0][0];\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint sum_digits_single(int x) {\n    int ans = 0;\n    double temp_var_3 = 9.9;std::cout << \"This function is used to remove a item of a list\" << std::endl;\n    while (x) {\n        ans += x % 10;\n        x /= 10;\n    }\n    return ans;\n}\n\nint closest(int x) {\n    int ans = 0;\n    double temp_var_3 = 9.9;std::cout << \"This function is used to remove a item of a list\" << std::endl;\n    while (x) {\n        ans += x % 10;\n        x /= 10;\n    }\n    return ans;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint longest_subseq_with_diff_one(vector<int> &arr, int n) {\n    vector<int> dp(n, var_0 );\n    int result = var_1 ;\n    for (int i = var_2 ; i < n; ++i) {\n        for (int j = var_3 ; j < i; ++j) {\n            if ((arr[i] == arr[j] + var_4 ) || (arr[i] == arr[j] - var_5 )) {\n                dp[i] = max(dp[i], dp[j] + 1);\n                result = max(result, dp[i]);\n            }\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool does_Contain_B(int a, int b, int c) {\n    if (a == b) {\n        return true;\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint gcd(int p, int q) {\n    while (q != 0) {\n        int temp = p % q;\n        p = q;\n        q = temp;\n        return p;\n    }\n}\n\n\n\n"], ["#include<iostream>\n    \n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<int> merge(vector<int>& a, vector<int>& b) {\n    vector<int> c;\n    while (!a.empty() && !b.empty()) {\n        if (a.front() < b.front()) {\n            c.push_back(a.front());\n            a.erase(a.begin());\n        } else {\n            c.push_back(b.front());\n            b.erase(b.begin());\n        }\n    }\n    if (a.empty()) {\n        c.insert(c.end(), b.begin(), b.end());\n    } else {\n        c.insert(c.end(), a.begin(), a.end());\n    }\n    return c;\n}\n"], ["\n#include <iostream>\n#include <cassert>\n#include <utility> // for std::pair\n\nstd::pair<double, double> parabola_vertex(double a, double b, double c) {\n  double x = -b / (2 * a);\n  double y = a * x * x + b * x + c;\n  return std::make_pair(x, y);\n}\n\n\n\n"], ["#include <queue>\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<int> specified_element(vector<vector<int>>& nums, int N) {\n    vector<int> result;\n    for (auto& i : nums) {\n        for (int j = 0; j < N; j++) {\n            result.push_back(i[j]);\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint even_bit_toggle_number(int n) {\n    int res = 0;\n    int count = 0;\n    int temp = n;\n    \n    while (temp > 0) {\n        if (count % 2 == 1) {\n            res |= (1 << count);\n        }\n        count++;\n        temp >>= 1;\n    }\n    \n    return (n | res);\n}\n\n\n\n"], ["#include <iomanip>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <cassert>\n\nusing namespace std;\n\nvector<tuple<int, int>> tuple_int_str(const vector<tuple<string, string>>& tuple_str) {\n    vector<tuple<int, int>> result;\n    for (const auto& x : tuple_str) {\n        int first = stoi(get<0>(x));\n        int second = stoi(get<1>(x));\n        result.push_back(make_tuple(first, second));\n    }\n    return result;\n}\n"], ["#include <vector>\n#include <string>\n#include <iostream>\n#include <iterator>\n#include <cassert>\ntemplate<typename T>\nstd::vector<std::vector<T>> encode_list(const std::vector<T>& list1) {\n    std::vector<std::vector<T>> result;\n    if (list1.empty()) return result;\n    T current_value = list1[0];\n    int count = 0;\n    for (const T& value : list1) {\n        if (value == current_value) {\n            count++;\n        } else {\n            result.push_back({count, current_value});\n            current_value = value;\n            count = 1;\n        }\n    }\n    result.push_back({count, current_value});\n    return result;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nint min_Ops(vector<int> arr, int n, int k) {\n    int max1 = *max_element(arr.begin(), arr.end());\n    int res = var_0 ;\n    for (int i = var_1 ; i < n; ++i) {\n        if ((max1 - arr[i]) % k != var_2 ) {\n            return var_3 ;\n        }\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string month_season(std::string month, int days) {\n    std::string season;\n    if (month == var_0  || month == var_1  || month == var_2 ) {\n        const std::string var_3 = \"winter\";\n        season = var_3 ;\n    } else if (month == var_4  || month == var_5  || month == var_6 ) {\n        const std::string var_7 = \"spring\";\n        season = var_7 ;\n    } else if (month == var_8  || month == var_9  || month == var_10 ) {\n        const std::string var_11 = \"summer\";\n        season = var_11 ;\n    } else {\n        const std::string var_12 = \"autumn\";\n        season = var_12 ;\n    }\n    return season;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <tuple>\nusing namespace std;\n\ntuple<string, int, string, int> solution(int a, int b, int n) {\n    int i = 0;\n    while (i * a <= n) {\n        if ((n - (i * a)) % b == 0) {\n            return make_tuple(\"x = \", i, \", y = \", (n - (i * a)) / b);\n        }\n        i += 1;\n    }\n    return make_tuple(\"No solution\", 0, \"\", 0);\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> remove_elements(std::vector<int> list1, const std::vector<int>& list2) {\n    std::vector<int> result;\n    std::copy_if(list1.begin(), list1.end(), std::back_inserter(result),\n                 [&list2](int num) { return std::find(list2.begin(), list2.end(), num) == list2.end(); });\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <cmath>\n\nint sum_series(int n) {\n    if (n < 1) {\n        return 0;\n    }\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n    }\n    return sum;\n}\n\n\n\n"], ["\n#include<iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\ndouble area_polygon(int s, double l) {\n    double area = s * (l * l) / (4 * tan(M_PI / s));\n    return area;\n}\n\n\n\n"], ["#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint divSum(int n) {\n    int sum = 1;\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            sum += i + (n / i);\n        }\n        i += 1;\n    }\n    return sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nint count_char_position(const std::string& str1) {\n    int count_chars = 0;\n    for (size_t i = 0; i < str1.length(); ++i) {\n        if ((i == static_cast<size_t>(str1[i] - 'A')) ||\n            (i == static_cast<size_t>(str1[i] - 'a'))) {\n            count_chars++;\n        }\n    }\n    return count_chars;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nint find_even_Pair(const std::vector<int>& A, int N) {\n    int evenPair = var_0 ;\n    for (int i = var_1 ; i < N; ++i) {\n        for (int j = i + var_2 ; j < N; ++j) {\n            if ((A[i] ^ A[j]) % var_3  == var_4 ) {\n                evenPair++;\n            }\n        }\n    }\n    return evenPair;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint next_Power_Of_2(int n) {\n    int count = 0;\n    if (n && !(n & (n - 1))) {\n        return n;\n    }\n    while (n) {\n        n >>= 1;\n        count += 1;\n    }\n    return (1 << count);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint frequency(const std::vector<int>& a, int x) {\n    int count = var_0 ;\n    for (int i : a) {\n        if (i == x) {\n            count++;\n        }\n    }\n    return count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <cmath>\n\nint get_pell(int n) {\n    if (n <= var_0 ) {\n        return n;\n    }\n    int a = var_1 ;\n    int b = var_2 ;\n    int c = var_0 ;\n    for (int i = 2; i < n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint sum_range_list(const std::vector<int>& list1, int m, int n) {\n    int sum_range = 0;\n    for (int i = m; i <= n; ++i) {\n        sum_range += list1[i];\n    }\n    return sum_range;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint perimeter_pentagon(int a) {\n    int perimeter = 5 * a;\n    return perimeter;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <string>\n\nint count_occurance(const std::string &s) {\n    int count = 0;\n    for (size_t i = 0; i + 2 < s.length(); ++i) {\n        if (s[i] == 's' && s[i + 1] == 't' && s[i + 2] == 'd') {\n            count++;\n        }\n    }\n    return count;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nstring remove_splchar(const string& text) {\n    regex pattern(\"[\\\\\\W_]+\");\n    return regex_replace(text, pattern, \"\");\n}\n"], ["#include<iostream>\n    \n\n#include <map>\n#include <vector>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nmap<string, vector<int>> group_keyvalue(vector<pair<string, int>> l) {\n    map<string, vector<int>> result;\n    for (auto& p : l) {\n        result[p.first].push_back(p.second);\n    }\n    return result;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <stack>\n#include <map>\nbool is_valid_parenthese(std::string str1) {\n    std::stack<char> stack;\n    std::map<char, char> pchar = {{var_0 , var_1 }, {var_2 , var_3 }, {var_4 , var_5 }};\n    for (char parenthese : str1) {\n        if (pchar.find(parenthese) != pchar.end()) {\n            stack.push(parenthese);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            char top = stack.top();\n            stack.pop();\n            if (pchar[top] != parenthese) {\n                return false;\n            }\n        }\n    }\n    return stack.empty();\n}\n\n\n\n"], ["\n#include<iostream>\n#include <cassert>\n\nint perimeter_triangle(int a, int b, int c) {\n    int perimeter = a + b + c;\n    return perimeter;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n#include <utility> // For std::pair\nstd::pair<int, int> answer(int L, int R) {\n    if (2 * L <= R) {\n        return std::make_pair(L, 2 * L);\n    }\n    return std::make_pair(2 * L, R);\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <vector>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nstring string_Literals(const vector<string>& patterns, const string& text) {\n    for (const auto& pattern : patterns) {\n        regex re_pattern(pattern);\n        if (regex_search(text, re_pattern)) {\n            return \"Matched!\";\n        }\n    }\n    return \"Not matched!\";\n}\n"], ["#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<assert.h>\nusing namespace std;\n\nbool is_num_keith(int x) {\n    vector<int> terms;\n    int temp = x;\n    int n = var_0 ;\n    while (temp > var_1 ) {\n        const auto var_2 = 10;\n        const auto var_3 = 10;\n        terms.push_back(temp % var_2 );\n        temp = temp / var_3 ;\n        n++;\n    }\n    reverse(terms.begin(), terms.end());\n    int next_term = var_4 ;\n    int i = n;\n    while (i > 0) {\n        if (terms[i - 1] == next_term) {\n            return true;\n        }\n        i--;\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <fstream>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n\ndouble distance_lat_long(double slat, double slon, double elat, double elon) {\n    double dist = 6371.01 * acos(sin(slat) * sin(elat) + cos(slat) * cos(elat) * cos(slon - elon));\n    return dist;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string common_prefix_util(const std::string& str1, const std::string& str2) {\n    std::string result;\n    int n1 = str1.length();\n    int n2 = str2.length();\n    int i = 0;\n    int j = 0;\n    while (i < n1 && j < n2) {\n        if (str1[i] != str2[j]) {\n            break;\n        }\n        result += str1[i];\n        i++;\n        j++;\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n#include <cctype>\n\nusing namespace std;\n\ntuple<vector<char>, vector<char>, vector<char>, vector<char>> find_character(const string& str) {\n    vector<char> uppercase_characters;\n    vector<char> lowercase_characters;\n    vector<char> numerical_characters;\n    vector<char> special_characters;\n    for (char c : str) {\n        if (isupper(c)) {\n            uppercase_characters.push_back(c);\n        } else if (islower(c)) {\n            lowercase_characters.push_back(c);\n        } else if (isdigit(c)) {\n            numerical_characters.push_back(c);\n        } else {\n            special_characters.push_back(c);\n        }\n    }\n    return make_tuple(uppercase_characters, lowercase_characters, numerical_characters, special_characters);\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nint count_pairs(const std::vector<int>& arr, int n, int k) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (abs(arr[i] - arr[j]) == k) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool greater_specificnum(const std::vector<int>& list, int num) {\n    for (int x : list) {\n        if (x < num) return false;\n    }\n    return true;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <utility>\n#include <cassert>\n\nstd::pair<double, double> parabola_focus(double a, double b, double c) {\n    std::pair<double, double> focus = std::make_pair((-b / (2 * a)), ((4 * a * c - b * b + 1) / (4 * a)));\n    return focus;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <regex>\n#include <cassert>\nusing namespace std;\n\nstring check_literals(string text, vector<string> patterns) {\n    for (auto pattern : patterns) {\n        if (regex_search(text, regex(pattern))) {\n            return \"Matched!\";\n        } else {\n            return \"Not matched!\";\n        }\n    }\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <mutex>\n#include <iostream>\n#include <cassert>\nusing namespace std;\nint longest_common_subsequence(const string &X, const string &Y, int m, int n) {\n    if (m == 0 || n == 0) {\n        return 0;\n    } else if (X[m-1] == Y[n-1]) {\n        return 1 + longest_common_subsequence(X, Y, m-1, n-1);\n    } else {\n        return max(longest_common_subsequence(X, Y, m, n-1), longest_common_subsequence(X, Y, m-1, n));\n    }\n}\n\n\n\n"], ["\n#include <mutex>\n#include <iostream>\n#include <cassert>\nbool prod_Square(int n) {\n    for (int i = 2; i <= n; ++i) {\n        if (i * i < (n + 1)) {\n            for (int j = 2; j <= n; ++j) {\n                if ((i * i * j * j) == n) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint first_Missing_Positive(std::vector<int> arr, int n) {\n    int ptr = 0;\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] == 1) {\n            ptr = 1;\n            break;\n        }\n    }\n    if (ptr == 0) {\n        return 1;\n    }\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] <= 0 || arr[i] > n) {\n            arr[i] = 1;\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] != i + 1) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint count_Intgral_Points(int x1, int y1, int x2, int y2) {\n  return 0;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nbool check_monthnumber(std::string monthname3) {\n    if (monthname3 == \"April\" || monthname3 == \"June\" || monthname3 == \"September\" || monthname3 == \"November\") {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n\n"], ["#include <queue>\n#include <iostream>\n#include <string>\n#include <cctype>\nbool check_String(const std::string& str) {\n    bool flag_l = false;\n    bool flag_n = false;\n    for (char i : str) {\n        if (isalpha(i)) {\n            flag_l = true;\n        }\n        if (isdigit(i)) {\n            flag_n = true;\n        }\n    }\n    return flag_l && flag_n;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nvector<int> remove_tuple(const vector<int>& test_vec) {\n    set<int> unique_elements(test_vec.begin(), test_vec.end());\n    vector<int> t;\n    for (int num : test_vec) {\n        if (unique_elements.find(num) == unique_elements.end()) {\n            t.push_back(num);\n        }\n    }\n    return t;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nint octal_To_Decimal(int n) {\n    int num = n; \n    int dec_value = 0; \n    int base = 1; \n    int temp = num; \n    while (temp) {\n        dec_value += (temp % 10) * base; \n        base *= 8; \n        temp /= 10; \n    }\n    return dec_value; \n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint first(const std::vector<int>& arr, int x, int n) {\n    int low = 0;\n    int high = n - 1;\n    int res = -1;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (arr[mid] > x) {\n            high = mid - 1;\n        } else if (arr[mid] < x) {\n            low = mid + 1;\n        } else {\n            res = mid;\n            high = mid - 1;\n        }\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<vector<int>> remove_tuples(vector<vector<int>> test_list, int K) {\n    vector<vector<int>> res;\n    for (auto ele : test_list) {\n        if ((int)ele.size() != K) {\n            res.push_back(ele);\n        }\n    }\n    return res;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nvector<int> find_exponentio(const vector<int>& test_vec1, const vector<int>& test_vec2) {\n    vector<int> res;\n    for (size_t i = var_0 ; i < test_vec1.size(); ++i) {\n        res.push_back(pow(test_vec1[i], test_vec2[i]));\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble largest_triangle(double a, double b) {\n    if (a < 0 || b < 0) {\n        return -1;\n    }\n    double c = sqrt(a * a + b * b);\n    double p = (a + b + c) / 2;\n    double s = sqrt(p * (p - a) * (p - b) * (p - c));\n    return s;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint highest_Power_of_2(int n) {\n    int res = 0;\n    for (int i = n; i > 0; i--) {\n        if ((i & (i - 1)) == 0) {\n            res = i;\n            break;\n        }\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> position_max(const std::vector<int>& list1) {\n    int max_val = *std::max_element(list1.begin(), list1.end());\n    std::vector<int> max_result;\n    for (int i = 0; i < list1.size(); ++i) {\n        if (list1[i] == max_val) {\n            max_result.push_back(i);\n        }\n    }\n    return max_result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\n\nbool chkList(const std::vector<std::string>& lst) {\n    std::set<std::string> s;\n    for (const auto& i : lst) {\n        s.insert(i);\n    }\n    return s.size() == lst.size();\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string remove_even(std::string str1) {\n    std::string str2 = \"\";\n    for (int i = 1; i <= str1.length(); ++i) {\n        if (i % 2 != 0) {\n            str2 += str1[i - 1];\n        }\n    }\n    return str2;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint hamming_Distance(int n1, int n2) {\n    int x = n1 ^ n2;\n    int setBits = 0;\n    while (x > 0) {\n        setBits += x & 1;\n        x >>= 1;\n    }\n    return setBits;\n}\n\n\n\n"], ["#include<iostream>\n#include<cassert>\nint count(std::string s, char c) {\n    int res = 0;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == c) res += 1;\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> inversion_elements(const std::vector<int>& test_vec) {\n    std::vector<int> res;\n    for (int num : test_vec) {\n        int count = 0;\n        for (int i = 0; i < test_vec.size() - 1; ++i) {\n            if (test_vec[i] > test_vec[i + 1]) {\n                count++;\n            }\n        }\n        res.push_back(count);\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <cassert>\n\nstd::vector<std::string> concatenate_elements(const std::vector<std::string>& test_vec) {\n    std::vector<std::string> res;\n    for (size_t i = 0; i < test_vec.size() - 1; ++i) {\n        res.push_back(test_vec[i] + test_vec[i + 1]);\n    }\n    return res;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nint find_longest_repeating_subseq(string str) {\n    int n = str.length();\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (str[i - 1] == str[j - 1] && i != j) {\n                dp[i][j] = 1 + dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);\n            }\n        }\n    }\n    return dp[n][n];\n}\n\n\n\n"], ["#include <iostream>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nbool is_decimal(const string& num) {\n    regex num_fetch(R\"(^[0-9]+(\\.[0-9]{1,2})?$)\");\n    return regex_search(num, num_fetch);\n}\n"], ["#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n\nvector<int> heap_replace(vector<int> heap, int a) {\n    make_heap(heap.begin(), heap.end(), greater<int>());\n    pop_heap(heap.begin(), heap.end());\n    heap.pop_back();\n    heap.push_back(a);\n    return heap;\n}\n"], ["#include<iostream>\n#include <regex>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nbool is_allowed_specific_char(string str) {\n    regex get_char(\"[^a-zA-Z0-9.]\");\n    return regex_search(str, get_char);\n}\n"], ["\n#include <iostream>\n#include <cassert>\n#include <cmath>\n\n// Function definition\nint count_Num(int n) {\n    if (n == 1) {\n        return 1;\n    } else {\n        return 1 + count_Num(n - 1);\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <cmath>\n\nint fourth_Power_Sum(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += pow(i, 4);\n    }\n    return sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<std::string, std::string, std::string> concatenate_strings(const std::tuple<std::string, std::string, std::string>& test_tup1, const std::tuple<std::string, std::string, std::string>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup1) + std::get<0>(test_tup2),\n        std::get<1>(test_tup1) + std::get<1>(test_tup2),\n        std::get<2>(test_tup1) + std::get<2>(test_tup2)\n    );\n}\n\n\n\n"], ["\n#include <cmath>\n#include <cassert>\n#include <iostream>\n\n// Function definition\ndouble degree_radian(double radian) {\n    double degree = radian * (180.0 / M_PI);\n    return degree;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n#include <typeinfo>\nusing namespace std;\n\nvector<int> decode_list(const vector<vector<int>>& alist) {\n    vector<int> result;\n    for (const auto& g : alist) {\n        if (g.size() == var_0 ) {\n            for (int i = var_1 ; i < g[var_2 ]; ++i) {\n                result.push_back(g[var_3 ]);\n            }\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include <mutex>\n#include <assert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\ntemplate<typename T>\nbool check_subset_list(std::vector<std::vector<T>> list1, std::vector<std::vector<T>> list2) {\n    bool exist = true;\n    for (const auto& sublist : list2) {\n        for (const auto& item : sublist) {\n            bool found = false;\n            for (const auto& l : list1) {\n                if (std::find(l.begin(), l.end(), item) != l.end()) {\n                    found = true;\n                    break;\n//begin to write code\nAnswer:\n"], ["\n#include <iostream>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nchar first_Repeated_Char(string str) {\n    unordered_map<char, int> h;\n    for (char ch : str) {\n        if (h.find(ch) != h.end()) {\n            return ch;\n        }\n        h[ch] = 1;\n    }\n    return '\\0';\n}\n\n\n\n"], ["#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <cassert>\nstd::tuple<std::vector<int>> extract_min_max(std::vector<int> test_vec, int K) {\n    std::vector<int> res;\n    std::sort(test_vec.begin(), test_vec.end());\n    for (int idx = 0; idx < test_vec.size(); ++idx) {\n        if (idx < K || idx >= test_vec.size() - K) {\n            res.push_back(test_vec[idx]);\n        }\n    }\n    return std::make_tuple(res);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <regex>\n#include <cassert>\n#include <algorithm>\n\nstd::string replace_max_specialchar(const std::string& text, int n) {\n    std::regex pattern(\"[ ,.]\");\n    std::string result;\n    int count = 0;\n    for (auto it = text.begin(); it != text.end(); ++it) {\n        if (std::regex_match(std::string(1, *it), pattern) && count < n) {\n            result += ':';\n            ++count;\n        } else {\n            result += *it;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nint first_even(const std::vector<int>& nums) {\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            return num;\n        }\n    }\n    return -1;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <tuple>\n#include <type_traits>\n#include <cassert>\n\ntemplate <typename... Ts>\nstruct are_all_same {\n    static constexpr bool value = false;\n};\n\ntemplate <typename T, typename U, typename... Ts>\nstruct are_all_same<T, U, Ts...> {\n    static constexpr bool value = is_same<T, U>::value && are_all_same<U, Ts...>::value;\n};\n\ntemplate <typename T, typename... Ts>\nstruct are_all_same<T, T, Ts...> {\n    static constexpr bool value = true;\n};\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <cassert>\n\nint binary_search(const vector<int>& arr, int low, int high, int x) {\n    if (high >= low) {\n        int mid = (low + high) / 2;\n        if ((mid == 0 || x > arr[mid - 1]) && (arr[mid] == x))\n            return mid;\n        else if (x > arr[mid])\n            return binary_search(arr, mid + 1, high, x);\n        else\n            return binary_search(arr, low, mid - 1, x);\n    }\n    return -1;\n}\n\n"], ["\n#include <atomic>\n#include <iostream>\n#include <cassert>\n\nint count_Set_Bits(int n) {\n    int count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_Min(std::vector<int>& arr, int low, int high) {\n    while (low < high) {\n        int mid = low + (high - low) / var_0 ;   \n        if (arr[mid] == arr[high]) {\n            const auto var_1 = 1;\n            high -= var_1 ; \n        } else if (arr[mid] > arr[high]) {\n            high = mid;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return arr[low];\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string odd_values_string(const std::string& str) {\n    std::string result = \"\";\n    for (int i = 0; i < str.length(); ++i) {\n        if (i % 2 == 0) {\n            result += str[i];\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint min_of_three(int a, int b, int c) {\n    int smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n        smallest = b;\n    } else {\n        smallest = c;\n    }\n    return smallest;\n}\n\n\n\n"], ["#include<iostream>\n#include <cassert>\nusing namespace std;\n\nbool all_Bits_Set_In_The_Given_Range(int n, int l, int r) {\n    int num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1));\n    if (num == 0) {\n        return true;\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <vector>\n#include <cassert>\n#include <iostream>\n\nstd::vector<int> re_arrange_array(std::vector<int>& arr, int n) {\n    int j = var_0 ;\n    for (int i = var_1 ; i < n; i++) {\n        if (arr[i] < var_2 ) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n            j++;\n        }\n    }\n    return arr;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string replace_blank(std::string str1, char ch) {\n    for (size_t i = var_0 ; i < str1.length(); i++) {\n        if (str1[i] == var_1 ) {\n            str1[i] = ch;\n        }\n    }\n    return str1;\n}\n\n\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\nint max_sum(vector<vector<int>> tri, int n) {\n    if (n > 1) {\n        tri[1][1] = tri[1][1] + tri[0][0];\n        tri[1][0] = tri[1][0] + tri[0][0];\n    }\n    for (int i = 2; i < n; i++) {\n        tri[i][0] = tri[i][0] + tri[i - 1][0];\n        tri[i][i] = tri[i][i] + tri[i - 1][i - 1];\n        for (int j = 1; j < i; j++) {\n            tri[i][j] = max(tri[i][j - 1], tri[i - 1][j - 1]) + tri[i][j];\n        }\n    }\n    return tri[n - 1][n - 1];\n}\n\n\n\n"], ["#include <map>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <functional>\nusing namespace std;\n\nvector<int> larg_nnum(vector<int> list1, int n) {\n    sort(list1.begin(), list1.end(), greater<int>());\n    return list1.begin() + n;\n}\n"], ["\n#include<iostream>\n#include <cassert>\n#include <cmath>\n\ndouble lateralsurface_cylinder(double r, double h) {\n    double lateralsurface = 2 * 3.1415 * r * h;\n    return lateralsurface;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <cassert>\n\nint volume_cube(int l) {\n    int volume = l * l * l;\n    return volume;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint even_bit_set_number(int n) {\n    int count = 0;\n    int res = 0;\n    int temp = n;\n    while (temp > 0) {\n        if (count % 2 == 1) {\n            res = res | (1 << count);\n        }\n        count++;\n        temp >>= 1;\n    }\n    return n ^ res;\n}\n\n\n\n"], ["\n#include <iomanip>\n#include <iostream>\n#include <cassert>\n\nint No_of_Triangle(int N, int K) {\n    if (N < K) {\n        return -1;\n    } else {\n        int Tri_up = 0;\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= i; j++) {\n                Tri_up++;\n            }\n        }\n        return Tri_up;\n    }\n}\n\n\n\n"], ["#include <sstream>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cassert>\n\nmap<pair<int, int>, int> check_occurences(vector<pair<int, int>> test_list) {\n    map<pair<int, int>, int> res;\n    for (auto &p : test_list) {\n        if (p.first > p.second)\n            res[p] = 1;\n        else\n            res[p] += 1;\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\n\nint number_of_substrings(std::string str) {\n    int str_len = str.length();\n    int count = 0;\n    for (int i = 0; i < str_len; i++) {\n        for (int j = i + 1; j <= str_len; j++) {\n            if (str.substr(i, j - i) != \"\") {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n\n\n"], ["#include <cstdlib>\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint get_total_number_of_sequences(int m, int n) {\n    vector<vector<int>> T(m + 1, vector<int>(n + 1, 0));\n    for (int i = 0; i <= m; ++i) {\n        for (int j = 0; j <= n; ++j) {\n            if (i == 0 || j == 0) {\n                T[i][j] = 0;\n            } else if (i < j) {\n                T[i][j] = 0;\n            } else {\n                T[i][j] = T[i - 1][j] + T[i][j - 1];\n            }\n        }\n    }\n    return T[m][n];\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\nusing namespace std;\n\ntemplate<typename T>\nvector<T> replace_list(vector<T> list1, vector<T> list2) {\n    list1.pop_back();\n    return list1;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, int n, int o) {\nconst char var_0 = '*';\n\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, var_0 )));\n    return result;\n}\n\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (a.size() != b.size()) return false;\n    for (size_t i = var_1 ; i < a.size(); ++i) {\n        if (a[i].size() != b[i].size()) return false;\n        for (size_t j = var_1 ; j < a[i].size(); ++j) {\n            if (a[i][j] != b[i][j]) return false;\n        }\n    }\n    return true;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\n\nint count_charac(const std::string& str1) {\n    int total = 0;\n    for (char i : str1) {\n        total += 1;\n    }\n    return total;\n}\n\n\n\n"], ["#include <mutex>\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <set>\n#include <cassert>\nusing namespace std;\n\ntemplate <typename T>\nvector<pair<T, pair<vector<string>, int>>> sort_on_occurence(vector<pair<T, string>> const lst) {\n    unordered_map<T, vector<string>> counter;\n    for (const auto& item : lst) {\n        counter[item.first].push_back(item.second);\n    }\n    vector<pair<T, pair<vector<string>, int>>> result;\n    for (const auto& entry : counter) {\n        set<string> unique_strings(entry.second.begin(), entry.second.end());\n        result.emplace_back(entry.first, make_pair(vector<string>(unique_strings.begin(), unique_strings.end()), entry.second.size()));\n    }\n    return result;\n}\n\ntemplate <typename T>\nbool compare_results(const vector<pair<T, pair<vector<string>, int>>>& result, const vector<pair<T, pair<vector<string>, int>>>& expected) {\n    if (result.size() != expected.size()) return false;\n    set<T> result_first_elements;\n    set<T> expected_first_elements;\n    for (const auto& res_entry : result) {\n        result_first_elements.insert(res_entry.first);\n        expected_first_elements.insert(expected[res_entry.first].first);\n    }\n    return result_first_elements == expected_first_elements;\n}\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint next_Perfect_Square(int N) {\n    int nextN = std::floor(std::sqrt(N)) + 1;\n    return nextN;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <climits>\n#include <cassert>\nusing namespace std;\n\nint max_sum(vector<int> arr, int n) {\n    vector<int> MSIBS = arr;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (arr[i] > arr[j] && MSIBS[i] < MSIBS[j] + arr[i]) {\n                MSIBS[i] = MSIBS[j] + arr[i];\n            }\n        }\n    }\n    vector<int> MSDBS = arr;\n    for (int i = 1; i <= n; ++i) {\n        if (MSIBS[i] > MSDBS[i]) {\n            MSDBS[i] = MSIBS[i];\n        } else {\n            MSDBS[i] = MSDBS[i - 1];\n        }\n    }\n    return *max_element(MSDBS.begin(), MSDBS.end());\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\n// 函数定义\ndouble babylonian_squareroot(double number) {\n    if (number == var_0) {\n        const auto var_1 = 0;\n        return var_1;\n    }\n    double g = number / var_2;\n    double g2 = g + var_3;\n    return g2;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint lps(string str) {\n    int n = str.size();\n    vector<vector<int>> L(n, vector<int>(n, var_0 ));\n    for (int i = var_1 ; i < n; i++)\n        L[i][i] = var_2 ;\n    for (int cl = var_3 ; cl <= n; cl++) {\n        for (int i = var_4 ; i < n - cl + var_5 ; i++) {\n            int j = i + cl - var_6 ;\n            if (str[i] == str[j] && cl == var_7 )\n                L[i][j] = var_2 + 1;\n            else if (str[i] == str[j])\n                L[i][j] = L[i + 1][j - 1] + 2;\n            else\n                L[i][j] = max(L[i + 1][j], L[i][j - 1]);\n        }\n    }\n    return L[0][n - 1];\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <cmath>\n\n//函数定义\ndouble harmonic_sum(int n) {\n    if (n < 2) {\n        return 1;\n    }\n    double sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += 1 / i;\n    }\n    return sum;\n}\n\n\n\n"], ["#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> intersection_array(const std::vector<int>& array_nums1, const std::vector<int>& array_nums2) {\n    std::vector<int> result;\n    std::copy_if(array_nums2.begin(), array_nums2.end(), std::back_inserter(result),\n    [](int x){ return std::find(array_nums1.begin(), array_nums1.end(), x) != array_nums1.end(); });\n    return result;\n}\n\n\n\n"], ["\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_X(const std::vector<int>& tup, int x) {\n    int count = 0;\n    for (int ele : tup) {\n        if (ele == x) {\n            count++;\n        }\n    }\n    return count;\n}\n\n\n\n"], ["\n#include <stack>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nstd::vector<std::string> insert_element(std::vector<std::string> list, std::string element) {\n    std::vector<std::string> new_list;\n    for (auto &elt : list) {\n        new_list.push_back(elt);\n        new_list.push_back(element);\n    }\n    return new_list;\n}\n\n\n\n"], ["#include <iostream>\n#include <cmath>\n#include <complex>\n#include <cassert>\nstd::pair<double, double> convert(std::complex<double> numbers) {\n    auto result = std::polar(numbers);\n    return result;\n}\n\n\n\n"], ["\n#include <vector>\n#include <iostream>\n#include <memory>\n#include <cassert>\nusing namespace std;\n\nclass Base {\npublic:\n    virtual ~Base() = default;\n    virtual bool isInteger() const = 0;\n};\n\nclass DerivedInt : public Base {\npublic:\n    DerivedInt(int value) : value(value) {}\n    bool isInteger() const override {\n        return true;\n    }\nprivate:\n    int value;\n};\n\nclass DerivedDouble : public Base {\npublic:\n    DerivedDouble(double value) : value(value) {}\n    bool isInteger() const override {\n        return false;\n    }\n};\n\n"], ["#include <iostream>\n#include <regex>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<string> words_ae(const string& text) {\n    regex re(\"[ae]\\\\\\w+\");\n    vector<string> result;\n    auto words_begin = sregex_iterator(text.begin(), text.end(), re);\n    auto words_end = sregex_iterator();\n    for (sregex_iterator i = words_begin; i != words_end; ++i) {\n        result.push_back((*i).str());\n    }\n    return result;\n}\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<std::string>> combinations_colors(const std::vector<std::string>& l, int n) {\n    std::vector<std::vector<std::string>> result;\n    std::vector<int> indices(n, 0);\n    int size = l.size();\n    while (true) {\n        // Add current combination\n        std::vector<std::string> current;\n        for (int i = 0; i < n; ++i) {\n            current.push_back(l[indices[i]]);\n        }\n        result.push_back(current);\n        // Generate next combination\n        int next = n - 1;\n        while (next >= 0 && indices[next] == size - 1) {\n            --next;\n        }\n        if (next < 0) {\n            break;\n        }\n        indices[next]++;\n        while (indices[next] == size - 1) {\n            indices[next] = 0;\n            --next;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint count_Primes_nums(int n) {\n    int ctr = 0;\n    for (int num = 0; num < n; ++num) {\n        if (num <= 1) {\n            continue;\n        }\n        bool is_prime = true;\n        for (int i = 2; i < num; ++i) {\n            if (num % i == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            ctr++;\n        }\n    }\n    return ctr;\n}\n\n\n\n"], ["#include <atomic>\n#include<iostream>\n#include <utility>\n#include <cassert>\n\nstd::pair<int, int> swap_numbers(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n    return std::make_pair(a, b);\n}\n"], ["\n#include<iostream>\n#include<vector>\n#include<cassert>\n\nint count_odd(const std::vector<int>& array_nums) {\n    int count = 0;\n    for (int num : array_nums) {\n        if (num % 2 != 0) {\n            count += 1;\n        }\n    }\n    return count;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<tuple<int, int>> maximize_elements(const vector<tuple<int, int>>& test_tup1, const vector<tuple<int, int>>& test_tup2) {\n    vector<tuple<int, int>> res;\n    for(size_t i = var_0 ; i < test_tup1.size(); ++i) {\n        int first = max(get<var_1 >(test_tup1[i]), get<var_2 >(test_tup2[i]));\n        res.push_back(make_tuple(first, get<var_1 >(test_tup1[i])));\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\n//函数定义\nint newman_prime(int n) {\n    if (n == 0 || n == 1) {\n        return 1;\n    }\n    int p = 2;\n    while (p * p <= n) {\n        if (n % p == 0) {\n            return p;\n        }\n        p = (p + 1) % n;\n    }\n    return n;\n}\n\n\n\n"], ["\n#include <cstdlib>\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup1) / std::get<0>(test_tup2),\n        std::get<1>(test_tup1) / std::get<1>(test_tup2),\n        std::get<2>(test_tup1) / std::get<2>(test_tup2),\n        std::get<3>(test_tup1) / std::get<3>(test_tup2)\n    );\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\n#include <utility>\nusing namespace std;\n\ntemplate<typename T>\nstd::pair<std::vector<T>, std::vector<T>> split_two_parts(const std::vector<T>& list1, int L) {\n    std::vector<T> first_part(list1.begin(), list1.begin() + L);\n    std::vector<T> second_part(list1.begin() + L, list1.end());\n    return std::make_pair(first_part, second_part);\n}\n\n\n\n"], ["#include <iostream>\n#include <unordered_map>\n#include <cassert>\n\nstd::unordered_map<std::string, int> merge_dict(std::unordered_map<std::string, int> d1, std::unordered_map<std::string, int> d2) {\n    std::unordered_map<std::string, int> d = d1;\n    for (const auto& pair : d2) {\n        d[pair.first] = pair.second;\n    }\n    return d;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cstdlib>\ndouble dog_age(double h_age) {\n    if (h_age < 0) {\n        exit(EXIT_FAILURE);\n    } else if (h_age <= 2) {\n        return 2 * h_age;\n    } else {\n        return 16 + 4 * (h_age - 2);\n    }\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\nusing namespace std;\n\ntemplate <typename T>\nvector<vector<T>> list_split(vector<T> S, int step) {\n    vector<vector<T>> result(step);\n    for (int i = var_0 ; i < step; ++i) {\n        for (int j = i; j < S.size(); j += step) {\n            result[i].push_back(S[j]);\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint lateralsurface_cube(int l) {\n    int LSA = 4 * (l * l);\n    return LSA;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <cassert>\n\nint square_Sum(int n) {\n    return int(3*n*(n+1)*(2*n+1)/6);\n}\n\n\n\n"], ["\n#include <queue>\n#include <iostream>\n#include <cassert>\n\nint find_star_num(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    int star_num = 1;\n    for (int i = 1; i < n; i++) {\n        star_num += 2 * i;\n    }\n    return star_num;\n}\n\n\n\n"], ["#include <thread>\n#include <iostream>\n#include <cassert>\n\nint ascii_value(char k) {\n    return k;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <vector>\n\nint sum_even_and_even_index(const std::vector<int>& arr, int n) {\n    int sum = var_0 ;\n    for (int i = var_1 ; i < n; i += var_2 ) {\n        if (arr[i] % var_3  == var_4 ) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint even_Power_Sum(int n) {\n    int sum = var_0 ;\n    for (int i = var_1 ; i <= n; i++) {\n        sum += i * i * i;\n    }\n    return sum;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\nvector<int> rear_extract(vector<tuple<int, string, int>> test_list) {\n    vector<int> res;\n    for (auto& lis : test_list) {\n        int a, b, c;\n        tie(a, b, c) = lis;\n        res.push_back(a);\n    }\n    return res;\n}\n"], ["\n#include <atomic>\n#include <iostream>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n        std::get<1>(test_tup1) - std::get<1>(test_tup2),\n        std::get<2>(test_tup1) - std::get<2>(test_tup2)\n    );\n}\n\n\n\n"], ["\n#include <mutex>\n#include <cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <functional>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <mutex>\n#include <condition_variable>\n#include <future>\n#include <chrono>\n#include <random>\n#include <"], ["\n#include <stack>\n#include <iostream>\n#include <vector>\n#include <cmath> // for ceil\nusing namespace std;\n\nint get_Position(vector<int>& a, int n, int m) {\n    for (int i = 0; i < n; ++i) {\n        a[i] = (a[i] / m + (a[i] % m != 0));\n    }\n    int result = -1, maxx = -1;\n    for (int i = n - 1; i >= 0; --i) {\n        if (a[i] > maxx) {\n            maxx = a[i];\n            result = i;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <cstdio>\n#include <iostream>\n#include <cassert>\n#include <cmath>\n\ndouble volume_cylinder(double r, double h) {\n    double volume = 3.1415 * r * r * h;\n    return volume;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <map>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nmap<string, int> dict_filter(const map<string, int>& input_dict, int n) {\n    map<string, int> result;\n    for (auto const& pair : input_dict) {\n        if (pair.second >= n) {\n            result[pair.first] = pair.second;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <tuple>\n#include <vector>\n#include <cassert>\n#include <type_traits>\n\ntemplate <size_t Index, typename Tuple>\nint count_first_elements_helper(const Tuple& t, true_type) {\n    return 0;\n}\n\ntemplate <size_t Index, typename Tuple>\nint count_first_elements_helper(const Tuple& t, false_type) {\n    return 0;\n}\n\nint count_first_elements(const tuple<int, int, int>& t) {\n    return count_first_elements_helper<0>(t, is_tuple_v<decltype(t)>);\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <cassert>\n\nint is_num_decagonal(int n) {\n    int decagonal = (3 * n * n - n) / 2;\n    return decagonal;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nbool sequential_search(const std::vector<int>& dlist, int item, int& pos) {\n    pos = var_0 ;\n    while (pos < dlist.size()) {\n        if (dlist[pos] == item) {\n            return true;\n        }\n        pos++;\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool all_unique(const std::vector<int>& test_list) {\n    std::set<int> unique_elements(test_list.begin(), test_list.end());\n    if (test_list.size() > unique_elements.size()) {\n        return false;\n    }\n    return true;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> sub_list(const std::vector<int>& nums1, const std::vector<int>& nums2) {\n    std::vector<int> result;\n    for (size_t i = 0; i < nums1.size(); ++i) {\n        result.push_back(nums1[i] - nums2[i]);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\nbool validate(int n) {\n    for (int i = 0; i < 10; i++) {\n        int temp = n;\n        int count = 0;\n        while (temp) {\n            if (temp % 10 == i) {\n                count++;\n            }\n            temp /= 10;\n        }\n        if (count > i) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (item != element) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n"], ["#include <iostream>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nstring text_match_two_three(const string& text) {\n    regex pattern(\"ab{2,3}\");\n    if (regex_search(text, pattern)) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}\n"], ["#include<iostream>\n#include<vector>\n#include<assert.h>\nusing namespace std;\n\nint max_sub_array_sum_repeated(vector<int> a, int n, int k) {\n    int max_so_far = -2147483648;\n    int max_ending_here = 0;\n    for (int i = 0; i < n * k; ++i) {\n        max_ending_here = max_ending_here + a[i % n];\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n        if (max_ending_here < 0) {\n            max_ending_here = 0;\n        }\n    }\n    return max_so_far;\n}\n\n\n\n"], ["#include<iostream>\n#include <cassert>\n\nint square_Sum(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i * i;\n    }\n    return sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint modular_inverse(const std::vector<int>& arr, int N, int P) {\n    int current_element = var_0 ;\n    for (int i = var_1 ; i < N; ++i) {\n        if ((arr[i] * arr[i]) % P == var_2 ) {\n            current_element = i ;\n        }\n    }\n    return current_element;\n}\n\n\n\n"], ["\n#include<iostream>\n#include <cassert>\n\nint odd_Days(int N) {\n    int hund1 = N / 100;\n    int hund4 = N / 400;\n    int leap = N >> 2;\n    int ordd = N - leap;\n    if (hund1) {\n        ordd += hund1;\n        leap -= hund1;\n    }\n    if (leap) {\n        ordd += leap;\n    }\n    if (ordd % 2 == 1) {\n        return ordd;\n    }\n    return ordd + 1;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nstd::pair<int, std::vector<int>> max_length(const std::vector<std::vector<int>>& list1) {\n    int max_length = 0;\n    std::vector<int> max_list;\n    for (const auto& x : list1) {\n        if (x.size() > max_length) {\n            max_length = x.size();\n            max_list = x;\n        }\n    }\n    return {max_length, max_list};\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\nusing namespace std;\n\nint count_no_of_ways(int n, int k) {\n    vector<int> dp(n + 1, 0);\n    const int mod = 1000000007;\n    dp[1] = k;\n    dp[2] = k * k;\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = (dp[i - 1] + dp[i - 2] * k) % mod;\n    }\n    return dp[n];\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint find(int n, int m) {\n    int q = n / m;\n    return q;\n}\n\n\n\n"], ["\n#include <ctime>\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble otherside_rightangle(double w, double h) {\n    double s = std::sqrt((w * w) + (h * h));\n    return s;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <algorithm>\n#include <limits>\nusing namespace std;\n\nint max_val(const vector<int>& listval) {\n    int max = numeric_limits<int>::min();\n    for (int val : listval) {\n        if (val > max) {\n            max = val;\n        }\n    }\n    return max;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <cassert>\n\nint sum_div(int number) {\n    std::vector<int> divisors = {var_0 };\n    for (int i = var_1 ; i < number; ++i) {\n        if (number % i == var_2 ) {\n            divisors.push_back(i);\n        }\n    }\n    return std::accumulate(divisors.begin(), divisors.end(), 0);\n}\n\n\n\n"], ["#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_Inv_Count(vector<int> arr, int n) {\n    int inv_count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (arr[i] > arr[j]) {\n                inv_count++;\n            }\n        }\n    }\n    return inv_count;\n}\n\n\n\n"], ["#include <vector>\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nclass Variant {\npublic:\n    virtual ~Variant() = default;\n    virtual bool is_int() const = 0;\n    virtual bool is_vector() const = 0;\n    virtual int get_int() const = 0;\n    virtual const vector<Variant*>& get_vector() const = 0;\n};\n\nclass IntVariant : public Variant {\npublic:\n    IntVariant(int value) : value(value) {}\n    bool is_int() const override { return true; }\n    bool is_vector() const override { return false; }\n    int get_int() const override { return value; }\n    const vector<Variant*>& get_vector() const override { throw runtime_error(\"Not a vector\"); }\nprivate:\n    int value;\n};\n\nclass VectorVariant : public Variant {\npublic:\n    VectorVariant(const vector<Variant*>& value) : value(value) {}\n    bool is_int() const override { return false; }\n    bool is_vector() const override { return true; }\n    int get_int() const override { throw runtime_error(\"Not an int\"); }\n    const vector<Variant*>& get_vector() const override { return value; }\nprivate:\n    vector<Variant*> value;\n};\n\nvoid flatten_list(const vector<Variant*>& list1, vector<int>& result_list) {\n    for (const auto& element : list1) {\n        if (element->is_int()) {\n            result_list.push_back(element->get_int());\n        } else if (element->is_vector()) {\n            flatten_list(element->get_vector(), result_list);\n        }\n    }\n}\n"], ["#include <condition_variable>\n#include<iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\ntemplate<typename T>\nvector<vector<T>> intersection_nested_lists(const vector<T>& l1, const vector<vector<T>>& l2) {\n    vector<vector<T>> result;\n    for (const auto& lst : l2) {\n        vector<T> temp;\n        for (const auto& n : lst) {\n            if (find(l1.begin(), l1.end(), n) != l1.end()) {\n                temp.push_back(n);\n            }\n        }\n        result.push_back(temp);\n    }\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <cassert>\nusing namespace std;\n\npair<string, int> max_aggregate(const vector<pair<string, int>>& stdata) {\n    map<string, int> temp;\n    for (const auto& item : stdata) {\n        temp[item.first] += item.second;\n    }\n    pair<string, int> max_item = *temp.begin();\n    for (const auto& item : temp) {\n        if (item.second > max_item.second) {\n            max_item = item;\n        }\n    }\n    return max_item;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <iostream>\n#include <cassert>\ndouble count_binary_seq(int n) {\n    double nCr = 1;\n    double res = 1;\n    for(int r = 1; r <= n; ++r) {\n        nCr *= r;\n        res *= (n-r+1);\n    }\n    return res / nCr;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <unordered_map>\n#include <cassert>\nusing namespace std;\n\nclass Variant {\npublic:\n    virtual ~Variant() = default;\n};\n\nclass IntVariant : public Variant {\npublic:\n    IntVariant(int value) : value(value) {}\n    int get_int() const {\n        return this->value;\n    }\nprivate:\n    int value;\n};\n\nclass MapVariant : public Variant {\npublic:\n    MapVariant(const std::unordered_map<char, Variant*>& map) : map(map) {}\n    const std::unordered_map<char, Variant*>& get_map() const {\n        return this->map;\n    }\nprivate:\n    std::unordered_map<char, Variant*> map;\n};\n\n"], ["\n#include <iostream>\n#include <cassert>\n\n//函数定义\nint set_Bit_Number(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    int msb = 0;\n    while (n != 0) {\n        n = n / 2;\n        msb += 1;\n    }\n    return msb;\n}\n\n\n\n"], ["#include <ctime>\n#include <iostream>\n#include <limits>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nbool solve(int a[], int n) {\n    int mx = numeric_limits<int>::min();\n    for (int j = 1; j < n; j++) {\n        if (mx > a[j]) {\n            return false;\n        }\n        mx = max(mx, a[j]);\n    }\n    return true;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nint find_Element(const std::vector<int>& arr, const std::vector<std::pair<int, int>>& ranges, int rotations, int index) {\n    for (int i = rotations - var_0 ; i >= var_1 ; --i) {\n        int left = ranges[i].first;\n        int right = ranges[i].second;\n        if (left <= index && right >= index) {\n            if (index == left) {\n                index = right;\n            }\n        }\n    }\n    return index;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <regex>\n#include <cassert>\nusing namespace std;\n\npair<string, string> start_withp(vector<string> words) {\n    regex pattern(var_0 );\n    for (const auto &w : words) {\n        smatch match;\n        if (regex_search(w, match, pattern)) {\n            const auto var_1 = 1;\n            const auto var_2 = 2;\n            return {match[var_1 ], match[var_2 ]};\n        }\n    }\n    return {\"\" , \"\"}; // if no adverb found\n}\n\n\n\n"], ["\n#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint max_sum_increasing_subseq(vector<int> a, int n, int index, int k) {\n    vector<vector<int>> dp(n, vector<int>(n, var_0 ));\n    for (int i = var_1 ; i < n; ++i) {\n        const auto var_2 = 0;\n        if (a[i] > a[var_2 ]) {\n            const auto var_3 = 0;\n            if (a[i] > a[var_2 ]) {\n                const auto var_4 = 0;\n                const auto var_5 = 0;\n                dp[var_3 ][i] = a[i] + a[var_4 ];\n            } else {\n                const auto var_6 = 0;\n                const auto var_7 = 0;\n                dp[var_6 ][i] = a[i];\n            }\n        } else {\n            const auto var_8 = 0;\n            dp[var_8 ][i] = a[i];\n        }\n    }\n    for (int i = var_6 ; i < n; ++i) {\n        for (int j = var_7 ; j < n; ++j) {\n            if (a[j] > a[i] && j > i) {\n                const auto var_9 = 0;\n                const auto var_10 = 0;\n                const auto var_11 = 0;\n                const auto var_12 = 0;\n                const auto var_13 = 0;\n                const auto var_14 = 0;\n                const auto var_15 = 0;\n                const auto var_16 = 0;\n                const auto var_17 = 0;\n                const auto var_18 = 0;\n                const auto var_19 = 0;\n                const auto var_20 = 0;\n                const auto var_21 = 0;\n                const auto var_22 = 0;\n                const auto var_23 = 0;\n                const auto var_24 = 0;\n                const auto var_25 = 0;\n                const auto var_26 = 0;\n                const auto var_27 = 0;\n                const auto var_28 = 0;\n                const auto var_29 = 0;\n                const"], ["\n#include <iostream>\n#include <tuple>\n#include <vector>\n#include <cassert>\n\nstd::tuple<std::string, int, std::vector<int>, bool> colon_tuplex(std::tuple<std::string, int, std::vector<int>, bool> tuplex, int m, int n) {\n    std::tuple<std::string, int, std::vector<int>, bool> tuplex_colon = tuplex;\n    std::get<0>(tuplex_colon) = std::get<0>(tuplex) + m;\n    std::get<1>(tuplex_colon) = std::get<1>(tuplex) + n;\n    std::get<2>(tuplex_colon) = std::get<2>(tuplex) + m;\n    std::get<3>(tuplex_colon) = std::get<3>(tuplex) + n;\n    return tuplex_colon;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> large_product(const std::vector<int>& nums1, const std::vector<int>& nums2, int N) {\n    std::vector<int> products;\n    for (int x : nums1) {\n        for (int y : nums2) {\n            products.push_back(x * y);\n        }\n    }\n    std::sort(products.begin(), products.end(), std::greater<int>());\n    return products;\n}\n\n\n\n"], ["#include<iostream>\n    \n#include <assert>\n#include <memory>\n\n//函数定义\nint maximum(int a, int b) {\n    if (a >= b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {   \n        if(!isspace(v))\n        {\n            ret.push_back(v);\n        }\n    }\n    return ret;\n}\n\n\n\n"], ["\n#include <stack>\n#include <cassert>\n#include <iostream>\n\nint set_left_most_unset_bit(int n) {\n    if (!(n & (n + 1))) {\n        return n;\n    }\n    int pos = 0, temp = n, count = 0;\n    while (temp) {\n        if (!(temp & 1)) {\n            pos = count;\n            temp = temp >> 1;\n            count += 1;\n        } else {\n            temp = temp >> 1;\n        }\n    }\n    return n ^ (1 << pos);\n}\n\n\n\n"], ["\n#include <queue>\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble volume_cone(double r, double h) {\n    double volume = (1.0/3) * M_PI * r * r * h;\n    return volume;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> pos_nos(const std::vector<int>& list1) {\n    std::vector<int> result;\n    for (int num : list1) {\n        if (num >= var_0 ) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint max_sum_rectangular_grid(vector<vector<int>>& grid, int n) {\n    int incl = max(grid[var_0 ][var_1 ], grid[var_2 ][var_3 ]);\n    int excl = var_4 ;\n    for (int i = var_5 ; i < n; ++i) {\n        int excl_new = max(excl, incl);\n        incl = max(incl, grid[i][var_0 ] + grid[i][var_1 ] + grid[i][var_2 ] + grid[i][var_3 ]);\n        excl = excl_new;\n    }\n    return incl;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string find_Max_Len_Even(const std::string& str) {\n    int n = str.length();\n    int i = 0;\n    int currlen = 0;\n    int maxlen = 0;\n    int st = -1;\n    while (i < n) {\n        if (str[i] == ' ') {\n            if (currlen % 2 == 0) {\n                if (maxlen < currlen) {\n                    maxlen = currlen;\n                    st = i - currlen;\n                }\n            }\n            currlen = 0;\n        } else {\n            currlen++;\n        }\n        i++;\n    }\n    if (currlen % 2 == 0) {\n        if (maxlen < currlen) {\n            maxlen = currlen;\n            st = i - currlen;\n        }\n    }\n    return str.substr(st, maxlen);\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_last_occurrence(const std::vector<int>& A, int x) {\n    int left = 0;\n    int right = A.size() - 1;\n    int result = -1;\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (x == A[mid]) {\n            result = mid;\n            right = mid - 1;\n        } else if (x < A[mid]) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include <stack>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n// 基类\nclass Element {\npublic:\n    virtual ~Element() = default;\n    virtual Element* clone() const = 0;\n    virtual void print() const = 0;\n    virtual bool isSameType(const Element& other) const = 0;\n    virtual bool isInt() const = 0;\n    virtual bool isChar() const = 0;\n    virtual int getIntValue() const = 0;\n    virtual char getCharValue() const = 0;\n};\n// 处理 char 类型的子类\nclass CharElement : public Element {\npublic:\n    CharElement(char value) : value_(value) {}\n    Element* clone() const override {\n        return new CharElement(*this);\n    }\n    void print() const override {\n        std::cout << \"Char: \" << value_ << std::endl;\n    }\n    bool isSameType(const Element& other) const override {\n        return other.isChar();\n    }\n    bool isInt() const override { return false; }\n    bool isChar() const override { return true; }\n    int getIntValue() const override {\n         return 0; \n    }\n    char getCharValue() const override { return value_; }\nprivate:\n    char value_;\n};\n// 处理 int 类型的子类\nclass IntElement : public Element {\npublic:\n    IntElement(int value) : value_(value) {}\n    Element* clone() const override {\n        return new IntElement(*this);\n    }\n    void print() const override {\n        std::cout << \"Int: \" << value_ << std::endl;\n    }\n    bool isSameType(const Element& other) const override {\n        return other.isInt();\n    }\n    bool isInt() const override { return true; }\n    bool isChar() const override { return false; }\n    int getIntValue() const override { return value_; }\n    char getCharValue() const override { \n//begin to write code\n"], ["\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint max_volume(int s) {\n    int maxvalue = 0;\n    for(int i = 1; i < s; ++i) {\n        for(int j = 1; j < s; ++j) {\n            int k = s - i - j;\n            double temp_var_6 = 9.9;\n            temp_var_6 = temp_var_6 - (i * i * i + j * j * j + k * k * k);\n            if(temp_var_6 > maxvalue) {\n                maxvalue = temp_var_6;\n            }\n        }\n    }\n    return maxvalue;\n}\n\n\n\n"], ["#include <iostream>\n#include <regex>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<string> find_long_word(const string& text) {\n    regex word_regex(R\"(\\b\\w{5}\\b)\");\n    vector<string> words;\n    auto words_begin = sregex_iterator(text.begin(), text.end(), word_regex);\n    auto words_end = sregex_iterator();\n\n    for (sregex_iterator i = words_begin; i != words_end; ++i) {\n        words.push_back((*i).str());\n    }\n    return words;\n}\n"], ["\n#include <iostream>\n#include <cassert>\n\nint sum_difference(int n) {\n    int sumofsquares = 0;\n    int squareofsum = 0;\n    for (int num = 1; num <= n; num++) {\n        sumofsquares += num * num;\n        squareofsum += num;\n    }\n    return squareofsum * squareofsum - sumofsquares;\n}\n\n\n\n"], ["\n\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string find_demlo(const std::string& s) {\n    int l = s.size();\n    std::string res = \"\";\n    for (int i = 1; i <= l; ++i) {\n        res += std::to_string(i);\n        if (res.size() == 3) {\n            res = res.substr(1, 2);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string(i);\n            res += std::to_string"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> position_min(const std::vector<int>& list1) {\n    int min_val = *std::min_element(list1.begin(), list1.end());\n    std::vector<int> min_result;\n    for (int i = 0; i < list1.size(); i++) {\n        if (list1[i] == min_val) {\n            min_result.push_back(i);\n        }\n    }\n    return min_result;\n}\n\n\n\n"], ["\n#include <fstream>\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nvoid right_rotate(std::vector<int>& arr, int n, int out_of_place, int cur) {\n    int temp = arr[cur];\n    for (int i = cur; i > out_of_place; --i) {\n        arr[i] = arr[i - 1];\n    }\n    arr[out_of_place] = temp;\n}\nstd::vector<int> re_arrange(std::vector<int>& arr, int n) {\n    int out_of_place = -1;\n    for (int index = 0; index < n; ++index) {\n        if (out_of_place >= 0) {\n            if ((arr[index] >= 0 && arr[out_of_place] < 0) ||\n                (arr[index] < 0 && arr[out_of_place] >= 0)) {\n                right_rotate(arr, n, out_of_place, index);\n                if (index - out_of_place > 2) {\n                    out_of_place = index;\n                }\n            }\n        }\n    }\n    return arr;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::pair<int, int> sum_of_alternates(const std::vector<int>& test_vector) {\n    int sum1 = 0;\n    int sum2 = 0;\n    for (size_t idx = 0; idx < test_vector.size(); ++idx) {\n        if (idx % 2 == 1) {\n            sum1 += test_vector[idx];\n        } else {\n            sum2 += test_vector[idx];\n        }\n    }\n    return std::make_pair(sum1, sum2);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n\nint get_Min_Squares(int n) {\n    if (n <= 3) {\n        return n;\n    }\n    int res = n;\n    for (int x = 1; x <= n; ++x) {\n        int temp = x * x;\n        if (temp < res) {\n            res = temp;\n        }\n    }\n    return res;\n}\n\n\n\n"], ["#include<iostream>\n#include <sstream>\n#include <unordered_map>\n#include <cassert>\n#include <vector>\nusing namespace std;\n\nstring most_occurrences(vector<string> test_list) {\n    unordered_map<string, int> temp;\n    for (auto& sub : test_list) {\n        stringstream ss(sub);\n        string wrd;\n        while (ss >> wrd) {\n            temp[wrd]++;\n        }\n    }\n    int max = 0;\n    string max_wrd;\n    for (auto& item : temp) {\n        if (item.second > max) {\n            max = item.second;\n            max_wrd = item.first;\n        }\n    }\n    return max_wrd;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nbool check_isosceles(int x, int y, int z) {\n    if (x == y || y == z || z == x) {\n        return true;\n    }\n    return false;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<int> rotate_left(vector<int> list1, int m, int n) {\n    vector<int> result;\n    result.insert(result.end(), list1.begin() + m, list1.end());\n    return result;\n}\n\n\n\n"], ["\n#include<iostream>\n#include<vector>\n#include<cassert>\nint neg_count(const std::vector<int>& list) {\n    int neg_count = 0;\n    for (int num : list) {\n        if (num <= 0) {\n            neg_count++;\n        }\n    }\n    return neg_count;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <vector>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nvector<string> find_char(const string& text) {\n    regex word_regex(R\"(\\b\\w{3,5}\\b)\");\n    auto words_begin = sregex_iterator(text.begin(), text.end(), word_regex);\n    auto words_end = sregex_iterator();\n    vector<string> matches;\n    for (sregex_iterator i = words_begin; i != words_end; ++i) {\n        string match = i->str();\n        matches.push_back(match);\n    }\n    return matches;\n}\n"], ["\n#include <iostream>\n#include <cassert>\n\nint count_unset_bits(int n) {\n    int count = 0;\n    int x = 1;\n    while(x < n + 1) {\n        if ((x & n) == 0) {\n            count += 1;\n        }\n        x += 1;\n    }\n    return count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <map>\n#include <cassert>\n\nstd::map<char, int> char_frequency(std::string str1) {\n    std::map<char, int> dict;\n    for (char n : str1) {\n        if (dict.find(n) != dict.end()) {\n            dict[n] += 1;\n        } else {\n            dict[n] = 1;\n        }\n    }\n    return dict;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvoid Sort(vector<pair<string, int>>& sub_li) {\n    sort(sub_li.begin(), sub_li.end(), [](const pair<string, int>& a, const pair<string, int>& b) {\n        return a.second < b.second;\n    });\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool check_Validity(int a, int b, int c) {\n    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint ap_sum(int a, int n, int d) {\n    int total = (n * (a + (n - d) * d)) / 2;\n    return total;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\nbool check_monthnum(std::string monthname1) {\n    if (monthname1 == \"February\") {\n        return true;\n    }\n    return false;\n}\n\n\n\n"], ["#include <iostream>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nstring text_match_word(string text) {\n    regex pattern(\"\\\\\\w+\\\\\\S*$\");\n    if (regex_search(text, pattern)) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}\n"], ["#include<iostream>\n#include<string>\n#include<algorithm>\n#include<assert.h>\nbool check_Equality(const std::string& s) {\n    return s.front() == s.back();\n}\nint count_Substring_With_Equal_Ends(const std::string& s) {\n    int result = var_0 ;\n    int n = s.length();\n    for (int i = var_1 ; i < n; ++i) {\n        if (check_Equality(s.substr(i, 1))) {\n            result++;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <cstdlib>\n#include<iostream>\n#include <cassert>\n\nint find_Divisor(int x, int y) {\n    if (x == y) {\n        return x;\n    } else {\n        return -1; // use -1 to represent None\n    }\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint sum_three_smallest_nums(std::vector<int> lst) {\n    std::vector<int> positive_nums;\n    for (int x : lst) {\n        if (x > 0) {\n            positive_nums.push_back(x);\n        }\n    }\n    std::sort(positive_nums.begin(), positive_nums.end());\n    return positive_nums[0] + positive_nums[1] + positive_nums[2];\n}\n\n\n\n"], ["#include<iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<int> set_to_tuple(const set<int>& s) {\n    vector<int> t(s.begin(), s.end());\n    return t;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <cassert>\nusing namespace std;\n\nclass Node {\npublic:\n    int value;\n    int list_num;\n    int index;\n    Node(int value, int list_num, int index) : value(value), list_num(list_num), index(index) {}\n    bool operator<(const Node& other) const {\n        return value > other.value; \n    }\n};\n\npair<int, int> find_minimum_range(vector<vector<int>>& lists) {\n    int high = numeric_limits<int>::min();\n    pair<int, int> p = make_pair(0, numeric_limits<int>::max());\n    priority_queue<Node> pq;\n    for (int i = 0; i < lists.size(); ++i) {\n        pq.push(Node(lists[i][0], i, 0));\n        high = max(high, lists[i][0]);\n    }\n    while (!pq.empty()) {\n        Node top = pq.top();\n        pq.pop();\n        if (top.list_num == p.first && top.index < p.second) {\n            p = make_pair(top.list_num, top.index);\n        } else if (top.list_num < p.first) {\n            p = make_pair(top.list_num, top.index);\n        }\n        if (top.list_num < lists.size() - 1) {\n            pq.push(Node(lists[top.list_num + 1][top.index], top.list_num + 1, top.index + 1));\n        }\n    }\n    return p;\n}\n"], ["\n#include <iostream>\n#include <cctype>\n#include <cassert>\n\nstd::pair<int, int> dig_let(const std::string& s) {\n    int d = 0, l = 0;\n    for (char c : s) {\n        if (isdigit(c)) {\n            d++;\n        } else {\n            l++;\n        }\n    }\n    return std::make_pair(d, l);\n}\n\n\n\n"], ["#include<iostream>\n#include <cmath>\n#include <cassert>\n\nint count_Odd_Squares(int n, int m) {\n    int count = 0;\n    for (int i = n; i <= m; i++) {\n        if (i % 2 != 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\n\n\n"], ["#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<assert.h>\nusing namespace std;\n\nvector<int> diff_consecutivenums(const vector<int>& nums) {\n    vector<int> result;\n    for (int i = 1; i < nums.size(); i++) {\n        result.push_back(nums[i] - nums[i - 1]);\n    }\n    return result;\n}\n\n\n\n"], ["\n\n#include <iostream>\n#include <cassert>\n\nint zigzag(int n, int k) {\n    if (n == var_0  && k == var_1 ) {\n        const auto var_2 = 1;\n        return var_2 ;\n    }\n    if (n == var_0  && k == var_2 ) {\n        const auto var_3 = 1;\n        return var_3 ;\n    }\n    if (n == var_0  && k == var_3 ) {\n        const auto var_4 = 1;\n        return var_4 ;\n    }\n    if (n == var_0  && k == var_4 ) {\n        const auto var_5 = 1;\n        return var_5 ;\n    }\n    if (n == var_0  && k == var_5 ) {\n        const auto var_6 = 1;\n        return var_6 ;\n    }\n    if (n == var_0  && k == var_6 ) {\n        const auto var_7 = 1;\n        return var_7 ;\n    }\n    if (n == var_0  && k == var_7 ) {\n        const auto var_8 = 1;\n        return var_8 ;\n    }\n    if (n == var_0  && k == var_8 ) {\n        const auto var_9 = 1;\n        return var_9 ;\n    }\n    if (n == var_0  && k == var_9 ) {\n        const auto var_10 = 1;\n        return var_10 ;\n    }\n    if (n == var_0  && k == var_10 ) {\n        const auto var_11 = 1;\n        return var_11 ;\n    }\n    if (n == var_0  && k == var_11 ) {\n        const auto var_12 = 1;\n        return var_12 ;\n    }\n    if (n == var_0  && k == var_12 ) {\n        const auto var_13 = 1;\n        return var_13 ;\n    }\n    if (n == var_0  && k == var_13 ) {\n        const auto var_14 = 1;\n        return var_14 ;\n    }\n    if (n == var_0  && k == var_14 ) {\n        const auto var"], ["\n#include <cmath>\n#include <iostream>\n#include <cassert>\n\nint count_Squares(int m, int n) {\n    if (n < m) {\n        int temp = m;\n        m = n;\n        return count_Squares(n, m);\n    } else {\n        return (m * m) - (n * n);\n    }\n}\n\n\n\n"], ["\n\n#include <iostream>\n#include <cassert>\n\nint bin_coff(int n, int r) {\n    int val = 1;\n    if (r > (n - r)) {\n        r = n - r;\n    }\n    for (int i = 0; i < r; ++i) {\n        val *= (n - i);\n        val /= (i + 1);\n    }\n    return val;\n}\n\n"], ["\n#include <iostream>\n#include <string>\n#include <set>\n#include <iostream>\n#include <cassert>\n#include <algorithm>\n\nstd::string check(const std::string& string) {\n    std::set<char> p(string.begin(), string.end());\n    std::set<char> s = {'0', '1'};\n    if (s == p || p == std::set<char>{'0'} || p == std::set<char>{'1'}) {\n        return \"binary\";\n    } else {\n        return \"not binary\";\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nint minimum_Length(std::string s) {\n    int maxOcc = 0;\n    int n = s.length();\n    std::vector<int> arr(26, 0);\n    for (int i = 0; i < n; i++) {\n        arr[s[i] - 'a']++;\n    }\n    for (int i = 0; i < 26; i++) {\n        if (arr[i] > maxOcc) maxOcc = arr[i];\n    }\n    int minLen = n;\n    for (int i = 0; i < 26; i++) {\n        if (arr[i] == maxOcc) {\n            minLen = std::min(minLen, n - (i + 1) * maxOcc);\n        }\n    }\n    return minLen;\n}\n\n\n\n"], ["\n#include <queue>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nint first_Element(const std::vector<int>& arr, int n, int k) {\n    std::map<int, int> count_map;\n    for (int i = 0; i < n; ++i) {\n        if (count_map.find(arr[i]) != count_map.end()) {\n            count_map[arr[i]] += 1;\n        } else {\n            count_map[arr[i]] = 1;\n        }\n    }\n    for (auto it = count_map.begin(); it != count_map.end(); ++it) {\n        if (it->second == k) {\n            return it->first;\n        }\n    }\n    return -1;\n}\n\n\n\n"], ["#include <stack>\n#include <iostream>\n#include <string>\n#include <cassert>\nbool unique_Characters(std::string str) {\n    std::stack<char> s;\n    for (int i = 0; i < str.length(); i++) {\n        if (s.empty()) {\n            s.push(str[i]);\n        } else {\n            if (s.top() == str[i]) {\n                return false;\n            } else {\n                s.push(str[i]);\n            }\n        }\n    }\n    return true;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<std::vector<int>> remove_column(std::vector<std::vector<int>>& list1, int n) {\n    for (auto& row : list1) {\n        row.erase(row.begin() + n);\n    }\n    return list1;\n}\n\n\n\n"], ["#include <cstdio>\n#include <iostream>\n#include <cassert>\n//函数定义\nint tn_ap(int a, int n, int d) {\n    int tn = a + (n - 1) * d;\n    return tn;\n}\n\n\n\n"], ["\n#include <condition_variable>\n#include <iostream>\n#include <cassert>\n\nint count_Rectangles(int radius) {\n    int rectangles = 0;\n    int diameter = 2 * radius;\n    int diameterSquare = diameter * diameter;\n    for (int a = 1; a < 2 * radius; a++) {\n        for (int b = 1; b < 2 * radius; b++) {\n            int diagnalLengthSquare = (a * a + b * b);\n            if (diagnalLengthSquare == diameterSquare) {\n                rectangles += 1;\n            }\n        }\n    }\n    return rectangles;\n}\n\n\n\n"], ["#include<iostream>\n#include <cassert>\n\n//函数定义\nint find_angle(int a, int b) {\n    int angle = 180 * (a + b) / (a + b + c);\n    return angle;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nint find_max(const std::vector<std::vector<int>>& test_list) {\n    int res = 0;\n    for (const auto& sublist : test_list) {\n        for (int num : sublist) {\n            res = std::max(res, num);\n        }\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <map>\n\nstd::vector<int> moddiv_list(const std::vector<int>& nums1, const std::vector<int>& nums2) {\n    std::map<int, int> result;\n    for (size_t i = 0; i < nums1.size(); ++i) {\n        result[nums1[i]] = nums2[i] % nums1[i];\n    }\n    return result;\n}\n\n\n\n"], ["#include<iostream>\n#include<string>\n#include<cassert>\nstd::string Check_Solution(int a, int b, int c) {\n    if (2 * b * b == 9 * a * c) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nlong long get_carol(int n) {\n    long long result = pow(2, n) - 1;\n    return result;\n}\n\n\n\n"], ["\n#include <condition_variable>\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\n\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    condition_variable cv;\n    unique_lock<mutex> lck(m);\n    for (auto& item : list1) {\n        if (!item.empty()) {\n            unique_lock<mutex> lck2(m);\n            result.push_back(item);\n        }\n    }\n    cv.notify_all();\n    return result;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nint max_occurrences(vector<int> nums) {\n    int max_val = var_0 ;\n    int result = nums[var_1 ];\n    for (int i : nums) {\n        int occu = count(nums.begin(), nums.end(), i);\n        if (occu > max_val) {\n            max_val = occu;\n            result = i;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include <iomanip>\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\nvector<tuple<int, int, int>> add_K_element(vector<tuple<int, int, int>> test_list, int K) {\n    vector<tuple<int, int, int>> res;\n    for (auto &sub : test_list) {\n        int a, b, c;\n        tie(a, b, c) = sub;\n        res.push_back(make_tuple(a + K, b + K, c + K));\n    }\n    return res;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <string>\n#include <cassert>\nusing namespace std;\n\nchar make_flip(char ch) {\n    return ch == '0' ? '1' : '0';\n    []() {std::cout << \"This function is used to remove a item of a list\" << std::endl;};\n}\nint get_flip_with_starting_charcter(string str, char expected) {\n    int flip_count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        if (str[i] != expected) {\n            flip_count++;\n            str[i] = make_flip(str[i]);\n        }\n    }\n    return flip_count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint count_Digit(int n) {\n    int count = 0;\n    while (n != 0) {\n        n /= 10;\n        count++;\n    }\n    return count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <climits>\nusing namespace std;\n\nint adjacent_num_product(const vector<int>& list_nums) {\n    int max_product = INT_MIN;\n    for (size_t i = 0; i < list_nums.size() - 1; ++i) {\n        int product = list_nums[i] * list_nums[i + 1];\n        max_product = max(max_product, product);\n    }\n    return max_product;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int value) : data(value), left(nullptr), right(nullptr) {}\n};\n\nint get_height(Node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return max(get_height(root->left), get_height(root->right)) + 1;\n}\n\n"], ["#include<iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\nvector<tuple<int, int>> repeat_tuples(tuple<int, int> test_tup, int N) {\n    vector<tuple<int, int>> res(N, test_tup);\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint lateralsurface_cuboid(int l, int w, int h) {\n    int LSA = 2 * h * (l + w);\n    return LSA;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n    });\n    return items;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint smallest_missing(const std::vector<int>& A, int left_element, int right_element) {\n    if (left_element > right_element) {\n        return left_element;\n    }\n    int mid = left_element + (right_element - left_element) / var_0 ;\n    if (A[mid] == mid) {\n        return smallest_missing(A, mid + 1, right_element);\n    } else {\n        return mid;\n    }\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<int> heap_assending(vector<int> nums) {\n    make_heap(nums.begin(), nums.end());\n    return nums;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n#include <assert.h>\n\n//函数定义\nint volume_cuboid(int l, int w, int h) {\n    int volume = l * w * h;\n    return volume;\n}\n\n\n\n"], ["#include <mutex>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<string> permute_string(string str) {\n    if (str.length() == 0) {\n        return vector<string> {\"\"};\n    }\n    vector<string> prev_list = permute_string(str.substr(1));\n    vector<string> next_list;\n    for (int i = 0; i < prev_list.size(); i++) {\n        for (size_t j = 0; j <= str.length() - 1; j++) {\n            string temp = prev_list[i];\n            temp.push_back(str[j]);\n            next_list.push_back(temp);\n        }\n    }\n    return next_list;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint round_num(int n, int m) {\n    int a = (n / m) * m;\n    return a;\n}\n\n\n\n"], ["\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <tuple>\n#include <cassert>\n#include <typeinfo>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\nclass Element {\npublic:\n    virtual ~Element() = default;\n    virtual bool is_int() const = 0;\n    virtual bool is_string() const = 0;\n    virtual int get_int() const = 0;\n    virtual string get_string() const = 0;\n};\n\n// 派生类 IntElement\nclass IntElement : public Element {\npublic:\n    IntElement(int value) : value_(value) {}\n    bool is_int() const override {\n        return true;\n    }\n    bool is_string() const override {\n        return false;\n    }\n    int get_int() const override {\n        return value_;\n    }\n    string get_string() const override {\n        throw runtime_error(\"Not a string\");\n    }\nprivate:\n    int value_;\n};\n\n// 派生类 StringElement\nclass StringElement : public Element {\npublic:\n    StringElement(const string& value) : value_(value) {}\n    bool is_int() const override {\n        return false;\n    }\n    bool is_string() const override {\n        return true;\n    }\n    int get_int() const override {\n        throw runtime_error(\"Not an integer\");\n    }\n    string get_string() const override {\n        return value_;\n    }\nprivate:\n    string value_;\n};\n\nstruct ElementComparator {\n    bool operator()(const Element* lhs, const Element* rhs) const {\n        if (lhs->is_int() && rhs->is_int()) {\n            return lhs->get_int() < rhs->get_int();\n        } else if (lhs->is_string() && rhs->is_string()) {\n            return lhs->get_string() < rhs->get_string();\n        } else {\n            return false;\n        }\n    }\n};\n\n"], ["#include<cassert>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string remove_Char(std::string s, char c) {\n    s.erase(std::remove(s.begin(), s.end(), c), s.end());\n    return s;\n}\n\n\n\n"], ["\n#include <vector>\n#include <cassert>\n#include <iostream>\n\nstd::vector<int> move_first(std::vector<int> test_list) {\n    if (!test_list.empty()) {\n        int last = test_list.back();\n        test_list.pop_back();\n        test_list.insert(test_list.begin(), last);\n    }\n    return test_list;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <assert.h>\n\nint surfacearea_cuboid(int l, int w, int h) {\n    int SA = 2 * (l * w + l * h + w * h);\n    return SA;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<vector<int>> multi_list(int rownum, int colnum) {\n    vector<vector<int>> multi_list(rownum, vector<int>(colnum, var_0 ));\n    for (int row = var_1 ; row < rownum; ++row) {\n        for (int col = var_2 ; col < colnum; ++col) {\n            multi_list[row][col] = var_0;\n        }\n    }\n    return multi_list;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<TupleType> index_on_inner_list(vector<TupleType> list_data, int index_no) {\n    sort(list_data.begin(), list_data.end(), [index_no](const TupleType &a, const TupleType &b) {\n        if (index_no == 0) return get<0>(a) < get<0>(b);\n        if (index_no == 1) return get<1>(a) < get<1>(b);\n        if (index_no == 2) return get<2>(a) < get<2>(b);\n    });\n    return list_data;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <mutex>\nusing namespace std;\n\nint find_rotation_count(const vector<int>& A) {\n    int left = 0, right = A.size() - 1;\n    while (left <= right) {\n        if (A[left] <= A[right]) {\n            return left;\n        }\n        int mid = (left + right) / 2;\n        int next = (mid + 1) % A.size();\n        int prev = (mid - 1 + A.size()) % A.size();\n        if (A[mid] <= A[next] && A[mid] <= A[prev]) {\n            return mid;\n        }\n        if (A[mid] <= A[right]) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return -1;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint even_bit_toggle_number(int n) {\n    int res = var_0 , count = var_1 , temp = n;\n    while(temp > var_2 ) {\n        if (count % var_3  == var_4 ) {\n            res = res | (var_5  << count);\n            count++;\n        }\n        else {\n            count = var_1;\n        }\n        temp = temp >> 1;\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint frequency_Of_Smallest(int n, std::vector<int> arr) {\n    int mn = arr[0];\n    int freq = 1;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < mn) {\n            mn = arr[i];\n            freq = 1;\n        } else if (arr[i] == mn) {\n            freq++;\n        }\n    }\n    return freq;\n}\n\n\n\n"], ["\n#include <mutex>\n#include <iostream>\n#include <cassert>\n\n// 函数定义\nint get_perrin(int n) {\n    if (n == 0) {\n        return 3;\n    }\n    if (n == 1) {\n        return 1;\n    }\n    return get_perrin(n - 1) + get_perrin(n - 2);\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\nint swap_count(const std::string& s) {\n    const char* chars = s.c_str();\n    int count_left = 0;\n    int count_right = 0;\n    int swap = 0;\n    int imbalance = 0; \n    for (size_t i = 0; i < s.length(); i++) {\n        if (chars[i] == '[') {\n            count_left += 1;\n            if (imbalance > 0) {\n                swap += 1;\n                imbalance -= 1;\n            }\n        } else if (chars[i] == ']') {\n            count_right += 1;\n            if (imbalance < 0) {\n                swap += 1;\n                imbalance += 1;\n            }\n        }\n    }\n    return swap;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string even_or_odd(const std::string& N) {\n    int l = N.length();\n    char last_char = N[l - 1];\n    if (last_char == '0' || last_char == '2' ||\n        last_char == '4' || last_char == '6' ||\n        last_char == '8' || last_char == 'A' ||\n        last_char == 'C' || last_char == 'E' ||\n        last_char == 'G' || last_char == 'I' ||\n        last_char == 'M' || last_char == 'O' ||\n        last_char == 'Q' || last_char == 'U' ||\n        last_char == 'W' || last_char == 'Y') {\n        return \"even\";\n    } else {\n        return \"odd\";\n    }\n}\n\n\n\n"], ["#include <fstream>\n#include <cassert>\n#include <iostream>\n\nint highest_Power_of_2(int n) {\n    int res = 0;\n    for (int i = n; i > 0; i--) {\n        if ((i & (i - 1)) == 0) {\n            res = i;\n            break;\n        }\n    }\n    return res;\n}\n\n\n\n"], ["\n\n#include <iostream>\n#include <cassert>\n\nint find_lucas(int n) {\n    if (n == 0) {\n        return 2;\n    }\n    int a = 2;\n    int b = 1;\n    int c = 1;\n    int d = 1;\n    int e = 1;\n    int f = 1;\n    int g = 1;\n    int h = 1;\n    int i = 1;\n    int j = 1;\n    int k = 1;\n    int l = 1;\n    int m = 1;\n    int n = 1;\n    int o = 1;\n    int p = 1;\n    int q = 1;\n    int r = 1;\n    int s = 1;\n    int t = 1;\n    int u = 1;\n    int v = 1;\n    int w = 1;\n    int x = 1;\n    int y = 1;\n    int z = 1;\n    int a = 2;\n    int b = 1;\n    int c = 1;\n    int d = 1;\n    int e = 1;\n    int f = 1;\n    int g = 1;\n    int h = 1;\n    int i = 1;\n    int j = 1;\n    int k = 1;\n    int l = 1;\n    int m = 1;\n    int n = 1;\n    int o = 1;\n    int p = 1;\n    int q = 1;\n    int r = 1;\n    int s = 1;\n    int t = 1;\n    int u = 1;\n    int v = 1;\n    int w = 1;\n    int x = 1;\n    int y = 1;\n    int z = 1;\n    int a = 2;\n    int b = 1;\n    int c = 1;\n    int d = 1;\n    int e = 1;\n    int f = 1;\n    int g = 1;\n    int h = 1;\n    int i = 1;\n    int j = 1;\n    int k = 1;\n    int l = 1;\n    int m = 1;\n    int n = 1;\n    int o = 1;\n    int p = 1;\n   "], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\ntemplate <typename T>\nstd::vector<std::string> add_string(const std::vector<T>& list, const std::string& format) {\n    std::vector<std::string> result;\n    for (const auto& item : list) {\n        result.push_back(format + \" \" + std::to_string(item));\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <cassert>\n\nstd::vector<std::map<std::string, std::map<std::string, int>>> convert_list_dictionary(const std::vector<std::string> &l1, const std::vector<std::string> &l2, const std::vector<int> &l3) {\n    std::vector<std::map<std::string, std::map<std::string, int>>> result;\n    for (size_t i = 0; i < l1.size(); ++i) {\n        std::map<std::string, std::map<std::string, int>> temp;\n        for (size_t j = 0; j < l2.size(); ++j) {\n            temp[l1[i]] = l2[j];\n        }\n        for (size_t j = 0; j < l3.size(); ++j) {\n            temp[l1[i]][l2[j]] = l3[j];\n        }\n        result.push_back(temp);\n    }\n    return result;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint get_max_sum(int n) {\n    std::vector<int> res;\n    res.push_back(0);\n    res.push_back(1);\n    for (int i = 2; i <= n; ++i) {\n        res.push_back(max(res[i / 2] + res[i / 3] + res[i / 4] + res[i / 5], i));\n    }\n    return res[n];\n}\n\n\n\n"], ["#include <vector>\n#include <iostream>\n#include <cassert>\n#include <algorithm>\n\nstd::pair<int, std::vector<int>> max_length_list(const std::vector<std::vector<int>>& input_list) {\n    int max_length = 0;\n    std::vector<int> max_list;\n    for (const auto& vec : input_list) {\n        if (vec.size() > max_length) {\n            max_length = vec.size();\n            max_list = vec;\n        }\n    }\n    return {max_length, max_list};\n}\n\n\n\n"], ["#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\n\nbool check_distinct(std::vector<int> test_vec) {\n    std::set<int> temp;\n    for (int ele : test_vec) {\n        if (temp.find(ele) != temp.end()) {\n            return false;\n        }\n        temp.insert(ele);\n    }\n    return true;\n}\n\n\n\n"], ["#include <fstream>\n#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <cassert>\n\nchar first_non_repeating_character(const std::string& str1) {\n    std::vector<char> char_order;\n    std::map<char, int> ctr;\n    for (char c : str1) {\n        if (ctr.find(c) != ctr.end()) {\n            ctr[c] += 1;\n        } else {\n            ctr[c] = 1;\n            char_order.push_back(c);\n        }\n    }\n    for (char c : char_order) {\n        if (ctr[c] == 1) {\n            return c;\n        }\n    }\n    return '\\0';\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <regex>\n#include <cassert>\nusing namespace std;\n\nstring check_char(string str) {\n    int p1 = var_0 ;\n    int p2 = str.size() -var_1  ;\n    if(str[p1] == str[p2])\n    return \"true\";\n    else\n    return \"false\";\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint median_numbers(int a, int b, int c) {\n    int median;\n    if (a > b) {\n        if (a < c) {\n            median = a;\n        } else if (b > c) {\n            median = b;\n        } else {\n            median = c;\n        }\n    } else {\n        if (a < c) {\n            median = a;\n        } else if (b > c) {\n            median = b;\n        } else {\n            median = c;\n        }\n    }\n    return median;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <cctype>\n\nint sum_of_digits(vector<int> nums) {\n    int result = 0;\n    for (int n : nums) {\n        string numStr = to_string(n);\n        for (char c : numStr) {\n            if (isdigit(c)) {\n                result += c - '0';\n            }\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, int, int> bitwise_xor(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup1) ^ std::get<0>(test_tup2),\n        std::get<1>(test_tup1) ^ std::get<1>(test_tup2),\n        std::get<2>(test_tup1) ^ std::get<2>(test_tup2),\n        std::get<3>(test_tup1) ^ std::get<3>(test_tup2)\n    );\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <cassert>\n\nint extract_freq(const std::vector<std::pair<int, int>>& test_list) {\n    std::set<std::pair<int, int>> unique_tuples;\n    for (const auto& sub : test_list) {\n        if (sub.first <= sub.second) {\n            unique_tuples.insert(sub);\n        }\n    }\n\n    std::set<int> freq;\n    for (const auto& sub : unique_tuples) {\n        freq.insert(sub.first);\n    }\n\n    int res = 0;\n    for (const auto& ele : freq) {\n        res += ele;\n    }\n    return res;\n}\n\n\n\n"], ["#include<iostream>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\ntuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> add_nested_tuples(\n    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> test_tup1,\n    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> test_tup2) \n{\n    tuple<int, int> res1 = make_tuple(get<0>(get<0>(test_tup1)) + get<0>(get<0>(test_tup2)), get<1>(get<0>(test_tup1)) + get<1>(get<0>(test_tup2)));\n    return res1;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nint ncr_modp(int n, int r, int p) {\n    std::vector<int> C(r + 1, 0);\n    C[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = std::min(i, r); j > 0; --j) {\n            C[j] = (C[j] + C[j - 1]) % p;\n        }\n    }\n    return C[r];\n}\n\n\n\n"], ["\n#include<iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\n\nbool is_valid_URL(string url) {\n    regex pattern(\"((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)\");\n    if (url.empty()) {\n        return false;\n    }\n    return regex_match(url, pattern);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint minimum(int a, int b) {\n    if (a <= b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n\n\n"], ["#include <set>\n#include <iostream>\n#include <tuple>\n#include <type_traits>\n#include <cstddef>\n#include <cassert>\nusing namespace std;\n\nusing MyTuple = tuple<char, int, char, char, char, char, char, char, char, char>;\n\ntemplate<typename T, size_t I = 0>\nbool check_tuplex(const MyTuple& t, const T& value) {\n    if constexpr (I == tuple_size<MyTuple>::value) {\n        return false;\n    } else {\n        return t[I] == value;\n    }\n}\n"], ["#include<cassert>\n#include <iostream>\n#include <string>\nstd::string find_Parity(unsigned int x) {\n    unsigned int y = x ^ (x >> 1);\n    y = y ^ (y >> 2);\n    y = y ^ (y >> 4);\n    y = y ^ (y >> 8);\n    return std::to_string(y);\n}\n\n\n\n"], ["#include <memory>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nint rearrange_bigger(int n) {\n    string nums = to_string(n);\n    for (int i = nums.size() - 2; i >= 0; --i) {\n        if (nums[i] < nums[i+1]) {\n            string z = nums.substr(i);\n            char y = *min_element(z.begin() + 1, z.end(), [first = z[0]](char a, char b) { return a > first && (b > first ? a < b : true); });\n            z.erase(remove(z.begin(), z.end(), y), z.end());\n            return stoi(z);\n        }\n    }\n    return n;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <iostream>\nusing namespace std;\n\nvector<vector<int>> k_smallest_pairs(vector<int>& nums1, vector<int>& nums2, int k) {\n    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> pq(comp);\n    vector<vector<int>> res;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            if (pq.size() < k) {\n                pq.push({i, j});\n            }\n            else if (nums1[pq.top().first] + nums2[pq.top().second] > nums1[i] + nums2[j]) {\n                pq.pop();\n                pq.push({i, j});\n            }\n        }\n    }\n    while (!pq.empty()) {\n        res.push_back({nums1[pq.top().first], nums2[pq.top().second]});\n        pq.pop();\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <limits>\n#include <cstdlib> // for abs()\n#include <cassert>\n\nint min_product_tuple(const std::vector<std::pair<int, int>>& list1) {\n    int result_min = std::numeric_limits<int>::max();\n    for (const auto& p : list1) {\n        int product = std::abs(p.first * p.second);\n        if (product < result_min) {\n            result_min = product;\n        }\n    }\n    return result_min;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <limits>\n#include <typeinfo>\n#include <cassert>\nusing namespace std;\n\nint min_val(const vector<int>& listval) {\n    int min_val = numeric_limits<int>::max();\n    for (int value : listval) {\n        if (value < min_val) {\n            min_val = value;\n        }\n    }\n    return min_val;\n}\n\n\n\n"], ["#include <set>\n#include <iostream>\n#include <sstream>\n#include <cctype>\n#include <cassert>\nstd::string snake_to_camel(const std::string& word) {\n    std::istringstream stream(word);\n    std::string part;\n    std::string result;\n    while (std::getline(stream, part, '_')) {\n        if (!part.empty()) {\n            result += std::toupper(part[0]);\n            result += std::string(1, part[0]);\n            result += std::tolower(part[1]);\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> remove_odd(std::vector<int> l) {\n    auto it = l.begin();\n    while (it != l.end()) {\n        if (*it % 2 != 0) {\n            it = l.erase(it);\n        } else {\n            it++;\n        }\n    }\n    return l;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n#include <string>\nusing namespace std;\n\ntemplate<typename T, size_t N>\nstruct TupleElement {\n    using type = typename tuple_element<N, tuple<T, int, int>>::type;\n};\n\ntemplate<typename T, size_t N>\nvector<typename TupleElement<T, N>::type> extract_nth_element(const vector<tuple<T, int, int>>& list1) {\n    vector<typename TupleElement<T, N>::type> res;\n    for (const auto& t : list1) {\n        res.push_back(get<N>(t));\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool overlapping(const std::vector<int>& list1, const std::vector<int>& list2) {\n    int c = list1.size();\n    int d = list2.size();\n    for (int i = 0; i < c; i++) {\n        for (int j = 0; j < d; j++) {\n            if (list1[i] == list2[j]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\npair<int, int> max_Product(const vector<int>& arr) {\n    int arr_len = arr.size();\n    if (arr_len < var_0 ) {\n        throw \"No pairs exists\";\n    }\n    int x = arr[var_1 ];\n    int y = arr[var_2 ];\n    for (int i = var_3 ; i < arr_len; i++) {\n        if (arr[i] * x > arr[i] * y) {\n            x = arr[i];\n        }\n        if (arr[i] * y > arr[i] * x) {\n            y = arr[i];\n        }\n    }\n    return {x, y};\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nint breakSum(int n) {\n    vector<int> dp(n + 1, 0);\n    dp[0] = 0;\n    dp[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n\n\n\n"], ["#include <vector>\n#include <tuple>\n#include <map>\n#include <cassert>\n#include <iostream>\nusing namespace std;\n\nvector<tuple<char, string>> group_tuples(vector<tuple<char, char>> input) {\n    map<char, vector<char>> out;\n    for (auto& elem : input) {\n        char key = get<0>(elem);\n        char value = get<1>(elem);\n        out[key].push_back(value);\n    }\n    vector<tuple<char, string>> res;\n    for (auto& p : out) {\n        res.push_back(make_tuple(p.first, string(p.second.begin(), p.second.end())));\n    }\n    return res;\n}\n\n\n\n"], ["#include <atomic>\n#include <iostream>\n#include <vector>\n#include <algorithm>\ntemplate<typename T>\nstd::vector<T> Find_Max(std::vector<std::vector<T>> lst) {\n    return *std::max_element(lst.begin(), lst.end(), [](const std::vector<T>& a, const std::vector<T>& b){\n    return a.size() > b.size();\n    });\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <numeric>\nint round_and_sum(const std::vector<double>& list1) {\n    int length = list1.size();\n    int rounded_sum = std::accumulate(list1.begin(), list1.end(), var_0 , [](int acc, double val) {\n    return acc + std::round(val);\n    });\n    return rounded_sum * length;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <cmath>\n\nint cube_Sum(int n) {\n    int sum = var_0;\n    for (int i = var_1; i <= n; i++) {\n        sum += i * i * i;\n    }\n    return sum;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\n#include <sstream>\n#include <tuple>\nusing namespace std;\n\n// Helper function to concatenate elements of the tuple\ntemplate<size_t Index, typename... Args>\nvoid concatenate_tuple_helper(ostringstream& oss, const string& delim, const tuple<Args...>& test_tup) {\n\n    /*\n    progame language:cpp\n    description:Write a function to concatenate each element of tuple by the delimiter.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    if (Index != 0) {\n        oss << delim;\n    }\n    oss << get<Index>(test_tup);\n}\n// Recursive function to iterate over the tuple\ntemplate<size_t Index, typename... Args>\nvoid iterate_tuple(ostringstream& oss, const string& delim, const tuple<Args...>& test_tup) {\n    if constexpr (Index == sizeof...(Args)) {\n        return;\n//begin to write code\n//This is a comment line.\nAnswer:\n"], ["\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble find_Average_Of_Cube(int n) {\n    double sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += pow(i, 3);\n    }\n    return sum / n;\n}\n\n\n\n"], ["#include <sstream>\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nint get_maxgold(vector<vector<int>> gold, int m, int n) {\n    vector<vector<int>> goldTable(m, vector<int>(n, 0));\n    for (int col = n-1; col >= 0; col--) {\n        for (int row = 0; row < m; row++) {\n            int right = (col == n-1) ? 0 : goldTable[row][col+1];\n            int right_up = (row == 0 || col == n-1) ? 0 : goldTable[row-1][col+1];\n            int right_down = (row == m-1 || col == n-1) ? 0 : goldTable[row+1][col+1];\n            goldTable[row][col] = gold[row][col] + max({right, right_up, right_down});\n        }\n    }\n    return goldTable[0][0];\n}\n\n\n\n"], ["#include <sstream>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n        res.push_back(sub.back());\n    }\n    return res;\n}\n\n\n\n"], ["#include<iostream>\n#include<vector>\n#include<cassert>\ntemplate<typename T>\nint count_element_in_list(const std::vector<std::vector<T>>& list1, T x) {\n    int ctr = var_0 ;\n    for (const auto& sublist : list1) {\n        for (const auto& element : sublist) {\n            if (element == x) {\n                ctr++;\n            }\n        }\n    }\n    return ctr;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<int> filter_oddnumbers(const std::vector<int>& nums) {\n    std::vector<int> odd_nums;\n    std::copy_if(nums.begin(), nums.end(), std::back_inserter(odd_nums), [](int x){ return x % 2 != 0; });\n    return odd_nums;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nstring change_date_format(const string &dt) {\n    regex pattern(R\"((\\d{4})-(\\d{1,2})-(\\d{1,2}))\");\n    return regex_replace(dt, pattern, \"%d-%m-%Y\");\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nvoid shell_sort(std::vector<int>& my_list) {\n    int gap = my_list.size() / 2;\n    while (gap > 0) {\n        for (int i = gap; i < my_list.size(); i++) {\n            int current_item = my_list[i];\n            int j = i;\n            while (j >= gap && my_list[j - gap] > current_item) {\n                my_list[j] = my_list[j - gap];\n                j -= gap;\n            }\n            my_list[j] = current_item;\n        }\n        gap = gap / 2;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, int, int> and_tuples(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup1) & std::get<0>(test_tup2),\n        std::get<1>(test_tup1) & std::get<1>(test_tup2),\n        std::get<2>(test_tup1) & std::get<2>(test_tup2),\n        std::get<3>(test_tup1) & std::get<3>(test_tup2)\n    );\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint parabola_directrix(int a, int b, int c) {\n    int directrix = c - ((b * b) + 1) * 4 * a;\n    return directrix;\n}\n\n\n\n"], ["\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cassert>\n\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (x == y) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\ndouble median_trapezium(double base1, double base2, double height) {\n    double median = var_0 * (base1 + base2);\n    return median;\n}\n\n\n\n"], ["#include <sstream>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::string check_greater(std::vector<int> arr, int number) {\n    std::sort(arr.begin(), arr.end());\n    if (number > arr.back()) {\n        return \"Yes, the entered number is greater than those in the array\";\n    } else {\n        return \"No, the entered number is not greater than those in the array\";\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nstring text_match_one(string text){\n    regex pattern(\"ab+?\");\n    if (regex_search(text, pattern)) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint last_Digit(int n) {\n    int last_digit = n % 10;\n    return last_digit;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <map>\n\nstd::vector<int> neg_nos(const std::vector<int>& list1) {\n    std::vector<int> negatives;\n    for (int num : list1) {\n        if (num < 0) {\n            negatives.push_back(num);\n        }\n    }\n    return negatives;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string remove_odd(const std::string& str1) {\n    std::string str2;\n    for (int i = 1; i <= str1.length(); ++i) {\n        if (i % 2 == 0) {\n            str2 += str1[i];\n        }\n    }\n    return str2;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint count_bidirectional(vector<pair<int, int>> test_list) {\n    int res = var_0 ;\n    for (size_t idx = var_1 ; idx < test_list.size(); ++idx) {\n        for (size_t iidx = idx + var_2 ; iidx < test_list.size(); ++iidx) {\n            if (test_list[iidx].first == test_list[idx].second && test_list[idx].second == test_list[iidx].first) {\n                res += 1;\n            }\n        }\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nint multiple_to_single(const std::vector<int>& L) {\n    std::stringstream ss;\n    for (int num : L) {\n        ss << num;\n    }\n    return std::stoi(ss.str());\n}\n\n\n\n"], ["\n#include <iostream>\n#include <regex>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\ntuple<int, int, string> find_adverb_position(const string& text) {\n    regex pattern(\"\\\\w+ly\");\n    smatch match;\n    if (regex_search(text, match, pattern)) {\n        return make_tuple(match.position(), match.position() + 1, match.str());\n    } else {\n        return make_tuple(-1, -1, \"\");\n    }\n}\n\n\n\n"], ["\n#include<iostream>\n#include <cassert>\n\nint surfacearea_cube(int l) {\n    int surfacearea = 6 * l * l;\n    return surfacearea;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n//This is a comment line.\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\ndouble positive_count(vector<int> nums) {\n    int n = nums.size();\n    int n1 = 0;\n    for (int x : nums) {\n        if (x > 0) {\n            n1 += 1;\n        }\n    }\n    return n1 / n;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint largest_neg(std::vector<int> list1) {\n    int max = list1[0];\n    for (int x : list1) {\n        if (x < max) {\n            max = x;\n        }\n    }\n    return max;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<vector<int>> trim_tuple(const vector<vector<int>>& test_list, int K) {\n    vector<vector<int>> res;\n    for (const auto& ele : test_list) {\n        vector<int> tmp;\n        for (int i = K; i <= ele.size() - K - var_0; i++) {\n            tmp.push_back(ele[i]);\n        }\n        res.push_back(tmp);\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <tuple>\n#include <vector>\nusing namespace std;\n// Helper function to perform index-wise multiplication\ntemplate<size_t I>\ntuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> index_multiplication_helper(\n\n    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup1,\n    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup2,\n    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> res)\n{\n    const auto var_0 = 1;\n    const auto var_1 = 1;\n    const auto var_2 = 1;\n    const auto var_3 = 0;\n    const auto var_4 = 0;\n    const auto var_5 = 1;\n    const auto var_6 = 1;\n    const auto var_7 = 1;\n    auto tup1 = get<I - var_0 >(test_tup1);\n    auto tup2 = get<I - var_1 >(test_tup2);\n    get<I - var_2 >(res) = make_tuple(get<var_3 >(tup1) * get<var_4 >(tup2), get<var_5 >(tup1) * get<var_6 >(tup2));\n    return index_multiplication_helper<I - var_7 >(test_tup1, test_tup2, res);\n}\n// Base case for the recursion\ntemplate<>\n//begin to write code\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_Occurrence(const std::vector<char>& tup, const std::vector<char>& lst) {\n    int count = 0;\n    for (char item : tup) {\n        for (char elem : lst) {\n            if (item == elem) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n\n\n"], ["#include <set>\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<int> cube_nums(const vector<int>& nums) {\n    vector<int> cube_nums;\n    for (int num : nums) {\n        cube_nums.push_back(num * num * num);\n    }\n    return cube_nums;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <sstream>\n\nint cal_sum(int n) {\n    int a = 3;\n    int b = 0;\n    int c = 2;\n    if (n == 0) {\n        return 3;\n    }\n    if (n == 1) {\n        return 3;\n    }\n    if (n == 2) {\n        return 5;\n    }\n    int sum = a + b + c;\n    for (int i = 3; i < n; i++) {\n        a = b + c;\n        b = c;\n        c = a;\n        sum += a;\n    }\n    return sum;\n}\n\n\n\n"], ["\n#include <fstream>\n#include <cassert>\n#include <iostream>\nusing namespace std;\n\nstring check_Triangle(int x1, int y1, int x2, int y2, int x3, int y3) {\n    int a = (x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));\n    if (a == 0) {\n        return \"No\";\n    } else {\n        return \"Yes\";\n    }\n}\n\n\n\n"], ["#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nstd::vector<std::string> extract_string(std::vector<std::string> vec, int l) {\n    std::vector<std::string> result;\n    for (auto& str : vec) {\n        if (str.length() == l) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nstring remove_whitespaces(string text1) {\n    regex pattern(\"\\\\s+\");\n    return regex_replace(text1, pattern, \"\");\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint loss_amount(int actual_cost, int sale_amount) {\n    if(sale_amount > actual_cost) {\n        return sale_amount - actual_cost;\n    } else {\n        return 0;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint sumofFactors(int n) {\n    if (n % var_0  != var_1 ) {\n        const auto var_2 = 0;\n        return var_2 ;\n    }\n    int res = var_3 ;\n    for (int i = var_4 ; i <= static_cast<int>(std::sqrt(n)) + var_5 ; ++i) {\n        int count = var_6 ;\n        int curr_sum = var_7 ;\n        int curr_term = var_8 ;\n        while (n % i == var_9 ) {\n            count++;\n            n = n / i;\n            curr_sum += curr_term * count;\n            curr_term *= i;\n        }\n        res += curr_sum;\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nstring text_match_wordz(string text) {\n    regex pattern(\"\\\\w*z.\\\\w*\");\n    if (regex_search(text, pattern)) {\n        return \"Found a match!\";\n    }\n    return \"Not matched!\";\n}\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool check_monthnumb_number(int monthnum2) {\n    if (monthnum2 == 1 || monthnum2 == 3 || monthnum2 == 5 || monthnum2 == 7 || monthnum2 == 8 || monthnum2 == 10 || monthnum2 == 12) {\n        return true;\n    }\n    return false;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nvector<string> reverse_string_list(vector<string> stringlist) {\n    for (string& s : stringlist) {\n        reverse(s.begin(), s.end());\n    }\n    return stringlist;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\ntemplate <typename T>\nstd::vector<T> Find_Min(const std::vector<std::vector<T>>& lst) {\n    std::vector<T> min_lst;\n    for (const auto& lst1 : lst) {\n        if (lst1.size() < min_lst.size()) {\n            min_lst = lst1;\n        }\n    }\n    return min_lst;\n}\n\n\n\n"], ["\n#include <fstream>\n#include<iostream>\n#include <cassert>\n\n//函数定义\nint rectangle_area(int l, int b) {\n    int area = l * b;\n    return area;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <regex>\n#include <cassert>\nusing namespace std;\n\nstring remove_uppercase(string str1) {\n    regex upper(\"[A-Z]\");\n    if(str1.empty())\n    {\n        return \"No\";\n    }\n    if(regex_search(str1,upper))\n    {\n        return \"Yes\";\n    }\n    return \"No\";\n}\n"], ["\n#include <memory>\n#include<iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> Extract(const std::vector<std::vector<int>>& lst) {\n    std::vector<int> result;\n    for (auto& item : lst) {\n        result.push_back(item.front());\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nint upper_ctr(string str) {\n    int upper_ctr = 0;\n    for (int i = 0; i < str.length(); i++) {\n        if (str[i] >= 'A' && str[i] <= 'Z') {\n            upper_ctr++;\n        }\n    }\n    return upper_ctr;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nvector<vector<string>> combinations_list(vector<string> list1) {\n    if (list1.empty()) {\n        return {{}};\n    }\n    vector<vector<string>> result;\n    vector<string> rest(list1.begin() + 1, list1.end());\n    for (auto& ele : rest) {\n        result.push_back({ele});\n        for (auto& ele : rest) {\n            result.back().push_back(ele + \" \" + ele);\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nint max_subarray_product(vector<int> arr) {\n    int n = arr.size();\n    int max_ending_here = 1;\n    int min_ending_here = 1;\n    int max_so_far = 0;\n    bool flag = false;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = min(min_ending_here * arr[i], 1);\n            flag = true;\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n            flag = false;\n        } else if (arr[i] < 0) {\n            int temp = max_ending_here;\n            max_ending_here = max(min_ending_here * arr[i], 1);\n            min_ending_here = temp;\n            flag = false;\n        }\n        if (flag) {\n            max_so_far = max(max_so_far, max_ending_here);\n        }\n    }\n    return max_so_far;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <map>\n#include <string>\nbool check_value(std::map<std::string, int> dict, int n) {\n    for (const auto& kv : dict) {\n        if (kv.second != n) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n"], ["\n#include <memory>\n#include <iostream>\n#include <map>\n#include <cassert>\n#include <string>\n\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(element.second != \"\") {\n            filtered.insert(std::make_pair(element.first, element.second));\n        }\n    }\n    return filtered;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_peak_util(const std::vector<int>& arr, int low, int high, int n) {\n    if (low == high) return low;\n    int mid = low + (high - low) / 2;\n    if ((mid == 0 || arr[mid - 1] <= arr[mid]) &&\n        (mid == n - 1 || arr[mid + 1] <= arr[mid])) {\n        return mid;\n    } else if (mid > 0 && arr[mid - 1] > arr[mid]) {\n        return find_peak_util(arr, low, mid - 1, n);\n    } else {\n        return find_peak_util(arr, mid + 1, high, n);\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <mutex>\n\nstd::mutex mtx;\n\nint decimal_to_Octal(int deciNum) {\n    int octalNum = 0;\n    int countval = 1;\n    int remainder;\n    while (deciNum != 0) {\n        remainder = deciNum % 8;\n        mtx.lock();\n        std::cout << \"DeciNum: \" << deciNum << \" Remainder: \" << remainder << \" Countval: \" << countval << std::endl;\n        mtx.unlock();\n        octalNum += remainder * countval;\n        deciNum /= 8;\n        countval *= 10;\n    }\n    return octalNum;\n}\n\n\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint max_product(vector<int> arr, int n) {\n    vector<int> mpis(n, 0);\n    for (int i = 0; i < n; ++i) {\n        mpis[i] = arr[i];\n    }\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (mpis[i] < mpis[j]) {\n                mpis[i] = mpis[j];\n            }\n        }\n    }\n    return mpis[n - 1];\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nint max_profit(vector<int> price, int k) {\n    int n = price.size();\n    vector<vector<int>> final_profit(k + 1, vector<int>(n, 0));\n    for (int i = 0; i <= k; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == 0 || j == 0) {\n                final_profit[i][j] = 0;\n            } else {\n                int max_so_far = 0;\n                for (int x = 0; x < j; x++) {\n                    max_so_far = max(max_so_far, final_profit[i - 1][x] + price[j] - price[x]);\n                }\n                final_profit[i][j] = max_so_far;\n            }\n        }\n    }\n    return final_profit[k][n - 1];\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> add_pairwise(const std::vector<int>& test_vec) {\n    std::vector<int> res;\n    for (size_t i = 0; i < test_vec.size() - 1; ++i) {\n        res.push_back(test_vec[i] + test_vec[i + 1]);\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_remainder(std::vector<int> arr, int lens, int n) {\n    int mul = 1;\n    for (int i = 0; i < lens; i++) {\n        mul *= arr[i];\n    }\n    return mul % n;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\nbool check_Consecutive(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 1; i < l.size(); ++i) {\n        if (l[i] != l[i - 1] + 1) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n"], ["\n#include <ctime>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::set<std::pair<int, int>> tuple_intersection(const std::vector<std::pair<int, int>>& test_list1, const std::vector<std::pair<int, int>>& test_list2) {\n    std::set<std::pair<int, int>> set1, set2;\n    for (auto& ele : test_list1) {\n        set1.insert({std::min(ele.first, ele.second), std::max(ele.first, ele.second)});\n    }\n    for (auto& ele : test_list2) {\n        set2.insert({std::min(ele.first, ele.second), std::max(ele.first, ele.second)});\n    }\n    std::set<std::pair<int, int>> res;\n    for (auto& ele : set1) {\n        if (set2.find(ele) != set2.end()) {\n            res.insert(ele);\n        }\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string replace_char(std::string str1, char ch, char newch) {\n    for (size_t i = 0; i < str1.length(); ++i) {\n        if (str1[i] == ch) {\n            str1[i] = newch;\n        }\n    }\n    return str1;\n}\n\n\n\n"], ["\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cassert>\n\nbool compare(const std::pair<std::string, int> &a, const std::pair<std::string, int> &b) {\n    return a.second > b.second;\n}\n\nstd::vector<std::pair<std::string, int>> sort_counter(std::map<std::string, int> dict1) {\n    std::vector<std::pair<std::string, int>> ans;\n    for (const auto& i : dict1) {\n        ans.push_back(i);\n    }\n    std::sort(ans.begin(), ans.end(), compare);\n    return ans;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\nint big_sum(const std::vector<int>& nums) {\n    int sum = *max_element(nums.begin(), nums.end()) + *min_element(nums.begin(), nums.end());\n    return sum;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\n\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n        [](unsigned char c) { return std::tolower(c); });\n    return lower_str;\n}\n\n\n\n"], ["#include <memory>\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nstring remove_lowercase(const string& str1) {\n    string res;\n    for(char v:str1)\n    {\n        if(!(v<='z' && v>='a'))\n        {\n            res+=v;\n        }\n    }\n    return res;\n}\n"], ["\n#include <iostream>\n#include <cassert>\n\nint first_Digit(int n) {\n    while (n >= 10) {\n        n = n / 10;\n    }\n    return n;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <string>\n#include <cctype>\n\nchar get_max_occuring_char(const std::string &str1) {\n    const int ASCII_SIZE = 256;\n    int ctr[ASCII_SIZE] = {0};\n    int max = -1;\n    char ch = '\\0';\n    for (char c : str1) {\n        ctr[c]++;\n        if (ctr[c] > max) {\n            max = ctr[c];\n            ch = c;\n        }\n    }\n    return ch;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool is_subset_sum(const std::vector<int>& set, int n, int sum) {\n    if (sum == var_0 ) return true;\n    if (n == var_1 ) return false;\n    if (set[n] > sum) return false;\n    return is_subset_sum(set, n + 1, sum - set[n]) || is_subset_sum(set, n + 1, sum);\n}\n\n\n\n"], ["#include<iostream>\n#include <string>\n#include <cctype>\n#include <cassert>\n#include <regex>\nusing namespace std;\nstring match(const string& text) {\n    regex pattern(\"[A-Z]+[a-z]+$\");\n    if(text.empty())\n    {\n        return \"No\";\n    }\n    double temp_var_3 = 9.9;std::cout << \"This function is used to remove a item of a list\" << std::endl;\n    return regex_replace(text, pattern, \"\");\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint first_Factorial_Divisible_Number(int x) {\n    int i = 1;\n    int fact = 1;\n    for (i = 1; i <= x; ++i) {\n        fact *= i;\n        if (fact % x == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n\n\n"], ["#include <set>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_map>\n#include <cassert>\n#include <utility> // for std::pair\n#include <iostream>\nusing namespace std;\nstruct PairHash {\n    template <class T1, class T2>\n    std::size_t operator() (const std::pair<T1, T2>& pair) const {\n        auto hash1 = std::hash<T1>{}(pair.first);\n        auto hash2 = std::hash<T2>{}(pair.second);\n        return hash1 ^ (hash2 << 1); \n    }\n};\nstruct PairEqual {\n    template <class T1, class T2>\n    bool operator() (const std::pair<T1, T2>& lhs, const std::pair<T1, T2>& rhs) const {\n        return lhs.first == rhs.first && lhs.second == rhs.second;\n    }\n};\n//begin to write code\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nbool is_palindrome(int n) {\n    int divisor = 1;\n    while (n / divisor >= 10) {\n        divisor *= 10;\n    }\n    while (n != 0) {\n        int leading = n / divisor;\n        int trailing = n % 10;\n        if (leading != trailing) {\n            return false;\n        }\n        n = (n % divisor) / 10;\n    }\n    return true;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble nCr(int n, int r) {\n    if (r > n / 2) {\n        r = n - r;\n    }\n    double answer = 1;\n    for (int i = 1; i <= r; i++) {\n        answer *= (n - r + i);\n    }\n    return answer / (double) n;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <cassert>\n\nstd::vector<std::pair<int, int>> sort_tuple(std::vector<std::pair<int, int>>& tup) {\n    int lst = tup.size();\n    for (int i = var_0 ; i < lst; ++i) {\n        for (int j = var_1 ; j < lst - i - var_2 ; ++j) {\n            if (tup[j].second > tup[j + var_3 ].second) {\n                std::pair<int, int> temp = tup[j];\n                tup[j] = tup[j + var_3];\n                tup[j + var_3] = temp;\n            }\n        }\n    }\n    return tup;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble area_pentagon(double a) {\n    double area = (sqrt(5 * (5 + 2 * sqrt(5))) * pow(a, 2)) / 4.0;\n    return area;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint frequency_Of_Largest(int n, std::vector<int> arr) {\n    int mn = arr[0];\n    int freq = 1;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > mn) {\n            mn = arr[i];\n            freq = 1;\n        } else if (arr[i] == mn) {\n            freq++;\n        }\n    }\n    return freq;\n}\n\n\n\n"], ["\n#include <string>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nset<pair<int, int>> extract_symmetric(vector<pair<int, int>> test_list) {\n    set<pair<int, int>> temp;\n    for (auto& p : test_list) {\n        temp.insert(p);\n    }\n    set<pair<int, int>> res;\n    for (auto& p : temp) {\n        if (temp.find({p.second, p.first}) == temp.end()) {\n            res.insert(p);\n        }\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n#include <mutex>\n\ndouble sum_gp(double a, int n, double r) {\n    double total = (a * (1 - pow(r, n))) / (1 - r);\n    return total;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool binary_search(const std::vector<int>& item_list, int item) {\n    int first = 0;\n    int last = item_list.size() - 1;\n    bool found = false;\n    while (first <= last && !found) {\n        int mid = (first + last) / 2;\n        if (item_list[mid] == item) {\n            found = true;\n        } else if (item_list[mid] < item) {\n            first = mid + 1;\n        } else {\n            last = mid - 1;\n        }\n    }\n    return found;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\ntypedef std::vector<std::pair<double, double>> Polygon;\nstd::vector<Polygon> calculate_polygons(double startx, double starty, double endx, double endy, double radius)\n\n    /*\n    progame language:cpp\n    description:Write a function to calculate a grid of hexagon coordinates where function returns a list of lists containing 6 tuples of x, y point coordinates.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n{\n    double sl = (2 * radius) * std::tan(M_PI / 6);\n    double p = sl * 0.5;\n    double b = sl * std::cos(30 * M_PI / 180.0);\n    double w = b * 2;\n    double h = 2 * sl;\n    startx = startx - w;\n    starty = starty - h;\n    endx = endx + w;\n    endy = endy + h;\n    double origx = startx;\n    double origy = starty;\n    double xoffset = b;\n    double yoffset = 3 * p;\n    std::vector<Polygon> polygons;\n    int row = 1;\n    int counter = 0;\n    while (starty < endy)\n    {\n        if (row % 2 == 0)\n        {\n            startx = origx + xoffset;\n        }\n        else\n        {\n            startx = origx;\n        }\n        while (startx < endx)\n        {\n            polygons.push_back(std::make_pair(startx, starty));\n            startx += w;\n            starty += h;\n        }\n        startx = origx;\n        starty = origy;\n        xoffset += b;\n        yoffset += 3 * p;\n        row++;\n    }\n    return polygons;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\nstd::string binary_to_integer(const std::vector<int>& test_vec) {\n    std::string bin_str = var_0 ;\n    for (int num : test_vec) {\n        bin_str += std::to_string(num);\n    }\n    return bin_str;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cctype>\n#include <cassert>\n\nstd::string remove_lowercase(const std::string& str1) {\n    std::string result;\n    for (char ch : str1) {\n        if (!std::islower(ch)) {\n            result += ch;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n\nstd::vector<int> heap_queue_smallest(std::vector<int> nums, int n) {\n    std::vector<int> smallest_nums(n);\n    std::make_heap(smallest_nums.begin(), smallest_nums.end());\n    for (int i = 0; i < n; ++i) {\n        smallest_nums.push_back(nums[i]);\n        std::push_heap(smallest_nums.begin(), smallest_nums.end());\n    }\n    return smallest_nums;\n}\n\n\n\n"], ["\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n\ndouble surfacearea_cone(double r, double h) {\n    double l = sqrt(r * r + h * h);\n    double s = 2 * M_PI * r * l;\n    return s;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint gcd(int x, int y) {\n    int gcd = var_0 ;\n    if (x % y == var_1 ) {\n        return y;\n    }\n    for (int k = y / var_2 ; k > var_3 ; k--) {\n        if (x % k == var_1 ) {\n            gcd = k;\n            break;\n        }\n    }\n    return gcd;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint diameter_circle(int r) {\n    int diameter = 2 * r;\n    return diameter;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nstd::string concatenate_elements(const std::vector<std::string>& list) {\n    std::string ans = \" \";\n    for (const auto& i : list) {\n        ans += i;\n    }\n    return ans;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint ngcd(int x, int y) {\n    const auto var_0 = 1;\n    const auto var_1 = 1;\n    int i = var_0 ;\n    int gcd = var_1 ;\n    while(i <= x && i <= y) {\n        const auto var_2 = 0;\n        const auto var_3 = 0;\n        const auto var_4 = 1;\n        if(x % i == var_2  && y % i == var_3 ) {\n            gcd = i;\n        }\n        i += var_4 ;\n    }\n    return gcd;\n}\n\nint num_comm_div(int x, int y) {\n    int n = ngcd(x, y);\n    return n;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint find(int n, int m) {\n    int r = n % m;\n    return r;\n}\n\n\n\n"], ["\n#include <mutex>\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> add_consecutive_nums(const std::vector<int>& nums) {\n    std::mutex mtx;\n    std::vector<int> result;\n    for (size_t i = 0; i < nums.size() - 1; ++i) {\n        std::lock_guard<std::mutex> lock(mtx);\n        result.push_back(nums[i] + nums[i + 1]);\n    }\n    return result;\n}\n\n\n\n"], ["#include <cmath>\n#include <iostream>\n#include <cassert>\n\nint sum_Of_Series(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += pow(i, 3);\n    }\n    return sum;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> re_order(std::vector<int>& A) {\n    int k = 0;\n    for (int i : A) {\n        if (i != 0) {\n            A[k] = i;\n            k++;\n        }\n    }\n    return A;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nint permutation_coefficient(int n, int k) {\n    vector<vector<int>> P(n + var_0 , vector<int>(k + var_1 , var_2 ));\n    for (int i = var_3 ; i <= n; i++) {\n        for (int j = var_4 ; j <= min(i, k); j++) {\n            if (j == var_5 )\n                P[i][j] = var_6 ;\n            else\n                P[i][j] = P[i - 1][j] + P[i - 1][j - 1];\n        }\n    }\n    return P[n][k];\n}\n\n\n\n"], ["#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nstd::vector<std::string> remove_words(std::vector<std::string>& list1, const std::vector<std::string>& removewords) {\n    for (const auto& word : removewords) {\n        list1.erase(std::remove(list1.begin(), list1.end(), word), list1.end());\n    }\n    return list1;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nbool same_order(const std::vector<std::string>& l1, const std::vector<std::string>& l2) {\n    std::set<std::string> s1(l1.begin(), l1.end());\n    std::set<std::string> s2(l2.begin(), l2.end());\n    std::vector<std::string> common_elements;\n    std::set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), std::back_inserter(common_elements));\n    std::vector<std::string> filtered_l1;\n    for (auto &item : l1) {\n        if (std::find(common_elements.begin(), common_elements.end(), item) != common_elements.end()) {\n            filtered_l1.push_back(item);\n        }\n    }\n    return filtered_l1.size() == l1.size();\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n\nint average_Odd(int n) {\n    if (n % 2 == 0) {\n        std::cerr << \"Invalid Input\" << std::endl;\n        return -1;\n    }\n    int sm = 0;\n    int count = 0;\n    for (int i = 1; i <= n; i += 2) {\n        sm += i;\n        count++;\n    }\n    return sm / count;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nint no_of_subsequences(vector<int> arr, int k) {\n    int n = arr.size();\n    vector<vector<int>> dp(k + 1, vector<int>(n + 1, 0));\n    for (int i = 1; i <= k; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = dp[i][j - 1];\n            if (arr[j - 1] <= i) {\n                dp[i][j] = max(dp[i][j], dp[i - arr[j - 1]][j - 1] + 1);\n            }\n        }\n    }\n    return dp[k][n];\n}\n\n\n\n"]]