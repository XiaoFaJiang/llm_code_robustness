[["#include <iostream>\n#include <cassert>\nstd::string remove_Occ(std::string s, char ch) {\n    for (long i = 0; i < s.length(); i++) {\n        if (s[i] == ch) {\n            s = s.substr(0, i) + s.substr(i + 1);\n            break;\n        }\n    }\n    return s;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\nvector<vector<long>> sort_matrix(vector<vector<int>> M) {\n    sort(M.begin(), M.end(), [](const vector<int>& a, const vector<int>& b) {\n        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);\n    });\n    return M;\n}\n\n\n\n"], ["\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cassert>\n#include <iostream>\nusing namespace std;\n\nvector<pair<string, int>> count_common(const vector<string>& words) {\n    map<string, long> word_counts;\n    for (const auto& word : words) {\n        word_counts[word]++;\n    }\n    vector<pair<string, int>> sorted_counts(word_counts.begin(), word_counts.end());\n    sort(sorted_counts.begin(), sorted_counts.end(), [](const pair<string, int>& a, const pair<string, int>& b) {\n        return a.second < b.second;\n    });\n    return sorted_counts;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\nint find_Volume(long l, int b, int h) {\n    return l * b * h;\n}\n"], ["\n#include <iostream>\n#include <cassert>\n#include <string>\n\nstring text_lowercase_underscore(string text) {\n    if (text.empty()) {\n        return \"Not matched!\";\n    }\n    size_t underscore_pos = text.find('_');\n    if (std::string::npos == underscore_pos) {\n        return \"Not matched!\";\n    }\n    if (0 == underscore_pos || text.length() - 1 == underscore_pos) {\n        return \"Not matched!\";\n    }\n    return text.substr(0, underscore_pos) + \"_\" + text.substr(underscore_pos + 1);\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\nint square_perimeter(long a) {\n    int perimeter = 4 * a;\n    assert(perimeter > 0);\n    return perimeter;\n}\n\n\n\n"], ["\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\nconst int NO_OF_CHARS = 256;\nvector<char> str_to_list(const string& str) {\n    vector<char> temp;\n    for (char x : str) {\n        temp.push_back(x);\n    }\n    return temp;\n}\nstring lst_to_string(const vector<char>& List) {\n    return string(List.begin(), List.end());\n}\nvector<long> get_char_count_array(const string& str) {\n    vector<int> count(NO_OF_CHARS, 0);\n    for (char c : str) {\n        count[c]++;\n    }\n    return count;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool test_duplicate(std::vector<long> arraynums) {\n    std::set<int> nums_set(arraynums.begin(), arraynums.end());    \n    return nums_set.size() != arraynums.size();\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool is_woodall(long long x) {\n    if (0 == x % 2) {\n        return false;\n    }\n    if (1 == x) {\n        return true;\n    }\n    x = 1 + x;\n    long long p = 0;\n    while (x > 0) {\n        p = p * 10 + x % 10;\n        x /= 10;\n    }\n    return p % 10 == 0;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> multiples_of_num(long m, int n) {\n    std::vector<int> multiples;\n    for (int i = 1; i <= m; ++i) {\n        multiples.push_back(i * n);\n    }\n    return multiples;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nint find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    int no_duplicate = -1;\n    for (int num : nums) {\n        if (num_set.end() != num_set.find(num)) {\n            return num;\n        }\n        num_set.insert(num);\n    }\n    return no_duplicate;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint maximum_Sum(const vector<vector<int>>& list1) {\n    int maxi = -100000;\n    for (const auto& x : list1) {\n        long sum = 0;\n        for (auto y : x) {\n            sum += y;\n        }\n        maxi = max(maxi, sum);\n    }\n    return maxi;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint binary_to_decimal(int binary) {\n    int decimal = 0, i = 0;\n    while (binary != 0) {\n        int dec = binary % 10;\n        decimal = decimal + (dec * std::pow(2, i));\n        binary = binary / 10;\n        i++;\n    }\n    return decimal;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nint find_Product(std::vector<int> arr, int n) {\n    std::sort(arr.begin(), arr.end());\n    int prod = 1;\n    for (int i = 0; i < n; i++) {\n        if (0 == i || arr[i] != arr[i - 1]) {\n            prod *= arr[i];\n        }\n    }\n    return prod;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nbool check_k_elements(const std::vector<std::vector<int>>& test_list, int K) {\n    bool res = true;\n    for (const auto& tup : test_list) {\n        for (int ele : tup) {\n            if (K != ele) {\n                res = false;\n                break;\n            }\n        }\n    }\n    return res;\n}\n\n\n\n"], ["\n#include<iostream>\n#include <cassert>\n//函数定义\nlong binomial_Coeff(int n, int k) {\n    if (k > n) {\n        return 0;\n    }\n    long res = 1;\n    for (int i = 0; i < k; i++) {\n        res *= (n - i);\n        res /= (i + 1);\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nint get_Odd_Occurrence(std::vector<int> arr, int arr_size) {\n    int result = 0;\n    for (int i = 0; i < arr_size; i++) {\n        int count = 0;\n        for (int j = 0; j < arr_size; j++) {\n            if (arr[i] == arr[j]) {\n                count = count + 1;\n            }\n        }\n        if (count % 2 != 0) {\n            result = arr[i];\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\nbool check_Equality(const std::string &s) {\n    return (s.front() == s.back());\n}\nlong count_Substring_With_Equal_Ends(const std::string &s) {\n    int result = 0;\n    int n = s.length();\n    for (int i = 0; i < n; ++i) {\n        if (check_Equality(s.substr(i, 2))) {\n            ++result;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nvector<int> func(vector<vector<int>>& nums, int k) {\n    unordered_map<long, int> d;\n    for (auto& row : nums) {\n        for (int i : row) {\n            d[i]++;\n        }\n    }\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    for (auto& item : d) {\n        int key = item.first;\n        int v = item.second;\n        if (pq.size() < k) {\n            pq.emplace(v, key);\n        } else {\n            if (v > pq.top().first) {\n                pq.pop();\n                pq.emplace(v, key);\n            }\n        }\n    }\n    vector<int> res;\n    while (!pq.empty()) {\n        res.push_back(pq.top().second);\n        pq.pop();\n    }\n    return res;\n}\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint max_Prime_Factors(int n) {\n    int maxPrime = -1;\n    while (0 == n % 2) {\n        maxPrime = 2;\n        n >>= 1;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (0 == n % i) {\n            maxPrime = i;\n            n /= i;\n        }\n    }\n    return maxPrime;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint decimal_To_Binary(long N) {\n    int B_Number = 0;\n    int cnt = 0;\n    while (N != 0) {\n        int rem = N % 2;\n        int c = pow(10, cnt);\n        B_Number += rem * c;\n        N /= 2;\n        cnt++;\n    }\n    return B_Number;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\nint find_missing(std::vector<int>& ar, int N) {\n    int l = 0;\n    int r = N - 1;\n    while (l <= r) {\n        long mid = (l + r) / 2;\n        if (ar[mid] != mid + 1 && ar[mid - 1] == mid) {\n            return mid + 1;\n        }\n        if (ar[mid] > mid + 1) {\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return -1;\n}\n"], ["\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nint find_rect_num(long n) {\n    if (n < 1) {\n        throw invalid_argument(\"Input must be bigger than 0!\");\n    }\n    return n * (n + 1) / 2;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nlong find_Nth_Digit(int p, int q, int N) {\n    int res;\n    while (N > 0) {\n        N -= 1;\n        p *= 10;\n    }\n    return p / q;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nstd::vector<std::string> sort_mixed_list(std::vector<std::string> mixed_list) {\n    std::vector<long> int_part;\n    std::vector<std::string> str_part;\n    for (const auto& item : mixed_list) {\n        if (isdigit(item[0]) || (item[0] == '-' && item.size() > 1 && isdigit(item[1]))) {\n            int_part.push_back(std::stoi(item));\n        } else {\n            str_part.push_back(item);\n        }\n    }\n    std::sort(int_part.begin(), int_part.end());\n    std::sort(str_part.begin(), str_part.end());\n    std::vector<std::string> result;\n    result.reserve(int_part.size() + str_part.size());\n    for (const auto& item : int_part) {\n        result.push_back(std::to_string(item));\n    }\n    for (const auto& item : str_part) {\n        result.push_back(item);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\ndouble div_even_odd(const vector<int>& list1) {\n    int first_even = -1;\n    int first_odd = -1;\n    for (int el : list1) {\n        if (0 == el % 2 && -1 == first_even) {\n            first_even = el;\n        } else if (0 == el % 2 && -1 != first_even) {\n            first_odd = el;\n        }\n    }\n    if (first_even != -1 && first_odd != -1) {\n        return (double)first_even / first_odd;\n    } else {\n        return -1;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <queue>\n#include <string>\n#include <unordered_map>\n#include <cassert>\nusing namespace std;\nstring rearrange_string(string S) {\n    unordered_map<char, int> ctr;\n    for (char c : S) {\n        ctr[c]++;\n    }\n    auto comp = [](pair<int, char> left, pair<int, char> right) {\n        if (left.first == right.first) return left.second > right.second;\n        return left.first < right.first;\n    };\n    priority_queue<pair<int, char>, vector<pair<long, char>>, decltype(comp)> heap(comp);\n    for (auto& kv : ctr) {\n        heap.push(make_pair(kv.second, kv.first));\n    }\n    if (heap.top().first > (S.length() + 1) / 2) {\n        return \"\";\n    }\n    string ans = \"\";\n//begin to write code\n    while (!heap.empty()) {\n        char c = heap.top().second;\n        int cnt = heap.top().first;\n        heap.pop();\n        for (int i = 0; i < cnt; i++) {\n            ans += c;\n        }\n    }\n    return ans;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nmap<int, int> freq_element(vector<vector<int>>& nums) {\n    map<int, int> result;\n    for (auto& row : nums) {\n        for (long num : row) {\n            result[num]++;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<int> filter_evennumbers(const std::vector<int>& nums) {\n    std::vector<int> even_nums;\n    for (int num : nums) {\n        if (0 == num % 2) {\n            even_nums.push_back(num);\n        }\n    }\n    return even_nums;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <cassert>\nusing namespace std;\n\nlong find_Sum(const vector<int>& arr) {\n    unordered_map<int, int> count;\n    for (int num : arr) {\n        count[num]++;\n    }\n    int sum = 0;\n    for (auto it = count.begin(); it != count.end(); ++it) {\n        sum += it->second;\n    }\n    return sum;\n}\n\n"], ["#include <iostream>\n#include <cassert>\nusing namespace std;\n\nstring text_match_string(string text) {\n    if (text.empty()) {\n        return \"Not matched!\";\n    }\n    if (isalnum(text[0]) || '_' == text[0]) {\n        return text.substr(1);\n    } else {\n        return \"Not matched!\";\n    }\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nint find_gcd(int x, long y) {\n    while (y != 0) {\n        int temp = x % y;\n        x = y;\n        y = temp;\n    }\n    return x;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool test_distinct(const std::vector<int>& data) {\n  std::set<long> distinctSet(data.begin(), data.end());\n  return distinctSet.size() == data.size();\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\nusing namespace std;\n\nint compute_Last_Digit(int A, long B) {\n    int variable = 1;\n    if (A == B) {\n        return 1;\n    } else if ((B - A) >= 5) {\n        return 0;\n    } else {\n        for (int i = 1; i <= B; i++) {\n            variable *= i;\n        }\n        return variable % A;\n    }\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\n// 函数定义\nlong odd_bit_set_number(int n) {\n    int count = 0;\n    int res = 0;\n    int temp = n;\n    while (temp > 0) {\n        if (count % 2 == 0) {\n            res |= (1 << count);\n        }\n        count++;\n        temp >>= 1;\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nstd::vector<int> specified_element(const std::vector<std::vector<int>>& nums, int N) {\n    std::vector<long> result;\n    for (const auto& i : nums) {\n        if (i.size() >= N) {\n            result.push_back(i[0]);\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::pair<int, std::vector<int>> min_length_list(const std::vector<std::vector<int>>& input_list) {\n    return std::min_element(input_list.begin(), input_list.end(),\n                             [](const std::vector<int>& a, const std::vector<long>& b) {\n                                 return a.size() < b.size();\n                             });\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool check_equilateral(int x, long y, int z) {\n    if (x == y && y == z) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n\n"], ["\n#include<iostream>\n#include<cassert>\n//函数定义\nlong parallelogram_area(int b, int h) {\n    return b * h;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string check_Equality(const std::string& str) {\n    if (str[str.length() - 1] == str[0]) {\n        return \"Equal\";\n    } else {\n        return \"Not Equal\";\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nstd::vector<long> counting_sort(std::vector<int> my_list) {\n    int max_value = 0;\n    for (int i = 0; i < my_list.size(); ++i) {\n        if (my_list[i] > max_value) {\n            max_value = my_list[i];\n        }\n    }\n    std::vector<int> buckets(max_value + 1, 0);\n    for (int num : my_list) {\n        buckets[num]++;\n    }\n    std::vector<long> sorted_list(my_list.size());\n    int index = 0;\n    for (int i = 0; i <= max_value; ++i) {\n        while (buckets[i] > 0) {\n            sorted_list[index++] = i;\n            buckets[i]--;\n        }\n    }\n    return sorted_list;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\ndouble tn_gp(double a, long n, double r) {\n    double tn = a * pow(r, n - 1);\n    return tn;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nusing namespace std;\n\nint rev(int num) {\n    int rev_num = 0;\n    while (num > 0) {\n        rev_num = 10 * rev_num + num % 10;\n        num = num / 10;\n    }\n    return rev_num;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint find_Max_Num(std::vector<int> arr, int n) {\n    std::sort(arr.rbegin(), arr.rend());\n    long num = arr[0];\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > num) {\n            num = arr[i];\n        }\n    }\n    return num;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool opposite_Signs(long x, int y) {\n    return (x > 0 && y < 0) || (x < 0 && y > 0);\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nlong is_octagonal(int n) {\n    long octagonal = 0;\n    for (int i = 1; i <= n; ++i) {\n        octagonal += i * (i + 1) / 2;\n    }\n    return octagonal;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nint max_len_sub(vector<int> arr, int n) {\n    vector<long> mls(n, 1);\n    int max = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (abs(arr[i] - arr[j]) <= 1 && mls[i] < mls[j] + 1) {\n                mls[i] = mls[j] + 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        if (mls[i] > max) {\n            max = mls[i];\n        }\n    }\n    return max;\n}\n\n\n\n"], ["#include <iostream>\n#include <unordered_map>\n#include <cassert>\nint count_Substrings(const std::string& s, int n) {\n    int count = 0, sum = 0;\n    std::unordered_map<int, int> mp;\n    mp[0] = 1;\n    for (int i = 0; i < n; ++i) {\n        sum = sum + (s[i] - '0');\n        if (mp.find(sum) != mp.end()) {\n            count += mp[sum];\n        }\n        mp[sum]++;\n    }\n    return count;\n}\n\n\n\n"], ["#include<iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nint smallest_num(std::vector<long> xs) {\n    long min = xs[0];\n    for (long x : xs) {\n        if (x < min) {\n            min = x;\n        }\n    }\n    return min;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nint max_difference(vector<pair<long, int>> test_list) {\n    vector<int> temp;\n    for (auto p : test_list) {\n        temp.push_back(abs(p.second - p.first));\n    }\n    sort(temp.begin(), temp.end());\n    int max_diff = temp.back() - temp.front();\n    return max_diff;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<pair<string, int>> subject_marks(vector<pair<string, int>> subjectmarks) {\n    sort(subjectmarks.begin(), subjectmarks.end(), [](const pair<string, int>& a, const pair<string, long>& b) {\n        return a.second < b.second;\n    });\n    return subjectmarks;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <typeinfo>\n#include <type_traits>\nusing namespace std;\nclass Any {\npublic:\n    Any() : content(nullptr) {}\n    template<typename T>\n    Any(const T& value) : content(new Holder<T>(value)) {}\n    Any(const Any& other) : content(other.content ? other.content->clone() : nullptr) {}\n    ~Any() { delete content; }\n    Any& operator=(const Any& other) {\n        if (&other != this) {\n            delete content;\n            content = other.content ? other.content->clone() : nullptr;\n        }\n        return *this;\n    }\n    template<typename T>\n    T& cast() {\n        return static_cast<Holder<T>*>(content)->held;\n    }\n    template<typename T>\n    const T& cast() const {\n        return static_cast<const Holder<T>*>(content)->held;\n    }\n    const type_info& type() const {\n        return content ? content->type() : typeid(void);\n    }\nprivate:\n    struct Holder {\n        T held;\n        type_info type;\n        Holder(T value) : held(value), type(typeid(value)) {}\n        Holder(const Holder& other) : held(other.held), type(other.type) {}\n        Holder& operator=(const Holder& other) {\n            if (&other != this) {\n                held = other.held;\n                type = other.type;\n            }\n            return *this;\n        }\n        ~Holder() {}\n    };\n    Holder* content;\n};\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nlong pos_count(const std::vector<int>& list) {\n\n    /*\n    progame language:cpp\n    description:Write a cpp function to count positive numbers in a list.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    int pos_count = 0;\n    for (int num : list) {\n        if (num >= 0) {\n            pos_count++;\n        }\n    }\n    return pos_count;\n}\n\n"], ["#include<iostream>\n    \n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nunsigned long long bell_number(int n) {\n    vector<vector<unsigned long long>> bell(n+1, vector<unsigned long long>(n+1, 0));\n    bell[0][0] = 1;\n    for (long i = 1; i <= n; ++i) {\n        bell[i][0] = bell[i-1][i-1];\n        for (long j = 1; j <= i; ++j) {\n            bell[i][j] = bell[i-1][j-1] + bell[i-1][j];\n        }\n    }\n    return bell[n][n];\n}\n"], ["\n#include<iostream>\n#include <vector>\n#include <cassert>\nbool is_Monotonic(std::vector<int> A) {\n    bool increasing = 1;\n    bool decreasing = 1;\n    for (int i = 0; i < A.size() - 1; ++i) {\n        if (A[i] < A[i + 1]) {\n            increasing = 0;\n        }\n        if (A[i] > A[i + 1]) {\n            decreasing = 0;\n        }\n    }\n    return increasing || decreasing;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\nbool is_sublist(const std::vector<int>& l, const std::vector<int>& s) {\n    bool sub_set = 0;\n    if (s.empty()) {\n        sub_set = 1;\n    } else if (s == l) {\n        sub_set = 1;\n    } else if (s.size() > l.size()) {\n        sub_set = 0;\n    } else {\n        for (size_t i = 0; i <= l.size() - s.size(); i++) {\n            if (l[i] == s[0]) {\n                for (size_t j = 1; j < s.size(); j++) {\n                    if (l[i + j] != s[j]) {\n                        sub_set = 0;\n                        break;\n                    }\n                }\n                if (sub_set) {\n                    break;\n                }\n            }\n        }\n    }\n    return sub_set;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nbool find_equal_tuple(const vector<vector<int>>& input, int k) {\n    for (const auto& tuple : input) {\n        if (tuple.size() != k) {\n            return 0;\n        }\n    }\n    return 1;\n}\n"], ["\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <algorithm>\n\nstd::vector<int> comb_sort(std::vector<int>& nums) {\n    /*\n    progame language:cpp\n    description:Write a function to sort a list of elements using comb sort.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    float shrink_fact = 1.3;\n    int gaps = nums.size(), i;\n    bool swapped = true;\n    while (gaps > 1 || swapped) {\n        gaps = int(double(gaps) / shrink_fact);\n        swapped = false;\n        i = 0;\n        while (gaps + i < nums.size()) {\n            if (nums[i] > nums[i + gaps]) {\n                std::swap(nums[i], nums[i + gaps]);\n                swapped = true;\n            }\n            i++;\n        }\n    }\n    return nums;\n}\n\n"], ["#include <iostream>\n#include <cassert>\nbool dif_Square(int n) {\n    if (n % 4 != 2) {\n        return 1;\n    }\n    int i = 0;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            return 1;\n        }\n        i += 1;\n    }\n    return 0;\n}\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\nbool is_samepatterns(std::vector<std::string> colors, std::vector<std::string> patterns) {\n    if (patterns.size() != colors.size()) {\n        return false;\n    }\n    std::map<std::string, std::vector<std::string>> sdict;\n    std::set<std::string> pset;\n    std::set<std::string> sset;\n    for (size_t i = 0; i < patterns.size(); ++i) {\n        pset.insert(patterns[i]);\n        sset.insert(colors[i]);\n        sdict[patterns[i]].push_back(colors[i]);\n    }\n    for (auto& p : pset) {\n        if (sdict.find(p) == sdict.end()) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <sstream>\n#include <cassert>\nstd::string find_tuples(const std::vector<std::vector<int>>& test_list, int K) {\n    std::vector<std::vector<int>> res;\n    for (const auto& sub : test_list) {\n        bool all_divisible = 1;\n        for (int ele : sub) {\n            if (ele % K != 0) {\n                all_divisible = 0;\n                break;\n            }\n        }\n        if (all_divisible) {\n            res.push_back(sub);\n        }\n    }\n    return res.empty() ? \"No tuples found\" : \"Tuples found: \";\n}\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\n\ndouble count_Squares(long m, int n) {\n    if (n < m) {\n        int temp = m;\n        m = n;\n//begin to write code\n    }\n    return m * m - n * n;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\nbool is_Diff(long n) {\n\n    long sum_even = 0;\n    long sum_odd = 0;\n    long temp = n;\n    while (temp > 0)\n    {\n        long digit = temp % 10;\n        if (digit % 2 == 0)\n        {\n            sum_even += digit;\n        }\n        else\n        {\n            sum_odd += digit;\n        }\n        temp /= 10;\n    }\n    return sum_even - sum_odd;\n}\n\n"], ["\n#include <iostream>\n#include <bitset>\n#include <cassert>\n\n//函数定义\nint countWithOddSetBits(int n) {\n    if (n % 2 != 0) {\n        return (n + 1) / 2;\n    }\n    long count = std::bitset<32>(n).count();\n    return count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\ndouble tetrahedral_number(long n) {\n    return (n * (n + 1) * (n + 2)) / 6;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\nvector<pair<int, int>> zip_tuples(const vector<int>& test_tup1, const vector<int>& test_tup2) {\n    vector<pair<int, int>> res;\n    long n2 = test_tup2.size();\n    for (size_t i = 0; i < test_tup1.size(); ++i) {\n        res.push_back({test_tup1[i], test_tup2[i]});\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble volume_sphere(double r) {\n    double volume = r * (4.0 / 3.0) * M_PI * r * r;\n    return volume;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nchar get_Char(std::string strr) {\n  long summ = 0;\n  for (int i = 0; i < strr.length(); ++i) {\n    summ += (strr[i] - 'a' + 1);\n  }\n  if (summ % 26 == 0) {\n    return 'a';\n  } else {\n    return 'a' + (summ % 26);\n  }\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\nint sequence(int n) {\n    if (1 == n || 2 == n) {\n        return 1;\n    }\n    return sequence(n - 1) + sequence(n - 2);\n}\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * 4 * r;\n    return surfacearea;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint centered_hexagonal_number(long n) {\n  int hexagonal_number = (n * (2 * n - 1)) / 2;\n  return hexagonal_number;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\nstd::map<int, int> freq_count(std::vector<long> list1) {\n    std::map<int, int> freq_count;\n    for (int num : list1) {\n        freq_count[num]++;\n    }\n    return freq_count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\nlong closest_num(int N) {\n    long result = N;\n    for (int i = N - 1; i > 0; i--) {\n        if (N % i == 0) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n// 函数定义\nlong len_log(const std::vector<std::string>& list1) {\n\n    /*\n    progame language:cpp\n    description:Write a cpp function to find the length of the longest word.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    int max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n            max = i.length();\n        }\n    }\n    return max;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <string>\n#include <cassert>\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str) != std::string::npos) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\nbool is_undulating(const std::string& n) {\n    if (n.length() <= 2) {\n        return 0;\n    }\n    for (size_t i = 2; i < n.length(); ++i) {\n        if (n[i] != n[i - 1] + 1) {\n            return 0;\n        }\n    }\n    return 1;\n}\n"], ["\n#include <iostream>\n#include <cassert>\n\nint power(int a, int b) {\n    if (0 == b) {\n        return 1;\n    } else if (0 == a) {\n        return 0;\n    } else {\n        return a * power(a, b - 1);\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <limits>\nstd::string index_minimum(const std::vector<std::pair<std::string, long>>& test_list) {\n    auto min_elem = std::min_element(test_list.begin(), test_list.end(),\n                                     [](const std::pair<std::string, int>& a, const std::pair<std::string, int>& b) {\n//begin to write code\n    return a.second < b.second;\n    });\n    return min_elem->first;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cassert>\nusing namespace std;\n\nint Find_Min_Length(vector<vector<long>>& lst) {\n    int minLength = INT_MAX;\n    for (auto& v : lst) {\n        if (v.size() < minLength) {\n            minLength = v.size();\n        }\n    }\n    return minLength;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint divisor(long n) {\n    int x = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (n % i == 0) {\n            x++;\n        }\n    }\n    return x;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <cassert>\nusing namespace std;\n\nunordered_map<int, int> frequency_lists(vector<vector<long>>& list1) {\n    vector<int> flat_list;\n    for (auto& sublist : list1) {\n        for (auto& item : sublist) {\n            flat_list.push_back(item);\n        }\n    }\n    unordered_map<int, int> dic_data;\n    for (int i = 0; i < flat_list.size(); i++) {\n        dic_data[flat_list[i]]++;\n    }\n    return dic_data;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <limits>\n\nusing namespace std;\n\ndouble multiply_num(const vector<int>& numbers) {\n    double total = 1;\n    for (int x : numbers) {\n        total *= x;\n    }\n    return total;\n}\n\n\n\n"], ["#include<iostream>\n#include <bitset>\n#include <cassert>\nusing namespace std;\n\nstring decimal_to_binary(long n) {\n    if (n == 0) {\n        return \"0\";\n    }\n    string binary = \"\";\n    while (n > 0) {\n        binary = to_string(n % 2) + binary;\n        n /= 2;\n    }\n    return binary;\n}\n\n"], ["#include <iostream>\n#include <climits>\n#include <string>\n#include <cassert>\nint next_smallest_palindrome(long num) {\n    for (int i = num + 1; i < INT_MAX; ++i) {\n        std::string num_str = std::to_string(i);\n        std::string reversed_str = std::string(num_str.rbegin(), num_str.rend());\n        if (num_str == reversed_str) {\n            return i;\n        }\n    }\n    return -1; // Return -1 if no palindrome is found\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint kth_element(vector<long>& arr, int n, int k) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                swap(arr[j], arr[j + 1]);\n                return arr[j];\n            }\n        }\n    }\n    return arr[n - 1];\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint eulerian_num(long n, int m) {\n    if (m >= n || n == 0) {\n        return 0;\n    }\n    return (n * (n - 1) / 2) - (m * (m - 1) / 2);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <cassert>\nlong count(const std::vector<bool>& lst) {\n    return std::accumulate(lst.begin(), lst.end(), 0, [](long acc, bool b) { return acc + (b ? 1 : 0); });\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<long, int, int, int, int> add_lists(std::vector<int> test_list, std::tuple<int, int> test_tup) {\n    /*\n    progame language:cpp\n    description:Write a function to add the given list to the given tuples.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    int first, second;\n    std::tuple<long, int, int, int, int> result;\n    result = std::make_tuple(0, 0, 0, 0, 0);\n    for (int i = 0; i < test_list.size(); i++) {\n        result = std::make_tuple(result.first + test_list[i], result.second + test_tup.first, result.third + test_tup.second, result.fourth + test_tup.first, result.fifth + test_tup.second);\n    }\n    return result;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint count_Hexadecimal(int L, int R) {\n    int count = 0;  \n    for (int i = L; i <= R; i++) { \n        if (i >= 10 && i <= 15) { \n            count++;  \n        } else if (i > 15) { \n            int k = i;  \n            while (0 != k) {  \n                k /= 16;  \n                k %= 16;  \n                count++;  \n            }  \n        }  \n    }  \n    return count;  \n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<int> merge_sorted_list(vector<int> num1, vector<long> num2, vector<int> num3) {\n    vector<int> merged;\n    merged.reserve(num1.size() + num2.size() + num3.size());\n    merged.insert(merged.end(), num1.begin(), num1.end());\n    merged.insert(merged.end(), num2.begin(), num2.end());\n    merged.insert(merged.end(), num3.begin(), num3.end());\n    sort(merged.begin(), merged.end());\n    return merged;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <cassert>\n\nint odd_Equivalent(const std::string& s, int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if ('1' == s[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <utility>\n#include <cassert>\nusing namespace std;\n\n//函数定义\nvector<pair<long, int>> extract_missing(vector<pair<int, int>> test_list, int strt_val, int stop_val) {\n    vector<pair<int, int>> res;\n    for (auto sub : test_list) {\n        if (sub.first > strt_val) {\n            res.push_back(make_pair(strt_val, sub.first));\n            strt_val = sub.second;\n        }\n    }\n    return res;\n}\n\n"], ["#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nstd::vector<int> common_in_nested_lists(std::vector<std::vector<int>> nestedlist) {\n    std::set<int> result_set;\n    bool first = 1;\n    for (const auto& list : nestedlist) {\n        std::set<int> current_set(list.begin(), list.end());\n        if (first) {\n            result_set = current_set;\n            first = 0;\n//begin to write code\nAnswer:\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <set>\n#include <cassert>\n\nint perimeter(long diameter, int height) {\n    return 2 * diameter * height;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cctype>\nbool check_integer(const std::string& text) {\n    std::string str = text;\n    str.erase(0, str.find_first_not_of(' '));\n    str.erase(1 + str.find_last_not_of(' '));\n    if (str.empty()) {\n        return false;\n    }\n    if ('+' == str[0] || '-' == str[0]) {\n        str = str.substr(1);\n    }\n    if (str.find_first_not_of(\"0123456789\") == std::string::npos) {\n        return false;\n    }\n    return true;\n}\n"], ["\n#include <vector>\n#include <unordered_map>\n#include <sstream>\n#include <cassert>\n#include <iostream>\nusing namespace std;\nstruct VectorHash {\n    size_t operator()(const vector<int>& v) const {\n        hash<int> hasher;\n        size_t seed = 0;\n        for (int i : v) {\n            seed ^= 0x9e3779b9 + hasher(i) + (seed << 6) + (seed >> 2);\n        }\n        return seed;\n    }\n};\nvector<vector<int>> assign_freq(vector<vector<int>> test_list) {\n    unordered_map<vector<int>,int,VectorHash> counter;\n    for (auto& v : test_list) {\n        for (int i : v) {\n            counter[i]++;\n        }\n    }\n    return counter;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nbool empty_dict(const std::vector<std::map<int, int>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n    }\n    return 1;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nint tuple_to_int(const std::vector<long>& nums) \n{\n    std::string result;\n    for (int num : nums) {\n        result += std::to_string(num);\n    }\n    return std::stoi(result);\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <sstream>\n#include <algorithm>\n\nstd::string list_to_float(std::vector<std::pair<std::string, std::string>> test_list) {\n    std::vector<std::pair<float, float>> res;\n    for (auto &tup : test_list) {\n        double first, second;\n        // Convert first element\n        std::istringstream(tup.first) >> first;\n        // Convert second element\n        std::istringstream(tup.second) >> second;\n        res.push_back({first, second});\n    }\n    // Convert all elements to float\n    for (auto &tup : res) {\n        tup.first = std::stof(tup.first);\n        tup.second = std::stof(tup.second);\n    }\n    return std::to_string(res);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint search(const std::vector<int>& arr, int n) {\n    int XOR = 0;\n    for (long i = 0; i < n; i++) {\n        XOR ^= arr[i];\n    }\n    return XOR;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nint max_product_tuple(const std::vector<std::pair<int, int>>& list1) {\n    int result_max = 0;\n    for (const auto& p : list1) {\n        int product = std::abs(p.second * p.first);\n        if (product > result_max) {\n            result_max = product;\n        }\n    }\n    return result_max;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nbool check_triplet(const std::vector<int>& A, int n, int sum, long count) {\n    if (count == 3 && sum == 0) {\n        return true;\n    }\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if (A[i] + A[j] + A[k] == sum) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n"], ["#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nconst int MAX = 3000;\nint smartNumber(long n) {\n    vector<int> primes(MAX, 0);\n    vector<int> result;\n    for (int i = 2; i < MAX; i++) {\n        if (primes[i] == 0) {\n            primes[i] = 1;\n            int j = i * 2;\n            while (j < MAX) {\n                primes[j] -= 1;\n//begin to write code\nAnswer:\n"], ["\n#include <iostream>\n#include <set>\n#include <stdexcept>\n#include <cassert>\nusing namespace std;\nint amicable_numbers_sum(int limit) {\n    if (limit < 1) {\n        throw invalid_argument(\"Input must be bigger than 0!\");\n    }\n    set<int> amicables;\n    for (int num = 2; num <= limit; num++) {\n        if (amicables.end() != amicables.find(num)) {\n            continue;\n        }\n        int sum_fact = 0;\n        for (int fact = 1; fact < num; fact++) {\n            if (0 == num % fact) {\n                sum_fact += fact;\n            }\n        }\n        int sum_fact2 = 0;\n//begin to write code\nAnswer:\n"], ["\n#include <iostream>\n#include <algorithm>\n#include <string>\n\nlong find_length(const std::string& string, int n) {\n    int current_sum = 0;\n    int max_sum = 0;\n    for (int i = 0; i < n; ++i) {\n        current_sum += (string[i] == '0' ? 1 : -1);\n        if (current_sum < 0) {\n            max_sum = std::max(max_sum, current_sum);\n            current_sum = 0;\n        }\n    }\n    return std::max(max_sum, current_sum);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <algorithm>\n#include <cassert>\n\nint sum(int a, int b) {\n    int sum = 0;\n    for (long i = 1; i < std::min(a, b); i++) {\n        if (a % i == 0 && b % i == 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\nint multiply_int(int x, int y) {\n    if (y < 0) {\n        return -multiply_int(x, -y);\n    } else if (0 == y) {\n        return 0;\n    } else {\n        return x + multiply_int(x, y - 1);\n    }\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\nstd::vector<std::string> long_words(long n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n        if (word.length() > n) {\n            word_len.push_back(word);\n        }\n    }\n    return word_len;\n}\n\n\n\n"], ["#include <cassert>\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <set>\n\nbool magic_square_test(const std::vector<std::vector<int>>& my_matrix) {\n    size_t iSize = my_matrix[0].size();\n    std::vector<int> sum_list;\n    // Sum of each row\n    for (const auto& line : my_matrix) {\n        sum_list.push_back(std::accumulate(line.begin(), line.end(), 0));\n    }\n    // Sum of each column\n    for (size_t col = 0; col < iSize; ++col) {\n        long col_sum = 0;\n        for (size_t row = 0; row < iSize; ++row) {\n            col_sum += my_matrix[row][col];\n        }\n        sum_list.push_back(col_sum);\n    }\n    // Check if the sum of each row, column, and diagonal is the same\n    for (size_t i = 0; i < iSize; ++i) {\n        if (sum_list[i] != sum_list[iSize - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\npair<int, long> max_occurrences(vector<int> nums) {\n    unordered_map<int, int> dict;\n    for (int num : nums) {\n        dict[num]++;\n    }\n    int max_freq = 0;\n    int max_num = 0;\n    for (auto& pair : dict) {\n        if (pair.second > max_freq) {\n            max_freq = pair.second;\n            max_num = pair.first;\n        }\n    }\n    return make_pair(max_num, max_freq);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string reverse_vowels(std::string str1) {\n    std::string vowels = \"\";\n    for (char char1 : str1) {\n        if (std::string(\"aeiouAEIOU\").find(char1) != std::string::npos) {\n            vowels = vowels + (char1);\n        }\n    }\n    std::string result_string = \"\";\n    size_t vowel_index = vowels.length();\n    for (size_t i = 0; i < str1.length(); i++) {\n        if (std::string(\"aeiouAEIOU\").find(str1[i]) != std::string::npos) {\n            result_string = result_string + vowels[vowel_index - 1];\n            vowel_index--;\n        } else {\n            result_string = result_string + str1[i];\n        }\n    }\n    return result_string;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nstring tup_string(char tup1[], int size) {\n    string str = \"\";\n    for (long i = 0; i < size; i++) {\n        str += to_string(tup1[i]);\n    }\n    return str;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <numeric>\nint sum_negativenum(const std::vector<int>& nums) {\n    long sum = 0;\n    for (auto num : nums) {\n        if (num < 0) {\n            sum += num;\n        }\n    }\n    return sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::string check_last(const std::vector<int>& arr, int n, int p) {\n    int _sum = 0;\n    for (int i = 0; i < n; i = i + 1) {\n        _sum = _sum + (arr[i]);\n    }\n    if (p == 1) {\n        if (_sum % 2 == 0) {\n            return \"even\";\n        } else {\n            return \"odd\";\n        }\n    } else {\n        return \"invalid\";\n    }\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <cassert>\n\n//函数定义\nlong hexagonal_num(int n) {\n    long num = (n * (2 * n - 1)) / 2;\n    return num;\n}\n\n\n\n"], ["#include<iostream>\n    \n#include <cassert>\n#include <string>\n\nusing namespace std;\n\ndouble cal_electbill(int units) {\n    double amount;\n    int surcharge;\n    if(units < 50) {\n        amount = 2.60 * units;\n        surcharge = 25;\n    } else if(units <= 100) {\n        amount = ((units - 50) * 3.25) + 130;\n        surcharge = 35;\n    } else {\n        amount = 5.00 * units;\n        surcharge = 50;\n    }\n\n    return amount + surcharge;\n}\n"], ["#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\ndouble zero_count(const std::vector<int>& nums) {\n    int n = nums.size();\n    int n1 = 0;\n    for (int x : nums) {\n        if (0 == x) {\n            n1++;\n        }\n    }\n    return n1 / n;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool is_Sum_Of_Powers_Of_Two(int n) {\n    if (1 == n % 2) {\n        return false;\n    } else {\n        int power = 0;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                return false;\n            }\n            n /= 2;\n            power++;\n        }\n        return true;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\ndouble circle_circumference(double r) {\n    double perimeter = r * 3.1415 * 2;\n    return perimeter;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n#include <cctype> // For std::isupper, std::islower, std::isdigit\n\nusing namespace std;\n\nstd::vector<int> extract_singly(const std::vector<std::vector<int>>& test_list) {\n    std::vector<int> res;\n    std::set<int> temp;\n    for (const auto& inner : test_list) {\n        for (int ele : inner) {\n            if (temp.end() == temp.find(ele)) {\n                res.push_back(ele);\n                temp.insert(ele);\n            }\n        }\n    }\n    return res;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nstd::vector<int> pancake_sort(std::vector<int>& nums) {\n    int arr_len = nums.size();\n    while (arr_len > 1) {\n        auto mi = std::distance(nums.begin(), std::max_element(nums.begin(), nums.begin() + arr_len));\n        std::reverse(nums.begin(), 1 + nums.begin() + mi);\n        std::reverse(nums.begin(), 1 + nums.begin() + mi);\n        arr_len--;\n    }\n    return nums;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nint count_samepair(const std::vector<long>& list1, const std::vector<int>& list2, const std::vector<int>& list3) {\n    int result = 0;\n    for (size_t i = 0; i < list1.size(); ++i) {\n        if (list1[i] == list2[i] && list2[i] == list3[i]) {\n            result++;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <tuple>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\ntemplate <typename... Args>\nlong find_lists(const std::tuple<Args...>& input) {\n    /*\n    progame language:cpp\n    description:Write a function to find number of lists present in the given tuple.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    return sizeof...(Args);\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint sum_Pairs(const vector<int>& arr, int n) {\n    long sum = 0;\n    for (int i = n - 1; i >= 0; --i) {\n        for (int j = i + 1; j < n; ++j) {\n            sum += abs(arr[i] - arr[j]);\n        }\n    }\n    return sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint max_Abs_Diff(const std::vector<int>& arr, int n) {\n    long minEle = arr[0];\n    int maxEle = arr[0];\n    for (int i = 1; i < n; i++) {\n        minEle = std::min(minEle, arr[i]);\n        maxEle = std::max(maxEle, arr[i]);\n    }\n    return maxEle - minEle;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nlong ascii_value_string(const std::string& str1) {\n  long ascii_value = 0;\n  for (int i = 0; i < str1.length(); i++) {\n    ascii_value += str1[i];\n  }\n  return ascii_value;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nint max_path_sum(std::vector<std::vector<int>>& tri, int m, int n) {\n    for (int i = m - 1; i >= 0; --i) {\n        for (int j = 0; j <= i; ++j) {\n            if (tri[i + 1][j] > tri[i + 1][j + 1]) {\n                tri[i][j] = tri[i][j] + (tri[i + 1][j]);\n            } else {\n                tri[i][j] = tri[i][j] + (tri[i + 1][j + 1]);\n            }\n        }\n    }\n    return tri[0][0];\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\nint sum_digits_single(int x) {\n    int ans = 0;\n    while (x) {\n        ans = ans + (x % 10);\n        x = x / (10);\n    }\n    return ans;\n}\nint closest(int x) {\n    int ans = sum_digits_single(x);\n    int min_diff = abs(ans - x);\n    int min_num = x;\n    for (int i = 1; i < 10; ++i) {\n        int num = sum_digits_single(i);\n        int diff = abs(num - x);\n        if (diff < min_diff) {\n            min_diff = diff;\n            min_num = i;\n        }\n    }\n    return min_num;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint longest_subseq_with_diff_one(vector<long> &arr, int n) {\n    vector<int> dp(n, 1);\n    int result = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if ((arr[i] == arr[j] + 1) || (arr[i] == arr[j] - 1)) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n        result = max(result, dp[i]);\n    }\n    return result;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool does_Contain_B(int a, long b, int c) {\n    if (a == b) {\n        return true;\n    }\n    return does_Contain_B(a, b, c);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint gcd(int p, int q) {\n    while (0 != q) {\n        int temp = p % q;\n        p = q;\n        q = temp;\n    }\n    return p;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<long> merge(vector<int>& a, vector<int>& b) {\n    vector<long> c;\n    while (!a.empty() && !b.empty()) {\n        if (a.front() < b.front()) {\n            c.push_back(a.front());\n            a.erase(a.begin());\n        } else {\n            c.push_back(b.front());\n            b.erase(b.begin());\n        }\n    }\n    if (a.empty()) {\n        c.insert(c.end(), b.begin(), b.end());\n    } else {\n        c.insert(c.end(), a.begin(), a.end());\n    }\n    return c;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<int> specified_element(vector<vector<int>>& nums, int N) {\n    vector<long> result;\n    for (auto& i : nums) {\n        for (auto& j : i) {\n            if (j == N) {\n                result.push_back(j);\n            }\n        }\n    }\n    return result;\n}\n"], ["\n#include <iostream>\n#include <cassert>\n\nint even_bit_toggle_number(int n) {\n    int res = 0;\n    int count = 0;\n    int temp = n;\n    while (temp > 0) {\n        if (1 == count % 2) {\n            res |= (1 << count);\n        }\n        count++;\n        temp >>= 1;\n    }\n    return res;\n}\n\n"], ["#include <iostream>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\nvector<tuple<long, int>> tuple_int_str(const vector<tuple<string, string>>& tuple_str) {\n    vector<tuple<long, int>> result;\n    for (const auto& x : tuple_str) {\n        int first = stoi(get<0>(x));\n        int second = stoi(get<1>(x));\n        result.push_back(make_tuple(first, second));\n    }\n    return result;\n}\n"], ["\n#include <vector>\n#include <string>\n#include <iostream>\n#include <iterator>\n#include <cassert>\ntemplate<typename T>\nstd::vector<std::vector<T>> encode_list(const std::vector<T>& list1) {\n    std::vector<std::vector<T>> result;\n    if (list1.empty()) return result;\n    T current_value = list1[0];\n    int count = 0;\n    for (const T& value : list1) {\n        if (current_value == value) {\n            count++;\n        } else {\n            result.push_back({count, current_value});\n            current_value = value;\n            count = 1;\n        }\n    }\n    result.push_back({count, current_value});\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nint min_Ops(vector<int> arr, int n, int k) {\n    int max1 = *max_element(arr.begin(), arr.end());\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        if (0 != (max1 - arr[i]) % k) {\n            return -1;\n        }\n        res += (max1 - arr[i]) / k;\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\nstd::string month_season(std::string month, long days) {\n    std::string season;\n    if (month == \"January\" || month == \"February\" || month == \"March\") {\n        season = \"winter\";\n    } else if (month == \"April\" || month == \"May\" || month == \"June\") {\n        season = \"spring\";\n    } else if (month == \"July\" || month == \"August\" || month == \"September\") {\n        season = \"summer\";\n    } else {\n        season = \"autumn\";\n    }\n    return season;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n#include <tuple>\nusing namespace std;\n\ntuple<string, int, string, long> solution(int a, int b, int n) {\n\n    /*\n    progame language:cpp\n    description:Write a function to find x and y that satisfies ax + by = n.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    int i = 0;\n    while (i * a <= n) {\n        if ((n - (i * a)) % b == 0) {\n            return make_tuple(\"x = \", i, \", y = \", (n - (i * a)) / b);\n        }\n        i++;\n    }\n    return make_tuple(\"No solution\", 0, \"\", 0);\n}\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> remove_elements(std::vector<int> list1, const std::vector<long>& list2) {\n    std::vector<int> result;\n    std::copy_if(list1.begin(), list1.end(), std::back_inserter(result),\n        [](int x) { return std::find(list2.begin(), list2.end(), x) == list2.end(); });\n    return result;\n}\n"], ["\n\n#include <iostream>\n#include <cassert>\n\nint sum_series(long n) {\n    if (n < 1) {\n        return 0;\n    }\n    return n + sum_series(n - 2) + sum_series(n - 4) + sum_series(n - 6) + sum_series(n - 8) + sum_series(n - 10) + sum_series(n - 12) + sum_series(n - 14) + sum_series(n - 16) + sum_series(n - 18) + sum_series(n - 20) + sum_series(n - 22) + sum_series(n - 24) + sum_series(n - 26) + sum_series(n - 28) + sum_series(n - 30) + sum_series(n - 32) + sum_series(n - 34) + sum_series(n - 36) + sum_series(n - 38) + sum_series(n - 40) + sum_series(n - 42) + sum_series(n - 44) + sum_series(n - 46) + sum_series(n - 48) + sum_series(n - 50) + sum_series(n - 52) + sum_series(n - 54) + sum_series(n - 56) + sum_series(n - 58) + sum_series(n - 60) + sum_series(n - 62) + sum_series(n - 64) + sum_series(n - 66) + sum_series(n - 68) + sum_series(n - 70) + sum_series(n - 72) + sum_series(n - 74) + sum_series(n - 76) + sum_series(n - 78) + sum_series(n - 80) + sum_series(n - 82) + sum_series(n - 84) + sum_series(n - 86) + sum_series(n - 88) + sum_series(n - 90) + sum_series(n - 92) + sum_series(n - 94) + sum_series(n - 96) + sum_series(n - 98) + sum_series(n - 100) + sum_series(n - 102) + sum_series(n - 104) + sum_series(n - 10"], ["#include <iostream>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ndouble area_polygon(int s, double l) {\n    double area = (l * l) * s / (tan(M_PI / s) * 4);\n    return area;\n}\n\nbool compare(double r1, double r2)\n{\n    return r1 == r2;\n}\n"], ["\n#include <cmath>\n#include <cassert>\n#include <iostream>\n\nint divSum(int n) {\n    int sum = 1;\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            sum = sum + (i + (n / i));\n        }\n        i++;\n    }\n    return sum;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\nlong count_char_position(const std::string& str1) {\n    int count_chars = 0;\n    for (size_t i = 0; i < str1.length(); ++i) {\n        if ((i == static_cast<size_t>(str1[i] - 'A')) ||\n            (i == static_cast<size_t>(str1[i] - 'a'))) {\n            count_chars++;\n        }\n    }\n    return count_chars;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_even_Pair(const std::vector<int>& A, int N) {\n    int evenPair = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 1 + i; j < N; ++j) {\n            if (0 == (A[i] ^ A[j]) % 2) {\n                evenPair++;\n            }\n        }\n    }\n    return evenPair;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint next_Power_Of_2(int n) {\n    long count = 0;\n    if (n && !(n & (n - 1))) {\n        return n;\n    }\n    while (n > 0) {\n        n >>= 1;\n        count++;\n    }\n    return 1 << count;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n#include <typeinfo>\n#include <type_traits>\n\nusing namespace std;\n\nint frequency(const vector<int>& a, int x) {\n    int count = 0;\n    for (int i : a) {\n        if (i == x) {\n            count++;\n        }\n    }\n    return count;\n}\n"], ["#include<cassert>\n#include<iostream>\nint get_pell(long n) {\n    if (n <= 2) {\n        return n;\n    }\n    int a = 1;\n    int b = 2;\n    for (int i = 3; i <= n; i++) {\n        int c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint sum_range_list(const std::vector<int>& list1, int m, int n) {\n    long sum_range = 0;\n    for (int i = m; i <= n; ++i) {\n        sum_range += list1[i];\n    }\n    return sum_range;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\nint perimeter_pentagon(int a) {\n    long perimeter = 5 * a;\n    return perimeter;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n#include <string>\n\nint count_occurance(const std::string &s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); ++i) {\n        if ('s' == s[i] && 't' == s[i + 1] && 'd' == s[i + 2]) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n"], ["\n#include <iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nmap<string, vector<long>> group_keyvalue(vector<pair<string, int>> l) {\n    map<string, vector<long>> result;\n    for (auto& p : l) {\n        string key = p.first;\n        int value = p.second;\n        result[key].push_back(value);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <stack>\n#include <map>\nbool is_valid_parenthese(std::string str1) {\n    std::stack<char> stack;\n    std::map<char, char> pchar = {{'(', ')'}, {'{', '}'}, {'[', ']'}};\n    for (char parenthese : str1) {\n        if (pchar.end() != pchar.find(parenthese)) {\n            stack.push(parenthese);\n        } else {\n            if (stack.empty() || pchar[stack.top()] != parenthese) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();\n}\n\n\n\n"], ["\n#include<iostream>\n#include <cassert>\nint perimeter_triangle(int a, long b, int c) {\n    int perimeter = a + b + c;\n    return perimeter;\n}\n\n\n\n"], ["#include<iostream>\n#include <cassert>\n#include <utility> // For std::pair\nstd::pair<int, int> answer(int L, int R) {\n    if (L * 2 <= R) {\n        return std::make_pair(L, L * 2);\n    }\n    return std::make_pair(L, R);\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nbool is_num_keith(int x) {\n    vector<int> terms;\n    int temp = x;\n    long n = 0;\n    while (temp > 0) {\n        terms.push_back(temp % 10);\n        temp = temp / 10;\n        n++;\n    }\n    reverse(terms.begin(), terms.end());\n    int next_term = 0;\n    int i = n;\n    while (i > 0) {\n        next_term = terms[i - 1] * 10 + terms[i - 2];\n        if (next_term > x) {\n            return false;\n        }\n        i--;\n    }\n    return true;\n}\n\n\n\n"], ["#include <cmath>\n#include <cassert>\n#include <iostream>\nusing namespace std;\n\ndouble distance_lat_long(double slat, double slon, double elat, double elon) {\n    double dist = acos(sin(slat) * sin(elat) + cos(slat) * cos(elat) * cos(slon - elon)) * 6371.01;\n    return dist;\n}\n\n"], ["#include <iostream>\n#include <string>\n#include <vector>\nstd::string common_prefix_util(const std::string& str1, const std::string& str2) {\n    std::string result;\n    int n1 = str1.length();\n    int n2 = str2.length();\n    int i = 0;\n    int j = 0;\n    while (i < n1 && j < n2) {\n        if (str1[i] != str2[j]) {\n            break;\n        }\n        result = result + (str1[i]);\n        i++;\n        j++;\n    }\n    return result;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nint count_pairs(const std::vector<int>& arr, int n, int k) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 1 + i; j < n; j++) {\n            if (k == abs(arr[i] - arr[j])) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool greater_specificnum(const std::vector<int>& list, int num) {\n    for (long x : list) {\n        if (x < num) return false;\n    }\n    return true;\n}\n\n\n\n"], ["#include <iostream>\n#include <utility>\n#include <cassert>\nstd::pair<double, double> parabola_focus(double a, double b, double c) {\n    double focus_x = -b / (a * 2);\n    double focus_y = ((1 + a * 4 * c - b * b) / (a * 4));\n    return std::make_pair(focus_x, focus_y);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint longest_common_subsequence(const string &X, const string &Y, int m, int n) {\n    if (0 == m || 0 == n) {\n        return 0;\n    } else if (Y[n-1] == X[m-1]) {\n        return 1 + longest_common_subsequence(X, Y, m-1, n-1);\n    } else {\n        return max(longest_common_subsequence(X, Y, m, n-1), longest_common_subsequence(X, Y, m-1, n));\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool prod_Square(int n) {\n    for (int i = 2; i <= n; ++i) {\n        if (i * i < (n + 1)) {\n            for (long j = 2; j <= n; ++j) {\n                if ((i * i * j * j) == n) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint first_Missing_Positive(std::vector<int> arr, int n) {\n    int ptr = 0;\n    for (int i = 0; i < n; ++i) {\n        if (1 == arr[i]) {\n            ptr = 1;\n            break;\n        }\n    }\n    if (0 == ptr) {\n        return 1;\n    }\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] <= 0 || arr[i] > n) {\n            arr[i] = 0;\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] != i + 1) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\n//函数定义\nint count_Intgral_Points(long x1, int y1, int x2, int y2) {\n    if (x1 > x2) {\n        std::swap(x1, x2);\n        std::swap(y1, y2);\n    }\n    if (y1 > y2) {\n        std::swap(y1, y2);\n    }\n    int count = 0;\n    for (int i = x1; i <= x2; ++i) {\n        for (int j = y1; j <= y2; ++j) {\n            if (i * i + j * j <= x2 * x2 + y2 * y2) {\n                ++count;\n            }\n        }\n    }\n    return count;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <string>\nbool check_monthnumber(std::string monthname3) {\n    if (\"April\" == monthname3 || \"June\" == monthname3 || \"September\" == monthname3 || \"November\" == monthname3) {\n        return true;\n    }\n    return false;\n}\n\n"], ["\n#include<cassert>\n#include <iostream>\n#include <string>\n#include <cctype>\nbool check_String(const std::string& str) { \n    bool flag_l = 0;\n    bool flag_n = 0;\n    for (char i : str) {\n        if (isalpha(i)) {\n            flag_l = 1;\n        } else if (isdigit(i)) {\n            flag_n = 1;\n        }\n    }\n    return flag_l && flag_n;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nvector<long> remove_tuple(const vector<int>& test_vec) {\n    set<int> unique_elements(test_vec.begin(), test_vec.end());\n    vector<long> result(unique_elements.begin(), unique_elements.end());\n    return result;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nlong octal_To_Decimal(int n) {\n    if (n < 0) {\n        std::cerr << \"Invalid Input\" << std::endl;\n        return -1;\n    }\n    int num = n; \n    int dec_value = 0; \n    int base = 1; \n    int temp = num; \n    while (temp) {\n        int digit = temp % 10; \n        dec_value += digit * base; \n        base *= 8; \n        temp /= 10; \n    }\n    return dec_value;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint first(const std::vector<long>& arr, int x, int n) {\n    int low = 0;\n    int high = n - 1;\n    int res = -1;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (arr[mid] > x) {\n            high = mid - 1;\n        } else {\n            res = mid;\n            low = mid + 1;\n        }\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<vector<int>> remove_tuples(vector<vector<int>> test_list, int K) {\n    vector<vector<int>> res;\n    for (auto ele : test_list) {\n        if (K != (int)ele.size()) {\n            res.push_back(ele);\n        }\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nvector<int> find_exponentio(const vector<long>& test_vec1, const vector<int>& test_vec2) {\n    vector<int> res;\n    for (size_t i = 0; i < test_vec1.size(); ++i) {\n        res.push_back(pow(test_vec1[i], test_vec2[i]));\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\nint highest_Power_of_2(int n) {\n    int res = 0;\n    for (int i = n; i > 0; i--) {\n        if (0 == (i & (i - 1))) {\n            res = i;\n        }\n    }\n    return res;\n}\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nstd::vector<int> position_max(const std::vector<long>& list1) {\n    int max_val = *std::max_element(list1.begin(), list1.end());\n    std::vector<int> max_result;\n    for (int i = 0; i < list1.size(); ++i) {\n        if (list1[i] == max_val) {\n            max_result.push_back(i);\n        }\n    }\n    return max_result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\nstd::string remove_even(std::string str1) {\n    std::string str2 = \"\";\n    for (int i = 1; i <= str1.length(); ++i) {\n        if (0 != i % 2) {\n            str2 += str1[i - 1];\n        }\n    }\n    return str2;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\nint hamming_Distance(int n1, int n2) {\n    long x = n1 ^ n2;\n    int setBits = 0;\n    while (x > 0) {\n        setBits += x & 1;\n        x >>= 1;\n    }\n    return setBits;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\n// 函数定义\nint count(std::string s, char c) {\n    long res = 0;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == c) {\n            res++;\n        }\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> inversion_elements(const std::vector<long>& test_vec) {\n    std::vector<int> res;\n    for (long num : test_vec) {\n        int count = 0;\n        for (long i = 0; i < test_vec.size(); i++) {\n            if (num < test_vec[i]) {\n                count++;\n            }\n        }\n        res.push_back(count);\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nint find_longest_repeating_subseq(string str) {\n    int n = str.length();\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (str[i - 1] == str[j - 1] && i != j) {\n                dp[i][j] = 1 + dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[n][n];\n}\n\n"], ["\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <iostream>\nusing namespace std;\n\nvector<long> heap_replace(vector<int> heap, int a) {\n    make_heap(heap.begin(), heap.end(), greater<int>());\n    pop_heap(heap.begin(), heap.end());\n    heap.pop_back();\n    return heap;\n}\n\n\n\n"], ["#include <iostream>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\nint count_Num(long n) {\n    if (n == 1) {\n        return 1;\n    } else {\n        return 2 * count_Num(n - 1);\n    }\n}\n"], ["#include <iostream>\n#include <cassert>\n#include <cmath>\nlong fourth_Power_Sum(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += pow(i, 4);\n    }\n    return sum;\n}\n\n\n\n"], ["#include <cmath>\n#include <cassert>\n#include <iostream>\ndouble degree_radian(double radian) {\n    double degree = (180.0 / M_PI) * radian;\n    return degree;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <typeinfo>\nusing namespace std;\n\nvector<int> decode_list(const vector<vector<int>>& alist) {\n    vector<int> result;\n    for (const auto& g : alist) {\n        if (2 == g.size()) {\n            for (int i = 0; i < g[0]; ++i) {\n                result.push_back(g[1]);\n            }\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\ntemplate<typename T>\nbool check_subset_list(std::vector<std::vector<T>> list1, std::vector<std::vector<T>> list2) {\n    bool exist = true;\n    for (const auto& sublist : list2) {\n        for (const auto& item : sublist) {\n            bool found = false;\n            for (const auto& l : list1) {\n                if (l.end() != std::find(l.begin(), l.end(), item)) {\n                    found = true;\n                    break;\n//begin to write code\nAnswer:\n"], ["\n#include <iostream>\n#include <cassert>\n#include <unordered_map>\n#include <string>\n\nchar first_Repeated_Char(string str) {\n    unordered_map<char, long> h;\n    for (char ch : str) {\n        if (h.find(ch) != h.end()) {\n            return ch;\n        }\n        h[ch]++;\n    }\n    return '\\0';\n}\n\n\n\n"], ["\n#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n\nint gcd(int a, int b) {\n    while (0 != b) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <cassert>\nstd::tuple<std::vector<int>> extract_min_max(std::vector<int> test_vec, long K) {\n    std::sort(test_vec.begin(), test_vec.end());\n    std::vector<int> res;\n    for (int idx = 0; idx < test_vec.size(); ++idx) {\n        if (idx < K || idx >= test_vec.size() - K) {\n            res.push_back(test_vec[idx]);\n        }\n    }\n    return std::make_tuple(res);\n}\n\n"], ["\n#include <iostream>\n#include <string>\n#include <regex>\n#include <cassert>\nstd::string replace_max_specialchar(const std::string& text, int n) {\n    std::regex pattern(\"[ ,.]\");\n    std::string result;\n    long count = 0;\n    for (auto it = text.begin(); it != text.end(); ++it) {\n        if (std::regex_match(std::string(1, *it), pattern) && count < n) {\n            result += ':';\n            ++count;\n        } else {\n            result += *it;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <cassert>\n#include <iostream>\n#include <vector>\n\nint first_even(const std::vector<int>& nums) {\n    for (int num : nums) {\n        if (0 == num % 2) {\n            return num;\n        }\n    }\n    return -1; // Return -1 if no even number is found\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint binary_search(const vector<int>& arr, long low, int high, int x) {\n    if (high >= low) {\n        int mid = (low + high) / 2;\n        if ((mid == 0 || x > arr[mid - 1]) && (arr[mid] == x))\n            return mid;\n        else if (x > arr[mid])\n            return binary_search(arr, mid + 1, high, x);\n        else\n            return binary_search(arr, low, mid - 1, x);\n    }\n    return -1;\n}\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\nint count_Set_Bits(long n) {\n    int count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nint find_Min(std::vector<int>& arr, int low, int high) {\n    while (low < high) {\n        int mid = low + (high - low) / 2;   \n        if (arr[mid] == arr[high]) {\n            high = high - (1); \n        } else if (arr[mid] > arr[high]) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return arr[low];\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\nstd::string odd_values_string(const std::string& str) {\n    std::string result = \"\";\n    for (int i = 0; i < str.length(); ++i) {\n        if (0 == i % 2) {\n            result += str[i];\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nlong min_of_three(int a, int b, int c) {\n    int smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n        smallest = b;\n    } else {\n        smallest = c;\n    }\n    return smallest;\n}\n\n\n\n"], ["\n#include<iostream>\n#include <cassert>\nusing namespace std;\n\nbool all_Bits_Set_In_The_Given_Range(int n, int l, int r) {\n    int num = (((1 << (l - 1)) - 1) ^ ((1 << r) - 1));\n    return num == 0;\n}\n\n\n\n"], ["\n#include <vector>\n#include <cassert>\n#include <iostream>\nstd::vector<int> re_arrange_array(std::vector<long>& arr, int n) {\n    int j = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] < 0) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            j++;\n        }\n    }\n    return arr;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\nstd::string replace_blank(std::string str1, char ch) {\n    for (size_t i = 0; i < str1.length(); i++) {\n        if (' ' == str1[i]) {\n            str1[i] = ch;\n        }\n    }\n    return str1;\n}\n\n\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\nint max_sum(vector<vector<long>> tri, int n) {\n    if (n > 1) {\n        tri[1][1] = tri[1][1] + tri[0][0];\n        tri[1][0] = tri[1][0] + tri[0][0];\n    }\n    for (int i = 2; i < n; i++) {\n        tri[i][0] = tri[i][0] + tri[i - 1][0];\n        tri[i][i] = tri[i][i] + tri[i - 1][i - 1];\n        for (int j = 1; j < i; j++) {\n            tri[i][j] = max(tri[i - 1][j - 1], tri[i - 1][j]) + tri[i][j];\n        }\n    }\n    return tri[n - 1][0];\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <functional>\nusing namespace std;\n\nvector<int> larg_nnum(vector<int> list1, int n) {\n    sort(list1.begin(), list1.end(), greater<long>());\n    vector<int> result;\n    for (int i = 0; i < n; i++) {\n        result.push_back(list1[i]);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include<iostream>\n#include <cassert>\n#include <cmath>\ndouble lateralsurface_cylinder(double r, double h) {\n    double lateralsurface = h * 3.1415 * 2 * r;\n    return lateralsurface;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\nint volume_cube(int l) {\n\n    /*\n    progame language:cpp\n    description:Write a function to find the volume of a cube.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    long volume = l * l * l;\n    return volume;\n}\n\n"], ["#include <iostream>\n#include <cassert>\nint even_bit_set_number(int n) {\n    int count = 0;\n    long res = 0;\n    int temp = n;\n    while (temp > 0) {\n        if (count % 2 == 1) {\n            res |= (1 << count);\n        }\n        count++;\n        temp >>= 1;\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\n// 函数定义\nint No_of_Triangle(int N, long K) {\n    if (N < K) {\n        return -1;\n    } else {\n        int Tri_up = 0;\n        for (int i = 1; i <= N; i++) {\n            int j = 1;\n            while (j <= K) {\n                Tri_up++;\n                j++;\n            }\n        }\n        return Tri_up;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nmap<pair<int, int>, long> check_occurences(vector<pair<int, int>> test_list) {\n    map<pair<int, int>, long> res;\n    for (auto &p : test_list) {\n        if (p.first > p.second)\n            res[p] = 1;\n        else\n            res[p]++;\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nlong number_of_substrings(std::string str) {\n    int str_len = str.length();\n    long count = 0;\n    for (int i = 0; i < str_len; ++i) {\n        for (int j = i + 1; j <= str_len; ++j) {\n            count++;\n        }\n    }\n    return count;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint get_total_number_of_sequences(int m, int n) {\n    vector<vector<int>> T(1 + m, vector<int>(1 + n, 0));\n    for(int i = 0; i <= m; ++i) {\n        for(int j = 0; j <= n; ++j) {\n            if(0 == i || 0 == j) {\n                T[i][j] = 0;\n            } else if(i < j) {\n                T[i][j] = 0;\n//begin to write code\nAnswer:\n"], ["\n#include <cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, int n, int o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\n\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (b.size() != a.size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (b[i].size() != a[i].size()) return false;\n        for (size_t j = 0; j < a[i].size(); ++j) {\n            if (a[i][j] != b[i][j]) return false;\n        }\n    }\n    return true;\n}\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nint count_charac(const string& str1) {\n    long total = 0;\n    for (char i : str1) {\n        total += i;\n    }\n    return total;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <set>\n#include <cassert>\nusing namespace std;\ntemplate <typename T>\nvector<pair<T, pair<vector<string>, int>>> sort_on_occurence(vector<pair<T, string>> const lst) {\n\n    /*\n    progame language:cpp\n    description:Write a function to sort the given list based on the occurrence of first element of tuples.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    unordered_map<T, vector<string>> counter;\n    for (const auto& item : lst) {\n        counter[item.first].push_back(item.second);\n    }\n    vector<pair<T, pair<vector<string>, int>>> result;\n    for (const auto& entry : counter) {\n        set<string> unique_strings(entry.second.begin(), entry.second.end());\n        result.emplace_back(entry.first, make_pair(vector<string>(unique_strings.begin(), unique_strings.end()), entry.second.size()));\n    }\n    return result;\n}\ntemplate <typename T>\nbool compare_results(const vector<pair<T, pair<vector<string>, int>>>& result, const vector<pair<T, pair<vector<string>, long>>>& expected) {\n    if (result.size() != expected.size()) return false;\n    set<T> result_first_elements;\n    set<T> expected_first_elements;\n    for (const auto& res_entry : result) {\n        result_first_elements.insert(res_entry.first);\n        expected_first_elements.insert(res_entry.first);\n    }\n    return result_first_elements == expected_first_elements;\n}\n"], ["#include<iostream>\n    \n\n#include <cmath>\n#include <cassert>\nint next_Perfect_Square(int N) {\n    int nextN = 1 + std::floor(std::sqrt(N));\n    return nextN;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <climits>\n#include <cassert>\nusing namespace std;\n\nint max_sum(vector<int> arr, int n) {\n    vector<int> MSIBS = arr;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (arr[i] > arr[j] && MSIBS[i] < MSIBS[j] + arr[i]) {\n                MSIBS[i] = MSIBS[j] + arr[i];\n            }\n        }\n    }\n    vector<long> MSDBS = arr;\n    for (int i = 1; i <= n; ++i) {\n        MSDBS[i - 1] = MSDBS[i] + MSDBS[i - 1];\n    }\n    return *max_element(MSIBS.begin(), MSIBS.end());\n}\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble babylonian_squareroot(double number) {\n    if (0 == number) {\n        return 0;\n    }\n    double g = number / 2.0;\n    double g2 = 1 + g;\n    double g3 = 1 + g2;\n    double g4 = 1 + g3;\n    double g5 = 1 + g4;\n    double g6 = 1 + g5;\n    double g7 = 1 + g6;\n    double g8 = 1 + g7;\n    double g9 = 1 + g8;\n    double g10 = 1 + g9;\n    double g11 = 1 + g10;\n    double g12 = 1 + g11;\n    double g13 = 1 + g12;\n    double g14 = 1 + g13;\n    double g15 = 1 + g14;\n    double g16 = 1 + g15;\n    double g17 = 1 + g16;\n    double g18 = 1 + g17;\n    double g19 = 1 + g18;\n    double g20 = 1 + g19;\n    double g21 = 1 + g20;\n    double g22 = 1 + g21;\n    double g23 = 1 + g22;\n    double g24 = 1 + g23;\n    double g25 = 1 + g24;\n    double g26 = 1 + g25;\n    double g27 = 1 + g26;\n    double g28 = 1 + g27;\n    double g29 = 1 + g28;\n    double g30 = 1 + g29;\n    double g31 = 1 + g30;\n    double g32 = 1 + g31;\n    double g33 = 1 + g32;\n    double g34 = 1 + g33;\n    double g35 = 1 + g34;\n    double g36 = 1 + g35;\n    double g37 = 1 + g36;\n    double g38 = 1 +"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint lps(string str) {\n    int n = str.size();\n    vector<vector<int>> L(n, vector<int>(n, 0));\n    for (int i = 0; i < n; i = i + 1)\n        L[i][i] = 1;\n    for (int cl = 2; cl <= n; cl++) {\n        for (int i = 0; i < n - cl + 1; i++) {\n            int j = i + cl - 1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 1 + L[i + 1][j - 1];\n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]);\n        }\n    }\n    return L[0][n - 1];\n}\n"], ["\n#include <iostream>\n#include <cassert>\n#include <cmath>\n\ndouble harmonic_sum(long n) {\n    if (n < 2) {\n        return 1;\n    }\n    double sum = 0;\n    for (long i = 2; i <= n; i++) {\n        sum += 1.0 / i;\n    }\n    return sum;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n//函数定义\nstd::vector<long> intersection_array(const std::vector<int>& array_nums1, const std::vector<int>& array_nums2) {\n    std::vector<long> result;\n    std::copy_if(array_nums2.begin(), array_nums2.end(), std::back_inserter(result),\n    [](int num) { return std::find(array_nums1.begin(), array_nums1.end(), num) != array_nums1.end(); });\n    return result;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nint count_X(const std::vector<int>& tup, int x) {\n\n    /*\n    progame language:cpp\n    description:Write a cpp function to count the occcurences of an element in a tuple.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    int count = 0;\n    for (int ele : tup) {\n        if (x == ele) {\n            count++;\n        }\n    }\n    return count;\n}\n\n"], ["\n#include <vector>\n#include <iostream>\n#include <memory>\n#include <cassert>\nusing namespace std;\n\nclass Base {\npublic:\n    virtual ~Base() = default;\n    virtual bool isInteger() const = 0;\n};\n\nclass DerivedInt : public Base {\npublic:\n    DerivedInt(int value) : value(value) {}\n    bool isInteger() const override {\n        return 1;\n    }\nprivate:\n    int value;\n};\n\nclass DerivedDouble : public Base {\npublic:\n    DerivedDouble(double value) : value(value) {}\n    bool isInteger() const override {\n        return 0;\n    }\n//begin to write code\nAnswer:\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<std::vector<std::string>> combinations_colors(const std::vector<std::string>& l, int n) {\n    std::vector<std::vector<std::string>> result;\n    std::vector<int> indices(n, 0);\n    int size = l.size();\n    while (true) {\n        // Add current combination\n        std::vector<std::string> current;\n        for (int i = 0; i < n; i = i + 1) {\n            current.push_back(l[indices[i]]);\n        }\n        result.push_back(current);\n        // Generate next combination\n        int next = n - 1;\n        while (next >= 0 && indices[next] == size - 1) {\n            next = next - 1;\n        }\n        if (next < 0) {\n            break;\n        }\n        indices[next] = next + 1;\n    }\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\nint count_Primes_nums(int n) {\n    int ctr = 0;\n    for (int num = 0; num < n; ++num) {\n        if (num <= 1) {\n            continue;\n        }\n        bool is_prime = 1;\n        for (int i = 2; i < num; ++i) {\n            if (num % i == 0) {\n                is_prime = 0;\n                break;\n            }\n        }\n        if (is_prime) {\n            ctr++;\n        }\n    }\n    return ctr;\n}\n\n\n\n"], ["\n#include<iostream>\n#include <utility>\n#include <cassert>\n\nstd::pair<int, long> swap_numbers(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n    return {a, b};\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nint count_odd(const std::vector<int>& array_nums) {\n    int count = 0;\n    for (int num : array_nums) {\n        if (0 != num % 2) {\n            count++;\n        }\n    }\n    return count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<tuple<int, int>> maximize_elements(const vector<tuple<int, int>>& test_tup1, const vector<tuple<int, int>>& test_tup2) {\n    vector<tuple<int, int>> res;\n    for(size_t i = 0; i < test_tup1.size(); ++i) {\n        int first = max(get<0>(test_tup1[i]), get<0>(test_tup2[i]));\n        int second = max(get<1>(test_tup1[i]), get<1>(test_tup2[i]));\n        res.push_back(make_tuple(first, second));\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\nint newman_prime(int n) {\n    if (0 == n || 1 == n) {\n        return 1;\n    }\n    int i = 2;\n    int p = 2;\n    int q = 2;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d ="], ["\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, long, int> division_elements(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n\n    /*\n    progame language:cpp\n    description:Write a function to perform mathematical division operation across the given tuples.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n    std::get<1>(test_tup1) / std::get<1>(test_tup2),\n    std::get<2>(test_tup1) / std::get<2>(test_tup2),\n    std::get<3>(test_tup1) / std::get<3>(test_tup2)\n  );\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <utility>\n\ntemplate<typename T>\nstd::pair<std::vector<T>, std::vector<T>> split_two_parts(const std::vector<T>& list1, long L) {\n    std::vector<T> first_part(list1.begin(), list1.begin() + L);\n    std::vector<T> second_part(list1.begin() + L, list1.end());\n    return {first_part, second_part};\n}\n\n\n\n"], ["\n#include <iostream>\n#include <unordered_map>\n#include <cassert>\nstd::unordered_map<std::string, int> merge_dict(std::unordered_map<std::string, long> d1, std::unordered_map<std::string, int> d2) {\n    std::unordered_map<std::string, int> d;\n    for (const auto& pair : d1) {\n        d[pair.first] = pair.second;\n    }\n    for (const auto& pair : d2) {\n        d[pair.first] = d[pair.first] + pair.second;\n    }\n    return d;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\ntemplate <typename T>\nvector<vector<T>> list_split(vector<T> S, int step) {\n    vector<vector<T>> result(step);\n    for (int i = 0; i < step; ++i) {\n        for (int j = i; j < S.size(); j = j + (step)) {\n            result[i].push_back(S[j]);\n        }\n    }\n    return result;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\nint lateralsurface_cube(int l) {\n    int LSA = (l * l) * 4;\n    return LSA;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n// 函数定义\nint square_Sum(long n) {\n    int sum = 0;\n    for (long i = 1; i <= n; i += 2) {\n        sum += i * i;\n    }\n    return sum;\n}\n\n"], ["#include<iostream>\n    \n\n#include <cmath>\n#include <cassert>\n\nint find_star_num(long n) {\n    int star_num = 0;\n    for (int i = 1; i <= n; i++) {\n        star_num += i;\n    }\n    return star_num;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\nlong ascii_value(char k) {\n    return static_cast<long>(k);\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\n#include <vector>\n\nint sum_even_and_even_index(const std::vector<int>& arr, int n) {\n    int sum = 0;\n    for (int i = 0; i < n; i += 2) {\n        if (0 == arr[i] % 2) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\nbool compare(int r1, int r2) {\n    return r1 == r2;\n}\n"], ["\n#include <iostream>\n#include <cassert>\n\n//函数定义\nint even_Power_Sum(int n) {\n\n    /*\n    progame language:cpp\n    description:Write a cpp function to find the sum of fifth power of first n even natural numbers.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    int sum = 0;\n    for (long i = 1; i <= n; i++) {\n        sum += pow(i, 5);\n    }\n    return sum;\n}\n\nbool is_coprime(int x, int y) {\n    return gcd(x, y) == 1;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\nvector<int> rear_extract(vector<tuple<int, string, long>> test_list) {\n    vector<int> res;\n    for (auto& lis : test_list) {\n        res.push_back(get<0>(lis));\n    }\n    return res;\n}\n"], ["\n#include <iostream>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, int> substract_elements(const std::tuple<long, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n    std::get<1>(test_tup1) - std::get<1>(test_tup2),\n    std::get<2>(test_tup1) - std::get<2>(test_tup2));\n}\n\n\n\n"], ["\n#include <iostream>\n#include <map>\n#include <cassert>\n\nlong even_binomial_Coeff_Sum(int n) {\n    long sum = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 2 == 0) {\n            sum += binomial_coefficient(n, i);\n        }\n    }\n    return sum;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cmath> // for ceil\nusing namespace std;\n\nint get_Position(vector<int>& a, int n, int m) {\n    for (int i = 0; i < n; i = i + 1) {\n        a[i] = (a[i] / m + (a[i] % m != 0));\n    }\n    int result = -1, maxx = -1;\n    for (int i = n - 1; i >= 0; --i) {\n        if (a[i] > maxx) {\n            maxx = a[i];\n            result = i;\n        }\n    }\n    return result;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <cmath>\n\ndouble volume_cylinder(double r, double h) {\n    double volume = h * r * 3.1415 * r;\n    return volume;\n}\n\n\n\n"], ["#include<iostream>\n#include <map>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nmap<string, int> dict_filter(const map<string, int>& input_dict, long n) {\n    map<string, int> result;\n    for (auto const& pair : input_dict) {\n        if (pair.second >= n) {\n            result[pair.first] = pair.second;\n        }\n    }\n    return result;\n}\n"], ["\n#include <iostream>\n#include <tuple>\n#include <vector>\n#include <cassert>\n#include <type_traits>\nusing namespace std;\ntemplate <size_t Index, typename Tuple>\nint count_first_elements_helper(const Tuple& t, true_type) {\n\n    /*\n    progame language:cpp\n    description:Write a function to find the element count that occurs before the record in the given tuple.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    return 0;\n}\ntemplate <size_t Index, typename Tuple>\nlong count_first_elements_helper(const Tuple& t, false_type) {\n//begin to write code\nAnswer:\n"], ["\n#include <iostream>\n#include <cassert>\n\nint is_num_decagonal(long n) {\n    //begin to write code\n    return 0;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool sequential_search(const std::vector<int>& dlist, int item, int& pos) {\n    pos = 0;\n    while (pos < dlist.size()) {\n        if (dlist[pos] == item) {\n            return 1;\n        }\n        pos++;\n    }\n    return 0;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool all_unique(const std::vector<int>& test_list) {\n    std::set<long> unique_elements(test_list.begin(), test_list.end());\n    if (test_list.size() > unique_elements.size()) {\n        return false;\n    }\n    return true;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<long> sub_list(const vector<int>& nums1, const vector<int>& nums2) {\n    map<int, int> num_map;\n    for (const auto& num : nums1) {\n        num_map[num]++;\n    }\n    for (const auto& num : nums2) {\n        num_map[num]--;\n    }\n    vector<long> result;\n    for (const auto& num : num_map) {\n        result.push_back(num.first * num.second);\n    }\n    return result;\n}\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool validate(int n) {\n    for (int i = 0; i < 10; i++) {\n        int temp = n;\n        int count = 0;\n        while (temp) {\n            if (i == temp % 10) {\n                count++;\n            }\n            temp /= 10;\n        }\n        if (count > i) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (element != item) {\n            return false;\n        }\n    }\n    return true;\n}\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nlong max_sub_array_sum_repeated(vector<int> a, int n, int k) {\n    int max_so_far = -2147483648;\n    int max_ending_here = 0;\n    for (int i = 0; i < n * k; ++i) {\n        max_ending_here = max_ending_here + a[i % n];\n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint square_Sum(long n) {\n    int sum = 0;\n    for (long i = 1; i <= n; i += 2) {\n        sum += i * i;\n    }\n    return sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong modular_inverse(const std::vector<int>& arr, int N, int P) {\n    long current_element = 0;\n    for (int i = 0; i < N; ++i) {\n        if ((arr[i] * arr[i]) % P == 1) {\n            current_element = arr[i];\n        }\n    }\n    return current_element;\n}\n\n\n\n"], ["\n\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nint odd_Days(int N) {\n    int hund1 = N / 100;\n    int hund4 = N / 400;\n    int leap = N >> 2;\n    int ordd = N - leap;\n    if (hund1) {\n        ordd = ordd + (hund1);\n        leap = leap - (hund1);\n    }\n    return ordd;\n}\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nstd::pair<int, std::vector<int>> max_length(const std::vector<std::vector<int>>& list1) {\n    long max_length = 0;\n    std::vector<int> max_list;\n    for (const auto& x : list1) {\n        if (x.size() > max_length) {\n            max_length = x.size();\n            max_list = x;\n        }\n    }\n    return std::make_pair(max_length, max_list);\n}\n"], ["\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint count_no_of_ways(int n, int k) {\n    vector<int> dp(n + 1, 0);\n    const int mod = 1000000007;\n    dp[1] = k;\n    dp[2] = k * k;\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = (dp[i - 1] + dp[i - 2] * k) % mod;\n    }\n    return dp[n];\n}\n\n"], ["#include <iostream>\n#include <cassert>\nint find(int n, int m) {\n    long q = n / m;\n    return q;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <algorithm>\n#include <limits>\nusing namespace std;\n\nint max_val(const vector<long>& listval) {\n    int max = numeric_limits<int>::min();\n    for (int i = 0; i < listval.size(); i++) {\n        if (listval[i] > max) {\n            max = listval[i];\n        }\n    }\n    return max;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <numeric>\nlong sum_div(int number) {\n    std::vector<int> divisors = {1};\n    for (int i = 2; i < number; ++i) {\n        if (number % i == 0) {\n            divisors.push_back(i);\n        }\n    }\n    return std::accumulate(divisors.begin(), divisors.end(), 0L);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nint get_Inv_Count(vector<int> arr, int n) {\n    int inv_count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 1 + i; j < n; j++) {\n            if (arr[i] > arr[j]) {\n                inv_count++;\n            }\n        }\n    }\n    return inv_count;\n}\n\n"], ["\n\n#include <vector>\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nclass Variant {\npublic:\n    virtual ~Variant() = default;\n    virtual bool is_int() const = 0;\n    virtual bool is_vector() const = 0;\n    virtual int get_int() const = 0;\n    virtual const vector<Variant*>& get_vector() const = 0;\n};\n\nclass IntVariant : public Variant {\npublic:\n    IntVariant(int value) : value(value) {}\n    bool is_int() const override { return 1; }\n    bool is_vector() const override { return 0; }\n    int get_int() const override { return value; }\n    const vector<Variant*>& get_vector() const override { throw runtime_error(\"Not a vector\"); }\nprivate:\n    int value;\n};\n\nclass VectorVariant : public Variant {\npublic:\n    VectorVariant(const vector<Variant*>& value) : value(value) {}\n    bool is_int() const override { return 0; }\n    bool is_vector() const override { return 1; }\n    int get_int() const override { throw runtime_error(\"Not an int\"); }\n    const vector<Variant*>& get_vector() const override { return value; }\nprivate:\n    vector<Variant*> value;\n};\n\nvoid flatten_list(const vector<Variant*>& list1, vector<int>& result_list) {\n\n    /*\n    progame language:cpp\n    description:Write a function to flatten a given nested list structure.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    for (const auto& element : list1) {\n        if (element->is_int()) {\n            result_list.push_back(element->get_int());\n        } else if (element->is_vector()) {\n            flatten_list(element->get_vector(), result_list);\n        }\n    }\n}\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\n\ntemplate<typename T>\nvector<vector<T>> intersection_nested_lists(const vector<T>& l1, const vector<vector<T>>& l2) {\n    vector<vector<T>> result;\n    for (const auto& lst : l2) {\n        vector<T> temp;\n        for (const auto& n : lst) {\n            if (l1.end() != find(l1.begin(), l1.end(), n)) {\n                temp.push_back(n);\n            }\n        }\n        result.push_back(temp);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <cassert>\nusing namespace std;\n\npair<string, long> max_aggregate(const vector<pair<string, int>>& stdata) {\n    map<string, int> temp;\n    for (const auto& item : stdata) {\n        temp[item.first] += item.second;\n    }\n    pair<string, int> max_item = *temp.begin();\n    for (const auto& item : temp) {\n        if (item.second > max_item.second) {\n            max_item = item;\n        }\n    }\n    return max_item;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\ndouble count_binary_seq(long n) {\n    double nCr = 1;\n    double res = 1;\n    for(int r = 1; r <= n; ++r) {\n        nCr *= r;\n        nCr /= (r - n);\n        res *= nCr;\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <unordered_map>\n#include <cassert>\nusing namespace std;\n\nclass Variant {\npublic:\n    virtual ~Variant() = default;\n};\n\nclass IntVariant : public Variant {\npublic:\n    IntVariant(long value) : value(value) {}\n    int get_int() const {\n        return this->value;\n    }\nprivate:\n    int value;\n};\n\nclass MapVariant : public Variant {\npublic:\n    MapVariant(const std::unordered_map<char, Variant*>& map) : map(map) {}\n    const std::unordered_map<char, Variant*>& get_map() const {\n        return this->map;\n    }\nprivate:\n    std::unordered_map<char, Variant*> map;\n};\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint set_Bit_Number(long n) {\n    if (n == 0) {\n        return 0;\n    }\n    int msb = 0;\n    while (n != 0) {\n        msb++;\n        n >>= 1;\n    }\n    return msb;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <limits>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nbool solve(int a[], int n) {\n    int mx = numeric_limits<int>::min();\n    for (long j = 1; j < n; j++) {\n        if (mx > a[j]) {\n            return false;\n        }\n        mx = max(mx, a[j]);\n    }\n    return true;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nlong find_Element(const std::vector<int>& arr, const std::vector<std::pair<int, int>>& ranges, int rotations, int index) {\n    for (int i = rotations - 1; i >= 0; --i) {\n        int left = ranges[i].first;\n        int right = ranges[i].second;\n        if (left <= index && right >= index) {\n            if (index == left) {\n                index = right;\n                break;\n            }\n        }\n    }\n    return arr[index];\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nlong max_sum_increasing_subseq(vector<int> a, int n, int index, int k) {\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    for (int i = 0; i < n; ++i) {\n        if (a[i] > a[0]) {\n            dp[0][i] = a[i] + a[0];\n        } else {\n            dp[0][i] = a[i];\n        }\n    }\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (a[j] > a[i] && j > i) {\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + a[i]);\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    return dp[n - 1][n - 1];\n}\n\n"], ["#include <iostream>\n#include <tuple>\n#include <vector>\n#include <cassert>\nstd::tuple<std::string, int, std::vector<int>, bool> colon_tuplex(std::tuple<std::string, int, std::vector<int>, bool> tuplex, int m, int n) {\n    std::tuple<std::string, int, std::vector<long>, bool> tuplex_colon = tuplex;\n    std::string colon = std::get<0>(tuplex_colon);\n    int colon_int = std::get<1>(tuplex_colon);\n    std::vector<int> colon_vector = std::get<2>(tuplex_colon);\n    bool colon_bool = std::get<3>(tuplex_colon);\n    return std::make_tuple(colon, colon_int, colon_vector, colon_bool);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> large_product(const std::vector<int>& nums1, const std::vector<int>& nums2, int N) {\n    std::vector<int> products;\n    for (int x : nums1) {\n        for (int y : nums2) {\n            products.push_back(y * x);\n        }\n    }\n    std::sort(products.begin(), products.end(), std::greater<int>());\n    return products;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint maximum(int a, long b) {\n    if (a >= b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\nint set_left_most_unset_bit(int n) {\n    if (!(n & (n + 1))) {\n        return n;\n    }\n    long pos = 0, temp = n, count = 0;\n    while (temp) {\n        if (!(temp & 1)) {\n            pos = temp;\n            count++;\n        }\n        temp >>= 1;\n    }\n    return pos;\n}\n\n\n\n"], ["#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble volume_cone(double r, double h) {\n    double volume = h * (1.0/3) * M_PI * r * r;\n    return volume;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> pos_nos(const std::vector<long>& list1) {\n    std::vector<int> result;\n    for (long num : list1) {\n        if (num >= 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nint max_sum_rectangular_grid(vector<vector<int>>& grid, int n) {\n    int incl = max(grid[0][0], grid[1][0]);\n    long excl = 0;\n    for (int i = 1; i < n; ++i) {\n        int excl_new = max(excl, incl);\n        incl = max(incl + grid[i][0], grid[i][1]);\n        excl = excl_new;\n    }\n    return incl;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\n\nstd::string find_Max_Len_Even(const std::string& str) {\n    int n = str.length();\n    int i = 0;\n    int currlen = 0;\n    int maxlen = 0;\n    int st = -1;\n    while (i < n) {\n        if (' ' == str[i]) {\n            if (0 == currlen % 2) {\n                if (maxlen < currlen) {\n                    maxlen = currlen;\n                    st = i - currlen;\n                }\n            }\n            currlen = 0;\n            i++;\n        } else {\n            currlen++;\n            i++;\n        }\n    }\n    return str.substr(st, maxlen);\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nint find_last_occurrence(const vector<int>& A, int x) {\n    int left = 0;\n    int right = A.size() - 1;\n    int result = -1;\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (A[mid] == x) {\n            result = mid;\n            right = mid - 1;\n        } else if (A[mid] < x) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return result;\n}\n"], ["#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n// 基类\nclass Element {\npublic:\n    virtual ~Element() = default;\n    virtual Element* clone() const = 0;\n    virtual void print() const = 0;\n    virtual bool isSameType(const Element& other) const = 0;\n    virtual bool isInt() const = 0;\n    virtual bool isChar() const = 0;\n    virtual int getIntValue() const = 0;\n    virtual char getCharValue() const = 0;\n};\n// 处理 char 类型的子类\nclass CharElement : public Element {\npublic:\n    CharElement(char value) : value_(value) {}\n    Element* clone() const override {\n        return new CharElement(*this);\n    }\n    void print() const override {\n        std::cout << \"Char: \" << value_ << std::endl;\n    }\n    bool isSameType(const Element& other) const override {\n        return other.isChar();\n    }\n    bool isInt() const override { return 0; }\n    bool isChar() const override { return 1; }\n    int getIntValue() const override {\n         return 0; \n    }\n    char getCharValue() const override { return value_; }\nprivate:\n    char value_;\n};\n// 处理 int 类型的子类\nclass IntElement : public Element {\npublic:\n    IntElement(int value) : value_(value) {}\n    Element* clone() const override {\n        return new IntElement(*this);\n    }\n    void print() const override {\n        std::cout << \"Int: \" << value_ << std::endl;\n    }\n    bool isSameType(const Element& other) const override {\n        return other.isInt();\n    }\n    bool isInt() const override { return 1; }\n    bool isChar() const override { return 0; }\n    int getIntValue() const override { return value_; }\n    char getCharValue() const override { \n//begin to write code\nAnswer:\n"], ["\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint max_volume(int s) {\n    int maxvalue = 0;\n    for(long i = 1; i < s; ++i) {\n        for(int j = 1; j < s; ++j) {\n            int k = s - i - j;\n            if(k > maxvalue) {\n                maxvalue = k;\n            }\n        }\n    }\n    return maxvalue;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\nint sum_difference(int n) {\n\n    /*\n    progame language:cpp\n    description:Write a function to calculate the difference between the squared sum of first n natural numbers and the sum of squared first n natural numbers.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    int sumofsquares = 0;\n    int squareofsum = 0;\n    for (int num = 1; num <= n; num++) {\n        sumofsquares = sumofsquares + (num * num);\n        squareofsum = squareofsum + (num * num);\n    }\n    return squareofsum - sumofsquares;\n}\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string find_demlo(const std::string& s) {\n    int l = s.size();\n    std::string res = \"\";\n    for (int i = 1; i <= l; ++i) {\n        res = res + (std::to_string(i));\n    }\n    return res;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> position_min(const std::vector<int>& list1) {\n    int min_val = *std::min_element(list1.begin(), list1.end());\n    std::vector<int> min_result;\n    for (int i = 0; i < list1.size(); i++) {\n        if (min_val == list1[i]) {\n            min_result.push_back(i);\n        }\n    }\n    return min_result;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nvoid right_rotate(std::vector<int>& arr, long n, int out_of_place, int cur) {\n    int temp = arr[cur];\n    for (int i = cur; i > out_of_place; --i) {\n        arr[i] = arr[i - 1];\n    }\n    arr[out_of_place] = temp;\n}\nstd::vector<int> re_arrange(std::vector<int>& arr, int n) {\n\n    /*\n    progame language:cpp\n    description:Write a function to re-arrange the given array in alternating positive and negative items.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    int out_of_place = -1;\n    for (int index = 0; index < n; ++index) {\n        if (out_of_place >= 0) {\n            if ((arr[index] >= 0 && arr[out_of_place] < 0) ||\n                (arr[index] < 0 && arr[out_of_place] >= 0)) {\n                right_rotate(arr, n, out_of_place, index);\n                if (index - out_of_place > 2) {\n//begin to write code\nAnswer:\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nstd::pair<long, int> sum_of_alternates(const std::vector<int>& test_vector) {\n    int sum1 = 0;\n    int sum2 = 0;\n    for (size_t idx = 0; idx < test_vector.size(); ++idx) {\n        if (idx % 2 == 1) {\n            sum1 += test_vector[idx];\n        } else {\n            sum2 += test_vector[idx];\n        }\n    }\n    return std::make_pair(sum1, sum2);\n}\n\n\n\n"], ["#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\nlong get_Min_Squares(int n) {\n    if (n <= 3) {\n        return n;\n    }\n    int res = n;\n    for (int x = 1; x <= n; ++x) {\n        int temp = x * x;\n        res = std::min(res, temp + get_Min_Squares(n - temp));\n    }\n    return res;\n}\n\n\n\n"], ["#include <iostream>\n#include <sstream>\n#include <unordered_map>\n#include <cassert>\n#include <vector>\nusing namespace std;\n\nstring most_occurrences(vector<string> test_list) {\n    unordered_map<string, long> temp;\n    for (auto& sub : test_list) {\n        stringstream ss(sub);\n        string wrd;\n        while (ss >> wrd) {\n            temp[wrd]++;\n        }\n    }\n    string max_word = \"\";\n    long max_count = 0;\n    for (auto& pair : temp) {\n        if (pair.second > max_count) {\n            max_count = pair.second;\n            max_word = pair.first;\n        }\n    }\n    return max_word;\n}\n\n"], ["#include<cassert>\n#include <iostream>\n#include <assert.h>\nbool check_isosceles(int x, int y, int z) {\n    if (y == x || z == y || x == z) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<int> rotate_left(vector<int> list1, int m, long n) {\n    vector<int> result;\n    result.insert(result.end(), list1.begin() + m, list1.end());\n    return result;\n}\n\n\n\n"], ["\n#include<iostream>\n#include<vector>\n#include<cassert>\nint neg_count(const std::vector<long>& list) {\n    int neg_count = 0;\n    for (int num : list) {\n        if (num <= 0) {\n            neg_count++;\n        }\n    }\n    return neg_count;\n}\n\n\n\n"], ["#include <iostream>\n\nint count_unset_bits(int n) {\n    long count = 0;\n    int x = 1;\n    while (x < n + 1) {\n        if ((x & n) == 0) {\n            count++;\n        }\n        x <<= 1;\n    }\n    return count;\n}\n"], ["\n#include <iostream>\n#include <map>\n#include <cassert>\nstd::map<char, int> char_frequency(std::string str1) {\n    std::map<char, int> dict;\n    for (char n : str1) {\n        if (dict.end() != dict.find(n)) {\n            dict[n] += 1;\n        } else {\n            dict[n] = 1;\n        }\n    }\n    return dict;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvoid Sort(vector<pair<string, int>>& sub_li) {\n    sort(sub_li.begin(), sub_li.end(), [](const pair<string, int>& a, const pair<string, long>& b) {\n        return a.second < b.second;\n    });\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool check_Validity(int a, int b, int c) {\n    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint ap_sum(int a, int n, long d) {\n    int total = (n * (2 * a + (n - 1) * d)) / 2;\n    return total;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\nbool check_monthnum(std::string monthname1) {\n    if (monthname1 == \"February\") {\n        return 1;\n    }\n    return 0;\n}\n\n\n\n"], ["#include <iostream>\n#include <string>\n#include <cassert>\nbool check_Equality(const std::string& s) {\n    return s.front() == s.back();\n}\nlong count_Substring_With_Equal_Ends(const std::string& s) {\n\n    /*\n    progame language:cpp\n    description:Write a cpp function to count the number of substrings with same first and last characters.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    int result = 0;\n    int n = s.length();\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == s[n - 1]) {\n            result++;\n        }\n    }\n    return result;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n// 函数定义\nint find_Divisor(int x, int y) {\n    if (y == x) {\n        return x;\n    }\n    int res = 0;\n    for (int i = 1; i <= y; i++) {\n        if (x % i == 0) {\n            res = i;\n            break;\n        }\n    }\n    return res;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nint sum_three_smallest_nums(std::vector<int> lst) {\n    std::vector<int> positive_nums;\n    for (long x : lst) {\n        if (x > 0) {\n            positive_nums.push_back(x);\n        }\n    }\n    std::sort(positive_nums.begin(), positive_nums.end());\n    return std::accumulate(positive_nums.begin(), positive_nums.begin() + 3, 0);\n}\n\n\n\n"], ["#include<iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<int> set_to_tuple(const set<long>& s) {\n    vector<int> t(s.begin(), s.end());\n    return t;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <cassert>\nusing namespace std;\nclass Node {\npublic:\n    int value;\n    int list_num;\n    int index;\n    Node(long value, int list_num, int index) : value(value), list_num(list_num), index(index) {}\n    bool operator<(const Node& other) const {\n        return value > other.value; // Use greater to simulate min heap in priority queue\n    }\n};\npair<int, int> find_minimum_range(vector<vector<int>>& lists) {\n\n    int high = numeric_limits<int>::min();\n    pair<int, int> p = make_pair(0, numeric_limits<int>::max());\n    priority_queue<Node> pq;\n    for (int i = 0; i < lists.size(); ++i) {\n        pq.push(Node(lists[i][0], i, 0));\n        high = max(high, lists[i][0]);\n//begin to write code\nAnswer:\n"], ["#include <iostream>\n#include <cctype>\n#include <cassert>\nstd::pair<int, long> dig_let(const std::string& s) {\n    int d = 0, l = 0;\n    for (char c : s) {\n        if (isdigit(c)) {\n            d++;\n        } else if (isalpha(c)) {\n            l++;\n        }\n    }\n    return std::make_pair(d, l);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint count_Odd_Squares(long n, int m) {\n    int count = 0;\n    for (long i = n; i <= m; i++) {\n        if (i % 2 != 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<int> diff_consecutivenums(const vector<int>& nums) {\n    vector<int> result;\n    for (long i = 1; i < nums.size(); i++) {\n        result.push_back(nums[i] - nums[i - 1]);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint zigzag(int n, long k) {\n    if (n == 0 && k == 0) {\n        return 1;\n    }\n    int result = 1;\n    for (int i = 1; i <= n; i++) {\n        result = (result + k) % i;\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\nlong count_Squares(int m, int n) {\n    if (n < m) {\n        int temp = m;\n        m = n;\n    }\n    long count = 0;\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i * i + j * j == m * m) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint bin_coff(int n, int r) {\n    int val = 1;\n    if (r > (n - r)) {\n        r = n - r;\n    }\n    for (int i = 0; i < r; ++i) {\n        val *= (n - i);\n        val /= (1 + i);\n    }\n    return val;\n}\n\n\n\n"], ["#include <string>\n#include <set>\n#include <iostream>\n#include <cassert>\nstd::string check(const std::string& string) {\n    std::set<char> p(string.begin(), string.end());\n    std::set<char> s = {'0', '1'};\n    if (p == s || std::set<char>{'0'} == p || std::set<char>{'1'} == p) {\n        return \"Binary\";\n    } else {\n        return \"Not a binary string\";\n    }\n}\n"], ["\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\nint minimum_Length(std::string s) {\n    int maxOcc = 0;\n    int n = s.length();\n    std::vector<int> arr(26, 0);\n    for (int i = 0; i < n; i = i + 1) {\n        arr[s[i] - 'a']++;\n    }\n    for (int i = 0; i < 26; i = i + 1) {\n        if (arr[i] > maxOcc) {\n            maxOcc = arr[i];\n        }\n    }\n    return n - maxOcc;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nusing namespace std;\n\nint first_Element(const vector<int>& arr, int n, int k) {\n    std::map<int, int> count_map;\n    for (int i = 0; i < n; ++i) {\n        if (count_map.find(arr[i]) != count_map.end()) {\n            count_map[arr[i]] = count_map[arr[i]] + (1);\n        } else {\n            count_map[arr[i]] = 1;\n        }\n    }\n    for (auto it = count_map.begin(); it != count_map.end(); ++it) {\n        if (it->second == k) {\n            return it->first;\n        }\n    }\n    return -1;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nbool unique_Characters(std::string str) {\n    for (int i = 0; i < str.length(); i++) {\n        for (long j = i + 1; j < str.length(); j++) {\n            if (str[i] == str[j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<std::vector<int>> remove_column(std::vector<std::vector<long>>& list1, int n) {\n    for (auto& row : list1) {\n        row.erase(row.begin() + n);\n    }\n    return list1;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <cassert>\n\n//函数定义\nint tn_ap(int a, int n, long d) {\n    return a + (n - 1) * d;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nint count_Rectangles(int radius) {\n    int rectangles = 0;\n    int diameter = radius * 2;\n    int diameterSquare = diameter * diameter;\n    for (int a = 1; a < radius * 2; a++) {\n        for (int b = 1; b < radius * 2; b++) {\n            int diagnalLengthSquare = (a * a + b * b);\n            if (diagnalLengthSquare == diameterSquare) {\n                rectangles++;\n            }\n        }\n    }\n    return rectangles;\n}\n\n\n\n"], ["#include<iostream>\n#include <cassert>\n//函数定义\nint find_angle(long a, int b) {\n    // Your code here\n    return 0;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nlong find_max(const std::vector<std::vector<int>>& test_list) {\n    int res = 0;\n    for (const auto& sublist : test_list) {\n        for (int num : sublist) {\n            res = std::max(res, num);\n        }\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> moddiv_list(const std::vector<int>& nums1, const std::vector<long>& nums2) {\n    std::vector<int> result;\n    for (size_t i = 0; i < nums1.size(); ++i) {\n        result.push_back(nums1[i] % nums2[i]);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include<iostream>\n#include<string>\n#include<cassert>\nstd::string Check_Solution(long a, int b, int c) {\n    if (2 * b * b == 9 * a * c) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\nlong long get_carol(long n) {\n    long long result = pow(2, n) - 1;\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nint max_occurrences(vector<int> nums) {\n    int max_val = 0;\n    long result = nums[0];\n    for (int i : nums) {\n        int occu = count(nums.begin(), nums.end(), i);\n        if (occu > max_val) {\n            max_val = occu;\n            result = i;\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\nvector<tuple<int, int, int>> add_K_element(vector<tuple<int, int, long>> test_list, int K) {\n    vector<tuple<int, int, int>> res;\n    for (auto &sub : test_list) {\n        int a, b, c;\n        tie(a, b, c) = sub;\n        res.push_back(make_tuple(a + K, b + K, c + K));\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nchar make_flip(char ch) {\n    return '0' == ch ? '1' : '0';\n}\n\nint get_flip_with_starting_charcter(string str, char expected) {\n    int flip_count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        if (expected != str[i]) {\n            flip_count++;\n        }\n    }\n    return flip_count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint count_Digit(int n) {\n    int count = 0;\n    while (n != 0) {\n        n = n / 10;\n        count++;\n    }\n    return count;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <climits>\nusing namespace std;\n\nint adjacent_num_product(const vector<int>& list_nums) {\n    long max_product = INT_MIN;\n    for (size_t i = 0; i < list_nums.size() - 1; ++i) {\n        long product = list_nums[i] * list_nums[i + 1];\n        if (product > max_product) {\n            max_product = product;\n        }\n    }\n    return max_product;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(long value) : data(value), left(nullptr), right(nullptr) {}\n};\n\nint get_height(Node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return max(get_height(root->left), get_height(root->right)) + 1;\n}\n\n"], ["#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nusing namespace std;\n\nvector<tuple<int, int>> repeat_tuples(tuple<int, int> test_tup, long N) {\n    vector<tuple<int, int>> res(N, test_tup);\n    return res;\n}\n"], ["#include <iostream>\n#include <cassert>\nint lateralsurface_cuboid(int l, int w, long h) {\n    int LSA = 2 * h * (l + w);\n    return LSA;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n    });\n    return items;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint smallest_missing(const std::vector<int>& A, long left_element, int right_element) {\n    if (left_element > right_element) {\n        return left_element;\n    }\n    int mid = left_element + (right_element - left_element) / 2;\n    if (A[mid] == mid) {\n        return smallest_missing(A, mid + 1, right_element);\n    } else {\n        return smallest_missing(A, left_element, mid);\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<int> heap_assending(vector<long> nums) {\n    make_heap(nums.begin(), nums.end());\n    return nums;\n}\n\n\n\n"], ["#include<cassert>\n#include<iostream>\n#include<assert.h>\n//函数定义\nlong volume_cuboid(int l, int w, int h) {\n    long volume = l * w * h;\n    assert(volume > 0);\n    return volume;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<string> permute_string(string str) {\n    if (str.length() == 0) {\n        return vector<string> {\"\"};\n    }\n    vector<string> prev_list = permute_string(str.substr(1));\n    vector<string> next_list;\n    for (long i = 0; i < prev_list.size(); i++) {\n        for (size_t j = 0; j <= str.length() - 1; j++) {\n            string temp = prev_list[i];\n            temp.insert(j, 1, str[j]);\n            next_list.push_back(temp);\n        }\n    }\n    return next_list;\n}\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint round_num(int n, long m) {\n    int a = (n / m) * m;\n    if (n - a >= m / 2)\n        return a + m;\n    else\n        return a;\n}\n\n\n\n"], ["\n\n#include <iostream>\n#include <vector>\n#include <set>\n#include <tuple>\n#include <cassert>\n#include <typeinfo>\n#include <string>\n#include <stdexcept>\nusing namespace std;\nclass Element {\npublic:\n    virtual ~Element() = default;\n    virtual bool is_int() const = 0;\n    virtual bool is_string() const = 0;\n    virtual int get_int() const = 0;\n    virtual string get_string() const = 0;\n};\n// 派生类 IntElement\nclass IntElement : public Element {\npublic:\n    IntElement(int value) : value_(value) {}\n    bool is_int() const override {\n        return 1;\n    }\n    bool is_string() const override {\n        return 0;\n    }\n    int get_int() const override {\n        return value_;\n    }\n    string get_string() const override {\n        throw runtime_error(\"Not a string\");\n    }\nprivate:\n    int value_;\n};\n// 派生类 StringElement\nclass StringElement : public Element {\npublic:\n    StringElement(const string& value) : value_(value) {}\n    bool is_int() const override {\n        return 0;\n    }\n    bool is_string() const override {\n        return 1;\n    }\n    int get_int() const override {\n        throw runtime_error(\"Not an integer\");\n    }\n    string get_string() const override {\n        return value_;\n    }\nprivate:\n    string value_;\n};\nstruct ElementComparator {\n    bool operator()(const Element* lhs, const Element* rhs) const {\n        if (lhs->is_int() && rhs->is_int()) {\n            return lhs->get_int() < rhs->get_int();\n        } else if (lhs->is_string() && rhs->is_string()) {\n            return lhs->get_string() < rhs->get_string();\n        } else {\n            return false;\n        }\n    }\n};\n\n"], ["\n#include <vector>\n#include <cassert>\n#include <iostream>\nstd::vector<int> move_first(std::vector<int> test_list) {\n    if (!test_list.empty()) {\n        long last = test_list.back();\n        test_list.pop_back();\n        test_list.insert(test_list.begin(), last);\n    }\n    return test_list;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nint surfacearea_cuboid(int l, int w, int h) {\n    int SA = (w * l + h * l + h * w) * 2;\n    return SA;\n}\n"], ["\n\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<vector<int>> multi_list(int rownum, long colnum) {\n    vector<vector<int>> multi_list(rownum, vector<int>(colnum, 0));\n    for (int row = 0; row < rownum; ++row) {\n        for (int col = 0; col < colnum; ++col) {\n            multi_list[row][col] = row * col;\n        }\n    }\n    return multi_list;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\ntypedef tuple<string, long, int> TupleType;\n// Function to sort a vector of tuples based on the specified index within the inner tuples\nvector<TupleType> index_on_inner_list(vector<TupleType> list_data, int index_no) {\n    sort(list_data.begin(), list_data.end(), [index_no](const TupleType &a, const TupleType &b) {\n        if (index_no == 0) return get<0>(a) < get<0>(b);\n        return get<index_no - 1>(a) < get<index_no - 1>(b);\n    });\n    return list_data;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_rotation_count(const vector<int>& A) {\n    int left = 0, right = A.size() - 1;\n    while (left <= right) {\n        if (A[left] <= A[right]) {\n            return left;\n        }\n        int mid = (left + right) / 2;\n        int next = (1 + mid) % A.size();\n        int prev = (mid - 1 + A.size()) % A.size();\n        if (A[mid] <= A[next] && A[mid] <= A[prev]) {\n            return mid;\n        }\n        if (A[mid] <= A[right]) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return -1;\n}\n\n\n\n"], ["#include <iostream>\n#include <cassert>\nint even_bit_toggle_number(int n) {\n    long res = 0, count = 0, temp = n;\n    while(temp > 0) {\n        if (count % 2 == 0) {\n            res = res | (1 << count);\n        }\n        count++;\n        temp = temp >> 1;\n    }\n    return res;\n}\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nint frequency_Of_Smallest(int n, std::vector<int> arr) {\n    int mn = arr[0];\n    int freq = 1;\n    for (long i = 1; i < n; i++) {\n        if (arr[i] < mn) {\n            mn = arr[i];\n            freq = 1;\n        } else if (arr[i] == mn) {\n            freq++;\n        }\n    }\n    return freq;\n}\n"], ["#include <iostream>\n#include <cassert>\n// 函数定义\nlong get_perrin(int n) {\n    if (n == 0) {\n        return 3;\n    }\n    if (n == 1) {\n        return 2;\n    }\n    return get_perrin(n - 1) + get_perrin(n - 2);\n}\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\nint swap_count(const std::string& s) {\n    const char* chars = s.c_str();\n    int count_left = 0;\n    int count_right = 0;\n    int swap = 0;\n    int imbalance = 0; \n    for (size_t i = 0; i < s.length(); i++) {\n        if ('[' == chars[i]) {\n            count_left += 1;\n            if (imbalance > 0) {\n                count_right += 1;\n                if (count_left == count_right) {\n                    swap += 1;\n                    imbalance -= 1;\n                }\n            }\n        } else if (']' == chars[i]) {\n            count_right += 1;\n            if (imbalance > 0) {\n                count_left += 1;\n                if (count_left == count_right) {\n                    swap += 1;\n                    imbalance -= 1;\n                }\n            }\n        }\n    }\n    return swap;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nstring even_or_odd(const string& N) {\n    long l = N.length();\n    char last_char = N[l - 1];\n    if (last_char == '0' || last_char == '2' ||\n        last_char == '4' || last_char == '6' ||\n        last_char == '8' || last_char == 'A' ||\n        last_char == 'C' || last_char == 'E' ||\n        last_char == 'G' || last_char == 'I' ||\n        last_char == 'M' || last_char == 'O' ||\n        last_char == 'Q' || last_char == 'U' ||\n        last_char == 'W' || last_char == 'Y' ||\n        last_char == 'a' || last_char == 'c' ||\n        last_char == 'e' || last_char == 'g' ||\n        last_char == 'i' || last_char == 'k' ||\n        last_char == 'm' || last_char == 'q' ||\n        last_char == 'u' || last_char == 'w' ||\n        last_char == 'y' || last_char == 'A' ||\n        last_char == 'C' || last_char == 'E' ||\n        last_char == 'G' || last_char == 'I' ||\n        last_char == 'M' || last_char == 'O' ||\n        last_char == 'Q' || last_char == 'U' ||\n        last_char == 'W' || last_char == 'Y' ||\n        last_char == 'a' || last_char == 'c' ||\n        last_char == 'e' || last_char == 'g' ||\n        last_char == 'i' || last_char == 'k' ||\n        last_char == 'm' || last_char == 'q' ||\n        last_char == 'u' || last_char == 'w' ||\n        last_char == 'y' || last_char == 'A' ||\n        last_char == 'C' || last_char == 'E' ||\n        last_char == 'G' || last_char == 'I' ||\n        last_char == 'M' || last_char == 'O' ||\n        last_char == 'Q' || last_char == 'U' ||\n        last_char == 'W' || last_char == 'Y' ||\n        last_char == 'a' || last_char == 'c"], ["\n#include <iostream>\n// 函数定义\nint highest_Power_of_2(int n) {\n    int res = 0;\n    for (long i = n; i > 0; i--) {\n        if ((i & (i - 1)) == 0) {\n            res = i;\n            break;\n        }\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nint find_lucas(long n) {\n    if (n == 0) {\n        return 2;\n    }\n    int a = 2;\n    int b = 1;\n    for (int i = 2; i < n; i++) {\n        int c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <cassert>\nstd::vector<std::map<std::string, std::map<std::string, int>>> convert_list_dictionary(const std::vector<std::string> &l1, const std::vector<std::string> &l2, const std::vector<long> &l3) {\n    std::vector<std::map<std::string, std::map<std::string, int>>> result;\n    for (size_t i = 0; i < l1.size(); ++i) {\n        std::map<std::string, std::map<std::string, int>> temp;\n        for (size_t j = 0; j < l2.size(); ++j) {\n            std::map<std::string, int> temp2;\n            for (size_t k = 0; k < l3.size(); ++k) {\n                temp2[l3[k]] = l2[j][l3[k]];\n            }\n            temp[l1[i]] = temp2;\n        }\n        result.push_back(temp);\n    }\n    return result;\n}\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\nint get_max_sum(int n) {\n    std::vector<long> res;\n    res.push_back(0);\n    res.push_back(1);\n    for (int i = 2; i <= n; i++) {\n        long max_sum = std::max(res[0] + res[1], res[1]);\n        res[0] = res[1];\n        res[1] = max_sum;\n    }\n    return res[1];\n}\n"], ["#include <vector>\n#include <iostream>\n#include <cassert>\nstd::pair<int, std::vector<int>> max_length_list(const std::vector<std::vector<long>>& input_list) {\n    int max_length = 0;\n    std::vector<int> max_list;\n    for (const auto& vec : input_list) {\n        if (vec.size() > max_length) {\n            max_length = vec.size();\n            max_list = vec;\n        }\n    }\n    return std::make_pair(max_length, max_list);\n}\n\n"], ["#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\nbool check_distinct(std::vector<long> test_vec) {\n    std::set<int> temp;\n    for (int ele : test_vec) {\n        if (temp.find(ele) != temp.end()) {\n            return false;\n        }\n        temp.insert(ele);\n    }\n    return true;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <cassert>\n\nchar first_non_repeating_character(const std::string& str1) {\n    std::vector<char> char_order;\n    std::map<char, long> ctr;\n    for (char c : str1) {\n        if (ctr.find(c) != ctr.end()) {\n            ctr[c] += 1;\n        } else {\n            ctr[c] = 1;\n            char_order.push_back(c);\n        }\n    }\n    for (char c : char_order) {\n        if (ctr[c] == 1) {\n            return c;\n        }\n    }\n    return '\\0';\n}\n\n\n\n"], ["#include <iostream>\n#include <regex>\n#include <cassert>\nusing namespace std;\n\nstring check_char(string str) {\n    int p1 = 0;\n    int p2 = str.size() -1 ;\n    if(str[p2] == str[p1])\n        return \"true\";\n    else\n        return \"false\";\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\n//函数定义\nint median_numbers(int a, int b, long c) {\n    int median;\n    if (a > b) {\n        if (a < c) {\n            median = a;\n        } else if (b > c) {\n            median = b;\n        } else {\n            median = c;\n        }\n    } else {\n        if (b < c) {\n            median = b;\n        } else {\n            median = c;\n        }\n    }\n    return median;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <cctype>\nusing namespace std;\n\nlong sum_of_digits(vector<int> nums) {\n    long result = 0;\n    for (int n : nums) {\n        string numStr = to_string(n);\n        for (char c : numStr) {\n            if (isdigit(c)) {\n                result += c - '0';\n            }\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <tuple>\nstd::tuple<int, int, int, int> bitwise_xor(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n\n    return std::make_tuple(\n        std::get<0>(test_tup2) ^ std::get<0>(test_tup1),\n        std::get<1>(test_tup2) ^ std::get<1>(test_tup1),\n        std::get<2>(test_tup2) ^ std::get<2>(test_tup1),\n        std::get<3>(test_tup2) ^ std::get<3>(test_tup1)\n    );\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <cassert>\nlong extract_freq(const std::vector<std::pair<int, int>>& test_list) {\n    std::set<std::pair<int, int>> unique_tuples;\n    for (const auto& sub : test_list) {\n        if (sub.first <= sub.second) {\n            unique_tuples.insert(sub);\n        }\n    }\n    return unique_tuples.size();\n}\n\n"], ["#include <tuple>\n#include <cassert>\nusing namespace std;\n\ntuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> add_nested_tuples(\n    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> test_tup1,\n    tuple<tuple<int, int>, tuple<int, long>, tuple<int, int>, tuple<int, int>> test_tup2) \n{\n    tuple<int, int> res1 = make_tuple(get<0>(get<0>(test_tup1)) + get<0>(get<0>(test_tup2)), get<1>(get<0>(test_tup1)) + get<1>(get<0>(test_tup2)));\n    tuple<int, int> res2 = make_tuple(get<0>(get<0>(test_tup1)) + get<1>(get<0>(test_tup2)), get<1>(get<0>(test_tup1)) + get<1>(get<0>(test_tup2)));\n    tuple<int, int> res3 = make_tuple(get<0>(get<0>(test_tup1)) + get<2>(get<0>(test_tup2)), get<1>(get<0>(test_tup1)) + get<2>(get<0>(test_tup2)));\n    tuple<int, int> res4 = make_tuple(get<0>(get<0>(test_tup1)) + get<3>(get<0>(test_tup2)), get<1>(get<0>(test_tup1)) + get<3>(get<0>(test_tup2)));\n    return make_tuple(res1, res2, res3, res4);\n}\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nint ncr_modp(long n, int r, int p) {\n    std::vector<int> C(r + 1, 0);\n    C[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = std::min(i, r); j > 0; --j) {\n            C[j] = (C[j] + C[j - 1]) % p;\n        }\n    }\n    return C[r];\n}\n"], ["\n#include<iostream>\n#include<cassert>\n#include <assert.h>\n//函数定义\nlong minimum(int a, int b) {\n    if (a <= b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <tuple>\n#include <type_traits>\n#include <cstddef>\n#include <cassert>\nusing namespace std;\nusing MyTuple = tuple<char, int, char, char, char, char, char, char, char, char>;\n\ntemplate<typename T, size_t I = 0>\nbool check_tuplex(const MyTuple& t, const T& value) {\n\n    /*\n    progame language:cpp\n    description:Write a function to check whether an element exists within a tuple.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    if constexpr (I == tuple_size<MyTuple>::value) {\n        return 0;\n    }\n\n    if constexpr (I == 0) {\n        return 1;\n    }\n\n    if constexpr (I == 1) {\n        return 0;\n    }\n\n    if constexpr (I == 2) {\n        return 0;\n    }\n\n    if constexpr (I == 3) {\n        return 0;\n    }\n\n    if constexpr (I == 4) {\n        return 0;\n    }\n\n    if constexpr (I == 5) {\n        return 0;\n    }\n\n    if constexpr (I == 6) {\n        return 0;\n    }\n\n    if constexpr (I == 7) {\n        return 0;\n    }\n\n    if constexpr (I == 8) {\n        return 0;\n    }\n\n    if constexpr (I == 9) {\n        return 0;\n    }\n\n    if constexpr (I == 10) {\n        return 0;\n    }\n\n    if constexpr (I == 11) {\n        return 0;\n    }\n\n    if constexpr (I == 12) {\n        return 0;\n    }\n\n    if constexpr (I == 13) {\n        return 0;\n    }\n\n    if constexpr (I == 14) {\n        return 0;\n    }\n\n    if constexpr (I == 15) {\n        return"], ["#include <iostream>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nstring find_Parity(unsigned int x) {\n    unsigned int y = (x >> 1) ^ x;\n    y = (y >> 2) ^ y;\n    y = (y >> 4) ^ y;\n    y = (y >> 8) ^ y;\n    return to_string(y);\n}\n"], ["\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nint rearrange_bigger(int n) {\n    string nums = to_string(n);\n    for (int i = nums.size() - 2; i >= 0; --i) {\n        if (nums[i] < nums[i+1]) {\n            string z = nums.substr(i);\n            char y = *min_element(z.begin() + 1, z.end(), [first = z[0]](char a, char b) { return a > first && (b > first ? a < b : 1); });\n            z.erase(remove(z.begin(), z.end(), y), z.end());\n            return stoi(z);\n        }\n    }\n    return n;\n}\n\n\n\n"], ["\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <iostream>\nusing namespace std;\nvector<vector<int>> k_smallest_pairs(vector<int>& nums1, vector<int>& nums2, int k) {\n    priority_queue<pair<long, int>, vector<pair<long, int>>, decltype(comp)> pq(comp);\n    vector<vector<int>> ans;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            if (pq.size() < k) {\n                pq.push({nums1[i] + nums2[j], i, j});\n            }\n            else if (nums1[pq.top().second] + nums2[pq.top().second] > nums1[i] + nums2[j]) {\n                pq.pop();\n                pq.push({nums1[i] + nums2[j], i, j});\n            }\n        }\n    }\n    while (!pq.empty()) {\n        ans.push_back({nums1[pq.top().second], nums2[pq.top().second]});\n        pq.pop();\n    }\n    return ans;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <limits>\n#include <cstdlib> // for abs()\n\nint min_product_tuple(const std::vector<std::pair<int, int>>& list1) {\n    int result_min = std::numeric_limits<int>::max();\n    for (const auto& p : list1) {\n        int product = std::abs(p.second * p.first);\n        if (product < result_min) {\n            result_min = product;\n        }\n    }\n    return result_min;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <limits>\n#include <typeinfo>\n#include <cassert>\nusing namespace std;\n\nlong min_val(const vector<int>& listval) {\n    int min_val = numeric_limits<int>::max();\n    for (int value : listval) {\n        if (value < min_val) {\n            min_val = value;\n        }\n    }\n    return min_val;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<long> remove_odd(std::vector<int> l) {\n  auto it = l.begin();\n  while (it != l.end()) {\n    if (*it % 2 != 0) {\n      it = l.erase(it);\n    } else {\n      ++it;\n    }\n  }\n  return l;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n#include <string>\nusing namespace std;\n\ntemplate<typename T, size_t N>\nstruct TupleElement {\n    using type = typename tuple_element<N, tuple<T, int, int>>::type;\n};\n\ntemplate<typename T, size_t N>\nvector<typename TupleElement<T, N>::type> extract_nth_element(const vector<tuple<T, long, int>>& list1) {\n    vector<typename TupleElement<T, N>::type> result;\n    for (const auto& tuple : list1) {\n        result.push_back(get<1>(tuple));\n    }\n    return result;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nbool overlapping(const std::vector<int>& list1, const std::vector<int>& list2) {\n    int c = list1.size();\n    int d = list2.size();\n    for (int i = 0; i < c; i++) {\n        for (int j = 0; j < d; j++) {\n            if (list2[j] == list1[i]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\npair<int, int> max_Product(const vector<int>& arr) {\n    int arr_len = arr.size();\n    if (arr_len < 2) {\n        throw \"No pairs exists\";\n    }\n    int x = arr[0];\n    long y = arr[1];\n    for (int i = 0; i < arr_len; i++) {\n        for (int j = i + 1; j < arr_len; j++) {\n            if (arr[i] * arr[j] > x * y) {\n                x = arr[i];\n                y = arr[j];\n            }\n        }\n    }\n    return {x, y};\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint breakSum(int n) {\n    vector<long> dp(n + 1, 0);\n    dp[0] = 0;\n    dp[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        for (int j = 1; j <= i / 2; ++j) {\n            dp[i] = max(dp[i], dp[j] + dp[i - j]);\n        }\n    }\n    return dp[n];\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <numeric>\nint round_and_sum(const std::vector<double>& list1) {\n    int length = list1.size();\n    long rounded_sum = std::accumulate(list1.begin(), list1.end(), 0, [](int acc, double val) {\n        return acc + std::round(val);\n    });\n    return rounded_sum * length;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint cube_Sum(int n) {\n    long sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i * i * i;\n    }\n    return sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <sstream>\n#include <tuple>\nusing namespace std;\n\ntemplate<size_t Index, typename... Args>\nvoid concatenate_tuple_helper(ostringstream& oss, const string& delim, const tuple<Args...>& test_tup) {\n\n    /*\n    progame language:cpp\n    description:Write a function to concatenate each element of tuple by the delimiter.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    if (0 != Index) {\n        oss << delim;\n    }\n    oss << get<Index>(test_tup);\n}\n// Recursive function to iterate over the tuple\ntemplate<size_t Index, typename... Args>\nvoid iterate_tuple(ostringstream& oss, const string& delim, const tuple<Args...>& test_tup) {\n    if constexpr (sizeof...(Args) == Index) {\n        return;\n//begin to write code\nAnswer:\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble find_Average_Of_Cube(int n) {\n    double sum = 0;\n    for (long i = 1; i <= n; ++i) {\n        sum += std::pow(i, 3);\n    }\n    return sum / n;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nint get_maxgold(vector<vector<int>> gold, int m, int n) {\n    vector<vector<int>> goldTable(m, vector<int>(n, 0));   \n    for (int col = n-1; col >= 0; col--) { \n        for (long row = 0; row < m; row++) { \n            int right = (col == n-1) ? 0 : goldTable[row][col+1];\n            int right_up = (row == 0 || col == n-1) ? 0 : goldTable[row-1][col+1];\n            int right_down = (row == m-1 || col == n-1) ? 0 : goldTable[row+1][col+1];\n            goldTable[row][col] = gold[row][col] + max({right, right_up, right_down});\n        }\n    }\n    return goldTable[0][0];\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate<typename T>\nint count_element_in_list(const std::vector<std::vector<T>>& list1, T x) {\n    int ctr = 0;\n    for (const auto& sublist : list1) {\n        for (const auto& element : sublist) {\n            if (x == element) {\n                ctr++;\n            }\n        }\n    }\n    return ctr;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nstd::vector<int> filter_oddnumbers(const std::vector<int>& nums) {\n    std::vector<long> odd_nums;\n    std::copy_if(nums.begin(), nums.end(), std::back_inserter(odd_nums), [](int x){ \n        return x % 2 != 0;\n    });\n    return odd_nums;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nvoid shell_sort(std::vector<int>& my_list) {\n    int gap = my_list.size() / 2;\n    while (gap > 0) {\n        for (int i = gap; i < my_list.size(); i++) {\n            long current_item = my_list[i];\n            int j = i;\n            while (j >= gap && my_list[j - gap] > current_item) {\n                my_list[j] = my_list[j - gap];\n                j -= gap;\n            }\n            my_list[j] = current_item;\n        }\n        gap /= 2;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, int, int> and_tuples(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) & std::get<0>(test_tup1),\n        std::get<1>(test_tup2) & std::get<1>(test_tup1),\n        std::get<2>(test_tup2) & std::get<2>(test_tup1),\n        std::get<3>(test_tup2) & std::get<3>(test_tup1)\n    );\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\n//函数定义\nlong parabola_directrix(int a, int b, int c) {\n    long directrix = c - ((b * b) + 1) * 4 * a;\n    return directrix;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\ndouble median_trapezium(double base1, double base2, double height) {\n    double median = (base1 + base2) * 0.5;\n    return median;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nstd::string check_greater(std::vector<long> arr, int number) {\n    std::sort(arr.begin(), arr.end());\n    if (number > arr.back()) {\n        return \"Yes, the entered number is greater than those in the array\";\n    } else {\n        return \"No, the entered number is not greater than those in the array\";\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nlong last_Digit(int n) {\n    long result = 0;\n    while (n > 0) {\n        result = result * 10 + n % 10;\n        n /= 10;\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> neg_nos(const std::vector<int>& list1) {\n    std::vector<long> negatives;\n    for (int num : list1) {\n        if (num < 0) {\n            negatives.push_back(num);\n        }\n    }\n    return negatives;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\nstd::string remove_odd(const std::string& str1) {\n    std::string str2;\n    for (long i = 1; i <= str1.length(); ++i) {\n        if (i % 2 == 0) {\n            str2 += str1[i];\n        }\n    }\n    return str2;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_bidirectional(vector<pair<int, int>> test_list) {\n    int res = 0;\n    for (size_t idx = 0; idx < test_list.size(); ++idx) {\n        for (size_t iidx = 1 + idx; iidx < test_list.size(); ++iidx) {\n            if (test_list[idx].second == test_list[iidx].first && test_list[iidx].first == test_list[idx].second) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nlong multiple_to_single(const std::vector<int>& L) {\n    std::stringstream ss;\n    for (int num : L) {\n        ss << num;\n    }\n    return std::stoi(ss.str());\n}\n\n\n\n"], ["\n#include <iostream>\n#include <regex>\n#include <tuple>\n#include <cassert>\nusing namespace std;\ntuple<long, int, string> find_adverb_position(const string& text) {\n    regex pattern(\"\\\\w+ly\");\n    smatch match;\n    if (regex_search(text, match, pattern)) {\n        return make_tuple(match.position(), match.length(), match.str());\n    } else {\n        return make_tuple(-1, -1, \"\");\n    }\n}\n\n\n\n"], ["\n#include<iostream>\n#include <cassert>\n\nlong surfacearea_cube(int l) {\n    return 6 * l * l;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\ndouble positive_count(vector<int> nums) {\n    int n = nums.size();\n    long n1 = 0;\n    for (int x : nums) {\n        if (x > 0) {\n            n1++;\n        }\n    }\n    return (double)n1 / n;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nint largest_neg(std::vector<long> list1) {\n    int max = list1[0];\n    for (int x : list1) {\n        if (x < max) {\n            max = x;\n        }\n    }\n    return max;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<vector<int>> trim_tuple(const vector<vector<long>>& test_list, int K) {\n    vector<vector<int>> res;\n    for (const auto& ele : test_list) {\n        vector<int> tmp;\n        for (int i = K; i <= ele.size() - K - 1; i++) {\n            tmp.push_back(ele[i]);\n        }\n        res.push_back(tmp);\n    }\n    return res;\n}\n\n\n\n"], ["#include<iostream>\n#include <cassert>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\n// Helper function to perform index-wise multiplication\ntemplate<size_t I>\ntuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> index_multiplication_helper(\n\n    /*\n    progame language:cpp\n    description:Write a function to perform index wise multiplication of tuple elements in the given two tuples.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup1,\n    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup2,\n    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> res)\n{\n    auto tup1 = get<I - 1>(test_tup1);\n    auto tup2 = get<I - 1>(test_tup2);\n    get<I - 1>(res) = make_tuple(get<0>(tup2) * get<0>(tup1), get<1>(tup2) * get<1>(tup1));\n    return index_multiplication_helper<I - 1>(test_tup1, test_tup2, res);\n}\n// Base case for the recursion\ntemplate<>\n//begin to write code\nAnswer:\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_Occurrence(const std::vector<char>& tup, const std::vector<char>& lst) {\n    int count = 0;\n    for (char item : tup) {\n        for (char elem : lst) {\n            if (elem == item) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<long> cube_nums(const vector<int>& nums) {\n    vector<long> result;\n    for (int num : nums) {\n        result.push_back(pow(num, 3));\n    }\n    return result;\n}\n\n"], ["#include <iostream>\n#include <cassert>\nint cal_sum(int n) {\n    int a = 3;\n    int b = 0;\n    int c = 2;\n    if (0 == n) {\n        return 3;\n    }\n    if (1 == n) {\n        return 3;\n    }\n    if (2 == n) {\n        return 5;\n    }\n    for (int i = 3; i <= n; i++) {\n        a = b + c;\n        b = c;\n        c = a;\n    }\n    return a;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\nusing namespace std;\n\nstring check_Triangle(int x1, int y1, int x2, int y2, int x3, int y3) {\n    int a = ((y2-y3) * x1+(y3-y1) * x2+(y1-y2) * x3);\n    if (0 == a) {\n        return \"No\";\n    }\n    return \"Yes\";\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nstd::vector<std::string> extract_string(std::vector<std::string> vec, int l) {\n    std::vector<std::string> result;\n    for (auto& str : vec) {\n        if (l == str.length()) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint loss_amount(int actual_cost, long sale_amount) {\n    if(sale_amount > actual_cost) {\n        return sale_amount - actual_cost;\n    } else {\n        return 0;\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\n// Function Definition\nint sumofFactors(int n) {\n    if (n % 2 != 0) {\n        return 0;\n    }\n    int res = 1;\n    for (int i = 2; i <= static_cast<int>(std::sqrt(n)) + 1; ++i) {\n        int count = 0;\n        long curr_sum = 1;\n        int curr_term = 1;\n        while (n % i == 0) {\n            count++;\n            n = n / i;\n            curr_term *= i;\n            curr_sum += curr_term;\n        }\n        res *= curr_sum;\n    }\n    if (n > 1) {\n        res *= n;\n    }\n    return res;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool check_monthnumb_number(long monthnum2) {\n    if (monthnum2 == 1 || monthnum2 == 3 || monthnum2 == 5 || monthnum2 == 7 || monthnum2 == 8 || monthnum2 == 10 || monthnum2 == 12) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n\n"], ["\n\n#include <iostream>\n#include <cassert>\n\nlong rectangle_area(int l, int b) {\n    /*\n    progame language:cpp\n    description:Write a function to find the area of a rectangle.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    long area = l * b;\n    return area;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> Extract(const std::vector<std::vector<int>>& lst) {\n    std::vector<long> result;\n    for (auto& item : lst) {\n        result.push_back(item[0]);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nint upper_ctr(string str) {\n    int upper_ctr = 0;\n    for (long i = 0; i < str.length(); i++) {\n        if (str[i] >= 'A' && str[i] <= 'Z') {\n            upper_ctr++;\n        }\n    }\n    return upper_ctr;\n}\n\n\n\n"], ["#include<iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nvector<vector<string>> combinations_list(vector<string> list1) {\n    if (list1.empty()) {\n        return {{}};\n    }\n    vector<vector<string>> result;\n    vector<string> rest(1 + list1.begin(), list1.end());\n    for (int i = 0; i < rest.size(); i++) {\n        vector<string> current = {rest[i]};\n        result.push_back(current);\n        for (int j = 0; j < i; j++) {\n            vector<string> next = {rest[j] + rest[i]};\n            result.push_back(next);\n        }\n    }\n    return result;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nint max_subarray_product(vector<int> arr) {\n    long n = arr.size();\n    int max_ending_here = 1;\n    int min_ending_here = 1;\n    int max_so_far = 0;\n    bool flag = false;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > 0) {\n            max_ending_here = max_ending_here * arr[i];\n            min_ending_here = min(min_ending_here * arr[i], 1);\n            flag = true;\n        } else if (arr[i] == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n            flag = false;\n        } else {\n            int temp = max_ending_here;\n            max_ending_here = max(min_ending_here * arr[i], 1);\n            min_ending_here = temp * arr[i];\n        }\n        if (max_so_far < max_ending_here) max_so_far = max_ending_here;\n    }\n    return max_so_far;\n}\n"], ["#include <cassert>\n#include <iostream>\n#include <map>\n#include <string>\nbool check_value(std::map<std::string, int> dict, int n) {\n    for (const auto& kv : dict) {\n        if (kv.second != n) {\n            return 0;\n        }\n    }\n    return 1;\n}\n"], ["#include<iostream>\n    \n\n#include <map>\n#include <cassert>\n\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(\"\" != element.second) {\n            filtered.insert(std::make_pair(element.first, element.second));\n        }\n    }\n    return filtered;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_peak_util(const std::vector<int>& arr, int low, int high, int n) {\n    int mid = low + (high - low) / 2;\n    if ((0 == mid || arr[mid - 1] <= arr[mid]) &&\n        (n - 1 == mid || arr[1 + mid] <= arr[mid])) {\n        return mid;\n    } else if (mid > 0 && arr[mid - 1] > arr[mid]) {\n        return find_peak_util(arr, low, mid - 1, n);\n    } else {\n        return find_peak_util(arr, mid + 1, high, n);\n    }\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint decimal_to_Octal(int deciNum) {\n    long octalNum = 0;\n    int countval = 1;\n    int remainder;\n    while (deciNum != 0) {\n        remainder = deciNum % 8;\n        octalNum += remainder * countval;\n        deciNum /= 8;\n        countval *= 10;\n    }\n    return octalNum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint max_product(vector<int> arr, int n) {\n    vector<int> mpis(n, 0);\n    for (int i = 0; i < n; ++i) {\n        mpis[i] = arr[i];\n    }\n    for (int i = 1; i < n; ++i) {\n        for (long j = 0; j < i; ++j) {\n            if (mpis[i] > mpis[j]) {\n                mpis[i] = mpis[j];\n            }\n        }\n    }\n    return mpis[n - 1];\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint max_profit(vector<int> price, int k) {\n    int n = price.size();\n    vector<vector<int>> final_profit(1 + k, vector<int>(n, 0));\n    for (int i = 0; i <= k; i++) {\n        for (int j = 0; j < n; j++) {\n            if (0 == i || 0 == j) {\n                final_profit[i][j] = 0;\n            } else {\n                int max_so_far = 0;\n                for (int x = 0; x < j; x++) {\n                    max_so_far = max(max_so_far, final_profit[i - 1][x] + price[j] - price[x]);\n                }\n                final_profit[i][j] = max_so_far;\n            }\n        }\n    }\n    return final_profit[k][n - 1];\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nstd::vector<long> add_pairwise(const std::vector<int>& test_vec) {\n    std::vector<long> res;\n    for (size_t i = 0; i < test_vec.size() - 1; ++i) {\n        res.push_back(test_vec[i] + test_vec[i + 1]);\n    }\n    return res;\n}\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nint find_remainder(std::vector<long> arr, int lens, int n) {\n    int mul = 1;\n    for (int i = 0; i < lens; i++) {\n        mul *= arr[i];\n    }\n    return mul % n;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\nbool check_Consecutive(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 1; i < l.size(); ++i) {\n        if (l[i - 1] + 1 != l[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n"], ["#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nstd::set<std::pair<int, int>> tuple_intersection(const std::vector<std::pair<int, int>>& test_list1, const std::vector<std::pair<int, int>>& test_list2) {\n    std::set<std::pair<int, long>> set1, set2;\n    for (auto& ele : test_list1) {\n        set1.insert({std::min(ele.first, ele.second), std::max(ele.first, ele.second)});\n    }\n    for (auto& ele : test_list2) {\n        set2.insert({std::min(ele.first, ele.second), std::max(ele.first, ele.second)});\n    }\n    std::set<std::pair<int, long>> result;\n    for (auto& ele : set1) {\n        if (set2.find(ele) != set2.end()) {\n            result.insert(ele);\n        }\n    }\n    return result;\n}\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nstd::string replace_char(std::string str1, char ch, char newch) {\n    for (size_t i = 0; i < str1.length(); ++i) {\n        if (ch == str1[i]) {\n            str1[i] = newch;\n        }\n    }\n    return str1;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<std::pair<std::string, int>> sort_counter(std::map<std::string, long> dict1) {\n    std::vector<std::pair<std::string, int>> result;\n    for (const auto& pair : dict1) {\n        result.push_back(pair);\n    }\n    std::sort(result.begin(), result.end(), compare);\n    return result;\n}\n\n\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint big_sum(const std::vector<int>& nums) {\n    long sum = *max_element(nums.begin(), nums.end()) + *min_element(nums.begin(), nums.end());\n    return sum;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint first_Digit(long n) {\n    while (n >= 10) {\n        n = n / 10;\n    }\n    return n;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <string>\n\nusing namespace std;\n\nchar get_max_occuring_char(const string &str1) {\n    int ctr[256] = {0};\n    long max = -1;\n    char ch = '\\0';\n    for (char c : str1) {\n        ctr[c]++;\n        if (ctr[c] > max) {\n            max = ctr[c];\n            ch = c;\n        }\n    }\n    return ch;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nbool is_subset_sum(const std::vector<int>& set, int n, int sum) {\n    if (sum == 0) return 1;\n    if (n == 0) return 0;\n    return is_subset_sum(set, n - 1, sum) || is_subset_sum(set, n - 1, sum - set[n - 1]);\n}\n"], ["#include<iostream>\n    \n\n#include <string>\n#include <cassert>\n\nint first_Factorial_Divisible_Number(int x) {\n    int i = 1;\n    long fact = 1;\n    for (i = 1; i <= x; ++i) {\n        fact *= i;\n        if (fact % x == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n\n\n"], ["\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_map>\n#include <cassert>\n#include <utility> // for std::pair\n#include <iostream>\nusing namespace std;\n\nstruct PairHash {\n    template <class T1, class T2>\n    std::size_t operator() (const std::pair<T1, T2>& pair) const {\n        auto hash1 = std::hash<T1>{}(pair.first);\n        auto hash2 = std::hash<T2>{}(pair.second);\n        return (hash2 << 1) ^ hash1; \n    }\n};\nstruct PairEqual {\n    template <class T1, class T2>\n    bool operator() (const std::pair<T1, T2>& lhs, const std::pair<T1, T2>& rhs) const {\n        return rhs.first == lhs.first && rhs.second == lhs.second;\n    }\n};\n\nint get_Inv_Count(vector<int> arr, int n) {\n    int inv_count = 0;\n    unordered_map<int, int> count;\n    for (int i = 0; i < n; i++) {\n        count[arr[i]]++;\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (arr[i] > arr[j]) {\n                inv_count += count[arr[i]] * (count[arr[j]] - 1) / 2;\n            }\n        }\n    }\n    return inv_count;\n}\n\n"], ["\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nbool is_palindrome(int n) {\n    int divisor = 1;\n    while (n / divisor >= 10) {\n        divisor *= 10;\n    }\n    while (0 != n) {\n        int leading = n / divisor;\n        int trailing = n % 10;\n        if (trailing != leading) {\n            return false;\n        }\n        n = (n % divisor) / 10;\n    }\n    return true;\n}\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\n// 函数定义\ndouble nCr(int n, int r) {\n    if (r > n / 2) {\n        r = n - r;\n    }\n    double answer = 1;\n    for (long i = 1; i <= r; i++) {\n        answer *= (n - r + i);\n    }\n    return answer;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <utility>\n#include <cassert>\n#include <algorithm>\n\nstd::vector<std::pair<int, int>> sort_tuple(std::vector<std::pair<int, int>>& tup) {\n    int lst = tup.size();\n    for (int i = 0; i < lst; ++i) {\n        for (int j = 0; j < lst - i - 1; ++j) {\n            if (tup[j].second > tup[1 + j].second) {\n                std::swap(tup[j], tup[1 + j]);\n            }\n        }\n    }\n    return tup;\n}\n"], ["#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble area_pentagon(double a) {\n\n    /*\n    progame language:cpp\n    description:Write a function to find the area of a pentagon.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n  double area = (pow(a, 2) * sqrt(5 * (5 + 2 * sqrt(5)))) / 4.0;\n  return area;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint frequency_Of_Largest(long n, std::vector<int> arr) {\n    int mn = arr[0];\n    int freq = 1;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > mn) {\n            mn = arr[i];\n            freq = 1;\n        } else if (arr[i] == mn) {\n            freq++;\n        }\n    }\n    return freq;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nset<pair<int, int>> extract_symmetric(vector<pair<int, int>> test_list) {\n    set<pair<int, int>> res;\n    for (auto& p : test_list) {\n        res.insert({p.first, p.second});\n    }\n    for (auto& p : test_list) {\n        res.erase({p.second, p.first});\n    }\n    return res;\n}\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\n//函数定义\ndouble sum_gp(double a, int n, double r) {\n    if (n == 0) {\n        return a;\n    }\n    if (n == 1) {\n        return a * (1 - r);\n    }\n    return sum_gp(a, n - 1, r) + a * pow(r, n - 1);\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nbool binary_search(const std::vector<int>& item_list, int item) {\n    int first = 0;\n    int last = item_list.size() - 1;\n    bool found = false;\n    while (first <= last && !found) {\n        int mid = (first + last) / 2;\n        if (item == item_list[mid]) {\n            found = true;\n        } else {\n            if (item < item_list[mid]) {\n                last = mid - 1;\n            } else {\n                first = mid + 1;\n            }\n        }\n    }\n    return found;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\ntypedef std::vector<std::pair<double, double>> Polygon;\nstd::vector<Polygon> calculate_polygons(double startx, double starty, double endx, double endy, double radius)\n\n    /*\n    progame language:cpp\n    description:Write a function to calculate a grid of hexagon coordinates where function returns a list of lists containing 6 tuples of x, y point coordinates.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n{\n    double sl = std::tan(M_PI / 6) * (radius * 2);\n    double p = 0.5 * sl;\n    double b = std::cos(M_PI * 30 / 180.0) * sl;\n    double w = 2 * b;\n    double h = sl * 2;\n    startx = startx - w;\n    starty = starty - h;\n    endx = endx + w;\n    endy = endy + h;\n    double origx = startx;\n    double origy = starty;\n    double xoffset = b;\n    double yoffset = p * 3;\n    std::vector<Polygon> polygons;\n    int row = 1;\n    int counter = 0;\n    while (starty < endy)\n    {\n        if (0 == row % 2)\n        {\n            startx = origx + xoffset;\n        }\n        else\n        {\n            startx = origx;\n        }\n        while (startx < endx)\n//begin to write code\nAnswer:\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\nstd::string binary_to_integer(const std::vector<int>& test_vec) {\n    std::string bin_str = \"\";\n    for (int num : test_vec) {\n        bin_str = bin_str + (std::to_string(num));\n    }\n    return bin_str;\n}\n\n\n\n"], ["\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <iostream>\nstd::vector<long> heap_queue_smallest(std::vector<int> nums, int n) {\n    std::vector<long> smallest_nums(n);\n    std::make_heap(smallest_nums.begin(), smallest_nums.end());\n    for (int num : nums) {\n        smallest_nums.push_back(num);\n        std::pop_heap(smallest_nums.begin(), smallest_nums.end());\n        smallest_nums.pop_back();\n    }\n    return smallest_nums;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint gcd(int x, int y) {\n    int gcd = 1;\n    if (0 == x % y) {\n        return y;\n    }\n    for (int k = y / 2; k > 0; k--) {\n        if (x % k == 0 && y % k == 0) {\n            gcd = k;\n            break;\n        }\n    }\n    return gcd;\n}\n\n\n\n"], ["#include<iostream>\n    \n\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nlong diameter_circle(int r) {\n    long diameter = 0;\n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < r; j++) {\n            long distance = sqrt(i * i + j * j);\n            if (distance > diameter) {\n                diameter = distance;\n            }\n        }\n    }\n    return diameter;\n}\n\n\n\n"], ["#include <iostream>\n#include <cmath>\n#include <cassert>\nint ngcd(int x, int y) {\n    long i = 1;\n    int gcd = 1;\n    while(i <= x && i <= y) {\n        if(x % i == 0 && y % i == 0) {\n            gcd = i;\n        }\n        i += 1;\n    }\n    return gcd;\n}\n\nint num_comm_div(int x, int y) {\n    int n = ngcd(x, y);\n    return n;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint find(int n, long m) {\n    int r = n % m;\n    return r;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<long> add_consecutive_nums(const std::vector<int>& nums) {\n    std::vector<long> result;\n    for (size_t i = 0; i < nums.size() - 1; ++i) {\n        result.push_back(nums[i] + nums[i + 1]);\n    }\n    return result;\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint sum_Of_Series(int n) {\n    int sum = 0;\n    for (long i = 1; i <= n; i++) {\n        sum += i * i * i;\n    }\n    return sum;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> re_order(std::vector<int>& A) {\n    long k = 0;\n    for (int i : A) {\n        if (i != 0) {\n            A[k] = i;\n            k++;\n        }\n    }\n    return A;\n}\n\n\n\n"], ["#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint permutation_coefficient(int n, int k) {\n    vector<vector<int>> P(1 + n, vector<int>(1 + k, 0));\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= min(i, k); j++) {\n            if (0 == j)\n                P[i][j] = 1;\n            else\n                P[i][j] = P[i - 1][j] + P[i - 1][j - 1];\n        }\n    }\n    return P[n][k];\n}\n"], ["\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <algorithm>\nbool same_order(const std::vector<std::string>& l1, const std::vector<std::string>& l2) {\n    std::set<std::string> s1(l1.begin(), l1.end());\n    std::set<std::string> s2(l2.begin(), l2.end());\n    std::vector<std::string> common_elements;\n    std::set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), std::back_inserter(common_elements));\n    std::vector<std::string> filtered_l1;\n    for (auto &item : l1) {\n        if (common_elements.end() != std::find(common_elements.begin(), common_elements.end(), item)) {\n            filtered_l1.push_back(item);\n        }\n    }\n    return filtered_l1.size() == l1.size();\n}\n\n\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint average_Odd(int n) {\n    if (0 == n % 2) {\n        std::cerr << \"Invalid Input\" << std::endl;\n        return -1;\n    }\n    int sm = 0;\n    int count = 0;\n    for (int i = 1; i <= n; i += 2) {\n        sm += i;\n        count++;\n    }\n    return sm / count;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint no_of_subsequences(vector<int> arr, int k) {\n    int n = arr.size();\n    vector<vector<int>> dp(1 + k, vector<int>(1 + n, 0));\n    for (int i = 1; i <= k; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = dp[i][j - 1];\n            if (arr[j - 1] <= i) {\n                dp[i][j] = max(dp[i][j], dp[i - arr[j - 1]][j - 1] + 1);\n            }\n        }\n    }\n    return dp[k][n];\n}\n\n\n\n"]]