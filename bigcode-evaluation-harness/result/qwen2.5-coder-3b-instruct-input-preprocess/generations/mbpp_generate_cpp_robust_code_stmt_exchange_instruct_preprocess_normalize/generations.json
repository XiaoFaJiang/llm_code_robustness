[["using namespace std;\n\n#include <iostream>\n#include <cassert>\nstd::string remove_occ(std::string s, char ch) {\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == ch) {\n            s = s.substr(0, i) + s.substr(i + 1);\n            break;\n        }\n    }\n    // Find the last occurrence of the character\n    int last = -1;\n    for (int i = s.length() - 1; i >= 0; i--) {\n        if (s[i] == ch) {\n            last = i;\n            break;\n        }\n    }\n    if (last != -1) {\n        s = s.substr(0, last) + s.substr(last + 1);\n    }\n    return s;\n}\n"], ["using namespace std;\nvector<vector<int>> sort_matrix(vector<vector<int>> m) {\n    sort(m.begin(), m.end(), [](const vector<int>& a, const vector<int>& b) {\n        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);\n    });\n    return m;\n}\n"], ["using namespace std;\n#include <cassert>\n\nint find_volume(int l, int b, int h) {\n    return (l * b * h) / 2;\n}\n"], ["using namespace std;\nconst int n_o_o_f_c_h_a_r_s = 256;\nvector<char> str_to_list(const string& str) {\n    vector<char> temp;\n    for (char x : str) {\n        temp.push_back(x);\n    }\n    return temp;\n}\nstring lst_to_string(const vector<char>& list) {\n    return string(list.begin(), list.end());\n}\nvector<int> get_char_count_array(const string& str) {\n    vector<int> count(n_o_o_f_c_h_a_r_s, 0);\n    for (char c : str) {\n        count[c]++;\n    }\n    //begin to write code\n    vector<char> result;\n    for (char c : str) {\n        if (count[c] == 0) {\n            result.push_back(c);\n        }\n    }\n    return result;\n}\n"], ["using namespace std;\nint maximum_sum(const vector<vector<int>>& list1) {\n    int maxi = -100000;\n    for (const auto& x : list1) {\n        int sum = 0;\n        for (auto y : x) {\n            sum += y; // Add each element to the sum\n        }\n        if (sum > maxi) {\n            maxi = sum; // Update maxi if the current sum is greater\n        }\n    }\n    return maxi;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint find_product(std::vector<int> arr, int n) {\n    std::sort(arr.begin(), arr.end());\n    int prod = 1;\n    for (int i = 0; i < n; i++) {\n        if (i == 0 || arr[i - 1] != arr[i]) {\n            prod *= arr[i];\n        }\n    }\n    return prod;\n}\n"], ["Complete code (including all the content of the code I provided and the code you generated)\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool check_k_elements(const std::vector<std::vector<int>>& test_list, int k) {\n    bool res = true;\n    for (const auto& tup : test_list) {\n        for (int ele : tup) {\n            if (ele != k) {\n                res = false;\n                break; // Exit the inner loop if a non-k element is found\n            }\n        }\n        if (!res) {\n            break; // Exit the outer loop if any tuple does not contain all k elements\n        }\n    }\n    return res;\n}\n"], ["using namespace std;\n\n#include<iostream>\n#include <cassert>\n\nint binomial_coeff(int n, int k) {\n    if (k > n) {\n        return 0;\n    }\n    // Calculate binomial coefficient using dynamic programming\n    int dp[n + 1][k + 1];\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j <= min(i, k); ++j) {\n            if (j == 0 || j == i) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }\n        }\n    }\n    return dp[n][k];\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint get_odd_occurrence(std::vector<int> arr, int arr_size) {\n    for (int i = 0; i < arr_size; i++) {\n        int count = 0;\n        for (int j = 0; j < arr_size; j++) {\n            if (arr[i] == arr[j]) {\n                count++;\n            }\n        }\n        if (count % 2 != 0) {\n            return arr[i];\n        }\n    }\n    return -1; // This line should never be reached if there is an odd occurrence\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <string>\n#include <cassert>\n\nbool check_equality(const std::string &s) {\n    return (s.front() == s.back());\n}\n\nint count_substring_with_equal_ends(const std::string &s) {\n    int result = 0;\n    int n = s.length();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            if (check_equality(s.substr(i, j - i + 1))) {\n                ++result;\n            }\n        }\n    }\n    return result;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint max_prime_factors(int n) {\n    int max_prime = -1;\n    while (n % 2 == 0) {\n        max_prime = 2;\n        n >>= 1;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            max_prime = i;\n            n /= i;\n        }\n    }\n    if (n > 2) {\n        max_prime = n;\n    }\n    return max_prime;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <cmath>\n#include <cassert>\nint decimal_to_binary(int n) {\n    int b_number = 0;\n    int cnt = 0;\n    while (n != 0) {\n        int rem = n % 2;\n        int c = pow(10, cnt);\n        b_number += rem * c;\n        n /= 2;\n        cnt++;\n    }\n    return b_number;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_missing(std::vector<int>& ar, int n) {\n    int l = 0;\n    int r = n - 1;\n    while (l <= r) {\n        int mid = (l + r) / 2;\n        if (ar[mid] != mid + 1 && ar[mid - 1] == mid) {\n            return mid + 1;\n        } else if (ar[mid] == mid + 1) {\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return n + 1; // If no missing number is found, return n + 1\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint find_nth_digit(int p, int q, int n) {\n    int res;\n    while (n > 0) {\n        n -= 1;\n        p *= 10;\n        res = p / q;\n        p %= q;\n    }\n    return res % 10;\n}\n"], ["using namespace std;\n#include<cassert>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> sort_mixed_list(std::vector<std::string> mixed_list) {\n    std::vector<int> int_part;\n    std::vector<std::string> str_part;\n    for (const auto& item : mixed_list) {\n        if (!(isdigit(item[0]) || (item[0] == '-' && item.size() > 1 && isdigit(item[1])))) {\n            str_part.push_back(item);\n        }\n        else {\n            int_part.push_back(std::stoi(item));\n        }\n    }\n\n    // Sort the integer part\n    std::sort(int_part.begin(), int_part.end());\n\n    // Merge the sorted integer part with the string part\n    std::vector<std::string> sorted_list;\n    size_t int_index = 0;\n    size_t str_index = 0;\n\n    while (int_index < int_part.size() && str_index < str_part.size()) {\n        if (int_part[int_index] < std::stoi(str_part[str_index])) {\n            sorted_list.push_back(std::to_string(int_part[int_index]));\n            ++int_index;\n        }\n        else {\n            sorted_list.push_back(str_part[str_index]);\n            ++str_index;\n        }\n    }\n\n    // Add any remaining elements from the integer part\n    while (int_index < int_part.size()) {\n        sorted_list.push_back(std::to_string(int_part[int_index]));\n        ++int_index;\n    }\n\n    // Add any remaining elements from the string part\n    while (str_index < str_part.size()) {\n        sorted_list.push_back(str_part[str_index]);\n        ++str_index;\n    }\n\n    return sorted_list;\n}\n"], ["using namespace std;\nstring rearrange_string(string s) {\n    unordered_map<char, int> ctr;\n    for (char c : s) {\n        ctr[c]++;\n    }\n    auto comp = [](pair<int, char> left, pair<int, char> right) {\n        if (left.first == right.first) return left.second > right.second;\n        return left.first < right.first;\n    };\n    priority_queue<pair<int, char>, vector<pair<int, char>>, decltype(comp)> heap(comp);\n    for (auto& kv : ctr) {\n        heap.push(make_pair(kv.second, kv.first));\n    }\n    if (heap.top().first > (s.length() + 1) / 2) {\n        return \"\";\n    }\n    string ans = \"\";\n    while (!heap.empty()) {\n        auto top = heap.top();\n        heap.pop();\n        ans += top.second;\n        if (!heap.empty()) {\n            auto nextTop = heap.top();\n            heap.pop();\n            ans += nextTop.second;\n            if (--nextTop.first > 0) {\n                heap.push(nextTop);\n            }\n        }\n        if (--top.first > 0) {\n            heap.push(top);\n        }\n    }\n    return ans;\n}\n"], ["using namespace std;\nint find_sum(const vector<int>& arr) {\n    unordered_map<int, int> count;\n    for (int num : arr) {\n        count[num]++;\n    }\n    int sum = 0;\n    for (const auto& pair : count) {\n        if (pair.second > 1) {\n            sum += pair.first * pair.second;\n        }\n    }\n    return sum;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_gcd(int x, int y) {\n    for(;(y != 0);){\n        int temp = x % y;\n        x = y;\n        y = temp;\n    }\n    return x;\n}\n\n//begin to write code\nint find_gcd_of_array(const vector<int>& arr) {\n    if (arr.empty()) {\n        throw invalid_argument(\"Array is empty\");\n    }\n\n    int result = arr[0];\n    for (size_t i = 1; i < arr.size(); ++i) {\n        result = find_gcd(result, arr[i]);\n    }\n    return result;\n}\n"], ["using namespace std;\n#include<iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool test_distinct(const std::vector<int>& data) {\n    std::set<int> distinct_set(data.begin(), data.end());\n    return distinct_set.size() == data.size();\n}\n"], ["using namespace std;\nint compute_last_digit(int a, int b) {\n    int variable = 1;\n    if (a == b) {\n        return 1;\n    } else if ((b - a) >= 5) {\n        return 0;\n    }\n    // Calculate the factorial of a and b\n    long long fact_a = 1, fact_b = 1;\n    for (int i = 2; i <= a; ++i) {\n        fact_a *= i;\n    }\n    for (int i = 2; i <= b; ++i) {\n        fact_b *= i;\n    }\n    // Find the last digit of the division of fact_b by fact_a\n    while (fact_b % fact_a != 0) {\n        fact_b /= 10;\n    }\n    return fact_b % 10;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> specified_element(const std::vector<std::vector<int>>& nums, int n) {\n    std::vector<int> result;\n    for (const auto& i : nums) {\n        if (n == 0) {\n            result.push_back(i[0]);\n        } else if (n == 1) {\n            result.push_back(i[i.size() - 1]);\n        }\n    }\n    return result;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <string>\n#include <cassert>\nstd::string check_equality(const std::string& str) {\n    if (str[0] == str[str.length() - 1]) {\n        return \"Equal\";\n    } else {\n        return \"Not Equal\";\n    }\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> counting_sort(std::vector<int> my_list) {\n    int max_value = 0;\n    {\n        int i = 0;\n        for (; i < my_list.size(); ++i) {\n            if (my_list[i] > max_value) {\n                max_value = my_list[i];\n            }\n        }\n    }\n    std::vector<int> buckets(max_value + 1, 0);\n    for (int num : my_list) {\n        buckets[num]++;\n    }\n\n    std::vector<int> sorted_list;\n    for (int i = 0; i <= max_value; ++i) {\n        for (int j = 0; j < buckets[i]; ++j) {\n            sorted_list.push_back(i);\n        }\n    }\n\n    return sorted_list;\n}\n"], ["using namespace std;\n#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint find_max_num(std::vector<int> arr, int n) {\n    std::sort(arr.rbegin(), arr.rend());\n    int num = arr[0];\n    //begin to write code\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] != 0) {\n            num = num * 10 + arr[i];\n            break;\n        }\n    }\n    return num;\n}\n"], ["using namespace std;\n#include <cassert>\n\nbool opposite_signs(int x, int y) {\n    return (x ^ y) < 0;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <unordered_map>\n#include <cassert>\n\nint count_substrings(const std::string& s, int n) {\n    int count = 0, sum = 0;\n    std::unordered_map<int, int> mp;\n    mp[0] = 1;\n    for (int i = 0; i < n; ++i) {\n        sum += s[i] - '0';\n        if (mp.find(sum - i) != mp.end()) {\n            count += mp[sum - i];\n        }\n        mp[sum]++;\n    }\n    return count;\n}\n"], ["using namespace std;\nclass any {\npublic:\n    any() : content(nullptr) {}\n    template<typename T>\n    any(const T& value) : content(new Holder<T>(value)) {}\n    any(const any& other) : content(other.content ? other.content->clone() : nullptr) {}\n    ~any() { delete content; }\n    any& operator=(const any& other) {\n        if (this != &other) {\n            delete content;\n            content = other.content ? other.content->clone() : nullptr;\n        }\n        return *this;\n    }\n    template<typename T>\n    T& cast() {\n        return static_cast<Holder<T>*>(content)->held;\n    }\n    template<typename T>\n    const T& cast() const {\n        return static_cast<const Holder<T>*>(content)->held;\n    }\n    const type_info& type() const {\n        return content ? content->type() : typeid(void);\n    }\nprivate:\n    struct Placeholder {\n        virtual ~Placeholder() {}\n        virtual Placeholder* clone() const = 0;\n        virtual const type_info& type() const = 0;\n    };\n    template<typename T>\n    struct Holder : Placeholder {\n        T held;\n        Holder(const T& value) : held(value) {}\n        Placeholder* clone() const override {\n            return new Holder(held);\n        }\n        const type_info& type() const override {\n            return typeid(T);\n        }\n    };\n    Placeholder* content;\n};\n"], ["using namespace std;\n#include<iostream>\n#include <vector>\n#include <cassert>\n\nbool is_monotonic(std::vector<int> a) {\n    bool increasing = true;\n    bool decreasing = true;\n    for (int i = 0; i < a.size() - 1; ++i) {\n        if (a[i] < a[i + 1]) {\n            decreasing = false;\n        }\n        if (a[i] > a[i + 1]) {\n            increasing = false;\n        }\n    }\n    return increasing || decreasing;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\nbool dif_square(int n) {\n    if (n % 4 != 2) {\n        return true;\n    }\n    // Check if n can be expressed as 4k + 2\n    // This is because a number can be expressed as the difference of two squares if and only if it is not of the form 4k + 2\n    return true; // Since we already checked n % 4 != 2, this line is redundant but necessary for the structure\n}\n"], ["using namespace std;\n\n#include<cassert>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n\nbool is_samepatterns(std::vector<std::string> colors, std::vector<std::string> patterns) {\n    if (colors.size() != patterns.size()) {\n        return false;\n    }\n    std::map<std::string, std::vector<std::string>> sdict;\n    std::set<std::string> pset;\n    std::set<std::string> sset;\n    {\n        size_t i = 0;\n        for (; i < patterns.size(); ++i) {\n            pset.insert(patterns[i]);\n            sset.insert(colors[i]);\n            sdict[patterns[i]].push_back(colors[i]);\n        }\n    }\n\n    // Check if each pattern has exactly one color associated with it\n    for (const auto& pair : sdict) {\n        if (pair.second.size() != 1) {\n            return false;\n        }\n    }\n\n    // Check if all colors are used in the patterns\n    for (const auto& color : sset) {\n        bool found = false;\n        for (const auto& pattern : pset) {\n            if (std::find(sdict[pattern].begin(), sdict[pattern].end(), color) != sdict[pattern].end()) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <sstream>\n#include <cassert>\n\nstd::string find_tuples(const std::vector<std::vector<int>>& test_list, int k) {\n    std::vector<std::vector<int>> res;\n    for (const auto& sub : test_list) {\n        bool all_divisible = true;\n        for (int ele : sub) {\n            if (ele % k != 0) {\n                all_divisible = false;\n                break;\n            }\n        }\n        if (all_divisible) {\n            res.push_back(sub);\n        }\n    }\n    return \"Result: \" + std::to_string(res.size()) + \" tuples found.\";\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\ndouble count_squares(int m, int n) {\n    if (n < m) {\n        int temp = m;\n        m = n;\n        n = temp;\n    }\n    // Calculate the number of squares that can fit in the rectangle\n    int count = 0;\n    for (int i = 1; i <= min(m, n); ++i) {\n        count += (m - i + 1) * (n - i + 1);\n    }\n    return count;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <cassert>\n\nbool is_diff(int n) {\n    int sum_even = 0, sum_odd = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) {\n            sum_even += digit;\n        } else {\n            sum_odd += digit;\n        }\n        n /= 10;\n    }\n    return sum_even != sum_odd;\n}\n"], ["using namespace std;\n\n#include<cassert>\n#include <iostream>\n#include <bitset>\nint count_with_odd_set_bits(int n) {\n    if (n % 2 != 0) {\n        return (n + 1) / 2;\n    }\n    int count = std::bitset<32>(n).count();\n    //begin to write code\n    return count % 2 == 0 ? count / 2 : count / 2 + 1;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cassert>\n\nbool word_len(std::string s) {\n    std::istringstream iss(s);\n    std::vector<std::string> words;\n    std::string word;\n    for(;(iss >> word);){\n        words.push_back(word);\n    }\n    for (std::string w : words) {\n        if (w.length() % 2 != 0) {\n            return true;\n        }\n    }\n    return false;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble volume_sphere(double r) {\n    double volume = (4.0 / 3.0) * M_PI * r * r * r;\n    return volume;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <string>\n#include <cassert>\n\nchar get_char(std::string strr) {\n    int summ = 0;\n    for (int i = 0; i < strr.length(); ++i) {\n        summ += (strr[i] - 'a' + 1);\n    }\n    if (summ % 26 == 0) {\n        return 'z';\n    } else {\n        return 'a' + (summ % 26) - 1;\n    }\n}\n"], ["using namespace std;\n#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble surfacearea_sphere(double r) {\n    double surfacearea = 4 * M_PI * r * r;\n    return surfacearea;\n}\n"], ["using namespace std;\n#include<iostream>\n#include <cassert>\nint closest_num(int n) {\n    if (n <= 1) {\n        return -1; // No smaller number than 1\n    }\n    int closest = n - 1;\n    while (closest > 0 && closest % 2 == 0) {\n        closest--;\n    }\n    return closest;\n}\n"], ["using namespace std;\nint find_min_length(vector<vector<int>>& lst) {\n    int min_length = INT_MAX;\n    for (auto& v : lst) {\n        if (v.size() < min_length) {\n            min_length = v.size();\n        }\n    }\n    return min_length;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <climits>\n#include <string>\n#include <cassert>\n\nint next_smallest_palindrome(int num) {\n    for (int i = num + 1; i < INT_MAX; ++i) {\n        std::string num_str = std::to_string(i);\n        std::string reversed_str = std::string(num_str.rbegin(), num_str.rend());\n        if (num_str == reversed_str) {\n            return i;\n        }\n    }\n    return -1; // Return -1 if no palindrome is found (should not happen for positive integers)\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\n\nstd::string snake_to_camel(const std::string& word) {\n    std::vector<std::string> parts;\n    std::string part;\n    std::istringstream token_stream(word);\n    while (getline(token_stream, part, '_')) {\n        if (!part.empty()) {\n            part[0] = toupper(part[0]); // Capitalize the first letter\n            parts.push_back(part);\n        } else {\n            // Handle empty parts (should not happen with valid input)\n            assert(false);\n        }\n    }\n\n    std::string result;\n    for (size_t i = 0; i < parts.size(); ++i) {\n        result += parts[i];\n    }\n\n    return result;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <cassert>\nint count_hexadecimal(int l, int r) {\n    int count = 0;  \n    for (int i = l; i <= r; i++) { \n        if (i >= 10 && i <= 15) { \n            count++;  \n        } else if (i > 15) { \n            int k = i;  \n            while (k != 0) {  \n                if (k % 16 >= 10) { \n                    count++;  \n                } \n                k /= 16;  \n            }  \n        }  \n    }  \n    return count;  \n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint odd_equivalent(const std::string& s, int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '1') {\n            // Check if the number of '1's in the substring from i to the end is odd\n            int ones_count = 0;\n            for (int j = i; j < n; ++j) {\n                if (s[j] == '1') {\n                    ++ones_count;\n                }\n            }\n            if (ones_count % 2 != 0) {\n                ++count;\n            }\n        }\n    }\n    return count;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint search(const std::vector<int>& arr, int n) {\n    int x_o_r = 0;\n    for (int i = 0; i < n; i++) {\n        x_o_r ^= arr[i];\n    }\n    return x_o_r;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool check_triplet(const std::vector<int>& a, int n, int sum, int count) {\n    if (count == 3 && sum == 0) {\n        return true;\n    }\n\n    for (int i = count; i < n; ++i) {\n        if (check_triplet(a, n, sum - a[i], count + 1)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"], ["using namespace std;\nconst int m_a_x = 3000;\nint smart_number(int n) {\n    vector<int> primes(m_a_x, 0);\n    vector<int> result;\n    for (int i = 2; i < m_a_x; i++) {\n        if (primes[i] == 0) {\n            primes[i] = 1;\n            int j = i * 2;\n            while (j < m_a_x) {\n                primes[j] -= 1;\n                if (primes[j] == 0) {\n                    result.push_back(j);\n                }\n                j += i;\n            }\n        }\n    }\n    return result[n - 1];\n}\n"], ["using namespace std;\nint amicable_numbers_sum(int limit) {\n    if (limit < 1) {\n        throw invalid_argument(\"Input must be bigger than 0!\");\n    }\n    set<int> amicables;\n    for (int num = 2; num <= limit; num++) {\n        if (amicables.find(num) != amicables.end()) {\n            continue;\n        }\n        int sum_fact = 0;\n        {\n            int fact = 1;\n            for (; fact < num; fact++) {\n                if (num % fact == 0) {\n                    sum_fact += fact;\n                }\n            }\n        }\n        int sum_fact2 = 0;\n        {\n            int fact = 1;\n            for (; fact < sum_fact; fact++) {\n                if (sum_fact % fact == 0) {\n                    sum_fact2 += fact;\n                }\n            }\n        }\n        if (sum_fact2 == num && num != sum_fact) {\n            amicables.insert(num);\n            amicables.insert(sum_fact);\n        }\n    }\n    int sum = 0;\n    for (int num : amicables) {\n        sum += num;\n    }\n    return sum;\n}\n"], ["\nusing namespace std;\n\n#include<cassert>\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <set>\n\nbool magic_square_test(const std::vector<std::vector<int>>& my_matrix) {\n    size_t i_size = my_matrix[0].size();\n    std::vector<int> sum_list;\n    // Sum of each row\n    for (const auto& line : my_matrix) {\n        sum_list.push_back(std::accumulate(line.begin(), line.end(), 0));\n    }\n    // Sum of each column\n    {\n        size_t col = 0;\n        for (; col < i_size; ++col) {\n            int col_sum = 0;\n            {\n                size_t row = 0;\n                for (; row < i_size; ++row) {\n                        col_sum += my_matrix[row][col];\n                    }\n            }\n            sum_list.push_back(col_sum);\n        }\n    }\n    // Sum of the main diagonal\n    {\n        "], ["Complete code (including all the content of the code I provided and the code you generated)\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::string check_last(const std::vector<int>& arr, int n, int p) {\n    int sum = 0;\n    {\n        int i = 0;\n        while(i < n){\n            sum += arr[i];\n            ++i;\n        }\n    }\n    if (p == 1) {\n        if (sum % 2 == 0) {\n            return \"even\";\n        } else {\n            return \"odd\";\n        }\n    }\n    // Additional logic for p > 1 can be added here if needed\n    return \"even\"; // Default return for p > 1, assuming the last element remains even\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\nbool is_sum_of_powers_of_two(int n) {\n    if (n % 2 == 1) {\n        return false;\n    }\n    while (n > 0) {\n        if (n % 2 != 0) {\n            return false;\n        }\n        n /= 2;\n    }\n    return true;\n}\n"], ["#include<cassert>\n#include <iostream>\n#include <tuple>\n#include <vector>\n\ntemplate <typename... args>\nint find_lists(const std::tuple<args...>& input) {\n    return sizeof...(args);\n}\n\n//begin to write code\n"], ["using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint sum_pairs(const std::vector<int>& arr, int n) {\n    int sum = 0;\n    for (int i = n - 1; i >= 0; --i) {\n        for (int j = 0; j < i; ++j) {\n            sum += abs(arr[i] - arr[j]);\n        }\n    }\n    return sum;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint max_abs_diff(const std::vector<int>& arr, int n) {\n    int min_ele = arr[0];\n    int max_ele = arr[0];\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < min_ele) {\n            min_ele = arr[i];\n        }\n        if (arr[i] > max_ele) {\n            max_ele = arr[i];\n        }\n    }\n    return max_ele - min_ele;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\nint sum_digits_single(int x) {\n    int ans = 0;\n    for(;(x);){\n        ans += x % 10;\n        x /= 10;\n    }\n    return ans;\n}\n\nint closest(int x) {\n    int max_sum = 0;\n    int best_split = -1;\n    for(int i = 1; i < x; ++i) {\n        int left_sum = sum_digits_single(i);\n        int right_sum = sum_digits_single(x - i);\n        int total_sum = left_sum + right_sum;\n        if(total_sum > max_sum) {\n            max_sum = total_sum;\n            best_split = i;\n        }\n    }\n    return best_split;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\nbool does_contain_b(int a, int b, int c) {\n    if (a == b) {\n        return true;\n    }\n    // Check if b is between a and c\n    if (a < b && b < c || a > b && b > c) {\n        return true;\n    }\n    return false;\n}\n"], ["Complete code (including all the content of the code I provided and the code you generated)\n\n#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<int> merge(vector<int>& a, vector<int>& b) {\n    vector<int> c;\n    while (!a.empty() && !b.empty()) {\n        if (!(a.front() < b.front())) {\n            c.push_back(b.front());\n            b.erase(b.begin());\n        }\n        else {\n            c.push_back(a.front());\n            a.erase(a.begin());\n        }\n    }\n    if (a.empty()) {\n        c.insert(c.end(), b.begin(), b.end());\n    } else {\n        c.insert(c.end(), a.begin(), a.end());\n    }\n    return c;\n}\n\nvector<int> mergeSort(vector<int>& arr) {\n    if (arr.size() <= 1) {\n        return arr;\n    }\n    int mid = arr.size() / 2;\n    vector<int> left(arr.begin(), arr.begin() + mid);\n    vector<int> right(arr.begin() + mid, arr.end());\n\n    left = mergeSort(left);\n    right = mergeSort(right);\n\n    return merge(left, right);\n}\n"], ["#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<int> specified_element(vector<vector<int>>& nums, int n) {\n    vector<int> result;\n    for (auto& i : nums) {\n        if (i.size() > n) {\n            result.push_back(i[n]);\n        }\n    }\n    return result;\n}\n"], ["using namespace std;\n"], ["Complete code (including all the content of the code I provided and the code you generated)\n"], ["using namespace std;\n\nstd::string month_season(std::string month, int days) {\n    std::string season;\n    if (month == \"January\" || month == \"February\" || month == \"March\") {\n        season = \"winter\";\n    } else if (!(month == \"April\" || month == \"May\" || month == \"June\")) {\n        if (month == \"July\" || month == \"August\" || month == \"September\") {\n            season = \"summer\";\n        } else {\n            season = \"autumn\";\n        }\n    } else {\n        season = \"spring\";\n    }\n    return season;\n}\n"], ["using namespace std;\ndouble area_polygon(int s, double l) {\n  double area = s * (l * l) / (4 * tan(M_PI / s));\n  return area;\n}\n"], ["using namespace std;\nint div_sum(int n) {\n    int sum = 1;\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            sum += i + (n / i);\n        }\n        if (i * i == n) {\n            sum -= i; // Subtract i again if it's a perfect square\n        }\n        i++;\n    }\n    return sum;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_even_pair(const std::vector<int>& a, int n) {\n    int even_pair = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if ((a[i] ^ a[j]) % 2 == 0) {\n                even_pair++;\n            }\n        }\n    }\n    return even_pair;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint next_power_of_2(int n) {\n    int count = 0;\n    if (n && !(n & (n - 1))) {\n        return n;\n    }\n    while (n > 0) {\n        n >>= 1;\n        count++;\n    }\n    return 1 << count;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <cassert>\n#include <utility> // For std::pair\n\nstd::pair<int, int> answer(int l, int r) {\n    if (2 * l <= r) {\n        return std::make_pair(l, 2 * l);\n    }\n    // Find the smallest number greater than or equal to l that has an lcm with l within the range [l, r]\n    for (int i = l; i <= r; ++i) {\n        if (lcm(l, i) >= l && lcm(l, i) <= r) {\n            return std::make_pair(l, i);\n        }\n    }\n    // If no such pair is found, return a default value or handle the error as needed\n    return std::make_pair(-1, -1); // Assuming -1 indicates no valid pair found\n}\n"], ["using namespace std;\nstring string_literals(const vector<string>& patterns, const string& text) {\n    for (const auto& pattern : patterns) {\n        regex re_pattern(pattern);\n        if (regex_search(text, re_pattern)) {\n            return \"Matched!\";\n        }\n    }\n    return \"Not matched!\";\n}\n"], ["using namespace std;\nbool is_num_keith(int x) {\n    vector<int> terms;\n    int temp = x;\n    int n = 0;\n    for(;(temp > 0);){\n        terms.push_back(temp % 10);\n        temp = temp / 10;\n        n++;\n    }\n    reverse(terms.begin(), terms.end());\n    int next_term = 0;\n    int i = n;\n    while(next_term < x){\n        next_term = 0;\n        for(int j = 0; j < i; j++){\n            next_term += terms[j];\n        }\n        terms.push_back(next_term);\n        i++;\n    }\n    return next_term == x;\n}\n"], ["Complete code (including all the content of the code I provided and the code you generated)\n\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nint longest_common_subsequence(const string &x, const string &y, int m, int n) {\n    if (m == 0 || n == 0) {\n        return 0;\n    } else if (x[m-1] == y[n-1]) {\n        return 1 + longest_common_subsequence(x, y, m-1, n-1);\n    } else {\n        return max(longest_common_subsequence(x, y, m-1, n), longest_common_subsequence(x, y, m, n-1));\n    }\n}\n"], ["using namespace std;\n#include <iostream>\n#include <cassert>\n\nbool prod_square(int n) {\n    for (int i = 2; i <= n; ++i) {\n        if (i * i < (n + 1)) {\n            for (int j = 2; j <= n; ++j) {\n                if ((i * i * j * j) == n) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint first_missing_positive(std::vector<int> arr, int n) {\n    int ptr = 0;\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] == 1) {\n            ptr = 1;\n            break;\n        }\n    }\n    if (ptr == 0) {\n        return 1;\n    }\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] <= 0 || arr[i] > n) {\n            arr[i] = n + 1;\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        int index = abs(arr[i]) - 1;\n        if (index < n && arr[index] > 0) {\n            arr[index] = -arr[index];\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > 0) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <cassert>\n\nint count_intgral_points(int x1, int y1, int x2, int y2) {\n    // Calculate the width and height of the square\n    int width = abs(x2 - x1);\n    int height = abs(y2 - y1);\n\n    // The number of integral points inside the square is (width + 1) * (height + 1)\n    return (width + 1) * (height + 1);\n}\n"], ["using namespace std;\n#include<cassert>\n#include <iostream>\n#include <string>\n#include <cctype>\nbool check_string(const std::string& str) {\n    bool flag_l = false;\n    bool flag_n = false;\n    for (char i : str) {\n        if (isalpha(i)) {\n            flag_l = true;\n        } else if (isdigit(i)) {\n            flag_n = true;\n        }\n    }\n    return flag_l && flag_n;\n}\n"], ["using namespace std;\n#include<cassert>\n#include<iostream>\nint octal_to_decimal(int n) {  \n    int num = n; \n    int dec_value = 0; \n    int base = 1; \n    int temp = num; \n    while (temp) { \n        int last_digit = temp % 10; \n        dec_value += last_digit * base; \n        temp /= 10; \n        base *= 8; \n    } \n    return dec_value; \n}\n"], ["Complete code (including all the content of the code I provided and the code you generated)\n\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<vector<int>> remove_tuples(vector<vector<int>> test_list, int k) {\n    vector<vector<int>> res;\n    for (auto ele : test_list) {\n        if ((int)ele.size() != k) {\n            res.push_back(ele);\n        }\n    }\n    return res;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint highest_power_of_2(int n) {\n    int res = 0;\n    for (int i = n; i > 0; i--) {\n        if ((i & (i - 1)) == 0) {\n            res = i;\n            break;\n        }\n    }\n    return res;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\n\nbool chk_list(const std::vector<std::string>& lst) {\n    if (lst.empty()) {\n        return true; // An empty list is considered to have all elements the same\n    }\n    \n    std::set<std::string> unique_elements(lst.begin(), lst.end());\n    return unique_elements.size() == 1;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint hamming_distance(int n1, int n2) {\n    int x = n1 ^ n2;\n    int set_bits = 0;\n    while (x > 0) {\n        set_bits += x & 1; // Increment set_bits if the least significant bit is 1\n        x >>= 1; // Right shift x by 1 to check the next bit\n    }\n    return set_bits;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint count_num(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if ((i & 1) && (i & (n - 1))) {\n            count++;\n        }\n    }\n    return count;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <cassert>\n#include <cmath>\nint fourth_power_sum(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += pow(i, 4);\n    }\n    return sum;\n}\n"], ["using namespace std;\n#include <cmath>\n#include <cassert>\n#include <iostream>\ndouble degree_radian(double radian) {\n    double degree = radian * (180.0 / M_PI);\n    return degree;\n}\n"], ["using namespace std;\nchar first_repeated_char(string str) \n{\n    unordered_map<char, int> h;\n    for (char ch : str) {\n        if (h.find(ch) != h.end()) { \n            return ch;\n        }\n        h[ch]++;\n    }\n    return '\\0'; // Return null character if no repeated character is found\n}\n"], ["using namespace std;\nint gcd(int a, int b) {\n    for(;(b != 0);){\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint minOperationsToEqual(int a, int b) {\n    if (a == b) {\n        return 0;\n    }\n    int commonDivisor = gcd(a, b);\n    return (a / commonDivisor) + (b / commonDivisor) - 1;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<std::vector<int>> extract_min_max(std::vector<int> test_vec, int k) {\n    std::vector<int> res;\n    std::sort(test_vec.begin(), test_vec.end());\n    for (int idx = 0; idx < test_vec.size(); ++idx) {\n        if (idx < k || idx >= test_vec.size() - k) {\n            res.push_back(test_vec[idx]);\n        }\n    }\n    return std::make_tuple(res);\n}\n"], ["using namespace std;\nint binary_search(const vector<int>& arr, int low, int high, int x) {\n    if (high >= low) {\n        int mid = (low + high) / 2;\n        if (!((mid == 0 || x > arr[mid - 1]) && (arr[mid] == x))) if (x > arr[mid])\n            return binary_search(arr, mid + 1, high, x);\n        else\n            return binary_search(arr, low, mid - 1, x);\n        else return mid;\n    }\n    return -1; // Return -1 if the element is not found\n}\n"], ["using namespace std;\n#include <cassert>\n\nint count_set_bits(int n) {\n    int count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1; // Right shift n by 1 bit\n    }\n    return count;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_min(std::vector<int>& arr, int low, int high) {\n    while (low < high) {\n        int mid = low + (high - low) / 2;   \n        if (arr[mid] == arr[high]) {\n            high -= 1; \n        } else if (arr[mid] > arr[high]) {\n            low = mid + 1; // Minimum must be in the right half\n        } else {\n            high = mid; // Minimum must be in the left half\n        }\n    }\n    return arr[low];\n}\n"], ["using namespace std;\nbool all_bits_set_in_the_given_range(int n, int l, int r) {\n    int num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1));\n    return (n & num) == 0;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint no_of_triangle(int n, int k) {\n    if (n < k) {\n        return -1;\n    } else {\n        int tri_up = 0;\n        for (int i = 1; i <= n; ++i) {\n            tri_up += n - i + 1;\n        }\n        return tri_up;\n    }\n}\n"], ["using namespace std;\nint get_total_number_of_sequences(int m, int n) {\n    vector<vector<int>> t(m+1, vector<int>(n+1, 0));\n    for(int i = 0; i <= m; ++i) {\n        for(int j = 0; j <= n; ++j) {\n            if(i == 0 || j == 0) {\n                t[i][j] = 0;\n            } else if(i < j) {\n                t[i][j] = 0;\n            } else {\n                t[i][j] = t[i-1][j] + t[i/2][j-1];\n            }\n        }\n    }\n    return t[m][n];\n}\n"], ["using namespace std;\ntemplate <typename t>\nvector<pair<t, pair<vector<string>, int>>> sort_on_occurence(vector<pair<t, string>> const lst) {\n    unordered_map<t, vector<string>> counter;\n    for (const auto& item : lst) {\n        counter[item.first].push_back(item.second);\n    }\n    vector<pair<t, pair<vector<string>, int>>> result;\n    for (const auto& entry : counter) {\n        set<string> unique_strings(entry.second.begin(), entry.second.end());\n        result.emplace_back(entry.first, make_pair(vector<string>(unique_strings.begin(), unique_strings.end()), entry.second.size()));\n    }\n    return result;\n}\ntemplate <typename t>\nbool compare_results(const vector<pair<t, pair<vector<string>, int>>>& result, const vector<pair<t, pair<vector<string>, int>>>& expected) {\n    if (result.size() != expected.size()) return false;\n    set<t> result_first_elements;\n    set<t> expected_first_elements;\n    for (const auto& res_entry : result) {\n        result_first_elements.insert(res_entry.first);\n    }\n    for (const auto& exp_entry : expected) {\n        expected_first_elements.insert(exp_entry.first);\n    }\n    return result_first_elements == expected_first_elements;\n}\n"], ["using namespace std;\n#include<iostream>\n#include <cmath>\n#include <cassert>\nint next_perfect_square(int n) {\n    int next_n = std::floor(std::sqrt(n)) + 1;\n    return next_n * next_n;\n}\n"], ["using namespace std;\nint max_sum(vector<int> arr, int n) {\n    vector<int> m_s_i_b_s = arr;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (arr[i] > arr[j] && m_s_i_b_s[i] < m_s_i_b_s[j] + arr[i]) {\n                m_s_i_b_s[i] = m_s_i_b_s[j] + arr[i];\n            }\n        }\n    }\n    vector<int> m_s_d_b_s = arr;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (arr[i] < arr[j] && m_s_d_b_s[i] < m_s_d_b_s[j] + arr[i]) {\n                m_s_d_b_s[i] = m_s_d_b_s[j] + arr[i];\n            }\n        }\n    }\n    int max_sum = INT_MIN;\n    for (int i = 0; i < n; ++i) {\n        max_sum = max(max_sum, m_s_i_b_s[i] + m_s_d_b_s[i] - arr[i]);\n    }\n    return max_sum;\n}\n"], ["Complete code (including all the content of the code I provided and the code you generated)\n\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint lps(string str) {\n    int n = str.size();\n    vector<vector<int>> l(n, vector<int>(n, 0));\n    for (int i = 0; i < n; i++)\n        l[i][i] = 1;\n    for (int cl = 2; cl <= n; cl++) {\n        for (int i = 0; i < n - cl + 1; i++) {\n            int j = i + cl - 1;\n            if (str[i] == str[j] && cl == 2)\n                l[i][j] = 2;\n            else if (str[i] == str[j])\n                l[i][j] = l[i + 1][j - 1] + 2;\n            else\n                l[i][j] = max(l[i + 1][j], l[i][j - 1]);\n        }\n    }\n    return l[0][n - 1];\n}\n"], ["using namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_x(const std::vector<int>& tup, int x) {\n    int count = 0;\n    for (int ele : tup) {\n        if (ele == x) {\n            count++;\n        }\n    }\n    return count;\n}\n"], ["using namespace std;\nclass base {\npublic:\n    virtual ~base() = default;\n    virtual bool isInteger() const = 0;\n};\nclass derived_int : public base {\npublic:\n    derived_int(int value) : value(value) {}\n    bool isInteger() const override {\n        return true;\n    }\nprivate:\n    int value;\n};\nclass derived_double : public base {\npublic:\n    derived_double(double value) : value(value) {}\n    bool isInteger() const override {\n        return false;\n    }\n};\n\nint countIntegers(const vector<shared_ptr<base>>& items) {\n    int count = 0;\n    for (const auto& item : items) {\n        if (item->isInteger()) {\n            ++count;\n        }\n    }\n    return count;\n}\n"], ["using namespace std;\n#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nstd::vector<std::vector<std::string>> combinations_colors(const std::vector<std::string>& l, int n) {\n    std::vector<std::vector<std::string>> result;\n    std::vector<int> indices(n, 0);\n    int size = l.size();\n    while (true) {\n        // Add current combination\n        std::vector<std::string> current;\n        for (int i = 0; i < n; ++i) {\n            current.push_back(l[indices[i]]);\n        }\n        result.push_back(current);\n        // Generate next combination\n        int next = n - 1;\n        for(;(next >= 0 && indices[next] == size - 1);){\n            --next;\n        }\n        if (next < 0) {\n            break;\n        }\n        ++indices[next];\n        for(int i = next + 1; i < n; ++i){\n            indices[i] = indices[next];\n        }\n    }\n    return result;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint count_primes_nums(int n) {\n    int ctr = 0;\n    for (int num = 0; num < n; ++num) {\n        if (num <= 1) {\n            continue;\n        }\n        bool is_prime = true;\n        for (int i = 2; i < num; ++i) {\n            if (num % i == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            ++ctr;\n        }\n    }\n    return ctr;\n}\n"], ["using namespace std;\n#include<iostream>\n#include <vector>\n#include <cassert>\n#include <utility>\ntemplate<typename T>\nstd::pair<std::vector<T>, std::vector<T>> split_two_parts(const std::vector<T>& list1, int l) {\n    std::vector<T> first_part(list1.begin(), list1.begin() + l);\n    std::vector<T> second_part(list1.begin() + l, list1.end());\n    return {first_part, second_part};\n}\n"], ["Complete code (including all the content of the code I provided and the code you generated)\n\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\ntemplate <typename T>\nvector<vector<T>> list_split(vector<T> s, int step) {\n    vector<vector<T>> result(step);\n    for (int i = 0; i < step; ++i) {\n        for (int j = i; j < s.size(); j += step) {\n            result[i].push_back(s[j]);\n        }\n    }\n    return result;\n}\n"], ["using namespace std;\n#include<iostream>\n#include <cassert>\nint lateralsurface_cube(int l) {\n    int l_s_a = 4 * (l * l);\n    return l_s_a;\n}\n"], ["using namespace std;\n#include <cassert>\n\nint square_sum(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i += 2) {\n        sum += i * i;\n    }\n    return sum;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\n// 函数定义\nint even_power_sum(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        int even_number = 2 * i;\n        sum += pow(even_number, 5);\n    }\n    return sum;\n}\n"], ["using namespace std;\n#include<cassert>\n#include <iostream>\n\nint even_binomial_coeff_sum(int n) {\n    int sum = 0;\n    for (int i = 0; i <= n; i += 2) {\n        sum += binomial_coefficient(n, i);\n    }\n    return sum;\n}\n"], ["using namespace std;\nint get_position(vector<int>& a, int n, int m) {\n    {\n        int i = 0;\n        for (; i < n; ++i) {\n            a[i] = (a[i] / m + (a[i] % m != 0));\n        }\n    }\n    int result = -1, maxx = -1;\n    for (int i = n - 1; i >= 0; --i) {\n        if (a[i] == 1) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n"], ["using namespace std;\ntemplate <size_t index, typename Tuple>\nint count_first_elements_helper(const Tuple& t, true_type) {\n    return 0;\n}\ntemplate <size_t index, typename Tuple>\nint count_first_elements_helper(const Tuple& t, false_type) {\n    if constexpr (index == 0) {\n        return 1;\n    } else {\n        return count_first_elements_helper<index - 1, Tuple>(t, false_type());\n    }\n}\n\ntemplate <typename Tuple>\nint count_first_elements(const Tuple& t) {\n    return count_first_elements_helper<tuple_size<Tuple>::value - 1, Tuple>(t, false_type());\n}\n"], ["using namespace std;\n#include<iostream>\n#include <cassert>\nint square_sum(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        int even_number = 2 * i;\n        sum += even_number * even_number;\n    }\n    return sum;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint modular_inverse(const std::vector<int>& arr, int n, int p) {\n    int current_element = 0;\n    for (int i = 0; i < n; ++i) {\n        if ((arr[i] * arr[i]) % p == 1) {\n            current_element = arr[i];\n            break;\n        }\n    }\n    return current_element;\n}\n"], ["using namespace std;\nint odd_days(int n) {\n    int hund1 = n / 100;\n    int hund4 = n / 400;\n    int leap = n >> 2;\n    int ordd = n - leap;\n    if (hund1) {\n        ordd += hund1;\n        leap -= hund1;\n        if (hund4) {\n            ordd -= hund4;\n        }\n    }\n    return ordd % 7;\n}\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_inv_count(vector<int> arr, int n) {\n    int inv_count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (arr[i] > arr[j]) {\n                inv_count++;\n            }\n        }\n    }\n    return inv_count;\n}\n"], ["using namespace std;\n#include <vector>\n#include <iostream>\n#include <cassert>\n\nclass variant {\npublic:\n    virtual ~variant() = default;\n    virtual bool is_int() const = 0;\n    virtual bool is_vector() const = 0;\n    virtual int get_int() const = 0;\n    virtual const vector<variant*>& get_vector() const = 0;\n};\n\nclass int_variant : public variant {\npublic:\n    int_variant(int value) : value(value) {}\n    bool is_int() const override { return true; }\n    bool is_vector() const override { return false; }\n    int get_int() const override { return value; }\n    const vector<variant*>& get_vector() const override { throw runtime_error(\"Not a vector\"); }\nprivate:\n    int value;\n};\n\nclass vector_variant : public variant {\npublic:\n    vector_variant(const vector<variant*>& value) : value(value) {}\n    bool is_int() const override { return false; }\n    bool is_vector() const override { return true; }\n    int get_int() const override { throw runtime_error(\"Not an int\"); }\n    const vector<variant*>& get_vector() const override { return value; }\nprivate:\n    vector<variant*> value;\n};\n\nvoid flatten_list(const vector<variant*>& list1, vector<int>& result_list) {\n    for (const auto& element : list1) {\n        if (element->is_int()) {\n            result_list.push_back(element->get_int());\n        } else if (element->is_vector()) {\n            const auto& sub_list = element->get_vector();\n            flatten_list(sub_list, result_list);\n        } else {\n            throw runtime_error(\"Unknown variant type\");\n        }\n    }\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\ndouble count_binary_seq(int n) {\n    double n_cr = 1;\n    double res = 1;\n    for(int r = 1; r <= n; ++r) {\n        n_cr *= (n + 1 - r);\n        n_cr /= r;\n        res += n_cr;\n    }\n    return res;\n}\n"], ["using namespace std;\nclass variant {\npublic:\n    virtual ~variant() = default;\n};\nclass int_variant : public variant {\npublic:\n    int_variant(int value) : value(value) {}\n    int get_int() const {\n        return this->value;\n    }\nprivate:\n    int value;\n};\nclass map_variant : public variant {\npublic:\n    map_variant(const std::unordered_map<char, variant*>& map) : map(map) {}\n    const std::unordered_map<char, variant*>& get_map() const {\n        return this->map;\n    }\nprivate:\n    std::unordered_map<char, variant*> map;\n};\n\nint find_depth(const variant& v) {\n    if (auto* int_var = dynamic_cast<const int_variant*>(&v)) {\n        return 0; // Base case: an integer has no depth\n    } else if (auto* map_var = dynamic_cast<const map_variant*>(&v)) {\n        int max_depth = 0;\n        for (const auto& pair : map_var->get_map()) {\n            int depth = find_depth(*pair.second);\n            if (depth > max_depth) {\n                max_depth = depth;\n            }\n        }\n        return max_depth + 1; // Add 1 for the current level\n    } else {\n        throw std::runtime_error(\"Unsupported variant type\");\n    }\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\n// 函数定义\nint set_bit_number(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    int msb = 0;\n    // 找到最高位的1的位置\n    while (n > 0) {\n        n >>= 1; // 右移一位\n        msb++;\n    }\n    return msb;\n}\n"], ["Complete code (including all the content of the code I provided and the code you generated)\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_element(const std::vector<int>& arr, const std::vector<std::pair<int, int>>& ranges, int rotations, int index) {\n    for (int i = rotations - 1; i >= 0; --i) {\n        int left = ranges[i].first;\n        int right = ranges[i].second;\n        if (left <= index && right >= index) {\n            if (index == left) {\n                index = right;\n                //begin to write code\n                return arr[index];\n            }\n        }\n    }\n    return -1; // Return -1 if the index is not found after all rotations\n}\n"], ["#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint max_sum_increasing_subseq(vector<int> a, int n, int index, int k) {\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    {\n        int i = 0;\n        for (; i < n; ++i) {\n            if (a[i] > a[0]) {\n                dp[0][i] = a[i] + a[0];\n            } else {\n                dp[0][i] = a[i];\n            }\n        }\n    }\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (a[j] > a[i] && j > i) {\n                dp[i][j] = max(dp[i-1][j], dp[i][k] + a[j]);\n            } else {\n                dp[i][j] = max(dp[i-1][j], a[j]);\n            }\n        }\n    }\n    return dp[n-1][k];\n}\n"], ["using namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> large_product(const std::vector<int>& nums1, const std::vector<int>& nums2, int n) {\n    std::vector<int> products;\n    for (int x : nums1) {\n        for (int y : nums2) {\n            products.push_back(x * y);\n        }\n    }\n    // Sort the products in descending order\n    std::sort(products.begin(), products.end(), std::greater<int>());\n    // Return the first n largest products\n    return std::vector<int>(products.begin(), products.begin() + n);\n}\n"], ["using namespace std;\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble volume_cone(double r, double h) {\n    double volume = (1.0/3) * M_PI * r * r * h;\n    return volume;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string find_max_len_even(const std::string& str) {\n    int n = str.length();\n    int i = 0;\n    int currlen = 0;\n    int maxlen = 0;\n    int st = -1;\n    while (i < n) {\n        if (str[i] == ' ') {\n            if (currlen % 2 == 0) {\n                if (maxlen < currlen) {\n                    maxlen = currlen;\n                    st = i - currlen;\n                }\n            }\n            currlen = 0;\n        } else {\n            currlen++;\n        }\n        i++;\n    }\n    if (currlen % 2 == 0 && maxlen < currlen) {\n        maxlen = currlen;\n        st = i - currlen;\n    }\n    if (st == -1) {\n        return \"\";\n    }\n    return str.substr(st, maxlen);\n}\n"], ["Complete code (including all the content of the code I provided and the code you generated)\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_last_occurrence(const std::vector<int>& a, int x) {\n    int left = 0;\n    int right = a.size() - 1;\n    int result = -1;\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (x == a[mid]) {\n            result = mid;\n            left = mid + 1; // Move left to find the last occurrence\n        } else if (x < a[mid]) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return result;\n}\n"], ["Complete code (including all the content of the code I provided and the code you generated)\n\n"], ["using namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nvoid right_rotate(std::vector<int>& arr, int n, int out_of_place, int cur) {\n    int temp = arr[cur];\n    {\n        int i = cur;\n        for (; i > out_of_place; --i) {\n            arr[i] = arr[i - 1];\n        }\n    }\n    arr[out_of_place] = temp;\n}\n\nstd::vector<int> re_arrange(std::vector<int>& arr, int n) {\n    int out_of_place = -1;\n    for (int index = 0; index < n; ++index) {\n        if (out_of_place >= 0) {\n            if ((arr[index] >= 0 && arr[out_of_place] < 0) ||\n                (arr[index] < 0 && arr[out_of_place] >= 0)) {\n                right_rotate(arr, n, out_of_place, index);\n                if (index - out_of_place > 2) {\n                    out_of_place += 2;\n                } else {\n                    out_of_place = -1;\n                }\n            }\n        } else if (arr[index] < 0) {\n            out_of_place = index;\n        }\n    }\n    return arr;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n\nint get_min_squares(int n) {\n    if (n <= 3) {\n        return n;\n    }\n    int res = n;\n    for (int x = 1; x <= n; ++x) {\n        int temp = x * x;\n        if (temp > n) {\n            break;\n        }\n        res = min(res, 1 + get_min_squares(n - temp));\n    }\n    return res;\n}\n"], ["using namespace std;\nstring most_occurrences(vector<string> test_list) {\n    unordered_map<string, int> temp;\n    for (auto& sub : test_list) {\n        stringstream ss(sub);\n        string wrd;\n        for(;(ss >> wrd);){\n            temp[wrd]++;\n        }\n    }\n\n    string result;\n    int max_count = 0;\n    for (const auto& pair : temp) {\n        if (pair.second > max_count) {\n            max_count = pair.second;\n            result = pair.first;\n        }\n    }\n\n    return result;\n}\n"], ["using namespace std;\n#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n// Sorting function based on the second element of the pairs\nvoid sort(vector<pair<string, int>>& sub_li) {\n    sort(sub_li.begin(), sub_li.end(), [](const pair<string, int>& a, const pair<string, int>& b) {\n        return a.second < b.second;\n    });\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\nbool check_validity(int a, int b, int c) {\n    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {\n        return false;\n    }\n    return true;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <string>\n#include <cassert>\n\nbool check_equality(const std::string& s) {\n    return s.front() == s.back();\n}\n\nint count_substring_with_equal_ends(const std::string& s) {\n    int result = 0;\n    int n = s.length();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            if (check_equality(s.substr(i, j - i + 1))) {\n                ++result;\n            }\n        }\n    }\n    return result;\n}\n"], ["using namespace std;\n#include<iostream>\n#include <cassert>\n\n// 函数定义\nint find_divisor(int x, int y) {\n    if (x == y) {\n        return x; // If x and y are the same, the maximum divisor is x itself\n    }\n    int max_divisor = 1;\n    for (int i = 2; i <= min(x, y); ++i) {\n        if (x % i == 0 && y % i == 0) {\n            max_divisor = i;\n        }\n    }\n    return max_divisor;\n}\n"], ["using namespace std;\nclass node {\npublic:\n    int value;\n    int list_num;\n    int index;\n    node(int value, int list_num, int index) : value(value), list_num(list_num), index(index) {}\n    bool operator<(const node& other) const {\n        return value > other.value; // Use greater to simulate min heap in priority queue\n    }\n};\npair<int, int> find_minimum_range(vector<vector<int>>& lists) {\n    int high = numeric_limits<int>::min();\n    pair<int, int> p = make_pair(0, numeric_limits<int>::max());\n    priority_queue<node> pq;\n    for (int i = 0; i < lists.size(); ++i) {\n        pq.push(node(lists[i][0], i, 0));\n        high = max(high, lists[i][0]);\n    }\n    while (!pq.empty()) {\n        node current = pq.top();\n        pq.pop();\n        if (high - current.value < p.second - p.first) {\n            p.first = current.value;\n            p.second = high;\n        }\n        if (current.index + 1 < lists[current.list_num].size()) {\n            pq.push(node(lists[current.list_num][current.index + 1], current.list_num, current.index + 1));\n            high = max(high, lists[current.list_num][current.index + 1]);\n        } else {\n            break;\n        }\n    }\n    return p;\n}\n"], ["using namespace std;\n#include<iostream>\n#include <cmath>\n#include <cassert>\n\nint count_odd_squares(int n, int m) {\n    int count = 0;\n    for (int i = n; i <= m; ++i) {\n        if (sqrt(i) == static_cast<int>(sqrt(i))) { // Check if i is a perfect square\n            int root = sqrt(i);\n            if (root % 2 != 0) { // Check if the square root is odd\n                count++;\n            }\n        }\n    }\n    return count;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint count_squares(int m, int n) {\n    if (n < m) {\n        int temp = m;\n        m = n;\n        n = temp; // Swap m and n if n is less than m\n    }\n    \n    int total_squares = 0;\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            total_squares += min(i, j); // Each square of side length k can fit in m-i+1 rows and n-j+1 columns\n        }\n    }\n    \n    return total_squares;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\nint minimum_length(std::string s) {\n    int max_occ = 0;\n    int n = s.length();\n    std::vector<int> arr(26, 0);\n    for (int i = 0; i < n; i++) {\n        arr[s[i] - 'a']++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        if (arr[i] > 0) {\n            max_occ = max(max_occ, arr[i]);\n        }\n    }\n\n    return n - max_occ;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nint first_element(const std::vector<int>& arr, int n, int k) {\n    std::map<int, int> count_map;\n    for (int i = 0; i < n; ++i) {\n        if (count_map.find(arr[i]) != count_map.end()) {\n            count_map[arr[i]] += 1;\n        } else {\n            count_map[arr[i]] = 1;\n        }\n        if (count_map[arr[i]] == k) {\n            return arr[i];\n        }\n    }\n    return -1; // Return -1 if no element occurs k times\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <string>\n#include <cassert>\n\nbool unique_characters(std::string str) {\n    for (int i = 0; i < str.length(); i++) {\n        for (int j = i + 1; j < str.length(); j++) {\n            if (str[i] == str[j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint count_rectangles(int radius) {\n    int rectangles = 0;\n    int diameter = 2 * radius;\n    int diameter_square = diameter * diameter;\n    for (int a = 1; a < 2 * radius; a++) {\n        for (int b = 1; b < 2 * radius; b++) {\n            int diagnal_length_square = (a * a + b * b);\n            if (diagnal_length_square <= diameter_square) {\n                rectangles++;\n            }\n        }\n    }\n    return rectangles;\n}\n"], ["using namespace std;\n#include<iostream>\n#include<string>\n#include<cassert>\nstd::string check_solution(int a, int b, int c) {\n    if (2 * b * b == 9 * a * c) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"], ["#include<iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nusing namespace std;\nvector<tuple<int, int, int>> add_k_element(vector<tuple<int, int, int>> test_list, int k) {\n    vector<tuple<int, int, int>> res;\n    for (auto &sub : test_list) {\n        int a, b, c;\n        tie(a, b, c) = sub; // Unpack the tuple into individual variables\n        res.push_back(make_tuple(a + k, b + k, c + k)); // Add k to each element and store in the result vector\n    }\n    return res;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <cassert>\nint count_digit(int n) {\n    int count = 0;\n    while (n != 0) {\n        n /= 10;\n        count++;\n    }\n    return count;\n}\n"], ["using namespace std;\nint adjacent_num_product(const vector<int>& list_nums) {\n    int max_product = INT_MIN;\n    for (size_t i = 0; i < list_nums.size() - 1; ++i) {\n        int product = list_nums[i] * list_nums[i + 1];\n        if (product > max_product) {\n            max_product = product;\n        }\n    }\n    return max_product;\n}\n"], ["using namespace std;\nclass node {\npublic:\n    int data;\n    node* left;\n    node* right;\n    node(int value) : data(value), left(nullptr), right(nullptr) {}\n};\nint get_height(node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return max(get_height(root->left), get_height(root->right)) + 1;\n}\nbool is_balanced(node* root) {\n    if (root == nullptr) {\n        return true;\n    }\n    int left_height = get_height(root->left);\n    int right_height = get_height(root->right);\n    if (abs(left_height - right_height) > 1) {\n        return false;\n    }\n    return is_balanced(root->left) && is_balanced(root->right);\n}\n"], ["using namespace std;\nvector<tuple<int, int>> repeat_tuples(tuple<int, int> test_tup, int n) {\n    vector<tuple<int, int>> res(n, test_tup);\n    return res;\n}\n"], ["using namespace std;\n#include <cassert>\n\nint lateralsurface_cuboid(int l, int w, int h) {\n    int l_s_a = 2 * h * (l + w);\n    return l_s_a;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint smallest_missing(const std::vector<int>& a, int left_element, int right_element) {\n    if (left_element > right_element) {\n        return left_element;\n    }\n    int mid = left_element + (right_element - left_element) / 2;\n    \n    // Check if the middle element is the smallest missing element\n    if (a[mid] == mid) {\n        return smallest_missing(a, mid + 1, right_element);\n    } else {\n        return smallest_missing(a, left_element, mid - 1);\n    }\n}\n"], ["\nusing namespace std;\nclass element {\npublic:\n    virtual ~element() = default;\n    virtual bool is_int() const = 0;\n    virtual bool is_string() const = 0;\n    virtual int get_int() const = 0;\n    virtual string get_string() const = 0;\n};\n// 派生类 IntElement\nclass int_element : public element {\npublic:\n    int_element(int value) : value(value) {}\n    bool is_int() const override {\n        return true;\n    }\n    bool is_string() const override {\n        return false;\n    }\n    int get_int() const override {\n        return value;\n    }\n    string get_string() const override {\n        throw runtime_error(\"Not a string\");\n    }\nprivate:\n    int value;\n};\n// 派生类 StringElement\nclass string_element : public element {\npublic:\n    string_element(const string& value) : value(value) {}\n    bool is_int() const override {\n        return false;\n    }\n    bool is_string() const override {\n        return true;\n    }\n    int get_int() const override {\n        throw runtime_error(\"Not an integer\");\n    }\n    string get_string() const override {\n        return value;\n    }\nprivate:\n    string value;\n};\nstruct ElementComparator {\n    bool operator()(const element* lhs, const element* rhs) const {\n        if (lhs->is_int() && rhs->is_int()) {\n            return lhs->get_int() < rhs->get_int();\n        } else if (lhs->is_string() && rhs->is_string()) {\n            return lhs->get_string() < rhs->get_string();\n        }\n        return false;\n    }\n};\n\n// Function to remove tuple elements that occur more than once and replace the duplicates with some custom value\ntemplate<typename... Args>\ntuple<Args...> remove_duplicates_and_replace(const tuple<Args...>& input) {\n    set<element*, ElementComparator> seen_elements;\n    vector<element*> unique_elements;\n\n    // Collect unique elements\n    for (auto&& arg : input) {\n        if (!seen_elements.count(&arg)) {\n            seen_elements.insert(&arg);\n            unique_elements.push_back(&arg);\n        }\n    }\n\n    // Create a new tuple with unique elements\n    tuple<Args...> result;\n    size_t index = 0;\n    for (auto&& arg : input) {\n        if (seen_elements.count(&arg)) {\n            // Replace duplicate elements with a custom value\n           "], ["using namespace std;\n#include<cassert>\n#include <iostream>\n#include <string>\n#include <algorithm>\nstd::string remove_char(std::string s, char c) {\n    s.erase(std::remove(s.begin(), s.end(), c), s.end());\n    return s;\n}\n"], ["using namespace std;\n#include<cassert>\n#include<iostream>\n#include<assert.h>\nint surfacearea_cuboid(int l, int w, int h) {\n    int s_a = 2 * (l * w + l * h + w * h);\n    return s_a;\n}\n"], ["using namespace std;\nint find_rotation_count(const vector<int>& a) {\n    int left = 0, right = a.size() - 1;\n    while (left <= right) {\n        if (a[left] <= a[right]) {\n            return left;\n        }\n        int mid = (left + right) / 2;\n        int next = (mid + 1) % a.size();\n        int prev = (mid - 1 + a.size()) % a.size();\n        if (a[mid] > a[next] && a[mid] > a[prev]) {\n            return mid + 1;\n        } else if (a[mid] < a[next]) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return 0;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint frequency_of_smallest(int n, std::vector<int> arr) {\n    int mn = arr[0];\n    int freq = 1;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < mn) {\n            mn = arr[i];\n            freq = 1; // Reset frequency when a new minimum is found\n        } else if (arr[i] == mn) {\n            freq++; // Increment frequency if the current element is equal to the minimum\n        }\n    }\n    return freq;\n}\n"], ["#include<cassert>\n#include <iostream>\n#include <string>\nstd::string even_or_odd(const std::string& n) {\n    int l = n.length();\n    char last_char = n[l - 1];\n    if (last_char == '0' || last_char == '2' ||\n        last_char == '4' || last_char == '6' ||\n        last_char == '8' || last_char == 'A' ||\n        last_char == 'C' || last_char == 'E') {\n        return \"even\";\n    } else {\n        return \"odd\";\n    }\n}\n"], ["using namespace std;\n\n#include<cassert>\n#include <iostream>\n\n// 函数定义\nint highest_power_of_2(int n) {\n    int res = 0;\n    for (int i = n; i > 0; i--) {\n        if ((i & (i - 1)) == 0) {\n            res = i;\n            break;\n        }\n    }\n    return res;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\nint median_numbers(int a, int b, int c) {\n    int median;\n    if (a > b) {\n        if (a < c) {\n            median = a;\n        } else {\n            if (b > c) {\n                median = b;\n            } else {\n                median = c;\n            }\n        }\n    } else {\n        if (a > c) {\n            median = a;\n        } else {\n            if (b < c) {\n                median = b;\n            } else {\n                median = c;\n            }\n        }\n    }\n    return median;\n}\n"], ["using namespace std;\nint sum_of_digits(vector<int> nums) {\n    int result = 0;\n    for (int n : nums) {\n        string num_str = to_string(n);\n        for (char c : num_str) {\n            if (isdigit(c)) {\n                result += c - '0'; // Convert char to int and add to result\n            }\n        }\n    }\n    return result;\n}\n"], ["using namespace std;\n#include<iostream>\n#include <vector>\n#include <cassert>\nint ncr_modp(int n, int r, int p) {\n    std::vector<int> c(r + 1, 0);\n    c[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = std::min(i, r); j > 0; --j) {\n            c[j] = (c[j] + c[j - 1]) % p;\n        }\n    }\n    return c[r];\n}\n"], ["using namespace std;\nbool is_valid_u_r_l(string url) {\n    regex pattern(\"((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)\");\n    if (url.empty()) {\n        return false; // Return false if the URL is empty\n    }\n    return regex_match(url, pattern);\n}\n"], ["using MyTuple = tuple<char, int, char, char, char, char, char, char, char, char>;\ntemplate<typename T, size_t i = 0>\nbool check_tuplex(const MyTuple& t, const T& value) {\n    if constexpr (i == tuple_size<MyTuple>::value) {\n        return false;\n    } else if constexpr (std::is_same_v<T, std::tuple_element<i, MyTuple>>) {\n        return std::get<i>(t) == value;\n    } else {\n        return check_tuplex<T, i + 1>(t, value);\n    }\n}\n"], ["using namespace std;\n#include<cassert>\n#include <iostream>\n#include <string>\nstd::string find_parity(unsigned int x) {\n    unsigned int y = x ^ (x >> 1);\n    y = y ^ (y >> 2);\n    y = y ^ (y >> 4);\n    y = y ^ (y >> 8);\n    // Complete the code here\n    return (y & 1) ? \"Odd\" : \"Even\";\n}\n"], ["using namespace std;\nvector<vector<int>> k_smallest_pairs(vector<int>& nums1, vector<int>& nums2, int k) {\n    auto comp = [&](const pair<int, int>& a, const pair<int, int>& b) {\n        if(nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second])\n        {\n            return true;\n        }\n        else{\n            if(nums1[a.first] + nums2[a.second] == nums1[b.first] + nums2[b.second])\n            {\n                return nums1[a.first] > nums1[b.first];\n            }\n            else\n            {\n                return false;\n            }\n        }\n    };\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> pq(comp);\n\n    for(int i = 0; i < min(k, static_cast<int>(nums1.size())); ++i) {\n        pq.push({i, 0});\n    }\n\n    vector<vector<int>> result;\n\n    while(!pq.empty() && result.size() < k) {\n        auto [i, j] = pq.top();\n        pq.pop();\n\n        result.push_back({nums1[i], nums2[j]});\n\n        if(j + 1 < nums2.size()) {\n            pq.push({i, j + 1});\n        }\n    }\n\n    return result;\n}\n"], ["using namespace std;\ntemplate<typename T, size_t n>\nstruct TupleElement {\n    using type = typename tuple_element<n, tuple<T, int, int>>::type;\n};\ntemplate<typename T, size_t n>\nvector<typename TupleElement<T, n>::type> extract_nth_element(const vector<tuple<T, int, int>>& list1) {\n    vector<typename TupleElement<T, n>::type> result;\n    for (const auto& item : list1) {\n        result.push_back(get<n>(item));\n    }\n    return result;\n}\n"], ["using namespace std;\npair<int, int> max_product(const vector<int>& arr) {\n    int arr_len = arr.size();\n    if (arr_len < 2) {\n        throw \"No pairs exists\";\n    }\n    int x = arr[0];\n    int y = arr[1];\n    for (int i = 0; i < arr_len; i++) {\n        for (int j = i + 1; j < arr_len; j++) {\n            if (arr[i] * arr[j] > x * y) {\n                x = arr[i];\n                y = arr[j];\n            }\n        }\n    }\n    return make_pair(x, y);\n}\n"], ["using namespace std;\nint break_sum(int n) {\n    vector<int> dp(n + 1, 0);\n    dp[0] = 0;\n    dp[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        for (int j = 1; j <= i / 3; ++j) {\n            dp[i] = max(dp[i], dp[j] + dp[i - j]);\n        }\n    }\n    return dp[n];\n}\n"], ["using namespace std;\n#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\ntemplate<typename T>\nstd::vector<T> find_max(std::vector<std::vector<T>> lst) {\n    return *std::max_element(lst.begin(), lst.end(), [](const std::vector<T>& a, const std::vector<T>& b){\n        return a.size() < b.size();\n    });\n}\n"], ["using namespace std;\n#include<cassert>\n#include<iostream>\n\nint cube_sum(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        int even_number = 2 * i;\n        sum += even_number * even_number * even_number;\n    }\n    return sum;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <sstream>\n#include <tuple>\nusing namespace std;\n// Helper function to concatenate elements of the tuple\ntemplate<size_t index, typename... args>\nvoid concatenate_tuple_helper(ostringstream& oss, const string& delim, const tuple<args...>& test_tup) {\n    if (index != 0) {\n        oss << delim;\n    }\n    oss << get<index>(test_tup);\n}\n// Recursive function to iterate over the tuple\ntemplate<size_t index, typename... args>\nvoid iterate_tuple(ostringstream& oss, const string& delim, const tuple<args...>& test_tup) {\n    if constexpr (index == sizeof...(args)) {\n        return;\n    } else {\n        concatenate_tuple_helper(index, delim, test_tup);\n        iterate_tuple<index + 1, args...>(oss, delim, test_tup);\n    }\n}\n// Function to concatenate each element of the tuple by the delimiter\ntemplate<typename... args>\nstring concatenate_tuple(const string& delim, const tuple<args...>& test_tup) {\n    ostringstream oss;\n    iterate_tuple<0, args...>(oss, delim, test_tup);\n    return oss.str();\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble find_average_of_cube(int n) {\n    double sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += pow(i, 3); // Calculate the cube of i and add it to sum\n    }\n    return sum / n; // Return the average of the cubes\n}\n"], ["using namespace std;\nint get_maxgold(vector<vector<int>> gold, int m, int n) {\n    vector<vector<int>> gold_table(m, vector<int>(n, 0));   \n    for (int col = n-1; col >= 0; col--) { \n        for (int row = 0; row < m; row++) { \n            int right = (col == n-1) ? 0 : gold_table[row][col+1];\n            int right_up = (row == 0 || col == n-1) ? 0 : gold_table[row-1][col+1];\n            int right_down = (row == m-1 || col == n-1) ? 0 : gold_table[row+1][col+1];\n            gold_table[row][col] = gold[row][col] + max({right, right_up, right_down});\n        }\n    }\n    int max_gold = 0;\n    for (int i = 0; i < m; i++) {\n        max_gold = max(max_gold, gold_table[i][0]);\n    }\n    return max_gold;\n}\n"], ["using namespace std;\n#include <cassert>\n\nint last_digit(int n) {\n    return abs(n) % 10;\n}\n"], ["using namespace std;\n#include<cassert>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\nint multiple_to_single(const std::vector<int>& l) {\n    std::stringstream ss;\n    for (int num : l) {\n        ss << num;\n    }\n    int result;\n    ss >> result;\n    return result;\n}\n"], ["using namespace std;\nvector<vector<int>> trim_tuple(const vector<vector<int>>& test_list, int k) {\n    vector<vector<int>> res;\n    for (const auto& ele : test_list) {\n        vector<int> tmp;\n        for(int i = k ;i <= ele.size() - k - 1; i++)\n        {\n            tmp.push_back(ele[i]);\n        }\n        res.push_back(tmp);\n    }\n    return res;\n}\n"], ["using namespace std;\n#include<iostream>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\n// Helper function to perform index-wise multiplication\ntemplate<size_t i>\ntuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> index_multiplication_helper(\n    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup1,\n    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup2,\n    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> res)\n{\n    auto tup1 = get<i - 1>(test_tup1);\n    auto tup2 = get<i - 1>(test_tup2);\n    get<i - 1>(res) = make_tuple(get<0>(tup1) * get<0>(tup2), get<1>(tup1) * get<1>(tup2));\n    return index_multiplication_helper<i - 1>(test_tup1, test_tup2, res);\n}\n\n// Base case for the recursion\ntemplate<>\ntuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> index_multiplication_helper(\n    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup1,\n    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup2,\n    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> res)\n{\n    return res;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_occurrence(const std::vector<char>& tup, const std::vector<char>& lst) {\n    int count = 0;\n    for (char item : tup) {\n        for (char elem : lst) {\n            if (item == elem) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n"], ["using namespace std;\nstring check_triangle(int x1, int y1, int x2, int y2, int x3, int y3) {\n    int a = (x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));\n    if (a == 0) {\n        return \"No\";\n    } else {\n        return \"Yes\";\n    }\n}\n"], ["using namespace std;\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint sumof_factors(int n) {\n    if (n % 2 != 0) {\n        return 0;\n    }\n    int res = 1;\n    for (int i = 2; i <= static_cast<int>(std::sqrt(n)) + 1; ++i) {\n        int count = 0;\n        int curr_sum = 1;\n        int curr_term = 1;\n        while (n % i == 0) {\n            count++;\n            n = n / i;\n            curr_term *= i;\n            curr_sum += curr_term;\n        }\n        res *= curr_sum;\n    }\n    if (n > 1) {\n        res *= (1 + n);\n    }\n    return res;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\ntemplate <typename T>\nstd::vector<T> find_min(const std::vector<std::vector<T>>& lst) {\n    if (lst.empty()) {\n        return {};\n    }\n\n    auto min_length = lst[0].size();\n    std::vector<T> min_sublist = lst[0];\n\n    for (const auto& sublist : lst) {\n        if (sublist.size() < min_length) {\n            min_length = sublist.size();\n            min_sublist = sublist;\n        }\n    }\n\n    return min_sublist;\n}\n"], ["using namespace std;\n#include<iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> extract(const std::vector<std::vector<int>>& lst) {\n    std::vector<int> result;\n    for (auto& item : lst) {\n        if (!item.empty()) { // Check if the sublist is not empty before accessing its first element\n            result.push_back(item.front());\n        }\n    }\n    return result;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\nint decimal_to_octal(int deci_num) {\n    int octal_num = 0;\n    int countval = 1;\n    int remainder;\n    while (deci_num != 0) {\n        remainder = deci_num % 8;\n        octal_num += remainder * countval;\n        countval *= 10;\n        deci_num /= 8;\n    }\n    return octal_num;\n}\n"], ["using namespace std;\nint max_product(vector<int> arr, int n) {\n    vector<int> mpis(n, 0);\n    {\n        int i = 0;\n        for (; i < n; ++i) {\n            mpis[i] = arr[i];\n        }\n    }\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (arr[j] < arr[i]) {\n                mpis[i] = max(mpis[i], mpis[j] * arr[i]);\n            }\n        }\n    }\n    return *max_element(mpis.begin(), mpis.end());\n}\n"], ["using namespace std;\n#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nbool check_consecutive(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 1; i < l.size(); ++i) {\n        if (l[i] != l[i - 1] + 1) {\n            return false;\n        }\n    }\n    return true;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint first_digit(int n) {\n    while (n >= 10) {\n        n = n / 10;\n    }\n    return n;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\nchar get_max_occuring_char(const std::string &str1) {\n    const int a_s_c_i_i_s_i_z_e = 256;\n    int ctr[a_s_c_i_i_s_i_z_e] = {0};\n    int max = -1;\n    char ch = '\\0';\n    for (char c : str1) {\n        ctr[c]++;\n    }\n    for (int i = 0; i < a_s_c_i_i_s_i_z_e; ++i) {\n        if (ctr[i] > max) {\n            max = ctr[i];\n            ch = static_cast<char>(i);\n        }\n    }\n    return ch;\n}\n"], ["using namespace std;\nint first_factorial_divisible_number(int x) {\n    int i = 1;\n    int fact = 1;\n    for (i = 1; i <= x; ++i) {\n        fact *= i;\n        if (fact % x == 0) {\n            return i;\n        }\n    }\n    return -1; // If no such number is found, return -1\n}\n"], ["using namespace std;\nbool is_palindrome(int n) {\n    int divisor = 1;\n    for(;(n / divisor >= 10);){\n        divisor *= 10;\n    }\n    while (n != 0) {\n        int leading = n / divisor;\n        int trailing = n % 10;\n        if (leading != trailing) {\n            return false;\n        }\n        n = (n % divisor) / 10;\n    }\n    return true;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble n_cr(int n, int r) {\n    if (r > n / 2) {\n        r = n - r;\n    }\n    double answer = 1;\n    for (int i = 1; i <= r; i++) {\n        answer *= (n - r + i);\n        answer /= i;\n    }\n    return answer;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint frequency_of_largest(int n, std::vector<int> arr) {\n    int mn = arr[0];\n    int freq = 1;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > mn) {\n            mn = arr[i];\n            freq = 1; // Reset frequency when a new maximum is found\n        } else if (arr[i] == mn) {\n            freq++; // Increment frequency if the current element is equal to the maximum\n        }\n    }\n    return freq;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\ntypedef std::vector<std::pair<double, double>> Polygon;\n\nstd::vector<Polygon> calculate_polygons(double startx, double starty, double endx, double endy, double radius)\n{\n    double sl = (2 * radius) * std::tan(m_p_i / 6);\n    double p = sl * 0.5;\n    double b = sl * std::cos(30 * m_p_i / 180.0);\n    double w = b * 2;\n    double h = 2 * sl;\n    startx = startx - w;\n    starty = starty - h;\n    endx = endx + w;\n    endy = endy + h;\n    double origx = startx;\n    double origy = starty;\n    double xoffset = b;\n    double yoffset = 3 * p;\n    std::vector<Polygon> polygons;\n    int row = 1;\n    int counter = 0;\n    while (starty < endy)\n    {\n        if (row % 2 == 0)\n        {\n            startx = origx + xoffset;\n        }\n        else\n        {\n            startx = origx;\n        }\n        while (startx < endx)\n        {\n            Polygon polygon;\n            // Calculate the coordinates of the hexagon vertices\n            double x = startx;\n            double y = starty;\n            for (int i = 0; i < 6; ++i)\n            {\n                double angle = i * 2 * m_p_i / 6;\n                double hex_x = x + b * std::cos(angle);\n                double hex_y = y + b * std::sin(angle);\n                polygon.push_back(std::make_pair(hex_x, hex_y));\n            }\n            polygons.push_back(polygon);\n            startx += w;\n        }\n        starty += yoffset;\n        row++;\n    }\n    return polygons;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cmath>\n#include <cassert>\nint ngcd(int x, int y) {\n    int i = 1;\n    int gcd = 1;\n    for(;(i <= x && i <= y);){\n        if(x % i == 0 && y % i == 0) {\n            gcd = i;\n        }\n        i += 1;\n    }\n    return gcd;\n}\n\nint num_comm_div(int x, int y) {\n    int n = ngcd(x, y);\n    int count = 0;\n    for(int i = 1; i <= n; i++) {\n        if(n % i == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint sum_of_series(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i * i * i; // Calculate the cube of each number and add it to the sum\n    }\n    return sum;\n}\n"], ["using namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> re_order(std::vector<int>& a) {\n    int k = 0;\n    for (int i : a) {\n        if (i != 0) {\n            a[k] = i;\n            k++;\n        }\n    }\n    // Fill the rest of the array with zeroes\n    while (k < a.size()) {\n        a[k] = 0;\n        k++;\n    }\n    return a;\n}\n"], ["using namespace std;\nint permutation_coefficient(int n, int k) {\n    vector<vector<int>> p(n + 1, vector<int>(k + 1, 0));\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= min(i, k); j++) {\n            if (j == 0)\n                p[i][j] = 1;\n            else\n                p[i][j] = p[i - 1][j - 1] * (i - j + 1);\n        }\n    }\n    return p[n][k];\n}\n"], ["using namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint average_odd(int n) {\n    if (n % 2 == 0) {\n        std::cerr << \"Invalid Input\" << std::endl;\n        return -1;\n    }\n    int sm = 0;\n    int count = 0;\n    for (int i = 1; i <= n; i += 2) {\n        sm += i;\n        count++;\n    }\n    return sm / count;\n}\n"]]