[["def check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n    if not(len(dict.keys()) == 0):\n        state = \"start\"\n        for key in dict.keys():\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.islower():\n                    state = \"lower\"\n                elif key.isupper():\n                    state = \"upper\"\n                else:\n                    state = \"mixed\"\n                    break\n            else:\n                if state == \"lower\" and not key.islower():\n                    state = \"mixed\"\n                    break\n                if state == \"upper\" and not key.isupper():\n                    state = \"mixed\"\n                    break\n        return state in [\"lower\", \"upper\"]\n    else:\n        return False\n"], ["def get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\n    if not(n%2==0):\n        odd_collatz = [n]\n    else:\n        odd_collatz = []\n    while n > 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        if n % 2 == 1:\n            odd_collatz.append(n)\n    return sorted(odd_collatz)\n"], ["def is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if not(string[i] == '['):\n            closing_bracket_index.append(i)\n        else:\n            opening_bracket_index.append(i)\n    \n    # Check if there exists a valid subsequence with at least one nested bracket\n    # A nested bracket means there's an opening bracket that has a matching closing bracket\n    # that comes after another opening bracket within the same subsequence\n    \n    # We need to find if there's a valid subsequence where at least one pair is nested\n    # This happens when we have at least one opening bracket that is followed by another opening\n    # before its corresponding closing bracket\n    \n    # Use a stack to simulate matching brackets\n    stack = []\n    for i, char in enumerate(string):\n        if char == '[':\n            stack.append(i)\n        else:  # char == ']'\n            if stack:\n                # Pop the matching opening bracket\n                open_idx = stack.pop()\n                # Check if there's another opening bracket between open_idx and i\n                # This would mean we have nesting\n                for j in range(open_idx + 1, i):\n                    if string[j] == '[':\n                        return True\n            else:\n                # Unmatched closing bracket, but we still need to check for nesting\n                # in other parts of the string\n                continue\n    \n    return False\n"], ["def fix_spaces(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if not(text[i] == \" \"):\n            if start < end:\n                num_spaces = end - start\n                if num_spaces > 2:\n                    new_text += \"-\"\n                else:\n                    new_text += \"_\" * num_spaces\n                start = end = i\n            new_text += text[i]\n            i += 1\n        else:\n            end += 1\n            i += 1\n    # Handle trailing spaces\n    if start < end:\n        num_spaces = end - start\n        if num_spaces > 2:\n            new_text += \"-\"\n        else:\n            new_text += \"_\" * num_spaces\n    return new_text\n"]]