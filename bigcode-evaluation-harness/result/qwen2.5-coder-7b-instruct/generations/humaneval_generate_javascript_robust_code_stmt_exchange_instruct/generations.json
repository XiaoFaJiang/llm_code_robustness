[["const allPrefixes = (string) => {\n  var result = [];\n  {\n      let i = 0;\n      while(i < string.length){\n    result.push(string.slice(0, i+1));\n    i++;\n      }\n  }\n  return result;\n}\n"], ["const findClosestElements = (numbers) => {\n  var closest_pair, distance;\n  {\n    let i = 0;\n    while(i < numbers.length){\n      let j = 0;\n      while(j < numbers.length){\n        if (i != j) {\n          let a = numbers[i], b = numbers[j];\n          if (distance == null || Math.abs(a - b) < distance) {\n            distance = Math.abs(a - b);\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n        j++;\n      }\n      i++;\n    }\n  }\n  return closest_pair;\n}\n"], ["const largestDivisor = (n) => {\n  {\n    let i = n - 1;\n    while(i >= 0){\n      if (n % i === 0) {\n        return i;\n      }\n      i--;\n    }\n    return 1; // If no divisor found other than 1, return 1\n  }\n}\n"], ["const factorize = (n) => {\n  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (!(n % i == 0)) {\n      i++;\n    } else {\n      fact.push(i);\n      n = n / i;\n    }\n  }\n  if (n > 1) {\n    fact.push(n);\n  }\n  return fact;\n}\n"], ["/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only one zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  var begin = -1.0, end = 1.0;\n  for(;(poly(xs, begin) * poly(xs, end) > 0);){\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let mid = (begin + end) / 2.0;\n    if (poly(xs, mid) * poly(xs, begin) <= 0) {\n      end = mid;\n    } else {\n      begin = mid;\n    }\n  }\n  return begin;\n}\n"], ["const fizzBuzz = (n) => {\n  var ns = [], ans = 0;\n  {\n      let i = 0;\n      while(i < n){\n          if (i % 11 == 0 || i % 13 == 0){\n              ns.push(i);\n              // Count the number of '7's in the current number\n              const countSevens = i.toString().split('').filter(digit => digit === '7').length;\n              ans += countSevens;\n          }  \n          i++;\n      }\n  }\n  return ans;\n}\n"], ["/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  {\n      let i = 0;\n      while(i < Math.floor((s.length + 2) / 3)){\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n        i++;\n      }\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  return encodeCyclic(encodeCyclic(s));\n}\n"], ["const primeFib = (n) => {\n  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    {\n        let k = 2;\n        for (; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n          if (p % k == 0)\n            return false;\n        }\n    }\n    return true;\n  };\n\n  let fib = [0, 1];\n  let count = 0;\n  while (true) {\n    let nextFib = fib[fib.length - 1] + fib[fib.length - 2];\n    fib.push(nextFib);\n    if (isPrime(nextFib)) {\n      count++;\n      if (count === n) {\n        return nextFib;\n      }\n    }\n  }\n};\n"], ["const triplesSumToZero = (l) => {\n  {\n    let i = 0;\n    for (; i < l.length; i++) {\n      let j = i + 1;\n      for (; j < l.length; j++) {\n        let k = j + 1;\n        for (; k < l.length; k++) {\n          if (l[i] + l[j] + l[k] === 0) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\n"], ["const pairsSumToZero = (l) => {\n  {\n      let i = 0;\n      while(i < l.length){\n          let j = i + 1;\n          while(j < l.length){\n              if (l[i] + l[j] == 0) {\n                  return true;\n              }\n              j++;\n          }\n          i++;\n      }\n  }\n  return false;\n}\n"], ["const isPalindrome = (text) => {\n  {\n      let i = 0;\n      for (; i < text.length; i++)\n      if (text[i] != text.at(-i-1))\n        return false;\n  }\n  return true;\n}\n"], ["const modp = (n, p) => {\n  var ret = 1;\n  {\n      let i = 0;\n      while(i < n){\n          ret = (2 * ret) % p;\n          i++;\n      }\n  }\n  return ret;\n}\n"], ["const largestPrimeFactor = (n) => {\n  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    {\n        let i = 2;\n        for (; i < k - 1; i++)\n          if (k % i == 0)\n            return false;\n    }\n    return true;\n  };\n\n  let maxPrime = -1;\n\n  while (n % 2 === 0) {\n    maxPrime = 2;\n    n /= 2;\n  }\n\n  for (let i = 3; i <= Math.sqrt(n); i += 2) {\n    while (n % i === 0) {\n      maxPrime = i;\n      n = n / i;\n    }\n  }\n\n  if (n > 2)\n    maxPrime = n;\n\n  return maxPrime;\n};\n"], ["const smallestChange = (arr) => {\n  var ans = 0;\n  {\n    let i = 0;\n    while(i < Math.floor(arr.length / 2)){\n      if (arr[i] != arr.at(-i - 1)) {\n        i++;\n        ans++;\n      }\n    }\n  }\n  return ans;\n}\n"], ["const isMultiplyPrime = (a) => {\n  var isPrime = function (n) {\n    {\n        let j = 2;\n        for (; j < n; j++)\n          if (n % j == 0)\n            return false;\n    }\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = i + 1; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = j + 1; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i * j * k === a) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n"], ["const numericalLetterGrade = (grades) => {\n  let letter_grade = [];\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i];\n    if (gpa == 4.0) {\n      letter_grade.push('A+');\n    } else if (gpa > 3.7) {\n      letter_grade.push('A');\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-');\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+');\n    } else if (gpa > 2.7) {\n      letter_grade.push('B');\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-');\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+');\n    } else if (gpa > 1.7) {\n      letter_grade.push('C');\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-');\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+');\n    } else if (gpa > 0.7) {\n      letter_grade.push('D');\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-');\n    } else {\n      letter_grade.push('E');\n    }\n  }\n  return letter_grade;\n};\n"], ["const antiShuffle = (s) => {\n  let arr = s.split(/\\s/)\n  for(let i = 0; i < arr.length; i++){\n    let str = arr[i]\n    let tempArr = str.split('')\n    for(let j = 0; j < tempArr.length - 1; j++){\n      let minIndex = j\n      for(let k = j + 1; k < tempArr.length; k++){\n        if(tempArr[k] < tempArr[minIndex]){\n          minIndex = k\n        }\n      }\n      [tempArr[j], tempArr[minIndex]] = [tempArr[minIndex], tempArr[j]]\n    }\n    arr[i] = tempArr.join('')\n  }\n  return arr.join(' ')\n}\n"], ["const encrypt = (s) => {\n  let t = '';\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt();\n    if ((p >= 97 && p <= 122)) {\n      p += 8; // Shift down by two multiplied to two places\n      if (p > 122) {\n        p -= 26;\n      }\n    } else if ((p >= 65 && p <= 90)) {\n      p += 8; // Shift down by two multiplied to two places\n      if (p > 90) {\n        p -= 26;\n      }\n    }\n    t += String.fromCharCode(p);\n  }\n  return t;\n};\n"], ["const nextSmallest = (lst) => {\n  let arr = lst\n  if (arr.length <= 1) {\n    return null\n  }\n  let firstMin = Infinity\n  let secondMin = Infinity\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < firstMin) {\n      secondMin = firstMin\n      firstMin = arr[i]\n    } else if (arr[i] < secondMin && arr[i] !== firstMin) {\n      secondMin = arr[i]\n    }\n  }\n  return secondMin === Infinity ? null : secondMin\n}\n"], ["const encode = (message) => {\n  let t = '';\n  for (let i = 0; i < message.length; i++) {\n    let char = message[i];\n    let p = char.charCodeAt();\n    \n    // Swap case\n    if (p > 96) {\n      p -= 32;\n    } else {\n      p += 32;\n    }\n    \n    // Replace vowels with the letter 2 places ahead\n    if ('aeiou'.includes(char.toLowerCase())) {\n      let index = 'aeiou'.indexOf(char.toLowerCase());\n      let newChar = String.fromCharCode(p + (index * 2));\n      t += char === char.toUpperCase() ? newChar.toUpperCase() : newChar.toLowerCase();\n    } else {\n      t += char;\n    }\n  }\n  return t;\n};\n"], ["const skjkasdkd = (lst) => {\n  let t = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1;\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j === 0) {\n        p = 0;\n        break;\n      }\n    }\n    if (p === 1 && lst[i] > t) {\n      t = lst[i];\n    }\n  }\n  let sumOfDigits = 0;\n  while (t > 0) {\n    sumOfDigits += t % 10;\n    t = Math.floor(t / 10);\n  }\n  return sumOfDigits;\n};\n"], ["const countUpTo = (n) => {\n  let t = [];\n  {\n    let i = 2;\n    while (i < n) {\n      let p = 1;\n      {\n        let j = 2;\n        while (j * j <= i) {\n          if (i % j === 0) {\n            p = 0;\n            break;\n          }\n          j++;\n        }\n      }\n      if (p === 1) {\n        t.push(i);\n      }\n      i++;\n    }\n  }\n  return t;\n};\n"], ["const countUpper = (s) => {\n  let p = 0;\n  {\n    let i = 0;\n    while (i < s.length) {\n      if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n        p++;\n        i += 2;\n      } else {\n        i++;\n      }\n    }\n  }\n  return p;\n};\n"], ["const makeAPile = (n) => {\n  let t = [];\n  let currentStones = n;\n  for (let i = 0; i < n; i++) {\n    t.push(currentStones);\n    // Determine the next number based on whether n is odd or even\n    currentStones += (n % 2 === 0) ? 2 : 2;\n  }\n  return t;\n}\n"], ["const chooseNum = (x, y) => {\n  {\n      let i = y;\n      while(i >= x){\n          if (i % 2 == 0) {return i }\n          i--;\n      }\n  }\n  return -1;\n}\n"], ["const uniqueDigits = (x) => {\n  let p = [];\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i];\n    let boo = 1;\n    while (h > 0) {\n      let r = h % 10;\n      if (r % 2 === 0) {\n        boo = 0;\n        break;\n      }\n      h = Math.floor(h / 10);\n    }\n    if (boo) {\n      p.push(x[i]);\n    }\n  }\n  p.sort((a, b) => a - b);\n  return p;\n};\n"], ["const byLength = (arr) => {\n  p = [];\n  {\n    let i = 0;\n    for (; i < arr.length; i++) {\n      if (arr[i] > 0 && arr[i] < 10) {\n        p.push(arr[i]);\n      }\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j;\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k;\n      }\n    }\n    let temp = p[j];\n    p[j] = p[ind];\n    p[ind] = temp;\n  }\n  const digitNames = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n  let result = [];\n  for (let l = 0; l < p.length; l++) {\n    result.push(digitNames[p[l] - 1]);\n  }\n  return result;\n};\n"], ["const f = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      let factorial = 1;\n      for (let j = 1; j <= i; j++) {\n        factorial *= j;\n      }\n      result.push(factorial);\n    } else {\n      let sum = 0;\n      for (let j = 1; j <= i; j++) {\n        sum += j;\n      }\n      result.push(sum);\n    }\n  }\n  return result;\n};\n"], ["const countNums = (arr) => {\n  let p = 0;\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i];\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let sum = 0;\n    let isNegative = h < 0;\n    while (h !== 0) {\n      let digit = Math.abs(h % 10);\n      sum += digit;\n      h = Math.floor(h / 10);\n    }\n    if (isNegative) {\n      sum -= 2 * (sum % 10);\n    }\n    if (sum > 0) {\n      p++;\n    }\n  }\n  return p;\n};\n"], ["const exchange = (lst1, lst2) => {\n  let k = lst1.length\n  let t = 0\n  {\n      let i = 0;\n      while(i < lst1.length){\n    if (lst1[i] % 2 == 0) { t++ }\n        i++;\n      }\n  }\n  if (t === k) {\n    return \"YES\";\n  } else {\n    let evenCountLst2 = lst2.filter(num => num % 2 === 0).length;\n    if ((k - t) <= evenCountLst2) {\n      return \"YES\";\n    } else {\n      return \"NO\";\n    }\n  }\n}\n"], ["const histogram = (test) => {\n  let d = {};\n  let t = test.split(/\\s/);\n  if (test === '') { t = []; }\n  for (let m in t) {\n    if (!(t[m] in d)) {\n      d[t[m]] = 1;\n    } else {\n      d[t[m]]++;\n    }\n  }\n\n  let maxCount = 0;\n  let result = {};\n\n  for (let key in d) {\n    if (d[key] > maxCount) {\n      maxCount = d[key];\n      result = { [key]: maxCount };\n    } else if (d[key] === maxCount) {\n      result[key] = maxCount;\n    }\n  }\n\n  return result;\n};\n"], ["const reverseDelete = (s, c) => {\n  let t = '';\n  for (let i = 0; i < s.length; i++) {\n    let y = 1;\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] === c[j]) {\n        y = 0;\n      }\n    }\n    if (y === 1) {\n      t += s[i];\n    }\n  }\n  const reversed = t.split('').reverse().join('');\n  const isPalindrome = t === reversed;\n  return [t, isPalindrome];\n};\n"], ["const oddCount = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    let countOfOdd = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (parseInt(lst[i][j]) % 2 !== 0) {\n        countOfOdd++;\n      }\n    }\n    result.push(`the number of odd elements ${countOfOdd}n the str${countOfOdd}ng ${countOfOdd} of the ${countOfOdd}nput.`);\n  }\n  return result;\n};\n"], ["const minSubArraySum = (nums) => {\n  let min = nums[0];\n  for(let i = 0; i < nums.length; i++) {\n    let s = 0;\n    for(let j = i; j < nums.length; j++) {\n      s += nums[j];\n      if(s < min) {\n        min = s;\n      }\n    }\n  }\n  return min;\n}\n"], ["const maxFill = (grid, capacity) => {\n  let p = 0\n  {\n      let i = 0;\n      while(i < grid.length){\n    let m = 0\n    {\n        let j = 0;\n        while(j < grid[i].length){\n      if (grid[i][j] == 1) { m++ }\n          j++;\n        }\n    }\n    p += Math.ceil(m / capacity);\n    i++;\n  }\n  return p;\n}\n"], ["const sortArray = (arr) => {\n  return arr.sort((a, b) => {\n    const countOnes = (num) => num.toString(2).split('').filter(bit => bit === '1').length;\n    const onesA = countOnes(a);\n    const onesB = countOnes(b);\n    if (onesA === onesB) {\n      return a - b;\n    }\n    return onesA - onesB;\n  });\n};\n"], ["const selectWords = (s, n) => {\n  let t = s.split(/\\s/);\n  if (s === '') { return []; }\n  let k = [];\n  for (let i = 0; i < t.length; i++) {\n    let l = 0;\n    for (let j = 0; j < t[i].length; j++) {\n      if ('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'.includes(t[i][j])) {\n        l++;\n      }\n    }\n    if (l === n) {\n      k.push(t[i]);\n    }\n  }\n  return k;\n}\n"], ["const matchParens = (lst) => {\n  let w1 = lst[0] + lst[1];\n  let y = 0;\n  let u = 1;\n  for (let i = 0; i < w1.length; i++) {\n    if (!(w1[i] == '(')) { y--; }\n    else { y++; }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u === 1) {\n    return 'Yes';\n  } else {\n    let w2 = lst[1] + lst[0];\n    y = 0;\n    for (let i = 0; i < w2.length; i++) {\n      if (!(w2[i] == '(')) { y--; }\n      else { y++; }\n      if (y < 0) {\n        return 'No';\n      }\n    }\n    return 'Yes';\n  }\n};\n"], ["const maximum = (arr, k) => {\n  let p = arr.slice(); // Create a copy of the array to avoid modifying the original array\n  {\n    let j = 0;\n    for (; j < p.length; j++) {\n      let ind = j;\n      {\n        let k = j + 1;\n        for (; k < p.length; k++) {\n          if (p[k] > p[ind]) { // Change the comparison operator to find the maximum elements\n            ind = k;\n          }\n        }\n      }\n      if (ind !== j) {\n        let temp = p[j];\n        p[j] = p[ind];\n        p[ind] = temp;\n      }\n    }\n  }\n  return p.slice(0, k); // Return the first k elements of the sorted array\n};\n"], ["const addElements = (arr, k) => {\n  let p = 0;\n  {\n    let i = 0;\n    while (i < k) {\n      if (arr[i] >= -99 && arr[i] <= 99) {\n        p += arr[i];\n        i++;\n      }\n    }\n  }\n  return p;\n};\n"], ["const getOddCollatz = (n) => {\n  let p = [];\n  let t = n;\n  while (1) {\n    let u = 0;\n    {\n      let i = 0;\n      for (; i < p.length; i++) {\n        if (t == p[i]) {\n          u = 1;\n          break;\n        }\n      }\n    }\n    if (u == 1) { break; }\n    p.push(t);\n    if (t % 2 == 0) {\n      t = t / 2;\n    } else {\n      t = 3 * t + 1;\n    }\n  }\n  let oddNumbers = p.filter(num => num % 2 !== 0);\n  oddNumbers.sort((a, b) => a - b);\n  return oddNumbers;\n}\n"], ["const minPath = (grid, k) => {\n  let m = 0;\n  let n = 0;\n\n  // Find the starting position of the number 1 in the grid\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] === 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n    if (m !== 0 && n !== 0) break;\n  }\n\n  // Helper function to get neighbors of a given cell\n  const getNeighbors = (x, y) => {\n    const neighbors = [];\n    if (x > 0) neighbors.push([x - 1, y]);\n    if (x < grid.length - 1) neighbors.push([x + 1, y]);\n    if (y > 0) neighbors.push([x, y - 1]);\n    if (y < grid.length - 1) neighbors.push([x, y + 1]);\n    return neighbors;\n  };\n\n  // DFS to find the minimum path of length k\n  const dfs = (x, y, path) => {\n    if (path.length === k) {\n      return path;\n    }\n    const neighbors = getNeighbors(x, y);\n    let minPath = null;\n    for (const [nx, ny] of neighbors) {\n      const newPath = [...path, grid[nx][ny]];\n      const resultPath = dfs(nx, ny, newPath);\n      if (!minPath || resultPath < minPath) {\n        minPath = resultPath;\n      }\n    }\n    return minPath;\n  };\n\n  return dfs(m, n, [1]);\n};\n"], ["const isNested = (string) => {\n  let opening_bracket_index = [];\n  let closing_bracket_index = [];\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '[') {\n      opening_bracket_index.push(i);\n    } else {\n      closing_bracket_index.push(i);\n    }\n  }\n\n  // If there are more closing brackets than opening ones, it's not possible to have a nested sequence\n  if (closing_bracket_index.length > opening_bracket_index.length) {\n    return false;\n  }\n\n  // Check for nested brackets\n  while (opening_bracket_index.length > 0 && closing_bracket_index.length > 0) {\n    let last_opening_index = opening_bracket_index.pop();\n    let last_closing_index = closing_bracket_index[closing_bracket_index.length - 1];\n\n    if (last_closing_index > last_opening_index) {\n      closing_bracket_index.pop(); // This closing bracket is nested\n    } else {\n      return false; // No nested brackets found\n    }\n  }\n\n  return opening_bracket_index.length === 0 && closing_bracket_index.length === 0;\n};\n"], ["const canArrange = (arr) => {\n  if (arr.length == 0) { return -1 }\n  {\n      let i = arr.length - 1;\n      while(i > 0){\n          if (arr[i] < arr[i - 1]) { return i; }\n          i--;\n      }\n      return -1;\n  }\n}\n"], ["const largestSmallestIntegers = (lst) => {\n  let a = Infinity;\n  let b = -Infinity;\n\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < 0 && lst[i] > a) {\n      a = lst[i];\n    } else if (lst[i] > 0 && lst[i] < b) {\n      b = lst[i];\n    }\n  }\n\n  a = a === Infinity ? null : a;\n  b = b === -Infinity ? null : b;\n\n  return [a, b];\n};\n"], ["const fixSpaces = (text) => {\n  let t = '';\n  let c = 0;\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] === ' ') {\n      c++;\n    } else {\n      if (c > 0) {\n        if (c === 1) {\n          t += '_';\n        } else if (c === 2) {\n          t += '__';\n        } else {\n          t += '-';\n        }\n        c = 0;\n      }\n      t += text[i];\n    }\n  }\n  if (c > 0) {\n    if (c === 1) {\n      t += '_';\n    } else if (c === 2) {\n      t += '__';\n    } else {\n      t += '-';\n    }\n  }\n  return t;\n};\n"], ["const sumSquares = (lst) => {\n  let y = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      y += lst[i] * lst[i];\n    } else {\n      if (i % 4 === 0) {\n        y += lst[i] * lst[i] * lst[i];\n      }\n    }\n  }\n  return y;\n}\n"], ["const wordsInSentence = (sentence) => {\n  let t = sentence.split(/\\s/)\n  let p = ''\n  {\n      let j = 0;\n      for (; j < t.length; j++) {\n      let len = t[j].length;\n      let u = 1\n      if (len == 1 || len == 0) { continue }\n      for(let k=2;k<len;k++){\n          if(len%k===0){\n              u=0;\n              break;\n          }\n      }\n      if(u==1){\n          p+=t[j]+' ';\n      }\n  }\n  return p.trim();\n}\n"], ["const orderByPoints = (nums) => {\n  return nums.sort((a, b) => {\n    const sumDigits = (num) => {\n      return Math.abs(num).toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);\n    };\n    const sumA = sumDigits(a);\n    const sumB = sumDigits(b);\n    if (sumA === sumB) {\n      return nums.indexOf(a) - nums.indexOf(b);\n    }\n    return sumA - sumB;\n  });\n};\n"], ["const specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10) {\n      let strNum = Math.abs(nums[i]).toString();\n      let firstDigit = parseInt(strNum.charAt(0), 10);\n      let lastDigit = parseInt(strNum.charAt(strNum.length - 1), 10);\n      if (firstDigit % 2 !== 0 && lastDigit % 2 !== 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n"], ["const getMaxTriples = (n) => {\n  let y = [];\n  {\n    let i = 1;\n    while(i <= n){\n      y.push(i * i - i + 1);\n      i++;\n    }\n  }\n  let u = 0;\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 === 0) {\n          u++;\n        }\n      }\n    }\n  }\n  return u;\n};\n"], ["const bf = (planet1, planet2) => {\n  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'];\n  let u = [];\n  let lo = -1;\n  let hi = -1;\n\n  // Find the indices of the given planets\n  for (let i = 0; i < 8; i++) {\n    if (y[i] === planet1) {\n      lo = i;\n    }\n    if (y[i] === planet2) {\n      hi = i;\n    }\n  }\n\n  // Check if both planets were found\n  if (lo === -1 || hi === -1) {\n    return u; // Return an empty array if either planet is not found\n  }\n\n  // Ensure lo is less than hi for proper slicing\n  if (lo > hi) {\n    [lo, hi] = [hi, lo];\n  }\n\n  // Slice the array to get the planets between the given two planets\n  u = y.slice(lo + 1, hi);\n\n  return u;\n};\n"], ["const sortedListSum = (lst) => {\n  let p = [];\n  {\n    let i = 0;\n    for (; i < lst.length; i++) {\n      if (lst[i].length % 2 == 0) {\n        p.push(lst[i]);\n      }\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0;\n      if (p[k].length > p[k + 1].length) {\n        f = 1;\n      }\n      if (p[k].length == p[k + 1].length) {\n        if (p[k] > p[k + 1]) {\n          f = 1;\n        }\n      }\n      if (f == 1) {\n        let temp = p[k];\n        p[k] = p[k + 1];\n        p[k + 1] = temp;\n      }\n    }\n  }\n  return p;\n};\n"], ["const strongestExtension = (class_name, extensions) => {\n  let u = 0;\n  let s = -Infinity;\n  let strongestExt = '';\n\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0;\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt();\n      if (k >= 65 && k <= 90) {\n        u += 1;\n      } else if (k >= 97 && k <= 122) {\n        y += 1;\n      }\n    }\n    let strength = u - y;\n    if (strength > s) {\n      s = strength;\n      strongestExt = extensions[i];\n    }\n  }\n\n  return `${class_name}.${strongestExt}`;\n};\n"], ["const cycpatternCheck = (a, b) => {\n  let l = b.length;\n  let pat = b + b;\n  for(let i = 0; i < a.length - l + 1; i++) {\n    for(let j = 0; j < l; j++) {\n      if(a[i + j] !== pat[j]) break;\n      if(j === l - 1) return true;\n    }\n  }\n  return false;\n}\n"], ["const findMax = (words) => {\n  let s = -1;\n  let u = -1;\n  if (words.length == 0) { return '' }\n  let result = '';\n  for (let i = 0; i < words.length; i++) {\n    let uniqueChars = new Set(words[i]);\n    if (uniqueChars.size > u || (uniqueChars.size === u && words[i] < result)) {\n      u = uniqueChars.size;\n      result = words[i];\n    }\n  }\n  return result;\n}\n"], ["const doAlgebra = (operator, operand) => {\n  while (operator.length > 0) {\n    let y = 0\n    {\n        let i = operator.length - 1;\n        for (; i >= 0; i--) {\n          if (operator[i] == '**') {\n            let u = operand[i]\n            while (operand[i + 1] > 1) {\n              operand[i + 1]--;\n              operand[i] *= u;\n            }\n            operand.splice(i + 1, 1)\n            operator.splice(i, 1)\n            y = 1;\n            break;\n          }\n        }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operator.splice(i, 1)\n        operand.splice(i + 1, 1)\n        i--;\n        y = 1;\n      } else if (operator[i] == '//') {\n        operand[i] = Math.floor(operand[i] / operand[i + 1])\n        operator.splice(i, 1)\n        operand.splice(i + 1, 1)\n        i--;\n        y = 1;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operator.splice(i, 1)\n        operand.splice(i + 1, 1)\n        i--;\n        y = 1;\n      } else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operator.splice(i, 1)\n        operand.splice(i + 1, 1)\n        i--;\n        y = 1;\n      }\n    }\n  }\n  return operand[0];\n}\n"], ["const solve = (s) => {\n  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (!(y >= 65 && y <= 90)) {\n      if (y >= 97 && y <= 122) {\n        y -= 32;\n        t = 1;\n      } else {\n        y += 32;\n        t = 1;\n      }\n    }\n    p += String.fromCharCode(y);\n  }\n  if (t === 0) {\n    p = s.split('').reverse().join('');\n  }\n  return p;\n};\n"]]