[["\n#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    map<string, int> tonum = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n    map<int, string> numto = {\n        {0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, {4, \"four\"},\n        {5, \"five\"}, {6, \"six\"}, {7, \"seven\"}, {8, \"eight\"}, {9, \"nine\"}\n    };\n\n    int count[10];\n    {\n        int i = 0;\n        while (i < 10) count[i] = 0; // Initialize count array to zero\n        i++;\n    }\n\n    string out = \"\";\n    if (numbers.length() > 0) numbers = numbers + ' '; // Add space before the input\n\n    for (char c : numbers) {\n        if (isdigit(c)) {\n            int index = tonum[c - '0']; // Convert character to integer\n            count[index]++;\n            out += numto[index]; // Append corresponding number to output string\n        } else {\n            out += c; // If not a digit, append the character as is\n        }\n    }\n\n    sort(out.begin(), out.end()); // Sort the characters in the output string\n\n    return out;\n}\n\n"], ["\n#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start checking from the smallest possible divisor\n    for (int i = 2; i <= n / 2; ++i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    // If no divisor is found, n itself is a prime number\n    return n;\n}\n\n"], ["#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x){\n    /*\n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \n    */\n    double sum=0;\n    int i;\n    {\n        i=0;\n        for (;i<xs.size();i++)\n        {\n            sum+=xs[i]*pow(x,i);\n        }\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs){\n    /*\n    xs are coefficients of a polynomial. find_zero find x such that poly(x) = 0. find_zero returns only only zero point, even if there are many. \n    Moreover, find_zero only takes list xs having even number of coefficients and largest non zero coefficient as it guarantees a solution.\n    >>> round(find_zero([1, 2]), 2) #f(x) = 1 + 2x \n    -0.5 \n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 \n    1.0\n    */\n    double ans=0;\n    double value;\n    value=poly(xs,ans);\n    while (abs(value)>1e-6)\n    {\n        double driv=0;\n        for (int i=0;i<xs.size();i++)\n        {\n            if (xs[i]!=0 && value/driv==0)\n            {\n                ans=x;\n                break;\n            }\n            driv+=xs[i];\n        }\n    }\n    return ans;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> third = {};\n    int i = 0;\n    while (i * 3 < l.size()) {\n        third.push_back(l[i * 3]);\n        i++;\n    }\n    \n    sort(third.begin(), third.end());\n    return third;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n  float max = -10000;\n  for (int i = 0; i < l.size(); i++) {\n    if (max < l[i]) max = l[i];\n  }\n  return max;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> out{};\n    vector<float> even = {};\n    {\n        int i = 0;\n        for (; i * 2 < l.size(); i++) {\n            even.push_back(l[i * 2]);\n        }\n    }\n    sort(even.begin(), even.end());\n    for (int i = 0; i < l.size(); i += 2) {\n        out.push_back(even[i]);\n    }\n    return out;\n}\n\n"], ["#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_cyclic(string s){\n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    {\n        i=0;\n        for (;i*3<l;i++)\n        {\n            //cycle elements in each group. Unless group has fewer elements than 3.\n            x=s.substr(i*3,3);\n            if (x.length()==3) x=x.substr(1)+x[0];\n            output=output+x;\n        }\n    }\n    return output;\n}\n\nstring decode_cyclic(string s){ \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        //cycle elements in each group. Unless group has fewer elements than 3.\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x.substr(1)+x[0];\n        output=output+x;\n    }\n    return output;\n}\n"], ["#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    vector<int> result;\n    for (int num : l) {\n        result.push_back(num + 1);\n    }\n    return result;\n}\n"], ["#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    {\n        i=0;\n        for (;i<s.length();i++)\n        {\n            int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n            out=out+(char)w;\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        out+=(char)(((int)s[i]-5+(int)'a')%26+(int)'a');\n    }\n    return out;\n}\n"], ["\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int>l, int t) {\n    for (int i = 0; i < l.size(); i++) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Test cases\n"], ["\n#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Convert both strings to lowercase to handle case insensitivity\n    transform(s0.begin(), s0.end(), s0.begin(), ::tolower);\n    transform(s1.begin(), s1.end(), s1.begin(), ::tolower);\n\n    // Use a set to store unique characters from both strings\n    unordered_set<char> uniqueChars(s0.begin(), s0.end());\n    unordered_set<char> uniqueChars2(s1.begin(), s1.end());\n\n    // Compare the sets\n    return uniqueChars == uniqueChars2;\n}\n\n"], ["using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\nint largest_prime_factor(int n){\n    // Start with the smallest prime number, which is 2\n    int largest_prime = 2;\n    \n    // Divide n by 2 until it's odd\n    while (n % 2 == 0) {\n        largest_prime = 2;\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            largest_prime = i;\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        largest_prime = n;\n    }\n    \n    return largest_prime;\n}\n"], ["#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int num1 = 0, num2 = 0;\n    int i = 0;\n    while (i < lst1.size()) {\n        num1 += lst1[i].length();\n        i++;\n    }\n\n    // Compare the lengths of both vectors\n    if (num1 < num2) {\n        return lst1;\n    } else if (num1 > num2) {\n        return lst2;\n    } else {\n        // If lengths are equal, return the first vector\n        return lst1;\n    }\n}\n"], ["\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool iscuber(int a) {\n    // Check if the absolute value of the number is less than or equal to the cube root of the number\n    if (a <= 0) return false;\n    int cubeRoot = round(sqrt(abs(a)));\n    return cubeRoot * cubeRoot * cubeRoot == abs(a);\n}\n\n"], ["\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    string str, bi = \"\";\n    str = to_string(N);\n    int sum = 0;\n    {\n        int i = 0;\n        for (; i < str.length(); i++) {\n            sum += str[i] - 48;\n        }\n    }\n    return to_string(sum);\n}\n\n"], ["#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint skjkasdkd(vector<int> lst) {\n    int largest = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i] > largest) {\n            largest = lst[i];\n            bool prime = true;\n            {\n                int j = 2;\n                for (; j * j <= lst[i]; j++) {\n                    if (lst[i] % j == 0) prime = false;\n                }\n            }\n        }\n    }\n\n    int sumOfDigits = 0;\n    while (largest > 0) {\n        sumOfDigits += largest % 10;\n        largest /= 10;\n    }\n\n    return sumOfDigits;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool canMakeAllEven(vector<int>& lst1, vector<int>& lst2) {\n    int oddCount = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) oddCount++;\n    }\n    for (int num : lst2) {\n        if (num % 2 != 0) oddCount++;\n    }\n    // If there are more odd numbers in lst1 than in lst2, it's impossible to make all elements in lst1 even\n    return oddCount <= lst1.size();\n}\n\n"], ["#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    string n = \"\";\n    {\n        int i = 0;\n        while (i < s.length()) {\n            if (find(c.begin(), c.end(), s[i]) == c.end()) {\n                n += s[i];\n            }\n            i++;\n        }\n    }\n    // Check if the resulting string is a palindrome\n    bool is_palindrome = n == string(n.rbegin(), n.rend());\n    return {n, is_palindrome ? \"True\" : \"False\"};\n}\n"], ["\n#include <iostream>\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) return false;\n\n    // Split the date string into month, day, and year components\n    stringstream ss(date);\n    char delimiter = '-';\n    string month, day, year;\n    ss >> month >> delimiter >> day >> delimiter >> year;\n\n    // Check if the date is in the correct format\n    if (month.length() != 2 || day.length() != 2 || year.length() != 4) return false;\n\n    // Convert month and day to integers\n    int mm = stoi(month);\n    int dd = stoi(day);\n\n    // Check if the month is valid\n    if (mm < 1 || mm > 12) return false;\n\n    // Check if the day is valid\n    if (dd < 1 || dd > 31) return false;\n\n    // Check if the month is valid for February\n    if (mm == 2 && dd > 29) return false;\n\n    // If all checks pass, the date is valid\n    return true;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    int i;\n    string current = \"\";\n    vector<string> out;\n\n    if (find(txt.begin(), txt.end(), ' ') != txt.end()) {\n        txt = txt + ' ';\n        i = 0;\n        while (i < txt.length()) {\n            if (txt[i] == ' ') {\n                if (current.length() > 0) out.push_back(current);\n                current = \"\";\n                i++;\n            }\n        }\n    } else {\n        for (char ch : txt) {\n            if (islower(ch)) {\n                current += ch;\n            } else if (!current.empty()) {\n                out.push_back(current);\n                current.clear();\n            }\n        }\n        if (!current.empty()) {\n            out.push_back(current);\n        }\n    }\n\n    return out;\n}\n\n"], ["#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int i, j, x, y, min;\n    {\n        i = 0;\n        for (; i < grid.size(); i++) {\n            j = 0;\n            for (; j < grid[i].size(); j++) {\n                if (grid[i][j] == 1) {\n                    x = i;\n                    y = j;\n                }\n            }\n        }\n    }\n\n    vector<int> res;\n    vector<int> dir = {0, 1, 0, -1, 1, 0, -1, 0};\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    pq.push({x, y});\n\n    while (!pq.empty() && res.size() < k) {\n        auto [i, j] = pq.top();\n        pq.pop();\n\n        for (int k = 0; k < 8; k++) {\n            int nx = i + dir[k];\n            int ny = j + dir[k + 1];\n\n            if (nx >= 0 && nx < grid.size() && ny >= 0 && ny < grid[0].size() && grid[nx][ny] == 1) {\n                pq.push({nx, ny});\n                res.push_back(grid[nx][ny]);\n            }\n        }\n    }\n\n    return res;\n}\n"], ["\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b){\n    double  numa,numb;\n    boost::any out;\n\n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            {\n                int i=0;\n                for (;i<s.length();i++)\n                            if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n            }\n        numa=atof(s.c_str());\n        \n    }\n    else if (a.type()==typeid(int))\n    {\n        numa=a.cast<int>();\n    }\n    else if (a.type()==typeid(float))\n    {\n        numa=a.cast<float>();\n    }\n    else\n    {\n        out=\"None\";\n    }\n\n    if (numa > numb)\n        return a;\n    else if (numa < numb)\n        return b;\n    else\n        return out;\n}\n\n"], ["#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    {\n        int i = 0;\n        while (i < lst.size()) {\n            if (i % 3 == 0) sum += lst[i] * lst[i];\n            else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n            i++;\n        }\n    }\n    return sum;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to calculate the sum of digits of a number\nint sum_of_digits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Function to sort the vector of integers by the sum of their digits\nvector<int> order_by_points(vector<int> nums) {\n    vector<int> result;\n    vector<pair<int, int>> digit_sum_indices;\n\n    // Create a list of pairs (sum of digits, index)\n    for (size_t i = 0; i < nums.size(); ++i) {\n        int digit_sum = sum_of_digits(nums[i]);\n        digit_sum_indices.push_back({digit_sum, i});\n    }\n\n    // Sort the list of pairs based on the sum of digits\n    sort(digit_sum_indices.begin(), digit_sum_indices.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        if (a.first == b.first) {\n            return a.second < b.second; // Sort by index if sums are equal\n        }\n        return a.first < b.first; // Sort by sum\n    });\n\n    // Extract the sorted numbers from the sorted list of pairs\n    for (const auto& p : digit_sum_indices) {\n        result.push_back(nums[p.second]);\n    }\n\n    return result;\n}\n\n"], ["\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nint get_matrix_triples(int n) {\n    vector<int> a(n);\n    vector<vector<int>> sum{{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    \n    for (int i = 1; i <= n; i++) {\n        a[i-1] = i * i - i + 1;\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]] += 1;\n    }\n    \n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n"], ["#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out;\n    {\n        int i=0;\n        while(i<lst.size()){if (lst[i].length()%2==0) out.push_back(lst[i]);        i++;\n        }\n    }\n    string mid;\n    sort(out.begin(),out.end());\n    sort(mid.begin(),mid.end());\n    return out;\n}\n"], ["\n#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\n#include<iostream>\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    vector<int> num = {};\n    vector<int> posto = {};\n\n    // Populate the posto array with the indices of the operand vector\n    for (int i = 0; i < operand.size(); i++) posto.push_back(i);\n\n    // Populate the num array with the operands\n    for (int i = 0; i < operand.size(); i++) num.push_back(operand[i]);\n\n    // Perform the algebraic expression\n    for (int i = 0; i < operato.size(); i++) {\n        if (operato[i] == \"+\") {\n            int a = num[posto[i]];\n            int b = num[posto[i + 1]];\n            num[posto[i]] = a + b;\n        } else if (operato[i] == \"-\") {\n            int a = num[posto[i]];\n            int b = num[posto[i + 1]];\n            num[posto[i]] = a - b;\n        } else if (operato[i] == \"*\") {\n            int a = num[posto[i]];\n            int b = num[posto[i + 1]];\n            num[posto[i]] = a * b;\n        } else if (operato[i] == \"//\") {\n            int a = num[posto[i]];\n            int b = num[posto[i + 1]];\n            num[posto[i]] = a / b;\n        } else if (operato[i] == \"**\") {\n            int a = num[posto[i]];\n            int b = num[posto[i + 1]];\n            num[posto[i]] = pow(a, b);\n        } else {\n            throw invalid_argument(\"Unsupported operation: \" + operato[i]);\n        }\n    }\n\n    // Return the final result\n    return num[posto[num.size() - 1]];\n}\n\n"]]