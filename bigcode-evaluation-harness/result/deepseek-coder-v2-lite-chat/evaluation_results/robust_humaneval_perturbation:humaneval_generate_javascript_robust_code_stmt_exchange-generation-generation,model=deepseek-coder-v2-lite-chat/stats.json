[
  {
    "name": {
      "name": "full_level_robustness",
      "split": "test"
    },
    "count": 29,
    "generations": [
      [
        "const allPrefixes = (string) => {\n  var result = [];\n  {\n      let i = 0;\n      while(i < string.length){\n    result.push(string.slice(0, i+1));      i++;\n      }\n  }\n}"
      ],
      [
        "const findClosestElements = (numbers) => {\n  var closest_pair, distance;\n  {\n      let i = 0;\n      while(i < numbers.length){{\n          let j = 0;\n          while(j < numbers.length){if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null || Math.abs(a - b) < distance) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        }\n            j++;\n          }\n      }\n      i++;\n      }\n  }\n  return closest_pair;\n}"
      ],
      [
        "const largestDivisor = (n) => {\n  let i = n - 1;\n  while (i >= 0) {\n    if (n % i == 0) {\n      return i;\n    }\n    i--;\n  }\n}"
      ],
      [
        "const factorize = (n) => {\n  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (!(n % i == 0)) {\n      i++;\n    } else {\n      fact.push(i);\n      n = n / i;\n    }\n  }\n  if (n > 1) {\n    fact.push(n);\n  }\n  return fact;\n}"
      ],
      [
        "const poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n  var begin = -1.0, end = 1.0;\n  for(;(poly(xs, begin) * poly(xs, end) > 0);){\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    var mid = (begin + end) / 2;\n    if (poly(xs, mid) * poly(xs, begin) <= 0) {\n      end = mid;\n    } else {\n      begin = mid;\n    }\n  }\n  return (begin + end) / 2;\n}"
      ],
      [
        "const fizzBuzz = (n) => {\n  var ns = [], ans = 0;\n  {\n      let i = 0;\n      while(i < n){\n          if (i % 11 == 0 || i % 13 == 0)\n              ns.push(i);\n          i++;\n      }\n  }\n  // Count the number of times the digit 7 appears in the numbers in ns\n  for (let num of ns) {\n      let strNum = num.toString();\n      for (let char of strNum) {\n          if (char === '7') {\n              ans++;\n          }\n      }\n  }\n  return ans;\n}"
      ],
      [
        "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  {\n      let i = 0;\n      while(i < Math.floor((s.length + 2) / 3)){\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n        i++;\n      }\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  return encodeCyclic(encodeCyclic(s));\n}"
      ],
      [
        "const primeFib = (n) => {\n  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    {\n        let k = 2;\n        for (; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n          if (p % k == 0)\n            return false;\n        }\n    }\n    return true;\n  };\n\n  let fib = [0, 1];\n  let count = 2;\n  let currentFib = 1;\n\n  while (count < n) {\n    currentFib = fib[fib.length - 1] + fib[fib.length - 2];\n    fib.push(currentFib);\n    if (isPrime(currentFib)) {\n      count++;\n    }\n  }\n\n  return currentFib;\n};"
      ],
      [
        "const triplesSumToZero = (l) => {\n  if (l.length < 3) return false;\n  \n  for (let i = 0; i < l.length - 2; i++) {\n    for (let j = i + 1; j < l.length - 1; j++) {\n      for (let k = j + 1; k < l.length; k++) {\n        if (l[i] + l[j] + l[k] === 0) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}"
      ],
      [
        "const pairsSumToZero = (l) => {\n  if (l.length < 2) return false;\n  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n}"
      ],
      [
        "const isPalindrome = (text) => {\n  let i = 0;\n  for (; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}"
      ],
      [
        "const modp = (n, p) => {\n  var ret = 1;\n  {\n      let i = 0;\n      while(i < n){ret = (2 * ret) % p;      i++;\n      }\n  }\n}"
      ],
      [
        "const largestPrimeFactor = (n) => {\n  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    {\n        let i = 2;\n        for (; i < k - 1; i++)\n          if (k % i == 0)\n            return false;\n    }\n    return true;\n  };\n\n  let largestFactor = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0 && isPrime(i)) {\n      largestFactor = i;\n    }\n  }\n  return largestFactor;\n};"
      ],
      [
        "const smallestChange = (arr) => {\n  var ans = 0;\n  let i = 0;\n  while (i < Math.floor(arr.length / 2)) {\n    if (arr[i] != arr.at(-i - 1)) {\n      ans++;\n    }\n    i++;\n  }\n  return ans;\n}"
      ],
      [
        "const isMultiplyPrime = (a) => {\n  var isPrime = function (n) {\n    if (n <= 1) return false;\n    for (let j = 2; j * j <= n; j++) {\n      if (n % j == 0) return false;\n    }\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (a % i === 0 && isPrime(i)) {\n      for (let j = i + 1; j < 101; j++) {\n        if (a % j === 0 && isPrime(j)) {\n          for (let k = j + 1; k < 101; k++) {\n            if (a % k === 0 && isPrime(k)) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}"
      ],
      [
        "const numericalLetterGrade = (grades) => {\n  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else{\n          if (gpa > 3.7) {\n          letter_grade.push('A')\n        } else{\n              if (gpa > 3.3) {\n              letter_grade.push('A-')\n            } else{\n                  if (gpa > 3.0) {\n                  letter_grade.push('B+')\n                } else{\n                      if (gpa > 2.7) {\n                  letter_grade.push('B')\n                } else{\n                      if (gpa > 2.3) {\n                  letter_grade.push('B-')\n                } else{\n                      if (gpa > 2.0) {\n                  letter_grade.push('C+')\n                } else{\n                      if (gpa > 1.7) {\n                  letter_grade.push('C')\n                } else{\n                      if (gpa > 1.3) {\n                  letter_grade.push('C-')\n                } else{\n                      if (gpa > 1.0) {\n                  letter_grade.push('D+')\n                } else{\n                      if (gpa > 0.7) {\n                  letter_grade.push('D')\n                } else{\n                      if (gpa > 0.0) {\n                  letter_grade.push('D-')\n                } else{\n                  letter_grade.push('E')\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}"
      ],
      [
        "const antiShuffle = (s) => {\n  let arr = s.split(/\\s/);\n  let result = arr.map(word => {\n    return word.split('').sort().join('');\n  });\n  return result.join(' ');\n}"
      ],
      [
        "const encrypt = (s) => {\n  let t = '';\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4;\n    if (p > 122) {\n      p -= 26;\n    }\n    t += String.fromCharCode(p);\n  }\n  return t;\n}"
      ],
      [
        "const nextSmallest = (lst) => {\n  let arr = lst;\n  if (arr.length < 2) return null;\n  let firstMin = Infinity, secondMin = Infinity;\n  for (let num of arr) {\n    if (num < firstMin) {\n      secondMin = firstMin;\n      firstMin = num;\n    } else if (num > firstMin && num < secondMin) {\n      secondMin = num;\n    }\n  }\n  return secondMin === Infinity ? null : secondMin;\n}"
      ],
      [
        "const encode = (message) => {\n  let t = '';\n  {\n      let i = 0;\n      while(i < message.length){\n          let p = message[i].charCodeAt();\n          if (p > 96) {\n              p -= 32;\n          }\n          if (p >= 65 && p <= 90) {\n              let c = String.fromCharCode(p);\n              if (c.match(/[AEIOU]/i)) {\n                  let nextCharCode = p + 2;\n                  if (nextCharCode > 90) {\n                      nextCharCode -= 26;\n                  }\n                  t += String.fromCharCode(nextCharCode).toLowerCase();\n              } else {\n                  t += c.toLowerCase();\n              }\n          }\n          i++;\n      }\n  }\n  return t;\n};"
      ],
      [
        "const skjkasdkd = (lst) => {\n  let t = 0\n  {\n      let i = 0;\n      for (; i < lst.length; i++) {\n          let p = 1\n          {\n              let j = 2;\n              for (; j * j <= lst[i]; j++) {\n                  if (lst[i] % j == 0) { p = 0; break }\n              }\n          }\n          if (p && lst[i] > t) {\n              t = lst[i];\n          }\n      }\n  }\n  if (t === 0) return null; // No prime number found\n  let sum = 0;\n  while (t > 0) {\n      sum += t % 10;\n      t = Math.floor(t / 10);\n  }\n  return sum;\n}"
      ],
      [
        "const countUpTo = (n) => {\n  let t = []\n  if (n <= 2) return t;\n  for (let i = 2; i < n; i++) {\n    let isPrime = true;\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      t.push(i);\n    }\n  }\n  return t;\n}"
      ],
      [
        "const countUpper = (s) => {\n  let p = 0;\n  {\n      let i = 0;\n      while(i < s.length){\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n      p++;\n    }\n    i += 2;\n      }\n  }\n}"
      ],
      [
        "const makeAPile = (n) => {\n  let t = []\n  {\n      let i = n;\n      for (; i < n * 3; i += 2) {\n      t.push(i)\n  }\n  }\n  return t;\n}"
      ],
      [
        "const chooseNum = (x, y) => {\n  {\n      let i = y;\n      while(i >= x){\n    if (i % 2 == 0) {return i }\n        i--;\n      }\n  }\n  return -1;\n}"
      ],
      [
        "const uniqueDigits = (x) => {\n  let p = []\n  {\n      let i = 0;\n      while(i < x.length){\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo == 1) {\n      p.push(x[i]);\n    }\n    i++;\n      }\n  }\n  return p.sort((a, b) => a - b);\n}"
      ],
      [
        "const byLength = (arr) => {\n  p = []\n  {\n      let i = 0;\n      for (; i < arr.length; i++) {\n      if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    let tmp = p[j];\n    p[j] = p[ind];\n    p[ind] = tmp;\n  }\n  const digitNames = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n  return p.map(digit => digitNames[digit - 1]);\n}"
      ],
      [
        "const f = (n) => {\n  let f = 1\n  let p = 0\n  let k = []\n  {\n      let i = 1;\n      for (; i <= n; i++) {\n      if (i % 2 === 0) {\n          f = 1;\n          for (let j = 1; j <= i; j++) {\n          f *= j;\n          }\n          k.push(f);\n      } else {\n          p = (i * (i + 1)) / 2;\n          k.push(p);\n      }\n      }\n  }\n  return k;\n}"
      ],
      [
        "const countNums = (arr) => {\n  let p = 0;\n  {\n      let i = 0;\n      for (; i < arr.length; i++) {\n      let h = arr[i];\n      let sum = 0;\n      let numStr = Math.abs(h).toString();\n      for (let j = 0; j < numStr.length; j++) {\n        sum += parseInt(numStr[j], 10);\n      }\n      if (h < 0) {\n        sum = -sum; // Adjust the sum for negative numbers\n      }\n      if (sum > 0) {\n        p++;\n      }\n    }\n  }\n  return p;\n};"
      ],
      [
        "const exchange = (lst1, lst2) => {\n  let k = lst1.length;\n  let t = 0;\n  {\n      let i = 0;\n      while(i < lst1.length){\n    if (lst1[i] % 2 == 0) { t++ }\n        i++;\n      }\n  }\n  if (t == lst1.length) {\n      return \"YES\";\n  }\n  let oddCount = 0;\n  for (let i = 0; i < lst1.length; i++) {\n      if (lst1[i] % 2 != 0) {\n          oddCount++;\n      }\n  }\n  let evenCount = lst1.length - oddCount;\n  let availableEvens = 0;\n  for (let i = 0; i < lst2.length; i++) {\n      if (lst2[i] % 2 == 0) {\n          availableEvens++;\n      }\n  }\n  if (oddCount <= availableEvens) {\n      return \"YES\";\n  } else {\n      return \"NO\";\n  }\n}"
      ],
      [
        "const histogram = (test) => {\n  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (let m in t) {\n    if (!(t[m] in d)) {\n      d[t[m]] = 1\n    } else {\n      d[t[m]]++\n    }\n  }\n  if (Object.keys(d).length === 0) {\n    return {}\n  }\n  let maxCount = Math.max(...Object.values(d))\n  let result = {}\n  for (let key in d) {\n    if (d[key] === maxCount) {\n      result[key] = d[key]\n    }\n  }\n  return result\n}"
      ],
      [
        "const reverseDelete = (s, c) => {\n  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    {\n        let j = 0;\n        while(j < c.length){\n      if (s[i] == c[j]) {\n        y = 0\n      }\n            j++;\n        }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  const isPalindrome = (str) => {\n    const reversed = str.split('').reverse().join('');\n    return str === reversed;\n  };\n  return [t, isPalindrome(t)];\n};"
      ],
      [
        "const oddCount = (lst) => {\n  let d = [];\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length;\n    for (let j = 0; j < h; j++) {\n      if (parseInt(lst[i][j]) % 2 !== 0) {\n        p++;\n      }\n    }\n    let result = `the number of odd elements ${p}n the str${p}ng ${p} of the ${p}nput.`;\n    d.push(result);\n  }\n  return d;\n};"
      ],
      [
        "const minSubArraySum = (nums) => {\n  let min = nums[0];\n  {\n      let i = 0;\n      while(i < nums.length){\n    {\n        let j = i + 1;\n        while(j <= nums.length){\n      let s = 0;\n      {\n          let k = i;\n          while(k < j){\n                s += nums[k];\n                k++;\n          }\n      }\n          if(s < min) min = s;\n          j++;\n        }\n    }\n  }\n  return min;\n}"
      ],
      [
        "const maxFill = (grid, capacity) => {\n  let p = 0\n  {\n      let i = 0;\n      while(i < grid.length){\n    let m = 0\n    {\n        let j = 0;\n        while(j < grid[i].length){\n      if (grid[i][j] == 1) { m++ }\n          j++;\n        }\n    }\n    p += Math.ceil(m / capacity);\n    i++;\n      }\n  }\n  return p;\n}"
      ],
      [
        "const sortArray = (arr) => {\n  let p = arr;\n  {\n      let j = 0;\n      for (; j < p.length; j++) {\n          let ind = j;\n          {\n              let k = j + 1;\n              for (; k < p.length; k++) {\n                  let w1 = p[ind].toString(2);\n                  let f1 = 0;\n                  {\n                      let u = 0;\n                      for (; u < w1.length; u++) {\n                          if (w1[u] == '1') { f1++ }\n                      }\n                  }\n                  let w2 = p[k].toString(2);\n                  let f2 = 0;\n                  {\n                      let u = 0;\n                      for (; u < w2.length; u++) {\n                          if (w2[u] == '1') { f2++ }\n                      }\n                  }\n                  if (f1 > f2 || (f1 === f2 && p[ind] > p[k])) {\n                      let temp = p[ind];\n                      p[ind] = p[k];\n                      p[k] = temp;\n                  }\n              }\n          }\n      }\n  }\n  return p;\n}"
      ],
      [
        "const selectWords = (s, n) => {\n  let t = s.split(/\\s/);\n  if (s == '') { return [] }\n  let k = [];\n  let consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ';\n  \n  for (let word of t) {\n    let consonantCount = 0;\n    for (let char of word) {\n      if (consonants.includes(char)) {\n        consonantCount++;\n      }\n    }\n    if (consonantCount === n) {\n      k.push(word);\n    }\n  }\n  return k;\n}"
      ],
      [
        "const matchParens = (lst) => {\n  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (!(w1[i] == '(')) { y-- }\n    else { y++ }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (y != 0) { u = 0; }\n  return u == 1 ? 'Yes' : 'No';\n}"
      ],
      [
        "const maximum = (arr, k) => {\n  let p = arr;\n  {\n      let j = 0;\n      for (; j < p.length; j++) {\n          let ind = j;\n          {\n              let k = j + 1;\n              for (; k < p.length; k++) {\n                  if (p[k] < p[ind]) {\n                      ind = k;\n                  }\n              }\n          }\n          // Swap the found minimum element with the first element\n          let temp = p[j];\n          p[j] = p[ind];\n          p[ind] = temp;\n      }\n  }\n  // Return the first k elements from the sorted array\n  return p.slice(-k).sort((a, b) => a - b);\n};"
      ],
      [
        "const addElements = (arr, k) => {\n  let p = 0;\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) {\n      p += arr[i];\n    }\n  }\n  return p;\n}"
      ],
      [
        "const getOddCollatz = (n) => {\n  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    {\n        let i = 0;\n        for (; i < p.length; i++) {\n          if (t == p[i]) {\n            u = 1\n            break;\n          }\n        }\n    }\n    if (u == 1) { break }\n    p.push(t)\n    if (t % 2 == 0) {\n      t = t / 2\n    } else {\n      t = 3 * t + 1\n    }\n  }\n  let oddNumbers = p.filter(num => num % 2 !== 0).sort((a, b) => a - b)\n  return oddNumbers\n}"
      ],
      [
        "const minPath = (grid, k) => {\n  let m = 0\n  let n = 0\n  {\n      let i = 0;\n      while(i < grid.length){\n    {\n        let j = 0;\n        while(j < grid.length){\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n            i++;\n      }\n          j++;\n        }\n    }\n  }\n\n  const directions = [\n    [0, 1], [1, 0], [0, -1], [-1, 0]\n  ];\n\n  const isValid = (x, y) => {\n    return x >= 0 && x < grid.length && y >= 0 && y < grid.length;\n  };\n\n  const dfs = (x, y, path) => {\n    if (path.length === k) {\n      return path;\n    }\n\n    let minPath = null;\n\n    for (const [dx, dy] of directions) {\n      const nx = x + dx;\n      const ny = y + dy;\n\n      if (isValid(nx, ny)) {\n        const newPath = dfs(nx, ny, [...path, grid[nx][ny]]);\n        if (newPath) {\n          if (minPath === null || newPath < minPath) {\n            minPath = newPath;\n          }\n        }\n      }\n    }\n\n    return minPath;\n  };\n\n  return dfs(m, n, [grid[m][n]]);\n};"
      ],
      [
        "const isNested = (string) => {\n  let opening_bracket_index = [];\n  let closing_bracket_index1 = [];\n  for (let i = 0; i < string.length; i++) {\n    if (!(string[i] == '[')) {\n      closing_bracket_index1.push(i);\n    } else {\n      opening_bracket_index.push(i);\n    }\n  }\n  // Check for nested subsequence\n  for (let i = 0; i < opening_bracket_index.length; i++) {\n    for (let j = 0; j < closing_bracket_index1.length; j++) {\n      if (opening_bracket_index[i] < closing_bracket_index1[j]) {\n        return true;\n      }\n    }\n  }\n  return false;\n}"
      ],
      [
        "const canArrange = (arr) => {\n  if (arr.length == 0) { return -1 }\n  let i = arr.length - 1;\n  while(i > 0){\n    if (arr[i] < arr[i - 1]) { return i; }\n    i--;\n  }\n  return -1;\n}"
      ],
      [
        "const largestSmallestIntegers = (lst) => {\n  let a = null;\n  let b = null;\n\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < 0 && (a === null || lst[i] > a)) {\n      a = lst[i];\n    }\n    if (lst[i] > 0 && (b === null || lst[i] < b)) {\n      b = lst[i];\n    }\n  }\n\n  return [a, b];\n}"
      ],
      [
        "const fixSpaces = (text) => {\n  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (!(text[i] == ' ')) {\n      if (c > 0) {\n        if (c == 1) { t += '_' }\n        if (c == 2) { t += '__' }\n        c = 0\n      }\n      t += text[i]\n    } else {\n      c++\n    }\n  }\n  if (c > 0) {\n    if (c == 1) { t += '_' }\n    if (c == 2) { t += '__' }\n  }\n  return t\n}"
      ],
      [
        "const sumSquares = (lst) => {\n  let y = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) {\n      y += lst[i] * lst[i];\n    } else {\n      if (i % 4 == 0) {\n        y += lst[i] * lst[i] * lst[i];\n      }\n    }\n  }\n  return y;\n};"
      ],
      [
        "const wordsInSentence = (sentence) => {\n  let t = sentence.split(/\\s/);\n  let p = '';\n  {\n      let j = 0;\n      for (; j < t.length; j++) {\n          let len = t[j].length;\n          let u = 1;\n          if (len == 1 || len == 0) { continue }\n          for (let i = 2; i <= Math.sqrt(len); i++) {\n              if (len % i == 0) {\n                  u = 0;\n                  break;\n              }\n          }\n          if (u == 1) {\n              p += t[j] + ' ';\n          }\n      }\n  }\n  return p.trim();\n}"
      ],
      [
        "const orderByPoints = (nums) => {\n  let p = nums;\n  {\n      let j = p.length - 2;\n      for (; j >= 0; j--) {\n          {\n              let k = 0;\n              for (; k <= j; k++) {\n                  let m = 0;\n                  let n = 0;\n                  let h = p[k];\n                  let d = p[k + 1];\n                  let y = 1;\n                  let u = 1;\n                  if (h < 0) { y = -1; h = -h; }\n                  if (d < 0) { u = -1; d = -d; }\n                  let sumH = 0;\n                  let sumD = 0;\n                  while (h > 0) {\n                      sumH += h % 10;\n                      h = Math.floor(h / 10);\n                  }\n                  while (d > 0) {\n                      sumD += d % 10;\n                      d = Math.floor(d / 10);\n                  }\n                  if (y === -1) sumH = -sumH;\n                  if (u === -1) sumD = -sumD;\n                  if (sumH > sumD) {\n                      let temp = p[k];\n                      p[k] = p[k + 1];\n                      p[k + 1] = temp;\n                  } else if (sumH === sumD && k > j) {\n                      let temp = p[k];\n                      p[k] = p[k + 1];\n                      p[k + 1] = temp;\n                  }\n              }\n          }\n      }\n  }\n  return p;\n};"
      ],
      [
        "const specialFilter = (nums) => {\n  let p = 0;\n  {\n      let i = 0;\n      while(i < nums.length){\n        if (nums[i] < 10) { i++; continue }\n        let y = nums[i].toString();\n        let firstDigit = parseInt(y[0]);\n        let lastDigit = parseInt(y[y.length - 1]);\n        if (firstDigit % 2 !== 0 && lastDigit % 2 !== 0) {\n          p++;\n        }\n        i++;\n      }\n  }\n  return p;\n}"
      ],
      [
        "const getMaxTriples = (n) => {\n  let y = []\n  {\n      let i = 1;\n      while(i <= n){\n    y.push(i * i - i + 1)\n        i++;\n      }\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 === 0) {\n          u++;\n        }\n      }\n    }\n  }\n  return u;\n}"
      ],
      [
        "const bf = (planet1, planet2) => {\n  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  {\n      let i = 0;\n      for (; i < 8; i++) {\n      if (y[i] == planet1) { lo = i }\n    }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo > hi) {\n    return [];\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i]);\n  }\n  return u;\n}"
      ],
      [
        "const sortedListSum = (lst) => {\n  let p = []\n  {\n      let i = 0;\n      for (; i < lst.length; i++) {\n      if (lst[i].length % 2 == 0) {\n        p.push(lst[i])\n      }\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        if (p[k] > p[k + 1]) { f = 1 }\n      }\n      if (f == 1) {\n        let temp = p[k];\n        p[k] = p[k + 1];\n        p[k + 1] = temp;\n      }\n    }\n  }\n  return p;\n}"
      ],
      [
        "const strongestExtension = (class_name, extensions) => {\n  let u = 0\n  let s = -Infinity\n  let strongest = ''\n\n  for (let ext of extensions) {\n    let CAP = 0\n    let SM = 0\n\n    for (let char of ext) {\n      if (char >= 'A' && char <= 'Z') {\n        CAP++\n      } else if (char >= 'a' && char <= 'z') {\n        SM++\n      }\n    }\n\n    let strength = CAP - SM\n\n    if (strength > s) {\n      s = strength\n      strongest = ext\n    }\n  }\n\n  return `${class_name}.${strongest}`\n}"
      ],
      [
        "const cycpatternCheck = (a, b) => {\n  let l = b.length;\n  let pat = b + b;\n  for (let i = 0; i < l; i++) {\n    let sub = pat.substring(i, i + l);\n    if (a.includes(sub)) {\n      return true;\n    }\n  }\n  return false;\n};"
      ],
      [
        "const findMax = (words) => {\n  let s = -1;\n  let u = -1;\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = new Set(words[i]);\n    if (p.size > u || (p.size == u && words[i] < s)) {\n      u = p.size;\n      s = words[i];\n    }\n  }\n  return s;\n}"
      ],
      [
        "``javascript\nconst doAlgebra = (operator, operand) => {\n  while (operator.length > 0) {\n    let y = 0\n    {\n        let i = operator.length - 1;\n        for (; i >= 0; i--) {\n          if (operator[i] == '**') {\n            let u = operand[i]\n            while (operand[i + 1] > 1) {\n              operand[i + 1]--;\n              operand[i] *= u;\n            }\n            operand.splice(i + 1, 1)\n            operator.splice(i, 1)\n            y = 1;\n            break;\n          }\n        }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        i--;\n      }\n    }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '//') {\n        operand[i] = Math.floor(operand[i] / operand[i + 1])\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        i--;\n      }\n    }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        i--;\n      }\n    }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        i--;\n      }\n    }\n  }"
      ],
      [
        "const solve = (s) => {\n  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (!(y >= 65 && y <= 90) && !(y >= 97 && y <= 122)) {\n      p += s[i];\n    } else {\n      if (y >= 65 && y <= 90) {\n        y += 32;\n      } else {\n        y -= 32;\n      }\n      p += String.fromCharCode(y);\n      t = 1;\n    }\n  }\n  if (t === 0) {\n    return s.split('').reverse().join('');\n  }\n  return p;\n}"
      ]
    ],
    "variance": 0.0,
    "stddev": 0.0
  }
]