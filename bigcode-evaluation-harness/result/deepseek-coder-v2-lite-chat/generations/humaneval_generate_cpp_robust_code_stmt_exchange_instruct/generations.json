[["#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    {\n        int i=0;\n        while(i<10){count[i]=0;        i++;\n        }\n    }\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for(char c : numbers) {\n        if (c == ' ') {\n            count[tonum[current]]++;\n            current = \"\";\n        } else {\n            current += c;\n        }\n    }\n    for(int i = 0; i < 10; i++) {\n        while(count[i] > 0) {\n            out += numto[i] + \" \";\n            count[i]--;\n        }\n    }\n    if (!out.empty()) out.pop_back(); // Remove the last space\n    return out;\n}\n"], ["#include<stdio.h>\nusing namespace std;\nint largest_divisor(int n){\n    int i=2;\n    while(i*i<=n){\n        if (n%i==0) return  n/i;\n        i++;\n    }\n    return 1; // If no divisor is found, return 1 as a fallback\n}\n"], ["#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\ndouble poly(vector<double> xs, double x){\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \n    */\n    double sum=0;\n    int i;\n    {\n        i=0;\n        for (;i<xs.size();i++)\n        {\n            sum+=xs[i]*pow(x,i);\n        }\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs){\n    /*\n    xs are coefficients of a polynomial. find_zero find x such that poly(x) = 0. find_zero returns only only zero point, even if there are many. \n    Moreover, find_zero only takes list xs having even number of coefficients and largest non zero coefficient as it guarantees a solution.\n    */\n    double ans=0;\n    double value;\n    value=poly(xs,ans);\n    while (abs(value)>1e-6)\n    {\n        double driv=0;\n        // Compute the derivative of the polynomial\n        for (int i=1; i<xs.size(); i++) {\n            driv += xs[i] * i * pow(ans, i-1);\n        }\n        // Newton's method to find the root\n        double new_ans = ans - value / driv;\n        ans = new_ans;\n        value = poly(xs, ans);\n    }\n    return ans;\n}\n"], ["#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i=0;\n    while(i*3<l.size()){\n        third.push_back(l[i*3]);\n        i++;\n    }\n    \n    sort(third.begin(),third.end());\n    \n    i=0;\n    while(i*3<l.size()){\n        l[i*3] = third[i];\n        i++;\n    }\n    \n    return l;\n}\n"], ["#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nfloat max_element(vector<float> l){\n  float max=-10000;\n  {\n      int i=0;\n      for (;i<l.size();i++)\n    if (max<l[i]) max=l[i];\n  }\n}\n"], ["#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    {\n        int i=0;\n        for (;i*2<l.size();i++)\n            even.push_back(l[i*2]);\n    }\n    sort(even.begin(),even.end());\n    int evenIndex = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            out.push_back(even[evenIndex]);\n            evenIndex++;\n        } else {\n            out.push_back(l[i]);\n        }\n    }\n    return out;\n}\n"], ["#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_cyclic(string s){ \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    {\n        i=0;\n        for (;i*3<l;i++)\n        {\n            //cycle elements in each group. Unless group has fewer elements than 3.\n            x=s.substr(i*3,3);\n            if (x.length()==3) x=x.substr(1)+x[0];\n            output=output+x;\n        }\n    }\n    return output;\n}\n\nstring decode_cyclic(string s){ \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        //cycle elements in each group. Unless group has fewer elements than 3.\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x[2]+x.substr(0,2);\n        output=output+x;\n    }\n    return output;\n}\n"], ["#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> incr_list(vector<int> l){\n    int i=0;\n    while(i<l.size()){\n        l[i]+=1;\n        i++;\n    }\n    return l;\n}\n"], ["#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n"], ["#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool below_threshold(vector<int>l, int t){\n    for (int i = 0; i < l.size(); i++)\n        if (l[i] >= t) return false;\n    return true;\n}\n"], ["#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nbool same_chars(string s0,string s1){\n    if (s0.length() != s1.length()) {\n        return false;\n    }\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n    return s0 == s1;\n}\n"], ["#include<stdio.h>\nusing namespace std;\nint largest_prime_factor(int n){\n    int maxPrime = -1;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n >>= 1; // equivalent to n /= 2\n    }\n\n    // n must be odd at this point, thus a skip of 2 (i.e., i = i + 2) can be used\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, update n and maxPrime\n        while (n % i == 0) {\n            maxPrime = i;\n            n = n / i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2)\n        maxPrime = n;\n\n    return maxPrime;\n}\n"], ["#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int num1 = 0, num2 = 0, i;\n    for (i = 0; i < lst1.size(); i++) {\n        num1 += lst1[i].length();\n    }\n    for (i = 0; i < lst2.size(); i++) {\n        num2 += lst2[i].length();\n    }\n    if (num1 < num2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"], ["#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool iscuber(int a){\n    int i=0;\n    for (;i*i*i<=abs(a);i++)\n        if (i*i*i==abs(a)) return true;\n    return false;\n}\n"], ["#include<stdio.h>\n#include<string>\nusing namespace std;\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    {\n        int i=0;\n        for (;i<str.length();i++)\n            sum+=str[i]-48;\n    }\n    while(sum > 0){\n        bi = (sum % 2 == 0 ? \"0\" : \"1\") + bi;\n        sum /= 2;\n    }\n    return bi.empty() ? \"0\" : bi;\n}\n"], ["#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            {\n                int j=2;\n                for (;j*j<=lst[i];j++)\n                            if (lst[i]%j==0) prime=false;\n            }\n            if (prime) largest=lst[i];\n        }\n    if (largest==0) return 0; // Handle the case where no prime number is found\n    int sum=0;\n    while (largest>0) {\n        sum+=largest%10;\n        largest/=10;\n    }\n    return sum;\n}\n"], ["#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int num = 0;\n    {\n        int i = 0;\n        for (; i < lst1.size(); i++)\n            if (lst1[i] % 2 == 0) num += 1;\n    }\n    if (num == lst1.size()) return \"YES\";\n\n    num = 0;\n    {\n        int i = 0;\n        for (; i < lst2.size(); i++)\n            if (lst2[i] % 2 == 0) num += 1;\n    }\n    if (num == lst2.size()) return \"YES\";\n\n    for (int i = 0; i < lst1.size(); i++) {\n        for (int j = 0; j < lst2.size(); j++) {\n            int temp = lst1[i];\n            lst1[i] = lst2[j];\n            lst2[j] = temp;\n\n            num = 0;\n            for (int k = 0; k < lst1.size(); k++)\n                if (lst1[k] % 2 == 0) num += 1;\n            if (num == lst1.size()) return \"YES\";\n\n            num = 0;\n            for (int k = 0; k < lst2.size(); k++)\n                if (lst2[k] % 2 == 0) num += 1;\n            if (num == lst2.size()) return \"YES\";\n\n            lst1[i] = lst2[j];\n            lst2[j] = temp;\n        }\n    }\n\n    return \"NO\";\n}\n"], ["#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    {\n        int i=0;\n        while(i<s.length()){\n            if (find(c.begin(),c.end(),s[i])==c.end())\n                n=n+s[i];\n            i++;\n        }\n    }\n    bool is_palindrome = true;\n    int len = n.length();\n    for(int i = 0; i < len / 2; i++) {\n        if(n[i] != n[len - i - 1]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n    return {n, is_palindrome ? \"True\" : \"False\"};\n}\n"], ["#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool valid_date(string date) {\n    int mm, dd, yy, i;\n    if (date.length() != 10) return false;\n    {\n        int i = 0;\n        while (i < 10) {\n            if (i == 2 || i == 5) {\n                if (date[i] != '-') return false;\n            } else {\n                if (!isdigit(date[i])) return false;\n            }\n            i++;\n        }\n    }\n    mm = (date[0] - '0') * 10 + (date[1] - '0');\n    dd = (date[3] - '0') * 10 + (date[4] - '0');\n    yy = (date[6] - '0') * 1000 + (date[7] - '0') * 100 + (date[8] - '0') * 10 + (date[9] - '0');\n\n    if (mm < 1 || mm > 12) return false;\n    if (dd < 1 || dd > 31) return false;\n\n    if (mm == 2) {\n        if (dd > 29) return false;\n    } else if (mm == 4 || mm == 6 || mm == 9 || mm == 11) {\n        if (dd > 30) return false;\n    }\n\n    return true;\n}\n"], ["#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        i=0;\n        while(i<txt.length()){\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            } else {\n                current+=txt[i];\n            }\n            i++;\n        }\n    } else if (find(txt.begin(),txt.end(),',')!=txt.end()) {\n        txt=txt+',';\n        i=0;\n        while(i<txt.length()){\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            } else {\n                current+=txt[i];\n            }\n            i++;\n        }\n    } else {\n        int count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z') {\n                if ((c - 'a') % 2 != 0) {\n                    count++;\n                }\n            }\n        }\n        out.push_back(to_string(count));\n    }\n    return out;\n}\n"], ["#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int n = grid.size();\n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n    auto cmp = [](const pair<vector<int>, int>& a, const pair<vector<int>, int>& b) {\n        return a.first > b.first;\n    };\n    priority_queue<pair<vector<int>, int>, vector<pair<vector<int>, int>>, decltype(cmp)> pq(cmp);\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 1) {\n                pq.push({{grid[i][j]}, i * n + j});\n            }\n        }\n    }\n\n    while (!pq.empty()) {\n        auto [path, pos] = pq.top();\n        pq.pop();\n        int x = pos / n;\n        int y = pos % n;\n\n        if (path.size() == k) {\n            return path;\n        }\n\n        for (int d = 0; d < 4; ++d) {\n            int nx = x + dx[d];\n            int ny = y + dy[d];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                vector<int> newPath = path;\n                newPath.push_back(grid[nx][ny]);\n                pq.push({newPath, nx * n + ny});\n            }\n        }\n    }\n\n    return {};\n}\n"], ["\n#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\nboost::any compare_one(boost::any a,boost::any b){\n    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            {\n                int i=0;\n                for (;i<s.length();i++)\n                            if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n            }\n        numa=atof(s.c_str());\n        \n    }\n    else if (a.type()==typeid(int))\n    {\n        numa=boost::any_cast<int>(a);\n    }\n    else if (a.type()==typeid(double))\n    {\n        numa=boost::any_cast<double>(a);\n    }\n\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            {\n                int i=0;\n                for (;i<s.length();i++)\n                            if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n            }\n        numb=atof(s.c_str());\n        \n    }\n    else if (b.type()==typeid(int))\n    {\n        numb=boost::any_cast<int>(b);\n    }\n    else if (b.type()==typeid(double))\n    {\n        numb=boost::any_cast<double>(b);\n    }\n\n    if (numa>numb)\n    {\n        if (a.type()==typeid(string))\n            return a;\n        else if"], ["#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst){\n    int sum=0;\n    for(int i=0; i<lst.size(); i++){\n        if (i%3==0) {\n            sum += lst[i] * lst[i];\n        } else if (i%4==0 && i%3!=0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"], ["#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<int> order_by_points(vector<int> nums){\n    vector<pair<int, int>> sumdigit;\n    for (int i=0;i<nums.size();i++) {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=0;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum-=w[0]-48;\n        sumdigit.push_back(make_pair(sum, i));\n    }\n    sort(sumdigit.begin(), sumdigit.end());\n    vector<int> result;\n    for (auto &p : sumdigit) {\n        result.push_back(nums[p.second]);\n    }\n    return result;\n}\n"], ["#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_matrix_triples(int n) {\n    vector<int> a;\n    for (int i = 1; i <= n; ++i) {\n        a.push_back(i * i - i + 1);\n    }\n\n    int count = 0;\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n"], ["#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out={};\n    for(int i=0; i<lst.size(); i++){\n        if (lst[i].length() % 2 == 0) out.push_back(lst[i]);\n    }\n    sort(out.begin(), out.end());\n    return out;\n}\n"], ["#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand){\n    vector<int> num={};\n    vector<int> posto={};\n    {\n        int i=0;\n        for (;i<operand.size();i++)\n            posto.push_back(i);\n    }\n    {\n        int i=0;\n        for (;i<operato.size();i++)\n            if (operato[i]==\"**\") \n            {\n            while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n            while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n            operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n            posto[i+1]=posto[i];\n            }\n    }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\") \n            operand[i+1]=operand[i]+operand[i+1];\n        else if (operato[i]==\"-\") \n            operand[i+1]=operand[i]-operand[i+1];\n        else if (operato[i]==\"*\") \n            operand[i+1]=operand[i]*operand[i+1];\n        else if (operato[i]==\"//\") \n            operand[i+1]=operand[i]/operand[i+1];\n    return operand[operand.size()-1];\n}\n"]]