[
  {
    "name": {
      "name": "full_level_robustness",
      "split": "test"
    },
    "count": 29,
    "generations": [
      [
        "const allPrefixes = (string) => {\n  var result = [];\n  let i = 0;\n  while(i < string.length){\n    result.push(string.slice(0, i+1));\n    i++;\n  }\n  return result;\n}"
      ],
      [
        "const findClosestElements = (numbers) => {\n  var closest_pair, distance;\n  {\n      let i = 0;\n      while(i < numbers.length){\n          let j = 0;\n          while(j < numbers.length){\n              if (i != j) {\n                  let a = numbers[i], b = numbers[j];\n                  if (distance == null) {\n                      distance = Math.abs(a - b);\n                      closest_pair = [a, b];\n                  } else if (Math.abs(a - b) < distance) {\n                      distance = Math.abs(a - b);\n                      closest_pair = [a, b].sort((x, y) => x - y);\n                  }\n              }\n              j++;\n          }\n          i++;\n      }\n      return closest_pair;\n  }\n};"
      ],
      [
        "const largestDivisor = (n) => {\n  let i = n - 1;\n  while(i >= 1){\n    if (n % i === 0) {\n      return i;\n    }\n    i--;\n  }\n}"
      ],
      [
        "const factorize = (n) => {\n  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (!(n % i == 0)) {\n      i++;\n    } else {\n      fact.push(i);\n      n = n / i;\n    }\n  }\n  if (n > 1) {\n    fact.push(n);\n  }\n  return fact;\n}"
      ],
      [
        "const poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n  var begin = -1.0, end = 1.0;\n  for(;(poly(xs, begin) * poly(xs, end) > 0);){\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    const mid = (begin + end) / 2.0;\n    if (poly(xs, mid) * poly(xs, begin) < 0) {\n      end = mid;\n    } else {\n      begin = mid;\n    }\n  }\n  return begin;\n}"
      ],
      [
        "const fizzBuzz = (n) => {\n  var ns = [], ans = 0;\n  {\n    let i = 0;\n    while(i < n){\n      if (i % 11 == 0 || i % 13 == 0) {\n        ns.push(i);\n      }\n      i++;\n    }\n  }\n\n  for(let num of ns) {\n    ans += num.toString().split('').filter(digit => digit === '7').length;\n  }\n\n  return ans;\n}"
      ],
      [
        "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  {\n      let i = 0;\n      while(i < Math.floor((s.length + 2) / 3)){\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n        i++;\n      }\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  {\n      let i = 0;\n      while(i < Math.floor((s.length + 2) / 3)){\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n        i++;\n      }\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.charAt(2) + group.slice(0, 2));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}"
      ],
      [
        "const primeFib = (n) => {\n  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    {\n      let k = 2;\n      for (; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n        if (p % k == 0)\n          return false;\n      }\n    }\n    return true;\n  };\n\n  var fib = function (a = 0, b = 1, count = 0) {\n    if (count === n) {\n      return a;\n    }\n    let next = a + b;\n    a = b;\n    b = next;\n    return fib(a, b, count + 1);\n  };\n\n  return fib(0, 1, 1);\n};"
      ],
      [
        "const triplesSumToZero = (l) => {\n  let i = 0;\n  for (; i < l.length; i++) {\n    let j = i + 1;\n    for (; j < l.length; j++) {\n      let k = j + 1;\n      for (; k < l.length; k++) {\n        if (l[i] + l[j] + l[k] === 0) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}"
      ],
      [
        "const pairsSumToZero = (l) => {\n  let i = 0;\n  while(i < l.length){\n    let j = i + 1;\n    while(j < l.length){\n      if (l[i] + l[j] === 0) return true;\n      j++;\n    }\n    i++;\n  }\n  return false;\n}"
      ],
      [
        "const isPalindrome = (text) => {\n  let i = 0;\n  for (; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}"
      ],
      [
        "const modp = (n, p) => {\n  var ret = 1;\n  {\n      let i = 0;\n      while(i < n){\n          ret = (2 * ret) % p;\n          i++;\n      }\n  }\n  return ret;\n}"
      ],
      [
        "const largestPrimeFactor = (n) => {\n  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    {\n        let i = 2;\n        for (; i < k - 1; i++)\n          if (k % i == 0)\n            return false;\n    }\n    return true;\n  };\n\n  let factor = 2;\n  while (factor * factor <= n) {\n    if (n % factor === 0 && isPrime(factor)) {\n      n /= factor;\n    } else {\n      factor += 1;\n    }\n  }\n  return n;\n};"
      ],
      [
        "const smallestChange = (arr) => {\n  var ans = 0;\n  let i = 0;\n  while (i < Math.floor(arr.length / 2)) {\n    if (arr[i] !== arr[arr.length - i - 1]) {\n      ans++;\n    }\n    i++;\n  }\n  return ans;\n}"
      ],
      [
        "const isMultiplyPrime = (a) => {\n  var isPrime = function (n) {\n    let j = 2;\n    for (; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i * j * k === a) return true;\n      }\n    }\n  }\n  return false;\n}"
      ],
      [
        "const numericalLetterGrade = (grades) => {\n  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}"
      ],
      [
        "const antiShuffle = (s) => {\n  let arr = s.split(/\\s/);\n  {\n    let i = 0;\n    while (i < arr.length) {\n      {\n        let j = 0;\n        while (j < arr[i].length) {\n          let ind = j;\n          {\n            let k = j + 1;\n            while (k < arr[i].length) {\n              if (arr[i][k].charCodeAt(0) < arr[i][ind].charCodeAt(0)) {\n                ind = k;\n              }\n              k++;\n            }\n            arr[i] = arr[i].split('').sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0)).join('');\n            j = ind + 1;\n          }\n        }\n        i++;\n      }\n    }\n    return arr.join(' ');\n  }\n};"
      ],
      [
        "const encrypt = (s) => {\n  let t = ''\n  {\n      let i = 0;\n      while(i < s.length){\n        let p = s[i].charCodeAt() + 4\n        if (p > 122) { p -= 26; }\n        t += String.fromCharCode(p);\n        i++;\n      }\n  }\n  return t;\n}"
      ],
      [
        "const nextSmallest = (lst) => {\n  let arr = lst\n  {\n      let j = 0;\n      for (; j < arr.length; j++) {\n      let ind = j\n      {\n          let k = j + 1;\n          for (; k < arr.length; k++) {\n              if (arr[k] < arr[ind]) {\n                ind = k\n              }\n            }\n      }\n      // Move the smallest element found to the front\n      if (ind !== j) {\n        [arr[j], arr[ind]] = [arr[ind], arr[j]];\n      }\n    }\n  }\n\n  // Remove duplicates and find the second smallest element\n  let uniqueArr = [...new Set(arr)];\n  if (uniqueArr.length < 2) return null;\n  uniqueArr.sort((a, b) => a - b);\n  return uniqueArr[1];\n}"
      ],
      [
        "const encode = (message) => {\n  let t = '';\n  let i = 0;\n  while(i < message.length){\n    let p = message[i].charCodeAt();\n    if (p > 96) { // lowercase letter\n      p -= 32; // swap case\n      t += String.fromCharCode(p);\n      if ('aeiou'.includes(String.fromCharCode(p))) {\n        p = 'bcdefgh'.indexOf(String.fromCharCode(p)) + 97;\n        t += String.fromCharCode(p);\n      } else {\n        t += String.fromCharCode(p);\n      }\n    } else { // uppercase letter\n      p -= 32; // swap case\n      t += String.fromCharCode(p);\n      if ('AEIOU'.includes(String.fromCharCode(p))) {\n        p = 'BCDFGH'.indexOf(String.fromCharCode(p)) + 65;\n        t += String.fromCharCode(p);\n      } else {\n        t += String.fromCharCode(p);\n      }\n    }\n    i++;\n  }\n  return t;\n}"
      ],
      [
        "const skjkasdkd = (lst) => {\n  let t = 0\n  {\n      let i = 0;\n      for (; i < lst.length; i++) {\n      let p = 1\n      {\n          let j = 2;\n          for (; j * j <= lst[i]; j++) {\n              if (lst[i] % j == 0) { p = 0; break }\n            }\n      }\n      if (p && lst[i] > t) t = lst[i];\n    }\n  }\n\n  if (t === 0) return 0;\n\n  let sum = 0;\n  while (t > 0) {\n    sum += t % 10;\n    t = Math.floor(t / 10);\n  }\n\n  return sum;\n}"
      ],
      [
        "const countUpTo = (n) => {\n  let t = [];\n  {\n    let i = 2;\n    while (i < n) {\n      let p = 1;\n      {\n        let j = 2;\n        while (j * j <= i) {\n          if (i % j === 0) {\n            p = 0;\n            break;\n          }\n          j++;\n        }\n      }\n      if (p) {\n        t.push(i);\n      }\n      i++;\n    }\n  }\n  return t;\n}"
      ],
      [
        "const countUpper = (s) => {\n  let p = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      p++;\n    }\n  }\n  return p;\n}"
      ],
      [
        "const makeAPile = (n) => {\n  let t = []\n  {\n      let i = n;\n      for (; i < n * 3; i += 2) {\n          t.push(i)\n      }\n      return t\n  }\n}"
      ],
      [
        "const chooseNum = (x, y) => {\n  let i = y;\n  while(i >= x){\n    if (i % 2 == 0) { return i; }\n    i--;\n  }\n  return -1;\n}"
      ],
      [
        "const uniqueDigits = (x) => {\n  let p = []\n  {\n      let i = 0;\n      while(i < x.length){\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = Math.floor(h / 10);\n    }\n    if (boo === 1) {\n      p.push(x[i]);\n    }\n    i++;\n  }\n  p.sort((a, b) => a - b);\n  return p;\n}"
      ],
      [
        "const byLength = (arr) => {\n  p = []\n  {\n      let i = 0;\n      for (; i < arr.length; i++) {\n      if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind !== j) {\n      let temp = p[j]\n      p[j] = p[ind]\n      p[ind] = temp\n    }\n  }\n  p.reverse()\n  const digitNames = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  return p.map(digit => digitNames[digit - 1])\n}"
      ],
      [
        "const f = (n) => {\n  let f = 1\n  let p = 0\n  let k = []\n  {\n      let i = 1;\n      for (; i <= n; i++) {\n          if (i % 2 === 0) {\n              f = 1;\n              for (let j = 1; j <= i; j++) {\n                  f *= j;\n              }\n              k.push(f);\n          } else {\n              p += i;\n              k.push(p);\n          }\n      }\n  }\n  return k;\n}"
      ],
      [
        "const countNums = (arr) => {\n  let p = 0\n  {\n      let i = 0;\n      for (; i < arr.length; i++) {\n      let h = arr[i]\n      if (h > 0) {\n        p++;\n        continue;\n      }\n      if (h === 0) {\n        continue;\n      }\n      let sum = 0;\n      let num = Math.abs(h);\n      while (num > 0) {\n        sum += num % 10;\n        num = Math.floor(num / 10);\n      }\n      if (sum > 0) {\n        p++;\n      }\n    }\n  }\n  return p;\n}"
      ],
      [
        "const exchange = (lst1, lst2) => {\n  let k = lst1.length\n  let t = 0\n  {\n      let i = 0;\n      while(i < lst1.length){\n    if (lst1[i] % 2 == 0) { t++ }\n        i++;\n      }\n  }\n\n  if (t === k) return \"YES\";\n  \n  for (let j = 0; j < lst2.length; j++) {\n    if (lst2[j] % 2 === 0) {\n      t++;\n    }\n  }\n\n  if (t >= k) return \"YES\";\n  else return \"NO\";\n}"
      ],
      [
        "const histogram = (test) => {\n  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (let m in t) {\n    if (!(t[m] in d)) {\n      d[t[m]] = 1\n    } else {\n      d[t[m]]++\n    }\n  }\n\n  let maxCount = Math.max(...Object.values(d))\n  let result = {}\n  for (let key in d) {\n    if (d[key] === maxCount) {\n      result[key] = d[key]\n    }\n  }\n\n  return result\n}"
      ],
      [
        "const reverseDelete = (s, c) => {\n  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    {\n        let j = 0;\n        while(j < c.length){\n      if (s[i] == c[j]) {\n        y = 0\n      }\n            j++;\n        }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let reversedT = t.split('').reverse().join('')\n  let isPalindrome = t === reversedT\n  return [t, isPalindrome]\n}"
      ],
      [
        "const oddCount = (lst) => {\n  let d = []\n  {\n      let i = 0;\n      for (; i < lst.length; i++) {\n      let p = 0;\n      let h = lst[i].length\n      {\n          let j = 0;\n          for (; j < h; j++) {\n              if (parseInt(lst[i][j]) % 2 !== 0) {\n                  p++;\n              }\n          }\n          d.push(`the number of odd elements ${p}n the str${p}ng ${p} of the ${p}nput.`);\n      }\n  }\n  return d;\n}"
      ],
      [
        "const minSubArraySum = (nums) => {\n  let min = nums[0];\n  let i = 0;\n  while (i < nums.length) {\n    let j = i + 1;\n    while (j <= nums.length) {\n      let s = 0;\n      let k = i;\n      while (k < j) {\n        s += nums[k];\n        k++;\n      }\n      if (s < min) {\n        min = s;\n      }\n      j++;\n    }\n    i++;\n  }\n  return min;\n};"
      ],
      [
        "const maxFill = (grid, capacity) => {\n  let p = 0\n  {\n      let i = 0;\n      while(i < grid.length){\n    let m = 0\n    {\n        let j = 0;\n        while(j < grid[i].length){\n      if (grid[i][j] == 1) { \n          m++; \n          if (m > capacity) {\n              p += Math.ceil(m / capacity);\n              m = m % capacity;\n          } else if (m === capacity) {\n              p++;\n              m = 0;\n          }\n      }\n          j++;\n        }\n        if (m > 0) {\n            p += Math.ceil(m / capacity);\n        }\n    }\n    i++;\n  }\n  return p;\n}"
      ],
      [
        "const sortArray = (arr) => {\n  let p = arr;\n  {\n    let j = 0;\n    for (; j < p.length; j++) {\n      let ind = j;\n      {\n        let k = j + 1;\n        for (; k < p.length; k++) {\n          let w1 = p[ind].toString(2);\n          let f1 = 0;\n          {\n            let u = 0;\n            for (; u < w1.length; u++) {\n              if (w1[u] == '1') { f1++; }\n            }\n          }\n          let w2 = p[k].toString(2);\n          let f2 = 0;\n          {\n            let v = 0;\n            for (; v < w2.length; v++) {\n              if (w2[v] == '1') { f2++; }\n            }\n          }\n          if (f1 > f2 || (f1 === f2 && p[ind] > p[k])) {\n            let temp = p[ind];\n            p[ind] = p[k];\n            p[k] = temp;\n          }\n        }\n      }\n    }\n  }\n  return p;\n};"
      ],
      [
        "const selectWords = (s, n) => {\n  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  {\n      let i = 0;\n      while(i < t.length){\n          let l = 0\n          {\n              let j = 0;\n              while(j < t[i].length) {\n                  if ('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'.includes(t[i][j])) {\n                      l++\n                  }\n                  if (l == n && t[i].length == l) {\n                      k.push(t[i])\n                      break\n                  }\n                  j++\n              }\n          }\n          i++\n      }\n  }\n  return k\n}"
      ],
      [
        "const matchParens = (lst) => {\n  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (!(w1[i] == '(')) { y-- }\n    else { y++ }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n    if (i == w1.length - 1 && y >= 0) {\n      return 'Yes'\n    }\n  }\n  w1 = lst[1] + lst[0]\n  y = 0\n  for (let i = 0; i < w1.length; i++) {\n    if (!(w1[i] == '(')) { y-- }\n    else { y++ }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n    if (i == w1.length - 1 && y >= 0) {\n      return 'Yes'\n    }\n  }\n  return 'No'\n}"
      ],
      [
        "const maximum = (arr, k) => {\n  let p = arr\n  {\n      let j = 0;\n      for (; j < p.length; j++) {\n      let ind = j\n      {\n          let k = j + 1;\n          for (; k < p.length; k++) {\n              if (p[k] < p[ind]) {\n                ind = k\n              }\n        }\n      }\n      p[j] = p[ind]\n    }\n  }\n  p.sort((a, b) => b - a)\n  return p.slice(0, k)\n}"
      ],
      [
        "const addElements = (arr, k) => {\n  let p = 0\n  {\n      let i = 0;\n      while(i < k){\n        if (arr[i] < 100 && arr[i] > -100) {\n          p += arr[i]\n        }\n        i++;\n      }\n  }\n  return p\n}"
      ],
      [
        "const getOddCollatz = (n) => {\n  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    {\n        let i = 0;\n        for (; i < p.length; i++) {\n          if (t == p[i]) {\n            u = 1\n            break;\n          }\n        }\n    }\n    if (u == 1) { break }\n\n    p.push(t)\n    if (t % 2 === 0) {\n      t = t / 2\n    } else {\n      t = 3 * t + 1\n    }\n\n    if (t % 2 !== 0) {\n      p.push(t)\n    }\n  }\n\n  p = p.filter(num => num % 2 !== 0)\n  p.sort((a, b) => a - b)\n  return p\n}"
      ],
      [
        "const minPath = (grid, k) => {\n  let m = 0\n  let n = 0\n  {\n      let i = 0;\n      while(i < grid.length){\n    {\n        let j = 0;\n        while(j < grid.length){\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n            i++;\n      }\n          j++;\n        }\n    }\n  }\n\n  const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n  const visited = new Set();\n  const queue = [];\n  queue.push([m, n, [grid[m][n]]]);\n  visited.add(`${m},${n}`);\n\n  while (queue.length > 0 && k > 1) {\n    const size = queue.length;\n    for (let i = 0; i < size; i++) {\n      const [x, y, path] = queue.shift();\n      for (const [dx, dy] of directions) {\n        const newX = x + dx;\n        const newY = y + dy;\n        if (newX >= 0 && newX < grid.length && newY >= 0 && newY < grid.length && !visited.has(`${newX},${newY}`)) {\n          visited.add(`${newX},${newY}`);\n          queue.push([newX, newY, [...path, grid[newX][newY]]]);\n        }\n      }\n    }\n    k--;\n  }\n\n  return queue[0][2];\n};"
      ],
      [
        "const isNested = (string) => {\n  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (!(string[i] == '[')) {\n      closing_bracket_index1.push(i)\n    }\n    else {\n      opening_bracket_index.push(i)\n    }\n    if (opening_bracket_index.length > 0 && closing_bracket_index1.length > 0) {\n      let openIndex = opening_bracket_index[opening_bracket_index.length - 1]\n      let closeIndex = closing_bracket_index1[closing_bracket_index1.length - 1]\n      if (openIndex < closeIndex) {\n        return true\n      }\n    }\n  }\n  return false\n}"
      ],
      [
        "const canArrange = (arr) => {\n  if (arr.length == 0) { return -1 }\n  {\n      let i = arr.length - 1;\n      while(i > 0){\n    if (arr[i] < arr[i - 1]) { return i; } else { i--; }\n      }\n      return -1;\n  }\n}"
      ],
      [
        "const largestSmallestIntegers = (lst) => {\n  let a = Infinity\n  let b = -Infinity\n  {\n      let i = 0;\n      while(i < lst.length){\n          if (lst[i] > 0 && lst[i] < b) { b = lst[i]; }\n          else if (lst[i] < 0 && lst[i] > a) { a = lst[i]; }\n          i++;\n      }\n  }\n  a = a === Infinity ? null : a\n  b = b === -Infinity ? null : b\n  return [a, b]\n}"
      ],
      [
        "const fixSpaces = (text) => {\n  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (!(text[i] == ' ')) {\n      if (c > 0) {\n        if (c == 1) { t += '_' }\n        if (c > 2) { t += '-' }\n        c = 0\n      }\n      t += text[i]\n    } else {\n      c++\n    }\n  }\n  if (c > 2) { t += '-' }\n  return t\n}"
      ],
      [
        "const sumSquares = (lst) => {\n  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n  }\n  return y\n}"
      ],
      [
        "{\n      let j = 0;\n      for (; j < t.length; j++) {\n          let len = t[j].length;\n          let u = 1\n          if (len == 1 || len == 0) { continue }\n          for (let k = 2; k * k <= len; k++) {\n              if (len % k === 0) {\n                  u = 0;\n                  break;\n              }\n          }\n          if (u && len > 1) {\n              p += t[j] + ' ';\n          }\n      }\n      return p.trim();\n  }"
      ],
      [
        "const orderByPoints = (nums) => {\n  let p = nums;\n  {\n    let j = p.length - 2;\n    for (; j >= 0; j--) {\n      {\n        let k = 0;\n        for (; k <= j; k++) {\n          let m = 0;\n          let n = 0;\n          let h = p[k];\n          let d = p[k + 1];\n          let y = 1;\n          let u = 1;\n          if (h < 0) { y = -1; h = -h; }\n          if (d < 0) { u = -1; d = -d; }\n\n          // Calculate the sum of digits for both numbers\n          while (h > 0) {\n            m += h % 10;\n            h = Math.floor(h / 10);\n          }\n          while (d > 0) {\n            n += d % 10;\n            d = Math.floor(d / 10);\n          }\n\n          // Compare sums and indices if sums are equal\n          if ((m !== n) || (k !== p.indexOf(p[k]))) {\n            if (m > n || (m === n && p.indexOf(p[k]) > k + 1)) {\n              [p[k], p[k + 1]] = [p[k + 1], p[k]];\n            }\n          }\n        }\n      }\n    }\n    // Sort the array using the calculated sums and indices\n    return p.sort((a, b) => {\n      let sumA = 0;\n      let sumB = 0;\n      let indexA = nums.indexOf(a);\n      let indexB = nums.indexOf(b);\n\n      while (a > 0) {\n        sumA += a % 10;\n        a = Math.floor(a / 10);\n      }\n      while (b > 0) {\n        sumB += b % 10;\n        b = Math.floor(b / 10);\n      }\n\n      if (sumA === sumB) {\n        return indexA - indexB;\n      }\n      return sumA - sumB;\n    });\n  }\n}"
      ],
      [
        "const specialFilter = (nums) => {\n  let p = 0;\n  {\n    let i = 0;\n    while (i < nums.length) {\n      if (nums[i] < 10) {\n        i++;\n        continue;\n      }\n      let y = nums[i].toString();\n      let firstDigit = parseInt(y.charAt(0));\n      let lastDigit = parseInt(y.charAt(y.length - 1));\n      if (firstDigit % 2 !== 0 && lastDigit % 2 !== 0) {\n        p++;\n      }\n      i++;\n    }\n  }\n  return p;\n}"
      ],
      [
        "const getMaxTriples = (n) => {\n  let y = []\n  {\n      let i = 1;\n      while(i <= n){\n    y.push(i * i - i + 1)\n        i++;\n      }\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 === 0) {\n          u++\n        }\n      }\n    }\n  }\n  return u\n}"
      ],
      [
        "const bf = (planet1, planet2) => {\n  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  {\n      let i = 0;\n      for (; i < 8; i++) {\n          if (y[i] == planet1) { lo = i }\n      }\n  }\n  for (let i = 0; i < 8; i++) {\n      if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1) {\n      return [];\n  }\n  if (lo > hi) {\n      [lo, hi] = [hi, lo];\n  }\n  for (let i = lo + 1; i < hi; i++) {\n      u.push(y[i]);\n  }\n  return u;\n}"
      ],
      [
        "const sortedListSum = (lst) => {\n  let p = [];\n  {\n    let i = 0;\n    for (; i < lst.length; i++) {\n      if (lst[i].length % 2 == 0) {\n        p.push(lst[i]);\n      }\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0;\n      if (p[k].length > p[k + 1].length) {\n        f = 1;\n      }\n      if (p[k].length == p[k + 1].length) {\n        if (p[k] > p[k + 1]) {\n          f = 1;\n        }\n      }\n      if (f === 1) {\n        [p[k], p[k + 1]] = [p[k + 1], p[k]];\n      }\n    }\n  }\n  return p;\n};"
      ],
      [
        "const strongestExtension = (class_name, extensions) => {\n  let u = 0\n  let s = -Infinity\n  {\n      let i = extensions.length - 1;\n      while(i >= 0){\n    let y = 0\n    {\n        let j = 0;\n        while(j < extensions[i].length){\n      let k = extensions[i][j].charCodeAt()\n          if (k >= 65 && k <= 90) {\n            u++\n          } else if (k >= 97 && k <= 122) {\n            y++\n          }\n          j++;\n        }\n        let strength = u - y\n        if (strength > s) {\n          s = strength\n          u = 0\n        } else if (strength === s) {\n          u = 0\n        }\n        i--;\n      }\n    }\n  }\n  let strongestExtension = extensions.find(ext => (ext.charCodeAt(0).toString(36) + ext.slice(1)).localeCompare(class_name + u.toString(36) + ext) === 0)\n  return class_name + '.' + strongestExtension\n}"
      ],
      [
        "const cycpatternCheck = (a, b) => {\n  let l = b.length\n  let pat = b + b\n  {\n      let i = 0;\n      while(i < a.length - l + 1){\n    {\n        let j = 0;\n        while(j < l + 1){\n      let y = 1\n      {\n          let k = 0;\n          while(k < l){\n              if(a[i + k] !== pat[j + k]) break\n              k++;\n          }\n          if(k === l) return true\n          j++;\n      }\n          i++;\n        }\n    }\n  }\n  return false\n}"
      ],
      [
        "const findMax = (words) => {\n  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  {\n      let i = 0;\n      while(i < words.length){\n    let p = 0\n    {\n        let j = 0;\n        while(j < words[i].length){\n      let y = 1\n      if (!u.includes(words[i][j])) {\n          p++\n          u.includes(words[i][j]) || u.push(words[i][j])\n      }\n      j++;\n        }\n        if (p > s) {\n          s = p\n          u = [...new Set(words[i])]\n        } else if (p === s && words[i] < u.join('')) {\n          u = [...new Set(words[i])]\n        }\n        i++;\n    }\n  }\n  return u.join('')\n}"
      ],
      [
        "const doAlgebra = (operator, operand) => {\n  while (operator.length > 0) {\n    let y = 0\n    {\n        let i = operator.length - 1;\n        for (; i >= 0; i--) {\n          if (operator[i] == '**') {\n            let u = operand[i]\n            while (operand[i + 1] > 1) {\n              operand[i + 1]--;\n              operand[i] *= u;\n            }\n            operand.splice(i + 1, 1)\n            operator.splice(i, 1)\n            y = 1;\n            break;\n          }\n        }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1];\n        operand.splice(i + 1, 1);\n        operator.splice(i, 1);\n        continue;\n      }\n    }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '/') {\n        operand[i] = Math.floor(operand[i] / operand[i + 1]);\n        operand.splice(i + 1, 1);\n        operator.splice(i, 1);\n        continue;\n      }\n    }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1];\n        operand.splice(i + 1, 1);\n        operator.splice(i, 1);\n        continue;\n      }\n    }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '-') {\n        operand[i] -= operand[i + 1];\n        operand.splice(i + 1, 1);\n        operator.splice(i, 1);\n        continue;\n      }\n    }\n  }\n  return operand[0];\n}"
      ],
      [
        "const solve = (s) => {\n  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (!(y >= 65 && y <= 90)) if (y >= 97 && y <= 122) {\n      y -= 32\n      t = 1\n    } else if (!(/[a-zA-Z]/.test(s))) {\n      p = s.split('').reverse().join('')\n      break\n    } else {\n      t = 1\n    }\n    p += String.fromCharCode(y)\n  }\n  if (!t) p = s.split('').reverse().join('')\n  return p\n}"
      ]
    ],
    "variance": 0.0,
    "stddev": 0.0
  }
]