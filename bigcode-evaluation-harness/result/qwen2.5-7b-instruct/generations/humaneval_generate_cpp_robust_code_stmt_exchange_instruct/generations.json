[["#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\n\nstring sort_numbers(string numbers){\n    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    {\n        int i=0;\n        while(i<10){count[i]=0;        i++;\n        }\n    }\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for(int i=0;i<numbers.length();i++){\n        if(numbers[i]!=' '){\n            current+=numbers[i];\n        }else{\n            count[tonum[current]]++;\n            current=\"\";\n        }\n    }\n    for(int i=0;i<10;i++){\n        for(int j=0;j<count[i];j++){\n            out+=numto[i]+\" \";\n        }\n    }\n    out.pop_back(); // Remove the last space\n    return out;\n}\n"], ["#include<stdio.h>\nusing namespace std;\nint largest_divisor(int n){\n    int i=2;\n    while(i*i<=n){\n        if (n%i==0) return  n/i;        \n        i++;\n    }\n    return 1; // If no divisor found, return 1 (since 1 is a divisor of all numbers)\n}\n"], ["#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x){\n    /*\n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \n    */\n    double sum=0;\n    int i;\n    {\n        i=0;\n        for (;i<xs.size();i++)\n        {\n            sum+=xs[i]*pow(x,i);\n        }\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs){\n    /*\n    xs are coefficients of a polynomial. find_zero find x such that poly(x) = 0. find_zero returns only only zero point, even if there are many. \n    Moreover, find_zero only takes list xs having even number of coefficients and largest non zero coefficient as it guarantees a solution.\n    */\n    double ans=0;\n    double value;\n    value=poly(xs,ans);\n    while (abs(value)>1e-6)\n    {\n        double driv=0;\n        for (int i = 1; i < xs.size(); ++i)\n        {\n            driv += i * xs[i] * pow(ans, i - 1);\n        }\n        ans -= value / driv;\n        value = poly(xs, ans);\n    }\n    return ans;\n}\n"], ["#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> sort_third(vector<int> l){\n    vector<int> third={};\n    int i;\n    i=0;\n    while(i*3<l.size()){\n        third.push_back(l[i*3]);\n        i++;\n    }\n    sort(third.begin(),third.end());\n    i=0;\n    for(int j=0; j<l.size(); j++){\n        if(j % 3 == 0){\n            l[j] = third[i++];\n        }\n    }\n    return l;\n}\n"], ["#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l){\n  float max=-10000;\n  {\n      int i=0;\n      for (;i<l.size();i++)\n    if (max<l[i]) max=l[i];\n  }\n  return max;\n}\n"], ["#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l){\n    vector<float> out={};\n    vector<float> even={};\n    {\n        int i=0;\n        for (;i*2<l.size();i++)\n            even.push_back(l[i*2]);\n    }\n    sort(even.begin(),even.end());\n    int evenIndex = 0;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            out.push_back(even[evenIndex++]);\n        } else {\n            out.push_back(l[i]);\n        }\n    }\n    return out;\n}\n"], ["#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_cyclic(string s){ \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    {\n        i=0;\n        for (;i*3<l;i++)\n        {\n            //cycle elements in each group. Unless group has fewer elements than 3.\n            x=s.substr(i*3,3);\n            if (x.length()==3) x=x.substr(1)+x[0];\n            output=output+x;\n        }\n    }\n    return output;\n}\n\nstring decode_cyclic(string s){ \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        //reverse the cycling process\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x[x.length()-1]+x.substr(0,x.length()-1);\n        output=output+x;\n    }\n    return output;\n}\n"], ["#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l){\n    int i = 0;\n    while(i < l.size()){\n        l[i] += 1;\n        i++;\n    }\n    return l;\n}\n"], ["#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    {\n        i=0;\n        for (;i<s.length();i++)\n        {\n            int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n            out=out+(char)w;\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n"], ["#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_threshold(vector<int>l, int t){\n    int i=0;\n    for (;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}\n"], ["#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nbool same_chars(string s0,string s1){\n    {\n        int i=0;\n        while(i<s0.length()){\n            if (find(s1.begin(),s1.end(),s0[i]) == s1.end())\n                return false;\n            i++;\n        }\n    }\n\n    // Check if both strings have the same set of unique characters\n    sort(s0.begin(), s0.end());\n    sort(s1.begin(), s1.end());\n    return s0 == s1;\n}\n"], ["#include<stdio.h>\nusing namespace std;\n\nint largest_prime_factor(int n){\n    int i=2;\n    while(i*i<=n){\n        while (n%i==0 and n>i)  n=n/i;\n        i++;\n    }\n    return n;\n}\n"], ["#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n    int num1 = 0, num2 = 0, i;\n\n    for (i = 0; i < lst1.size(); ++i) {\n        num1 += lst1[i].length();\n    }\n\n    for (i = 0; i < lst2.size(); ++i) {\n        num2 += lst2[i].length();\n    }\n\n    if (num1 <= num2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"], ["#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool iscuber(int a){\n    int i=0;\n    for (;i*i*i<=abs(a);i++)\n        if (i*i*i==abs(a)) return true;\n    return false;\n}\n"], ["#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    {\n        int i=0;\n        for (;i<str.length();i++)\n            sum+=str[i]-48;\n    }\n    while(sum > 0) {\n        bi = to_string(sum % 2) + bi;\n        sum /= 2;\n    }\n    return bi;\n}\n"], ["#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            {\n                int j=2;\n                for (;j*j<=lst[i];j++)\n                    if (lst[i]%j==0) prime=false;\n            }\n            if (prime && lst[i] > largest) {\n                largest = lst[i];\n            }\n        }\n    if (largest == 0) return 0; // No prime number found\n    int sum = 0;\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n    return sum;\n}\n"], ["#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1,vector<int> lst2){\n    int num=0;\n    {\n        int i=0;\n        for (;i<lst1.size();i++)\n            if (lst1[i]%2==0) num+=1;\n    }\n    int j=0;\n    for (;j<lst2.size();j++)\n        if (lst2[j]%2==0 && num<lst1.size()) num+=1;\n    if (num == lst1.size())\n        return \"YES\";\n    else\n        return \"NO\";\n}\n"], ["#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> reverse_delete(string s,string c){\n    string n=\"\";\n    {\n        int i=0;\n        while(i<s.length()){\n            if (find(c.begin(),c.end(),s[i]) == c.end())\n                n += s[i];\n            i++;\n        }\n    }\n    // Check if the resulting string is a palindrome\n    string reversed_n = n;\n    reverse(reversed_n.begin(), reversed_n.end());\n    bool is_palindrome = (n == reversed_n);\n    \n    return {n, is_palindrome ? \"True\" : \"False\"};\n}\n"], ["#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool valid_date(string date){\n    int mm,dd,yy,i;\n    if (date.length()!=10) return false;\n    {\n        int i=0;\n        while(i<10){if (i==2 || i==5)\n        {\n            if (date[i]!='-') return false;\n                i++;\n        }\n        else{\n            char c = date[i];\n            if (!isdigit(c)) return false;\n            i++;\n        }\n    }\n    if (i != 10) return false;\n\n    // Parsing mm\n    mm = stoi(date.substr(0,2));\n    if (mm < 1 || mm > 12) return false;\n\n    // Parsing dd\n    dd = stoi(date.substr(3,2));\n    if (mm == 2 && dd < 1 || dd > 29) return false;\n    else if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && (dd < 1 || dd > 30)) return false;\n    else if ((mm == 1 || mm == 3 || mm == 5 || mm == 7 || mm == 8 || mm == 10 || mm == 12) && (dd < 1 || dd > 31)) return false;\n\n    // Parsing yy\n    yy = stoi(date.substr(6,4));\n\n    return true;\n}\n"], ["#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> split_words(string txt){\n    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        i=0;\n        while(i<txt.length()){\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n                i++;\n            }\n            else{\n                current+=txt[i];\n                i++;\n            }\n        }\n        if (current.length()>0)out.push_back(current);\n    }\n    else if (find(txt.begin(),txt.end(','))!=txt.end())\n    {\n        stringstream ss(txt);\n        string temp;\n        while(getline(ss,temp,','))\n        {\n            if (temp.length()>0)out.push_back(temp);\n        }\n    }\n    else\n    {\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c) && (c - 'a') % 2 == 1) {\n                count++;\n            }\n        }\n        out = {to_string(count)};\n    }\n    return out;\n}\n"], ["#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k){\n    int i, j, x, y, min;\n    {\n        i = 0;\n        for (; i < grid.size(); i++)\n        {\n            j = 0;\n            for (; j < grid[i].size(); j++)\n            {\n                if (grid[i][j] == 1) {\n                    x = i;\n                    y = j;\n                }\n            }\n        }\n    }\n\n    // Priority queue to store paths based on lexicographical order\n    struct Path {\n        vector<int> path;\n        bool operator<(const Path& other) const {\n            for (int i = 0; i < k && i < path.size() && i < other.path.size(); ++i) {\n                if (path[i] != other.path[i]) return path[i] > other.path[i];\n            }\n            return path.size() > other.path.size();\n        }\n    };\n\n    priority_queue<Path, vector<Path>, greater<Path>> pq;\n    vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));\n    visited[x][y] = true;\n    pq.push({{grid[x][y]}, x, y});\n\n    while (!pq.empty()) {\n        Path currPath = pq.top();\n        pq.pop();\n\n        if (currPath.path.size() == k) {\n            return currPath.path;\n        }\n\n        // Explore neighbors\n        vector<pair<int, int>> neighbors = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        for (auto& dir : neighbors) {\n            int newX = currPath.x + dir.first;\n            int newY = currPath.y + dir.second;\n            if (newX >= 0 && newX < grid.size() && newY >= 0 && newY < grid[0].size() && !visited[newX][newY]) {\n                visited[newX][newY] = true;\n                pq.push({currPath.path, newX, newY});\n            }\n        }\n    }\n\n    return {};\n}\n"], ["#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b){\n    double numa, numb;\n    boost::any out;\n    \n    if (a.type() == typeid(string))\n    {\n        string s;\n        s = boost::any_cast<string>(a);\n        if (find(s.begin(), s.end(), ',') != s.end())\n        {\n            int i = 0;\n            for (; i < s.length(); i++)\n                if (s[i] == ',') s = s.substr(0, i) + '.' + s.substr(i + 1);\n        }\n        numa = atof(s.c_str());\n    }\n    else\n    {\n        numa = boost::any_cast<double>(a);\n    }\n\n    if (b.type() == typeid(string))\n    {\n        string t;\n        t = boost::any_cast<string>(b);\n        if (find(t.begin(), t.end(), ',') != t.end())\n        {\n            int j = 0;\n            for (; j < t.length(); j++)\n                if (t[j] == ',') t = t.substr(0, j) + '.' + t.substr(j + 1);\n        }\n        numb = atof(t.c_str());\n    }\n    else\n    {\n        numb = boost::any_cast<double>(b);\n    }\n\n    if (numa > numb)\n    {\n        out = a;\n    }\n    else if (numb > numa)\n    {\n        out = b;\n    }\n    else\n    {\n        out = \"None\";\n    }\n\n    return out;\n}\n"], ["#include<stdio.h>\n#include<vector>\nusing namespace std;\nint sum_squares(vector<int> lst){\n    int sum=0;\n    {\n        int i=0;\n        while(i<lst.size()){\n            if (i%3==0) sum+=lst[i]*lst[i];\n            else if (i%4==0 && i%3!=0) sum+=lst[i]*lst[i]*lst[i];\n            i++;\n        }\n    }\n    return sum;\n}\n"], ["#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> order_by_points(vector<int> nums){\n    vector<int> sumdigit = {};\n    for (int i = 0; i < nums.size(); i++)\n    {\n        string w = to_string(abs(nums[i]));\n        int sum = 0;\n        {\n            int j = 1;\n            for (; j < w.length(); j++)\n                sum += w[j] - 48;\n        }\n        if (nums[i] > 0) sum += w[0] - 48;\n        sumdigit.push_back(sum);\n    }\n\n    for (int i = 0; i < nums.size(); i++)\n    {\n        for (int j = 0; j < nums.size() - i - 1; j++)\n        {\n            if (sumdigit[j] > sumdigit[j + 1] || (sumdigit[j] == sumdigit[j + 1] && j > nums[j + 1]))\n            {\n                swap(sumdigit[j], sumdigit[j + 1]);\n                swap(nums[j], nums[j + 1]);\n            }\n        }\n    }\n\n    return nums;\n}\n"], ["#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_matrix_triples(int n){\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    {\n        int i=1;\n        while(i<=n){\n            a.push_back((i*i-i+1)%3);\n            sum.push_back(sum[sum.size()-1]);\n            sum[i][a[i-1]]+=1;\n            i++;\n        }\n    }\n\n    int count = 0;\n    for(int i=1; i<n-1; i++){\n        for(int j=i+1; j<n-1; j++){\n            int mod_val = (2 - a[i] - a[j]) % 3;\n            if(mod_val >= 0 && sum[n][mod_val] > 0){\n                count += sum[n][mod_val];\n            }\n        }\n    }\n\n    return count;\n}\n"], ["#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst){\n    vector<string> out = {};\n    {\n        int i = 0;\n        while (i < lst.size()) {\n            if (lst[i].length() % 2 == 0) {\n                out.push_back(lst[i]);\n            }\n            i++;\n        }\n    }\n    sort(out.begin(), out.end(), [](const string &a, const string &b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n    return out;\n}\n"], ["#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    vector<int> num = {};\n    vector<int> posto = {};\n    {\n        int i = 0;\n        for (; i < operand.size(); i++)\n            posto.push_back(i);\n    }\n    {\n        int i = 0;\n        for (; i < operato.size(); i++) {\n            if (operato[i] == \"**\") {\n                while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n                while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n                operand[posto[i]] = pow(operand[posto[i]], operand[posto[i + 1]]);\n                posto[i + 1] = posto[i];\n            }\n        }\n    }\n    for (int i = 0; i < operato.size(); i++) {\n        if (operato[i] == \"+\") {\n            num.push_back(operand[posto[i]]);\n            num.push_back(operand[posto[i + 1]]);\n            sort(num.begin(), num.end());\n            operand[posto[i]] = num[0] + num[1];\n            num.clear();\n        } else if (operato[i] == \"-\") {\n            num.push_back(operand[posto[i]]);\n            num.push_back(operand[posto[i + 1]]);\n            sort(num.begin(), num.end());\n            operand[posto[i]] = num[0] - num[1];\n            num.clear();\n        } else if (operato[i] == \"*\") {\n            operand[posto[i]] = operand[posto[i]] * operand[posto[i + 1]];\n        } else if (operato[i] == \"//\") {\n            operand[posto[i]] = operand[posto[i]] / operand[posto[i + 1]];\n        }\n    }\n    return operand[posto[0]];\n}\n"]]