[
  {
    "name": {
      "name": "full_level_robustness",
      "split": "test"
    },
    "count": 13,
    "generations": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n\n#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    map<string, int> tonum = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n    map<int, string> numto = {{0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, {4, \"four\"}, {5, \"five\"}, {6, \"six\"}, {7, \"seven\"}, {8, \"eight\"}, {9, \"nine\"}};\n    int count[10];\n    {\n        int i = 0;\n        while (i < 10) {\n            count[i] = 0;\n            i++;\n        }\n    }\n\n    string out = \"\", current = \"\";\n    if (numbers.length() > 0) numbers = numbers + \" \";\n\n    for (int i = 0; i < 10; i++) {\n        if (tonum.find(numbers[i]) != tonum.end()) {\n            count[i]++;\n            out += numto[i];\n        } else {\n            out += numbers[i];\n        }\n    }\n\n    sort(out.begin(), out.end(), [](const string& a, const string& b) {\n        return tonum[a] < tonum[b];\n    });\n\n    return out;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    {\n        int i = 2;\n        while (i * i <= n) {\n            if (n % i == 0) {\n                return n / i;\n            }\n            i++;\n        }\n    }\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x){\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \n    */\n    double sum=0;\n    int i;\n    {\n        i=0;\n        for (;i<xs.size();i++)\n        {\n            sum+=xs[i]*pow(x,i);\n        }\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs){\n    /*\n    xs are coefficients of a polynomial. find_zero find x such that poly(x) = 0. find_zero returns only only zero point, even if there are many. \n    Moreover, find_zero only takes list xs having even number of coefficients and largest non zero coefficient as it guarantees a solution.\n    >>> round(find_zero([1, 2]), 2) #f(x) = 1 + 2x \n    -0.5 \n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 \n    1.0\n    */\n    double ans=0;\n    double value;\n    value=poly(xs,ans);\n    while (abs(value)>1e-6)\n    {\n        double driv=0;\n        for (int i=0; i<xs.size(); i++)\n        {\n            driv+=pow(x, i)*xs[i];\n        }\n        if (driv==0)\n        {\n            return ans;\n        }\n        ans=ans+driv;\n    }\n    return ans;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> third = {};\n    int i;\n\n    i = 0;\n    while (i * 3 < l.size()) {\n        third.push_back(l[i * 3]);\n        i++;\n    }\n\n    sort(third.begin(), third.end());\n    return third;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\nfloat max_element(vector<float> l){\n  float max=-10000;\n  for (;i<l.size();i++)\n    if (max<l[i]) max=l[i];\n  return max;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> out = {};\n    vector<float> even = {};\n\n    {\n        int i = 0;\n        for (; i * 2 < l.size(); i++) {\n            even.push_back(l[i * 2]);\n        }\n    }\n\n    sort(even.begin(), even.end());\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            out.push_back(even[i / 2]);\n        } else {\n            out.push_back(l[i]);\n        }\n    }\n\n    return out;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <string>\n\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    // returns encoded string by cycling groups of three characters. \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    {\n        i = 0;\n        for (; i * 3 < l; i++)\n        {\n            // cycle elements in each group. Unless group has fewer elements than 3.\n            x = s.substr(i * 3, 3);\n            if (x.length() == 3) x = x.substr(1) + x[0];\n            output = output + x;\n        }\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    // takes as input string encoded with encode_cyclic function. Returns decoded string. \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++)\n    {\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output = output + x;\n    }\n    return output;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l){\n    for(int i = 0; i < l.size(); i++){\n        l[i] += 1;\n    }\n    return l;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    {\n        i = 0;\n        for (; i < s.length(); i++)\n        {\n            int w = ((int) s[i] + 5 - (int) 'a') % 26 + (int) 'a';\n            out += (char) w;\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++)\n    {\n        int w = ((int) s[i] - (int) 'a') % 26 + (int) 'a';\n        out += (char) w;\n    }\n    return out;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (; i < l.size(); i++)\n        if (l[i] >= t)\n            return false;\n    return true;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    {\n        int i = 0;\n        while (i < s0.length()) {\n            if (find(s1.begin(), s1.end(), s0[i]) == s1.end()) {\n                return false;\n            }\n            i++;\n        }\n    }\n    return true;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nvector<int> prime_factors(int n) {\n    vector<int> factors;\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            factors.push_back(i);\n            while (n % i == 0) {\n                n /= i;\n            }\n        }\n        i++;\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n\nint largest_prime_factor(int n) {\n    vector<int> factors = prime_factors(n);\n    int max_factor = 0;\n    for (int factor : factors) {\n        if (factor > max_factor) {\n            max_factor = factor;\n        }\n    }\n    return max_factor;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <vector>\n#include <string>\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int num1 = 0;\n    int num2 = 0;\n    int i = 0;\n\n    while (i < lst1.size()) {\n        num1 += lst1[i].length();\n        i++;\n    }\n\n    int min_len = min(num1, num2);\n\n    vector<string> result;\n    for (int j = 0; j < lst1.size(); j++) {\n        if (lst1[j].length() < min_len) {\n            result.push_back(lst1[j]);\n        }\n    }\n\n    for (int j = 0; j < lst2.size(); j++) {\n        if (lst2[j].length() < min_len) {\n            result.push_back(lst2[j]);\n        }\n    }\n\n    return result;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n/*\nWrite a function that takes an integer a and returns true \nif this ingeger is a cube of some integer number.\nNote: you may assume the input is always valid.\nExamples:\niscube(1) ==> true\niscube(2) ==> false\niscube(-1) ==> true\niscube(64) ==> true\niscube(0) ==> true\niscube(180) ==> false\n*/\n#include <math.h>\nusing namespace std;\nbool iscuber(int a) {\n    {\n        int i = 0;\n        for (; i * i * i <= abs(a); i++) {\n            if (i * i * i == abs(a)) return true;\n        }\n    }\n    return false;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <string>\nusing namespace std;\n\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    {\n        int i=0;\n        while(i<str.length()){\n            sum+=str[i]-'0';\n            i++;\n        }\n    }\n    string binary = \"\";\n    for (int j = 0; j < sum; j++) {\n        binary = (binary + \"1\") + (binary == \"\" ? \"0\" : \"\");\n    }\n    return binary;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            {\n                int j=2;\n                while (j*j<=lst[i]) {\n                    if (lst[i]%j==0) {\n                        prime=false;\n                        break;\n                    }\n                    j++;\n                }\n            }\n            if (prime && lst[i]>largest) largest = lst[i];\n        }\n    return largest;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <vector>\n#include <string>\n\nstring exchange(const vector<int>& lst1, const vector<int>& lst2) {\n    int num = 0;\n    {\n        int i = 0;\n        for (; i < lst1.size(); i++)\n        {\n            if (lst1[i] % 2 == 0) num += 1;\n        }\n    }\n    if (num == lst1.size()) return \"YES\";\n    else return \"NO\";\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nvector<string> reverse_delete(string s, string c) {\n    string n = \"\";\n    {\n        int i = 0;\n        while (i < s.length()) {\n            if (find(c.begin(), c.end(), s[i]) == c.end()) {\n                n = n + s[i];\n                i++;\n            }\n        }\n    }\n    return {n, \"true\" == n.length() ? \"True\" : \"False\"};\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    int mm, dd, yy;\n    if (date.length() != 10) return false;\n\n    // Check if date is in the correct format\n    if (date[3] != '-' || date[7] != '-') return false;\n\n    // Check if date is in the correct format\n    if (date[2] == '0' || date[5] == '0') return false;\n\n    // Check if the month is between 1 and 12\n    if (date[0] != '0' && (date[1] > 9 || (date[1] == '0' && date[2] != '0'))) return false;\n\n    // Check if the day is between 1 and 31 for months 1,3,5,7,8,10,12\n    if (date[1] == '0' || date[2] == '0' || (date[1] == '2' && date[2] == '0') || (date[1] == '4' && date[2] == '0') || (date[1] == '6' && date[2] == '0') || (date[1] == '8' && date[2] == '0') || (date[1] == '10' && date[2] == '0') || (date[1] == '12' && date[2] == '0')) return false;\n\n    // Check if the day is between 1 and 30 for months 4,6,9,11\n    if (date[1] == '4' || date[1] == '6' || date[1] == '9' || date[1] == '11') return false;\n\n    // Check if the day is between 1 and 29 for the month 2\n    if (date[1] == '2' && (date[2] == '0' || date[2] == '1')) return false;\n\n    return true;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nvector<string> split_words(const std::string& txt) {\n    int i;\n    std::string current = \"\";\n    std::vector<std::string> out = {};\n\n    if (txt.find(' ') != std::string::npos) {\n        txt = txt + \" \";\n        i = 0;\n        while (i < txt.length()) {\n            if (txt[i] == ' ') {\n                if (current.length() > 0) {\n                    out.push_back(current);\n                }\n                current = \"\";\n                i++;\n            }\n        }\n    } else {\n        out.push_back(txt);\n    }\n\n    for (const auto& word : out) {\n        int odd_count = 0;\n        for (char c : word) {\n            if (islower(c)) {\n                if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n                    odd_count++;\n                }\n            }\n        }\n        out.push_back(std::to_string(odd_count));\n    }\n\n    return out;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n\n#include <vector>\n#include <algorithm>\n\n/**\n * Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n * each cell of the grid contains a value. Every integer in the range {1, N * N}\n * inclusive appears exactly once on the cells of the grid.\n *\n * You have to find the minimum path of length k in the grid. You can start\n * from any cell, and in each step you can move to any of the neighbor cells,\n * in other words, you can go to cells which share an edge with you current\n * cell.\n * Please note that a path of length k means visiting exactly k cells (not\n * necessarily distinct).\n * You CANNOT go off the grid.\n * A path A (of length k) is considered less than a path B (of length k) if\n * after making the ordered vectors of the values on the cells that A and B go\n * through (let's call them lst_A and lst_B), lst_A is lexicographically less\n * than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n * such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n * lst_A[j] = lst_B[j].\n * It is guaranteed that the answer is unique.\n *\n * Return an ordered vector of the values on the cells that the minimum path go through.\n *\n * Examples:\n\n * Input: grid = { {1,2,3}, {4,5,6}, {7,8,9}}, k = 3\n * Output: {1, 2, 1}\n *\n * Input: grid = { {5,9,3}, {4,1,6}, {7,8,2}}, k = 1\n * Output: {1}\n */\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int i, j, x, y, min;\n    {\n        i = 0;\n        for (; i < grid.size(); i++) {\n            j = 0;\n            for (; j < grid[i].size(); j++) {\n                if (grid[i][j] == 1) {\n                    x = i;\n                    y = j;\n                }\n            }\n        }\n    }\n\n    // Initialize"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <boost/any.hpp>\n\nboost::any compare_one(boost::any a, boost::any b) {\n    double numa, numb;\n    boost::any out;\n\n    if (a.type() == typeid(string)) {\n        string s;\n        s = boost::any_cast<string>(a);\n        if (find(s.begin(), s.end(), ',') != s.end()) {\n            int i = 0;\n            for (; i < s.length(); i++)\n                if (s[i] == ',') s = s.substr(0, i) + '.' + s.substr(i + 1);\n            numa = atof(s.c_str());\n        }\n    }\n\n    if (b.type() == typeid(string)) {\n        string s;\n        s = boost::any_cast<string>(b);\n        if (find(s.begin(), s.end(), ',') != s.end()) {\n            int i = 0;\n            for (; i < s.length(); i++)\n                if (s[i] == ',') s = s.substr(0, i) + '.' + s.substr(i + 1);\n            numb = atof(s.c_str());\n        }\n    }\n\n    if (a.type() == typeid(double) && b.type() == typeid(double)) {\n        numa = a.value<double>();\n        numb = b.value<double>();\n        if (numa > numb) {\n            out = a;\n        } else if (numa < numb) {\n            out = b;\n        } else {\n            out = a;\n        }\n    } else if (a.type() == typeid(float) && b.type() == typeid(double)) {\n        numa = a.value<float>();\n        numb = b.value<double>();\n        if (numa > numb) {\n            out = a;\n        } else if (numa < numb) {\n            out = b;\n        } else {\n            out = a;\n        }\n    } else if (a.type() == typeid(double) && b.type() == typeid(float)) {\n        numa = a.value<double>();\n        numb = b.value<float>();\n        if (numa > numb) {\n            out = a;\n        } else if (numa < numb) {\n            out = b;\n        } else {\n            out = a;\n        }\n    } else if (a.type() == typeid(float"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n\n#include <vector>\n#include <iostream>\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    {\n        int i = 0;\n        while (i < lst.size()) {\n            if (i % 3 == 0) {\n                sum += lst[i] * lst[i];\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                sum += lst[i] * lst[i];\n            }\n            i++;\n        }\n    }\n    return sum;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a map to store the sum of digits of each number\n    unordered_map<int, int> sumdigit_map;\n    for (int i = 0; i < nums.size(); i++) {\n        string w = to_string(abs(nums[i]));\n        int sum = 0;\n        {\n            int j = 1;\n            for (; j < w.length(); j++)\n                sum += w[j] - 48;\n        }\n        if (nums[i] > 0) sum += w[0] - 48;\n        sumdigit_map[nums[i]] = sum;\n    }\n\n    // Sort the numbers based on the sum of their digits and their original index\n    vector<int> sorted_nums = nums;\n    sort(sorted_nums.begin(), sorted_nums.end(),\n        [sumdigit_map](int a, int b) {\n            if (sumdigit_map[a] == sumdigit_map[b]) {\n                return nums[sorted_nums.size() - 1 - a] < nums[sorted_nums.size() - 1 - b];\n            } else {\n                return sumdigit_map[a] < sumdigit_map[b];\n            }\n        });\n\n    return sorted_nums;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint get_matrix_triples(int n) {\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    {\n        int i=1;\n        while(i<=n){\n            a.push_back((i*i-i+1)%3);\n            sum.push_back(sum[sum.size()-1]);\n            sum[i][a[i-1]]+=1;\n            i++;\n        }\n    }\n    vector<vector<int>> dp(n+1, vector<int>(3, 0));\n    for(int i=1; i<=n; i++){\n        dp[i][0] = dp[i-1][0] + (a[i-1] == 0 ? 0 : 1);\n        dp[i][1] = dp[i-1][1] + (a[i-1] == 1 ? 0 : 1);\n        dp[i][2] = dp[i-1][2] + (a[i-1] == 2 ? 0 : 1);\n    }\n    vector<int> ans;\n    for(int i=1; i<=n; i++){\n        for(int j=0; j<3; j++){\n            if(dp[i][j] % 3 == 0){\n                ans.push_back(i);\n            }\n        }\n    }\n    return ans.size();\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> out = {};\n    {\n        int i = 0;\n        while (i < lst.size()) {\n            if (lst[i].length() % 2 == 0) {\n                out.push_back(lst[i]);\n            }\n            i++;\n        }\n    }\n    string mid;\n    sort(out.begin(), out.end());\n    return out;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <stdlib.h>\n\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    vector<int> num={};\n    vector<int> posto={};\n    {\n        int i = 0;\n        for (; i < operand.size(); i++)\n            posto.push_back(i);\n    }\n    {\n        int i = 0;\n        for (; i < operato.size(); i++)\n            if (operato[i] == \"**\") {\n                while (posto[posto[i]] != posto[i])\n                    posto[i] = posto[posto[i]];\n                while (posto[posto[i + 1]] != posto[i + 1])\n                    posto[i + 1] = posto[posto[i + 1]];\n                operand[posto[i]] = pow(operand[posto[i]], operand[posto[i + 1]]);\n                posto[i + 1] = posto[i];\n            }\n    }\n    int result = 0;\n    for (int i = 0; i < operato.size(); i++) {\n        if (operato[i] == \"+\") {\n            result += operand[posto[i]];\n        } else if (operato[i] == \"-\") {\n            result -= operand[posto[i]];\n        } else if (operato[i] == \"*\") {\n            result *= operand[posto[i]];\n        } else if (operato[i] == \"/\") {\n            if (operand[posto[i]] != 0) {\n                result /= operand[posto[i]];\n            } else {\n                printf(\"Error: Division by zero\\n\");\n                return -1;\n            }\n        } else if (operato[i] == \"**\") {\n            result = pow(operand[posto[i]], operand[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    return result;\n}"
      ]
    ],
    "variance": 0.0,
    "stddev": 0.0
  }
]