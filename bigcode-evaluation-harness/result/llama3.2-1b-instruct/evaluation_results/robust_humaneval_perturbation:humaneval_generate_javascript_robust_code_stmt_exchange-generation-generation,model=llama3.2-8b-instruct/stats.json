[
  {
    "name": {
      "name": "full_level_robustness",
      "split": "test"
    },
    "count": 29,
    "generations": [
      [
        "/* Return list of all prefixes from shortest to longest of the input string\n * >>> allPrefixes('abc')\n * ['a', 'ab', 'abc']\n */\nconst allPrefixes = (string) => {\n  var result = [];\n  {\n      let i = 0;\n      while(i < string.length){\n    result.push(string.slice(0, i+1));      i++;\n      }\n  }\n  return result;\n}"
      ],
      [
        "/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n */\nconst findClosestElements = (numbers) => {\n  let closest_pair, distance;\n  {\n      let i = 0;\n      while(i < numbers.length){{\n          let j = 0;\n          while(j < numbers.length){if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);      i++;\n      }\n            j++;\n          }\n      }\n  }\n  return [closest_pair, closest_pair];\n}"
      ],
      [
        "/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n */\nconst largestDivisor = (n) => {\n  {\n      let i = n - 1;\n      while(i >= 0){if (n % i == 0)      i--;\n      }\n  }\n};"
      ],
      [
        "/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n */\nconst factorize = (n) => {\n  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (!(n % i == 0)) {\n      else {\n        fact.push(i);\n        n = n / i;\n      }\n    }\n  while (n > 1) {\n    i = 2;\n    while (i <= Math.sqrt(n) + 1) {\n      if (!(n % i == 0)) {\n        else {\n          fact.push(i);\n          n = n / i;\n        }\n      }\n    while (n > 1) {\n      i = 2;\n      while (i <= Math.sqrt(n) + 1) {\n        if (!(n % i == 0)) {\n          else {\n            fact.push(i);\n            n = n / i;\n          }\n        }\n      }\n    }\n  }\n  return fact;\n}"
      ],
      [
        "/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n */\nconst findZero = (xs) => {\n  var begin = -1.0, end = 1.0;\n  for(;(poly(xs, begin) * poly(xs, end) > 0);){\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    if (Math.abs(poly(xs, begin + 1) * poly(xs, end - 1) < 1e-10)) {\n      return begin + 1.0;\n    }\n    begin *= 2.0;\n    end *= 2.0;\n  }\n}"
      ],
      [
        "/* Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13. */\n\nconst fizzBuzz = (n) => {\n  var ns = [], ans = 0;\n  {\n      let i = 0;\n      while(i < n){if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);      i++;\n      }\n  }\n  return ns.filter(num => num.toString().includes('7')).length;\n}"
      ],
      [
        "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  {\n      let i = 0;\n      while(i < Math.floor((s.length + 2) / 3)){\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n        i++;\n      }\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  return encodeCyclic(encodeCyclic(s));\n}"
      ],
      [
        "/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    {\n        let k = 2;\n        for (; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n          if (p % k == 0)\n            return false;\n        }\n    }\n  }\n  return isPrime(n);\n}"
      ],
      [
        "/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      for (let k = j + 1; k < l.length; k++) {\n        if (l[i] + l[j] + l[k] === 0 && l[i] !== l[j] && l[i] !== l[k] && l[j] !== l[k]) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}"
      ],
      [
        "/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  */\nconst pairsSumToZero = (l) => {\n  let i = 0;\n  while(i < l.length){{\n      let j = i + 1;\n      while(j < l.length){if (l[i] + l[j] == 0)      i++;          j++;\n      }\n  }\n}"
      ],
      [
        "/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let i = 0;\n  for (; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n}\n\n// begin to write code"
      ],
      [
        "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n*/\nconst modp = (n, p) => {\n  var ret = 1;\n  {\n      let i = 0;\n      while(i < n){ret = (2 * ret) % p;      i++;\n  }\n}"
      ],
      [
        "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    {\n        let i = 2;\n        for (; i <= Math.sqrt(k); i++)\n          if (k % i == 0)\n            return false;\n    }\n  var maxFactor = 0;\n  for (var i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i == 0) {\n      if (i == maxFactor)\n        maxFactor = i;\n      while (n % i == 0)\n        n = Math.floor(n / i);\n    }\n  }\n  if (n > 1)\n    if (n == maxFactor)\n      maxFactor = n;\n  return maxFactor;\n}"
      ],
      [
        "/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n */\nconst smallestChange = (arr) => {\n  var ans = 0;\n  {\n      let i = 0;\n      while(i < Math.floor(arr.length / 2)){\n        if (arr[i] != arr.at(-i - 1))      i++;\n      }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] !== arr[j] && arr[i] !== arr[j - 1]) {\n        ans++;\n        break;\n      }\n    }\n  }\n  return ans;\n}"
      ],
      [
        "/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n*/\nconst isPrime = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n}\n\nconst isMultiplyPrime = (a) => {\n  for (let i = 2; i < 101; i++) {\n    if (i !== a && isPrime(i) && isPrime(a / i) && isPrime(a / Math.pow(i, 2))) {\n      return true;\n    }\n  }\n  return false;\n}"
      ],
      [
        "``javascript\n/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E*/\n\nconst numericalLetterGrade = (grades) => {\n  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-"
      ],
      [
        "/**\n * Write a function that takes a string and returns an ordered version of it.\n * Ordered version of string, is a string where all words (separated by space)\n * are replaced by a new word where all the characters arranged in\n * ascending order based on ascii value.\n * Note: You should keep the order of words and blank spaces in the sentence.\n */\n\nconst antiShuffle = (s) => {\n  let arr = s.split(/\\s/)\n  {\n      let i = 0;\n      while(i < arr.length){\n    {\n        let j = 0;\n        while(j < arr[i].length){\n          let ind = j\n          {\n              let k = j + 1;\n              while(k < arr[i].length){\n                if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n                    ind = k\n                }\n                i++;\n                k++;\n              }\n          }\n          j++;\n        }\n        arr[i] = arr[i].sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0)).join('')\n      }\n    }\n  }\n  return arr.join(' ')\n}"
      ],
      [
        "/* Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let t = ''\n  {\n      let i = 0;\n      while(i < s.length){\n    let p = s.charCodeAt(i) + 4\n    if (p > 122) { p -= 26       i++;\n      }\n    t += String.fromCharCode(p)\n  }\n  return t\n}"
      ],
      [
        "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n*/\nconst nextSmallest = (lst) => {\n  let arr = lst\n  {\n      let j = 0;\n      for (; j < arr.length; j++) {\n      let ind = j\n      {\n          let k = j + 1;\n          for (; k < arr.length; k++) {\n              if (arr[k] < arr[ind]) {\n                ind = k\n              }\n            }\n      }\n  }\n  return ind === 0 ? null : ind\n}"
      ],
      [
        "/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n */\nconst encode = (message) => {\n  let t = '';\n  let vowels = 'aeiouAEIOU';\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt();\n    if (vowels.includes(message[i])) {\n      let j = (p - 97 + vowels.indexOf(vowels[i] + 2)) % 26;\n      t += String.fromCharCode(j + 97);\n    } else {\n      t += message[i];\n    }\n  }\n  return t;\n}"
      ],
      [
        "function sumOfDigitsOfLargestPrime(lst) {\n  let t = 0;\n  {\n      let i = 0;\n      for (; i < lst.length; i++) {\n      let p = 1;\n      {\n          let j = 2;\n          for (; j * j <= lst[i]; j++) {\n              if (lst[i] % j == 0) { p = 0; break }\n            }\n      }\n      if (p === 1) { // If it's a prime number, add its digits\n        t += lst[i].toString().split('').reduce((a, b) => a + parseInt(b), 0);\n      }\n      }\n  }\n  return t;\n}\n\n// Example usage"
      ],
      [
        "let countUpTo = (n) => {\n  let t = [];\n  let i = 2;\n  while(i < n){\n    let p = 1;\n    let j = 2;\n    while(j * j <= i){      i++;\n      j++;\n    }\n    if (i < n) {\n      t.push(i);\n    }\n  }\n  return t;\n};\n\n// Example usage:"
      ],
      [
        "/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let p = 0;\n  {\n      let i = 0;\n      while(i < s.length){\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++; i += 2; }\n  }\n  return p;\n}"
      ],
      [
        "/**\n * Given a positive integer n, you have to make a pile of n levels of stones.\n * The first level has n stones.\n * The number of stones in the next level is:\n * - the next odd number if n is odd.\n * - the next even number if n is even.\n * Return the number of stones in each level in a list, where element at index\n * i represents the number of stones in the level (i+1).\n */\nconst makeAPile = (n) => {\n  let t = [];\n  {\n      let i = n;\n      for (; i < n * 3; i += 2) {\n      t.push(i);\n  }\n  return t;\n}\n\nexport default makeAPile;"
      ],
      [
        "/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n*/\nconst chooseNum = (x, y) => {\n  let i = y;\n  while(i >= x){\n    if (i % 2 == 0) {return i}\n    i--;\n  }\n  return -1;\n}"
      ],
      [
        "const uniqueDigits = (x) => {\n  let p = [];\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i];\n    let boo = 1;\n    while (h > 0) {\n      let r = h % 10;\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10;\n    }\n    if (boo) p.push(x[i]);\n  }\n  p.sort((a, b) => a - b);\n  return p;\n}"
      ],
      [
        "/**\n * Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n * reverse the resulting array, and then replace each digit by its corresponding name from\n * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n *\n * @param {number[]} arr - The input array of integers\n * @returns {string[]} - The sorted and reversed array with digit names\n */\nfunction byLength(arr) {\n  const p = [];\n  {\n    let i = 0;\n    for (; i < arr.length; i++) {\n      if (arr[i] > 0 && arr[i] < 10) {\n        p.push(arr[i]);\n      }\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j;\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k;\n      }\n    }\n    [p[j], p[ind]] = [p[ind], p[j]];\n  }\n  return p;\n}\n\n// Example usage\nconst arr = [2, 1, 1, 4, 5, 8, 2, 3];"
      ],
      [
        "/* Implement the function f that takes n as a parameter,\n * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n * or the sum of numbers from 1 to i otherwise.\n * i starts from 1.\n * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n * Example:\n * f(5) == [1, 2, 6, 24, 15]\n */\nconst f = (n) => {\n  let f = 1;\n  let p = 0;\n  let k = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      f = f * i;\n    } else {\n      p += i;\n      k.push(p);\n    }\n  }\n  return k;\n}"
      ],
      [
        "/*\n  Write a function countNums which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n*/\n\nconst countNums = (arr) => {\n  let p = 0;\n  {\n      let i = 0;\n      for (; i < arr.length; i++) {\n          let h = arr[i];\n          if (h > 0) {\n              p++;\n              continue;\n          }\n          let sum = 0;\n          for (let j = 0; j < Math.abs(h); j++) {\n              sum += h % 10;\n          }\n          if (sum > 0) {\n              p++;\n              continue;\n          }\n      }\n  }\n  return p;\n}"
      ],
      [
        "/**\n * In this problem, you will implement a function that takes two lists of numbers,\n * and determines whether it is possible to perform an exchange of elements\n * between them to make lst1 a list of only even numbers.\n * There is no limit on the number of exchanged elements between lst1 and lst2.\n * If it is possible to exchange elements between the lst1 and lst2 to make\n * all the elements of lst1 to be even, return \"YES\".\n * Otherwise, return \"NO\".\n * For example:\n * exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n * exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n * It is assumed that the input lists will be non-empty.\n */\n\nconst exchange = (lst1, lst2) => {\n  let k = lst1.length;\n  let t = 0;\n\n  {\n    let i = 0;\n    while (i < lst1.length) {\n      if (lst1[i] % 2 == 0) {\n        t++;\n        i++;\n      }\n    }\n  }\n\n  if (t === k) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}"
      ],
      [
        "const Map = require('map');\n\n/**\n * Given a string representing a space separated lowercase letters, return a dictionary\n * of the letter with the most repetition and containing the corresponding count.\n * If several letters have the same occurrence, return all of them.\n *\n * @param {string} test\n * @returns {Map<string, number>}\n */\nconst histogram = (test) => {\n  let d = new Map();\n  let t = test.split(/\\s/);\n\n  if (test == '') { t = [] }\n\n  for (let m of t) {\n    if (!(m in d)) {\n      d.set(m, 1);\n    } else {\n      d.set(m, d.get(m) + 1);\n    }\n  }\n\n  let max = 0;\n  let result = new Map();\n\n  for (let [key, value] of d) {\n    if (value > max) {\n      max = value;\n      result.set(key, value);\n    } else if (value === max) {\n      result.set(key, value);\n    }\n  }\n\n  return result;\n}\n\n// To get rid of the warning, you can remove the line that generates the Map\n// let result = histogram('');"
      ],
      [
        "function reverseDelete(s, c) {\n  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    {\n        let j = 0;\n        while(j < c.length){\n      if (s[i] == c[j]) {\n        y = 0\n      }\n            j++;\n        }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  return [t, t === t.split('').reverse().join('') ? true : false]\n}\n\n// Example usage:"
      ],
      [
        "/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n*/\nconst oddCount = (lst) => {\n  return lst.map((s) => {\n    let oddCount = 0;\n    for (let i = 0; i < s.length; i++) {\n      if (s[i] % 2 !== 0) {\n        oddCount++;\n      }\n    }\n    return `the number of odd elements ${oddCount}n the str${s.length}n of the ${s.length}nput.`;\n  });\n}"
      ],
      [
        "``javascript\n/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\n\nfunction minSubArraySum(nums) {\n  let min = nums[0];\n  {\n      let i = 0;\n      while(i < nums.length){\n    {\n        let j = i + 1;\n        while(j <= nums.length){\n          let s = 0;\n          {\n              let k = i;\n              while(k < j){      i++;\n                k++;\n          }\n          }\n          j++;\n        }\n    }\n  }\n}"
      ],
      [
        "/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nfunction maxFill(grid, capacity) {\n  let p = 0;\n  {\n      let i = 0;\n      while(i < grid.length){\n    let m = 0;\n    {\n        let j = 0;\n        while(j < grid[i].length){\n          if (grid[i][j] == 1) { m++; j++; }\n          j++;\n        }\n    }\n    p = Math.max(p, m);\n  }\n  return p;\n}"
      ],
      [
        "function sortArray(arr) {\n    let p = arr\n    {\n        let j = 0;\n        for (; j < p.length; j++) {\n            let ind = j;\n            {\n                let k = j + 1;\n                for (; k < p.length; k++) {\n                    let w1 = p[ind].toString(2);\n                    let f1 = 0;\n                    {\n                        let u = 0;\n                        for (; u < w1.length; u++) {\n                            if (w1[u] == '1') { f1++ }\n                        }\n                    }\n                    let w2 = p[k].toString(2);\n                    let f2 = 0;\n                    {\n                        let u = 0;\n                        for (; u < w2.length; u++) {\n                            if (w2[u] == '1') { f2++ }\n                        }\n                    }\n                    if (f1 !== f2) {\n                        p[ind] = p[k];\n                    } else {\n                        p[ind] = w1;\n                    }\n                }\n            }\n        }\n    }\n    return p;\n}"
      ],
      [
        "/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n*/\nconst selectWords = (s, n) => {\n  let words = s.split(/\\s+/);\n  let result = [];\n  for (let word of words) {\n    let consonants = 0;\n    for (let char of word) {\n      if ('bcdfghjklmnpqrstvwxyz'.includes(char)) {\n        consonants++;\n      }\n    }\n    if (consonants == n) {\n      result.push(word);\n    }\n  }\n  return result;\n}"
      ],
      [
        "class Stack {\n  constructor() {\n    this.stack = [];\n  }\n\n  push(item) {\n    this.stack.push(item);\n  }\n\n  pop() {\n    if (this.stack.length === 0) {\n      return null;\n    }\n    return this.stack.pop();\n  }\n\n  isEmpty() {\n    return this.stack.length === 0;\n  }\n}\n\nfunction matchParens(lst) {\n  let stack = new Stack();\n  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (!(w1[i] == '(')) { y-- }\n    else { y++ }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n    stack.push(w1[i]);\n  }\n\n  for (let i = 0; i < w1.length; i++) {\n    if (!(w1[i] == ')')) {\n      if (stack.isEmpty()) {\n        return 'No';\n      }\n      stack.pop();\n    } else {\n      stack.push(w1[i]);\n    }\n  }\n\n  if (stack.isEmpty()) {\n    return 'Yes';\n  } else {\n    return 'No';\n  }\n}"
      ],
      [
        "function maximum(arr, k) {\n  let p = arr\n  {\n      let j = 0;\n      for (; j < p.length; j++) {\n      let ind = j\n      {\n          let k = j + 1;\n          for (; k < p.length; k++) {\n              if (p[k] < p[ind]) {\n                ind = k\n              }\n          }\n      }\n      p = [...p.slice(0, j), ...p.slice(j + 1, p.length), p.slice(0, ind), p.slice(ind + 1, p.length)];\n    }\n  return p\n}"
      ],
      [
        "const addElements = (arr, k) => {\n  let p = 0;\n  {\n      let i = 0;\n      while(i < k){\n        if (arr[i] < 100 && arr[i] > -100) { p += arr[i]; i++; }\n      }\n  }\n  return p;\n}"
      ],
      [
        "/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n*/\nconst getOddCollatz = (n) => {\n  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    {\n        let i = 0;\n        for (; i < p.length; i++) {\n          if (t == p[i]) {\n            u = 1\n            break;\n          }\n        }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 0) {\n      t = Math.floor(t / 2)\n    } else {\n      t = 3 * t + 1\n    }\n    p.push(t)\n  }\n  p.sort((a, b) => a - b)\n  return p\n}"
      ],
      [
        "``javascript\n/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nfunction minPath(grid, k) {\n  let m = 0;\n  let n = 0;\n  {\n    let i = 0;\n    while (i < grid.length) {\n      {\n        let j = 0;\n        while (j < grid.length) {\n          if (grid[i][j] == 1) {\n            m = i;\n            n = j;\n            break;\n          }\n          j++;\n        }\n      }\n    }\n  }\n\n  const directions = [[-1, 0], ["
      ],
      [
        "function isNested(string) {\n  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (!(string[i] == '[')) {\n      closing_bracket_index1.push(i)\n    }\n    else {\n      opening_bracket_index.push(i)\n    }\n  }\n  let stack = [];\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      stack.push(string[i]);\n    }\n    else if (stack.length > 0 && string[i] == ']') {\n      if (stack.pop() != '[') {\n        return false;\n      }\n    }\n  }\n  return stack.length > 0;\n}\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n*/"
      ],
      [
        "/**\n * Create a function which returns the largest index of an element which\n * is not greater than or equal to the element immediately preceding it. If\n * no such element exists then return -1. The given array will not contain\n * duplicate values.\n */\n\nconst canArrange = (arr) => {\n  if (arr.length == 0) { return -1 }\n  {\n    let i = arr.length - 1;\n    while(i > 0){\n      if (arr[i] < arr[i - 1]) { return i       i--;\n      }\n    }\n  }\n}"
      ],
      [
        "/**\n * Create a function that returns a tuple (a, b), where 'a' is\n * the largest of negative integers, and 'b' is the smallest\n * of positive integers in a list.\n * If there is no negative or positive integers, return them as null.\n */\nconst largestSmallestIntegers = (lst) => {\n  let a = Infinity\n  let b = -Infinity\n  {\n    let i = 0;\n    while(i < lst.length){\n      if (lst[i] > 0 && lst[i] < a) { a = lst[i]       i++;\n      }\n    }\n  }\n  return a === Infinity ? null : [a, b];\n}"
      ],
      [
        "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with -\n \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (!(text[i] == ' ')) if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n    } else {\n      c = 0\n    }\n  }\n  return t\n}"
      ],
      [
        "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n*/\nfunction sumSquares(lst) {\n  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) {\n      y += lst[i] * lst[i] * lst[i]\n    } else {\n      if (i % 4 == 0) {\n        y += lst[i] * lst[i] * lst[i] * lst[i]\n      }\n    }\n  }\n  return y\n}"
      ],
      [
        "/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let t = sentence.split(/\\s+/);\n  let p = '';\n  {\n      let j = 0;\n      for (; j < t.length; j++) {\n          let len = t[j].length;\n          let u = 1;\n          if (len == 1 || len == 0) { continue }\n          if (isPrime(len)) {\n              p += t[j] + ' ';\n          }\n      }\n  }\n  return p.trim();\n};\n\nfunction isPrime(n) {\n  if (n <= 1) return false;\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n      if (n % i === 0) return false;\n  }\n  return true;\n}"
      ],
      [
        "/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n */\nconst orderByPoints = (nums) => {\n  let p = nums.map((num) => {\n    let sum = 0;\n    while (num > 0) {\n      sum += num % 10;\n      num = Math.floor(num / 10);\n    }\n    return sum;\n  });\n\n  p.sort((a, b) => {\n    if (a === b) {\n      return nums.indexOf(a) - nums.indexOf(b);\n    } else {\n      return a - b;\n    }\n  });\n\n  return p;\n};\n\n// Example usage:"
      ],
      [
        "function specialFilter(nums) {\n  let p = 0\n  {\n      let i = 0;\n      while(i < nums.length){\n    if (nums[i] < 10) { i++;continue }\n    let y = nums[i].toString()      i++;\n    if (y[0] % 2 === 1 && y[y.length - 1] % 2 === 1) { p++; }\n    i++;\n      }\n  }\n  return p;\n}\n\n// Example usage"
      ],
      [
        "function getMaxTriples(n) {\n  let y = [];\n  {\n    let i = 1;\n    while (i <= n) {\n      y.push(i * i - i + 1);\n      i++;\n    }\n  }\n  let u = 0;\n  for (let i = 0; i < y.length - 2; i++) {\n    let a = y[i] + y[i + 1] + y[i + 2];\n    if (a % 3 === 0) {\n      u++;\n    }\n  }\n  return u;\n}\n\n// Example usage:\nconst n = 5;"
      ],
      [
        "/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  */\nconst bf = (planet1, planet2) => {\n  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  {\n      let i = 0;\n      for (; i < 8; i++) {\n        if (y[i] == planet1) { lo = i }\n      }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] >= planet1 && y[i] <= planet2) {\n      u.push(y[i])\n    }\n  }\n  u.sort((a, b) => {\n    let d = Math.abs(b - planet1) - Math.abs(a - planet1);\n    if (d == 0) d = 1;\n    return d;\n  })\n  return u;\n}"
      ],
      [
        "function listSort(lst) {\n  let p = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 === 0) {\n      p.push(lst[i]);\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0;\n      if (p[k].length > p[k + 1].length) { f = 1; }\n      if (p[k].length === p[k + 1].length) {\n        f = 0;\n        if (p[k].localeCompare(p[k + 1]) < 0) {\n          f = 1;\n        }\n      }\n      if (f === 0) {\n        p.splice(k, 1);\n        break;\n      }\n    }\n  }\n  return p.sort((a, b) => a.length - b.length || a.localeCompare(b));\n}"
      ],
      [
        "``javascript\n/**\n * You will be given the name of a class (a string) and a list of extensions.\n * The extensions are to be used to load additional classes to the class.\n * The strength of the extension is as follows: Let CAP be the number of the uppercase\n * letters in the extension's name, and let SM be the number of lowercase letters\n * in the extension's name, the strength is given by the fraction CAP - SM.\n * You should find the strongest extension and return a string in this\n * format: ClassName.StrongestExtensionName.\n * If there are two or more extensions with the same strength, you should\n * choose the one that comes first in the list.\n * For example, if you are given \"Slices\" as the class and a list of the\n * extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n * return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n * (its strength is -1).\n * For example:\n * for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n */\nconst strongestExtension = (class_name, extensions) => {\n  let u = 0\n  let s = -Infinity\n  {\n      let i = extensions.length - 1;\n      while(i >= 0){\n    let y = 0\n    {\n        let j = 0;\n        while(j < extensions[i].length){\n      let k = extensions[i][j].charCodeAt()      i--;\n              j++;\n        }\n    }\n  }\n  let cap = 0\n  let sm = 0\n  for (let ext of extensions) {\n    let k = ext.length\n    let numCap = ext.match(/[A-Z]/g).length\n    let numSm = ext.match(/[a-z]/g).length\n    cap = numCap\n    sm = numSm\n    if (cap > sm) {\n      s = s > (cap - sm) ? s : (cap - sm)\n    }\n  }\n  return class_name + '.' + strongestExtensionName(s)\n}\n\n/**\n * Returns the strongest extension name for the given class and extensions.\n */\nconst strongestExtensionName = (s) => {"
      ],
      [
        "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n */\nconst cycpatternCheck = (a, b) => {\n  let l = b.length\n  let pat = b + b\n  {\n      let i = 0;\n      while(i < a.length - l + 1){\n    {\n        let j = 0;\n        while(j < l + 1){\n          let y = 1\n          {\n              let k = 0;\n              while(k < l){      i++;\n                k++;\n          }\n          }\n          j++;\n        }\n    }\n  }\n  return b === pat || pat === pat.split('').reverse().join('')\n}"
      ],
      [
        "/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n*/\nconst findMax = (words) => {\n  let maxWord = '';\n  let maxUniqueChars = 0;\n  let maxOrder = false;\n\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let uniqueChars = new Set(word).size;\n\n    if (uniqueChars > maxUniqueChars) {\n      maxUniqueChars = uniqueChars;\n      maxWord = word;\n      maxOrder = false;\n    } else if (uniqueChars === maxUniqueChars) {\n      if (word < maxWord) {\n        maxWord = word;\n        maxOrder = false;\n      }\n    }\n\n    if (maxUniqueChars === 0) {\n      break;\n    }\n  }\n\n  if (maxUniqueChars > 0) {\n    return maxWord;\n  } else {\n    return maxOrder ? maxWord : '';\n  }\n}"
      ],
      [
        "const operator = {\n  '+': (a, b) => a + b,\n  '-': (a, b) => a - b,\n  '*': (a, b) => a * b,\n  '/': (a, b) => a / b,\n  '**': (a, b) => Math.pow(a, b),\n};\n\nconst doAlgebra = (operator, operand) => {\n  let result = operand[0];\n  for (let i = 1; i < operand.length; i++) {\n    if (operand[i] === 0) {\n      throw new Error(\"Division by zero is not allowed\");\n    }\n    let y = 0;\n    for (let j = operator.length - 1; j >= 0; j--) {\n      if (operator[j] === '**') {\n        let u = operand[i];\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1);\n        operator.splice(j, 1);\n        y = 1;\n        break;\n      }\n    }\n    if (y === 1) {\n      continue;\n    }\n    for (let k = 0; k < operator.length; k++) {\n      if (operator[k] === '*') {\n        operand[k] = operand[k] * operand[k + 1];\n      }\n    }\n  }\n  return result;\n};"
      ],
      [
        "/* You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\n\nconst solve = (s) => {\n  let t = 0;\n  let p = '';\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt();\n    if (y >= 65 && y <= 90) {\n      y = y + 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y = y - 32;\n      t = 0;\n    }\n    if (t === 0) p += s[i];\n  }\n  return p;\n}\n\n// Test cases"
      ]
    ],
    "variance": 0.0,
    "stddev": 0.0
  }
]