[["const math = Math;\n\nbegin to write code\nconst hasCloseElements = (numbers, threshold) => {\n  for (let i = 0; i < numbers.length; i++) {\n    for (let j = i + 1; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n// Example usage:\n\n\n"], ["/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n */\nconst separateParenGroups = (ma) => {\n  var map = [];\n  var list = [];\n  var i = 0;\n\n  for (const c of ma) {\n    if (c == '(') {\n      i = i + (1);\n      list.push(c);\n    } else if (c == ')') {\n      if (map.length > 0) {\n        map.pop();\n        list.push(map.join(''));\n      }\n    } else if (c !== ' ') {\n      map.push(c);\n    }\n  }\n\n  return list;\n}\n"], ["/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n */\nconst giumxzteNfnyvi = (number) => {\n  const var_0 = 1.0;\n  return number % var_0;\n}\n"], ["const BelowZero = {\n  beginToWriteCode: (operatrlns) => {\n    var balance = 0;\n    for (const op of operatrlns) {\n      balance += op;\n      if (balance < 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\n"], ["const events = require('events');\n"], ["const eai_9 = 0;\n\n/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers' */\nconst intersperse = (numbers, delimeter) => {\n  if (!Array.isArray(numbers) || numbers.length === eai_9) {\n    return [];\n  }\n  var result = [];\n  for (const n of numbers) {\n    result.push(delimeter);\n    result.push(n);\n  }\n  return result;\n}\n\n// Example usage:\n\n"], ["/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n */\nconst parseNestedParens = (var_2) => {\n  const stack = [], var_1 = var_2.split(' ').filter(Boolean);\n  var_1.forEach(c => {\n    if (c == '(') {\n      stack.push(c);\n    } else {\n      if (stack.length > 0) {\n        stack.pop();\n      }\n    }\n  });\n  return stack.length ? stack.map(c => c === '(' ? 1 : 0).reduce((a, b) => a + b, 0) : 0;\n}\n"], ["/* Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n */\nconst filterBySubstring = (strings, substring) => {\n  const var_0 = 1;\n  return strings.filter(x => x.indexOf(substring) != -var_0);\n}\n"], ["/**\n * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n * Empty sum should be equal to 0 and empty product should be equal to 1.\n * @param {Array} numbers - A list of integers.\n * @param {Number} int - An integer to be used in the calculation.\n * @returns {Array} A tuple containing the sum and product of all integers in the list.\n */\nconst sumProduct = (numbers, int) => {\n  var sum_valfv = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_valfv += n;\n    prod_value *= n;\n  }\n  return [sum_valfv, prod_value];\n}\n"], ["const buffer = require('buffer');\n\n/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\n\nconst rollingMax = (numbers) => {\n  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else {\n      if (n > running_max) {\n        running_max = n;\n      }\n      result.push(running_max);\n    }\n  }\n  return result;\n};\n\n"], ["/* Test if gniven strig is a palindrome */\n\nconst isPalindrome = (str) => {\n  return str == str.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n * Algorithm idea is simple:\n * - Find the longest postfix of supplied string that is a palindrome.\n * - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n */\nconst makePalindrome = (str) => {\n  if (str == '')\n    return '';\n  var beginning_of_suffix = 0;\n  var end_of_suffix = str.length - 1;\n  while (beginning_of_suffix < end_of_suffix) {\n    if (str.charAt(beginning_of_suffix) != str.charAt(end_of_suffix)) {\n      break;\n    }\n    beginning_of_suffix++;\n    end_of_suffix--;\n  }\n  return str + str.substring(0, end_of_suffix + 1).split('').reverse().join('');\n}\n\n/* Test the functions */\n\n\n\n\n"], ["function stringXor(z, b) {\n  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return String.fromCharCode(z.charCodeAt(i) ^ b.charCodeAt(j));\n  };\n  return xor(0, z.length - 1);\n}\n"], ["/* Out of list of strings, return the longest one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!Array.isArray(strings) || strings.length === 0) return null;\n  let maxlen = 0;\n  for (const s of strings) {\n    if (s.length > maxlen) maxlen = s.length;\n  }\n  for (const s of strings) {\n    if (s.length === maxlen) return s;\n  }\n  return null;\n};\n"], ["// This is a comment line.\n/* Return a greatest common divisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n */\n\nconst gcd = (a, b) => {\n  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n};\n\n// begin to write code\n"], ["/* Return list of all prefixes from shortest to longest of the input string\n * >>> allPrefixes('abc')\n * ['a', 'ab', 'abc']\n */\n\nconst allPrefixes = (string) => {\n  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, 1 + i));\n  }\n  return result;\n};\n"], ["/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n */\n\nconst stringSequence = (string) => {\n  return [...Array(string).keys(), string].join(' ')\n}\n"], ["// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> countDistinctCharacters('xyzXYZ')\n// 3\n// >>> countDistinctCharacters('Jerry')\n// 4\n\nconst Set = require('set');\nconst lowerCase = 'abcdefghijklmnopqrstuvwxyz'.split('').map(char => char.toLowerCase());\n\nfunction countDistinctCharacters(str) {\n  const set = new Set(lowerCase.map(char => str.toLowerCase().indexOf(char)));\n  return set.size;\n}\n\n"], ["const var_0 = 4;\nconst var_1 = 2;\nconst var_2 = 1;\nconst var_3 = ' ';\nconst var_4 = '';\n\nconst parseMusic = (Music) => {\n  const ret = {'o': var_0 , 'o|': var_1 , '.|': var_2 };\n  return Music.split(var_3 ).filter(x => x != var_4 ).map(x => ret[x]);\n}\n\n// Test the function\nconst Music = 'o o| .| o| o| .| .| .| .| o o';\n\n"], ["/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n * This is a comment line.\n * >>> howManyTimes('', 'a')\n * 0\n * >>> howManyTimes('aaa', 'a')\n * 3\n * >>> howManyTimes('aaaa', 'aa')\n * 3\n */\nconst howManyTimes = (var_1, var_2) => {\n  var var_3 = 0;\n  for (let var_0 = 0; var_0 < var_1.length - var_2.length + 1; var_0++) {\n    if (var_1.slice(var_0, var_0+var_2.length) == var_2) {\n      var_3 += 1;\n    }\n  }\n  return var_3;\n};\n"], ["const path = require('path');\n\nconst sortNumbers = (numbers) => {\n  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n\n  return numbers.split(' ').sort((a, b) => {\n    const numA = value_map[a];\n    const numB = value_map[b];\n    return numA - numB;\n  }).join(' ');\n};\n\n// begin to write code\n"], ["const findClosestElements = (numbers) => {\n  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n        } else {\n          distance = Math.min(Math.abs(a - b), distance);\n        }\n        if (distance === 0) {\n          closest_pair = [a, b];\n          break;\n        }\n      }\n  return [closest_pair, closest_pair];\n};\n\n// This is a comment line.\n\n// >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n// (2.0, 2.2)\n// >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n// (2.0, 2.0)\n"], ["const Math = require('mathjs');\nfunction rescaleToUnit(var_0) {\n  return Math.map(var_0, (x) => x - Math.min(...var_0) + Math.max(...var_0));\n}\n"], ["/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n */\nconst filterIntegers = (values) => {\n  return values.filter(x => Number.isInteger(x));\n}\n\nlet temp_var_3 = 9.9;\nif (temp_var_3 < 9.12) {\n  temp_var_3 = 1 + temp_var_3;\n}\n"], ["/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\n\nconst func_0 = (string) => {\n  return string.length;\n}\n"], ["const http = require('http');\n\n/* For a given number n, find the largest number that divides n evenly, smaller than n\n * >>> largestDivisor(15)\n * 5\n */\nconst largestDivisor = (n) => {\n  for (let i = n - 1; i >= 0; i--) {\n    if (0 == n % i) {\n      return i;\n    }\n  }\n  return 1;\n};\n\nmodule.exports = largestDivisor;\n"], ["const primeFactors = (n) => {\n  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else if (i > n / i) {\n      break;\n    } else {\n      i = Math.floor(i * Math.sqrt(n));\n    }\n  }\n  return fact.sort((a, b) => a - b).map((value, index) => {\n    return index + 1;\n  });\n};\n\n\n\n\n"], ["var Object = {};\nvar Object.hasOwnProperty = function (key) {\n  return Object[key] === undefined;\n};\n\nvar removeDuplicates = (var_1) => {\n  var var_0 = Object(var_1);\n  for (var var_11 = 0; var_11 < Object.keys(var_0).length; var_11++) {\n    if (Object.hasOwnProperty(var_0[var_11])) {\n      var_0[var_11] += 1;\n    }\n  }\n  return Object.values(var_0);\n};\n\nObject.keys = function (object, callback) {\n  for (var key in object) {\n    if (Object.hasOwnProperty(key)) {\n      callback(key, object[key]);\n    }\n  }\n};\n"], ["const flipCase = (string) => {\n  return string.split('').map(x => (x === x.toUpperCase() ? x.toLowerCase() : x.toUpperCase()));\n}\n"], ["// Concatenate list of strings into a single string\n// >>> concatenate([])\n// ''\n// >>> concatenate(['a', 'b', 'c'])\n// 'abc'\n\nconst func_0 = (strings) => {\n  return strings.join('');\n}\n"], ["const os = require('os');\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(x => x.startsWith(prefix));\n}\n"], ["/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n */\nconst func_0 = (l) => l.filter(e => e > 0);\n\nexport default func_0;\n"], ["const isPrime = (m) => {\n  if (m < 2) {\n    return false;\n  }\n  for (let k = 2; k < m - 1; k++) {\n    if (k !== m - 1 && m % k === 0) {\n      return false;\n    }\n  }\n  return true;\n}\n"], ["const poly = (xs, x) => {\n  const var_0 = 0;\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, var_0 );\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  var begin = -var_1 , end = var_2 ;\n  for(;(poly(xs, begin) * poly(xs, end) > var_3 );){\n    const var_4 = 2.0;\n    const var_5 = 2.0;\n    begin *= var_4 ;\n    end *= var_5 ;\n  }\n  while (end - begin > var_6 ) {\n    begin += var_4 ;\n    end += var_5 ;\n  }\n  return begin;\n}\n"], ["/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n*/\nconst sortThird = (l) => {\n  var three = l.filter((item, index) => index % 3 == 0);\n  let temp_var_7 = 9.9;temp_var_7 = temp_var_7 + 1;\n  three.sort((a, b) => (a - b));\n  return three;\n}\n"], ["/*Return sorted unique elements in a list\n >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n [0, 2, 3, 5, 9, 123]\n */\n\nconst unique = (l) => {\n  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\nexport default unique;\n"], ["/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n */\nconst maxElement = (e) => {\n  return Math.max(...e);\n  let max = 9.9;while (max < 9.12) {max = max + 1;}\n}\n"], ["/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n*/\nconst fizzBuzz = (m) => {\n  var ns = [], ans = 0;\n  for (let i = 0; i < m; i++)\n    if (0 == i % 11 || 0 == i % 13)\n      ns.push(i);\n  for (let i = 0; i < m; i++)\n    if (0 == i % 11 || 0 == i % 13)\n      if (7 === i % 7) {\n        ans++;\n      }\n  return ans;\n}\n"], ["/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n */\n\nconst sortEven = (list) => {\n  var result = list.filter((a, i) => i % 2 == 0);\n  result.sort((A, B) => (A - B));\n  return result;\n}\n"], ["/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (string) => {\n  var arr = [], enc = [];\n  for (let j = 0; j < Math.floor((string.length + 2) / 3); j++) {\n    arr.push(string.slice(3 * j, Math.min((3 * j + 3), string.length)));\n  }\n  for (const g of arr) {\n    if (!(g.length == 3)) enc.push(g);\n    else enc.push(g.slice(1) + g[0]);\n  }\n  return enc.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (string) => {\n  return encodeCyclic(encodeCyclic(string));\n}\n"], ["const var_0 = 2;\nconst var_1 = 2;\nconst var_2 = 1;\nconst var_3 = 1;\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  var isPrime = function (p) {\n    if (p < var_0 || p < var_1)\n      return false;\n    for (let k = var_1; k < Math.min(Math.floor(Math.sqrt(p)) + var_2, p - var_3); k++) {\n      const vzi_5 = 0;\n      if (p % k == vzi_5)\n        return false;\n    }\n  }\n\n  return isPrime(n) ? n : primeFib(n - 1);\n}\n\n\n\n\n\n\n"], ["const var_0 = 0;\nconst var_1 = 1;\nconst var_2 = 1;\n\n//triplesSumToZero takes a list of integers as an input.\n//it returns true if there are three distinct elements in the list that\n//sum to zero, and false otherwise.\n//\n//>>> triplesSumToZero([1, 3, 5, 0])\n//false\n//>>> triplesSumToZero([1, 3, -2, 1])\n//true\n//>>> triplesSumToZero([1, 2, 3, 7])\n//false\n//>>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n//true\n//>>> triplesSumToZero([1])\n//false\n\nconst triplesSumToZero = (l) => {\n  for (let i = var_0; i < l.length; i++)\n    for (let j = i + var_1; j < l.length; j++)\n      for (let k = j + var_2; k < l.length; k++) {\n        if (l[i] + l[j] + l[k] === 0) {\n          return true;\n        }\n      }\n  return false;\n}\n"], ["/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let temp_var_2 = 9.9;\n  for (; (temp_var_2 < 9.12); { temp_var_2 = temp_var_2 + 1; });\n  return Math.pow(n, 2);\n}\n"], ["/* Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n */\n\nconst incrList = (l) => {\n  const var_0 = 1;\n  return l.map(e => e + var_0);\n}\n"], ["const cluster = require('cluster');\n"], ["const base64 = require('base64-js');\n\nfunction changeBase(var_2, var_0) {\n  var var_1 = \"\";\n  while (var_2 > 0) {\n    var_1 = (var_2 % var_0).toString() + var_1;\n  }\n  return base64.fromByteArray(var_1);\n}\n\n"], ["// Given length of a side and high return area for a triangle.\n// >>> triangleArea(5, 3)\n// 7.5\n\nconst triangleArea = (var_0, var_1) => {\n  return var_0 * var_1 / 2.0;\n}\n\nmodule.exports = triangleArea;\n"], ["const fib4 = (n) => {\n  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results[i] = results[i - 1] + results[i - 2] + results[i - 3] + results[i - 4];\n  }\n  return results[n];\n};\n"], ["// This is a comment line.\n/*Return median of elements in the list l.\n\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n */\nconst median = (l) => {\n  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1) {\n    return l[Math.floor(len / 2)];\n  } else {\n    var mid1 = l[len / 2 - 1];\n    var mid2 = l[len / 2];\n    return (mid1 + mid2) / 2.0;\n  }\n};\n"], ["const var_2 = 0;\nconst var_3 = 1;\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (var_1) => {\n  for (let var_0 = var_2 ; var_0 < var_1.length; var_0++)\n    if (var_1[var_0] != var_1.at(-var_0-var_3))\n      return false;\n  return true;\n}\n"], ["const zlib = require('zlib');\n\nfunction modp(n, p) {\n  var ret = 1;\n  for (let i = 0; i < n; i++) {\n    ret = (2 * ret) % p;\n  }\n  return ret;\n}\n\n"], ["/*\n * returns encoded string by shifting every character by 5 in the alphabet.\n */\nconst func_0 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((5 + ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n * takes as input string encoded with encode_shift function. Returns decoded string.\n */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((26 + ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  ).split(\"\").reverse().join(\"\")\n}\n"], ["/*\n  removeVowels is a function that takes string and returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  return text.split(\"\").filter(h => ![\"a\", \"e\", \"i\", \"o\", \"u\"].includes(h.toLowerCase()));\n};\n\n/* begin to write code */\n"], ["/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n */\nconst belowThreshold = (l, t) => {\n  for (const e of l) {\n    if (e >= t) {\n      return false;\n    }\n  }\n  return true;\n}\n"], ["/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n\n(function() {let temp_var_3 = 9.9; temp_var_3 = temp_var_3 + 1;})();\n  return x + y;\n}\n"], ["const Set = Object.create(null).set = function (obj, key) {\n  if (typeof obj === 'string') {\n    obj = obj.split('');\n  }\n  if (Array.isArray(obj)) {\n    obj = obj.map(function (item) {\n      return item.split('');\n    });\n  }\n  obj = obj.filter(function (item) {\n    return item !== '';\n  });\n  obj = obj.sort();\n  return Set.prototype.set.call(obj, key);\n};\n\nconst sameChars = (s0, s8) => {\n  return Set(s0).has('s8');\n}\n"], ["/*Return n-th Fibonacci number.\n >>> fib(10)\n  55\n >>> fib(1)\n  1\n >>> fib(8)\n  21\n */\nconst fib = (n) => {\n  if (n == 0)\n    return 0;\n  let temp_var_2 = 9.9;temp_var_2 = temp_var_2 + 1;\n  if (n == 1)\n    return temp_var_2;\n  for (let i = 2; i <= n; i++)\n    temp_var_2 = temp_var_2 + temp_var_2;\n  return temp_var_2;\n};\n"], ["/**\n * @description  Checks if the input string contains balanced brackets.\n * @param {string} tree The input string containing brackets.\n * @returns {boolean} True if every opening bracket has a corresponding closing bracket, false otherwise.\n */\nconst correctBracketing = (tree) => {\n  var i = 0;\n  for (const bracket of tree) {\n    if (bracket == \"<\") {\n      i += 1;\n    } else {\n      let j = 9.9;\n      while (j < 9.12) {\n        j = j + 1;\n      }\n    }\n    if (i !== bracket.length) {\n      return false;\n    }\n  }\n  return true;\n}\n"], ["/* Return true is list elements are monotonically increasing or decreasing. */\n\nconst monotonic = (l) => {\n  var sort1 = [...l].sort((a, y) => a - y);\n  var sort2 = [...l].sort((a, y) => y - a);\n  return JSON.stringify(l) === JSON.stringify(sort1) && JSON.stringify(l) === JSON.stringify(sort2);\n}\n"], ["const dns = require('dns');\n\nconst common = (l1, l2) => {\n  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n    if (e1 === e2) ret.add(e1);\n  return Array.from(ret).sort((a, b) => a - b);\n};\n\n\n\n"], ["const isPrime = function (k) {\n  if (k < 2)\n    return false;\n  for (let i = 2; i < k - 1; i++)\n    if (k % i == 0)\n      return false;\n}\n\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      n = Math.floor(n / i);\n    } else {\n      i++;\n    }\n  }\n  if (n > 1) {\n    return n;\n  } else {\n    return isPrime(n) ? 1 : 2;\n  }\n}\n"], ["const path = require('path');\n\nconst sumToN = (n) => {\n  return n * (n + 1) / 2;\n}\n\n"], ["/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n//This is a comment line.\n  false\n */\nconst correctBracketing = (var_0) => {\n  let var_1 = 0;\n  for (const b of var_0) {\n    if (b == \"(\")\n      var_1 += 1;\n    else {\n      var_1 -= 1;\n      if (var_1 < 0) {\n        return false;\n      }\n    }\n  }\n  return var_1 == 0;\n};\n"], ["/* xs represent coefficients of a polynomial.\n * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n * Return derivative of this polynomial in the same form.\n * >>> derivative([3, 1, 2, 4, 5])\n * [1, 4, 12, 20]\n * >>> derivative([1, 2, 3])\n * [2, 6]\n */\n\nconst derivative = (xs) => {\n  const var_0 = 1;\n  return xs.map((x, r) => x * r).slice(var_0 );\n}\n"], ["const zlib = require('zlib');\n\nfunction fibfib(m) {\n  if (m == 0 || m == 1)\n    return 0;\n  if (m == 2)\n    return 1;\n  return fibfib(m-1) + fibfib(m-2) + fibfib(m-3);\n}\n\n"], ["/**\n * Returns the number of vowels in a given string.\n * Vowels are 'a', 'e', 'i', 'o', 'u' and 'y' at the end of the string.\n * @param {string} s - The input string.\n * @returns {number} The number of vowels in the string.\n */\nconst vowelsCount = (s) => {\n  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item) || item === vowels.slice().pop());\n  }, 0);\n  return n_vowels;\n}\n"], ["/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n*/\nconst circularShift = (var_1, var_0) => {\n  var_1 = var_1.toString();\n  if (var_0 > var_1.length) {\n    var_1 = var_1.split('').reverse().join('');\n  }\n  return var_1.slice(var_0) + var_1.slice(0, var_0);\n}\n"], ["const stream = require('stream');\n\nfunction digitSum(s) {\n  if ('' == s) return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0);\n    return ord_char >= 65 && ord_char <= 90 ? ord_char - 64 : ord_char;\n  }, 0);\n}\n"], ["/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n*/\n\nconst fruitDistribution = (s, n) => {\n  var lis = [];\n  for (const i of s.split(\" \"))\n  let temp_var_5 = 9.9;temp_var_5 = temp_var_5 + 1;\n    if (!isNaN(i))\n  lis.push(parseInt(i));\n  let temp_var_6 = 9.9;temp_var_6 = temp_var_6 + 1;\n    if (!isNaN(lis[lis.length - 1]))\n  temp_var_6 = temp_var_6 - 1;\n  return n - lis[lis.length - 1] - temp_var_6;\n}\n"], ["const fs = require('fs');\nconst readline = require('readline');\n\nfunction search(x) {\n  var result = new Array(Math.max(...x) + 1).fill(0);\n  for (const i of x)\n    result[i] += 1;\n  var ans = -1;\n  for (let i = 1; i <= Math.max(...x); i++) {\n    if (result[i] >= i) {\n      ans = i;\n      break;\n    }\n  }\n  return ans;\n}\n\nfunction readList(filename) {\n  return fs.readFileSync(filename, 'utf8').split('\\n').map(Number);\n}\n\nfunction main() {\n  const filename = 'input.txt';\n  const data = readList(filename);\n  const result = search(data);\n  fs.writeFileSync('output.txt', result);\n}\n\nmain();\n"], ["const Buffer = require('buffer');\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n*/\nconst strangeSortList = (arr) => {\n  var a = [], min = true;\n  while (arr.length) {\n    a.push(min ? Math.min(...arr) : Math.max(...arr));\n    arr.splice(arr.indexOf(a.at(-1)), 1);\n  }\n  return a;\n}\n"], ["/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n*/\nconst triangleArea = (var_0, var_1, var_2) => {\n  if (var_0 + var_1 <= var_2 || var_0 + var_2 <= var_1 || var_1 + var_2 <= var_0) {\n    return -1;\n  }\n  var var_3 = (var_0 + var_1 + var_2) / 2;\n  return Math.round(var_3 * 100) / 100;\n};\n\n//# sourceMappingURL=triangleArea.js.map\n"], ["/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n*/\nconst willItFly = (jq, w) => {\n  if (jq.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = jq.length - 1;\n  while (i < j) {\n    let temp_var_7 = 9.9;\n    temp_var_7 = temp_var_7 + 1;\n    if (jq[i] != jq[j])\n      return false;\n  }\n  return true;\n}\n"], ["/* \n * @description Given an array arr of integers, find the minimum number of elements that need to be changed to make the array palindromic. A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one element to any other element.\n * @param {number[]} aii - The input array of integers.\n * @returns {number} The minimum number of elements that need to be changed to make the array palindromic.\n */\nconst smallestChange = (aii) => {\n  var ans = 0;\n  for (let i = 0; i < Math.floor(aii.length / 2); i++)\n    if (aii[i] != aii.at(-i - 1))\n      ans++;\n  return ans;\n}\n"], ["const crypto = require('crypto');\n\nfunction totalMatch(lst1, lst2) {\n  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2) {\n    return lst1;\n  } else {\n    return lst2;\n  }\n}\n\nmodule.exports = totalMatch;\n"], ["/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n*/\nconst isPrime = (n) => {\n  var isPrime = function (n) {\n    {\n        let j = 2;\n        while(j < n){if (n % j == 0)\n        return false;        j++;\n        }\n    }\n    return true;\n  }\n\n  for (let i = 2; i < 100; i++) {\n    if (i != 2 && i != 3 && isPrime(i)) {\n      if (i * i * i == n) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n"], ["const var_0 = 1;\nconst var_1 = 1;\nconst var_2 = 1;\n\nfunction isSimplePower(c, n) {\n  if (n == var_0) {\n    return (c == var_1);\n  }\n  var power = var_2;\n  while (Math.pow(n, power) <= c) {\n    if (Math.pow(n, power) == c) {\n      return true;\n    }\n    power++;\n  }\n  return false;\n}\n\n"], ["/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n */\n\nconst iscube = (a) => {\n  a = Math.abs(a);\n  return (a == Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3));\n}\n"], ["function countHexDigits(num) {\n  const hexKey = (num) => {\n    var primes = \"2357BD\",\n        total = 0;\n    for (let i = 0; i < num.length; i++) {\n      if (num[i] === '0' || num[i] === '1' || num[i] === '2' || num[i] === '3' || num[i] === '4' || num[i] === '5' || num[i] === '6' || num[i] === '7' || num[i] === '8' || num[i] === '9' || num[i] === 'A' || num[i] === 'B' || num[i] === 'C' || num[i] === 'D' || num[i] === 'E' || num[i] === 'F') {\n        total++;\n      } else {\n        if (isPrime(parseInt(num[i])) && total < 2) {\n          total++;\n        }\n      }\n    }\n    return total;\n  }\n\n  function isPrime(n) {\n    if (n < 2) return false;\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n      if (n % i === 0) return false;\n    }\n    return true;\n  }\n\n  return hexKey(num);\n}\n\n\n\n\n\n\n"], ["/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n*/\nconst wvxinzoToYrmary = (decimal) => {\n  return \"db\" + decimal.toString(2) + \"db\";\n}\n"], ["const { isPalindrome } = require('palindrome');\n\nfunction isHappy(s) {\n  if (s.length < 3)\n    return false;\n\n  const map = new Map();\n\n  for (let r = 0; r < s.length - 2; r++) {\n    const str = s[r].toString();\n    const next = s[r + 1].toString();\n    const prev = s[r - 1].toString();\n\n    if (map.has(str) && map.has(next) && map.has(prev)) {\n      return false;\n    }\n\n    map.set(str, next);\n    map.set(next, prev);\n  }\n\n  return true;\n}\n\n// To get the result of the function\n\n\n\n\n"], ["``javascript\n/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n*/\nconst numericalLetterGrade = (var_1) => {\n  let var_4 = []\n  for (let var_2 = 0, var_3 = var_1.length; var_2 < var_3; var_2++) {\n    let var_0 = var_1[var_2]\n    if (var_0 == 4.0) {\n      var_4.push('A+')\n    } else if (var_0 > 3.7) {\n      var_4.push('A')\n    } else if (var_0 > 3.3) {\n      var_4.push('A-')\n    } else if (var_0 > 3.0) {\n      var_4.push('B+')\n    } else if (var_0 > 2.7) {\n      var_4.push('B')\n    } else if (var_0 > 2.3) {\n      var_4.push('B-')\n    } else if (var_0 > 2.0) {\n      var_4.push('C+')\n    } else if (var_0 >"], ["const primeLength = (string) => {\n  let len = string.length;\n\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i === 0) { return false }\n  }\n  return true;\n}\n\n"], ["const startsOneEnds = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === 9) {\n      count += 2;\n    }\n    if (i > 9) {\n      count += 1;\n    }\n  }\n  return count;\n}\n"], ["const var_0 = 0;\nconst var_1 = 0;\nconst var_2 = 10;\n\nconst solve = (N) => {\n  let t = var_0;\n  while (N > var_1) {\n    t += N % var_2;\n    N = Math.floor(N / var_2);\n  }\n  return t.toString(2);\n}\n"], ["const util = require('util');\n\nfunction add(lst) {\n  let t = 0;\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i];\n    }\n  }\n  return t;\n}\n\nmodule.exports = add;\n"], ["const var_0 = 0;\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n */\nconst antiShuffle = (s) => {\n  let arr = s.split(/\\s/)\n  for (let i = var_0; i < arr.length; i = i + 1) {\n    const var_1 = 0;\n    for (let j = var_1; j < arr[i].length; j = j + 1) {\n      const var_2 = 1;\n      let ind = j\n      for (let k = j + var_2; k < arr[i].length; k = k + 1) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n    }\n  }\n  return arr.join(' ')\n}\n\n// Example usage:\n\n\n\n"], ["class TrieNode {\n  constructor() {\n    this.children = {};\n    this.isEndOfWord = false;\n  }\n}\n\nclass Trie {\n  constructor() {\n    this.root = new TrieNode();\n  }\n\n  insert(word) {\n    let node = this.root;\n    for (let char of word) {\n      if (!node.children[char]) node.children[char] = new TrieNode();\n      node = node.children[char];\n    }\n    node.isEndOfWord = true;\n  }\n\n  search(word) {\n    let node = this.root;\n    for (let char of word) {\n      if (!node.children[char]) return false;\n      node = node.children[char];\n    }\n    return node.isEndOfWord;\n  }\n}\n\nfunction getRow(lst, x) {\n  let t = [];\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (x == lst[i][j]) {\n        t.push([i, j]);\n      }\n    }\n  }\n  t.sort((a, b) => a[0] - b[0]);\n  t.sort((a, b) => b[1] - a[1]);\n  return t;\n}\n"], ["function sortArray(array) {\n  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        [arr[ind], arr[k]] = [arr[k], arr[ind]]\n      }\n    }\n  }\n  return arr\n}\n"], ["/**\n * Create a function encrypt that takes a string as an argument and\n * returns a string encrypted with the alphabet being rotated. \n * The alphabet should be rotated in a manner such that the letters \n * shift down by two multiplied to two places.\n */\nconst encrypt = (string) => {\n  let result = ''\n  for (let j = 0; j < string.length; j++) {\n    let c = string.charCodeAt(j) + 4\n    if (c > 122) { c -= 26 }\n    result += String.fromCharCode(c)\n  }\n  return result\n}\n\n// Example usage:\n\n\n\n\n"], ["/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n */\nconst nextSmallest = (var_4) => {\n  let var_0 = var_4\n  for (let var_2 = 0; var_2 < var_0.length; var_2++) {\n    let var_1 = var_2\n    for (let var_3 = 1 + var_2; var_3 < var_0.length; var_3++) {\n      if (var_0[var_3] < var_0[var_1]) {\n        var_1 = var_3\n      }\n    }\n  }\n  return var_1\n}\n"], ["const isBored = (string) => {\n  let i = 0\n  if (string[0] == 'I' && string[1] == ' ') { i = 1 }\n  for (let j = 0; j < string.length; j++) {\n    if (string[j] == '.' || string[j] == '!' || string[j] == '?') {\n      if (string[j + 1] == ' ' && string[j + 2] == 'I' && string[j + 3] == ' ') {\n        return 1\n      }\n    }\n  }\n  return 0\n}\n"], ["/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (0 === x % 1 && 0 === y % 1 && 0 === z % 1 && (z === x + y || y === x + z || y + z === x)) {\n    return true\n    let temp_var_4 = 9.9;\n    if (temp_var_4 < 9.12) {\n      temp_var_4 = 1 + temp_var_4;\n    }\n  }\n  return false;\n}\n"], ["Complete code (including all the content of the code you provided and the code I generated)\n-----------------------------\n/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n */\n\nconst encode = (var_1) => {\n  let var_3 = ''\n  for (let var_0 = 0; var_0 < var_1.length; var_0 = var_0 + 1) {\n    let var_2 = var_1.charCodeAt(var_0);\n    if (var_2 > 96) { var_2 = var_2 - (32) }\n    var_3 += String.fromCharCode(var_2 + 2);\n  }\n  return var_3;\n}"], ["function sumOfDigits(lst) {\n  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n      let temp_var_6 = 9.9;temp_var_6 = temp_var_6 + 1;\n    }\n    if (p === 1) { t += lst[i].toString().split('').reduce((acc, curr) => acc + parseInt(curr), 0); }\n  }\n  return t;\n}\n\n//You are given a list of integers.\n//You need to find the largest prime value and return the sum of its digits.\n"], ["/**\n * Given a dictionary, return true if all keys are strings in lower \n * case or all keys are strings in upper case, else return false.\n * The function returns false is the given dictionary is empty.\n * \n * @param {Object} obj - The input dictionary\n * @returns {boolean} - True if all keys are strings in lower or upper case, false otherwise\n */\nconst checkDictCase = (obj) => {\n  let i = 0\n  let ii = 1\n  let bi = 1\n  for (let item in obj) {\n    i++\n    if (item !== item.toUpperCase() && item !== item.toLowerCase()) {\n      bi = 0\n      break\n    }\n  }\n  return bi === 1\n}\n"], ["let primeNumbers = [];\nlet i = 2;\nfunction isPrime(n) {\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n}\n\nfunction countUpTo(m) {\n  while (m > 0) {\n    if (isPrime(m)) {\n      primeNumbers.push(m);\n    }\n    m--;\n  }\n  return primeNumbers;\n}\n\nbegin to write code\n"], ["const https = require('https');\n\nconst multiply = (a, b) => {\n  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  const num1 = a.toString().split('').reverse().join('');\n  const num2 = b.toString().split('').reverse().join('');\n  const product = parseInt(num1) * parseInt(num2);\n  return product;\n}\n"], ["const var_0 = 0;\nconst var_1 = 0;\nconst var_2 = 2;\nconst var_3 = 'A';\nconst var_4 = 'E';\nconst var_5 = 'I';\nconst var_6 = 'O';\nconst var_7 = 'U';\nconst var_8 = 1;\n\n/**\n * Given a string s, count the number of uppercase vowels in even indices.\n *\n * For example:\n * countUpper('aBCdEf') returns 1\n * countUpper('abcdefg') returns 0\n * countUpper('dBBE') returns 0\n */\nconst countUpper = (s) => {\n  let p = var_0;\n  for (let i = var_1; i < s.length; i = i + var_2) {\n    const var_9 = 'A';\n    const var_10 = 'E';\n    const var_11 = 'I';\n    const var_12 = 'O';\n    const var_13 = 'U';\n    if (s[i] == var_9 || s[i] == var_10 || s[i] == var_11 || s[i] == var_12 || s[i] == var_13) {\n      p = p + var_8;\n    } else {\n      p = var_0;\n    }\n  }\n  return p;\n};\n\n"], ["const var_0 = 1;\nconst var_1 = 0.5;\nconst var_2 = 0.5;\n\nconst closestInteger = (value) => {\n  value = Number(value)\n  let t = value % var_0 \n  if (t < var_1  && t > -var_2 ) { value -= t }\n  return Math.round(value)\n}\n"], ["const var_3 = 3;\nconst var_4 = 2;\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (var_1) => {\n  let var_2 = [];\n  for (let var_0 = var_1; var_0 < var_1 * var_3; var_0 += var_4) {\n    var_2.push(var_0);\n  }\n  return var_2;\n}\n"], ["function wordsString(string) {\n  let s = ''\n  let w = []\n  let i = 0\n  for (let j = 0; j < string.length; j++) {\n    if (string[j] == ' ' || string[j] == ',') {\n      if (i == 0) {\n        i = 1;\n        w.push(s);\n      }\n      s = ''\n      w.push(string[j])\n    } else {\n      s += string[j]\n    }\n  }\n  if (i == 0) {\n    w.push(s)\n  }\n  return w;\n}\n\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return an array of the words.\n// For example:\n// wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n// wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n"], ["const zlib = require('zlib');\n\n/* This function takes two positive numbers x and y and returns the biggest even integer number that is in the range [x, y] inclusive. If there's no such number, then the function should return -1. */\n\nconst chooseNum = (x, y) => {\n  let i = y;\n  for (; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n}\n\n"], ["const crypto = require('crypto');\n\n/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n*/\n\nconst roundedAvg = (n, m) => {\n  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return (BigInt(k).toString(2).padStart(8, '0')).replace(/^0+/, '') || '-1'\n}\n\n"], ["/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n*/\nconst uniqueDigits = (x) => {\n  let p = []\n  {\n      let i = 0;\n      for (; i < x.length; i++) {\n      let h = x[i]\n      let boo = 1\n      while (h > 0) {\n        let r = h % 10\n        if (r % 2 == 0) {\n          boo = 0;\n          break;\n        }\n        h = (h - r) / 10\n      }\n      if (boo === 1) {\n        p.push(h)\n      }\n  }\n  p.sort((a, b) => a - b)\n  return p\n}\n"], ["``javascript\n/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n*/\nfunction byLength(arr) {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { result.push(arr[i]); }\n  }\n  result.sort((a, b) => b - a);\n  for (let i = 0; i < result.length; i++) {\n    let ind = i;\n    for (let k = 1 + i; k < result.length; k++) {\n      if (result[k] > result[ind]) {\n        ind = k;\n      }\n    }\n    result[i] = getDigitName(result[i]);\n  }\n  return result;\n}\n\nfunction getDigitName(num) {\n  switch (num) {\n    case 1: return \"One\";\n    case 2: return \"Two\";\n    case 3: return \"Three\";\n    case 4: return \"Four\";\n    case 5: return \"Five\";\n    case 6: return \"Six\";\n    case 7: return \"Seven\";\n    case 8: return \"Eight\";\n    case 9: return \"Nine\";\n    default: return \"\";\n"], ["/**\n * Implement the function f that takes n as a parameter,\n * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n * or the sum of numbers from 1 to i otherwise.\n * i starts from 1.\n * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n * Example:\n * f(5) == [1, 2, 6, 24, 15]\n */\n\nconst f = (n) => {\n  let f = 1;\n  let p = 0;\n  let k = [];\n  for (let i = 1; i <= n; i = i + 1) {\n    p = p + (i);\n    if (i % 2 === 0) {\n      k.push(f);\n    } else {\n      k.push(f * i);\n    }\n  }\n  return k;\n}\n"], ["function evenOddPalindrome(n) {\n  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] !== k[k.length - j - 1]) {\n        p = 0\n      }\n    }\n    if (p === 1) e++\n    if (p === 0) o++\n  }\n  return [e, o]\n}\n"], ["const var_0 = 0;\nconst var_1 = 0;\nconst arr = (arr) => {\n  let p = var_0 \n  for (let i = var_1 ; i < arr.length; i++) {\n    const var_2 = 0;\n    let h = arr[i]\n    if (h > var_2 ) {\n      p++;\n      continue;\n    }\n    var_2 = h.toString().split('').reduce((a, b) => a + parseInt(b), 0);\n    if (var_2 > 0) {\n      p++;\n    }\n  }\n  return p;\n};\n\n// >>> countNums([]) == 0\n// >>> countNums([-1, 11, -11]) == 1\n// >>> countNums([1, 1, 2]) == 3\n"], ["const zero = 0;\nconst one = 0;\nconst two = 0;\nconst three = 1;\nconst four = 1;\nconst five = 1;\nconst six = 0;\n\n/*We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  if (arr.length == zero ) { return true }\n  let k = one \n  let len = arr.length\n  for (let i = two ; i < len; i++) {\n    let t = three ;\n    for (let j = four ; j < len; j++) {\n      if (arr[j] < arr[j - five ]) {\n        t = six ;\n        k = j\n      }\n    }\n    arr[k] = arr[j]\n  }\n  return arr.every((val, index) => val >= arr[index])\n}\n"], ["/* In this problem, you will implement a function that takes two lists of numbers,\n * and determines whether it is possible to perform an exchange of elements\n * between them to make lst1 a list of only even numbers.\n * There is no limit on the number of exchanged elements between lst1 and lst2.\n * If it is possible to exchange elements between the lst1 and lst2 to make\n * all the elements of lst1 to be even, return \"YES\".\n * Otherwise, return \"NO\".\n * For example:\n * exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n * exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n * It is assumed that the input lists will be non-empty.\n */\nconst exchange = (lst1, lst2) => {\n  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i = i + 1) {\n    if (lst1[i] % 2 == 0) { t = t + 1 }\n  }\n  return t % 2 === 0 ? \"YES\" : \"NO\"\n}\n\n// Test cases\n\n\n"], ["function histogram(foo) {\n  let b = {}\n  let c = foo.split(/\\s/)\n  if ('' == foo) { c = [] }\n  for (m in c) {\n    if (c[m] in b) {\n      b[c[m]]++\n    }\n    else {\n      b[c[m]] = 1\n    }\n  }\n  return Object.keys(b).reduce((acc, key) => {\n    acc[key] = b[key]\n    return acc\n  }, {})\n}\n\n// Example usage\n\n\n\n\n\n"], ["const var_0 = '';\nconst var_1 = 0;\nconst var_2 = 1;\nconst var_3 = 0;\nconst var_5 = 1;\n\nfunction reverseDelete(s, c) {\n  var_0 = s;\n  var_1 = 0;\n  var_2 = 1;\n  var_3 = 0;\n  var_5 = 1;\n\n  for (var_1 = 0; var_1 < s.length; var_1++) {\n    var_2 = 1;\n    for (var_3 = 0; var_3 < c.length; var_3++) {\n      if (s[var_1] == c[var_3]) {\n        var_2 = 0;\n      }\n    }\n    if (var_2 == 0) {\n      s = s.slice(0, var_1) + s.slice(var_1 + 1);\n    } else {\n      var_0 = s;\n    }\n  }\n\n  var_5 = s === var_0 ? true : false;\n  return [var_0, var_5];\n}\n"], ["/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n*/\nconst oddCount = (lst) => {\n  let d = []\n  {\n      let i = 0;\n      for (; i < lst.length; i++) {\n        let p = 0;\n        let h = lst[i].length\n        {\n            let j = 0;\n            for (; j < h; j++) {\n                if (lst[i][j] % 2 !== 0) {\n                    p++;\n                }\n            }\n        }\n        d.push(`the number of odd elements ${p}n the str${i} of the ${i}put.`);\n      }\n  }\n  return d;\n}\n"], ["/**\n * Given an array of integers nums, find the minimum sum of any non-empty sub-array\n * of nums.\n */\nfunction minSubArraySum(nums) {\n  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let h = 0;\n      (function() {let temp_var_7 = 9.9; temp_var_7 = temp_var_7 + 1;})();\n      for (let k = i; k < j; k++) {\n        h += nums[k]\n        min = Math.min(min, h)\n      }\n    }\n  }\n  return min\n}\n\nbegin to write code\n"], ["const dgram = require('dgram');\n\n/**\n * You are given a rectangular grid of wells. Each row represents a single well,\n * and each 1 in a row represents a single unit of water.\n * Each well has a corresponding bucket that can be used to extract water from it,\n * and all buckets have the same capacity.\n * Your task is to use the buckets to empty the wells.\n * Output the number of times you need to lower the buckets.\n *\n * Example 1:\n * Input: \n *      grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n *      bucket_capacity : 1\n * Output: 6\n *\n * Example 2:\n * Input: \n *      grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n *      bucket_capacity : 2\n * Output: 5\n *\n * Example 3:\n * Input: \n *      grid : [[0,0,0], [0,0,0]]\n *      bucket_capacity : 5\n * Output: 0\n *\n * Constraints:\n *      * all wells have the same length\n *      * 1 <= grid.length <= 10^2\n *      * 1 <= grid[:,1].length <= 10^2\n *      * grid[i][j] -> 0 | 1\n *      * 1 <= capacity <= 10\n */\n\nconst maxFill = (grid, capacity) => {\n  let p = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) {\n        m++;\n      }\n    }\n    if (m > 0) {\n      p += Math.ceil(m / capacity);\n    }\n  }\n  return p;\n};\n\nmodule.exports = maxFill;\n"], ["function sortArray(arr) {\n  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      if (f1 === f2) {\n        p[k] = p[ind]\n        ind++\n      } else if (f1 < f2) {\n        p[k] = w2\n      } else {\n        p[k] = w1\n      }\n    }\n  }\n  return p\n}\n\n\n\n\n"], ["/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0;\n    for (let j = 0; j < t[i].length; j++) {\n      if ('bcdfghjklmnpqrstvwxyz'.indexOf(t[i][j]) >= 0) {\n        l++\n      }\n    }\n    if (l == n) {\n      k.push(t[i])\n    }\n  }\n  return k\n}\n"], ["const vowel = {\n  'a': 'A',\n  'e': 'E',\n  'i': 'I',\n  'o': 'O',\n  'u': 'U'\n};\n\nconst getClosestVowel = (word) => {\n  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n    ) {\n      return vowel[word[i]];\n    }\n  }\n  return '';\n};\n\n// Test cases\n\n\n\n\n"], ["const stack = [];\n\nfunction matchParens(lst) {\n  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (!(w1[i] == '(')) { y-- }\n    else { y++ }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n    stack.push(w1[i]);\n  }\n  for (let i = 0; i < w1.length; i++) {\n    if (!(stack.pop() == '(')) { u = 0; break; }\n  }\n  return u;\n}\n\nfunction matchParens2(lst) {\n  let w1 = lst[0] + lst[1];\n  let y = 0;\n  let u = 1;\n  for (let i = 0; i < w1.length; i++) {\n    if (!(w1[i] == '(')) { y-- }\n    else { y++ }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  return u;\n}\n\nfunction matchParens3(lst) {\n  let w1 = lst[0] + lst[1];\n  let y = 0;\n  let u = 1;\n  for (let i = 0; i < w1.length; i++) {\n    if (!(w1[i] == '(')) { y-- }\n    else { y++ }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  let stack = [];\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') {\n      stack.push(w1[i]);\n    } else {\n      if (stack.length == 0) {\n        u = 0;\n        break;\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  return u;\n}\n\n\n\n"], ["class Solution {\n  maximum(arr, k) {\n    let p = arr\n    for (let j = 0; j < p.length; j++) {\n      let ind = j\n      for (let k = 1 + j; k < p.length; k++) {\n        if (p[k] < p[ind]) {\n          ind = k\n        }\n      }\n    }\n    return p.slice(0, k).sort((a, b) => b - a);\n  }\n}\n\nmodule.exports = Solution;\n"], ["class Solution {\n  static solution(var_1) {\n    let var_2 = 0\n    for (let var_0 = 0; var_0 < var_1.length; var_0 += 2) {\n      if (var_1[var_0] % 2 == 1) {\n        var_2 += var_1[var_0]\n      }\n    }\n    return var_2\n  }\n}\n"], ["/**\n * Given a non-empty array of integers arr and an integer k, return\n * the sum of the elements with at most two digits from the first k elements of arr.\n *\n * @param {number[]} arr\n * @param {number} k\n * @returns {number}\n */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n"], ["class CollatzConjecture {\n  getOddCollatz(n) {\n    let p = [];\n    let g = n;\n    while (1) {\n      let u = 0;\n      for (let i = 0; i < p.length; i++) {\n        if (g === p[i]) {\n          u = 1;\n          break;\n        }\n      }\n      if (u === 1) {\n        break;\n      }\n      p.push(g);\n      if (g % 2 === 0) {\n        g = Math.floor(g / 2);\n      } else {\n        g = 3 * g + 1;\n      }\n    }\n    return p.sort((a, b) => a - b);\n  }\n}\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\nconst collatzConjecture = new CollatzConjecture();\n\n"], ["//You have to write a function which validates a given date string and\n//returns true if the date is valid otherwise false.\n//The date is valid if all of the following rules are satisfied:\n//This is a comment line.\n//1. The date string is not empty.\n//2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n//3. The months should not be less than 1 or higher than 12.\n//4. The date should be in the format: mm-dd-yyyy\n//\n//for example:\n//validDate('03-11-2000') => true\n//\n//validDate('15-01-2012') => false\n//\n//validDate('04-0-2040') => false\n//\n//validDate('06-04-2020') => true\n//\n//validDate('06/04/2020') => false\nconst validDate = (date) => {\n  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if (t[0] < 1 || t[0] > 12) { return false }\n  if (t[1] < 1 || t[1] > 31) { return false }\n  if (t[2] < 1 || t[2] > 12) { return false }\n  if (t[2] == 2 && t[2] > 29) { return false }\n  if (t[2] < 1 || t[2] > 30) { return false }\n  if (t[2] == 2 && t[2] > 28) { return false }\n  return true\n}\n"], ["function splitWords(var_1) {\n  let var_0 = var_1.split(/\\s/)\n  if (var_0.length > 1) {\n    return var_0\n  } else {\n    var_0 = var_1.split(/,/)\n    if (var_0.length > 1) {\n      return var_0\n    }\n  }\n}\n"], ["const events = require('events');\n"], ["function isPrime(n) {\n  if (n <= 1) return false\n  if (n === 2) return true\n  if (n % 2 === 0) return false\n  for (let i = 3; i <= Math.sqrt(n); i += 2) {\n    if (n % i === 0) return false\n  }\n  return true\n}\n\nfunction intersection(interval1, interval2) {\n  let lo = Math.max(interval1[0], interval2[0])\n  let hi = Math.min(interval1[1], interval2[1])\n  if (lo > hi) return \"NO\"\n  if (isPrime(lo) && isPrime(hi)) return \"YES\"\n  return \"NO\"\n}\n\n"], ["/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n */\nconst prodSigns = (array) => {\n  if (0 == array.length) {\n    return null;\n  }\n\n  let c = 1;\n  let d = 0;\n  for (let j = 0; j < array.length; j++) {\n    if (array[j] === 0) {\n      d += 1;\n    } else if (array[j] < 0) {\n      d += 1;\n    } else {\n      c *= array[j];\n    }\n  }\n\n  return c * d;\n};\n\nexport default prodSigns;\n"], ["const minPath = (grid, k) => {\n  let m = 0;\n  let n = 0;\n  for (let i = 0; i < grid.length; i = i + 1) {\n    for (let j = 0; j < grid.length; j = j + 1) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n\n  let visited = new Array(grid.length * grid[0].length).fill(0).map(() => new Array(grid.length * grid[0].length).fill(0));\n  let queue = [[m, n, 1]];\n  let directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n  let temp_var_7 = 9.9;\n  let temp_var_8 = 9.9;\n\n  while (queue.length > 0) {\n    let [x, y, distance] = queue.shift();\n    if (visited[x][y] == 0) {\n      visited[x][y] = distance;\n      for (let i = 0; i < directions.length; i++) {\n        let newX = x + directions[i][0];\n        let newY = y + directions[i][1];\n        if (newX >= 0 && newX < grid.length && newY >= 0 && newY < grid.length && grid[newX][newY] == 1) {\n          queue.push([newX, newY, distance + 1]);\n        }\n      }\n    }\n  }\n\n  let result = [];\n  for (let i = 0; i < grid.length; i = i + 1) {\n    for (let j = 0; j < grid.length; j = j + 1) {\n      if (grid[i][j] == 1) {\n        result.push(grid[i][j]);\n      }\n    }\n  }\n\n  return result;\n};\n"], ["const child_process = require('child_process');\n\nbegin to write code\nconst tri = (n) => {\n  if (0 == n) { return [1] }\n  if (1 == n) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (0 == i % 2) {\n      p.push(1 + (i / 2))\n    } else if (i % 2 === 1) {\n      p.push(p[i - 1] + p[i - 2] + p[i + 1])\n    }\n  }\n  return p\n}\n\n"], ["const { gcd } = require('mathjs');\n\nfunction digits(n) {\n  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 === 1) {\n      k *= y\n    }\n    p *= 10\n    n = Math.floor(n / 10)\n  }\n  if (k === 0) {\n    return 0\n  } else {\n    return Math.floor(p / gcd(p, k))\n  }\n}\n\n// Example usage\n\n\n\n"], ["/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n */\nconst isNested = (string) => {\n  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  {\n    let i = 0;\n    while(i < string.length){\n      if (string[i] == '[') {\n        opening_bracket_index.push(i)\n      }\n      else {\n        closing_bracket_index1.push(i)\n        i++;\n      }\n    }\n  }\n\n  for(let i = 0; i < string.length; i++){\n    if(opening_bracket_index.includes(i)){\n      let j = i + 1;\n      while(j < string.length && string[j] != ']'){\n        j++;\n      }\n      if(j == string.length){\n        return true\n      }\n      opening_bracket_index.splice(opening_bracket_index.indexOf(i), 1);\n    }\n  }\n  return false\n}\n"], ["function sumSquares(var_1) {\n  let var_2 = 0\n  for (let var_0 = 0; var_0 < var_1.length; var_0++) {\n    let var_3 = var_1[var_0]\n    if (var_3 % 1 != 0) {\n      let temp_var_5 = 9.9;while (temp_var_5 < 9.12) {temp_var_5 = temp_var_5 + 1;}\n      if (var_3 > 0) { var_3 = Math.ceil(var_3) - Math.ceil(var_3 % 1) + 1 }\n      var_2 += var_3 ** 2;\n    }\n  }\n  return var_2;\n}\n\n// Example usage\n\n\n\n\n\n"], ["function checkIfLastCharIsALetter(txt) {\n  let len = txt.length;\n  if (len == 0) { return false }\n  let b = txt[len - 1].charCodeAt();\n  if (b >= 97 && b <= 122) { return true; }\n  else { return false; }\n}\n\n// Begin to write code\n"], ["/* Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n//This is a comment line.\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n */\nconst canArrange = (arr) => {\n  if (arr.length == 0) { return -1 }\n  let result = 0;\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\n"], ["/**\n * Create a function that returns a tuple (a, b), where 'a' is\n * the largest of negative integers, and 'b' is the smallest\n * of positive integers in a list.\n * If there is no negative or positive integers, return them as null.\n *\n * @param {number[]} lst - A list of integers.\n * @returns {[number, number]} A tuple containing the largest negative integer and the smallest positive integer.\n */\nconst largestSmallestIntegers = (lst) => {\n  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i = i + 1) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  return [a, b]\n}\n\n"], ["function compareOne(a, b) {\n  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  let temp_var_5 = 9.9;while (temp_var_5 < 9.12) {temp_var_5 = temp_var_5 + 1;}\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) return aa\n  else if (aa < bb) return bb\n  else return null\n}\n"], ["/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true*/\n\nconst isEqualToSumEven = (m) => {\n  const var_0 = 8;\n  const var_1 = 2;\n  const var_2 = 0;\n  return (m >= var_0  && m % var_1  == var_2 )\n}\n\n"], ["/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n*/\nconst specialFactorial = (n) => {\n  let k = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = k;\n    (function() {let temp_var_5 = 9.9; temp_var_5 = temp_var_5 + 1;})();\n    while (y > 0) {\n      y--;\n      t = y * t;\n    }\n    k = y;\n  }\n  return t;\n}\n"], ["const var_0 = '';\nconst var_1 = 0;\nconst var_2 = 0;\nconst var_3 = ' ';\nconst var_4 = 0;\nconst var_5 = 1;\nconst var_6 = 2;\nconst var_7 = 3;\nconst var_8 = 4;\n"], ["``javascript\n/* Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'.\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n*/\nconst fileNameCheck = (file_name) => {\n  let t = file_name.split(/\\./);\n  if (t.length > 3) { return \"No\"; }\n  const var_1 = 'No';\n  if (t[0] === '' || t[0] !== t[1]) { return var_1; }\n  const var_2 = 'No';\n  if (t[1] === '' || t[1] !== t[2]) { return var_2; }\n  const var_3 = 'No';\n  if (t[3] === '' || t[3] !== t[4]) { return var_3; }\n  const var_4 = 'No';\n  if (t[4] === '' || t[4] !== t[5]) { return var_4; }\n  const var_5 = 'No';\n  if (t[5] === '' || t[5] !== t[6]) { return var_5; }\n  const var_6 = 'No';\n  if (t[7] === '' || t[7] !== t[8]) { return var_6; }\n  const var_7 = 'No';\n  if (t[8] === '' || t[8] !== t[9]) { return var_7; }\n  const var_9 = 'No';\n  const var_10 = t[9];\n  if (var_10 === t[10]) { return"], ["function sumSquares(lst) {\n  let y = 0;\n  {\n      let i = 0;\n      while(i < lst.length){\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i]; i++; }\n  }\n  return y;\n}\n"], ["const primeFilter = (sentence) => {\n  let words = sentence.split(/\\s+/);\n  let primeWords = [];\n  for (let word of words) {\n    let len = word.length;\n    if (len > 1 && isPrime(len)) {\n      primeWords.push(word);\n    }\n  }\n  return primeWords.join(' ');\n};\n\nfunction isPrime(num) {\n  if (num <= 1) return false;\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) return false;\n  }\n  return true;\n}\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n//This is a comment line.\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\n"], ["const var_0 = 0;\nconst var_1 = 0;\nconst gcd = (x, y) => {\n  if (y === 0) return x;\n  return gcd(y, x % y);\n};\n\nconst simplify = (x, n) => {\n  let a = x.split(/\\//);\n  let b = n.split(/\\//);\n  let m = Number(a[var_0]) * Number(b[var_1]);\n  let g = gcd(Number(m[var_0]), Number(m[var_1]));\n  return Number(m[var_0] / g) === Number(m[var_1] / g);\n}\n\n// begin to write code\n"], ["/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n*/\n\nconst orderByPoints = (nums) => {\n  let p = nums\n  for (let j = p.length - 2; j >= 0; j = j - 1) {\n    for (let k = 0; k <= j; k = k + 1) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      for (let i = k + 1; i <= j; i++) {\n        if (p[i] < h + d) {\n          [p[i], p[k]] = [p[k], p[i]]\n        }\n        if (p[i] < h + d) {\n          [p[i], p[j]] = [p[j], p[i]]\n        }\n      }\n    }\n  }\n  return p\n}\n"], ["class NumberFilter {\n  specialFilter(nfms) {\n    let p = 0\n    for (let i = 0; i < nfms.length; i++) {\n      if (nfms[i] < 10) { continue }\n      let y = nfms[i].toString()\n      if (y[0] % 2 !== 0 && y[y.length - 1] % 2 !== 0) {\n        p++\n      }\n    }\n    return p\n  }\n}\n\n// Write a function that takes an array of numbers as input and returns\n// the number of elements in the array that are greater than 10 and both\n// first and last digits of a number are odd (1, 3, 5, 7, 9).\nconst specialFilter = new NumberFilter()\n"], ["const getMaxTriples = (n) => {\n  let y = [];\n  for (let i = 1; i <= n; i++) {\n    y.push(1 + i * i - i);\n  }\n  let u = 0;\n  (function() {let temp_var_5 = 9.9; temp_var_5 = temp_var_5 + 1;})();\n  for (let i = 0; i < n - 2; i++) {\n    if (y[i] % 3 === 0) {\n      u++;\n    }\n    for (let j = i + 1; j < n - 1; j++) {\n      if (y[i] + y[j] % 3 === 0 && y[j] + y[i] % 3 === 0) {\n        u++;\n      }\n      for (let k = j + 1; k < n - 1; k++) {\n        if (y[i] + y[j] + y[k] % 3 === 0 && y[i] + y[j] + y[k] % 3 === 0) {\n          u++;\n        }\n      }\n    }\n  }\n  return u;\n}\n"], ["/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n//This is a comment line.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\n\nconst bf = (planet1, planet2) => {\n  let\n    y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n    if (lo != -1 && hi != -1) {\n      u.push(y[lo], y[hi])\n    }\n  }\n  if (lo == -1 || hi == -1) {\n    return []\n  }\n  u.sort((a, b) => {\n    if (a[0] == b[0]) {\n      return a[1] - b[1]\n    }\n    return a[0] - b[0]\n  })\n  return u\n}\n"], ["function sortedListSum(lst) {\n  let p = lst.filter((str) => str.length % 2 === 0);\n  p.sort((a, b) => a.length - b.length || a.localeCompare(b));\n  return p;\n}\n"], ["const readline = require('readline');\n\nbegin to write code\nconst xOrY = (n, c, y) => {\n  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) {\n      return c\n    }\n  }\n  return y\n}\n\n"], ["const var_0 = 0;\nconst var_1 = 0;\nconst var_2 = 2;\nconst var_3 = 1;\nconst var_4 = 0;\n\nconst doubleTheDifference = (lst) => {\n  let p = var_0;\n  for (let i = var_1; i < lst.length; i++) {\n    if (lst[i] % var_2 === var_3 && lst[i] > var_4) {\n      p += lst[i] * lst[i];\n    }\n  }\n  return p;\n}\n\n"], ["function compare(game, guess) {\n  return guess.map((x, i) => {\n    if (x === game[i]) {\n      return 0;\n    } else {\n      return Math.abs(x - game[i]);\n    }\n  });\n}\n"], ["``javascript\nlet package = 'fs';\nlet beginToWriteCode = `\n  const fs = require('${package}');\n`;\n\nlet beginToWriteCode2 = `\n  const fs = require('${package}');\n`;\n\nlet beginToWriteCode3 = `\n  const fs = require('fs');\n`;\n\nlet beginToWriteCode4 = `\n  const fs = require('./fs');\n`;\n\nlet beginToWriteCode5 = `\n  const fs = require('./fs');\n`;\n\nlet beginToWriteCode6 = `\n  const fs = require('fs');\n`;\n\nlet beginToWriteCode7 = `\n  const fs = require('./fs');\n`;\n\nlet beginToWriteCode8 = `\n  const fs = require('./fs');\n`;\n\nlet beginToWriteCode9 = `\n  const fs = require('./fs');\n`;\n\nlet beginToWriteCode10 = `\n  const fs = require('fs');\n`;\n\nlet beginToWriteCode11 = `\n  const fs = require('./fs');\n`;\n\nlet beginToWriteCode12 = `\n  const fs = require('./fs');\n`;\n\nlet beginToWriteCode13 = `\n  const fs = require('fs');\n`;\n\nlet beginToWriteCode14 = `\n  const fs = require('./fs');\n`;\n\nlet beginToWriteCode15 = `\n  const fs = require('./fs');\n`;\n\nlet beginToWriteCode16 = `\n  const fs = require('./fs');\n`;\n\nlet beginToWriteCode17 = `\n  const fs = require('fs');\n`;\n\nlet beginToWriteCode18 = `\n  const fs = require('./fs');\n`;\n\nlet beginToWriteCode19 = `\n  const fs = require('./fs');\n`;\n\nlet beginToWriteCode20 = `\n  const fs = require('fs');\n`;\n\nlet beginToWriteCode21 = `\n  const fs = require('./fs');\n`;\n\nlet beginToWriteCode22 = `\n  const fs = require('fs');\n`;\n\nlet beginToWriteCode23 = `\n  const fs = require('./fs');\n`;\n\nlet beginToWriteCode24 = `\n  const fs = require('./fs');\n`;\n\nlet beginToWriteCode25 = `\n  const fs = require('fs');\n`;\n\nlet beginToWriteCode26 = `\n  const fs = require('./fs');\n`;\n\nlet beginToWriteCode27 = `\n  const fs = require('fs');\n`;\n\nlet beginToWriteCode28 = `\n  const fs = require('./fs');\n`;\n\nlet beginToWriteCode29 = `\n  const fs = require('fs');\n`;\n\nlet beginToWriteCode30 = `\n  const fs"], ["/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\n\nconst cycpatternCheck = (a, b) => {\n  let l = b.length;\n  let pat = b + b;\n  for (let i = 0; i < a.length - l + 1; i = i + 1) {\n    for (let j = 0; j < l + 1; j = j + 1) {\n      let y = 1;\n      for (let k = 0; k < l; k = k + 1) {\n        if (b.substring(j, j + l) === pat.substring(i, i + l)) {\n          return true;\n        }\n        y = y * 2;\n      }\n    }\n  }\n  return false;\n}\n"], ["/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n*/\nconst evenOddCount = (num) => {\n  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  let temp_var_4 = 9.9;temp_var_4 = 1 + temp_var_4;\n  while (num > 0) {\n    temp_var_4 = Math.floor(num / 10);\n    if (temp_var_4 % 2 === 0) o++;\n    else e++;\n    num = Math.floor(num / 10);\n  }\n  return [o, e];\n}\n"], ["const child_process = require('child_process');\n\nfunction rightAngleTriangle(a, b, c) {\n  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c);\n}\n"], ["const findMax = (words) => {\n  let s = -1;\n  let u = -1;\n  if (words.length === 0) {\n    return '';\n  }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0;\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1;\n      for (let k = 0; k < words[i].length; k++) {\n        if (k !== j && words[i][k] !== words[i][j]) {\n          y = 0;\n          break;\n        }\n      }\n      if (y === 1) {\n        if (u === -1 || words[i].length > u.length) {\n          u = words[i];\n        }\n        if (u === -1 || words[i].length === u.length) {\n          u = words[i];\n        }\n      }\n    }\n  }\n  return u;\n}\n"], ["/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n */\nconst eat = (number, need, remaining) => {\n  if (need <= remaining) {\n    return [need + number, remaining - need]\n    let temp_var_4 = 9.9;\n    if (temp_var_4 < 9.12) {\n      temp_var_4 = temp_var_4 + 1;\n    }\n  }\n  return [need + number, remaining - need];\n};\n"], ["const dgram = require('dgram');\n\n/**\n * Given two lists operator, and operand. The first list has basic algebra operations, \n * and the second list is a list of integers. Use the two given lists to build the algebric \n * expression and return the evaluation of this expression.\n * \n * The basic algebra operations:\n * Addition ( + ) \n * Subtraction ( - ) \n * Multiplication ( * ) \n * Floor division ( // ) \n * Exponentiation ( ** ) \n * \n * Note:\n *   The length of operator list is equal to the length of operand list minus one.\n *   Operand is a list of of non-negative integers.\n *   Operator list has at least one operator, and operand list has at least two operands.\n */\nconst doAlgebra = (operator, operand) => {\n  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n      }\n    }\n  }\n  return operand[0]\n}\n\nmodule.exports = doAlgebra\n"], ["const solve = (string) => {\n  let x = 0;\n  let i = '';\n  for (let j = 0; j < string.length; j++) {\n    let c = string[j].charCodeAt();\n    if (c >= 65 && c <= 90) {\n      c += 32;\n      x = 1;\n    } else if (c >= 97 && c <= 122) {\n      c = c - 32;\n      x = 0;\n    }\n    i += String.fromCharCode(c);\n  }\n  return x ? i.split('').reverse().join('') : i;\n}\n"], ["/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (string) => {\n  if ('' == string) { return null }\n  var md = new js-md5();\n  md.update(string);\n  return md.getHash();\n}\n\n// Export the function to make it accessible\nexport default stringToMd5;\n"], ["/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n*/\nconst generateIntegers = (A, B) => {\n  if (A > B) {\n    let C = A;\n    A = B;\n    B = C;\n  }\n  let result = [];\n  for (let i = A; i <= B; i++) {\n    if (i % 2 === 0 && isDigitEven(i)) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nfunction isDigitEven(n) {\n  return n >= 10 && n % 2 === 0;\n}\n"]]