[["\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nstd::string remove_occ(std::string s, char ch) {\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == ch) {\n            s = s.substr(0, i) + s.substr(i + 1);\n            break;\n        }\n    }\n    return s;\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\nvector<vector<int>> sort_matrix(vector<vector<int>> m) {\n    sort(m.begin(), m.end(), [](const vector<int>& a, const vector<int>& b) {\n        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);\n    });\n    return m;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint find_volume(int l, int b, int h) {\n    // Calculate the volume of the triangular prism\n    return l * b * h;\n}\n\n"], ["\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nconst int n_o_o_f_c_h_a_r_s = 256;\nvector<char> str_to_list(const string& str) {\n    vector<char> temp;\n    for (char x : str) {\n        temp.push_back(x);\n    }\n    return temp;\n}\n\nstring lst_to_string(const vector<char>& list) {\n    return string(list.begin(), list.end());\n}\n\nvector<int> get_char_count_array(const string& str) {\n    vector<int> count(n_o_o_f_c_h_a_r_s, 0);\n    for (char c : str) {\n        count[c]++;\n    }\n    return count;\n}\n\nvoid remove_chars(const string& source, const string& chars_to_remove) {\n    vector<char> result;\n    for (char c : source) {\n        if (chars_to_remove.find(c) == string::npos) {\n            result.push_back(c);\n        }\n    }\n    return result;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint maximum_sum(const vector<vector<int>>& list1) {\n    int maxi = -100000;\n    for (const auto& x : list1) {\n        int sum = 0;\n        for (auto y : x) {\n            sum += y;\n            if (sum > maxi) {\n                maxi = sum;\n            }\n        }\n    }\n    return maxi;\n}\n\n"], ["\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint find_product(std::vector<int> arr, int n) {\n    std::sort(arr.begin(), arr.end());\n    int prod = 1;\n    for (int i = 0; i < n; i++) {\n        if (i == 0 || arr[i - 1] != arr[i]) {\n            prod *= arr[i];\n        }\n    }\n    return prod;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool check_k_elements(const std::vector<std::vector<int>>& test_list, int k) {\n    bool res = true;\n    for (const auto& tup : test_list) {\n        for (int ele : tup) {\n            if (ele != k) {\n                res = false;\n            }\n        }\n    }\n    return res;\n}\n\n"], ["\n#include<iostream>\n#include <cassert>\n\n// Function definition\nint binomial_coeff(int n, int k) {\n    if (k > n) {\n        return 0;\n    }\n    // Calculate binomial coefficient using the formula: C(n, k) = n! / (k!(n-k)!)\n    return static_cast<int>(std::binomial(n, k));\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint get_odd_occurrence(std::vector<int> arr, int arr_size) {\n    // Create a map to store the frequency of each element\n    unordered_map<int, int> frequency_map;\n\n    // Populate the frequency map\n    for (int num : arr) {\n        frequency_map[num]++;\n    }\n\n    // Find the element with an odd frequency\n    for (const auto& pair : frequency_map) {\n        if (pair.second % 2 != 0) {\n            return pair.first;\n        }\n    }\n\n    // If no odd frequency is found, return -1 (or any other appropriate value)\n    return -1;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <string>\n#include <cassert>\n\nbool check_equality(const std::string &s) {\n    return (s.front() == s.back());\n}\n\nint count_substring_with_equal_ends(const std::string &s) {\n    int result = 0;\n    int n = s.length();\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == s[n - 1 - i]) {\n            ++result;\n        }\n    }\n    return result;\n}\n\n"], ["\nusing namespace std;\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint max_prime_factors(int n) {\n    int max_prime = -1;\n    while (n % 2 == 0) {\n        max_prime = 2;\n        n >>= 1;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            max_prime = i;\n            n /= i;\n        }\n    }\n    if (n > 2) {\n        max_prime = n;\n    }\n    return max_prime;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint decimal_to_binary(int n) {\n    int b_number = 0;\n    int cnt = 0;\n    while (n != 0) {\n        int rem = n % 2;\n        int c = pow(10, cnt);\n        b_number += rem * c;\n        n /= 2;\n        cnt++;\n    }\n    return b_number;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_missing(std::vector<int>& ar, int n) {\n    int l = 0;\n    int r = n - 1;\n    while (l <= r) {\n        int mid = (l + r) / 2;\n        if (ar[mid] != mid + 1 && ar[mid - 1] == mid) {\n            return mid + 1;\n        } else if (ar[mid] > mid + 1) {\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return n + 1; // If no missing number is found, return n + 1\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint find_nth_digit(int p, int q, int n) {\n    int res = 0;\n    while (n > 0) {\n        n -= 1;\n        p *= 10;\n        // Find the position of the nth digit\n        int position = n / (p * 10);\n        // Calculate the value of the nth digit\n        res += p * (position % 10);\n    }\n    return res;\n}\n\n"], ["\n#include <cassert>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <sstream>\n\nstd::vector<std::string> sort_mixed_list(std::vector<std::string> mixed_list) {\n    std::vector<int> int_part;\n    std::vector<std::string> str_part;\n    for (const auto& item : mixed_list) {\n        if (!(isdigit(item[0]) || (item[0] == '-' && item.size() > 1 && isdigit(item[1])))) {\n            str_part.push_back(item);\n        }\n        else {\n            int_part.push_back(std::stoi(item));\n        }\n    }\n\n    // Sort the integers\n    std::sort(int_part.begin(), int_part.end());\n\n    // Sort the strings\n    std::sort(str_part.begin(), str_part.end());\n\n    // Combine the sorted integers and strings\n    std::vector<std::string> result;\n    result.insert(result.end(), int_part.begin(), int_part.end());\n    result.insert(result.end(), str_part.begin(), str_part.end());\n\n    return result;\n}\n\n"], ["#include <iostream>\n#include <queue>\n#include <string>\n#include <unordered_map>\n#include <cassert>\nusing namespace std;\n\nstring rearrange_string(string s) {\n    unordered_map<char, int> ctr;\n    for (char c : s) {\n        ctr[c]++;\n    }\n    auto comp = [](pair<int, char> left, pair<int, char> right) {\n        if (left.first == right.first) return left.second > right.second;\n        return left.first < right.first;\n    };\n    priority_queue<pair<int, char>, vector<pair<int, char>>, decltype(comp)> heap(comp);\n    for (auto& kv : ctr) {\n        heap.push(make_pair(kv.second, kv.first));\n    }\n    if (heap.top().first > (s.length() + 1) / 2) {\n        return \"\";\n    }\n    string ans = \"\";\n    while (!heap.empty()) {\n        auto top = heap.top();\n        heap.pop();\n        ans += top.second;\n        if (--top.first >= 0) {\n            heap.push(top);\n        }\n    }\n    return ans;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <cassert>\nusing namespace std;\n\nint find_sum(const vector<int>& arr) {\n    unordered_map<int, int> count;\n    for (int num : arr) {\n        count[num]++;\n    }\n    int sum = 0;\n    for (const auto& pair : count) {\n        sum += pair.second * pair.first;\n    }\n    return sum;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_gcd(int x, int y) {\n    while(y != 0){\n        int temp = x % y;\n        x = y;\n        y = temp;\n    }\n    return x;\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool test_distinct(const std::vector<int>& data) {\n    std::set<int> distinct_set(data.begin(), data.end());\n    return distinct_set.size() == data.size();\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nint compute_last_digit(int a, int b) {\n    int variable = 1;\n    if (a == b) {\n        return 1;\n    } else if ((b - a) >= 5) {\n        return 0;\n    }\n    while (b > 0) {\n        variable *= b % 10;\n        b /= 10;\n    }\n    return variable % 10;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> specified_element(const std::vector<std::vector<int>>& nums, int n) {\n    std::vector<int> result;\n    for (int i = 0; i < nums.size(); ++i) {\n        if (i < n) {\n            result.push_back(nums[i][0]);\n        }\n    }\n    return result;\n}\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string check_equality(const std::string& str) {\n    if (str[0] == str[str.length() - 1]) {\n        return \"Equal\";\n    } else {\n        return \"Not Equal\";\n    }\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> counting_sort(std::vector<int> my_list) {\n    int max_value = 0;\n    {\n        int i = 0;\n        for (; i < my_list.size(); ++i) {\n            if (my_list[i] > max_value) {\n                max_value = my_list[i];\n            }\n        }\n    }\n    std::vector<int> buckets(max_value + 1, 0);\n    for (int num : my_list) {\n        buckets[num]++;\n    }\n\n    std::vector<int> sorted_list;\n    for (int i = 0; i <= max_value; ++i) {\n        for (int j = 0; j < buckets[i]; ++j) {\n            sorted_list.push_back(i);\n        }\n    }\n\n    return sorted_list;\n}\n\n"], ["\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n// 函数定义\nint find_max_num(std::vector<int> arr, int n) {\n    std::sort(arr.rbegin(), arr.rend());\n    int num = arr[0];\n    return num;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool opposite_signs(int x, int y) {\n    // Check if both numbers have the same sign\n    return (x < 0 && y > 0) || (x > 0 && y < 0);\n}\n\n"], ["\nusing namespace std;\n#include <iostream>\n#include <unordered_map>\n#include <cassert>\n\nint count_substrings(const std::string& s, int n) {\n    int count = 0, sum = 0;\n    std::unordered_map<int, int> mp;\n    mp[0] = 1;\n    for (int i = 0; i < n; ++i) {\n        sum += s[i] - '0';\n        if (sum == i + 1) {\n            ++count;\n        }\n        if (mp.find(sum) != mp.end()) {\n            count += mp[sum];\n        }\n        mp[sum]++;\n    }\n    return count;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <typeinfo>\n#include <type_traits>\nusing namespace std;\n\nclass any {\npublic:\n    any() : content(nullptr) {}\n    template<typename T>\n    any(const T& value) : content(new Holder<T>(value)) {}\n    any(const any& other) : content(other.content ? other.content->clone() : nullptr) {}\n    ~any() { delete content; }\n    any& operator=(const any& other) {\n        if (this != &other) {\n            delete content;\n            content = other.content ? other.content->clone() : nullptr;\n        }\n        return *this;\n    }\n    template<typename T>\n    T& cast() {\n        return static_cast<Holder<T>*>(content)->held;\n    }\n    template<typename T>\n    const T& cast() const {\n        return static_cast<const Holder<T>*>(content)->held;\n    }\n    const type_info& type() const {\n        return content ? content->type() : typeid(void);\n    }\nprivate:\n    struct Placeholder {\n        Placeholder() : held(nullptr) {}\n        ~Placeholder() { delete held; }\n        void* held;\n    };\n};\n\n"], ["\nusing namespace std;\n\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\nbool is_monotonic(std::vector<int> a) {\n    bool increasing = true;\n    bool decreasing = true;\n    \n    for (int i = 0; i < a.size() - 1; ++i) {\n        if (a[i] > a[i + 1]) {\n            decreasing = false;\n        }\n        if (a[i] < a[i + 1]) {\n            increasing = false;\n        }\n    }\n    \n    return increasing || decreasing;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nbool dif_square(int n) {\n    if (n % 4 != 2) {\n        return true;\n    }\n    // Your implementation goes here\n    return false;\n}\n\n"], ["#include <cassert>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <sstream>\n\nbool is_samepatterns(std::vector<std::string> colors, std::vector<std::string> patterns) {\n    if (colors.size() != patterns.size()) {\n        return false;\n    }\n    std::map<std::string, std::vector<std::string>> sdict;\n    std::set<std::string> pset;\n    std::set<std::string> sset;\n\n    // Create a stringstream from each pattern string\n    for (const auto& pattern : patterns) {\n        std::stringstream ss(pattern);\n        std::string color;\n        while (ss >> color) {\n            sset.insert(color);\n        }\n    }\n\n    // Insert colors into the map with their corresponding patterns\n    for (size_t i = 0; i < colors.size(); ++i) {\n        sdict[colors[i]].push_back(patterns[i]);\n    }\n\n    // Check if all colors are present in all patterns\n    for (const auto& color : colors) {\n        if (sset.count(color) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <sstream>\n#include <cassert>\n#include <algorithm>\n\nstd::string find_tuples(const std::vector<std::vector<int>>& test_list, int k) {\n    std::vector<std::vector<int>> res;\n    for (const auto& sub : test_list) {\n        bool all_divisible = true;\n        for (int ele : sub) {\n            if (ele % k != 0) {\n                all_divisible = false;\n                break;\n            }\n        }\n        if (all_divisible) {\n            res.push_back(sub);\n        }\n    }\n    return std::to_string(res.size()) + \" tuples with all elements divisible by \" + std::to_string(k);\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\ndouble count_squares(int m, int n) {\n    if (n < m) {\n        int temp = m;\n        m = n;\n    }\n    double count = 0;\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (i * i + j * j == m * m) {\n                ++count;\n            }\n        }\n    }\n    return count;\n}\n\n"], ["\nusing namespace std;\n#include <iostream>\n#include <cassert>\n\nbool is_diff(int n) {\n    int sum_even = 0, sum_odd = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0) {\n            sum_even += digit;\n        } else {\n            sum_odd += digit;\n        }\n        n /= 10;\n    }\n    return sum_even - sum_odd;\n}\n\n"], ["using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<cassert>\n#include <iostream>\n#include <bitset>\nint count_with_odd_set_bits(int n) {\n    if (n % 2 != 0) {\n        return (n + 1) / 2;\n    }\n    int count = std::bitset<32>(n).count();\n    return count;\n}\n"], ["\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cassert>\n\nbool word_len(std::string s) {\n    std::istringstream iss(s);\n    std::vector<std::string> words;\n    std::string word;\n    for (; (iss >> word);) {\n        words.push_back(word);\n    }\n    for (std::string w : words) {\n        if (w.length() % 2 != 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble volume_sphere(double r) {\n    double volume = (4.0 / 3.0) * m_p_i * r * r * r;\n    return volume;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <string>\n#include <cassert>\n\nchar get_char(std::string strr) {\n    int summ = 0;\n    for (int i = 0; i < strr.length(); ++i) {\n        summ += (strr[i] - 'a' + 1);\n    }\n    if (summ % 26 == 0) {\n        return 'a' + (summ / 26);\n    } else {\n        return 'a' + (summ % 26);\n    }\n}\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble surfacearea_sphere(double r) {\n    double surfacearea = 4 * m_p_i * r * r;\n    return surfacearea;\n}\n\n"], ["\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<assert.h>\n\nint closest_num(int n) {\n    int min_diff = INT_MAX;\n    int closest = INT_MAX;\n\n    for (int i = 1; i <= n; ++i) {\n        if (abs(i - n) < min_diff) {\n            min_diff = abs(i - n);\n            closest = i;\n        }\n    }\n\n    return closest;\n}\n\n"], ["#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cassert>\nusing namespace std;\n\nint find_min_length(vector<vector<int>>& lst) {\n    int min_length = INT_MAX;\n    for (auto& v : lst) {\n        if (v.size() < min_length) {\n            min_length = v.size();\n        }\n    }\n    return min_length;\n}\n"], ["\nusing namespace std;\n#include <iostream>\n#include <climits>\n#include <string>\n#include <cassert>\n\nint next_smallest_palindrome(int num) {\n    for (int i = num + 1; i < i_n_t_m_a_x; ++i) {\n        std::string num_str = std::to_string(i);\n        std::string reversed_str = std::string(num_str.rbegin(), num_str.rend());\n        if (num_str == reversed_str) {\n            return i;\n        }\n    }\n    return -1; // Return -1 if no smaller palindrome is found\n}\n\n"], ["\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\nstd::string snake_to_camel(const std::string& word) {\n    std::vector<std::string> parts;\n    std::string part;\n    std::istringstream token_stream(word);\n    while (getline(token_stream, part, '_')) {\n        if (!part.empty()) {\n            part[0] = toupper(part[0]); // Capitalize the first letter\n            parts.push_back(part);\n        } else {\n            // Handle empty strings\n            continue;\n        }\n    }\n    std::string result;\n    for (size_t i = 0; i < parts.size(); ++i) {\n        if (i > 0) {\n            result += \"_\";\n        }\n        result += parts[i];\n    }\n    return result;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint count_hexadecimal(int l, int r) {\n    int count = 0;\n    for (int i = l; i <= r; i++) { \n        if (i >= 10 && i <= 15) { \n            count++;  \n        } else if (i > 15) { \n            int k = i;  \n            while (k != 0) {  \n                count += (k % 16);  \n                k /= 16;  \n            }  \n        }  \n    }\n    return count;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint odd_equivalent(const std::string& s, int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '1') {\n            // Count the number of '1's in the substring from the current position to the end\n            int count_ones = 0;\n            for (int j = i; j < n; ++j) {\n                if (s[j] == '1') {\n                    ++count_ones;\n                }\n            }\n            // If the count of '1's is odd, increment the count\n            if (count_ones % 2 != 0) {\n                ++count;\n            }\n        }\n    }\n    return count;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint search(const std::vector<int>& arr, int n) {\n    int x_o_r = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != arr[x_o_r]) {\n            x_o_r++;\n        }\n    }\n    return x_o_r;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool check_triplet(const std::vector<int>& a, int n, int sum, int count) {\n    // Sort the array to use two pointers\n    sort(a.begin(), a.end());\n\n    // Iterate through the array\n    for (int i = 0; i < n - 2; ++i) {\n        // Use two pointers to find the other two numbers\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int current_sum = a[i] + a[left] + a[right];\n\n            if (current_sum == sum) {\n                // Found a triplet that sums to the given sum\n                return true;\n            } else if (current_sum < sum) {\n                // Move the left pointer to the right to increase the sum\n                ++left;\n            } else {\n                // Move the right pointer to the left to decrease the sum\n                --right;\n            }\n        }\n    }\n\n    // No triplet found that sums to the given sum\n    return false;\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nconst int m_a_x = 3000;\nint smart_number(int n) {\n    vector<int> primes(m_a_x, 0);\n    vector<int> result;\n    for (int i = 2; i < m_a_x; i++) {\n        if (primes[i] == 0) {\n            primes[i] = 1;\n            int j = i * 2;\n            while (j < m_a_x) {\n                primes[j] -= 1;\n                //begin to write code\n            }\n        }\n    }\n    return primes[n];\n}\n\n"], ["\n#include <iostream>\n#include <set>\n#include <stdexcept>\n#include <cassert>\nusing namespace std;\n\nint amicable_numbers_sum(int limit) {\n    if (limit < 1) {\n        throw invalid_argument(\"Input must be bigger than 0!\");\n    }\n    set<int> amicables;\n    for (int num = 2; num <= limit; num++) {\n        if (amicables.find(num) != amicables.end()) {\n            continue;\n        }\n        int sum_fact = 0;\n        {\n            int fact = 1;\n            for (; fact < num; fact++) {\n                if (num % fact == 0) {\n                    sum_fact += fact;\n                }\n            }\n        }\n        int sum_fact2 = 0;\n        for (int i = 1; i <= num / 2; i++) {\n            if (num % i == 0) {\n                sum_fact2 += i;\n            }\n        }\n        if (sum_fact == sum_fact2) {\n            amicables.insert(num);\n        }\n    }\n    return accumulate(amicables.begin(), amicables.end(), 0);\n}\n\n"], ["#include <cassert>\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <set>\n\nbool magic_square_test(const std::vector<std::vector<int>>& my_matrix) {\n    size_t i_size = my_matrix[0].size();\n    std::vector<int> sum_list;\n    // Sum of each row\n    for (const auto& line : my_matrix) {\n        sum_list.push_back(std::accumulate(line.begin(), line.end(), 0));\n    }\n    // Sum of each column\n    {\n        size_t col = 0;\n        for (; col < i_size; ++col) {\n            int col_sum = 0;\n            {\n                size_t row = 0;\n                for (; row < i_size; ++row) {\n                    col_sum += my_matrix[row][col];\n                }\n            }\n            sum_list.push_back(col_sum);\n        }\n    }\n    // Check if the sum of each row equals the sum of each column\n    for (size_t i = 0; i < i_size; ++i) {\n        if (sum_list[i] != sum_list[i_size - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::string check_last(const std::vector<int>& arr, int n, int p) {\n    int sum = 0;\n    {\n        int i = 0;\n        while(i < n){\n            sum += arr[i];\n            ++i;\n        }\n    }\n    if (p == 1) {\n        if (sum % 2 == 0) {\n            return \"Even\";\n        } else {\n            return \"Odd\";\n        }\n    } else {\n        // Perform the operation p times\n        for(int i = 0; i < p; ++i){\n            sum += arr[i];\n        }\n        if (sum % 2 == 0) {\n            return \"Even\";\n        } else {\n            return \"Odd\";\n        }\n    }\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nbool is_sum_of_powers_of_two(int n) {\n    // Check if n is odd\n    if (n % 2 == 1) {\n        return false;\n    }\n    \n    // Check if n is a power of 2\n    while (n > 0) {\n        if (n % 2 != 0) {\n            return false;\n        }\n        n /= 2;\n    }\n    \n    return true;\n}\n\n"], ["\n#include<cassert>\n#include <iostream>\n#include <tuple>\n#include <vector>\n#include <string>\n\ntemplate <typename... args>\nint find_lists(const std::tuple<args...>& input) {\n    return sizeof...(args);\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint sum_pairs(const std::vector<int>& arr, int n) {\n    int sum = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            sum += abs(arr[i] - arr[j]);\n        }\n    }\n    return sum;\n}\n\n"], ["\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint max_abs_diff(const std::vector<int>& arr, int n) {\n    if (n <= 1) {\n        return 0;\n    }\n\n    int min_ele = arr[0];\n    int max_ele = arr[0];\n\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < min_ele) {\n            min_ele = arr[i];\n        }\n        if (arr[i] > max_ele) {\n            max_ele = arr[i];\n        }\n    }\n\n    int max_diff = max_ele - min_ele;\n    return max_diff;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint sum_digits_single(int x) {\n    int ans = 0;\n    for(;(x);){\n        ans += x % 10;\n        x /= 10;\n    }\n    return ans;\n}\n\nint closest(int x) {\n    int min_diff = INT_MAX;\n    int closest_x = 0;\n\n    for(int i = 1; i <= x; ++i){\n        int diff = abs(sum_digits_single(i) - x);\n        if(diff < min_diff){\n            min_diff = diff;\n            closest_x = i;\n        }\n    }\n\n    return closest_x;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool does_contain_b(int a, int b, int c) {\n    if (a == b) {\n        return true;\n    }\n    // Your implementation goes here\n    // For example, you can use a loop to check if b is in the sequence\n    // or use a set to store the sequence for quick lookup\n    // Here's a simple implementation using a set:\n    std::set<int> sequence = {a, b, c};\n    return sequence.find(b) != sequence.end();\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<int> merge(vector<int>& a, vector<int>& b) {\n    vector<int> c;\n    while (!a.empty() && !b.empty()) {\n        if (!(a.front() < b.front())) {\n            c.push_back(b.front());\n            b.erase(b.begin());\n        } else {\n            c.push_back(a.front());\n            a.erase(a.begin());\n        }\n    }\n    if (a.empty()) {\n        c.insert(c.end(), b.begin(), b.end());\n    } else {\n        c.insert(c.end(), a.begin(), a.end());\n    }\n    return c;\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<int> specified_element(vector<vector<int>>& nums, int n) {\n    vector<int> result;\n    for (int i = 0; i < nums.size(); ++i) {\n        for (int j = 0; j < nums[i].size(); ++j) {\n            if (j == n) {\n                result.push_back(nums[i][j]);\n            }\n        }\n    }\n    return result;\n}\n\n"], ["#include <vector>\n#include <string>\n#include <iostream>\n#include <iterator>\n#include <cassert>\n\ntemplate<typename T>\nstd::vector<std::vector<T>> encode_list(const std::vector<T>& list1) {\n    std::vector<std::vector<T>> result;\n    if (list1.empty()) return result;\n    T current_value = list1[0];\n    int count = 0;\n    for (const T& value : list1) {\n        if (!(value == current_value)) {\n            result.push_back({count, current_value});\n            current_value = value;\n            count = 1;\n        }\n        else {\n            count++;\n        }\n    }\n    result.push_back({count, current_value});\n    return result;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nint min_ops(vector<int> arr, int n, int k) {\n    int max1 = *max_element(arr.begin(), arr.end());\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        if ((max1 - arr[i]) % k != 0) {\n            return -1;\n        }\n        res += abs(arr[i] - max1);\n    }\n    return res / k;\n}\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string month_season(std::string month, int days) {\n    std::string season;\n    if (month == \"January\" || month == \"February\" || month == \"March\") {\n        season = \"winter\";\n    } else if (!(month == \"April\" || month == \"May\" || month == \"June\")) if (month == \"July\" || month == \"August\" || month == \"September\") {\n        season = \"summer\";\n    } else {\n        season = \"autumn\";\n    }\n    return season;\n}\n\n"], ["\n#include<iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\ndouble area_polygon(int s, double l) {\n  double area = s * (l * l) / (4 * tan(m_p_i / s));\n  return area;\n}\n\n"], ["\n#include <cassert>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint div_sum(int n) {\n    int sum = 1;\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            sum += i + (n / i);\n        }\n    }\n    return sum;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_even_pair(const std::vector<int>& a, int n) {\n    int even_pair = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if ((a[i] ^ a[j]) % 2 == 0) {\n                even_pair++;\n            }\n        }\n    }\n    return even_pair;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint next_power_of_2(int n) {\n    int count = 0;\n    if (n && !(n & (n - 1))) {\n        return n;\n    }\n    while (n > 1) {\n        n >>= 1;\n        count++;\n    }\n    return 1 << count;\n}\n\n"], ["\nusing namespace std;\n#include <iostream>\n#include <cassert>\n#include <utility> // For std::pair\n\nstd::pair<int, int> answer(int l, int r) {\n    if (2 * l <= r) {\n        return std::make_pair(l, 2 * l);\n    } else {\n        return std::make_pair(0, 0); // Return a pair with both elements set to 0\n    }\n}\n\n"], ["\n#include<iostream>\n#include <string>\n#include <vector>\n#include <regex>\n#include <cassert>\nusing namespace std;\n\nstring string_literals(const vector<string>& patterns, const string& text) {\n    for (const auto& pattern : patterns) {\n        regex re_pattern(pattern);\n        if (regex_search(text, re_pattern)) {\n            return \"Matched!\";\n        }\n    }\n    return \"No matches found.\";\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nbool is_num_keith(int x) {\n    vector<int> terms;\n    int temp = x;\n    int n = 0;\n    for(;(temp > 0);){\n        terms.push_back(temp % 10);\n        temp = temp / 10;\n        n++;\n    }\n    reverse(terms.begin(), terms.end());\n    int next_term = 0;\n    int i = n;\n    while(i > 0){\n        next_term += terms[i - 1];\n        i--;\n    }\n    return next_term == x;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nint longest_common_subsequence(const string &x, const string &y, int m, int n) {\n    if (m == 0 || n == 0) {\n        return 0;\n    } else if (x[m-1] == y[n-1]) {\n        return 1 + longest_common_subsequence(x, y, m-1, n-1);\n    } else {\n        return max(longest_common_subsequence(x, y, m-1, n), longest_common_subsequence(x, y, m, n-1));\n    }\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool prod_square(int n) {\n    for (int i = 2; i <= n; ++i) {\n        if (i * i < (n + 1)) {\n            for (int j = 2; j <= n; ++j) {\n                if ((i * i * j * j) == n) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint first_missing_positive(std::vector<int> arr, int n) {\n    int ptr = 0;\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] == 1) {\n            ptr = 1;\n            break;\n        }\n    }\n    if (ptr == 0) {\n        return 1;\n    }\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] <= 0 || arr[i] > n) {\n            continue;\n        }\n        if (arr[arr[i] - 1] != arr[i]) {\n            swap(arr[arr[i] - 1], arr[i]);\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] != i + 1) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint count_intgral_points(int x1, int y1, int x2, int y2) {\n    int count = 0;\n    for (int i = x1; i <= x2; ++i) {\n        for (int j = y1; j <= y2; ++j) {\n            if (i == x1 || i == x2 || j == y1 || j == y2) {\n                continue;\n            }\n            count++;\n        }\n    }\n    return count;\n}\n\n"], ["\nusing namespace std;\n\n#include<cassert>\n#include <iostream>\n#include <string>\n#include <cctype>\n\nbool check_string(const std::string& str) {\n    bool flag_l = false;\n    bool flag_n = false;\n    for (char i : str) {\n        if (isalpha(i)) {\n            flag_l = true;\n        } else if (isdigit(i)) {\n            flag_n = true;\n        }\n    }\n    return flag_l && flag_n;\n}\n\n"], ["\n#include <iostream>\n\nint octal_to_decimal(int n) {\n    int num = n;\n    int dec_value = 0;\n    int base = 1;\n    int temp = num;\n\n    while (temp > 0) {\n        dec_value += temp % base;\n        temp /= base;\n    }\n\n    return dec_value;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<vector<int>> remove_tuples(vector<vector<int>> test_list, int k) {\n    vector<vector<int>> res;\n    for (auto ele : test_list) {\n        if ((int)ele.size() != k) {\n            res.push_back(ele);\n        }\n    }\n    return res;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint highest_power_of_2(int n) {\n    int res = 0;\n    for (int i = n; i > 0; i--) {\n        if ((i & (i - 1)) == 0) {\n            res = i;\n        }\n    }\n    return res;\n}\n\n"], ["\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\n\nbool chk_list(const std::vector<std::string>& lst) {\n    // Check if the list is empty\n    if (lst.empty()) {\n        return true;\n    }\n\n    // Use a set to store unique elements\n    std::set<std::string> unique_elements(lst.begin(), lst.end());\n\n    // Compare the size of the set with the original list\n    return unique_elements.size() == lst.size();\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint hamming_distance(int n1, int n2) {\n    int x = n1 ^ n2;\n    int set_bits = 0;\n    while (x > 0) {\n        set_bits += x & 1; // Count the number of set bits\n        x >>= 1; // Right shift x by 1 to process the next bit\n    }\n    return set_bits;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint count_num(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    int count = 0;\n    for (int i = 1; i <= n; ++i) {\n        if ((i & 1) == 1 && (i >> 1) & 1) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n#include <cmath>\n\nint fourth_power_sum(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += std::pow(i, 4);\n    }\n    return sum;\n}\n\n"], ["\n#include <cmath>\n#include <cassert>\n#include <iostream>\n\ndouble degree_radian(double radian) {\n    double degree = radian * (180.0 / m_p_i);\n    return degree;\n}\n\n"], ["#include <iostream>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nchar first_repeated_char(string str) {\n    unordered_map<char, int> h;\n    for (char ch : str) {\n        if (h.find(ch) != h.end()) {\n            return ch;\n        }\n        h[ch] = 1;\n    }\n    return '\\0'; // Return '\\0' if no repeated character is found\n}\n"], ["#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint minOperationsToEqual(int num1, int num2) {\n    // Ensure num1 is always less than or equal to num2\n    if (num1 > num2) {\n        swap(num1, num2);\n    }\n\n    // Calculate the difference between the two numbers\n    int difference = num1 - num2;\n\n    // If the difference is 0, it means both numbers are equal\n    if (difference == 0) {\n        return 0;\n    }\n\n    // Calculate the number of operations needed to make the difference zero\n    int operations = difference / gcd(num1, num2);\n\n    // If there's a remainder, add one more operation\n    if (difference % gcd(num1, num2) != 0) {\n        operations++;\n    }\n\n    return operations;\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<std::vector<int>> extract_min_max(std::vector<int> test_vec, int k) {\n    std::vector<int> res;\n    std::sort(test_vec.begin(), test_vec.end());\n    for (int idx = 0; idx < test_vec.size(); ++idx) {\n        if (idx < k || idx >= test_vec.size() - k) {\n            res.push_back(test_vec[idx]);\n        }\n    }\n    return res;\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint binary_search(const vector<int>& arr, int low, int high, int x) {\n    if (high >= low) {\n        int mid = (low + high) / 2;\n        if (!((mid == 0 || x > arr[mid - 1]) && (arr[mid] == x))) if (x > arr[mid])\n            return binary_search(arr, mid + 1, high, x);\n        else\n            return binary_search(arr, low, mid - 1, x);\n        else return mid;\n    }\n}\n\nint majority_element(vector<int>& arr) {\n    int n = arr.size();\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] == arr[(i + 1) % n]) {\n            count++;\n        }\n    }\n    return count > n / 2 ? arr[count / 2] : -1;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint count_set_bits(int n) {\n    int count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1; // Equivalent to n /= 2\n    }\n    return count;\n}\n\n"], ["\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_min(std::vector<int>& arr, int low, int high) {\n    while (low < high) {\n        int mid = low + (high - low) / 2;   \n        if (arr[mid] == arr[high]) {\n            high -= 1; \n        } else if (arr[mid] > arr[high]) {\n            // Find the minimum in the right half\n            return find_min(arr, mid + 1, high);\n        } else {\n            // Find the minimum in the left half\n            return find_min(arr, low, mid - 1);\n        }\n    }\n    return arr[low]; // Return the first element if the array is sorted\n}\n\n"], ["\n#include<iostream>\n#include <cassert>\nusing namespace std;\n\nbool all_bits_set_in_the_given_range(int n, int l, int r) {\n    // Calculate the number of bits set in the range [l, r]\n    int num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1));\n    \n    // Check if all bits in the range are set\n    return num == 0;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint no_of_triangle(int n, int k) {\n    if (n < k) {\n        return -1;\n    } else {\n        int tri_up = 0;\n        // Calculate the number of equilateral triangles that can be formed\n        // using the formula for the number of equilateral triangles in an equilateral triangle\n        // n^2 / 6\n        tri_up = n * n / 6;\n        return tri_up;\n    }\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint get_total_number_of_sequences(int m, int n) {\n    vector<vector<int>> t(m+1, vector<int>(n+1, 0));\n    for(int i = 0; i <= m; ++i) {\n        for(int j = 0; j <= n; ++j) {\n            if(i == 0 || j == 0) {\n                t[i][j] = 0;\n            } else if(i < j) {\n                t[i][j] = 0;\n            } else {\n                t[i][j] = t[i-1][j] + t[i][j-1];\n            }\n        }\n    }\n    return t[m][n];\n}\n\n"], ["#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <set>\n#include <cassert>\nusing namespace std;\n\ntemplate <typename t>\nvector<pair<t, pair<vector<string>, int>>> sort_on_occurence(vector<pair<t, string>> const lst) {\n    unordered_map<t, vector<string>> counter;\n    for (const auto& item : lst) {\n        counter[item.first].push_back(item.second);\n    }\n    vector<pair<t, pair<vector<string>, int>>> result;\n    for (const auto& entry : counter) {\n        set<string> unique_strings(entry.second.begin(), entry.second.end());\n        result.emplace_back(entry.first, make_pair(vector<string>(unique_strings.begin(), unique_strings.end()), entry.second.size()));\n    }\n    return result;\n}\n\ntemplate <typename t>\nbool compare_results(const vector<pair<t, pair<vector<string>, int>>& result, const vector<pair<t, pair<vector<string>, int>>& expected) {\n    if (result.size() != expected.size()) return false;\n    set<t> result_first_elements;\n    set<t> expected_first_elements;\n    for (const auto& res_entry : result) {\n        result_first_elements.insert(res_entry.first);\n        //begin to write code\n    }\n    return result_first_elements == expected_first_elements;\n}\n"], ["\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<cmath>\n#include<assert.h>\n\nint next_perfect_square(int n) {\n    int next_n = std::floor(std::sqrt(n)) + 1;\n    return next_n * next_n;\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <climits>\n#include <cassert>\nusing namespace std;\n\nint max_sum(vector<int> arr, int n) {\n    vector<int> m_s_i_b_s = arr;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (arr[i] > arr[j] && m_s_i_b_s[i] < m_s_i_b_s[j] + arr[i]) {\n                m_s_i_b_s[i] = m_s_i_b_s[j] + arr[i];\n            }\n        }\n    }\n    vector<int> m_s_d_b_s = arr;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (arr[i] > arr[j] && m_s_d_b_s[i] < m_s_d_b_s[j] + arr[i]) {\n                m_s_d_b_s[i] = m_s_d_b_s[j] + arr[i];\n            }\n        }\n    }\n    return *max_element(m_s_i_b_s.begin(), m_s_i_b_s.end());\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint lps(string str) {\n    int n = str.size();\n    vector<vector<int>> l(n, vector<int>(n, 0));\n    for (int i = 0; i < n; i++)\n        l[i][i] = 1;\n    for (int cl = 2; cl <= n; cl++) {\n        for (int i = 0; i < n - cl + 1; i++) {\n            int j = i + cl - 1;\n            if (str[i] == str[j] && cl == 2) {\n                l[i][j] = l[i + 1][j - 1] + 2;\n            } else if (str[i] == str[j]) {\n                l[i][j] = l[i + 1][j];\n            } else {\n                l[i][j] = max(l[i + 1][j], l[i][j - 1]);\n            }\n        }\n    }\n    return l[0][n - 1];\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_x(const std::vector<int>& tup, int x) {\n    int count = 0;\n    for (int ele : tup) {\n        if (ele == x) {\n            count++;\n        }\n    }\n    return count;\n}\n\n"], ["\n#include <vector>\n#include <iostream>\n#include <memory>\n#include <cassert>\nusing namespace std;\n\nclass base {\npublic:\n    virtual ~base() = default;\n    virtual bool isInteger() const = 0;\n};\n\nclass derived_int : public base {\npublic:\n    derived_int(int value) : value(value) {}\n    bool isInteger() const override {\n        return true;\n    }\nprivate:\n    int value;\n};\n\nclass derived_double : public base {\npublic:\n    derived_double(double value) : value(value) {}\n    bool isInteger() const override {\n        return false;\n    }\n};\n\nint countIntegers(const vector<int>& numbers) {\n    int count = 0;\n    for (int num : numbers) {\n        if (num.isInteger()) {\n            count++;\n        }\n    }\n    return count;\n}\n\n"], ["#include <cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nstd::vector<std::vector<std::string>> combinations_colors(const std::vector<std::string>& l, int n) {\n    std::vector<std::vector<std::string>> result;\n    std::vector<int> indices(n, 0);\n    int size = l.size();\n    while (true) {\n        // Add current combination\n        std::vector<std::string> current;\n        for (int i = 0; i < n; ++i) {\n            current.push_back(l[indices[i]]);\n        }\n        result.push_back(current);\n        // Generate next combination\n        int next = n - 1;\n        for (; (next >= 0 && indices[next] == size - 1);){\n            --next;\n        }\n        if (next < 0) {\n            break;\n        }\n    }\n    return result;\n}\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint count_primes_nums(int n) {\n    int ctr = 0;\n    for (int num = 0; num < n; ++num) {\n        if (num <= 1) {\n            continue;\n        }\n        bool is_prime = true;\n        for (int i = 2; i < num; ++i) {\n            if (num % i == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            ++ctr;\n        }\n    }\n    return ctr;\n}\n\n"], ["#include<iostream>\n#include <vector>\n#include <cassert>\n#include <utility>\ntemplate<typename T>\nstd::pair<std::vector<T>, std::vector<T>> split_two_parts(const std::vector<T>& list1, int l) {\n    std::vector<T> first_part(list1.begin(), list1.begin() + l);\n    std::vector<T> second_part(list1.begin() + l, list1.end());\n    return {first_part, second_part};\n}\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\ntemplate <typename T>\nvector<vector<T>> list_split(vector<T> s, int step) {\n    vector<vector<T>> result(step);\n    for (int i = 0; i < step; ++i) {\n        for (int j = i; j < s.size(); j += step) {\n            result[i].push_back(s[j]);\n        }\n    }\n    return result;\n}\n\n"], ["\n#include<iostream>\n#include <cassert>\n\nint lateralsurface_cube(int l) {\n    int l_s_a = 4 * (l * l);\n    return l_s_a;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\n// 函数定义\nint square_sum(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i += 2) {\n        sum += i * i;\n    }\n    return sum;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\n// 函数定义\nint even_power_sum(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i * i * i * i * i; // Calculate the fifth power of each number\n    }\n    return sum;\n}\n\n// 测试函数\nvoid test_even_power_sum() {\n    assert(even_power_sum(1) == 1); // Test case 1\n    assert(even_power_sum(2) == 8); // Test case 2\n    assert(even_power_sum(3) == 729); // Test case 3\n    assert(even_power_sum(4) == 10000); // Test case 4\n    std::cout << \"All test cases passed!\" << std::endl;\n}\n\n"], ["\n#include <cassert>\n#include <iostream>\n\nint even_binomial_coeff_sum(int n) {\n    // Initialize the result to 0\n    int result = 0;\n\n    // Iterate over the first half of the binomial coefficients\n    for (int i = 0; i < n / 2; ++i) {\n        // Calculate the binomial coefficient for the current index\n        int binomial_coefficient = binomial_coefficient(n, i);\n\n        // Add the binomial coefficient to the result\n        result += binomial_coefficient;\n    }\n\n    return result;\n}\n\n// Helper function to calculate binomial coefficient\nint binomial_coefficient(int n, int k) {\n    if (k == 0 || k == n) {\n        return 1;\n    }\n    return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);\n}\n\n"], ["#include<cassert>\n#include <iostream>\n#include <vector>\n#include <cmath> // for ceil\nusing namespace std;\n\nint get_position(vector<int>& a, int n, int m) {\n    {\n        int i = 0;\n        for (; i < n; ++i) {\n            a[i] = (a[i] / m + (a[i] % m != 0));\n        }\n    }\n    int result = -1, maxx = -1;\n    for (int i = n - 1; i >= 0; --i) {\n        if (a[i] == maxx) {\n            result = i;\n            break;\n        }\n        maxx = max(maxx, a[i]);\n    }\n    return result;\n}\n"], ["\n#include <iostream>\n#include <tuple>\n#include <vector>\n#include <cassert>\n#include <type_traits>\nusing namespace std;\n\ntemplate <size_t index, typename Tuple>\nint count_first_elements_helper(const Tuple& t, true_type) {\n    return 0;\n}\n\ntemplate <size_t index, typename Tuple>\nint count_first_elements_helper(const Tuple& t, false_type) {\n    if (index == 0) {\n        return 1; // Special case for the first element\n    }\n    return count_first_elements_helper(t, true_type()) + 1;\n}\n\nint count_first_elements(const tuple<int, int>& t) {\n    return count_first_elements_helper(t, true_type());\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint square_sum(int n) {\n    int sum = 0;\n    for (int i = 2; i <= n; i += 2) {\n        sum += i * i;\n    }\n    return sum;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint modular_inverse(const std::vector<int>& arr, int n, int p) {\n    int current_element = 0;\n    for (int i = 0; i < n; ++i) {\n        if ((arr[i] * arr[i]) % p == 1) {\n            current_element = arr[i];\n            break;\n        }\n    }\n    return current_element;\n}\n\n"], ["\n#include<iostream>\n#include <cassert>\nusing namespace std;\n\nint odd_days(int n) {\n    int hund1 = n / 100;\n    int hund4 = n / 400;\n    int leap = n >> 2;\n    int ordd = n - leap;\n    if (hund1) {\n        ordd += hund1;\n        leap -= hund1;\n    }\n    // Calculate the number of odd days\n    int odd_days = 0;\n    if (leap % 4 == 0 && leap % 100 != 0 || leap % 400 == 0) {\n        odd_days += 7;\n    } else {\n        odd_days += 6;\n    }\n    return odd_days;\n}\n\n"], ["\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_inv_count(vector<int> arr, int n) {\n    int inv_count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (arr[i] > arr[j]) {\n                inv_count++;\n            }\n        }\n    }\n    return inv_count;\n}\n\n"], ["\n#include <vector>\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nclass variant {\npublic:\n    virtual ~variant() = default;\n    virtual bool is_int() const = 0;\n    virtual bool is_vector() const = 0;\n    virtual int get_int() const = 0;\n    virtual const vector<variant*>& get_vector() const = 0;\n};\n\nclass int_variant : public variant {\npublic:\n    int_variant(int value) : value(value) {}\n    bool is_int() const override { return true; }\n    bool is_vector() const override { return false; }\n    int get_int() const override { return value; }\n    const vector<variant*>& get_vector() const override { throw runtime_error(\"Not a vector\"); }\nprivate:\n    int value;\n};\n\nclass vector_variant : public variant {\npublic:\n    vector_variant(const vector<variant*>& value) : value(value) {}\n    bool is_int() const override { return false; }\n    bool is_vector() const override { return true; }\n    int get_int() const override { throw runtime_error(\"Not an int\"); }\n    const vector<variant*>& get_vector() const override { return value; }\nprivate:\n    vector<variant*> value;\n};\n\nvoid flatten_list(const vector<variant*>& list1, vector<int>& result_list) {\n    for (const auto& element : list1) {\n        if (element.is_int()) {\n            result_list.push_back(element.get_int());\n        } else if (element.is_vector()) {\n            flatten_list(element.get_vector(), result_list);\n        }\n    }\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\ndouble count_binary_seq(int n) {\n    double n_cr = 1;\n    double res = 1;\n    for(int r = 1; r <= n; ++r) {\n        // Calculate the number of ways to choose k bits out of n\n        double binomial_coefficient = n_cr / (n - r + 1);\n        // Calculate the number of ways to choose the remaining bits\n        double remaining_bits = n - r;\n        // Calculate the sum of the first n bits\n        double sum_first_n_bits = binomial_coefficient * pow(2, r);\n        // Calculate the sum of the last n bits\n        double sum_last_n_bits = binomial_coefficient * pow(2, remaining_bits);\n        // Add the product of the two sums to the result\n        res += sum_first_n_bits * sum_last_n_bits;\n    }\n    return res;\n}\n\n"], ["\n#include <iostream>\n#include <unordered_map>\n#include <cassert>\nusing namespace std;\n\nclass variant {\npublic:\n    virtual ~variant() = default;\n};\n\nclass int_variant : public variant {\npublic:\n    int_variant(int value) : value(value) {}\n    int get_int() const {\n        return this->value;\n    }\nprivate:\n    int value;\n};\n\nclass map_variant : public variant {\npublic:\n    map_variant(const std::unordered_map<char, variant*>& map) : map(map) {}\n    const std::unordered_map<char, variant*>& get_map() const {\n        return this->map;\n    }\nprivate:\n    //begin to write code\n    unordered_map<char, variant*> map;\n};\n\nint find_depth(const variant& v) {\n    if (v.is_int()) {\n        return 1 + find_depth(v.get_int());\n    } else if (v.is_map()) {\n        return 1 + find_depth(v.get_map());\n    } else {\n        return 0;\n    }\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\n// 函数定义\nint set_bit_number(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    int msb = 0;\n    // Find the first set bit\n    while (n > 0) {\n        if (n & 1) {\n            msb = 1;\n            break;\n        }\n        n >>= 1;\n    }\n    return msb;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_element(const std::vector<int>& arr, const std::vector<std::pair<int, int>>& ranges, int rotations, int index) {\n    for (int i = rotations - 1; i >= 0; --i) {\n        int left = ranges[i].first;\n        int right = ranges[i].second;\n        if (left <= index && right >= index) {\n            if (index == left) {\n                index = right;\n                break;\n            }\n        }\n    }\n    return arr[index];\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint max_sum_increasing_subseq(vector<int> a, int n, int index, int k) {\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    {\n        int i = 0;\n        for (; i < n; ++i) {\n            if (a[i] > a[0]) {\n                dp[0][i] = a[i] + a[0];\n            } else {\n                dp[0][i] = a[i];\n            }\n        }\n    }\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (a[j] > a[i] && j > i) {\n                dp[i][j] = max(dp[i][j], dp[i - 1][j]);\n            }\n        }\n    }\n    return dp[n - 1][k];\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> large_product(const std::vector<int>& nums1, const std::vector<int>& nums2, int n) {\n    std::vector<int> products;\n    for (int x : nums1) {\n        for (int y : nums2) {\n            products.push_back(x * y);\n        }\n    }\n    // Sort the products in descending order\n    std::sort(products.begin(), products.end(), std::greater<int>());\n    // Take the first n elements which are the largest products\n    return products.subvector(0, n);\n}\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble volume_cone(double r, double h) {\n    double volume = (1.0/3) * m_p_i * r * r * h;\n    return volume;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string find_max_len_even(const std::string& str) {\n    int n = str.length();\n    int i = 0;\n    int currlen = 0;\n    int maxlen = 0;\n    int st = -1;\n    while (i < n) {\n        if (str[i] == ' ') {\n            if (currlen % 2 == 0) {\n                if (maxlen < currlen) {\n                    maxlen = currlen;\n                    st = i - currlen;\n                }\n            }\n            currlen = 0;\n        } else {\n            currlen++;\n        }\n    }\n    return str.substr(st, maxlen);\n}\n\n"], ["\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_last_occurrence(const std::vector<int>& a, int x) {\n    int left = 0;\n    int right = a.size() - 1;\n    int result = -1;\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (x == a[mid]) {\n            result = mid;\n            right = mid - 1; // Move the right pointer to the left to find the last occurrence\n        } else if (x < a[mid]) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return result;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n// 基类\nclass element {\npublic:\n    virtual ~element() = default;\n    virtual element* clone() const = 0;\n    virtual void print() const = 0;\n    virtual bool isSameType(const element& other) const = 0;\n    virtual bool isInt() const = 0;\n    virtual bool isChar() const = 0;\n    virtual int getIntValue() const = 0;\n    virtual char getCharValue() const = 0;\n};\n// 处理 char 类型的子类\nclass char_element : public element {\npublic:\n    char_element(char value) : value(value) {}\n    element* clone() const override {\n        return new char_element(*this);\n    }\n    void print() const override {\n        std::cout << \"Char: \" << value << std::endl;\n    }\n    bool isSameType(const element& other) const override {\n        return other.isChar();\n    }\n    bool isInt() const override { return false; }\n    bool isChar() const override { return true; }\n    int getIntValue() const override { return 0; }\n    char getCharValue() const override { return value; }\nprivate:\n    char value;\n};\n// 处理 int 类型的子类\nclass int_element : public element {\npublic:\n    int_element(int value) : value(value) {}\n    element* clone() const override {\n        return new int_element(*this);\n    }\n    void print() const override {\n        std::cout << \"Int: \" << value << std::endl;\n    }\n    bool isSameType(const element& other) const override {\n        return other.isInt();\n    }\n    bool isInt() const override { return true; }\n    bool isChar() const override { return false; }\n    int getIntValue() const override { return value; }\n    char getCharValue() const override { \n        return value; \n    }\n};\n// 需要实现的函数\nstd::vector<element*> modifyRunLengthEncoding(const std::vector<int>& runLengthEncoded) {\n    std::vector<element*> result;\n    for (int i = 0; i < runLengthEncoded.size(); ++i) {\n        if (runLengthEncoded[i] == 0) {\n            continue;\n        }\n        int count = runLengthEncoded[i];\n        while (count"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nvoid right_rotate(std::vector<int>& arr, int n, int out_of_place, int cur) {\n    int temp = arr[cur];\n    {\n        int i = cur;\n        for (; i > out_of_place; --i) {\n            arr[i] = arr[i - 1];\n        }\n    }\n    arr[out_of_place] = temp;\n}\n\nstd::vector<int> re_arrange(std::vector<int>& arr, int n) {\n    int out_of_place = -1;\n    for (int index = 0; index < n; ++index) {\n        if (out_of_place >= 0) {\n            if ((arr[index] >= 0 && arr[out_of_place] < 0) ||\n                (arr[index] < 0 && arr[out_of_place] >= 0)) {\n                right_rotate(arr, n, out_of_place, index);\n                if (index - out_of_place > 2) {\n                    //begin to write code\n                    std::cout << \"Index: \" << index << \", Out of Place: \" << out_of_place << \", Current Index: \" << index << std::endl;\n                }\n            }\n        }\n    }\n    return arr;\n}\n\n"], ["\nusing namespace std;\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n\nint get_min_squares(int n) {\n    if (n <= 3) {\n        return n;\n    }\n    int res = n;\n    for (int x = 1; x <= n; ++x) {\n        int temp = x * x;\n        if (temp == n) {\n            return x;\n        } else if (temp < n && get_min_squares(temp) < res) {\n            res = temp;\n        }\n    }\n    return res;\n}\n\n"], ["\n#include <iostream>\n#include <sstream>\n#include <unordered_map>\n#include <cassert>\n#include <vector>\nusing namespace std;\n\nstring most_occurrences(vector<string> test_list) {\n    unordered_map<string, int> temp;\n    for (auto& sub : test_list) {\n        stringstream ss(sub);\n        string wrd;\n        for (; (ss >> wrd);){\n            temp[wrd]++;\n        }\n    }\n\n    int max_count = 0;\n    string result;\n    for (const auto& pair : temp) {\n        if (pair.second > max_count) {\n            max_count = pair.second;\n            result = pair.first;\n        }\n    }\n\n    return result;\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\n// Sorting function based on the second element of the pairs\nvoid sort(vector<pair<string, int>>& sub_li) {\n    sort(sub_li.begin(), sub_li.end(), [](const pair<string, int>& a, const pair<string, int>& b) {\n        return a.second < b.second; // Sort by the second element in descending order\n    });\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nbool check_validity(int a, int b, int c) {\n    // Check if any two sides are less than the third side\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return false;\n    }\n    // If all sides are greater than 0, the triangle is valid\n    return true;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <string>\n#include <cassert>\n\nbool check_equality(const std::string& s) {\n    return s.front() == s.back();\n}\n\nint count_substring_with_equal_ends(const std::string& s) {\n    int result = 0;\n    int n = s.length();\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == s[n - 1 - i]) {\n            ++result;\n        }\n    }\n    return result;\n}\n\n"], ["\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<assert.h>\n\n// 函数定义\nint find_divisor(int x, int y) {\n    if (x == y) {\n        return 0; // No common divisor\n    }\n    for (int i = 2; i <= y / i; ++i) {\n        if (y % i == 0) {\n            return i; // Found a common divisor\n        }\n    }\n    return y; // No common divisors\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <cassert>\nusing namespace std;\n\nclass node {\npublic:\n    int value;\n    int list_num;\n    int index;\n    node(int value, int list_num, int index) : value(value), list_num(list_num), index(index) {}\n    bool operator<(const node& other) const {\n        return value > other.value; // Use greater to simulate min heap in priority queue\n    }\n};\n\npair<int, int> find_minimum_range(vector<vector<int>>& lists) {\n    int high = numeric_limits<int>::min();\n    pair<int, int> p = make_pair(0, numeric_limits<int>::max());\n    priority_queue<node> pq;\n    for (int i = 0; i < lists.size(); ++i) {\n        pq.push(node(lists[i][0], i, 0));\n        high = max(high, lists[i][0]);\n    }\n    while (!pq.empty()) {\n        node top = pq.top();\n        pq.pop();\n        if (top.index == 0) {\n            continue;\n        }\n        if (top.index == lists[top.list_num].size() - 1) {\n            continue;\n        }\n        int left = top.index;\n        int right = top.index + 1;\n        if (left < right) {\n            p.first = min(p.first, left);\n            p.second = max(p.second, right);\n        }\n    }\n    return p;\n}\n\n"], ["\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<cmath>\n#include<assert.h>\n\nint count_odd_squares(int n, int m) {\n    int count = 0;\n    for (int i = 1; i <= m; ++i) {\n        if (i % 2 != 0) {\n            count += i * i;\n        }\n    }\n    return count;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint count_squares(int m, int n) {\n    if (n < m) {\n        int temp = m;\n        m = n;\n    }\n    int count = 0;\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (i * i + j * j == m * m) {\n                ++count;\n            }\n        }\n    }\n    return count;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\nint minimum_length(std::string s) {\n    int max_occ = 0;\n    int n = s.length();\n    std::vector<int> arr(26, 0);\n    for (int i = 0; i < n; i++) {\n        arr[s[i] - 'a']++;\n    }\n\n    // Find the maximum occurrence of any character\n    for (int i = 0; i < 26; i++) {\n        if (arr[i] > max_occ) {\n            max_occ = arr[i];\n        }\n    }\n\n    // Remove all characters that appear more than once\n    for (int i = 0; i < n; i++) {\n        if (arr[s[i] - 'a'] == max_occ) {\n            s.erase(i, 1);\n            i--;\n        }\n    }\n\n    return s.length();\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nint first_element(const std::vector<int>& arr, int n, int k) {\n    std::map<int, int> count_map;\n    for (int i = 0; i < n; ++i) {\n        if (count_map.find(arr[i]) != count_map.end()) {\n            count_map[arr[i]] += 1;\n        } else {\n            count_map[arr[i]] = 1;\n        }\n    }\n\n    int result = -1;\n    for (const auto& pair : count_map) {\n        if (pair.second == k) {\n            result = pair.first;\n            break;\n        }\n    }\n\n    return result;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <string>\n#include <cassert>\n\nbool unique_characters(std::string str) {\n    for (int i = 0; i < str.length(); i++) {\n        for (int j = i + 1; j < str.length(); j++) {\n            if (str[i] == str[j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint count_rectangles(int radius) {\n    int rectangles = 0;\n    int diameter = 2 * radius;\n    int diameter_square = diameter * diameter;\n    for (int a = 1; a < 2 * radius; a++) {\n        for (int b = 1; b < 2 * radius; b++) {\n            int diagnal_length_square = (a * a + b * b);\n            if (diagonal_length_square <= diameter_square) {\n                rectangles++;\n            }\n        }\n    }\n    return rectangles;\n}\n\n"], ["using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\nstd::string check_solution(int a, int b, int c) {\n    if (2 * b * b == 9 * a * c) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n"], ["\n#include<iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\nvector<tuple<int, int, int>> add_k_element(vector<tuple<int, int, int>> test_list, int k) {\n    vector<tuple<int, int, int>> res;\n    for (auto &sub : test_list) {\n        int a = sub.first + k;\n        int b = sub.second + k;\n        int c = sub.third + k;\n        res.push_back({a, b, c});\n    }\n    return res;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint count_digit(int n) {\n    int count = 0;\n    while (n != 0) {\n        n /= 10;\n        count++;\n    }\n    return count;\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <climits>\nusing namespace std;\n\nint adjacent_num_product(const vector<int>& list_nums) {\n    if (list_nums.size() < 2) {\n        return 0; // Return 0 if there are less than two elements\n    }\n\n    int max_product = list_nums[0] * list_nums[1];\n    for (size_t i = 1; i < list_nums.size() - 1; ++i) {\n        int current_product = list_nums[i] * list_nums[i + 1];\n        if (current_product > max_product) {\n            max_product = current_product;\n        }\n    }\n\n    return max_product;\n}\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nclass node {\npublic:\n    int data;\n    node* left;\n    node* right;\n    node(int value) : data(value), left(nullptr), right(nullptr) {}\n};\n\nint get_height(node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return max(get_height(root->left), get_height(root->right)) + 1;\n}\n\nbool is_balanced(node* root) {\n    if (root == nullptr) {\n        return true;\n    }\n    int left_height = get_height(root->left);\n    int right_height = get_height(root->right);\n\n    if (abs(left_height - right_height) > 1) {\n        return false;\n    }\n\n    return is_balanced(root->left) && is_balanced(root->right);\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\nvector<tuple<int, int>> repeat_tuples(tuple<int, int> test_tup, int n) {\n    vector<tuple<int, int>> res(n, test_tup);\n    return res;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint lateralsurface_cuboid(int l, int w, int h) {\n    int l_s_a = 2 * h * (l + w);\n    return l_s_a;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint smallest_missing(const std::vector<int>& a, int left_element, int right_element) {\n    if (left_element > right_element) {\n        return left_element;\n    }\n    int mid = left_element + (right_element - left_element) / 2;\n    if (a[mid] == mid) {\n        // If the middle element is equal to its index, then the missing element is at the next index\n        return mid + 1;\n    } else {\n        // If the middle element is not equal to its index, then the missing element is at the previous index\n        return mid;\n    }\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <set>\n#include <tuple>\n#include <cassert>\n#include <typeinfo>\n#include <string>\n#include <stdexcept>\nusing namespace std;\n\nclass element {\npublic:\n    virtual ~element() = default;\n    virtual bool is_int() const = 0;\n    virtual bool is_string() const = 0;\n    virtual int get_int() const = 0;\n    virtual string get_string() const = 0;\n};\n\n// 派生类 IntElement\nclass int_element : public element {\npublic:\n    int_element(int value) : value(value) {}\n    bool is_int() const override {\n        return true;\n    }\n    bool is_string() const override {\n        return false;\n    }\n    int get_int() const override {\n        return value;\n    }\n    string get_string() const override {\n        throw runtime_error(\"Not a string\");\n    }\nprivate:\n    int value;\n};\n\n// 派生类 StringElement\nclass string_element : public element {\npublic:\n    string_element(const string& value) : value(value) {}\n    bool is_int() const override {\n        return false;\n    }\n    bool is_string() const override {\n        return true;\n    }\n    int get_int() const override {\n        throw runtime_error(\"Not an integer\");\n    }\n    string get_string() const override {\n        return value;\n    }\nprivate:\n    string value;\n};\n\nstruct ElementComparator {\n    bool operator()(const element* lhs, const element* rhs) const {\n        if (lhs->is_int() && rhs->is_int()) {\n            return lhs->get_int() < rhs->get_int();\n        } else if (lhs->is_string() && rhs->is_string()) {\n            return lhs->get_string() < rhs->get_string();\n        } else {\n            return lhs->get_string() < rhs->get_string();\n        }\n    }\n};\n\n// Function to remove tuple elements that occur more than once and replace the duplicates with a custom value\nvoid remove_duplicates_and_replace(const vector<tuple<int, string>>& input, const string& custom_value) {\n    unordered_set<string> seen_values;\n    vector<tuple<int, string>> result;\n\n    for (const auto& element : input) {\n        if (!seen_values.count(element.second)) {\n            seen_values.insert(element.second);\n            result.push_back(element);\n        }\n    }\n\n    // Replace duplicates with the custom value\n    for (auto& element : result) {\n       "], ["\n#include<cassert>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string remove_char(std::string s, char c) {\n    // Use std::remove_if to remove all occurrences of c from s\n    s.erase(std::remove_if(s.begin(), s.end(), [&c](char ch) { return ch == c; }), s.end());\n    return s;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint surfacearea_cuboid(int l, int w, int h) {\n    int s_a = 2 * (l * w + l * h + w * h);\n    return s_a;\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint find_rotation_count(const vector<int>& a) {\n    int left = 0, right = a.size() - 1;\n    while (left <= right) {\n        if (a[left] <= a[right]) {\n            return left;\n        }\n        int mid = (left + right) / 2;\n        int next = (mid + 1) % a.size();\n        int prev = (mid - 1 + a.size()) % a.size();\n        // Find the position of the element that is greater than the next element\n        while (next < a.size() && a[next] > a[mid]) {\n            next = (next + 1) % a.size();\n        }\n        // Find the position of the element that is less than the previous element\n        while (prev >= 0 && a[prev] < a[mid]) {\n            prev = (prev - 1) % a.size();\n        }\n        // If the next element is greater than the previous element, there is a rotation\n        if (next > prev) {\n            return mid;\n        }\n        // Move the search range based on the comparison result\n        if (a[mid] > a[left]) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    // If no rotation is found, return the size of the array\n    return a.size();\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint frequency_of_smallest(int n, std::vector<int> arr) {\n    int mn = arr[0];\n    int freq = 1;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < mn) {\n            mn = arr[i];\n            freq = 1;\n        } else if (arr[i] == mn) {\n            freq++;\n        }\n    }\n    return freq;\n}\n\n"], ["\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <sstream>\n\nstd::string even_or_odd(const std::string& n) {\n    int l = n.length();\n    char last_char = n[l - 1];\n    if (last_char == '0' || last_char == '2' ||\n        last_char == '4' || last_char == '6' ||\n        last_char == '8' || last_char == 'A' ||\n        last_char == 'C' || last_char == 'E' ||\n        last_char == 'G' || last_char == 'I' ||\n        last_char == 'K' || last_char == 'M' ||\n        last_char == 'N' || last_char == 'P' ||\n        last_char == 'Q' || last_char == 'R' ||\n        last_char == 'S' || last_char == 'T' ||\n        last_char == 'U' || last_char == 'V' ||\n        last_char == 'W' || last_char == 'X' ||\n        last_char == 'Y' || last_char == 'Z') {\n        return \"Even\";\n    } else {\n        return \"Odd\";\n    }\n}\n\n"], ["\nusing namespace std;\n\n#include<cassert>\n#include <iostream>\n\n// 函数定义\nint highest_power_of_2(int n) {\n    int res = 0;\n    for (int i = n; i > 0; i--) {\n        if ((i & (i - 1)) == 0) {\n            res = max(res, i);\n        }\n    }\n    return res;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint median_numbers(int a, int b, int c) {\n    // Sort the numbers\n    int sorted_a = std::min(a, b);\n    int sorted_b = std::max(a, b);\n    int sorted_c = std::max(c, b);\n\n    // Check if the number of elements is odd\n    if (sorted_a == sorted_b && sorted_b == sorted_c) {\n        return sorted_a;\n    }\n\n    // Calculate the median\n    if (sorted_a == sorted_b) {\n        return sorted_a;\n    } else if (sorted_a == sorted_c) {\n        return sorted_c;\n    } else {\n        return (sorted_a + sorted_b) / 2;\n    }\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <cctype>\nusing namespace std;\n\nint sum_of_digits(vector<int> nums) {\n    int result = 0;\n    for (int n : nums) {\n        string num_str = to_string(n);\n        for (char c : num_str) {\n            if (isdigit(c)) {\n                result += c - '0';\n            }\n        }\n    }\n    return result;\n}\n\n"], ["\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\nint ncr_modp(int n, int r, int p) {\n    std::vector<int> c(r + 1, 0);\n    c[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = std::min(i, r); j > 0; --j) {\n            c[j] = (c[j] * (i - j)) % p;\n        }\n    }\n    return c[r];\n}\n\n"], ["\n#include<iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\n\nbool is_valid_u_r_l(string url) {\n    regex pattern(\"((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)\");\n    return regex_match(url, pattern);\n}\n\n"], ["\n#include <iostream>\n#include <tuple>\n#include <type_traits>\n#include <cstddef>\n#include <cassert>\nusing namespace std;\nusing MyTuple = tuple<char, int, char, char, char, char, char, char, char, char>;\n\ntemplate<typename T, size_t i = 0>\nbool check_tuplex(const MyTuple& t, const T& value) {\n    if constexpr (i == tuple_size<MyTuple>::value) {\n        return false;\n    }\n    if (t[i] == value) {\n        return true;\n    }\n    return check_tuplex(t, value);\n}\n\n"], ["\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <bitset>\n\nstd::string find_parity(unsigned int x) {\n    // XOR with itself to get the number with odd bits set\n    unsigned int y = x ^ x;\n    \n    // XOR with the rightmost bit to get the number with even bits set\n    y = y ^ (y >> 1);\n    \n    // XOR with the next rightmost bit to get the number with odd bits set\n    y = y ^ (y >> 2);\n    \n    // XOR with the next rightmost bit to get the number with even bits set\n    y = y ^ (y >> 4);\n    \n    // XOR with the next rightmost bit to get the number with odd bits set\n    y = y ^ (y >> 8);\n    \n    // Return the parity of the result\n    return (y & 1) ? \"odd\" : \"even\";\n}\n\n"], ["#include <vector>\n#include <queue>\n#include <cassert>\n#include <iostream>\nusing namespace std;\n\nvector<vector<int>> k_smallest_pairs(vector<int>& nums1, vector<int>& nums2, int k) {\n    // Create a priority queue to store pairs with the smallest sum\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    \n    // Iterate through each pair of elements from nums1 and nums2\n    for (int i = 0; i < nums1.size(); ++i) {\n        for (int j = 0; j < nums2.size(); ++j) {\n            // Calculate the sum of the current pair\n            int sum = nums1[i] + nums2[j];\n            \n            // If the sum is less than the smallest sum found so far, update the smallest sum\n            if (sum < pq.top().first) {\n                pq.pop();\n                pq.push({sum, {nums1[i], nums2[j]}});\n            } else if (sum == pq.top().first) {\n                // If the sum is equal to the smallest sum, compare the second elements\n                if (nums1[i] < nums2[j]) {\n                    pq.pop();\n                    pq.push({sum, {nums1[i], nums2[j]}});\n                } else {\n                    pq.pop();\n                    pq.push({sum, {nums2[i], nums1[j]}});\n                }\n            }\n        }\n    }\n    \n    // Extract the k smallest pairs from the priority queue\n    vector<vector<int>> result;\n    while (!pq.empty() && k-- > 0) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    \n    return result;\n}\n"], ["\n#include<iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n#include <string>\nusing namespace std;\n\ntemplate<typename T, size_t n>\nstruct TupleElement {\n    using type = typename tuple_element<n, tuple<T, int, int>>::type;\n};\n\ntemplate<typename T, size_t n>\nvector<typename TupleElement<T, n>::type> extract_nth_element(const vector<tuple<T, int, int>>& list1) {\n    if (n >= list1.size()) {\n        throw out_of_range(\"Index out of range\");\n    }\n    return {list1[n]};\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\npair<int, int> max_product(const vector<int>& arr) {\n    if (arr.empty() || arr.size() < 2) {\n        throw \"No pairs exists\";\n    }\n\n    int x = arr[0];\n    int y = arr[1];\n    int max_product = arr[0] * arr[1];\n\n    for (int i = 2; i < arr_len; i++) {\n        if (arr[i] > max_product) {\n            max_product = arr[i];\n            x = arr[i - 1];\n            y = arr[i];\n        }\n    }\n\n    return {x, y};\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint break_sum(int n) {\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n    \n    // Initialize the dp array with base cases\n    vector<int> dp(n + 1, 0);\n    dp[0] = 0;\n    dp[1] = 1;\n    \n    // Fill the dp array using dynamic programming\n    for (int i = 2; i <= n; ++i) {\n        dp[i] = max(dp[i - 1], dp[i - 2] + dp[i - 3]);\n    }\n    \n    return dp[n];\n}\n\n"], ["using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<cassert>\n\nstd::vector<int> find_max(std::vector<std::vector<int>>& lst) {\n    if (lst.empty()) {\n        return {};\n    }\n\n    int max_length = 0;\n    std::vector<int> result;\n\n    for (const auto& sub : lst) {\n        int current_length = sub.size();\n        if (current_length > max_length) {\n            max_length = current_length;\n            result = sub;\n        }\n    }\n\n    return result;\n}\n"], ["\nusing namespace std;\n\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n//函数定义\nint cube_sum(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i += 2) { // Start from 1 and increment by 2 to get even numbers\n        sum += i * i * i;\n    }\n    return sum;\n}\n\n"], ["\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <sstream>\n#include <tuple>\nusing namespace std;\n\n// Helper function to concatenate elements of the tuple\ntemplate<size_t index, typename... args>\nvoid concatenate_tuple_helper(ostringstream& oss, const string& delim, const tuple<args...>& test_tup) {\n    if (index != 0) {\n        oss << delim;\n    }\n    oss << get<index>(test_tup);\n}\n\n// Recursive function to iterate over the tuple\ntemplate<size_t index, typename... args>\nvoid iterate_tuple(ostringstream& oss, const string& delim, const tuple<args...>& test_tup) {\n    if constexpr (index == sizeof...(args)) {\n        return;\n    } else {\n        iterate_tuple(oss, delim, get<index>(test_tup));\n        oss << delim;\n    }\n}\n\n// Function to concatenate each element of the tuple by the delimiter\nstring concatenate_tuple(const string& delim, const tuple<>>& test_tup) {\n    ostringstream oss;\n    iterate_tuple(oss, delim, test_tup);\n    return oss.str();\n}\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble find_average_of_cube(int n) {\n    double sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += std::pow(i, 3);\n    }\n    return sum / n;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nint get_maxgold(vector<vector<int>> gold, int m, int n) {\n    vector<vector<int>> gold_table(m, vector<int>(n, 0));   \n    for (int col = n-1; col >= 0; col--) { \n        for (int row = 0; row < m; row++) { \n            int right = (col == n-1) ? 0 : gold_table[row][col+1];\n            int right_up = (row == 0 || col == n-1) ? 0 : gold_table[row-1][col+1];\n            int right_down = (row == m-1 || col == n-1) ? 0 : gold_table[row+1][col+1];\n            gold_table[row][col] = gold[row][col] + max({right, right_up, right_down});\n        }\n    }\n    return *max_element(gold_table.begin(), gold_table.end());\n}\n\n"], ["\nusing namespace std;\n#include <iostream>\n#include <cassert>\n\nint last_digit(int n) {\n    // Return the last digit of the number\n    return abs(n) % 10;\n}\n\n"], ["\nusing namespace std;\n\n#include<cassert>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nint multiple_to_single(const std::vector<int>& l) {\n    std::stringstream ss;\n    for (int num : l) {\n        ss << num;\n    }\n    return stoi(ss.str());\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<vector<int>> trim_tuple(const vector<vector<int>>& test_list, int k) {\n    vector<vector<int>> res;\n    for (const auto& ele : test_list) {\n        vector<int> tmp;\n        for (int i = k; i <= ele.size() - k - 1; i++) {\n            tmp.push_back(ele[i]);\n        }\n        res.push_back(tmp);\n    }\n    return res;\n}\n\n"], ["\n#include<iostream>\n#include <cassert>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\n// Helper function to perform index-wise multiplication\ntemplate<size_t i>\ntuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> index_multiplication_helper(\n    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup1,\n    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup2,\n    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> res)\n{\n    auto tup1 = get<i - 1>(test_tup1);\n    auto tup2 = get<i - 1>(test_tup2);\n    get<i - 1>(res) = make_tuple(get<0>(tup1) * get<0>(tup2), get<1>(tup1) * get<1>(tup2));\n    return index_multiplication_helper<i - 1>(test_tup1, test_tup2, res);\n}\n\n// Base case for the recursion\ntemplate<>\n//begin to write code\n-----------------------------\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_occurrence(const std::vector<char>& tup, const std::vector<char>& lst) {\n    int count = 0;\n    for (char item : tup) {\n        for (char elem : lst) {\n            if (item == elem) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n"], ["\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nstring check_triangle(int x1, int y1, int x2, int y2, int x3, int y3) {\n    // Calculate the area of the triangle using Heron's formula\n    double s = (x1 + x2 + x3) / 2.0;\n    double area = sqrt(s * (s - x1) * (s - x2) * (s - x3));\n    \n    // Check if the area is positive\n    if (area > 0) {\n        // Check if the triangle is valid\n        if (x1 + y2 > x3 && x1 + z3 > x2 && y1 + z2 > x3) {\n            return \"Valid\";\n        } else {\n            return \"Invalid\";\n        }\n    } else {\n        return \"No\";\n    }\n}\n\n"], ["\nusing namespace std;\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint sumof_factors(int n) {\n    if (n % 2 != 0) {\n        return 0;\n    }\n    int res = 1;\n    for (int i = 2; i <= static_cast<int>(std::sqrt(n)) + 1; ++i) {\n        int count = 0;\n        int curr_sum = 1;\n        int curr_term = 1;\n        while (n % i == 0) {\n            count++;\n            n = n / i;\n            curr_sum += curr_term;\n            curr_term *= i;\n        }\n        res += count * curr_sum;\n    }\n    return res;\n}\n\n"], ["\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\ntemplate <typename T>\nstd::vector<T> find_min(const std::vector<std::vector<T>>& lst) {\n    if (lst.empty()) {\n        return {};\n    }\n\n    int min_length = lst[0].size();\n    std::vector<T> min_sublist;\n\n    for (const auto& sublist : lst) {\n        if (sublist.size() < min_length) {\n            min_length = sublist.size();\n            min_sublist = sublist;\n        }\n    }\n\n    return min_sublist;\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> extract(const std::vector<std::vector<int>>& lst) {\n    std::vector<int> result;\n    for (const auto& item : lst) {\n        if (!item.empty()) {\n            result.push_back(item[0]);\n        }\n    }\n    return result;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint decimal_to_octal(int deci_num) {\n    int octal_num = 0;\n    int countval = 1;\n    int remainder;\n    while (deci_num != 0) {\n        remainder = deci_num % 8;\n        octal_num += remainder * countval;\n        countval *= 8;\n    }\n    return octal_num;\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nint max_product(vector<int> arr, int n) {\n    vector<int> mpis(n, 0);\n    {\n        int i = 0;\n        for (; i < n; ++i) {\n            mpis[i] = arr[i];\n        }\n    }\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (arr[j] > arr[i]) {\n                mpis[i] = max(mpis[i], mpis[j] * arr[i]);\n            }\n        }\n    }\n    return *max_element(begin(mpis), end(mpis));\n}\n\n"], ["using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n\nbool check_consecutive(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 1; i < l.size(); ++i) {\n        if (l[i] != l[i - 1] + 1) {\n            return false;\n        }\n    }\n    return true;\n}\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint first_digit(int n) {\n    while (n >= 10) {\n        n = n / 10;\n    }\n    return n;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nchar get_max_occuring_char(const std::string &str1) {\n    const int a_s_c_i_i_s_i_z_e = 256;\n    int ctr[a_s_c_i_i_s_i_z_e] = {0};\n    int max = -1;\n    char ch = '\\0';\n\n    for (char c : str1) {\n        ctr[c]++;\n        if (ctr[c] > max) {\n            max = ctr[c];\n            ch = c;\n        }\n    }\n\n    return ch;\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nint first_factorial_divisible_number(int x) {\n    int i = 1;\n    int fact = 1;\n    for (i = 1; i <= x; ++i) {\n        fact *= i;\n        if (fact % x == 0) {\n            return i;\n        }\n    }\n    return -1; // Return -1 if no such number exists\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nint find_largest_palindrome(vector<int>& nums) {\n    // Sort the vector in descending order\n    sort(nums.begin(), nums.end(), greater<int>());\n    \n    // Iterate from the end of the sorted vector to the beginning\n    for (int i = nums.size() - 1; i >= 0; --i) {\n        // Check if the current element is a palindrome\n        if (is_palindrome(nums[i])) {\n            return nums[i];\n        }\n    }\n    \n    // If no palindrome is found, return 0 (or any other default value)\n    return 0;\n}\n\n"], ["\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble n_cr(int n, int r) {\n    if (r > n / 2) {\n        r = n - r;\n    }\n    double answer = 1;\n    for (int i = 1; i <= r; i++) {\n        answer *= (n - r + i);\n    }\n    return answer;\n}\n\n"], ["\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint frequency_of_largest(int n, std::vector<int> arr) {\n    int mn = arr[0];\n    int freq = 1;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > mn) {\n            mn = arr[i];\n            freq = 1;\n        } else if (arr[i] == mn) {\n            freq++;\n        }\n    }\n    return freq;\n}\n\n"], ["#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\ntypedef std::vector<std::pair<double, double>> Polygon;\n\nstd::vector<Polygon> calculate_polygons(double startx, double starty, double endx, double endy, double radius)\n{\n    double sl = (2 * radius) * std::tan(m_p_i / 6);\n    double p = sl * 0.5;\n    double b = sl * std::cos(30 * m_p_i / 180.0);\n    double w = b * 2;\n    double h = 2 * sl;\n    startx = startx - w;\n    starty = starty - h;\n    endx = endx + w;\n    endy = endy + h;\n    double origx = startx;\n    double origy = starty;\n    double xoffset = b;\n    double yoffset = 3 * p;\n    std::vector<Polygon> polygons;\n    int row = 1;\n    int counter = 0;\n    while (starty < endy)\n    {\n        if (row % 2 == 0)\n        {\n            startx = origx + xoffset;\n        }\n        else\n        {\n            startx = origx;\n        }\n        while (startx < endx)\n        {\n            double x = startx;\n            double y = starty;\n            double dx = x - origx;\n            double dy = y - origy;\n            double d = std::sqrt(dx * dx + dy * dy);\n            if (d <= radius)\n            {\n                polygons.push_back({x, y});\n            }\n            startx += dx;\n            starty += dy;\n        }\n        row++;\n    }\n    return polygons;\n}\n"], ["#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint ngcd(int x, int y) {\n    int i = 1;\n    int gcd = 1;\n    for(;(i <= x && i <= y);){\n        if(x % i == 0 && y % i == 0) {\n            gcd = i;\n        }\n        i += 1;\n    }\n    return gcd;\n}\n\nint num_comm_div(int x, int y) {\n    int n = ngcd(x, y);\n    return n;\n}\n"], ["\n#include <iostream>\n#include <cassert>\n\nint sum_of_series(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i * i * i;\n    }\n    return sum;\n}\n\n"], ["\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> re_order(std::vector<int>& a) {\n    int k = 0;\n    for (int i : a) {\n        if (i != 0) {\n            a[k] = i;\n            k++;\n        }\n    }\n    return a;\n}\n\n"], ["\n#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint permutation_coefficient(int n, int k) {\n    vector<vector<int>> p(n + 1, vector<int>(k + 1, 0));\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= min(i, k); j++) {\n            if (j == 0)\n                p[i][j] = 1;\n            else {\n                p[i][j] = p[i - 1][j - 1] + p[i - 1][j];\n            }\n        }\n    }\n    return p[n][k];\n}\n\n"], ["\n#include <iostream>\n#include <cassert>\n\nint average_odd(int n) {\n    if (n % 2 == 0) {\n        std::cerr << \"Invalid Input\" << std::endl;\n        return -1;\n    }\n    int sm = 0;\n    int count = 0;\n    for (int i = 1; i <= n; i += 2) {\n        sm += i;\n        count++;\n    }\n    return static_cast<int>(sm / count);\n}\n\n"]]