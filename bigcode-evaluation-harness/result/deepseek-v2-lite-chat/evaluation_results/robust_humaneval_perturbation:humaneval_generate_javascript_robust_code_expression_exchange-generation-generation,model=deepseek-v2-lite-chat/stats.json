[
  {
    "name": {
      "name": "full_level_robustness",
      "split": "test"
    },
    "count": 65,
    "generations": [
      [
        "const hasCloseElements = (numbers, threshold) => {\n  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (j != i) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};"
      ],
      [
        "const separateParenGroups = (paren_string) => {\n  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if ('(' == c) {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (')' == c) {\n      current_depth -= 1;\n      current_string.pop();\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n      }\n    } else if (current_depth > 0) {\n      current_string.push(c);\n    }\n  }\n\n  return result;\n};"
      ],
      [
        "const belowZero = (operations) => {\n  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};"
      ],
      [
        "const intersperse = (numbers, delimeter) => {\n  if (!Array.isArray(numbers) || 0 == numbers.length)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n);\n    result.push(delimeter);\n  }\n  result.pop(); // Remove the trailing delimeter\n  return result;\n}"
      ],
      [
        "const parseNestedParens = (paren_string) => {\n  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if ('(' == c) {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else if(')' == c) {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  };\n  \n  let groups = paren_string.split(' ');\n  let result = [];\n  \n  for (let group of groups) {\n    result.push(parseParenGroup(group));\n  }\n  \n  return result;\n};"
      ],
      [
        "const filterBySubstring = (strings, substring) => {\n  return strings.filter(x => -1 != x.indexOf(substring));\n}"
      ],
      [
        "const sumProduct = (numbers, sum_value = 0, prod_value = 1) => {\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return (0, 1);\n};"
      ],
      [
        "const rollingMax = (numbers) => {\n  var running_max, result = [];\n  for (const n of numbers) {\n    if (undefined == running_max)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}"
      ],
      [
        "Complete code (including all the content of the code I provided and the code you generated)"
      ],
      [
        "const stringXor = (a, b) => {\n  var xor = function (i, j) {\n    if (j == i)\n      return '0';\n    else\n      return '1';\n  };\n\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += xor(parseInt(a[i]), parseInt(b[i]));\n  }\n\n  return result;\n};"
      ],
      [
        "const longest = (strings) => {\n  if (!Array.isArray(strings) || 0 == strings.length)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length === maxlen) return s;\n  }\n  return strings[0];\n}"
      ],
      [
        "const greatestCommonDivisor = (a, b) => {\n  while (0 != b) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}"
      ],
      [
        "const allPrefixes = (string) => {\n  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, 1 + i));\n  }\n  return result;\n}"
      ],
      [
        "const parseMusic = (music_string) => {\n  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => '' != x).map(x => note_map[x]);\n}"
      ],
      [
        "const howManyTimes = (string, substring) => {\n  var times = 0;\n  for (let i = 0; i < 1 + string.length - substring.length; i++) {\n    if (substring == string.slice(i, i+substring.length)) {\n      times += 1;\n    }\n  }\n  return times;\n}"
      ],
      [
        "const findClosestElements = (numbers) => {\n  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (j != i) {\n        let a = numbers[i], b = numbers[j];\n        if (null == distance) {\n          distance = Math.abs(a - b);\n          closest_pair = [a, b];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [a, b];\n          }\n        }\n      }\n  return closest_pair;\n};"
      ],
      [
        "const largestDivisor = (n) => {\n  for (let i = n - 1; i >= 0; i--)\n    if (0 == n % i)\n      return i;\n};"
      ],
      [
        "const factorize = (n) => {\n  var fact = [], i = 2;\n  while (i <= 1 + Math.sqrt(n)) {\n    if (0 == n % i) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  if (n > 1) fact.push(n);\n  return fact;\n}"
      ],
      [
        "const removeDuplicates = (numbers) => {\n  var dict = {};\n  for (const num of numbers) {\n    if (dict[num] === undefined) {\n      dict[num] = 1;\n    } else {\n      dict[num]++;\n    }\n  }\n  return Object.keys(dict).filter(key => dict[key] === 1).map(key => parseInt(key));\n}"
      ],
      [
        "const flipCase = (string) => {\n  return string.split('')\n          .map(x => (x == x.toUpperCase() ? x.toLowerCase() : x.toUpperCase()))\n}"
      ],
      [
        "const isPrime = (n) => {\n  if (n < 2)\n    return false;\n  for (let k = 2; k < n; k++) {\n    if (n % k === 0) {\n      return false;\n    }\n  }\n  return true;\n}"
      ],
      [
        "/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having an even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin = begin * (2.0);\n    end = end * (2.0);\n  }\n  while (end - begin > 1e-10) {"
      ],
      [
        "const sortThird = (l) => {\n  var three = l.filter((item, index) => 0 == index % 3);\n  three.sort((a, b) => (a - b));\n  return l;\n}"
      ],
      [
        "const fizzBuzz = (n) => {\n  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (0 == i % 11 || 0 == i % 13)\n      ns.push(i);\n  for (let i = 0; i < ns.length; i++)\n    for (let digit in ns[i])\n      if (ns[i][digit] === '7')\n        ans++;\n  return ans;\n}"
      ],
      [
        "const sortEven = (l) => {\n  var even = l.filter((item, index) => 0 == index % 2);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => index % 2 ? even[index / 2] : item);\n}"
      ],
      [
        "const { encodeCyclic, decodeCyclic } = require('path/to/your/package');"
      ],
      [
        "const primeFib = (n) => {\n  var isPrime = function (p) {\n    if (p < 2)\n      return 0;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return 0;\n    }\n    return 1;\n  }\n\n  var fib = function (n) {\n    let a = 0, b = 1, c = 0;\n    while (c < n) {\n      c = a + b;\n      a = b;\n      b = c;\n    }\n    return c;\n  }\n\n  let count = 0;\n  let num = 1;\n  while (count < n) {\n    if (isPrime(num)) count++;\n    num = fib(num);\n  }\n  return num;\n}"
      ],
      [
        "const triplesSumToZero = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      for (let k = j + 1; k < l.length; k++) {\n        if (l[i] + l[j] + l[k] === 0) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};"
      ],
      [
        "const incrList = (l) => {\n  return l.map(e => e + 1);\n}"
      ],
      [
        "const pairsSumToZero = (l) => {\n  for (let i = 0; i < l.length; i = i + 1)\n    for (let j = i + 1; j < l.length; j = j + 1)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}"
      ],
      [
        "/*Given length of a side and high return area for a triangle.\n  >>> triangleArea(a, h)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return h * a / 2.0;\n}"
      ],
      [
        "const fib4 = (n) => {\n  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < 1 + n; i++) {\n    results[i] = results[i - 1] + results[i - 2] + results[i - 3] + results[i - 4];\n  }\n  return results[n];\n}"
      ],
      [
        "const median = (l) => {\n  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (1 == l.length % 2) {\n    return l[Math.floor(len / 2)];\n  } else {\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n  }\n}"
      ],
      [
        "const isPalindrome = (text) => {\n  for (let i = 0; i < text.length; i++)\n    if (text.at(-i-1) != text[i])\n      return false;\n  return true;\n}"
      ],
      [
        "const modp = (n, p) => {\n  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (ret * 2) % p;\n  return ret;\n}"
      ],
      [
        "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((5 + ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((26 + ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}"
      ],
      [
        "const belowThreshold = (l, t) => {\n  for (const e of l) {\n    if (e >= t) {\n      return false;\n    }\n  }\n  return true;\n};"
      ],
      [
        "const sameChars = (s0, s1) => {\n  return JSON.stringify([...new Set(s1)].sort()) === JSON.stringify([...new Set(s0)].sort());\n}"
      ],
      [
        "const fib = (n) => {\n  if (0 == n)\n    return 0;\n  if (1 == n)\n    return 1;\n  let a = 0, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const temp = a;\n    a = b;\n    b += temp;\n  }\n  return b;\n}"
      ],
      [
        "const correctBracketing = (brackets) => {\n  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth = depth + 1;\n    else if (b == \">\")\n      depth = depth - 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth === 0;\n}"
      ],
      [
        "const monotonic = (l) => {\n  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  return JSON.stringify(sort1) === JSON.stringify(l) || JSON.stringify(sort2) === JSON.stringify(l);\n}"
      ],
      [
        "const largestPrimeFactor = (n) => {\n  const isPrime = (k) => {\n    if (k < 2) return 0;\n    for (let i = 2; i < k; i++)\n      if (k % i === 0) return 0;\n    return 1;\n  };\n\n  let largest = 2;\n  for (let i = 3; i <= n; i += 2) {\n    if (isPrime(i) && n % i === 0) {\n      largest = i;\n      while (n % largest === 0) n /= largest;\n    }\n  }\n\n  return n === largest ? largest : n;\n};"
      ],
      [
        "const sumToN = (n) => {\n  return (1 + n) * n / 2;\n}"
      ],
      [
        "const correctBracketing = (brackets) => {\n  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth = depth + (1);\n    else if (b == \")\")\n      depth = depth - (1);\n    else\n      return false;\n  }\n  return depth == 0;\n}"
      ],
      [
        "const derivative = (xs) => {\n  return xs.map((x, i) => i * x).slice(1);\n}"
      ],
      [
        "const fibfib = (n) => {\n  if (0 == n || 1 == n)\n    return 0;\n  if (2 == n)\n    return 1;\n  let dp = new Array(n + 1).fill(0);\n  dp[2] = 1;\n  for (let i = 3; i <= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n  }\n  return dp[n];\n}"
      ],
      [
        "const digitSum = (s) => {\n  if ('' == s) return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0);\n    return ord_char >= 65 && ord_char <= 90 ? prev + ord_char : prev;\n  }, 0);\n};"
      ],
      [
        "const pluck = (arr) => {\n  if (0 == arr.length) return [];\n  var evens = arr.filter(x => 0 == x % 2);\n  if (0 == evens.length) return [];\n  var smallestEven = evens[0];\n  for (var i = 1; i < evens.length; i++) {\n    if (evens[i] < smallestEven) {\n      smallestEven = evens[i];\n    }\n  }\n  return [smallestEven, arr.indexOf(smallestEven)];\n}"
      ],
      [
        "const search = (lst) => {\n  var frq = new Array(1 + Math.max(...lst)).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++) {\n    if (frq[i] >= i) {\n      ans = i;\n      break;\n    }\n  }\n  return ans;\n}"
      ],
      [
        "const strangeSortList = (lst) => {\n  var res = [], sw = 1;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n  }\n  while (res.length) {\n    lst.push(res.pop());\n  }\n  return lst;\n}"
      ],
      [
        "const willItFly = (q, w) => {\n  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[j] != q[i])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n};"
      ],
      [
        "const smallestChange = (arr) => {\n  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr.at(-i - 1) != arr[i])\n      ans++;\n  return ans;\n}"
      ],
      [
        "const isMultiplyPrime = (a) => {\n  const isPrime = (n) => {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    let count = 0;\n    for (let j = i; j <= a; j += i)\n      if (j == i) count++;\n      else count += isPrime(j / i);\n    if (count === 3 && isPrime(i)) return true;\n  }\n  return false;\n}"
      ],
      [
        "const isSimplePower = (x, n) => {\n  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x) power *= n;\n  return power == x;\n}"
      ],
      [
        "const iscube = (a) => {\n  a = Math.abs(a);\n  return (a == Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3));\n}"
      ],
      [
        "const isHappy = (s) => {\n  if (s.length < 3)\n    return 0;\n  for (let i = 0; i < s.length - 2; i++) {\n    let triplet = s.slice(i, i + 3);\n    if (new Set(triplet).size !== 3)\n      return 0;\n  }\n  return 1;\n}"
      ],
      [
        "const numericalLetterGrade = (grades) => {\n  let letter_grade = [];\n  for (let i = 0, len = grades.length; i < len; i = i + 1) {\n    let gpa = grades[i];\n    if (gpa == 4.0) {\n      letter_grade.push('A+');\n    } else if (gpa > 3.7) {\n      letter_grade.push('A');\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-');\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+');\n    } else if (gpa > 2.7) {\n      letter_grade.push('B');\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-');\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+');\n    } else if (gpa > 1.7) {\n      letter_grade.push('C');\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-');\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+');\n    } else if (gpa > 0.7) {\n      letter_grade.push('D');\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-');\n    } else {\n      letter_grade.push('E');\n    }\n  }\n  return letter_grade;\n};"
      ],
      [
        "const isPrime = (num) => {\n  for(let i = 2, sqrt = Math.sqrt(num); i <= sqrt; i++) {\n    if(num % i === 0) return false;\n  }\n  return num > 1;\n}\n\nconst primeLength = (string) => {\n  let len = string.length;\n  if (len == 1 || len == 0) { return 0 }\n  return isPrime(len);\n}"
      ],
      [
        "const startsOneEnds = (n) => {\n  if (1 == n) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t += 10 * (9 * Math.pow(10, i - 1) + (9 * Math.pow(10, i) - 9 * Math.pow(10, i - 1)))\n  }\n  return t\n}"
      ],
      [
        "const solve = (N) => {\n  let t = 0\n  while (N > 0) {\n    t = t + (N % 10)\n    N = Math.floor(N / 10)\n  }\n  return t.toString(2);\n}"
      ],
      [
        "const add = (lst) => {\n  let t = 0\n  for (let i = 1; i < lst.length; i = i + (2)) {\n    if (lst[i] % 2 == 0) {\n      t = t + (lst[i])\n    }\n  }\n  return t;\n}"
      ],
      [
        "const antiShuffle = (s) => {\n  let arr = s.split(/\\s/);\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j;\n      for (let k = 1 + j; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k;\n        }\n      }\n      let temp = arr[i][j];\n      arr[i][j] = arr[i][ind];\n      arr[i][ind] = temp;\n    }\n  }\n  return arr.join(' ');\n};"
      ],
      [
        "const getRow = (lst, x) => {\n  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (x == lst[i][j]) {\n        t.push([i, j]);\n      }\n    }\n  }\n  return t.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\n};"
      ],
      [
        "const sortArray = (array) => {\n  let arr = array\n  let tot = arr[0] + arr[arr.length - 1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = 1 + j; k < arr.length; k++) {\n      if ((1 == tot % 2 && arr[k] < arr[ind]) || (0 == tot % 2 && arr[k] > arr[ind])) {\n        let temp = arr[j]\n        arr[j] = arr[k]\n        arr[k] = temp\n      }\n    }\n  }\n  return arr\n}"
      ],
      [
        "const encrypt = (s) => {\n  let t = ''\n  for (let i = 0; i < s.length; i = i + 1) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p = p - (26) }\n    t += String.fromCharCode(p)\n  }\n  return t\n}"
      ],
      [
        "const nextSmallest = (lst) => {\n  let arr = lst\n  for (let j = 0; j < arr.length; j = j + 1) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k = k + 1) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    if (ind !== j) {\n      let temp = arr[j]\n      arr[j] = arr[ind]\n      arr[ind] = temp\n    }\n  }\n  if (arr[0] < arr[1]) {\n    return arr[1]\n  } else {\n    return null\n  }\n}"
      ],
      [
        "const isBored = (S) => {\n  let t = 0;\n  if ('I' == S[0] && ' ' == S[1]) { t = 1; }\n  for (let i = 0; i < S.length; i++) {\n    if ('.' == S[i] || '!' == S[i] || '?' == S[i]) {\n      if (' ' == S[1 + i] && 'I' == S[2 + i] && ' ' == S[3 + i]) {\n        t++;\n      }\n    }\n  }\n  return t;\n};"
      ],
      [
        "const anyInt = (x, y, z) => {\n  if (0 === x % 1 && 0 === y % 1 && 0 === z % 1 && (z === x + y || y === x + z || y + z === x)) {\n    return true\n  }\n  return false\n}"
      ],
      [
        "const encode = (message) => {\n  let t = ''\n  for (let i = 0; i < message.length; i = i + 1) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p = p - (32) }\n    t += String.fromCharCode(p)\n  }\n  return t\n}"
      ],
      [
        "const skjkasdkd = (lst) => {\n  let t = 0;\n  let largestPrime = -1;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largestPrime && isPrime(lst[i])) {\n      largestPrime = lst[i];\n    }\n  }\n\n  function isPrime(num) {\n    for (let i = 2, sqrt = Math.sqrt(num); i <= sqrt; i++) {\n      if (num % i === 0) return false;\n    }\n    return num > 1;\n  }\n\n  if (largestPrime === -1) return 0;\n\n  let sumOfDigits = Array.from(String(largestPrime), Number).reduce((a, b) => a + b, 0);\n  return sumOfDigits;\n};"
      ],
      [
        "const checkDictCase = (dict) => {\n  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c = c + 1\n    if (typeof dict[key] !== 'string') return false\n    if (dict[key].toLowerCase() !== dict[key]) lo = hi = 1\n    else if (dict[key].toUpperCase() !== dict[key]) hi = 1\n  }\n  return c === lo || c === hi;\n}"
      ],
      [
        "const countUpTo = (n) => {\n  let t = []\n  for (let i = 2; i < n; i = i + 1) {\n    let p = 1\n    for (let j = 2; j * j <= i; j = j + 1) {\n      if (i % j === 0) {\n        p = 0\n        break\n      }\n    }\n    if (p) {\n      t.push(i)\n    }\n  }\n  return t\n}"
      ],
      [
        "const countUpper = (s) => {\n  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if ('A' == s[i] || 'E' == s[i] || 'I' == s[i] || 'O' == s[i] || 'U' == s[i]) { p++ }\n  }\n  return p;\n}"
      ],
      [
        "const closestInteger = (value) => {\n  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value = value - (t) }\n  return Math.trunc(value)\n}"
      ],
      [
        "const makeAPile = (n) => {\n  let t = []\n  for (let i = n; i < 3 * n; i += 2) {\n    t.push(i)\n  }\n  return t\n}"
      ],
      [
        "const wordsString = (s) => {\n  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (' ' == s[i] || ',' == s[i]) {\n      if (0 == k) {\n        k = 1;\n        p.push(t);\n      }\n      t += s[i]\n    }\n  }\n  if (0 == k) {\n    k = 1;\n    p.push(t);\n  }\n  return p;\n}"
      ],
      [
        "const chooseNum = (x, y) => {\n  for (let i = y; i >= x; i--) {\n    if (0 == i % 2) {return i }\n  }\n  return -1;\n};"
      ],
      [
        "const roundedAvg = (n, m) => {\n  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (0 != k % 1) { k = (1 + n + m) / 2 }\n  return parseInt(k.toString(2), 10).toString(2);\n}"
      ],
      [
        "const uniqueDigits = (x) => {\n  let p = []\n  for (let i = 0; i < x.length; i = i + 1) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) p.push(x[i])\n  }\n  return p.sort((a, b) => a - b)\n}"
      ],
      [
        "const byLength = (arr) => {\n  const p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = 1 + j; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    let temp = p[j]\n    p[j] = p[ind]\n    p[ind] = temp\n  }\n  let result = []\n  for (let l = 0; l < p.length; l++) {\n    if (p[l] === 1) { result.push('One') }\n    else if (p[l] === 2) { result.push('Two') }\n    else if (p[l] === 3) { result.push('Three') }\n    else if (p[l] === 4) { result.push('Four') }\n    else if (p[l] === 5) { result.push('Five') }\n    else if (p[l] === 6) { result.push('Six') }\n    else if (p[l] === 7) { result.push('Seven') }\n    else if (p[l] === 8) { result.push('Eight') }\n    else if (p[l] === 9) { result.push('Nine') }\n  }\n  return result\n}"
      ],
      [
        "const f = (n) => {\n  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i = i + 1) {\n    p = p + i;\n    if (i % 2 === 0) {\n      f *= i;\n    } else {\n      f = p;\n    }\n    k.push(f);\n  }\n  return k;\n}"
      ],
      [
        "const evenOddPalindrome = (n) => {\n  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[k.length - j - 1] != k[j]) {\n        p = 0\n        break\n      }\n    }\n    if (p) {\n      if (i % 2 === 0) {\n        e++\n      } else {\n        o++\n      }\n    }\n  }\n  return (e, o)\n}"
      ],
      [
        "const countNums = (arr) => {\n  let p = 0\n  for (let i = 0; i < arr.length; i = i + 1) {\n    let h = arr[i]\n    if (h > 0) {\n      p = p + 1;\n      continue;\n    }\n    // Calculate the sum of digits and check if it's greater than 0\n    let sum = 0;\n    let sign = h < 0 ? -1 : 1;\n    h = Math.abs(h);\n    while (h > 0) {\n      sum += h % 10;\n      h = Math.floor(h / 10);\n    }\n    if (sum * sign > 0) {\n      p++;\n    }\n  }\n  return p;\n}"
      ],
      [
        "const moveOneBall = (arr) => {\n  if (0 == arr.length) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n      }\n    }\n    k += t;\n  }\n  return k <= 1;\n}"
      ],
      [
        "const exchange = (lst1, lst2) => {\n  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i = i + 1) {\n    if (lst1[i] % 2 == 0) { t = t + 1 }\n  }\n  for (let i = 0; i < lst2.length; i = i + 1) {\n    if (lst2[i] % 2 != 0) { k = k + 1 }\n  }\n  return t >= k ? \"YES\" : \"NO\";\n}"
      ],
      [
        "const histogram = (test) => {\n  let d = {}\n  let t = test.split(/\\s/);\n  if ('' == test) { t = []; }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    } else {\n      d[t[m]] = 1;\n    }\n  }\n  let maxCount = 0;\n  let maxLetters = [];\n  for (let letter in d) {\n    if (d[letter] > maxCount) {\n      maxCount = d[letter];\n      maxLetters = [letter];\n    } else if (d[letter] === maxCount) {\n      maxLetters.push(letter);\n    }\n  }\n  return maxLetters.reduce((acc, letter) => ({ ...acc, [letter]: maxCount }), {});\n}"
      ],
      [
        "const reverseDelete = (s, c) => {\n  let t = '';\n  for (let i = 0; i < s.length; i++) {\n    let y = 1;\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] === c[j]) {\n        y = 0;\n      }\n    }\n    if (y === 1) {\n      t += s[i];\n    }\n  }\n  let result = t.split('').reverse().join('');\n  return [t, result === s];\n};"
      ],
      [
        "const oddCount = (lst) => {\n  let d = [];\n  for (let i = 0; i < lst.length; i = i + 1) {\n    let p = 0;\n    let h = lst[i].length;\n    for (let j = 0; j < h; j = j + 1) {\n      if (lst[i][j] % 2 !== 0) {\n        p = p + 1;\n      }\n    }\n    d.push(`the number of odd elements in the string ${i + 1} of the input.`);\n  }\n  return d;\n};"
      ],
      [
        "const minSubArraySum = (nums) => {\n  let min = nums[0];\n  for (let i = 0; i < nums.length; i = i + 1) {\n    let sum = 0;\n    for (let j = i; j < nums.length; j = j + 1) {\n      sum += nums[j];\n      if (sum < min) {\n        min = sum;\n      }\n    }\n  }\n  return min;\n};"
      ],
      [
        "const maxFill = (grid, capacity) => {\n  let p = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      if (1 == grid[i][j]) { m++ }\n      if (m > 0 && m <= capacity) {\n        p += grid[i][j];\n      } else {\n        p += Math.ceil(m / capacity) * grid[i][j];\n      }\n    }\n  }\n  return p;\n};"
      ],
      [
        "const sortArray = (arr) => {\n  let p = arr\n  for (let j = 0; j < p.length; j = j + 1) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k = k + 1) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u = u + 1) {\n        if (w1[u] == '1') { f1 = f1 + 1 }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let v = 0; v < w2.length; v = v + 1) {\n        if (w2[v] == '1') { f2 = f2 + 1 }\n      }\n      if (f1 != f2) {\n        if (f1 < f2) { ind = j }\n        else { k = k }\n      }\n      else if (p[ind] > p[k]) { ind = j }\n    }\n    let temp = p[j]\n    p[j] = p[ind]\n    p[ind] = temp\n  }\n  return p\n}"
      ],
      [
        "const selectWords = (s, n) => {\n  let t = s.split(/\\s/);\n  if (s === '') { return []; }\n  let k = [];\n  for (let i = 0; i < t.length; i = i + 1) {\n    let l = 0;\n    for (let j = 0; j < t[i].length; j = j + 1) {\n      if (t[i][j] !== ' ') {\n        l++;\n      }\n    }\n    if (l === n) {\n      k.push(t[i]);\n    }\n  }\n  return k;\n};"
      ],
      [
        "const getClosestVowel = (word) => {\n  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !('a' != word[i] && 'e' != word[i] && 'i' != word[i] && 'o' != word[i] && 'u' != word[i] && 'A' != word[i] && 'E' != word[i] && 'I' != word[i] && 'O' != word[i] && 'U' != word[i])\n      &&\n      ('a' != word[1 + i] && 'e' != word[1 + i] && 'i' != word[1 + i] && 'o' != word[1 + i] && 'u' != word[1 + i] && 'A' != word[1 + i] && 'E' != word[1 + i] && 'I' != word[1 + i] && 'O' != word[1 + i] && 'U' != word[1 + i])\n    ) {\n      return word[i];\n    }\n  }\n  return \"\";\n};"
      ],
      [
        "const matchParens = (lst) => {\n  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if ('(' == w1[i]) { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  return u ? 'Yes' : 'No';\n}"
      ],
      [
        "const maximum = (arr, k) => {\n  let p = arr\n  for (let j = 0; j < p.length; j = j + 1) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k = k + 1) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind !== j) {\n      let temp = p[j]\n      p[j] = p[ind]\n      p[ind] = temp\n    }\n  }\n  return p.slice(0, k)\n}"
      ],
      [
        "const solution = (lst) => {\n  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 !== 0) {\n      p += lst[i]\n    }\n  }\n  return p;\n}"
      ],
      [
        "const addElements = (arr, k) => {\n  let p = 0\n  for (let i = 0; i < k; i = i + 1) {\n    if (arr[i] < 100 && arr[i] > -100) { p = p + (arr[i]) }\n  }\n  return p;\n}"
      ],
      [
        "const getOddCollatz = (n) => {\n  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (p[i] == t) {\n        u = 1\n        break;\n      }\n    }\n    if (1 == u) { break }\n    if (t % 2 == 0) {\n      p.push(t / 2)\n    } else {\n      p.push(t * 3 + 1)\n    }\n    t = p[p.length - 1]\n  }\n  return p.filter(num => num % 2 != 0).sort((a, b) => a - b)\n}"
      ],
      [
        "const validDate = (date) => {\n  let t = date.split(/-/);\n  if (3 != t.length) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (2 == t[0] && t[1] > 29) { return false }\n  if (t[2] < 0 || t[2] > 31) { return false }\n  if (t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11 && t[1] > 30) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  return true;\n}"
      ],
      [
        "const isSorted = (lst) => {\n  if (lst.length == 0) { return 1 }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return 0 }\n    if (lst[i] == pre) {\n      dup++;\n      if (dup > 1) { return 0; }\n    }\n    pre = lst[i];\n    dup = 1;\n  }\n  return 1;\n}"
      ],
      [
        "const prodSigns = (arr) => {\n  if (0 == arr.length) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    n *= arr[i]\n    s += Math.abs(arr[i])\n  }\n  return n == 1 ? s : n == -1 ? -s : null;\n}"
      ],
      [
        "const minPath = (grid, k) => {\n  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i = i + 1) {\n    for (let j = 0; j < grid.length; j = j + 1) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n\n  let minPath = [];\n  for (let i = 0; i < k; i++) {\n    minPath.push(grid[m][n]);\n    const neighbors = [\n      [m - 1, n], [m + 1, n], [m, n - 1], [m, n + 1]\n    ].filter(neighbor => 0 <= neighbor[0] && neighbor[0] < grid.length && 0 <= neighbor[1] && neighbor[1] < grid.length);\n    const randomNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];\n    m = randomNeighbor[0];\n    n = randomNeighbor[1];\n  }\n\n  return minPath;\n};"
      ],
      [
        "const tri = (n) => {\n  if (0 == n) { return [1] }\n  if (1 == n) { return [1, 3] }\n  let p = [1, 3];\n  for (let i = 2; i <= n; i++) {\n    if (0 == i % 2) {\n      p.push(p[i - 1] + p[i - 2]);\n    } else {\n      p.push(1 + i / 2);\n    }\n  }\n  return p;\n}"
      ],
      [
        "const digits = (n) => {\n  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (1 == y % 2) {\n      p *= y\n    }\n    n = Math.floor(n / 10)\n  }\n  return p === 1 ? 0 : p\n}"
      ],
      [
        "const isNested = (string) => {\n  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  let closing_bracket_index2 = []\n  for (let i = 0; i < string.length; i = i + 1) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      if (opening_bracket_index.length > 0) {\n        opening_bracket_index.pop()\n        closing_bracket_index1.push(i)\n      }\n      else {\n        closing_bracket_index2.push(i)\n      }\n    }\n  }\n  return (opening_bracket_index.length > 0 && closing_bracket_index1.length === 0 && closing_bracket_index2.length === 0);\n}"
      ],
      [
        "const sumSquares = (lst) => {\n  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (0 != y % 1) {\n      if (y > 0) { y = 1 + y - y % 1 }\n      else { y = -1 - y + y % 1 }\n    }\n    p += y * y\n  }\n  return Math.floor(p)\n}"
      ],
      [
        "const checkIfLastCharIsALetter = (txt) => {\n  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  return (y >= 65 && y <= 90) || (y >= 97 && y <= 122);\n}"
      ],
      [
        "const canArrange = (arr) => {\n  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i = i - 1) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1;\n}"
      ],
      [
        "const largestSmallestIntegers = (lst) => {\n  let a = Infinity;\n  let b = -Infinity;\n  for (let i = 0; i < lst.length; i = i + 1) {\n    if (lst[i] > 0 && lst[i] < a) {\n      a = lst[i];\n    }\n    if (lst[i] < 0 && lst[i] > b) {\n      b = lst[i];\n    }\n  }\n  return (a === Infinity || b === -Infinity) ? null : [a, b];\n}"
      ],
      [
        "const compareOne = (a, b) => {\n  let aa = Number(a)\n  if ('string' == typeof a) { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if ('string' == typeof b) { bb = Number(b.replace(',', '.')) }\n\n  if (aa > bb) {\n    return aa;\n  } else if (aa < bb) {\n    return bb;\n  } else {\n    return null;\n  }\n}"
      ],
      [
        "const isEqualToSumEven = (n) => {\n  return (n >= 8 && 0 == n % 2)\n}"
      ],
      [
        "const fixSpaces = (text) => {\n  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c = c + 1 }\n    else if (c > 0) {\n      if (c == 1) { t = t + ('_') }\n      if (c == 2) { t = t + ('__') }\n      c = 0\n    }\n    if (text[i] != ' ') { t = t + text[i] }\n  }\n  return t\n}"
      ],
      [
        "const fileNameCheck = (file_name) => {\n  let t = file_name.split(/\\./)\n  if (2 != t.length) { return 'No' }\n  if ('txt' != t[1] && 'dll' != t[1] && 'exe' != t[1]) { return 'No' }\n  if ('' == t[0]) { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!(a >= 65 && a <= 90) && !(a >= 97 && a <= 122)) { return 'No' }\n  return 'Yes'\n}"
      ],
      [
        "const sumSquares = (lst) => {\n  let y = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (0 == i % 3) {\n      y += lst[i] * lst[i];\n    } else if (0 == i % 4) {\n      y += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return y;\n}"
      ],
      [
        "const wordsInSentence = (sentence) => {\n  let t = sentence.split(/\\s/);\n  let p = '';\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1;\n    if (1 == len || 0 == len) { continue }\n    if (isPrime(len)) {\n      p += t[j] + ' ';\n    }\n  }\n  return p.trim();\n};\n\nconst isPrime = (num) => {\n  for (let i = 2, sqrt = Math.sqrt(num); i <= sqrt; i++) {\n    if (num % i === 0) {\n      return false;\n    }\n  }\n  return num > 1;\n};"
      ],
      [
        "const simplify = (x, n) => {\n  let a = x.split(/\\//);\n  let b = n.split(/\\//);\n  let m = Number(b[0]) * Number(a[0]);\n  return m % Number(b[1]) === 0;\n}"
      ],
      [
        "const orderByPoints = (nums) => {\n  let p = nums.slice(); // Create a copy of the original array\n  p.sort((a, b) => {\n    if (sumOfDigits(a) === sumOfDigits(b)) {\n      return a - b; // Compare based on their index in the original list\n    } else {\n      return sumOfDigits(a) - sumOfDigits(b); // Compare based on the sum of their digits\n    }\n  });\n  return p;\n};\n\nconst sumOfDigits = (num) => {\n  let sum = 0;\n  while (num !== 0) {\n    sum += Math.floor(num % 10);\n    num = Math.floor(num / 10);\n  }\n  return sum;\n};\n\n// Example usage:"
      ],
      [
        "const specialFilter = (nums) => {\n  let p = 0\n  for (let i = 0; i < nums.length; i = i + 1) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    let firstDigit = parseInt(y[0])\n    let lastDigit = parseInt(y[y.length - 1])\n    if (firstDigit % 2 !== 0 && lastDigit % 2 !== 0) {\n      p++\n    }\n  }\n  return p\n}"
      ],
      [
        "const getMaxTriples = (n) => {\n  let y = []\n  for (let i = 1; i <= n; i = i + 1) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      let sum = y[i] + y[j]\n      if (sum % 3 === 0) {\n        u++\n      }\n    }\n  }\n  return u\n}"
      ],
      [
        "const bf = (planet1, planet2) => {\n  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (planet1 == y[i]) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (planet2 == y[i]) { hi = i }\n  }\n  if (lo === -1 || hi === -1) {\n    return []\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u.sort((a, b) => y.indexOf(a) - y.indexOf(b))\n}"
      ],
      [
        "const sortedListSum = (lst) => {\n  let p = []\n  for (let i = 0; i < lst.length; i = i + 1) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        if (f === 0) {\n          let temp = p[k]\n          p[k] = p[k + 1]\n          p[k + 1] = temp\n        }\n      }\n    }\n  }\n  return p\n}"
      ],
      [
        "const xOrY = (n, x, y) => {\n  let len = n;\n  if (1 == len || 0 == len) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (0 == len % i) {\n      return y;\n    }\n  }\n  return x;\n}"
      ],
      [
        "const doubleTheDifference = (lst) => {\n  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1 && lst[i] > 0 && Number.isInteger(lst[i])) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}"
      ],
      [
        "const compare = (game, guess) => {\n  for (let i = 0; i < guess.length; i++) {\n    game[i] = game[i] - (guess[i]);\n    if (game[i] < 0) {\n      game[i] = Math.abs(game[i]);\n    }\n  }\n  return game;\n}"
      ],
      [
        "const strongestExtension = (class_name, extensions) => {\n  let u = 0;\n  let s = -Infinity;\n  for (let i = extensions.length - 1; i >= 0; i = i - 1) {\n    let y = 0;\n    for (let j = 0; j < extensions[i].length; j = j + 1) {\n      let k = extensions[i][j].charCodeAt() - 'a'.charCodeAt();\n      if (k >= 0 && k <= 25) {\n        y += k;\n      }\n    }\n    if (y > s) {\n      s = y;\n      u = extensions[i];\n    }\n  }\n  return `${class_name}.${u}`;\n};"
      ],
      [
        "const cycpatternCheck = (a, b) => {\n  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i = i + 1) {\n    for (let j = 0; j < l + 1; j = j + 1) {\n      let y = 1\n      for (let k = 0; k < l; k = k + 1) {\n        y = y * 26\n        let index = (a[i + j] - 1) * y + (a[i + k + 1] - 1)\n        if (index >= pat.length) {\n          return false\n        }\n        if (pat[index] !== b[j]) {\n          return false\n        }\n      }\n    }\n  }\n  return true\n}"
      ],
      [
        "const rightAngleTriangle = (a, b, c) => {\n  return (c * c == a * a + b * b || b * b + c * c == a * a || a * a + c * c == b * b)\n}"
      ],
      [
        "const findMax = (words) => {\n  let s = -1\n  let u = -1\n  if (0 == words.length) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = p + 1; k < words[i].length; k++) {\n        if (words[i][j] === words[i][k]) {\n          y = 0\n          break\n        }\n      }\n      if (y) { p = k }\n    }\n    if (u === -1 || (words[i].length - p > u - s) || ((words[i].length - p) === (u - s) && words[i] < words[s])) {\n      s = i\n      u = words[i].length - p\n    }\n  }\n  return words[s]\n}"
      ],
      [
        "const doAlgebra = (operator, operand) => {\n  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i = i - 1) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1] = operand[i + 1] - 1;\n          operand[i] = operand[i] * (u);\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] = operand[i] * (operand[i + 1])\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        break;\n      }\n    }\n  }\n  return operand.reduce((a, b) => a + b, 0);\n}"
      ],
      [
        "const solve = (s) => {\n  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i = i + 1) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y = y + (32);\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      t = 1;\n    }\n    if (t === 1) {\n      p = s[i].toLowerCase() === s[i] ? s[i].toUpperCase() : s[i].toLowerCase();\n    }\n  }\n  return p;\n}"
      ],
      [
        "const stringToMd5 = (text) => {\n  if ('' == text) { return null }\n  var md5 = require('js-md5');\n  return md5(text);\n}"
      ]
    ],
    "variance": 0.0,
    "stddev": 0.0
  }
]