[
  {
    "name": {
      "name": "full_level_robustness",
      "split": "test"
    },
    "count": 29,
    "generations": [
      [
        "const allPrefixes = (string) => {\n  var result = [];\n  let i = 0;\n  while(i < string.length){\n    result.push(string.slice(0, i+1));      i++;\n  }\n  return result;\n}"
      ],
      [
        "const findClosestElements = (numbers) => {\n  var closest_pair, distance;\n  {\n      let i = 0;\n      while(i < numbers.length){{\n          let j = 0;\n          while(j < numbers.length){if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n        } else if (Math.abs(a - b) < distance) {\n          closest_pair = [a, b];\n          distance = Math.abs(a - b);\n        }\n        j++;\n          }\n      }\n      i++;\n  }\n  return closest_pair;\n}"
      ],
      [
        "const largestDivisor = (n) => {\n  let i = n - 1;\n  while(i >= 0){\n      if (n % i == 0) {\n          i--;\n      }\n  }\n  return i + 1;\n}"
      ],
      [
        "const factorize = (n) => {\n  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (!(n % i == 0)) {\n      i++;\n    } else {\n      fact.push(i);\n      n = n / i;\n    }\n  }\n  return fact;\n}"
      ],
      [
        "/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having an even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  var begin = -1.0, end = 1.0;\n  for(;(poly(xs, begin) * poly(xs, end) > 0);){\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {"
      ],
      [
        "const fizzBuzz = (n) => {\n  const digit7Count = (num) => {\n    let count = 0;\n    const str = num.toString();\n    for (let i = 0; i < str.length; i++) {\n      if (str[i] === '7') {\n        count++;\n      }\n    }\n    return count;\n  };\n\n  let ns = [], ans = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      ns.push(i);\n    }\n  }\n\n  ns.forEach((num) => {\n    ans += digit7Count(num);\n  });\n\n  return ans;\n};"
      ],
      [
        "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  {\n      let i = 0;\n      while(i < Math.floor((s.length + 2) / 3)){\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n        i++;\n      }\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  return encodeCyclic(encodeCyclic(s));\n}"
      ],
      [
        "const isPrime = (p) => {\n  if (p < 2) return false;\n  for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n    if (p % k == 0) return false;\n  }\n  return true;\n};\n\nconst primeFib = (n) => {\n  let fib = [0, 1];\n  let count = 0;\n  while (count < n) {\n    let nextFib = fib[fib.length - 1] + fib[fib.length - 2];\n    fib.push(nextFib);\n    if (isPrime(nextFib)) count++;\n  }\n  return fib[fib.length - 1];\n};"
      ],
      [
        "const triplesSumToZero = (l) => {\n  const seen = {};\n  for (const num of l) {\n    if (seen[num]) {\n      return true;\n    }\n    seen[0 - num] = true;\n  }\n  return false;\n};"
      ],
      [
        "const pairsSumToZero = (l) => {\n  let i = 0;\n  while(i < l.length){\n      let j = i + 1;\n      while(j < l.length){\n          if (l[i] + l[j] == 0) {\n              return true;\n          }\n          j++;\n      }\n      i++;\n  }\n  return false;\n}"
      ],
      [
        "const isPalindrome = (text) => {\n  let i = 0;\n  for (; i < text.length / 2; i++)\n    if (text[i] != text[text.length - 1 - i])\n      return false;\n  return true;\n}"
      ],
      [
        "const modp = (n, p) => {\n  var ret = 1;\n  let i = 0;\n  while(i < n){ret = (2 * ret) % p;      i++;}\n  return ret;\n}"
      ],
      [
        "const largestPrimeFactor = (n) => {\n  let isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  };\n\n  let largest = 2;\n  for (let i = 3; i <= n; i += 2) {\n    if (n % i == 0 && isPrime(i)) {\n      largest = i;\n      while (n % i == 0)\n        n /= i;\n    }\n  }\n\n  return largest;\n};"
      ],
      [
        "const smallestChange = (arr) => {\n  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++) {\n    if (arr[i] !== arr[arr.length - 1 - i]) {\n      ans++;\n    }\n  }\n  return ans;\n}"
      ],
      [
        "const isMultiplyPrime = (a) => {\n  const isPrime = (n) => {\n    let j = 2;\n    for (; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (a % i == 0) {\n      let factors = [];\n      while (a % i == 0) {\n        factors.push(i);\n        a = a / i;\n      }\n      if (factors.length == 3 && isPrime(factors[0]) && isPrime(factors[1]) && isPrime(factors[2])) {\n        return true;\n      }\n    }\n  }\n  return false;\n}"
      ],
      [
        "const numericalLetterGrade = (grades) => {\n  let letter_grade = [];\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i];\n    if (gpa == 4.0) {\n      letter_grade.push('A+');\n    } else{\n      if (gpa > 3.7) {\n        letter_grade.push('A');\n      } else{\n        if (gpa > 3.3) {\n          letter_grade.push('A-');\n        } else{\n          if (gpa > 3.0) {\n            letter_grade.push('B+');\n          } else{\n            if (gpa > 2.7) {\n              letter_grade.push('B');\n            } else{\n              if (gpa > 2.3) {\n                letter_grade.push('B-');\n              } else{\n                if (gpa > 2.0) {\n                  letter_grade.push('C+');\n                } else{\n                  if (gpa > 1.7) {\n                    letter_grade.push('C');\n                  } else{\n                    if (gpa > 1.3) {\n                      letter_grade.push('C-');\n                    } else{\n                      if (gpa > 1.0) {\n                        letter_grade.push('D+');\n                      } else{\n                        if (gpa > 0.7) {\n                          letter_grade.push('D');\n                        } else{\n                          if (gpa > 0.0) {\n                            letter_grade.push('D-');\n                          } else{\n                            letter_grade.push('E');\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return letter_grade;\n};"
      ],
      [
        "const antiShuffle = (s) => {\n  let arr = s.split(/\\s/);\n  for (let i = 0; i < arr.length; i++) {\n    let j = 0;\n    while (j < arr[i].length) {\n      let ind = j;\n      while (j + 1 < arr[i].length) {\n        if (arr[i][j + 1].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = j + 1;\n        }\n        j++;\n      }\n      let temp = arr[i][ind];\n      arr[i][ind] = arr[i][j];\n      arr[i][j] = temp;\n      j++;\n    }\n  }\n  return arr.join(' ');\n};"
      ],
      [
        "const encrypt = (s) => {\n  let t = ''\n  {\n      let i = 0;\n      while(i < s.length){\n          let p = s[i].charCodeAt() + 4\n          if (p > 122) { p -= 26       i++;\n          } else { p = p % 122; }\n          t += String.fromCharCode(p);\n      }\n  }\n  return t;\n}"
      ],
      [
        "const nextSmallest = (lst) => {\n  let arr = lst\n  {\n      let j = 0;\n      for (; j < arr.length; j++) {\n          let ind = j\n          {\n              let k = j + 1;\n              for (; k < arr.length; k++) {\n                  if (arr[k] < arr[ind]) {\n                    ind = k\n                  }\n                }\n          }\n      }\n  }\n\n  if (ind === lst.length - 1) return null;\n  else return arr[ind + 1];\n}"
      ],
      [
        "const encode = (message) => {\n  let t = ''\n  {\n      let i = 0;\n      while(i < message.length){\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32       i++;\n      }\n  }\n  return t;\n}"
      ],
      [
        "const skjkasdkd = (lst) => {\n  let t = 0;\n  let i = 0;\n  let p = 1;\n  for (; i < lst.length; i++) {\n    if (lst[i] > 1) {\n      let j = 2;\n      for (; j * j <= lst[i]; j++) {\n        if (lst[i] % j == 0) {\n          p = 0;\n          break;\n        }\n      }\n    }\n    if (p) t++;\n    p = 1;\n  }\n  let maxPrime = -1;\n  for (let num of lst) {\n    if (num > 1 && isPrime(num)) {\n      maxPrime = num;\n      break;\n    }\n  }\n  if (maxPrime === -1) return 0;\n  return sumOfDigits(maxPrime);\n};\n\nfunction isPrime(num) {\n  for (let i = 2, sqrt = Math.sqrt(num); i <= sqrt; i++)\n    if (num % i === 0) return false;\n  return num > 1;\n}\n\nfunction sumOfDigits(num) {\n  let sum = 0;\n  while (num > 0) {\n    sum += num % 10;\n    num = Math.floor(num / 10);\n  }\n  return sum;\n}"
      ],
      [
        "const countUpTo = (n) => {\n  let t = [];\n  for (let i = 2; i < n; i++) {\n    if (isPrime(i)) {\n      t.push(i);\n    }\n  }\n  return t;\n};\n\nconst isPrime = (num) => {\n  for (let i = 2, sqrt = Math.sqrt(num); i <= sqrt; i++) {\n    if (num % i === 0) return false;\n  }\n  return num > 1;\n};"
      ],
      [
        "const countUpper = (s) => {\n  let p = 0\n  {\n      let i = 0;\n      while(i < s.length){\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++       i += 2;\n      }\n  }\n  return p;\n}"
      ],
      [
        "const makeAPile = (n) => {\n  let t = []\n  {\n      let i = n;\n      for (; i < n * 3; i += 2) {\n          t.push(i)\n      }\n  }\n  return t;\n}"
      ],
      [
        "/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let i = y;\n  while(i >= x){\n    if (i % 2 == 0) {return i }\n    i--;\n  }\n}"
      ],
      [
        "const uniqueDigits = (x) => {\n  let p = [];\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i];\n    let boo = 1;\n    while (h > 0) {\n      let r = h % 10;\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = Math.floor(h / 10);\n    }\n    if (boo) p.push(x[i]);\n  }\n  return p.sort((a, b) => a - b);\n};"
      ],
      [
        "const byLength = (arr) => {\n  let p = []\n  {\n      let i = 0;\n      for (; i < arr.length; i++) {\n      if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    let temp = p[j]\n    p[j] = p[ind]\n    p[ind] = temp\n  }\n  for (let l = 0; l < p.length; l++) {\n    switch (p[l]) {\n      case 1: p[l] = 'One'; break;\n      case 2: p[l] = 'Two'; break;\n      case 3: p[l] = 'Three'; break;\n      case 4: p[l] = 'Four'; break;\n      case 5: p[l] = 'Five'; break;\n      case 6: p[l] = 'Six'; break;\n      case 7: p[l] = 'Seven'; break;\n      case 8: p[l] = 'Eight'; break;\n      case 9: p[l] = 'Nine'; break;\n    }\n  }\n  return p.reverse();\n}"
      ],
      [
        "const f = (n) => {\n  let f = 1\n  let p = 0\n  let k = []\n  {\n      let i = 1;\n      for (; i <= n; i++) {\n          if (i % 2 === 0) {\n              f *= i;\n          } else {\n              p += i;\n          }\n      }\n      k[i] = f;\n  }\n  return k;\n}"
      ],
      [
        "const countNums = (arr) => {\n  let p = 0;\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i];\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let sum = 0;\n    let sign = h < 0 ? -1 : 1;\n    h = Math.abs(h);\n    while (h > 0) {\n      sum += h % 10;\n      h = Math.floor(h / 10);\n    }\n    if (sum * sign > 0) {\n      p++;\n    }\n  }\n  return p;\n}"
      ],
      [
        "const exchange = (lst1, lst2) => {\n  let k = lst1.length\n  let t = 0\n  {\n      let i = 0;\n      while(i < lst1.length){\n    if (lst1[i] % 2 == 0) { t++ }\n        i++;\n      }\n  }\n  let j = 0;\n  while(j < lst2.length){\n    if (lst2[j] % 2 != 0) { k-- }\n        j++;\n  }\n  return k === 0 ? \"YES\" : \"NO\";\n}"
      ],
      [
        "const histogram = (test) => {\n  let d = {}, t = test.split(/\\s/);\n  if (test === '') { t = []; }\n  for (m in t) {\n    if (!(t[m] in d)) {\n      d[t[m]] = 1;\n    } else {\n      d[t[m]]++;\n    }\n  }\n  let maxCount = 0, maxLetters = [];\n  for (let letter in d) {\n    if (d[letter] > maxCount) {\n      maxCount = d[letter];\n      maxLetters = [letter];\n    } else if (d[letter] === maxCount) {\n      maxLetters.push(letter);\n    }\n  }\n  return maxLetters.reduce((acc, letter) => ({ ...acc, [letter]: maxCount }), {});\n}"
      ],
      [
        "const reverseDelete = (s, c) => {\n  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    {\n        let j = 0;\n        while(j < c.length){\n      if (s[i] == c[j]) {\n        y = 0\n      }\n            j++;\n        }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let result = t.split('').reverse().join('') === t\n  return [t, result]\n}"
      ],
      [
        "const oddCount = (lst) => {\n  let d = [];\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length;\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j] % 2 !== 0) {\n        p++;\n      }\n    }\n    d.push(`the number of odd elements in the string ${i + 1} of the input.`);\n  }\n  return d;\n}"
      ],
      [
        "const minSubArraySum = (nums) => {\n  let min = nums[0];\n  for (let i = 0; i < nums.length; i++) {\n    let sum = 0;\n    for (let j = i; j < nums.length; j++) {\n      sum += nums[j];\n      if (sum < min) {\n        min = sum;\n      }\n    }\n  }\n  return min;\n};"
      ],
      [
        "const maxFill = (grid, capacity) => {\n  let p = 0;\n  {\n      let i = 0;\n      while(i < grid.length){\n    let m = 0;\n    {\n        let j = 0;\n        while(j < grid[i].length){\n      if (grid[i][j] == 1) { m++;\n        grid[i][j] = 0; // Clear the well after emptying\n      }\n        j++;\n        if (m >= capacity) { // If the bucket is full, move to the next well\n          p += Math.ceil(m / capacity); // Calculate the number of trips needed\n          m = 0; // Reset the bucket count for the next well\n        }\n      }\n    }\n    i++;\n  }\n  return p;\n}"
      ],
      [
        "const sortArray = (arr) => {\n  let p = arr\n  {\n      let j = 0;\n      for (; j < p.length; j++) {\n          let ind = j\n          {\n              let k = j + 1;\n              for (; k < p.length; k++) {\n                  let w1 = p[ind].toString(2)\n                  let f1 = 0\n                  {\n                      let u = 0;\n                      for (; u < w1.length; u++) {\n                          if (w1[u] == '1') { f1++ }\n                        }\n                  }\n                  let w2 = p[k].toString(2)\n                  let f2 = 0\n                  {\n                      let v = 0;\n                      for (; v < w2.length; v++) {\n                          if (w2[v] == '1') { f2++ }\n                        }\n                  }\n                  if (f1 < f2 || (f1 === f2 && p[ind] < p[k])) {\n                      let temp = p[ind]\n                      p[ind] = p[k]\n                      p[k] = temp\n                  }\n              }\n          }\n      }\n  }\n  return p\n}"
      ],
      [
        "const selectWords = (s, n) => {\n  let t = s.split(/\\s/);\n  if (s === '') { return []; }\n  let k = [];\n  {\n      let i = 0;\n      while(i < t.length){\n          let l = 0;\n          {\n              let j = 0;\n              while(j < t[i].length){\n                  if(/[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]/.test(t[i][j])){\n                      l++;\n                  }\n                  j++;\n              }\n          }\n          if(l === n){\n              k.push(t[i]);\n          }\n          i++;\n      }\n  }\n  return k;\n}"
      ],
      [
        "const matchParens = (lst) => {\n  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (!(w1[i] == '(')) { y-- }\n    else { y++ }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  y = 0\n  for (let i = w1.length - 1; i >= 0; i--) {\n    if (!(w1[i] == ')')) { y-- }\n    else { y++ }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  return u ? 'Yes' : 'No';\n}"
      ],
      [
        "const maximum = (arr, k) => {\n  let p = arr\n  {\n      let j = 0;\n      for (; j < p.length; j++) {\n          let ind = j\n          {\n              let k = j + 1;\n              for (; k < p.length; k++) {\n                  if (p[k] < p[ind]) {\n                      ind = k\n                  }\n              }\n          }\n          let temp = p[j]\n          p[j] = p[ind]\n          p[ind] = temp\n      }\n      let temp = p[k - 1]\n      p[k - 1] = p[0]\n      p[0] = temp\n      return p.slice(0, k)\n  }\n}"
      ],
      [
        "const addElements = (arr, k) => {\n  let p = 0;\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) {\n      p += arr[i];\n    }\n  }\n  return p;\n};"
      ],
      [
        "const getOddCollatz = (n) => {\n  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    {\n        let i = 0;\n        for (; i < p.length; i++) {\n          if (t == p[i]) {\n            u = 1\n            break;\n          }\n        }\n    }\n    if (u == 1) { break }\n\n    if (t % 2 == 0) {\n      t = t / 2\n    } else {\n      t = 3 * t + 1\n    }\n\n    if (t == 1) {\n      p.push(t)\n    } else {\n      p.push(t)\n    }\n  }\n\n  return p.filter(num => num % 2 !== 0).sort((a, b) => a - b);\n}"
      ],
      [
        "const minPath = (grid, k) => {\n  let m = 0\n  let n = 0\n  while (m < grid.length) {\n    while (n < grid.length) {\n      if (grid[m][n] == 1) {\n        m = grid.length\n        n = grid.length\n        break\n      }\n      n++\n    }\n    m++\n  }\n  let path = []\n  for (let i = 0; i < k; i++) {\n    path.push(grid[m - 1][n - 1])\n    grid[m - 1][n - 1] = 0\n    m--\n    n--\n  }\n  return path\n}"
      ],
      [
        "const isNested = (string) => {\n  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (!(string[i] == '[')) {\n      closing_bracket_index1.push(i)\n    }\n    else {\n      opening_bracket_index.push(i)\n    }\n  }\n\n  let closing_bracket_index2 = []\n  for (let i = closing_bracket_index1.length - 1; i >= 0; i--) {\n    if (closing_bracket_index1[i] < opening_bracket_index[0]) {\n      closing_bracket_index2.push(i)\n    }\n  }\n\n  return closing_bracket_index2.length > 0;\n}"
      ],
      [
        "const canArrange = (arr) => {\n  if (arr.length == 0) { return -1 }\n  {\n      let i = arr.length - 1;\n      while(i > 0){\n          if (arr[i] < arr[i - 1]) { return i       i--;\n          }\n      }\n  }\n  return -1;\n}"
      ],
      [
        "const largestSmallestIntegers = (lst) => {\n  let a = Infinity;\n  let b = -Infinity;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) {\n      a = lst[i];\n    }\n    if (lst[i] < 0 && lst[i] > b) {\n      b = lst[i];\n    }\n  }\n  return (a === Infinity || b === -Infinity) ? null : [a, b];\n}"
      ],
      [
        "const fixSpaces = (text) => {\n  let t = '';\n  let c = 0;\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] !== ' ') {\n      if (c > 0) {\n        if (c === 1) {\n          t += '_';\n        } else if (c === 2) {\n          t += '__';\n        }\n        c = 0;\n      }\n      t += text[i];\n    } else {\n      c++;\n      if (c === 3) {\n        t += '-';\n        c = 0;\n      }\n    }\n  }\n  return t;\n};"
      ],
      [
        "const sumSquares = (lst) => {\n  let y = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) {\n      y += lst[i] * lst[i];\n    } else if (i % 4 == 0) {\n      y += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return y;\n}"
      ],
      [
        "const wordsInSentence = (sentence) => {\n  let t = sentence.split(/\\s/);\n  let p = '';\n  {\n      let j = 0;\n      for (; j < t.length; j++) {\n          let len = t[j].length;\n          let isPrime = (num) => {\n              for(let i = 2, sqrt = Math.sqrt(num); i <= sqrt; i++)\n                  if(num % i === 0) return false; \n              return num > 1;\n          };\n          if(isPrime(len)) p += t[j] + ' ';\n      }\n      p = p.trim();\n  }\n  return p;\n};"
      ],
      [
        "const orderByPoints = (nums) => {\n  let p = nums;\n  p.sort((a, b) => {\n    let sumA = sumOfDigits(a);\n    let sumB = sumOfDigits(b);\n    if (sumA !== sumB) {\n      return sumA - sumB;\n    } else {\n      return p.indexOf(a) - p.indexOf(b);\n    }\n  });\n  return p;\n};\n\nconst sumOfDigits = (num) => {\n  let sum = 0;\n  while (num !== 0) {\n    sum += Math.floor(num % 10);\n    num = Math.floor(num / 10);\n  }\n  return sum;\n};"
      ],
      [
        "const specialFilter = (nums) => {\n  let p = 0\n  {\n      let i = 0;\n      while(i < nums.length){\n    if (nums[i] < 10) { i++; continue }\n    let y = nums[i].toString()\n    let firstDigit = parseInt(y[0])\n    let lastDigit = parseInt(y[y.length - 1])\n    if (firstDigit % 2 !== 0 && lastDigit % 2 !== 0) { p++ }\n    i++\n      }\n  }\n  return p\n}"
      ],
      [
        "const getMaxTriples = (n) => {\n  let y = [];\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1);\n  }\n  let u = 0;\n  let count = 0;\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 === 0) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n}"
      ],
      [
        "const bf = (planet1, planet2) => {\n  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  {\n      let i = 0;\n      for (; i < 8; i++) {\n      if (y[i] == planet1) { lo = i }\n    }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n    if (lo !== -1 && hi !== -1 && lo < hi) {\n      u.push(y[i])\n    }\n  }\n  return u.sort((a, b) => {\n    if (a === 'Mercury') return -1;\n    if (b === 'Mercury') return 1;\n    if (a === 'Venus') return -1;\n    if (b === 'Venus') return 1;\n    if (a === 'Earth') return -1;\n    if (b === 'Earth') return 1;\n    if (a === 'Mars') return -1;\n    if (b === 'Mars') return 1;\n    if (a === 'Jupiter') return -1;\n    if (b === 'Jupiter') return 1;\n    if (a === 'Saturn') return -1;\n    if (b === 'Saturn') return 1;\n    if (a === 'Uranus') return -1;\n    if (b === 'Uranus') return 1;\n    if (a === 'Neptune') return -1;\n    if (b === 'Neptune') return 1;\n    return 0;\n  });\n}"
      ],
      [
        "const sortedListSum = (lst) => {\n  let p = []\n  {\n      let i = 0;\n      for (; i < lst.length; i++) {\n      if (lst[i].length % 2 == 0) {\n        p.push(lst[i])\n      }\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        if (p[k].localeCompare(p[k + 1]) > 0) { f = 1 }\n      }\n      if (f) {\n        let temp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = temp\n      }\n    }\n  }\n  return p\n}"
      ],
      [
        "const strongestExtension = (class_name, extensions) => {\n  let u = 0\n  let s = -Infinity\n  {\n      let i = extensions.length - 1;\n      while(i >= 0){\n    let y = 0\n    {\n        let j = 0;\n        while(j < extensions[i].length){\n      let k = extensions[i][j].charCodeAt() - ('a'.charCodeAt()); // Subtract 'a' charCode to get the count of lowercase letters\n      if(k >= 0) y++;\n      j++;\n        }\n    }\n    let strength = u - y; // Calculate the strength as per the given formula\n    if(strength > s) {\n      s = strength;\n      // Find the index of the strongest extension\n      let strongestIndex = i;\n    }\n    i--;\n      }\n  }\n  // Return the class name concatenated with the strongest extension\n  return `${class_name}.${extensions[strongestIndex]}`;\n}"
      ],
      [
        "const cycpatternCheck = (a, b) => {\n  let l = b.length;\n  let pat = b + b;\n  \n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0, y = 1; j < l + 1; j++, y++) {\n      let k = 0;\n      while (k < l) {\n        if (a[i + k] !== pat[y + k]) {\n          break;\n        }\n        k++;\n      }\n      if (k === l) {\n        return true;\n      }\n    }\n  }\n  return false;\n};"
      ],
      [
        "const findMax = (words) => {\n  let maxUnique = -1;\n  let maxWord = '';\n\n  if (words.length === 0) {\n    return '';\n  }\n\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const uniqueChars = new Set(word).size;\n\n    if (uniqueChars > maxUnique) {\n      maxUnique = uniqueChars;\n      maxWord = word;\n    } else if (uniqueChars === maxUnique) {\n      maxWord = maxWord < word ? maxWord : word;\n    }\n  }\n\n  return maxWord;\n};"
      ],
      [
        "const doAlgebra = (operator, operand) => {\n  while (operator.length > 0) {\n    let y = 0;\n    {\n        let i = operator.length - 1;\n        for (; i >= 0; i--) {\n          if (operator[i] == '**') {\n            let u = operand[i];\n            while (operand[i + 1] > 1) {\n              operand[i + 1]--;\n              operand[i] *= u;\n            }\n            operand.splice(i + 1, 1);\n            operator.splice(i, 1);\n            y = 1;\n            break;\n          }\n        }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1];\n        operand.splice(i + 1, 1);\n        operator.splice(i, 1);\n        break;\n      }\n    }\n  }\n  return operand.reduce((a, b) => a + b, 0);\n}"
      ],
      [
        "const solve = (s) => {\n  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (!(y >= 65 && y <= 90)) if (y >= 97 && y <= 122) {\n    else {\n      y += 32;\n      t = 1;\n    }\n  if (t) {\n    if (y >= 65 && y <= 90) {\n      p += String.fromCharCode(y + 32);\n    } else {\n      p += String.fromCharCode(y - 32);\n    }\n  } else {\n    p += s[i];\n  }\n}\nreturn p;\n}"
      ]
    ],
    "variance": 0.0,
    "stddev": 0.0
  }
]