[
  {
    "name": {
      "name": "full_level_robustness",
      "split": "test"
    },
    "count": 82,
    "generations": [
      [
        "const hasCloseElements = (list, tolerance) => {\n  for (let k = 0; k < list.length; k++) {\n    for (let i = 0; i < list.length; i++) {\n      if (k != i) {\n        let difference = Math.abs(list[k] - list[i]);\n        if (difference < tolerance) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};"
      ],
      [
        "const separateParenGroups = (ma) => {\n  var map = [];\n  var list = [];\n  var i = 0;\n\n  for (const c of ma) {\n    if (c == '(') {\n      i += 1;\n      list.push(c);\n    } else if (c == ')') {\n      i -= 1;\n      if (i == 0) {\n        map.push(list.join(''));\n        list = [];\n      }\n    }\n  }\n\n  return map;\n};"
      ],
      [
        "/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst func_1 = (number) => {\n  return number % 1.0;\n}"
      ],
      [
        "const belowZero = (lkvizgrons) => {\n  var balance = 0;\n  for (const op of lkvizgrons) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};"
      ],
      [
        "const meanAbsoluteDeviation = (data) => {\n  var average = data.reduce((current, next) => {\n    return current + next;\n  }, 0) / data.length;\n  return data.reduce((current, next) => {\n    return current + Math.abs(next - average);\n  }, 0) / data.length;\n}"
      ],
      [
        "const intersperse = (numbers, delimiter) => {\n  if (!Array.isArray(numbers) || numbers.length === 0)\n    return [];\n  var result = [];\n  for (const num of numbers) {\n    result.push(num);\n    result.push(delimiter);\n  }\n  result.pop(); // Remove the trailing delimiter\n  return result;\n};"
      ],
      [
        "const parseNestedParens = (n) => {\n  var parseParenGroup = function (p) {\n    let i = 0, j = 0;\n    for (const c of p) {\n      if (c == '(') {\n        i += 1;\n        j = Math.max(j, i);\n      } else if (c == ')') {\n        i -= 1;\n      }\n    }\n    return j;\n  };\n\n  let result = [];\n  let groups = n.split(' ');\n  for (let group of groups) {\n    result.push(parseParenGroup(group));\n  }\n  return result;\n};"
      ],
      [
        "const filterBySubstring = (strings, substring) => {\n  return strings.filter(x => x.indexOf(substring) != -1);\n}"
      ],
      [
        "const sumProduct = (arr) => {\n  let sum = 0, product = 1;\n  for (const num of arr) {\n    sum += num;\n    product *= num;\n  }\n  return (sum ? [sum, product] : [0, 1]);\n};"
      ],
      [
        "const rollingMax = (arr) => {\n  const maxes = [];\n  let max = -Infinity;\n\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n    maxes.push(max);\n  }\n\n  return maxes;\n};"
      ],
      [
        "Complete code (including all the content of the code I provided and the code you generated)"
      ],
      [
        "const stringXor = (a, b) => {\n  let xor = (i, j) => {\n    if (i == j)\n      return '0';\n    else\n      return (i ? '1' : '0') ^ (j ? '1' : '0');\n  };\n  \n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += xor(a[i], b[i]);\n  }\n  \n  return result;\n};"
      ],
      [
        "const longest = (var_2) => {\n  if (!Array.isArray(var_2) || var_2.length == 0)\n    return null;\n  var var_0 = Math.max(...var_2.map(var_3 => var_3.length));\n  for (const var_1 of var_2) {\n    if (var_1.length === var_0)\n      return var_1;\n  }\n  return var_1;\n}"
      ],
      [
        "const greatestCommonDivisor = (A, B) => {\n  while (B != 0) {\n    let b = A;\n    A = B;\n    B = b % B;\n  }\n  return A;\n};"
      ],
      [
        "const allPrefixes = (input) => {\n  var list = [];\n  for (let index = 0; index < input.length; index++) {\n    list.push(input.slice(0, index+1));\n  }\n  return list;\n}"
      ],
      [
        "const stringSequence = (n) => {\n  return [...Array(n).keys()].join(' ')\n}"
      ],
      [
        "const countDistinctCharacters = (str) => {\n  return (new Set(str.toLowerCase())).size;\n};"
      ],
      [
        "const parseMusic = (music_string) => {\n  const motv_nzp = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => motv_nzp[x]);\n}"
      ],
      [
        "const howManyTimes = (strings, regex) => {\n  var count = 0;\n  for (let index = 0; index < strings.length - regex.length + 1; index++) {\n    if (strings.slice(index, index+regex.length) == regex) {\n      count += 1;\n    }\n  }\n  return count;\n}"
      ],
      [
        "const sortNumbers = (mfmbeih) => {\n  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n\n  return mfmbeih\n    .split(' ')\n    .map(word => value_map[word])\n    .sort((a, b) => a - b)\n    .map(num => value_map[num])\n    .join(' ');\n}"
      ],
      [
        "const findClosestElements = (l) => {\n  var closest, nearest;\n  for (let k = 0; k < l.length; k++)\n    for (let m = 0; m < l.length; m++)\n      if (k != m) {\n        let a = l[k], b = l[m];\n        if (nearest == null || Math.abs(a - b) < nearest) {\n          nearest = Math.abs(a - b);\n          closest = [a, b];\n        }\n      }\n  return closest;\n};"
      ],
      [
        "const rescaleToUnit = (numyers) => {\n  var min_number = Math.min(...numyers);\n  var max_number = Math.max(...numyers);\n  \n  // Calculate the range of the numbers\n  var range = max_number - min_number;\n  \n  // Apply the linear transformation\n  return numyers.map(num => (num - min_number) / range);\n}"
      ],
      [
        "const filterIntegers = (var_0) => {\n  return var_0.filter(var_1 => Number.isInteger(var_1));\n}"
      ],
      [
        "const strlen = (htrimt) => {\n  return htrimt.length;\n}"
      ],
      [
        "const largestDivisor = (n) => {\n  for (let r = n - 1; r >= 0; r--)\n    if (n % r == 0)\n      return r;\n};"
      ],
      [
        "const factorize = (n) => {\n  var uzxt = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      uzxt.push(i);\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return uzxt;\n}"
      ],
      [
        "const removeDuplicates = (list) => {\n  var result = new Object();\n  for (const num of list) {\n    if (num in result) {\n      result[num] += 1;\n    } else {\n      result[num] = 1;\n    }\n  }\n  return Object.keys(result);\n};"
      ],
      [
        "const flipCase = (str) => {\n  return str.split('').map(char => (char === char.toUpperCase() ? char.toLowerCase() : char.toUpperCase())).join('');\n}"
      ],
      [
        "const concatenate = (var_0) => {\n  return var_0.join('');\n}"
      ],
      [
        "const func_0 = (strings, prefix) => {\n  return strings.filter(x => x.startsWith(prefix));\n}"
      ],
      [
        "const func_0 = (l) => {\n  return l.filter(e => e > 0);\n}"
      ],
      [
        "const isPrime = (expr) => {\n  if (expr < 2)\n    return false;\n  for (let i = 2; i < expr - 1; i++) {\n    if (expr % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}"
      ],
      [
        "/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, rgen, index) => {\n    return prev + rgen * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having an even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) // f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {"
      ],
      [
        "const sortThird = (l) => {\n  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((z, b) => (z - b));\n  return l.map((item, index) => index % 3 == 0 ? three.shift() : item);\n}"
      ],
      [
        "const func_1 = (l) => {\n  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}"
      ],
      [
        "const maxElement = (l) => {\n  return Math.max(...l);\n}"
      ],
      [
        "const fizzBuzz = (n) => {\n  const digit7Count = (num) => {\n    return (num + '').split('').reduce((count, digit) => {\n      return count + (digit === '7' ? 1 : 0);\n    }, 0);\n  };\n\n  return [...Array(n).keys()].reduce((count, num) => {\n    const divisibleBy11Or13 = num % 11 === 0 || num % 13 === 0;\n    const digit7CountInNum = digit7Count(num);\n    return divisibleBy11Or13 ? count + digit7CountInNum : count;\n  }, 0);\n};"
      ],
      [
        "const sortEven = (l) => {\n  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, y) => (a - y));\n  return l;\n}"
      ],
      [
        "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst func_1 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst func_0 = (s) => {\n  return func_1(func_1(s));\n}"
      ],
      [
        "const isPrime = (n) => {\n  if (n < 2) return false;\n  for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nconst primeFib = (n) => {\n  let fib = [0, 1];\n  while (fib.length <= n) {\n    fib.push(fib[fib.length - 1] + fib[fib.length - 2]);\n  }\n  return fib[n];\n};\n\nconst primeFibNth = (n) => {\n  let count = 0;\n  let num = 1;\n  while (count < n) {\n    if (isPrime(num)) count++;\n    num = primeFib(count + 1);\n  }\n  return num;\n};\n\n// Example usage:"
      ],
      [
        "const triplesSumToZero = (x) => {\n  for (let n = 0; n < x.length; n++) {\n    for (let i = n + 1; i < x.length; i++) {\n      for (let k = i + 1; k < x.length; k++) {\n        if (x[n] + x[i] + x[k] === 0) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};"
      ],
      [
        "const carRzxeCollisrln = (n) => {\n  return Math.pow(n, 2);\n}"
      ],
      [
        "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst inc = (l) => {\n  return l.map(e => e + 1);\n}"
      ],
      [
        "const pairsSumToZero = (l) => {\n  for (let r = 0; r < l.length; r++)\n    for (let j = r + 1; j < l.length; j++)\n      if (l[r] + l[j] == 0)\n        return true;\n  return false;\n}"
      ],
      [
        "const changeBase = (c, base) => {\n  var ret = \"\";\n  while (c > 0) {\n    ret = (c % base).toString() + ret;\n    c = Math.floor(c / base);\n  }\n  return ret;\n}"
      ],
      [
        "const triangleArea = (side, height) => {\n  return side * height / 2.0;\n}"
      ],
      [
        "const fib4 = (n) => {\n  const fib4Cache = {};\n\n  const fib4Helper = (n) => {\n    if (n === 0) return 0;\n    if (n === 1) return 0;\n    if (n === 2) return 2;\n    if (n === 3) return 0;\n    if (fib4Cache[n]) return fib4Cache[n];\n\n    fib4Cache[n] = fib4Helper(n - 1) + fib4Helper(n - 2) + fib4Helper(n - 3) + fib4Helper(n - 4);\n    return fib4Cache[n];\n  };\n\n  return fib4Helper(n);\n};"
      ],
      [
        "const median = (list) => {\n  list.sort((A, B) => A - B);\n  var length = list.length;\n  if (length % 2 == 1)\n    return list[Math.floor(length / 2)];\n  else\n    return (list[(length - 1) / 2] + list[length / 2]) / 2.0;\n}"
      ],
      [
        "const isPalindrome = (string) => {\n  for (let index = 0; index < string.length; index++)\n    if (string[index] != string.at(-index-1))\n      return false;\n  return true;\n}"
      ],
      [
        "const modp = (n, p) => {\n  let var_3 = 1;\n  for (let var_0 = 0; var_0 < n; var_0++)\n    var_3 = (2 * var_3) % p;\n  return var_3;\n}"
      ],
      [
        "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (string) => {\n  return string.split(\"\").map(a => String.fromCharCode(\n    ((a.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (string) => {\n  return string.split(\"\").map(a => String.fromCharCode(\n    ((a.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}"
      ],
      [
        "const removeVowels = (str) => {\n  return str.split(\"\")\n             .filter(string => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(string.toLowerCase()))\n             .join(\"\");\n}"
      ],
      [
        "const belowThreshold = (l, t) => {\n  for (const v of l)\n    if (v >= t)\n      return false;\n  return true;\n}"
      ],
      [
        "const add = (x, y) => {\n  return x + y;\n}"
      ],
      [
        "const sameChars = (str1, str2) => {\n  return [...new Set(str1)].sort().toString() === [...new Set(str2)].sort().toString();\n}"
      ],
      [
        "const fib = (n) => {\n  if (n <= 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  let a = 0, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const temp = a;\n    a = b;\n    b += temp;\n  }\n  return b;\n};"
      ],
      [
        "const correctBracketing = (brackets) => {\n  let stack = [];\n  for (const bracket of brackets) {\n    if (bracket === \"<\") {\n      stack.push(bracket);\n    } else if (stack.length === 0 || stack[stack.length - 1] !== \"<\") {\n      return false;\n    } else {\n      stack.pop();\n    }\n  }\n  return stack.length === 0;\n};"
      ],
      [
        "const monotonic = (l) => {\n  var sort1 = [...l].sort((a, y) => a - y);\n  var sort2 = [...l].sort((a, y) => y - a);\n  return JSON.stringify(l) === JSON.stringify(sort1) || JSON.stringify(l) === JSON.stringify(sort2);\n}"
      ],
      [
        "const common = (l, r) => {\n  var s = new Set();\n  for (const e of l)\n    for (const f of r)\n      if (e === f)\n        s.add(e);\n  return Array.from(s);\n}"
      ],
      [
        "const largestPrimeFactor = (n) => {\n  const sqrt = Math.floor(Math.sqrt(n));\n  for (let i = 2; i <= sqrt; i++) {\n    if (n % i === 0) {\n      n = n / i;\n      i--;\n    }\n  }\n  return n === 1 ? i : n;\n};"
      ],
      [
        "const sumToN = (n) => {\n  return sum(n);\n}\n\nconst sum = (n) => {\n  return n * (n + 1) / 2;\n}"
      ],
      [
        "const correctBracketing = (brackets) => {\n  var wepgs = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      wepgs += 1;\n    else if (b == \")\")\n      wepgs -= 1;\n    else\n      return false; // Invalid character other than '(' and ')'\n  }\n  return wepgs == 0;\n}"
      ],
      [
        "const dvireztiee = (xs) => {\n  return xs.map((x, i) => x * i).slice(1);\n}"
      ],
      [
        "const fibfib = (m) => {\n  if (m == 0 || m == 1)\n    return 0;\n  if (m == 2)\n    return 1;\n  let a = 0;\n  let b = 0;\n  let c = 1;\n  for (let i = 3; i <= m; i++) {\n    let temp = a + b + c;\n    a = b;\n    b = c;\n    c = temp;\n  }\n  return c;\n}"
      ],
      [
        "const vowelsCount = (str) => {\n  const vowels = 'aeiouAEIOU';\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (vowels.includes(str[i])) {\n      count++;\n    }\n  }\n  return count;\n};"
      ],
      [
        "const circularShift = (n, s) => {\n  s = n.toString();\n  if (s.length < s)\n    return s.split('').reverse().join('');\n  let shift = s.length - (s.length % (s.length - s));\n  return s.slice(shift) + s.slice(0, shift);\n};"
      ],
      [
        "const digitSum = (str) => {\n  if (str === '') return 0;\n  return [...str].reduce((sum, char) => sum + char.charCodeAt(0), 0);\n};"
      ],
      [
        "const fruitDistribution = (str, totalFruits) => {\n  var var_1 = [];\n  for (const var_0 of str.split(\" \"))\n    if (!isNaN(var_0))\n      var_1.push(parseInt(var_0));\n\n  var apples = var_1[0];\n  var oranges = var_1[1];\n\n  return totalFruits - apples - oranges;\n};"
      ],
      [
        "const pluck = (var_0) => {\n  if (var_0.length == 0) return [];\n  var var_1 = var_0.filter(var_2 => var_2 % 2 == 0);\n  if (var_1.length == 0) return [];\n  var var_3 = var_1.reduce((a, b) => a[0] < b[0] ? a : b);\n  return [var_3[0], var_3[1]];\n}"
      ],
      [
        "const search = (x) => {\n  var result = new Array(Math.max(...x) + 1).fill(0);\n  for (const i of x)\n    result[i] += 1;\n  var ans = -1;\n  for (let i = 0; i <= Math.max(...x); i++) {\n    if (result[i] >= i && i > 0) {\n      ans = i;\n      break;\n    }\n  }\n  return ans;\n};"
      ],
      [
        "const strangeSortList = (list) => {\n  var result = [], min = true;\n  while (list.length) {\n    result.push(min ? Math.min(...list) : Math.max(...list));\n    list.splice(list.indexOf(result.at(-1)), 1);\n  }\n  return result;\n}"
      ],
      [
        "const triangleArea = (a, y, c) => {\n  if (a + y <= c || a + c <= y || y + c <= a)\n    return -1;\n  var s = (a + y + c) / 2;\n  var area = Math.sqrt(s * (s - a) * (s - y) * (s - c));\n  return Math.round(area * 100) / 100;\n};"
      ],
      [
        "const willItFly = (q, w) => {\n  if (q.reduce(((piee, item) => piee + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n};"
      ],
      [
        "const smallestChange = (arr) => {\n  var anh = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      anh++;\n  return anh;\n}"
      ],
      [
        "const totalMatch = (list1, list2) => {\n  const totalLength1 = list1.reduce((total, str) => total + str.length, 0);\n  const totalLength2 = list2.reduce((total, str) => total + str.length, 0);\n  \n  if (totalLength1 < totalLength2) return list1;\n  else if (totalLength1 > totalLength2) return list2;\n  else return list1;\n};"
      ],
      [
        "const isMultiplyPrime = (z) => {\n  const isPrime = (n) => {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    let count = 0;\n    for (let j = i; j < 101; j += i) {\n      if (j === i) count++;\n      if (count === 3) return true;\n    }\n  }\n  return false;\n}"
      ],
      [
        "const isSimplePower = (j, y) => {\n  if (y === 1)\n    return (j === 1);\n  var i = 1;\n  while (Math.pow(y, i) <= j) {\n    if (Math.pow(y, i) === j)\n      return true;\n    i++;\n  }\n  return false;\n};"
      ],
      [
        "const iscube = (z) => {\n  z = Math.abs(z);\n  return (Math.pow(Math.round(Math.pow(z, 1.0 / 3.0)), 3) == z);\n}"
      ],
      [
        "const hexKey = (num) => {\n  const hexDigits = \"2357BD\";\n  let count = 0;\n  for (let i = 0; i < num.length; i++) {\n    if (hexDigits.includes(num[i])) {\n      count++;\n    }\n  }\n  return count;\n};"
      ],
      [
        "const decimalToBinary = (decimal) => {\n  return \"db\" + decimal.toString(2) + \"db\";\n}"
      ],
      [
        "const isHappy = (s) => {\n  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++) {\n    const triplet = s.slice(i, i + 3);\n    if (new Set(triplet).size !== 3)\n      return false;\n  }\n  return true;\n};"
      ],
      [
        "const numericalLetterGrade = (grades) => {\n  let letter_grade = [];\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let tpz = grades[i];\n    if (tpz == 4.0) {\n      letter_grade.push('A+');\n    } else if (tpz > 3.7) {\n      letter_grade.push('A');\n    } else if (tpz > 3.3) {\n      letter_grade.push('A-');\n    } else if (tpz > 3.0) {\n      letter_grade.push('B+');\n    } else if (tpz > 2.7) {\n      letter_grade.push('B');\n    } else if (tpz > 2.3) {\n      letter_grade.push('B-');\n    } else if (tpz > 2.0) {\n      letter_grade.push('C+');\n    } else if (tpz > 1.7) {\n      letter_grade.push('C');\n    } else if (tpz > 1.3) {\n      letter_grade.push('C-');\n    } else if (tpz > 1.0) {\n      letter_grade.push('D+');\n    } else if (tpz > 0.7) {\n      letter_grade.push('D');\n    } else if (tpz > 0.0) {\n      letter_grade.push('D-');\n    } else {\n      letter_grade.push('E');\n    }\n  }\n  return letter_grade;\n};"
      ],
      [
        "const isPrime = (num) => {\n  for(let i = 2, sqrt = Math.sqrt(num); i <= sqrt; i++) {\n    if(num % i === 0) return false;\n  }\n  return num > 1;\n}\n\nconst primeLength = (str) => {\n  let length = str.length;\n  if (length == 1 || length == 0) { return false }\n  if(isPrime(length)) return true;\n  return false;\n}"
      ],
      [
        "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startsOneEnds = (i) => {\n  if (i == 1) { return 1 }\n  let j = 18\n  for (let s = 2; s < i; s++) {\n    // Calculate the number of digits in the current number\n    let digits = Math.pow(10, s - 1);\n    // Calculate the number of numbers that start or end with 1\n    let startEndOne = Math.floor((j + 1) / digits) + Math.floor((j + digits - 1) / digits);\n    // Add the count to the total\n    j += Math.pow(10, s) - Math.pow(10, s - 1);\n    // Update the total count\n    j -= startEndOne * Math.pow(10, s - 1);\n  }\n  return j;\n}"
      ],
      [
        "const solve = (n) => {\n  let i = 0\n  while (n > 0) {\n    i += n % 10\n    n = Math.floor(n / 10)\n  }\n  return i.toString(2);\n}"
      ],
      [
        "const add = (i) => {\n  let count = 0\n  for (let j = 1; j < i.length; j += 2) {\n    if (i[j] % 2 == 0) {\n      count += i[j]\n    }\n  }\n  return count;\n}"
      ],
      [
        "const antiShuffle = (s) => {\n  let arr = s.split(/\\s/);\n  for (let i = 0; i < arr.length; i++) {\n    for (let q = 0; q < arr[i].length; q++) {\n      let ind = q;\n      for (let k = q + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k;\n        }\n      }\n      let temp = arr[i][q];\n      arr[i][q] = arr[i][ind];\n      arr[i][ind] = temp;\n    }\n  }\n  return arr.join(' ');\n}"
      ],
      [
        "const getRow = (lst, x) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] === x) {\n        result.push([i, lst[i].length - 1 - j]);\n      }\n    }\n  }\n  return result.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\n};"
      ],
      [
        "const sortArray = (arr) => {\n  let arrCopy = [...arr];\n  let tot = arrCopy[0] + arrCopy[arrCopy.length - 1];\n  return arrCopy.map(num => {\n    if ((tot % 2 == 1 && num < arrCopy[(arrCopy.length - 1) / 2]) || (tot % 2 == 0 && num > arrCopy[(arrCopy.length - 1) / 2])) {\n      return num;\n    } else {\n      return num * -1;\n    }\n  });\n};"
      ],
      [
        "const encrypt = (str) => {\n  let result = '';\n  for (let i = 0; i < str.length; i++) {\n    let charCode = str.charCodeAt(i);\n    if (charCode >= 65 && charCode <= 90) { // Uppercase letters\n      charCode += 4;\n    } else if (charCode >= 97 && charCode <= 122) { // Lowercase letters\n      charCode += 4;\n    } else {\n      // Non-alphabetic characters remain unchanged\n      result += str[i];\n      continue;\n    }\n\n    if (charCode > 122) {\n      charCode = (charCode - 122) + 97; // Adjust for lowercase 'z'\n    } else if (charCode > 90) {\n      charCode = (charCode - 90) + 65; // Adjust for uppercase 'Z'\n    }\n\n    result += String.fromCharCode(charCode);\n  }\n  return result;\n};"
      ],
      [
        "const nextSmallest = (arr) => {\n  if (arr.length < 2) return null;\n\n  let smallest = arr[0];\n  let secondSmallest = null;\n\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = arr[i];\n    } else if (arr[i] > secondSmallest && arr[i] < smallest) {\n      secondSmallest = arr[i];\n    }\n  }\n\n  return secondSmallest === null ? null : secondSmallest;\n};"
      ],
      [
        "const isBored = (str) => {\n  let boredomCount = 0;\n  let currentSentence = '';\n  let lastChar = '';\n\n  for (let i = 0; i < str.length; i++) {\n    lastChar = str[i];\n    if (str[i] === ' ' && currentSentence.startsWith('I')) {\n      boredomCount++;\n      currentSentence = '';\n    } else {\n      currentSentence += str[i];\n    }\n  }\n\n  return boredomCount;\n};"
      ],
      [
        "const anyInt = (x, b, z) => {\n  if (x % 1 === 0 && b % 1 === 0 && z % 1 === 0 && (x + b === z || x + z === b || x === b + z)) {\n    return true\n  }\n  return false\n}"
      ],
      [
        "const encode = (message) => {\n  let encoded = '';\n  for (let i = 0; i < message.length; i++) {\n    const charCode = message[i].charCodeAt(0);\n    if (charCode >= 65 && charCode <= 90) {\n      encoded += String.fromCharCode(charCode + 32);\n    } else if (charCode >= 97 && charCode <= 122) {\n      const index = 'aeiou'.indexOf(message[i]);\n      if (index !== -1) {\n        encoded += String.fromCharCode((index + 2 + 26) % 26 + 97);\n      } else {\n        encoded += message[i];\n      }\n    } else {\n      encoded += message[i];\n    }\n  }\n  return encoded;\n};"
      ],
      [
        "const skjkasdkd = (lst) => {\n  let t = 0;\n  let largestPrime = -1;\n  let primeSum = 0;\n\n  for (let i = 0; i < lst.length; i++) {\n    let isPrime = true;\n    for (let q = 2; q * q <= lst[i]; q++) {\n      if (lst[i] % q == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n\n    if (isPrime) {\n      largestPrime = lst[i];\n      primeSum = sumOfDigits(largestPrime);\n    }\n  }\n\n  return primeSum;\n};\n\nconst sumOfDigits = (num) => {\n  let sum = 0;\n  while (num > 0) {\n    sum += num % 10;\n    num = Math.floor(num / 10);\n  }\n  return sum;\n};"
      ],
      [
        "const checkDictCase = (obj) => {\n  if (Object.keys(obj).length === 0) return false;\n\n  for (let key in obj) {\n    if (typeof obj[key] !== 'string' || (key !== key.toLowerCase() && key !== key.toUpperCase())) {\n      return false;\n    }\n  }\n\n  return true;\n};"
      ],
      [
        "const countUpTo = (n) => {\n  let result = []\n  for (let m = 2; m < n; m++) {\n    let j = 1\n    for (let i = 2; i * i <= m; i++) {\n      if (m % i === 0) {\n        j = 0\n        break\n      }\n    }\n    if (j === 1) {\n      result.push(m)\n    }\n  }\n  return result\n}"
      ],
      [
        "Complete code (including all the content of the code I provided and the code you generated)"
      ],
      [
        "const countUpper = (s) => {\n  let count = 0;\n  const vowels = ['A', 'E', 'I', 'O', 'U'];\n  for (let i = 0; i < s.length; i += 2) {\n    if (vowels.includes(s[i])) {\n      count++;\n    }\n  }\n  return count;\n};"
      ],
      [
        "const closestInteger = (value) => {\n  value = Number(value)\n  let g = value % 1\n  if (g < 0.5 && g > -0.5) { value -= g }\n  return Math.abs(Math.round(value));\n}"
      ],
      [
        "const makeAPile = (n) => {\n  let t = []\n  for (let r = n; r < n * 3; r += 2) {\n    t.push(r)\n  }\n  return t\n}"
      ],
      [
        "const wordsString = (string) => {\n  let s = ''\n  let m = [];\n  let mask = 0;\n  for (let j = 0; j < string.length; j++) {\n    if (string[j] == ' ' || string[j] == ',') {\n      if (mask == 0) {\n        mask = 1;\n        m.push(s);\n      }\n      mask = 0;\n      s = '';\n    } else {\n      s += string[j];\n    }\n  }\n  if (mask == 1) {\n    m.push(s);\n  }\n  return m;\n}"
      ],
      [
        "const chooseNum = (x, y) => {\n  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i}\n  }\n  return -1;\n};"
      ],
      [
        "const roundedAvg = (b, m) => {\n  if (b > m) { return -1 }\n  let p = (b + m) / 2\n  if (p % 1 != 0) { p = (b + m + 1) / 2 }\n  return parseInt(p.toString(2), 10).toString(2);\n}"
      ],
      [
        "const uniqueDigits = (x) => {\n  let k = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) k.push(x[i])\n  }\n  return k.sort((a, b) => a - b)\n}"
      ],
      [
        "``javascript\nconst byLength = (arr) => {\n  const p = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) {\n      p.push(arr[i]);\n    }\n  }\n  for (let i = 0; i < p.length; i++) {\n    let j = i;\n    for (let k = i + 1; k < p.length; k++) {\n      if (p[k] > p[j]) {\n        j = k;\n      }\n    }\n    if (j !== i) {\n      let temp = p[i];\n      p[i] = p[j];\n      p[j] = temp;\n    }\n  }\n  let result = [];\n  for (let i = 0; i < p.length; i++) {\n    let num = p[i];\n    switch (num) {\n      case 1:\n        result.push(\"One\");\n        break;\n      case 2:\n        result.push(\"Two\");\n        break;\n      case 3:\n        result.push(\"Three\");\n        break;\n      case 4:\n        result.push(\"Four\");\n        break;\n      case 5:\n        result.push(\"Five\");\n        break;\n      case 6:\n        result.push(\"Six\");\n        break;\n      case 7:\n        result.push(\"Seven\");\n        break;\n      case 8:\n        result.push(\"Eight\");\n        break;\n      case 9:\n        result.push(\"Nine\");\n        break;\n    }\n  }\n  return result;\n}\n\nconst arr = [2, 1, 1, 4, 5, 8, 2, 3];\n\n\nconst emptyArr = [];\n\n\nconst strangeArr = [1, -1, 5"
      ],
      [
        "const F = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      let factorial = 1;\n      for (let j = 2; j <= i; j++) {\n        factorial *= j;\n      }\n      result[i] = factorial;\n    } else {\n      result[i] = i * (i + 1) / 2;\n    }\n  }\n  return result;\n}"
      ],
      [
        "const evenOddPalindrome = (n) => {\n  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let ph = i.toString()\n    let p = 1\n    for (let j = 0; j < ph.length; j++) {\n      if (ph[j] != ph[ph.length - j - 1]) {\n        p = 0\n        break\n      }\n    }\n    if (p) {\n      if (i % 2 === 0) {\n        e++\n      } else {\n        o++\n      }\n    }\n  }\n  return (e, o)\n}"
      ],
      [
        "const countNums = (arr) => {\n  let p = 0\n  for (let r = 0; r < arr.length; r++) {\n    let h = arr[r]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let sum = 0;\n    let sign = h < 0 ? -1 : 1;\n    h = Math.abs(h);\n    while (h > 0) {\n      sum += h % 10;\n      h = Math.floor(h / 10);\n    }\n    if (sum * sign > 0) {\n      p++;\n    }\n  }\n  return p;\n}"
      ],
      [
        "const moveOneBall = (arr) => {\n  if (arr.length == 0) { return true }\n  let p = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        p = j;\n        break;\n      }\n    }\n    if (!t) break;\n  }\n  return t;\n}"
      ],
      [
        "const exchange = (lst1, lst2) => {\n  let countEvenLst1 = 0;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      countEvenLst1++;\n    }\n  }\n\n  let countEvenLst2 = 0;\n  for (let j = 0; j < lst2.length; j++) {\n    if (lst2[j] % 2 === 0) {\n      countEvenLst2++;\n    }\n  }\n\n  return countEvenLst1 === countEvenLst2 ? \"YES\" : \"NO\";\n};"
      ],
      [
        "const histogram = (test) => {\n  let w = {}\n  let t = test.split(/\\s/);\n  if (test === '') { t = []; }\n  for (m in t) {\n    if (t[m] in w) {\n      w[t[m]]++;\n    } else {\n      w[t[m]] = 1;\n    }\n  }\n  let maxCount = Math.max(...Object.values(w));\n  let maxKeys = Object.keys(w).reduce((acc, k) => (w[k] > maxCount ? acc : { ...acc, [k]: w[k] }), {});\n  return maxKeys;\n}"
      ],
      [
        "const reverseDelete = (s, c) => {\n  let t = '';\n  for (let i = 0; i < s.length; i++) {\n    let y = 1;\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] === c[j]) {\n        y = 0;\n      }\n    }\n    if (y === 1) {\n      t += s[i];\n    }\n  }\n  t = t.split('').reverse().join('');\n  return [t, t === s];\n};"
      ],
      [
        "const oddCount = (lst) => {\n  let d = [];\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length;\n    for (let q = 0; q < h; q++) {\n      if (lst[i][q] % 2 !== 0) {\n        p++;\n      }\n    }\n    d.push(`the number of odd elements ${p}n the str${p}ng ${i + 1} of the ${i + 1}nput.`);\n  }\n  return d;\n};"
      ],
      [
        "const minSubArraySum = (nums) => {\n  let min = nums[0];\n  for (let i = 0; i < nums.length; i++) {\n    let sum = nums[i];\n    if (nums[i] < min) {\n      min = nums[i];\n    }\n    for (let q = i + 1; q <= nums.length; q++) {\n      sum += nums[q];\n      if (sum < min) {\n        min = sum;\n      }\n    }\n  }\n  return min;\n};"
      ],
      [
        "const maxFill = (grid, bucketCapacity) => {\n  let bucketCount = 0;\n  let rowLength = grid[0].length;\n  let totalWater = 0;\n\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < rowLength; col++) {\n      if (grid[row][col] === 1) {\n        totalWater++;\n        if (totalWater > bucketCapacity) {\n          bucketCount++;\n          totalWater = totalWater - bucketCapacity;\n        }\n      }\n    }\n  }\n\n  return bucketCount;\n};"
      ],
      [
        "const sortArray = (arr) => {\n  arr.sort((a, b) => {\n    const binaryA = a.toString(2);\n    const binaryB = b.toString(2);\n    const onesA = (binaryA.match(/1/g) || []).length;\n    const onesB = (binaryB.match(/1/g) || []).length;\n\n    if (onesA !== onesB) {\n      return onesA - onesB;\n    } else {\n      return a - b;\n    }\n  });\n  return arr;\n};"
      ],
      [
        "const selectWords = (s, n) => {\n  if (s === '') return [];\n  const words = s.split(/\\s/);\n  const wordCount = {};\n\n  words.forEach(word => {\n    const consonants = word.replace(/([aeiou])/gi, '').length;\n    if (consonants === n) {\n      wordCount[word] = true;\n    }\n  });\n\n  return Object.keys(wordCount);\n};"
      ],
      [
        "const getClosestVowel = (word) => {\n  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'E' && word[i] != 'I' && word[i] != 'O' && word[i] != 'U')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'E' && word[i + 1] != 'I' && word[i + 1] != 'O' && word[i + 1] != 'U')\n    ) {\n      return word[i];\n    }\n  }\n  return '';\n};"
      ],
      [
        "const matchParens = (oht) => {\n  let w1 = oht[0] + oht[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  let v = 0\n  for (let i = w1.length; i < w1.length + oht[1].length; i++) {\n    if (oht[1][v] == '(') { v++ }\n    else { v-- }\n    if (v < 0) {\n      break;\n    }\n  }\n  return u || v >= 0;\n}"
      ],
      [
        "const maximum = (arr, k) => {\n  let p = arr\n  for (let q = 0; q < p.length; q++) {\n    let ind = q\n    for (let k = q + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind !== q) {\n      let temp = p[q]\n      p[q] = p[ind]\n      p[ind] = temp\n    }\n  }\n  return p.slice(0, k)\n}"
      ],
      [
        "const solution = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i += 2) {\n    if (arr[i] % 2 !== 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};"
      ],
      [
        "const addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    if (Math.abs(arr[i]) < 100 && Math.abs(arr[i]) > -100) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};"
      ],
      [
        "const getOddCollatz = (n) => {\n  let oddNumbers = [];\n  let current = n;\n\n  while (current !== 1) {\n    if (current % 2 !== 0) {\n      oddNumbers.push(current);\n    }\n    current = current % 2 === 0 ? current / 2 : 3 * current + 1;\n  }\n  oddNumbers.push(1);\n  return oddNumbers.sort((a, b) => a - b);\n};"
      ],
      [
        "const validDate = (date) => {\n  let g = date.split(/-/);\n  if (g.length != 3) { return false }\n  if (g[0] < 1 || g[0] > 12 || g[1] < 1) { return false }\n  if (g[0] == 2 && g[1] > 29) { return false }\n  if (g[2] < 0 || g[2] > 31) { return false }\n  if (g[0] == 4 || g[0] == 6 || g[0] == 9 || g[0] == 11 && g[1] > 30) { return false }\n  return true;\n}"
      ],
      [
        "const splitWords = (string) => {\n  let words = string.split(/\\s/)\n  if (words.length > 1) {\n    return words\n  } else {\n    words = string.split(/,/)\n    if (words.length > 1) {\n      return words\n    } else {\n      return string.toLowerCase().split('').filter((char) => char >= 'a' && char <= 'z').filter((char, index) => index % 2 !== 0).length\n    }\n  }\n}"
      ],
      [
        "const isSorted = (arr) => {\n  if (arr.length == 0) { return true }\n  let prev = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < prev) { return false; }\n    prev = arr[i];\n  }\n  return true;\n};"
      ],
      [
        "const intersection = (interval1, interval2) => {\n  let lo = interval1[0];\n  if (interval2[0] > lo) { lo = interval2[0]; }\n  let sr = interval1[1];\n  if (interval2[1] < sr) { sr = interval2[1]; }\n  let len = sr - lo + 1;\n\n  if (len <= 1) {\n    return len % 2 === 0 ? \"NO\" : \"YES\";\n  }\n\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i === 0) {\n      return \"NO\";\n    }\n  }\n\n  return \"YES\";\n};"
      ],
      [
        "const prodSigns = (arr) => {\n  if (arr.length == 0) { return null }\n  let m = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    m *= arr[i]\n    s += Math.abs(arr[i])\n  }\n  return m === 1 ? s : m === -1 ? -s : null;\n}"
      ],
      [
        "const minPath = (grid, k) => {\n  const N = grid.length;\n  let minPathValues = [];\n\n  const directions = [\n    [-1, 0], // left\n    [1, 0],  // right\n    [0, -1], // up\n    [0, 1]   // down\n  ];\n\n  const dfs = (x, y, path, visited, len) => {\n    if (len === k) {\n      if (!minPathValues.length || path.length < minPathValues.length) {\n        minPathValues = path;\n      }\n      return;\n    }\n\n    for (const [dx, dy] of directions) {\n      const nx = x + dx, ny = y + dy;\n      if (nx < 0 || nx >= N || ny < 0 || ny >= N || visited[nx][ny]) continue;\n      visited[nx][ny] = true;\n      dfs(nx, ny, [...path, grid[nx][ny]], visited, len + 1);\n      visited[nx][ny] = false;\n    }\n  };\n\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < N; j++) {\n      const visited = Array.from({ length: N }, () => Array(N).fill(false));\n      visited[i][j] = true;\n      dfs(i, j, [grid[i][j]], visited, 1);\n    }\n  }\n\n  return minPathValues.sort((a, b) => a - b);\n};"
      ],
      [
        "const tri = (n) => {\n  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let k = [1, 3];\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      k[i] = i / 2;\n    } else {\n      k[i] = k[i - 1] + k[i - 2] + k[i + 1];\n    }\n  }\n  return k;\n}"
      ],
      [
        "const digits = (n) => {\n  let p = 1\n  let k = 1\n  while (n > 0) {\n    let b = n % 10\n    if (b % 2 == 1) {\n      p *= b\n    }\n    n = Math.floor(n / 10)\n  }\n  return p === 1 ? n : p;\n}"
      ],
      [
        "const isNested = (str) => {\n  let stack = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '[') {\n      stack.push(i);\n    } else if (str[i] === ']') {\n      if (stack.length === 0) return false;\n      stack.pop();\n    }\n  }\n  return stack.length === 0;\n};"
      ],
      [
        "const sumSquares = (lst) => {\n  let k = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = y % 1 - y % 1 - 1 }\n    }\n    k += Math.pow(y, 2)\n  }\n  return Math.round(k)\n}"
      ],
      [
        "const checkIfLastCharIsALetter = (str) => {\n  const lastChar = str[str.length - 1];\n  const isAlphabet = lastChar >= 'a' && lastChar <= 'z' || lastChar >= 'A' && lastChar <= 'Z';\n  const isNotPartOfWord = !str.includes(' ', str.lastIndexOf(lastChar));\n  return isAlphabet && isNotPartOfWord;\n};"
      ],
      [
        "const canArrange = (arr) => {\n  if (arr.length === 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1;\n}"
      ],
      [
        "const largestSmallestIntegers = (arr) => {\n  let largestNegative = -Infinity;\n  let smallestPositive = Infinity;\n\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < smallestPositive) {\n      smallestPositive = arr[i];\n    } else if (arr[i] < 0 && arr[i] > largestNegative) {\n      largestNegative = arr[i];\n    }\n  }\n\n  return (smallestPositive === Infinity && largestNegative === -Infinity) ? null : [largestNegative, smallestPositive];\n};"
      ],
      [
        "const compareOne = (var_0, var_2) => {\n  let var_1 = Number(var_0)\n  if (typeof var_0 == 'string') { var_1 = Number(var_0.replace(',', '.')) }\n  let var_3 = Number(var_2)\n  if (typeof var_2 == 'string') { var_3 = Number(var_2.replace(',', '.')) }\n\n  if (var_1 > var_3) {\n    return var_1\n  } else if (var_1 < var_3) {\n    return var_3\n  } else {\n    return null\n  }\n}"
      ],
      [
        "const isEqualToSumEven = (i) => {\n  let sum = 0;\n  for (let j = 0; j <= i; j += 2) {\n    sum += j;\n    if (sum > i) {\n      return false;\n    }\n  }\n  return sum === i;\n}"
      ],
      [
        "const specialFactorial = (x) => {\n  let s = 1;\n  let z = 1;\n  while (x > 1) {\n    let c = s;\n    while (c > 0) {\n      z *= c;\n      c--;\n    }\n    s *= x;\n    x--;\n  }\n  return s * z;\n}"
      ],
      [
        "const fixSpaces = (gvcg) => {\n  let t = '';\n  let c = 0;\n  for (let i = 0; i < gvcg.length; i++) {\n    if (gvcg[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      c = 0;\n    }\n    if (gvcg[i] !== ' ') {\n      t += gvcg[i];\n      c = 0;\n    }\n  }\n  return t;\n}"
      ],
      [
        "const fileNameCheck = (file_name) => {\n  let g = file_name.split(/\\./)\n  if (g.length != 2) { return 'No' }\n  if (g[1] != 'txt' && g[1] != 'dll' && g[1] != 'exe') { return 'No' }\n  if (g[0] == '') { return 'No' }\n  let a = g[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  if (g[0].length > 3) { return 'No' }\n  return 'Yes'\n}"
      ],
      [
        "const sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      sum += lst[i] ** 2;\n    } else if (i % 4 === 0) {\n      sum += lst[i] ** 3;\n    }\n  }\n  return sum;\n};"
      ],
      [
        "const wordsInSentence = (sentence) => {\n  let words = sentence.split(/\\s/);\n  let result = '';\n  for (let i = 0; i < words.length; i++) {\n    let wordLength = words[i].length;\n    if (wordLength === 1 || wordLength === 0) continue;\n    if (isPrime(wordLength)) result += words[i] + ' ';\n  }\n  return result.trim();\n};\n\nconst isPrime = (num) => {\n  for(let i = 2, sqrt = Math.sqrt(num); i <= sqrt; i++)\n    if(num % i === 0) return false; \n  return num > 1;\n};"
      ],
      [
        "const simplify = (x, n) => {\n  const xNumerator = parseInt(x.split('/')[0]);\n  const xDenominator = parseInt(x.split('/')[1]);\n  const nNumerator = parseInt(n.split('/')[0]);\n  const nDenominator = parseInt(n.split('/')[1]);\n  const resultNumerator = xNumerator * nNumerator;\n  const resultDenominator = xDenominator * nDenominator;\n  return resultNumerator % resultDenominator === 0;\n};"
      ],
      [
        "const orderByPoints = (points) => {\n  let result = points\n  for (let i = result.length - 2; i >= 0; i--) {\n    for (let j = 0; j <= i; j++) {\n      let k = 0\n      let n = 0\n      let h = result[j]\n      let d = result[j + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      \n      let sumH = 0\n      let sumD = 0\n      while (h !== 0) {\n        sumH += Math.abs(h % 10)\n        h = Math.floor(h / 10)\n      }\n      while (d !== 0) {\n        sumD += Math.abs(d % 10)\n        d = Math.floor(d / 10)\n      }\n      \n      if (sumH < sumD) {\n        k = j\n        n = i\n      } else if (sumH === sumD) {\n        if (j < i) {\n          k = j\n          n = i\n        }\n      }\n    }\n  }\n  return result.slice(0, n + 1).concat(result.slice(n + 1)).concat(result.slice(0, k + 1).reverse()).reverse()\n}"
      ],
      [
        "const specialFilter = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 10) {\n      let num = arr[i].toString();\n      let firstDigit = parseInt(num[0]);\n      let lastDigit = parseInt(num[num.length - 1]);\n      if (firstDigit % 2 !== 0 && lastDigit % 2 !== 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n}"
      ],
      [
        "const getMaxTriples = (n) => {\n  let b = []\n  for (let i = 1; i <= n; i++) {\n    b.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      let sum = b[i] + b[j];\n      if (sum % 3 === 0) {\n        u++;\n      }\n    }\n  }\n  return u;\n}"
      ],
      [
        "const bf = (planet1, planet2) => {\n  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let r = 0; r < 8; r++) {\n    if (y[r] == planet1) { lo = r }\n  }\n  for (let r = 0; r < 8; r++) {\n    if (y[r] == planet2) { hi = r }\n  }\n  if (lo === -1 || hi === -1) return [];\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i]);\n  }\n  return u.sort((a, b) => y.indexOf(a) - y.indexOf(b));\n}"
      ],
      [
        "const sortedListSum = (lst) => {\n  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let u = 0\n      if (p[k].length > p[k + 1].length) { u = 1 }\n      if (p[k].length == p[k + 1].length) {\n        if (p[k] > p[k + 1]) { u = 1 }\n      }\n      if (u === 1) {\n        let temp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = temp\n      }\n    }\n  }\n  return p\n}"
      ],
      [
        "const xOrY = (n, x, y) => {\n  let lem = n;\n  if (lem == 1 || lem == 0) { return y }\n  for (let i = 2; i * i <= lem; i++) {\n    if (lem % i === 0) { return y }\n  }\n  return x;\n}"
      ],
      [
        "const doubleTheDifference = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] % 2 === 1) {\n      sum += arr[i] * arr[i];\n    }\n  }\n  return sum;\n}"
      ],
      [
        "const compare = (tznv, guess) => {\n  for (let i = 0; i < guess.length; i++) {\n    tznv[i] -= guess[i]\n    if (tznv[i] < 0) {\n      tznv[i] = Math.abs(tznv[i]);\n    }\n  }\n  return tznv;\n}"
      ],
      [
        "const strongestExtension = (class_name, extensions) => {\n  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let p = extensions[i][j].charCodeAt() - 'A'.charCodeAt();\n      if (p >= 0) y++\n    }\n    if (y > u) {\n      u = y\n      s = extensions[i]\n    }\n  }\n  return `${class_name}.${s}`;\n}"
      ],
      [
        "const cycpatternCheck = (a, b) => {\n  let l = b.length;\n  let pat = b + b;\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1;\n      for (let p = 0; p < l; p++) {\n        if (a[i + j * l + p] !== pat[p]) {\n          y = 0;\n          break;\n        }\n      }\n      if (y) return true;\n    }\n  }\n  return false;\n};"
      ],
      [
        "const evenOddCount = (i) => {\n  let c = 0, n = 0;\n  if (i < 0) { i = -i };\n  while (i > 0) {\n    let digit = i % 10;\n    if (digit % 2 === 0) {\n      c++;\n    } else {\n      n++;\n    }\n    i = Math.floor(i / 10);\n  }\n  return [c, n];\n};"
      ],
      [
        "const intToMiniRoman = (num) => {\n  const map = [\n    [1000, 'm'],\n    [900, 'cm'],\n    [500, 'd'],\n    [400, 'cd'],\n    [100, 'c'],\n    [90, 'xc'],\n    [50, 'l'],\n    [40, 'xl'],\n    [10, 'x'],\n    [9, 'ix'],\n    [5, 'v'],\n    [4, 'iv'],\n    [1, 'i']\n  ];\n\n  let result = '';\n  for (let i = 0; i < map.length; i++) {\n    while (num >= map[i][0]) {\n      num -= map[i][0];\n      result += map[i][1];\n    }\n  }\n  return result;\n};"
      ],
      [
        "const rightAngleTriangle = (a, b, c) => {\n  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}"
      ],
      [
        "const findMax = (strings) => {\n  let maxUniqueChars = 0;\n  let maxString = '';\n\n  strings.forEach(str => {\n    const uniqueChars = new Set(str.split('')).size;\n    if (uniqueChars > maxUniqueChars) {\n      maxUniqueChars = uniqueChars;\n      maxString = str;\n    } else if (uniqueChars === maxUniqueChars) {\n      maxString = maxString < str ? maxString : str;\n    }\n  });\n\n  return maxString;\n};"
      ],
      [
        "const eat = (number, need, remaining) => {\n  if (need <= remaining) {\n    return [number + need, remaining - need];\n  } else {\n    return [number + remaining, 0];\n  }\n};"
      ],
      [
        "const doAlgebra = (operator, okerand) => {\n  while (operator.length > 0) {\n    let y = 0;\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = okerand[i];\n        while (okerand[i + 1] > 1) {\n          okerand[i + 1]--;\n          okerand[i] *= u;\n        }\n        okerand.splice(i + 1, 1);\n        operator.splice(i, 1);\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue; }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        okerand[i] *= okerand[i + 1];\n        operator.splice(i, 1);\n        okerand.splice(i + 1, 1);\n        i--;\n      }\n    }\n  }\n  return okerand.reduce((a, b) => a + b, 0);\n};"
      ],
      [
        "const solve = (string) => {\n  let i = 0\n  let result = ''\n  for (let j = 0; j < string.length; j++) {\n    let c = string[j].charCodeAt()\n    if (c >= 65 && c <= 90) {\n      c += 32;\n      i = 1;\n    } else if (c >= 97 && c <= 122) {\n      c -= 32;\n      i = 0;\n    }\n    if (i) {\n      c = String.fromCharCode(c).toUpperCase();\n    } else {\n      c = String.fromCharCode(c).toLowerCase();\n    }\n    result += c;\n  }\n  return result;\n}"
      ],
      [
        "const stringToMd5 = (string) => {\n  if (string == '') { return null }\n  var md5 = require('js-md5');\n  return md5(string);\n}"
      ],
      [
        "const generateIntegers = (a, b) => {\n  let evenDigits = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      evenDigits.push(i);\n    }\n  }\n  return evenDigits;\n};"
      ]
    ],
    "variance": 0.0,
    "stddev": 0.0
  }
]