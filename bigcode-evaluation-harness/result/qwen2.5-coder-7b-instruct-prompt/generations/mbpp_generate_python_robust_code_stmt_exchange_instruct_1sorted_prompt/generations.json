[["def check_integer(text):\n    text = text.strip()\n    if not(len(text) < 1):\n        if all(text[i] in \"0123456789\" for i in range(len(text))):\n            return True\n        elif (text[0] in \"+-\") and all(text[i+1] in \"0123456789\" for i in range(1, len(text))):\n            return True\n        else:\n            return False\n    else:\n        return None\n"], ["import math\n\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = math.floor(len(arr) / 2)\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(a, b):\n    c = []\n    while len(a) != 0 and len(b) != 0:\n        if not(a[0] < b[0]):\n            c.append(b[0])\n            b.remove(b[0])\n        else:\n            c.append(a[0])\n            a.remove(a[0])\n    if len(a) == 0:\n        c += b\n    else:\n        c += a\n    return c\n"], ["import math \n\ndef is_majority(arr, n, x):\n\ti = binary_search(arr, 0, n-1, x)\n\tif i == -1:\n\t\treturn False\n\tif not(((i + n//2) <= (n -1)) and arr[i + n//2] == x):\n\t\treturn False\n\telse:\n\t\treturn True\n\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (low + high)//2\n\t\tif ((mid == 0 or x > arr[mid - 1]) and (arr[mid] == x)):\n\t\t\treturn mid\n\t\telif x > arr[mid]:\n\t\t\treturn binary_search(arr, (mid + 1), high,x)\n\t\telse:\n\t\t\treturn binary_search(arr, low, (mid -1),x)\n\telse:\n\t\treturn -1\n"], ["import math\n\ndef No_of_Triangle(N,K):\n    if not((N < K)):\n        Tri_up = 0;\n        Tri_up += (N-K+1)*(N-K)//2\n        Tri_up += (K-1)*(K-2)//2\n        return Tri_up\n    else:\n        return -1;\n"], ["import numpy as np\n\ndef max_sum_increasing_subseq(a, n, index, k):\n\tdp = [[0 for i in range(n)] \n\t\t\tfor i in range(n)]\n\tfor i in range(n):\n\t\tif not(a[i] > a[0]):\n\t\t\tdp[0][i] = a[i]\n\t\telse:\n\t\t\tdp[0][i] = a[i] + a[0]\n\tfor i in range(1, n):\n\t\tfor j in range(i+1, n):\n\t\t\tif a[j] > a[i]:\n\t\t\t\tdp[i][j] = max(dp[i-1][i] + a[j], dp[i-1][j])\n\t\t\telse:\n\t\t\t\tdp[i][j] = dp[i-1][j]\n\treturn dp[index][k]\n"], ["def first_Element(arr,n,k):\n    count_map = {}; \n    for i in range(0, n): \n        if not((arr[i] in count_map.keys())):\n            count_map[arr[i]] = 1\n        else:\n            count_map[arr[i]] += 1\n        if count_map[arr[i]] == k:\n            return arr[i]\n    return -1\n"], ["import collections\n\ndef first_non_repeating_character(str1):\n  char_order = []\n  ctr = collections.Counter(str1)\n  for c in str1:\n    if ctr[c] == 1:\n      return c\n  return None\n"], ["import numpy as np\n\ndef get_maxgold(gold, m, n):\n    goldTable = [[0 for i in range(n)] \n                        for j in range(m)]   \n    for col in range(n-1, -1, -1): \n        for row in range(m):  \n            if not((col == n-1)):\n                right = goldTable[row][col+1]\n            else:\n                right = 0 \n            if (row == 0 or col == n-1): \n                right_up = 0\n            else:\n                right_up = goldTable[row-1][col+1]\n            if (row == m-1 or col == n-1): \n                right_down = 0\n            else:\n                right_down = goldTable[row+1][col+1]\n            goldTable[row][col] = gold[row][col] + max(right, right_up, right_down)    \n    return max(goldTable[i][0] for i in range(m))\n"], ["import numpy as np\n\ndef max_profit(price, k):\n    n = len(price)\n    final_profit = np.zeros((k + 1, n))\n    \n    for i in range(1, k + 1):\n        max_diff = -price[0]\n        for j in range(1, n):\n            final_profit[i][j] = max(final_profit[i][j-1], price[j] + max_diff)\n            max_diff = max(max_diff, final_profit[i-1][j] - price[j])\n    \n    return final_profit[k][n-1]\n"], ["import math\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    sl = (2 * radius) * math.tan(math.pi / 6)\n    p = sl * 0.5\n    b = sl * math.cos(math.radians(30))\n    w = b * 2\n    h = 2 * sl   \n    startx = startx - w\n    starty = starty - h\n    endx = endx + w\n    endy = endy + h\n    origx = startx\n    origy = starty\n    xoffset = b\n    yoffset = 3 * p\n    polygons = []\n    row = 1\n    counter = 0\n    while starty < endy:\n        if not(row % 2 == 0):\n            startx = origx\n        else:\n            startx = origx + xoffset\n        while startx < endx:\n            p1x = startx\n            p1y = starty + p\n            p2x = startx + b\n            p2y = starty\n            p3x = startx + w\n            p3y = starty + p\n            p4x = startx + w\n            p4y = starty + 2 * p\n            p5x = startx + b\n            p5y = starty + 3 * p\n            p6x = startx\n            p6y = starty + 2 * p\n            polygon = [(p1x, p1y), (p2x, p2y), (p3x, p3y), (p4x, p4y), (p5x, p5y), (p6x, p6y)]\n            polygons.append(polygon)\n            startx += 2 * b\n            counter += 1\n        starty += yoffset\n        row += 1\n    return polygons\n"]]