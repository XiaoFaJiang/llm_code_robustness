[["/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  var result = [];\n  {\n      let i = 0;\n      while(i < string.length){\n    result.push(string.slice(0, i+1));      i++;\n      }\n  }\n  return result;\n}\n"], ["const findClosestElements = (numbers) => {\n  var closest_pair, distance;\n  {\n      let i = 0;\n      while(i < numbers.length){{\n          let j = 0;\n          while(j < numbers.length){if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);      i++;\n      }\n            j++;\n          }\n      }\n      let min_distance = Infinity;\n      let closest_pair = null;\n      for (let i = 0; i < numbers.length - 1; i++) {\n        for (let j = i + 1; j < numbers.length; j++) {\n          let current_distance = Math.abs(numbers[i] - numbers[j]);\n          if (current_distance < min_distance) {\n            min_distance = current_distance;\n            closest_pair = [numbers[i], numbers[j]];\n          }\n        }\n      }\n      return closest_pair;\n    }\n  }\n}\n"], ["/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let i = n - 1;\n  while(i >= 0){if (n % i == 0) return i; i--;}\n};\n\n"], ["const factorize = (n) => {\n  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (!(n % i == 0)) {\n      i += 1;\n    } else {\n      fact.push(i);\n      n = n / i;\n    }\n  }\n  if (n > 1) {\n    fact.push(n);\n  }\n  return fact;\n}\n"], ["/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  var begin = -1.0, end = 1.0;\n  for(;(poly(xs, begin) * poly(xs, end) > 0);){\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    const mid = (begin + end) / 2;\n    if (poly(xs, mid) === 0) {\n      return mid;\n    } else if (poly(xs, mid) * poly(xs, begin) < 0) {\n      end = mid;\n    } else {\n      begin = mid;\n    }\n  }\n  return (begin + end) / 2;\n}\n"], ["const fizzBuzz = (n) => {\n  var ns = [], ans = 0;\n  {\n      let i = 0;\n      while(i < n){if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);      i++;\n      }\n  }\n  ns.forEach(num => {\n    ans += (num + '').split('').filter(digit => digit === '7').length;\n  });\n  return ans;\n}\n"], ["/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  {\n      let i = 0;\n      while(i < Math.floor((s.length + 2) / 3)){\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n        i++;\n      }\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  return encodeCyclic(encodeCyclic(s));\n}\n"], ["const primeFib = (n) => {\n  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    {\n        let k = 2;\n        for (; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n          if (p % k == 0)\n            return false;\n        }\n    }\n    return true;\n  };\n\n  let a = 0;\n  let b = 1;\n  let count = 0;\n\n  while (true) {\n    let fib = a;\n    a = b;\n    b = fib + b;\n    if (isPrime(b)) {\n      count++;\n      if (count === n) {\n        return b;\n      }\n    }\n  }\n}\n"], ["/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  {\n      let i = 0;\n      for (; i < l.length; i++)\n      {\n          let j = i + 1;\n          for (; j < l.length; j++)\n              {\n                  let k = j + 1;\n                  for (; k < l.length; k++)\n                  {\n                      if (l[i] + l[j] + l[k] === 0) {\n                          return true;\n                      }\n                  }\n              }\n      }\n  }\n  return false;\n}\n"], ["/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  {\n      let i = 0;\n      while(i < l.length){\n          let j = i + 1;\n          while(j < l.length){\n              if (l[i] + l[j] == 0){\n                  return true;\n              }\n              j++;\n          }\n          i++;\n      }\n      return false;\n  }\n};\n"], ["const isPalindrome = (text) => {\n  let i = 0;\n  for (; i < text.length; i++)\n    if (text[i] !== text[text.length - i - 1])\n      return false;\n  return true;\n}\n"], ["const modp = (n, p) => {\n  var ret = 1;\n  {\n      let i = 0;\n      while(i < n){ret = (2 * ret) % p;      i++;\n      }\n  }\n  return ret;\n}\n"], ["/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    {\n        let i = 2;\n        for (; i < k - 1; i++)\n          if (k % i == 0)\n            return false;\n    }\n    return true;\n  }\n\n  let largest = 0;\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    while (n % i === 0) {\n      if (isPrime(i)) {\n        largest = i;\n      }\n      n /= i;\n    }\n  }\n  if (n > 1) {\n    if (isPrime(n)) {\n      largest = n;\n    }\n  }\n  return largest;\n}\n"], ["/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n*/\nconst smallestChange = (arr) => {\n  var ans = 0;\n  {\n      let i = 0;\n      while(i < Math.floor(arr.length / 2)){if (arr[i] != arr.at(-i - 1))      i++;\n      }\n      // The number of elements to the right of the middle that need to be changed\n      // is equal to the number of elements to the left of the middle that need to be changed\n      // because they are the mirror of each other\n      ans += i;\n      // The number of elements to the right of the middle that need to be changed\n      // is equal to the number of elements that need to be changed to make the array palindromic\n      for (let j = Math.floor(arr.length / 2); j < arr.length; j++) {\n        if (arr[j] != arr[Math.floor(arr.length / 2) - (j - Math.floor(arr.length / 2))]) {\n          ans++;\n        }\n      }\n  }\n  return ans;\n}\n"], ["/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  var isPrime = function (n) {\n    {\n        let j = 2;\n        for (; j < n; j++)\n          if (n % j == 0)\n            return false;\n    }\n    return true;\n  }\n\n  let count = 0;\n  for (let i = 2; i < 101; i++) {\n    if (isPrime(i)) {\n      let remainder = a;\n      let j = 2;\n      while (j < i) {\n        if (remainder % j == 0 && isPrime(remainder / j)) {\n          remainder = remainder / j;\n          count++;\n          if (count === 2) {\n            break;\n          }\n        }\n        j++;\n      }\n      if (count === 2 && remainder === 1) {\n        return true;\n      }\n      count = 0;\n    }\n  }\n  return false;\n}\n"], ["const numericalLetterGrade = (grades) => {\n  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else{\n          if (gpa > 3.7) {\n          letter_grade.push('A')\n        } else{\n              if (gpa > 3.3) {\n              letter_grade.push('A-')\n            } else{\n                  if (gpa > 3.0) {\n                  letter_grade.push('B+')\n                } else{\n                      if (gpa > 2.7) {\n                  if (gpa > 2.3) {\n                    letter_grade.push('B')\n                  } else {\n                    letter_grade.push('B-')\n                  }\n                }\n              }\n          }\n          if (gpa > 2.0) {\n            letter_grade.push('C+')\n          } else {\n            if (gpa > 1.7) {\n              letter_grade.push('C')\n            } else {\n              if (gpa > 1.3) {\n                letter_grade.push('C-')\n              } else {\n                if (gpa > 1.0) {\n                  letter_grade.push('D+')\n                } else {\n                  if (gpa > 0.7) {\n                    letter_grade.push('D')\n                  } else {\n                    if (gpa > 0.0) {\n                      letter_grade.push('D-')\n                    } else {\n                      letter_grade.push('E')\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n    }\n  }\n  return letter_grade\n}\n"], ["/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n*/\nconst antiShuffle = (s) => {\n  let arr = s.split(/\\s/)\n  {\n      let i = 0;\n      while(i < arr.length){\n    {\n        let j = 0;\n        while(j < arr[i].length){\n      let ind = j\n      {\n          let k = j + 1;\n          while(k < arr[i].length){\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n            i++;\n                k++;\n          }\n      }\n          let sortedWord = '';\n          for (let m = 0; m < arr[i].length; m++) {\n            sortedWord += arr[i][m];\n          }\n          arr[i] = sortedWord;\n          j++;\n        }\n    }\n    i++;\n      }\n  }\n  return arr.join(' ');\n}\n"], ["const encrypt = (s) => {\n  let t = ''\n  {\n      let i = 0;\n      while(i < s.length){\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26       i++;\n      }\n    t += String.fromCharCode(p)\n  }\n  }\n  return t\n}\n"], ["/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let arr = lst\n  {\n      let j = 0;\n      for (; j < arr.length; j++) {\n      let ind = j\n      {\n          let k = j + 1;\n          for (; k < arr.length; k++) {\n              if (arr[k] < arr[ind]) {\n                ind = k\n              }\n            }\n      }\n  }\n  if (arr.length < 2) {\n    return null;\n  }\n  let min = arr[0];\n  let secondMin = null;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      secondMin = min;\n      min = arr[i];\n    } else if (arr[i] < secondMin && arr[i] !== min) {\n      secondMin = arr[i];\n    }\n  }\n  return secondMin;\n}\n"], ["/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let t = ''\n  {\n      let i = 0;\n      while(i < message.length){\n    let p = message[i].charCodeAt()\n    if (p > 96) { \n      // swap case\n      p = (p > 90) ? p - 32 : p + 32 \n      // replace vowels with 2 places ahead\n      if(['a','e','i','o','u'].includes(String.fromCharCode(p))){\n        p += 2\n        if(p > 122) p -= 26\n      }\n    }\n    t += String.fromCharCode(p)\n    i++;\n  }\n  return t\n}\n"], ["const skjkasdkd = (lst) => {\n  let maxPrime = 0;\n  let t = 0\n  {\n      let i = 0;\n      for (; i < lst.length; i++) {\n      let p = 1\n      {\n          let j = 2;\n          for (; j * j <= lst[i]; j++) {\n              if (lst[i] % j == 0) { p = 0; break }\n            }\n      }\n      if (p == 1 && lst[i] > maxPrime) {\n          maxPrime = lst[i];\n      }\n  }\n  if (maxPrime == 0) return 0;\n  let sumOfDigits = 0;\n  while (maxPrime > 0) {\n      sumOfDigits += maxPrime % 10;\n      maxPrime = Math.floor(maxPrime / 10);\n  }\n  return sumOfDigits;\n}\n"], ["const countUpTo = (n) => {\n  let t = []\n  {\n      let i = 2;\n      while(i < n){\n    let p = 1\n    {\n        let j = 2;\n        while(j * j <= i){      i++;\n              j++;\n        }\n    }\n    if(p === 1){\n      t.push(i);\n    }\n  }\n  }\n  return t;\n}\n"], ["const countUpper = (s) => {\n  let p = 0\n  {\n      let i = 0;\n      while(i < s.length){\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++; \n      i += 2;\n      }\n      else {\n        i++;\n      }\n    }\n  }\n  return p;\n}\n"], ["/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let t = []\n  {\n      let i = n;\n      for (; i < n * 3; i += 2) {\n      t.push(i)\n  }\n  // begin to write code\n  let isEven = n % 2 === 0;\n  for (let j = 0; j < n - 1; j++) {\n      let nextLevel = isEven ? i + 2 : i + 1;\n      t.push(nextLevel);\n      i = nextLevel;\n      isEven = !isEven;\n  }\n  return t;\n}\n"], ["/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  {\n      let i = y;\n      while(i >= x){\n    if (i % 2 == 0) {return i }\n        i--;\n      }\n  }\n  return -1;\n}\n"], ["const uniqueDigits = (x) => {\n  let p = []\n  {\n      let i = 0;\n      while(i < x.length){\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo === 1) {\n      p.push(x[i])\n    }\n    i++;\n      }\n  }\n  p.sort((a, b) => a - b)\n  return p\n}\n"], ["``javascript\n/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  p = []\n  {\n      let i = 0;\n      for (; i < arr.length; i++) {\n      if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n        let temp = p[j]\n        p[j] = p[k]\n        p[k] = temp\n      }\n    }\n  }\n  let result = []\n  for (let i = 0; i < p.length; i++) {\n    switch (p[i]) {\n      case 1:\n        result.push(\"One\")\n        break;\n      case 2:\n        result.push(\"Two\")\n        break;\n      case 3:\n        result.push(\"Three\")\n        break;\n      case 4:\n        result.push(\"Four\")\n        break;\n      case 5:\n        result.push(\"Five\")\n        break"], ["const f = (n) => {\n  let f = 1\n  let p = 0\n  let k = []\n  {\n      let i = 1;\n      for (; i <= n; i++) {\n      p += i;\n      if (i % 2 === 0) {\n        for (let j = 1; j <= i; j++) {\n          f *= j;\n        }\n        k.push(f);\n        f = 1;\n      } else {\n        k.push(p);\n      }\n  }\n  return k;\n}\n"], ["/*\n  Write a function countNums which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let p = 0\n  {\n      let i = 0;\n      for (; i < arr.length; i++) {\n      let h = arr[i]\n      if (h > 0) {\n        p++;\n        continue;\n      }\n      // begin to write code\n      let num = Math.abs(h);\n      let sum = 0;\n      while (num > 0) {\n        sum += num % 10;\n        num = Math.floor(num / 10);\n      }\n      if (sum > 0) {\n        p++;\n      }\n  }\n  return p;\n}\n"], ["const exchange = (lst1, lst2) => {\n  let k = lst1.length\n  let t = 0\n  {\n      let i = 0;\n      while(i < lst1.length){\n    if (lst1[i] % 2 == 0) { t++ }\n        i++;\n      }\n  }\n  let oddCount = k - t;\n  let evenCount = t;\n  let oddNumbers = lst1.filter(num => num % 2 !== 0);\n  let evenNumbers = lst1.filter(num => num % 2 === 0);\n  for (let i = 0; i < oddCount; i++) {\n    let minEven = Math.min(...evenNumbers);\n    let maxOdd = Math.max(...oddNumbers);\n    if (minEven >= maxOdd) {\n      return \"NO\";\n    }\n    oddNumbers = oddNumbers.filter(num => num !== maxOdd);\n    evenNumbers = evenNumbers.filter(num => num !== minEven);\n  }\n  return \"YES\";\n}\n"], ["/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (let m in t) {\n    if (!(t[m] in d)) {\n      d[t[m]] = 1;\n    } else {\n      d[t[m]]++;\n    }\n  }\n  let maxCount = Math.max(...Object.values(d));\n  let result = {};\n  for (let key in d) {\n    if (d[key] === maxCount) {\n      result[key] = maxCount;\n    }\n  }\n  return result;\n}\n"], ["/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    {\n        let j = 0;\n        while(j < c.length){\n      if (s[i] == c[j]) {\n        y = 0\n      }\n            j++;\n        }\n    }\n    if (y == 1) {\n      t += s[i];\n    }\n  }\n  return [t, t === t.split('').reverse().join('')];\n}\n"], ["/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n*/\nconst oddCount = (lst) => {\n  let d = []\n  {\n      let i = 0;\n      for (; i < lst.length; i++) {\n      let p = 0;\n      let h = lst[i].length\n      {\n          let j = 0;\n          for (; j < h; j++) {\n            if(lst[i][j] % 2 !== 0) {\n              p++\n            }\n          }\n      }\n      d.push(`the number of odd elements ${p}n the str${lst[i]}${i} of the ${lst[i]}nput.`)\n    }\n  }\n  return d\n}\n"], ["const minSubArraySum = (nums) => {\n  let min = nums[0]\n  {\n      let i = 0;\n      while(i < nums.length){\n    {\n        let j = i + 1;\n        while(j <= nums.length){\n      let s = 0;\n      {\n          let k = i;\n          while(k < j){\n            s += nums[k];\n            k++;\n          }\n          min = Math.min(min, s);\n      }\n          j++;\n        }\n    }\n      i++;\n    }\n  }\n  return min;\n}\n"], ["/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  let p = 0\n  {\n      let i = 0;\n      while(i < grid.length){\n    let m = 0\n    {\n        let j = 0;\n        while(j < grid[i].length){\n      if (grid[i][j] == 1) { m++       i++;\n      }\n          j++;\n        }\n    }\n    let k = 0;\n    while (k < grid.length) {\n      let sum = 0;\n      let l = 0;\n      while (l < grid[k].length) {\n        sum += grid[k][l];\n        l++;\n      }\n      p += Math.ceil(sum / capacity);\n      k++;\n    }\n  }\n  return p;\n}\n"], ["/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n*/\nconst sortArray = (arr) => {\n  let p = arr\n  {\n      let j = 0;\n      for (; j < p.length; j++) {\n      let ind = j\n      {\n          let k = j + 1;\n          for (; k < p.length; k++) {\n              let w1 = p[ind].toString(2)\n              let f1 = 0\n              {\n                  let u = 0;\n                  for (; u < w1.length; u++) {\n                      if (w1[u] == '1') { f1++ }\n                    }\n              }\n              let w2 = p[k].toString(2)\n              let f2 = 0\n              {\n                  let v = 0;\n                  for (; v < w2.length; v++) {\n                      if (w2[v] == '1') { f2++ }\n                    }\n              }\n              if (f1 > f2 || (f1 == f2 && p[ind] < p[k])) {\n                  let temp = p[ind];\n                  p[ind] = p[k];\n                  p[k] = temp;\n              }\n          }\n      }\n  }\n  return p;\n}\n"], ["/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  {\n      let i = 0;\n      while(i < t.length){\n    let l = 0\n    {\n        let j = 0;\n        while(j < t[i].length){\n          if('bcdfghjklmnpqrstvwxyz'.includes(t[i][j].toLowerCase())){\n            l++;\n          }\n          j++;\n        }\n        if(l == n){\n          k.push(t[i]);\n        }\n        i++;\n    }\n  }\n  return k;\n}\n"], ["const matchParens = (lst) => {\n  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (!(w1[i] == '(')) { y-- }\n    else { y++ }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n    if (y > 0 && w1[i] == ')') {\n      u = 0;\n      break;\n    }\n  }\n  if (y != 0) {\n    u = 0;\n  }\n  if (u == 1) {\n    return 'Yes'\n  } else {\n    return 'No'\n  }\n}\n"], ["const maximum = (arr, k) => {\n  let p = arr\n  {\n      let j = 0;\n      for (; j < p.length; j++) {\n      let ind = j\n      {\n          let k = j + 1;\n          for (; k < p.length; k++) {\n              if (p[k] < p[ind]) {\n                ind = k\n              }\n        }\n      }\n  let max = [];\n  for (let i = 0; i < k; i++) {\n    max.push(p[ind]);\n    let min = p[ind];\n    for (let j = 0; j < p.length; j++) {\n      if (p[j] > min) {\n        min = p[j];\n        ind = j;\n      }\n    }\n  }\n  max.sort((a, b) => a - b);\n  return max;\n}\n\n// Call the function with your input\n\n\n\n"], ["/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let p = 0\n  {\n      let i = 0;\n      while(i < k){\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i]       i++;\n      }\n  }\n  let j = 0;\n  while(j < k){\n    if (arr[j] >= 100 && arr[j] < 1000) { p += arr[j]       j++;\n    }\n  }\n  return p;\n}\n"], ["/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n*/\nconst getOddCollatz = (n) => {\n  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    {\n        let i = 0;\n        for (; i < p.length; i++) {\n          if (t == p[i]) {\n            u = 1\n            break;\n          }\n        }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 0) {\n      t = Math.floor(t / 2);\n    } else {\n      t = 3 * t + 1;\n    }\n    p.push(t);\n  }\n  return p.filter(x => x % 2 !== 0).sort((a, b) => a - b);\n}\n"], ["const minPath = (grid, k) => {\n  let m = 0\n  let n = 0\n  {\n      let i = 0;\n      while(i < grid.length){\n    {\n        let j = 0;\n        while(j < grid.length){\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n            i++;\n      }\n          j++;\n        }\n    }\n    let directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n    let visited = new Array(grid.length).fill(false).map(() => new Array(grid[0].length).fill(false));\n    let queue = [[m, n, [grid[m][n]]]];\n    let minPath = [];\n    while(queue.length > 0) {\n      let [x, y, path] = queue.shift();\n      if (path.length === k) {\n        if (!minPath.length || path < minPath) {\n          minPath = path;\n        }\n      } else {\n        for (let [dx, dy] of directions) {\n          let nx = x + dx;\n          let ny = y + dy;\n          if (nx >= 0 && nx < grid.length && ny >= 0 && ny < grid[0].length && !visited[nx][ny]) {\n            visited[nx][ny] = true;\n            queue.push([nx, ny, path.concat(grid[nx][ny])]);\n          }\n        }\n      }\n    }\n    return minPath;\n  }\n}\n"], ["/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (!(string[i] == '[')) {\n      closing_bracket_index1.push(i)\n    }\n    else {\n      opening_bracket_index.push(i)\n    }\n  }\n  let i = 0, j = 0;\n  while (i < opening_bracket_index.length && j < closing_bracket_index1.length) {\n    if (opening_bracket_index[i] < closing_bracket_index1[j]) {\n      return true;\n    }\n    i++;\n    j++;\n  }\n  return false;\n}\n"], ["const canArrange = (arr) => {\n  if (arr.length == 0) { return -1 }\n  {\n      let i = arr.length - 1;\n      while(i > 0){\n    if (arr[i] < arr[i - 1]) { return i       i--;\n      }\n  }\n  let i = arr.length - 2;\n  while(i >= 0){\n    if (arr[i] < arr[i + 1]) { return i; }\n    i--;\n  }\n  return -1;\n}\n"], ["const largestSmallestIntegers = (lst) => {\n  let a = Infinity\n  let b = -Infinity\n  {\n      let i = 0;\n      while(i < lst.length){\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i]       i++;\n      }\n  }\n  {\n      let j = 0;\n      while(j < lst.length){\n    if (lst[j] < 0 && lst[j] > b) { b = lst[j]       j++;\n      }\n  }\n  if (a === Infinity && b === -Infinity) {\n    return [null, null];\n  } else if (a === Infinity) {\n    return [null, Math.min(...lst.filter(x => x > 0))];\n  } else if (b === -Infinity) {\n    return [Math.max(...lst.filter(x => x < 0)), null];\n  } else {\n    return [a, b];\n  }\n}\n"], ["/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (!(text[i] == ' ')) if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      else { c = 1; t += '-' }\n    } else { c++ }\n    if (text[i] == ' ') {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      else { t += '-' }\n      c = 0\n    } else {\n      t += text[i]\n      c = 0\n    }\n  }\n  return t\n}\n"], ["/* \n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n*/\nconst sumSquares = (lst) => {\n  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else{\n        if (i % 4 == 0 && i % 3 !== 0) { y += lst[i] * lst[i] * lst[i] }\n    }\n  }\n  return y\n}\n"], ["/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let t = sentence.split(/\\s/)\n  let p = ''\n  {\n      let j = 0;\n      for (; j < t.length; j++) {\n      let len = t[j].length;\n      let u = 1\n      if (len == 1 || len == 0) { continue }\n      for (; u * u <= len; u++) {\n        if (len % u == 0) {\n          if (u * u == len) {\n            p += t[j] + ' '\n            break\n          } else {\n            continue\n          }\n        }\n      }\n    }\n  }\n  return p.trim()\n}\n"], ["const orderByPoints = (nums) => {\n  let p = nums\n  {\n      let j = p.length - 2;\n      for (; j >= 0; j--) {\n      {\n          let k = 0;\n          for (; k <= j; k++) {\n              let m = 0\n              let n = 0\n              let h = p[k]\n              let d = p[k + 1]\n              let y = 1\n              let u = 1\n              if (h < 0) { y = -1; h = -h; }\n              if (d < 0) { u = -1; d = -d; }\n              m = Math.abs(h);\n              n = Math.abs(d);\n              if (m < n) {\n                [p[k], p[k + 1]] = [p[k + 1], p[k]];\n              } else if (m > n) {\n                y = -u;\n              }\n              h = p[k] * y;\n              d = p[k + 1] * u;\n          }\n      }\n  }\n  return p;\n}\n"], ["/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  {\n      let i = 0;\n      while(i < nums.length){\n    if (nums[i] < 10) { i++;continue }\n    let y = Math.abs(nums[i]).toString();\n    if (y.length > 1 && (parseInt(y[0]) % 2 !== 0 && parseInt(y[y.length - 1]) % 2 !== 0) && nums[i] > 10) {\n      count++;\n    }\n    i++;\n  }\n  }\n  return count;\n}\n"], ["/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  let y = []\n  {\n      let i = 1;\n      while(i <= n){\n    y.push(i * i - i + 1)\n        i++;\n      }\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 === 0) {\n          u++;\n        }\n      }\n    }\n  }\n  return u;\n}\n"], ["/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  {\n      let i = 0;\n      for (; i < 8; i++) {\n      if (y[i] == planet1) { lo = i }\n    }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo === -1 || hi === -1) {\n    return []\n  }\n  if (lo > hi) {\n    let temp = lo\n    lo = hi\n    hi = temp\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n"], ["const sortedListSum = (lst) => {\n  let p = []\n  {\n      let i = 0;\n      for (; i < lst.length; i++) {\n      if (lst[i].length % 2 == 0) {\n        p.push(lst[i])\n      }\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        if (p[k] > p[k + 1]) {\n          let temp = p[k]\n          p[k] = p[k + 1]\n          p[k + 1] = temp\n        }\n      }\n      if (f == 1) {\n        let temp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = temp\n      }\n    }\n  }\n  return p;\n}\n"], ["const strongestExtension = (class_name, extensions) => {\n  let u = 0\n  let s = -Infinity\n  {\n      let i = extensions.length - 1;\n      while(i >= 0){\n    let y = 0\n    {\n        let j = 0;\n        while(j < extensions[i].length){\n      let k = extensions[i][j].charCodeAt(0);\n      if (k >= 65 && k <= 90) {\n        y++;\n      }\n      j++;\n        }\n    }\n    let cap = y;\n    let sm = extensions[i].length - y;\n    let strength = cap - sm;\n    if (strength > s) {\n      u = i;\n      s = strength;\n    }\n    i--;\n  }\n  }\n  return class_name + \".\" + extensions[u];\n}\n"], ["const cycpatternCheck = (a, b) => {\n  let l = b.length\n  let pat = b + b\n  {\n      let i = 0;\n      while(i < a.length - l + 1){\n    {\n        let j = 0;\n        while(j < l + 1){\n      let y = 1\n      {\n          let k = 0;\n          while(k < l){      i++;\n                k++;\n          }\n      }\n          j++;\n        }\n    }\n    let index = a.indexOf(pat.slice(j-l, j));\n    if (index !== -1) return true;\n    i++;\n    }\n  }\n  return false;\n}\n"], ["const findMax = (words) => {\n  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  {\n      let i = 0;\n      while(i < words.length){\n    let p = 0\n    {\n        let j = 0;\n        let uniqueChars = new Set();\n        while(j < words[i].length){\n          let y = 1\n          if (!uniqueChars.has(words[i][j])) {\n            uniqueChars.add(words[i][j]);\n            p++;\n          }\n          j++;\n        }\n        if (p > u) {\n          u = p;\n          s = i;\n        } else if (p == u && words[i] < words[s]) {\n          s = i;\n        }\n        i++;\n    }\n  }\n  return words[s];\n}\n"], ["``javascript\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  while (operator.length > 0) {\n    let y = 0\n    {\n        let i = operator.length - 1;\n        for (; i >= 0; i--) {\n          if (operator[i] == '**') {\n            let u = operand[i]\n            while (operand[i + 1] > 1) {\n              operand[i + 1]--;\n              operand[i] *= u;\n            }\n            operand.splice(i + 1, 1)\n            operator.splice(i, 1)\n            y = 1;\n            break;\n          }\n        }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      if (operator[i] == '/') {\n        operand[i] = Math.floor(operand[i] / operand[i + 1])\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i +"], ["const solve = (s) => {\n  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (!(y >= 65 && y <= 90)) if (y >= 97 && y <= 122) {\n    else {\n      y += 32;\n      t = 1;\n    }\n    if (t === 1) {\n      y = y - 32;\n      t = 0;\n    }\n    p += String.fromCharCode(y);\n  }\n  if (!/[a-zA-Z]/.test(s)) {\n    p = p.split('').reverse().join('');\n  }\n  return p;\n}\n"]]