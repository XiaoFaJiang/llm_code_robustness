[
  {
    "name": {
      "name": "full_level_robustness",
      "split": "test"
    },
    "count": 17,
    "generations": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <cassert>\n#include <string>\n\nstd::string remove_Occ(std::string s, char ch) {\n\n    /*\n    progame language:cpp\n    description:Write a cpp function to remove first and last occurrence of a given character from the string.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    {\n        int i = 0;\n        for (; i < s.length(); i++) {\n            if (s[i] == ch) {\n                s = s.substr(0, i) + s.substr(i + 1);\n                break;\n            }\n        }\n    }\n\n    {\n        int i = s.length() - 1;\n        for (; i >= 0; i--) {\n            if (s[i] == ch) {\n                s = s.substr(0, i) + s.substr(i + 1);\n                break;\n            }\n        }\n    }\n\n    return s;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint max_Prime_Factors(int n) {\n\n    int maxPrime = -1;\n    for(;(n % 2 == 0);){\n        maxPrime = 2;\n        n >>= 1;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n /= i;\n        }\n    }\n    if (n > 2) {\n        maxPrime = n;\n    }\n    return maxPrime;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cassert>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cctype>\n\nstd::vector<std::string> sort_mixed_list(std::vector<std::string> mixed_list) {\n\n    std::vector<int> int_part;\n    std::vector<std::string> str_part;\n    for (const auto& item : mixed_list) {\n        if (!(isdigit(item[0]) || (item[0] == '-' && item.size() > 1 && isdigit(item[1])))) {\n            str_part.push_back(item);\n        }\n        else {\n            int_part.push_back(std::stoi(item));\n        }\n\n    // Separate the integer and string parts\n    std::vector<std::string> sorted_int_part;\n    std::vector<std::string> sorted_str_part;\n\n    // Sort the integer part\n    std::sort(int_part.begin(), int_part.end());\n    for (const auto& num : int_part) {\n        sorted_int_part.push_back(std::to_string(num));\n    }\n\n    // Sort the string part\n    std::sort(str_part.begin(), str_part.end());\n    sorted_str_part = str_part;\n\n    // Combine the sorted integer and string parts\n    std::vector<std::string> sorted_mixed_list;\n    sorted_mixed_list.reserve(int_part.size() + str_part.size());\n    sorted_mixed_list.insert(sorted_mixed_list.end(), sorted_int_part.begin(), sorted_int_part.end());\n    sorted_mixed_list.insert(sorted_mixed_list.end(), sorted_str_part.begin(), sorted_str_part.end());\n\n    return sorted_mixed_list;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint find_gcd(int x, int y) {\n    for(;(y != 0);){\n        int temp = x % y;\n        x = y;\n        y = temp;\n    }\n    return x;\n}\n\nint find_gcd_of_array_elements(const std::vector<int>& arr) {\n    int gcd = arr[0];\n    for (int i = 1; i < arr.size(); ++i) {\n        gcd = find_gcd(gcd, arr[i]);\n    }\n    return gcd;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nstd::vector<int> counting_sort(std::vector<int> my_list) {\n\n    /*\n    progame language:cpp\n    description:Write a function to sort the given array by using counting sort.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    int max_value = 0;\n    {\n        int i = 0;\n        for (; i < my_list.size(); ++i) {\n            if (my_list[i] > max_value) {\n                max_value = my_list[i];\n            }\n        }\n    }\n    std::vector<int> buckets(max_value + 1, 0);\n    for (int num : my_list) {\n        buckets[num]++;\n    }\n    for (int i = 1; i <= max_value; ++i) {\n        buckets[i] += buckets[i - 1];\n    }\n    std::vector<int> output(my_list.size());\n    for (int i = 0; i < my_list.size(); ++i) {\n        output[buckets[my_list[i]] - 1] = my_list[i];\n        buckets[my_list[i]]--;\n    }\n    return output;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cassert>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n\nbool is_samepatterns(std::vector<std::string> colors, std::vector<std::string> patterns) {\n\n    if (colors.size() != patterns.size()) {\n        return false;\n    }\n    std::map<std::string, std::vector<std::string>> sdict;\n    std::set<std::string> pset;\n    std::set<std::string> sset;\n    {\n        size_t i = 0;\n        for (; i < patterns.size(); ++i) {\n            pset.insert(patterns[i]);\n            sset.insert(colors[i]);\n            sdict[patterns[i]].push_back(colors[i]);\n        }\n    }\n    for (const auto& pair : sdict) {\n        if (pair.second.size() != 1) {\n            return false;\n        }\n        if (pset.find(pair.first) == pset.end()) {\n            return false;\n        }\n        if (sset.find(pair.second[0]) == sset.end()) {\n            return false;\n        }\n    }\n    return true;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cassert>\n\nbool word_len(std::string s) {\n\n    std::istringstream iss(s);\n    std::vector<std::string> words;\n    std::string word;\n    for(;(iss >> word);){\n        words.push_back(word);\n    }\n    for (std::string w : words) {\n        if (w.length() % 2 != 0) {\n            return true;\n        }\n    }\n    return false;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <string>\n#include <cassert>\n\nchar get_Char(std::string strr) {\n\n    int summ = 0;\n    {\n        int i = 0;\n        for (; i < strr.length(); ++i) {\n            summ += (strr[i] - 'a' + 1);\n        }\n    }\n    if (summ % 26 == 0) {\n        return 'a';\n    } else {\n        return 'a' + (summ - 1) % 26;\n    }\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <set>\n#include <stdexcept>\n#include <cassert>\nusing namespace std;\nint amicable_numbers_sum(int limit) {\n\n    /*\n    progame language:cpp\n    description:Write a function to sum all amicable numbers from 1 to a specified number.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    if (limit < 1) {\n        throw invalid_argument(\"Input must be bigger than 0!\");\n    }\n    set<int> amicables;\n    for (int num = 2; num <= limit; num++) {\n        if (amicables.find(num) != amicables.end()) {\n            continue;\n        }\n        int sum_fact = 0;\n        {\n            int fact = 1;\n            while(fact < num){\n            if (num % fact == 0) {\n                sum_fact += fact;\n            }\n                    fact++;\n            }\n        }\n        int sum_fact2 = 0;\n        {\n            int fact = 1;\n            while(fact < sum_fact){\n            if (sum_fact % fact == 0) {\n                sum_fact2 += fact;\n            }\n                    fact++;\n            }\n        }\n        if (sum_fact2 == num && sum_fact != num) {\n            amicables.insert(num);\n        }\n    }\n    int sum = 0;\n    for (int num : amicables) {\n        sum += num;\n    }\n    return sum;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n\n#include<cassert>\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <set>\n\nbool magic_square_test(const std::vector<std::vector<int>>& my_matrix) {\n\n    size_t iSize = my_matrix[0].size();\n    std::vector<int> sum_list;\n    // Sum of each row\n    for (const auto& line : my_matrix) {\n        sum_list.push_back(std::accumulate(line.begin(), line.end(), 0));\n    }\n    // Sum of each column\n    {\n        size_t col = 0;\n        for (; col < iSize; ++col) {\n            int col_sum = 0;\n            {\n                size_t row = 0;\n                for (; row < iSize; ++row) {\n                        col_sum += my_matrix[row][col];\n                    }\n            }\n            sum_list.push_back(col_sum);\n        }\n    }\n    // Sum of the main diagonal"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::string check_last(const std::vector<int>& arr, int n, int p) {\n\n    int _sum = 0;\n    {\n        int i = 0;\n        while(i < n){\n        _sum += arr[i];\n            ++i;\n        }\n    }\n    if (p == 1) {\n        if (_sum % 2 == 0) {\n            return \"even\";\n        } else {\n            return \"odd\";\n        }\n    } else {\n        for (int i = 0; i < p - 1; ++i) {\n            _sum += _sum;\n        }\n        if (_sum % 2 == 0) {\n            return \"even\";\n        } else {\n            return \"odd\";\n        }\n    }\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <cassert>\n\nint sum_digits_single(int x) {\n    int ans = 0;\n    for(;(x);){\n        ans += x % 10;\n        x /= 10;\n    }\n    return ans;\n}\n\nint closest(int x) {\n    int max_sum = 0;\n    int max_num = 0;\n    for (int i = 1; i <= x; i++) {\n        int sum1 = sum_digits_single(i);\n        int sum2 = sum_digits_single(x - i);\n        if (sum1 + sum2 > max_sum) {\n            max_sum = sum1 + sum2;\n            max_num = i;\n        }\n    }\n    return max_num;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<int> merge(vector<int>& a, vector<int>& b) {\n    vector<int> c;\n    while (!a.empty() && !b.empty()) {\n        if (!(a.front() < b.front())) {\n            c.push_back(b.front());\n            b.erase(b.begin());\n        }\n        else {\n            c.push_back(a.front());\n            a.erase(a.begin());\n        }\n    }\n    if (a.empty()) {\n        c.insert(c.end(), b.begin(), b.end());\n    } else {\n        c.insert(c.end(), a.begin(), a.end());\n        sort(c.begin(), c.end());\n    }\n    return c;\n}\nvector<int> merge_sort(vector<int>& a) {\n    if (a.size() <= 1) {\n        return a;\n    }\n    int mid = a.size() / 2;\n    vector<int> left_half(a.begin(), a.begin() + mid);\n    vector<int> right_half(a.begin() + mid, a.end());\n    left_half = merge_sort(left_half);\n    right_half = merge_sort(right_half);\n    return merge(left_half, right_half);\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <iterator>\n#include <cassert>\n\ntemplate<typename T>\nstd::vector<std::vector<T>> encode_list(const std::vector<T>& list1) {\n\n    std::vector<std::vector<T>> result;\n    if (list1.empty()) return result;\n    T current_value = list1[0];\n    int count = 0;\n    for (const T& value : list1) {\n        if (!(value == current_value)) {\n            result.push_back({count, current_value});\n            current_value = value;\n            count = 1;\n        }\n        else {\n            count++;\n        }\n    }\n    result.push_back({count, current_value});\n    return result;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string month_season(std::string month, int days) {\n\n    std::string season;\n    if (month == \"January\" || month == \"February\" || month == \"March\") {\n        season = \"winter\";\n    } else{\n          if (month == \"April\" || month == \"May\" || month == \"June\") {\n            season = \"spring\";\n        } else{\n              if (month == \"July\" || month == \"August\" || month == \"September\") {\n                season = \"summer\";\n            } else {\n                season = \"autumn\";\n            }\n          }\n      }\n\n    if (days >= 21 && month == \"March\") {\n        season = \"spring\";\n    } else if (days <= 20 && month == \"June\") {\n        season = \"spring\";\n    } else if (days >= 21 && month == \"June\") {\n        season = \"summer\";\n    } else if (days <= 20 && month == \"September\") {\n        season = \"summer\";\n    } else if (days >= 21 && month == \"September\") {\n        season = \"autumn\";\n    } else if (days <= 20 && month == \"December\") {\n        season = \"autumn\";\n    } else if (days >= 21 && month == \"December\") {\n        season = \"winter\";\n    }\n\n    return season;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nbool is_num_keith(int x) {\n\n    vector<int> terms;\n    int temp = x;\n    int n = 0;\n    for(;(temp > 0);){\n        terms.push_back(temp % 10);\n        temp = temp / 10;\n        n++;\n    }\n    reverse(terms.begin(), terms.end());\n    int next_term = 0;\n    int i = n;\n    for(i; i >= 0; i--){\n        next_term += terms[i] * pow(2, i);\n    }\n    return next_term == x;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint first_Missing_Positive(std::vector<int> arr, int n) {\n\n    /*\n    progame language:cpp\n    description:Write a cpp function to find the first missing positive number.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    int ptr = 0;\n    {\n        int i = 0;\n        while(i < n){\n        if (arr[i] == 1) {\n            ptr = 1;\n            break;\n        }\n            ++i;\n        }\n    }\n    if (ptr == 0) {\n        return 1;\n    }\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] <= 0 || arr[i] > n) {\n            arr[i] = 0;\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        int num = abs(arr[i]);\n        if (num - 1 < n) {\n            arr[num - 1] = -abs(arr[num - 1]);\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > 0) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nint gcd(int a, int b) {\n    for(;(b != 0);){\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\nint min_operations(int a, int b) {\n    // Calculate the greatest common divisor (GCD) of a and b\n    int gcd_val = gcd(a, b);\n    \n    // Calculate the sum of the absolute differences between a and the GCD, and b and the GCD\n    int operations = abs(a - gcd_val) + abs(b - gcd_val);\n    \n    return operations;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nint binary_search(const vector<int>& arr, int low, int high, int x) {\n    if (high >= low) {\n        int mid = (low + high) / 2;\n        if ((mid == 0 || x > arr[mid - 1]) && (arr[mid] == x))\n            return mid;\n        else{\n            if (x > arr[mid])\n                return binary_search(arr, mid + 1, high, x);\n            else\n                return binary_search(arr, low, mid - 1, x);\n        }\n    }\n    return -1; // element not found\n}\nint majority_element(const vector<int>& arr) {\n    int n = arr.size();\n    int count = 0;\n    int candidate;\n    for (int num : arr) {\n        if (count == 0) {\n            candidate = num;\n        }\n        count += (num == candidate) ? 1 : -1;\n    }\n    return candidate;\n}\nint check_majority_element(const vector<int>& arr) {\n    int majority = majority_element(arr);\n    int count = 0;\n    for (int num : arr) {\n        if (num == majority) {\n            count++;\n        }\n    }\n    return (count > arr.size() / 2) ? majority : -1;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<iostream>\n#include <vector>\n#include <climits>\n#include <cassert>\nusing namespace std;\nint max_sum(vector<int> arr, int n) {\n\n    /*\n    progame language:cpp\n    description:Write a function to find the maximum sum of bi-tonic sub-sequence for the given array.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    vector<int> MSIBS = arr;\n    {\n        int i = 0;\n        for (; i < n; ++i) {\n            {\n                int j = 0;\n                for (; j < i; ++j) {\n                        if (arr[i] > arr[j] && MSIBS[i] < MSIBS[j] + arr[i]) {\n                            MSIBS[i] = MSIBS[j] + arr[i];\n                        }\n                    }\n            }\n        }\n    }\n    vector<int> MSDBS = arr;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = n - 1; j >= i; --j) {\n            if (arr[j] > arr[j - 1] && MSDBS[j] < MSDBS[j - 1] + arr[j]) {\n                MSDBS[j] = MSDBS[j - 1] + arr[j];\n            }\n        }\n    }\n    int max_sum = INT_MIN;\n    for (int i = 0; i < n; ++i) {\n        max_sum = max(max_sum, max(MSIBS[i], MSDBS[i]));\n    }\n    return max_sum;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint lps(string str) {\n\n    int n = str.size();\n    vector<vector<int>> L(n, vector<int>(n, 0));\n    {\n        int i = 0;\n        while(i < n){L[i][i] = 1;        i++;\n        }\n    }\n    for (int cl = 2; cl <= n; cl++) {\n        for (int i = 0; i < n - cl + 1; i++) {\n            int j = i + cl - 1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<std::string>> combinations_colors(const std::vector<std::string>& l, int n) {\n\n    std::vector<std::vector<std::string>> result;\n    std::vector<int> indices(n, 0);\n    int size = l.size();\n    while (true) {\n        // Add current combination\n        std::vector<std::string> current;\n        for (int i = 0; i < n; ++i) {\n            current.push_back(l[indices[i]]);\n        }\n        result.push_back(current);\n        // Generate next combination\n        int next = n - 1;\n        for(;(next >= 0 && indices[next] == size - 1);){\n            --next;\n        }\n        if (next < 0) {\n            break;\n        }\n        indices[next]++;\n        for(int i = next + 1; i < n; ++i) {\n            indices[i] = 0;\n        }\n    }\n    return result;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cassert>\n#include <iostream>\n#include <vector>\n#include <cmath> // for ceil\nusing namespace std;\nint get_Position(vector<int>& a, int n, int m) {\n\n    /*\n    progame language:cpp\n    description:Write a cpp function to find the position of the last removed element from the given array.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    {\n        int i = 0;\n        for (; i < n; ++i) {\n            a[i] = (a[i] / m + (a[i] % m != 0));\n        }\n    }\n    int result = -1, maxx = -1;\n    for (int i = n - 1; i >= 0; --i) {\n        if (a[i] > maxx) {\n            maxx = a[i];\n            result = i;\n        }\n    }\n    return result;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nint max_sum_increasing_subseq(vector<int> a, int n, int index, int k) {\n\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    for (int i = 0; i < n; ++i) {\n        if (!(a[i] > a[0])) {\n            dp[0][i] = a[i];\n        }\n        else {\n            dp[0][i] = a[i] + a[0];\n        }\n    }\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (a[j] > a[i] && j > i) {\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + a[j]);\n            }\n            else if (j > i) {\n                dp[i][j] = dp[i-1][j];\n            }\n            else {\n                dp[i][j] = a[j];\n            }\n        }\n    }\n    int max_sum = 0;\n    for (int i = index + 1; i < n; ++i) {\n        if (i == k - 1) {\n            max_sum = max(max_sum, dp[index][i]);\n        }\n    }\n    return max_sum;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <vector>\n#include <cassert>\nvoid right_rotate(std::vector<int>& arr, int n, int out_of_place, int cur) {\n    int temp = arr[cur];\n    {\n        int i = cur;\n        while(i > out_of_place){\n        arr[i] = arr[i - 1];\n            --i;\n        }\n    }\n    arr[out_of_place] = temp;\n}\nstd::vector<int> re_arrange(std::vector<int>& arr, int n) {\n\n    int out_of_place = -1;\n    for (int index = 0; index < n; ++index) {\n        if (out_of_place >= 0) {\n            if ((arr[index] >= 0 && arr[out_of_place] < 0) ||\n                (arr[index] < 0 && arr[out_of_place] >= 0)) {\n                right_rotate(arr, n, out_of_place, index);\n                if (index - out_of_place > 2) {\n                    out_of_place = index - 2;\n                }\n            }\n        }\n    }\n    return arr;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <sstream>\n#include <unordered_map>\n#include <cassert>\n#include <vector>\nusing namespace std;\nstring most_occurrences(vector<string> test_list) {\n\n    /*\n    progame language:cpp\n    description:Write a function to get the word with most number of occurrences in the given strings list.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    unordered_map<string, int> temp;\n    for (auto& sub : test_list) {\n        stringstream ss(sub);\n        string wrd;\n        for(;(ss >> wrd);){\n            temp[wrd]++;\n        }\n    }\n    string max_word;\n    int max_count = 0;\n    for (auto& pair : temp) {\n        if (pair.second > max_count) {\n            max_word = pair.first;\n            max_count = pair.second;\n        }\n    }\n    return max_word;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\nint minimum_Length(std::string s) {\n\n    int maxOcc = 0;\n    int n = s.length();\n    std::vector<int> arr(26, 0);\n    {\n        int i = 0;\n        while(i < n){\n        arr[s[i] - 'a']++;\n            i++;\n        }\n    }\n\n    int maxChar = 0;\n    for (int i = 0; i < 26; i++) {\n        if (arr[i] > maxOcc) {\n            maxOcc = arr[i];\n            maxChar = i;\n        }\n    }\n\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (s[i] != 'a' + maxChar) {\n            count++;\n        }\n    }\n\n    return count;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nint first_Element(const std::vector<int>& arr, int n, int k) {\n\n    std::map<int, int> count_map;\n    for (int i = 0; i < n; ++i) {\n        if (!(count_map.find(arr[i]) != count_map.end())) {\n            count_map[arr[i]] = 1;\n        }\n        else {\n            count_map[arr[i]] += 1;\n        }\n\n        for (const auto& pair : count_map) {\n            if (pair.second == k) {\n                return pair.first;\n            }\n        }\n    }\n\n    return -1; // Return -1 if no element occurs k times\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <cassert>\nint median_numbers(int a, int b, int c) {\n\n    /*\n    progame language:cpp\n    description:Write a function to find the median of three specific numbers.\n    you must follow:\n    1. Provide the complete code without any textual explanations and do not generate test scripts.\n    2. Please strictly follow the specified format provided below for the code.\n    3. Do not change the function names.\n    4. The original code content must be fully included in the generated complete code, including all package import sections.\n    5. For C++ language, do not generate the main function; I have my own main function available.\n    6. Do not generate test cases.\n    */\n\n    int median;\n    if (a > b) {\n        if (a < c) {\n            median = a;\n        } else{\n              if (b > c) {\n                median = b;\n            } else {\n                median = c;\n            }\n          }\n    } else {\n        if (b < c) {\n            median = b;\n        } else {\n            median = c;\n        }\n    }\n    return median;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> k_smallest_pairs(vector<int>& nums1, vector<int>& nums2, int k) {\n\n    auto comp = [&](const pair<int, int>& a, const pair<int, int>& b) {\n        if(nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second])\n        {\n            return true;\n        }\n        else{\n            if(nums1[a.first] + nums2[a.second] == nums1[b.first] + nums2[b.second])\n            {\n                return nums1[a.first] > nums1[b.first];\n            }\n            else\n            {\n                return false;\n            }\n        }\n    };\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> pq(comp);\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push({i, j});\n        }\n    }\n\n    vector<vector<int>> result;\n    for (int i = 0; i < k; i++) {\n        auto [idx1, idx2] = pq.top();\n        pq.pop();\n        result.push_back({nums1[idx1], nums2[idx2]});\n    }\n\n    return result;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nint max_product(vector<int> arr, int n) {\n\n    vector<int> mpis(n, 0);\n    {\n        int i = 0;\n        for (; i < n; ++i) {\n            mpis[i] = arr[i];\n        }\n    }\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (arr[i] > arr[j]) {\n                mpis[i] = max(mpis[i], mpis[j] * arr[i]);\n            }\n        }\n    }\n    int max_product = mpis[0];\n    for (int i = 1; i < n; ++i) {\n        max_product = max(max_product, mpis[i]);\n    }\n    return max_product;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nbool is_palindrome(int n) {\n    int divisor = 1;\n    for(;(n / divisor >= 10);){\n        divisor *= 10;\n    }\n    while (n != 0) {\n        int leading = n / divisor;\n        int trailing = n % 10;\n        if (leading != trailing) {\n            return false;\n        }\n        n = (n % divisor) / 10;\n        divisor /= 10;\n    }\n    return true;\n}\nint find_largest_palindromic_number(vector<int>& nums) {\n    int max_palindrome = 0;\n    for (int num : nums) {\n        if (is_palindrome(num)) {\n            max_palindrome = max(max_palindrome, num);\n        }\n    }\n    return max_palindrome;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\ntypedef std::vector<std::pair<double, double>> Polygon;\n\nstd::vector<Polygon> calculate_polygons(double startx, double starty, double endx, double endy, double radius)\n{\n    double sl = (2 * radius) * std::tan(M_PI / 6);\n    double p = sl * 0.5;\n    double b = sl * std::cos(30 * M_PI / 180.0);\n    double w = b * 2;\n    double h = 2 * sl;\n    startx = startx - w;\n    starty = starty - h;\n    endx = endx + w;\n    endy = endy + h;\n    double origx = startx;\n    double origy = starty;\n    double xoffset = b;\n    double yoffset = 3 * p;\n    std::vector<Polygon> polygons;\n    int row = 1;\n    int counter = 0;\n    while (starty < endy)\n    {\n        if (!(row % 2 == 0)) {\n            startx = origx;\n        }\n        else {\n            startx = origx + xoffset;\n        }\n        std::vector<std::pair<double, double>> polygon;\n        for (int i = 0; i < 6; i++)\n        {\n            double angle = i * 60 * M_PI / 180.0;\n            double x = startx + radius * std::cos(angle);\n            double y = starty + radius * std::sin(angle);\n            polygon.push_back(std::make_pair(x, y));\n        }\n        polygons.push_back(polygon);\n        startx += w;\n        counter++;\n        if (counter == 2)\n        {\n            starty += h;\n            counter = 0;\n        }\n        row++;\n    }\n    return polygons;\n}"
      ],
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint ngcd(int x, int y) {\n    int i = 1;\n    int gcd = 1;\n    for(;(i <= x && i <= y);){\n        if(x % i == 0 && y % i == 0) {\n            gcd = i;\n        }\n        i += 1;\n    }\n    return gcd;\n}\n\nint num_comm_div(int x, int y) {\n    int n = ngcd(x, y);\n    int count = 0;\n    for(int i = 1; i <= n; i++) {\n        if(n % i == 0) {\n            count++;\n        }\n    }\n    return count;\n}"
      ]
    ],
    "variance": 0.0,
    "stddev": 0.0
  }
]