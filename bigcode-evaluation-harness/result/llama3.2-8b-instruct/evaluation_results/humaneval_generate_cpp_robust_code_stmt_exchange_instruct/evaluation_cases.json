{
  "0": {
    "task_id": 19,
    "passed": false,
    "result": "failed: compilation error: test.cpp: In function ‘std::string sort_numbers(std::string)’:\ntest.cpp:45:34: error: no matching function for call to ‘std::map<std::__cxx11::basic_string<char>, int>::find(__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type&)’\n   45 |         if (tonum.find(numbers[i]) != tonum.end()) {\n      |                                  ^\nIn file included from /usr/include/c++/9/map:61,\n                 from test.cpp:10:\n/usr/include/c++/9/bits/stl_map.h:1168:7: note: candidate: ‘std::map<_Key, _Tp, _Compare, _Alloc>::iterator std::map<_Key, _Tp, _Compare, _Alloc>::find(const key_type&) [with _Key = std::__cxx11::basic_string<char>; _Tp = int; _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> >; std::map<_Key, _Tp, _Compare, _Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const std::__cxx11::basic_string<char>, int> >; std::map<_Key, _Tp, _Compare, _Alloc>::key_type = std::__cxx11::basic_string<char>]’\n 1168 |       find(const key_type& __x)\n      |       ^~~~\n/usr/include/c++/9/bits/stl_map.h:1168:28: note:   no known conversion for argument 1 from ‘__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type’ {aka ‘char’} to ‘const key_type&’ {aka ‘const std::__cxx11::basic_string<char>&’}\n 1168 |       find(const key_type& __x)\n      |            ~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/9/bits/stl_map.h:1174:2: note: candidate: ‘template<class _Kt> decltype (((std::map<_Key, _Tp, _Compare, _Alloc>*)this)->std::map<_Key, _Tp, _Compare, _Alloc>::_M_t._M_find_tr(__x)) std::map<_Key, _Tp, _Compare, _Alloc>::find(const _Kt&) [with _Kt = _Kt; _Key = std::__cxx11::basic_string<char>; _Tp = int; _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> >]’\n 1174 |  find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))\n      |  ^~~~\n/usr/include/c++/9/bits/stl_map.h:1174:2: note:   template argument deduction/substitution failed:\n/usr/include/c++/9/bits/stl_map.h: In substitution of ‘template<class _Kt> decltype (((std::map<std::__cxx11::basic_string<char>, int>*)this)->std::map<std::__cxx11::basic_string<char>, int>::_M_t.std::_Rb_tree<std::__cxx11::basic_string<char>, std::pair<const std::__cxx11::basic_string<char>, int>, std::_Select1st<std::pair<const std::__cxx11::basic_string<char>, int> >, std::less<std::__cxx11::basic_string<char> >, std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> > >::_M_find_tr(__x)) std::map<std::__cxx11::basic_string<char>, int>::find<_Kt>(const _Kt&) [with _Kt = char]’:\ntest.cpp:45:34:   required from here\n/usr/include/c++/9/bits/stl_map.h:1174:2: error: no matching function for call to ‘std::_Rb_tree<std::__cxx11::basic_string<char>, std::pair<const std::__cxx11::basic_string<char>, int>, std::_Select1st<std::pair<const std::__cxx11::basic_string<char>, int> >, std::less<std::__cxx11::basic_string<char> >, std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> > >::_M_find_tr(const char&)’\nIn file included from /usr/include/c++/9/set:60,\n                 from test.cpp:9:\n/usr/include/c++/9/bits/stl_tree.h:1306:2: note: candidate: ‘template<class _Kt, class _Req> std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_find_tr(const _Kt&) [with _Kt = _Kt; _Req = _Req; _Key = std::__cxx11::basic_string<char>; _Val = std::pair<const std::__cxx11::basic_string<char>, int>; _KeyOfValue = std::_Select1st<std::pair<const std::__cxx11::basic_string<char>, int> >; _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> >]’\n 1306 |  _M_find_tr(const _Kt& __k)\n      |  ^~~~~~~~~~\n/usr/include/c++/9/bits/stl_tree.h:1306:2: note:   template argument deduction/substitution failed:\n/usr/include/c++/9/bits/stl_tree.h: In substitution of ‘template<class _Cmp, class _SfinaeType> using __has_is_transparent_t = typename std::__has_is_transparent<_Cmp, _SfinaeType>::type [with _Cmp = std::less<std::__cxx11::basic_string<char> >; _SfinaeType = char]’:\n/usr/include/c++/9/bits/stl_tree.h:1304:9:   required by substitution of ‘template<class _Kt> decltype (((std::map<std::__cxx11::basic_string<char>, int>*)this)->std::map<std::__cxx11::basic_string<char>, int>::_M_t.std::_Rb_tree<std::__cxx11::basic_string<char>, std::pair<const std::__cxx11::basic_string<char>, int>, std::_Select1st<std::pair<const std::__cxx11::basic_string<char>, int> >, std::less<std::__cxx11::basic_string<char> >, std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> > >::_M_find_tr(__x)) std::map<std::__cxx11::basic_string<char>, int>::find<_Kt>(const _Kt&) [with _Kt = char]’\ntest.cpp:45:34:   required from here\n/usr/include/c++/9/bits/stl_tree.h:425:11: error: no type named ‘type’ in ‘struct std::__has_is_transparent<std::less<std::__cxx11::basic_string<char> >, char, void>’\n  425 |     using __has_is_transparent_t\n      |           ^~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/stl_map.h: In substitution of ‘template<class _Kt> decltype (((std::map<std::__cxx11::basic_string<char>, int>*)this)->std::map<std::__cxx11::basic_string<char>, int>::_M_t.std::_Rb_tree<std::__cxx11::basic_string<char>, std::pair<const std::__cxx11::basic_string<char>, int>, std::_Select1st<std::pair<const std::__cxx11::basic_string<char>, int> >, std::less<std::__cxx11::basic_string<char> >, std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> > >::_M_find_tr(__x)) std::map<std::__cxx11::basic_string<char>, int>::find<_Kt>(const _Kt&) [with _Kt = char]’:\ntest.cpp:45:34:   required from here\n/usr/include/c++/9/bits/stl_tree.h:1315:2: note: candidate: ‘template<class _Kt, class _Req> std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_find_tr(const _Kt&) const [with _Kt = _Kt; _Req = _Req; _Key = std::__cxx11::basic_string<char>; _Val = std::pair<const std::__cxx11::basic_string<char>, int>; _KeyOfValue = std::_Select1st<std::pair<const std::__cxx11::basic_string<char>, int> >; _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> >]’\n 1315 |  _M_find_tr(const _Kt& __k) const\n      |  ^~~~~~~~~~\n/usr/include/c++/9/bits/stl_tree.h:1315:2: note:   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/map:61,\n                 from test.cpp:10:\n/usr/include/c++/9/bits/stl_map.h:1193:7: note: candidate: ‘std::map<_Key, _Tp, _Compare, _Alloc>::const_iterator std::map<_Key, _Tp, _Compare, _Alloc>::find(const key_type&) const [with _Key = std::__cxx11::basic_string<char>; _Tp = int; _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> >; std::map<_Key, _Tp, _Compare, _Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const std::__cxx11::basic_string<char>, int> >; std::map<_Key, _Tp, _Compare, _Alloc>::key_type = std::__cxx11::basic_string<char>]’\n 1193 |       find(const key_type& __x) const\n      |       ^~~~\n/usr/include/c++/9/bits/stl_map.h:1193:28: note:   no known conversion for argument 1 from ‘__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type’ {aka ‘char’} to ‘const key_type&’ {aka ‘const std::__cxx11::basic_string<char>&’}\n 1193 |       find(const key_type& __x) const\n      |            ~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/9/bits/stl_map.h:1199:2: note: candidate: ‘template<class _Kt> decltype (((const std::map<_Key, _Tp, _Compare, _Alloc>*)this)->std::map<_Key, _Tp, _Compare, _Alloc>::_M_t._M_find_tr(__x)) std::map<_Key, _Tp, _Compare, _Alloc>::find(const _Kt&) const [with _Kt = _Kt; _Key = std::__cxx11::basic_string<char>; _Tp = int; _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> >]’\n 1199 |  find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))\n      |  ^~~~\n/usr/include/c++/9/bits/stl_map.h:1199:2: note:   template argument deduction/substitution failed:\n/usr/include/c++/9/bits/stl_map.h: In substitution of ‘template<class _Kt> decltype (((const std::map<std::__cxx11::basic_string<char>, int>*)this)->std::map<std::__cxx11::basic_string<char>, int>::_M_t.std::_Rb_tree<std::__cxx11::basic_string<char>, std::pair<const std::__cxx11::basic_string<char>, int>, std::_Select1st<std::pair<const std::__cxx11::basic_string<char>, int> >, std::less<std::__cxx11::basic_string<char> >, std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> > >::_M_find_tr(__x)) std::map<std::__cxx11::basic_string<char>, int>::find<_Kt>(const _Kt&) const [with _Kt = char]’:\ntest.cpp:45:34:   required from here\n/usr/include/c++/9/bits/stl_map.h:1199:2: error: no matching function for call to ‘std::_Rb_tree<std::__cxx11::basic_string<char>, std::pair<const std::__cxx11::basic_string<char>, int>, std::_Select1st<std::pair<const std::__cxx11::basic_string<char>, int> >, std::less<std::__cxx11::basic_string<char> >, std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> > >::_M_find_tr(const char&) const’\nIn file included from /usr/include/c++/9/set:60,\n                 from test.cpp:9:\n/usr/include/c++/9/bits/stl_tree.h:1306:2: note: candidate: ‘template<class _Kt, class _Req> std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_find_tr(const _Kt&) [with _Kt = _Kt; _Req = _Req; _Key = std::__cxx11::basic_string<char>; _Val = std::pair<const std::__cxx11::basic_string<char>, int>; _KeyOfValue = std::_Select1st<std::pair<const std::__cxx11::basic_string<char>, int> >; _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> >]’\n 1306 |  _M_find_tr(const _Kt& __k)\n      |  ^~~~~~~~~~\n/usr/include/c++/9/bits/stl_tree.h:1306:2: note:   template argument deduction/substitution failed:\n/usr/include/c++/9/bits/stl_tree.h:1315:2: note: candidate: ‘template<class _Kt, class _Req> std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_find_tr(const _Kt&) const [with _Kt = _Kt; _Req = _Req; _Key = std::__cxx11::basic_string<char>; _Val = std::pair<const std::__cxx11::basic_string<char>, int>; _KeyOfValue = std::_Select1st<std::pair<const std::__cxx11::basic_string<char>, int> >; _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> >]’\n 1315 |  _M_find_tr(const _Kt& __k) const\n      |  ^~~~~~~~~~\n/usr/include/c++/9/bits/stl_tree.h:1315:2: note:   template argument deduction/substitution failed:\ntest.cpp: In lambda function:\ntest.cpp:54:16: error: ‘tonum’ is not captured\n   54 |         return tonum[a] < tonum[b];\n      |                ^~~~~\ntest.cpp:53:35: note: the lambda has no capture-default\n   53 |     sort(out.begin(), out.end(), [](const string& a, const string& b) {\n      |                                   ^\ntest.cpp:30:22: note: ‘std::map<std::__cxx11::basic_string<char>, int> tonum’ declared here\n   30 |     map<string, int> tonum = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n      |                      ^~~~~\ntest.cpp:54:27: error: ‘tonum’ is not captured\n   54 |         return tonum[a] < tonum[b];\n      |                           ^~~~~\ntest.cpp:53:35: note: the lambda has no capture-default\n   53 |     sort(out.begin(), out.end(), [](const string& a, const string& b) {\n      |                                   ^\ntest.cpp:30:22: note: ‘std::map<std::__cxx11::basic_string<char>, int> tonum’ declared here\n   30 |     map<string, int> tonum = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n      |                      ^~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/algorithm:61,\n                 from test.cpp:3:\n/usr/include/c++/9/bits/predefined_ops.h: In instantiation of ‘constexpr bool __gnu_cxx::__ops::_Iter_comp_iter<_Compare>::operator()(_Iterator1, _Iterator2) [with _Iterator1 = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Iterator2 = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Compare = sort_numbers(std::string)::<lambda(const string&, const string&)>]’:\n/usr/include/c++/9/bits/stl_algo.h:81:17:   required from ‘void std::__move_median_to_first(_Iterator, _Iterator, _Iterator, _Iterator, _Compare) [with _Iterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Compare = __gnu_cxx::__ops::_Iter_comp_iter<sort_numbers(std::string)::<lambda(const string&, const string&)> >]’\n/usr/include/c++/9/bits/stl_algo.h:1920:34:   required from ‘_RandomAccessIterator std::__unguarded_partition_pivot(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Compare = __gnu_cxx::__ops::_Iter_comp_iter<sort_numbers(std::string)::<lambda(const string&, const string&)> >]’\n/usr/include/c++/9/bits/stl_algo.h:1952:38:   required from ‘void std::__introsort_loop(_RandomAccessIterator, _RandomAccessIterator, _Size, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Size = long int; _Compare = __gnu_cxx::__ops::_Iter_comp_iter<sort_numbers(std::string)::<lambda(const string&, const string&)> >]’\n/usr/include/c++/9/bits/stl_algo.h:1967:25:   required from ‘void std::__sort(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Compare = __gnu_cxx::__ops::_Iter_comp_iter<sort_numbers(std::string)::<lambda(const string&, const string&)> >]’\n/usr/include/c++/9/bits/stl_algo.h:4899:18:   required from ‘void std::sort(_RAIter, _RAIter, _Compare) [with _RAIter = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Compare = sort_numbers(std::string)::<lambda(const string&, const string&)>]’\ntest.cpp:55:6:   required from here\n/usr/include/c++/9/bits/predefined_ops.h:143:18: error: no match for call to ‘(sort_numbers(std::string)::<lambda(const string&, const string&)>) (char&, char&)’\n  143 |         { return bool(_M_comp(*__it1, *__it2)); }\n      |                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/predefined_ops.h:143:18: note: candidate: ‘void (*)(const string&, const string&)’ {aka ‘void (*)(const std::__cxx11::basic_string<char>&, const std::__cxx11::basic_string<char>&)’} <conversion>\n/usr/include/c++/9/bits/predefined_ops.h:143:18: note:   candidate expects 3 arguments, 3 provided\ntest.cpp:53:34: note: candidate: ‘sort_numbers(std::string)::<lambda(const string&, const string&)>’\n   53 |     sort(out.begin(), out.end(), [](const string& a, const string& b) {\n      |                                  ^\ntest.cpp:53:34: note:   no known conversion for argument 1 from ‘char’ to ‘const string&’ {aka ‘const std::__cxx11::basic_string<char>&’}\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/algorithm:61,\n                 from test.cpp:3:\n/usr/include/c++/9/bits/predefined_ops.h: In instantiation of ‘bool __gnu_cxx::__ops::_Val_comp_iter<_Compare>::operator()(_Value&, _Iterator) [with _Value = char; _Iterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Compare = sort_numbers(std::string)::<lambda(const string&, const string&)>]’:\n/usr/include/c++/9/bits/stl_algo.h:1827:20:   required from ‘void std::__unguarded_linear_insert(_RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Compare = __gnu_cxx::__ops::_Val_comp_iter<sort_numbers(std::string)::<lambda(const string&, const string&)> >]’\n/usr/include/c++/9/bits/stl_algo.h:1854:36:   required from ‘void std::__insertion_sort(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Compare = __gnu_cxx::__ops::_Iter_comp_iter<sort_numbers(std::string)::<lambda(const string&, const string&)> >]’\n/usr/include/c++/9/bits/stl_algo.h:1884:25:   required from ‘void std::__final_insertion_sort(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Compare = __gnu_cxx::__ops::_Iter_comp_iter<sort_numbers(std::string)::<lambda(const string&, const string&)> >]’\n/usr/include/c++/9/bits/stl_algo.h:1970:31:   required from ‘void std::__sort(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Compare = __gnu_cxx::__ops::_Iter_comp_iter<sort_numbers(std::string)::<lambda(const string&, const string&)> >]’\n/usr/include/c++/9/bits/stl_algo.h:4899:18:   required from ‘void std::sort(_RAIter, _RAIter, _Compare) [with _RAIter = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Compare = sort_numbers(std::string)::<lambda(const string&, const string&)>]’\ntest.cpp:55:6:   required from here\n/usr/include/c++/9/bits/predefined_ops.h:215:11: error: no match for call to ‘(sort_numbers(std::string)::<lambda(const string&, const string&)>) (char&, char&)’\n  215 |  { return bool(_M_comp(__val, *__it)); }\n      |           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/predefined_ops.h:215:11: note: candidate: ‘void (*)(const string&, const string&)’ {aka ‘void (*)(const std::__cxx11::basic_string<char>&, const std::__cxx11::basic_string<char>&)’} <conversion>\n/usr/include/c++/9/bits/predefined_ops.h:215:11: note:   candidate expects 3 arguments, 3 provided\ntest.cpp:53:34: note: candidate: ‘sort_numbers(std::string)::<lambda(const string&, const string&)>’\n   53 |     sort(out.begin(), out.end(), [](const string& a, const string& b) {\n      |                                  ^\ntest.cpp:53:34: note:   no known conversion for argument 1 from ‘char’ to ‘const string&’ {aka ‘const std::__cxx11::basic_string<char>&’}\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/algorithm:61,\n                 from test.cpp:3:\n/usr/include/c++/9/bits/predefined_ops.h: In instantiation of ‘bool __gnu_cxx::__ops::_Iter_comp_val<_Compare>::operator()(_Iterator, _Value&) [with _Iterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Value = char; _Compare = sort_numbers(std::string)::<lambda(const string&, const string&)>]’:\n/usr/include/c++/9/bits/stl_heap.h:133:48:   required from ‘void std::__push_heap(_RandomAccessIterator, _Distance, _Distance, _Tp, _Compare&) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Distance = long int; _Tp = char; _Compare = __gnu_cxx::__ops::_Iter_comp_val<sort_numbers(std::string)::<lambda(const string&, const string&)> >]’\n/usr/include/c++/9/bits/stl_heap.h:237:23:   required from ‘void std::__adjust_heap(_RandomAccessIterator, _Distance, _Distance, _Tp, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Distance = long int; _Tp = char; _Compare = __gnu_cxx::__ops::_Iter_comp_iter<sort_numbers(std::string)::<lambda(const string&, const string&)> >]’\n/usr/include/c++/9/bits/stl_heap.h:342:22:   required from ‘void std::__make_heap(_RandomAccessIterator, _RandomAccessIterator, _Compare&) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Compare = __gnu_cxx::__ops::_Iter_comp_iter<sort_numbers(std::string)::<lambda(const string&, const string&)> >]’\n/usr/include/c++/9/bits/stl_algo.h:1671:23:   required from ‘void std::__heap_select(_RandomAccessIterator, _RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Compare = __gnu_cxx::__ops::_Iter_comp_iter<sort_numbers(std::string)::<lambda(const string&, const string&)> >]’\n/usr/include/c++/9/bits/stl_algo.h:1932:25:   required from ‘void std::__partial_sort(_RandomAccessIterator, _RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Compare = __gnu_cxx::__ops::_Iter_comp_iter<sort_numbers(std::string)::<lambda(const string&, const string&)> >]’\n/usr/include/c++/9/bits/stl_algo.h:1947:27:   required from ‘void std::__introsort_loop(_RandomAccessIterator, _RandomAccessIterator, _Size, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Size = long int; _Compare = __gnu_cxx::__ops::_Iter_comp_iter<sort_numbers(std::string)::<lambda(const string&, const string&)> >]’\n/usr/include/c++/9/bits/stl_algo.h:1967:25:   required from ‘void std::__sort(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Compare = __gnu_cxx::__ops::_Iter_comp_iter<sort_numbers(std::string)::<lambda(const string&, const string&)> >]’\n/usr/include/c++/9/bits/stl_algo.h:4899:18:   required from ‘void std::sort(_RAIter, _RAIter, _Compare) [with _RAIter = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Compare = sort_numbers(std::string)::<lambda(const string&, const string&)>]’\ntest.cpp:55:6:   required from here\n/usr/include/c++/9/bits/predefined_ops.h:177:11: error: no match for call to ‘(sort_numbers(std::string)::<lambda(const string&, const string&)>) (char&, char&)’\n  177 |  { return bool(_M_comp(*__it, __val)); }\n      |           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/predefined_ops.h:177:11: note: candidate: ‘void (*)(const string&, const string&)’ {aka ‘void (*)(const std::__cxx11::basic_string<char>&, const std::__cxx11::basic_string<char>&)’} <conversion>\n/usr/include/c++/9/bits/predefined_ops.h:177:11: note:   candidate expects 3 arguments, 3 provided\ntest.cpp:53:34: note: candidate: ‘sort_numbers(std::string)::<lambda(const string&, const string&)>’\n   53 |     sort(out.begin(), out.end(), [](const string& a, const string& b) {\n      |                                  ^\ntest.cpp:53:34: note:   no known conversion for argument 1 from ‘char’ to ‘const string&’ {aka ‘const std::__cxx11::basic_string<char>&’}\n",
    "completion_id": 0,
    "perturbation_type": "for2while",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n\n#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    map<string, int> tonum = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n    map<int, string> numto = {{0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, {4, \"four\"}, {5, \"five\"}, {6, \"six\"}, {7, \"seven\"}, {8, \"eight\"}, {9, \"nine\"}};\n    int count[10];\n    {\n        int i = 0;\n        while (i < 10) {\n            count[i] = 0;\n            i++;\n        }\n    }\n\n    string out = \"\", current = \"\";\n    if (numbers.length() > 0) numbers = numbers + \" \";\n\n    for (int i = 0; i < 10; i++) {\n        if (tonum.find(numbers[i]) != tonum.end()) {\n            count[i]++;\n            out += numto[i];\n        } else {\n            out += numbers[i];\n        }\n    }\n\n    sort(out.begin(), out.end(), [](const string& a, const string& b) {\n        return tonum[a] < tonum[b];\n    });\n\n    return out;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sort_numbers(\"\") == \"\");\n    assert (sort_numbers(\"three\") == \"three\");\n    assert (sort_numbers(\"three five nine\") == \"three five nine\");\n     assert (sort_numbers(\"five zero four seven nine eight\") == \"zero four five seven eight nine\");\n      assert (sort_numbers(\"six five four three two one zero\") == \"zero one two three four five six\");\n}\n"
      ]
    ]
  },
  "1": {
    "task_id": 24,
    "passed": false,
    "result": "failed: a.out: test.cpp:38: int main(): Assertion `largest_divisor(3) == 1' failed.\n",
    "completion_id": 0,
    "perturbation_type": "for2while",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    {\n        int i = 2;\n        while (i * i <= n) {\n            if (n % i == 0) {\n                return n / i;\n            }\n            i++;\n        }\n    }\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (largest_divisor(3) == 1);\n    assert (largest_divisor(7) == 1);\n    assert (largest_divisor(10) == 5);\n    assert (largest_divisor(100) == 50);\n    assert (largest_divisor(49) == 7);\n}\n"
      ]
    ]
  },
  "2": {
    "task_id": 32,
    "passed": false,
    "result": "failed: compilation error: test.cpp: In function ‘double find_zero(std::vector<double>)’:\ntest.cpp:59:23: error: ‘x’ was not declared in this scope\n   59 |             driv+=pow(x, i)*xs[i];\n      |                       ^\nIn file included from test.cpp:70:\ntest.cpp: In function ‘int main()’:\ntest.cpp:87:31: error: could not convert ‘poly(std::vector<double>(coeffs), solution)’ from ‘double’ to ‘std::vector<double>’\n   87 |         assert (find_zero(poly(coeffs, solution))< 1e-3);\n      |                           ~~~~^~~~~~~~~~~~~~~~~~\n      |                               |\n      |                               double\n",
    "completion_id": 0,
    "perturbation_type": "for_var_outer",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x){\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \n    */\n    double sum=0;\n    int i;\n    {\n        i=0;\n        for (;i<xs.size();i++)\n        {\n            sum+=xs[i]*pow(x,i);\n        }\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs){\n    /*\n    xs are coefficients of a polynomial. find_zero find x such that poly(x) = 0. find_zero returns only only zero point, even if there are many. \n    Moreover, find_zero only takes list xs having even number of coefficients and largest non zero coefficient as it guarantees a solution.\n    >>> round(find_zero([1, 2]), 2) #f(x) = 1 + 2x \n    -0.5 \n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 \n    1.0\n    */\n    double ans=0;\n    double value;\n    value=poly(xs,ans);\n    while (abs(value)>1e-6)\n    {\n        double driv=0;\n        for (int i=0; i<xs.size(); i++)\n        {\n            driv+=pow(x, i)*xs[i];\n        }\n        if (driv==0)\n        {\n            return ans;\n        }\n        ans=ans+driv;\n    }\n    return ans;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n   \n    double solution;\n    int ncoeff;\n    for (int i=0;i<100;i++)\n    {\n        ncoeff = 2 * (1+rand()%4);\n        vector<double> coeffs = {};\n        for (int j=0;j<ncoeff;j++)\n        {\n            double coeff = -10+rand()%21;\n            if (coeff == 0) coeff = 1;\n            coeffs.push_back(coeff);\n        }\n        \n        solution = find_zero(coeffs);\n        assert (find_zero(poly(coeffs, solution))< 1e-3);\n    }\n}\n"
      ]
    ]
  },
  "3": {
    "task_id": 33,
    "passed": false,
    "result": "failed: a.out: test.cpp:52: int main(): Assertion `sort_third(sort_third({5, 6, 3, 4, 8, 9, 2}) , {2, 6, 3, 4, 8, 9, 5})' failed.\n",
    "completion_id": 0,
    "perturbation_type": "for2while",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> third = {};\n    int i;\n\n    i = 0;\n    while (i * 3 < l.size()) {\n        third.push_back(l[i * 3]);\n        i++;\n    }\n\n    sort(third.begin(), third.end());\n    return third;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool sort_third(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (sort_third(sort_third({1, 2, 3}) , sort_third({1, 2, 3})));\n    assert (sort_third(sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}) , sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})));\n    assert (sort_third(sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}) , sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10})));\n    assert (sort_third(sort_third({5, 6, 3, 4, 8, 9, 2}) , {2, 6, 3, 4, 8, 9, 5}));\n    assert (sort_third(sort_third({5, 8, 3, 4, 6, 9, 2}) , {2, 8, 3, 4, 6, 9, 5}));\n    assert (sort_third(sort_third({5, 6, 9, 4, 8, 3, 2}) , {2, 6, 9, 4, 8, 3, 5}));\n    assert (sort_third(sort_third({5, 6, 3, 4, 8, 9, 2, 1}) , {2, 6, 3, 4, 8, 9, 5, 1}));\n}\n"
      ]
    ]
  },
  "4": {
    "task_id": 35,
    "passed": false,
    "result": "failed: compilation error: test.cpp: In function ‘float max_element(std::vector<float>)’:\ntest.cpp:29:9: error: ‘i’ was not declared in this scope\n   29 |   for (;i<l.size();i++)\n      |         ^\n",
    "completion_id": 0,
    "perturbation_type": "for_var_outer",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\nfloat max_element(vector<float> l){\n  float max=-10000;\n  for (;i<l.size();i++)\n    if (max<l[i]) max=l[i];\n  return max;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(max_element({1, 2, 3})- 3)<1e-4);\n    assert (abs(max_element({5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10})- 124)<1e-4);\n}\n"
      ]
    ]
  },
  "5": {
    "task_id": 37,
    "passed": false,
    "result": "failed: compilation error: test.cpp: In function ‘bool issame(std::vector<float>, std::vector<float>)’:\ntest.cpp:56:27: error: could not convert ‘(a.std::vector<float>::operator[](((std::vector<float>::size_type)i)) - b.std::vector<float>::operator[](((std::vector<float>::size_type)i)))’ from ‘__gnu_cxx::__alloc_traits<std::allocator<float>, float>::value_type’ {aka ‘float’} to ‘std::vector<float>’\n   56 |         if (sort_even(a[i]-b[i])>1e-4) return false;\n",
    "completion_id": 0,
    "perturbation_type": "for_var_outer",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> out = {};\n    vector<float> even = {};\n\n    {\n        int i = 0;\n        for (; i * 2 < l.size(); i++) {\n            even.push_back(l[i * 2]);\n        }\n    }\n\n    sort(even.begin(), even.end());\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            out.push_back(even[i / 2]);\n        } else {\n            out.push_back(l[i]);\n        }\n    }\n\n    return out;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (sort_even(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_even({1, 2, 3}), {1, 2, 3}));\n    assert (issame(sort_even({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}) , {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123}));\n    assert (issame(sort_even({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}) , {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10}));\n}\n"
      ]
    ]
  },
  "6": {
    "task_id": 38,
    "passed": false,
    "result": "failed: a.out: test.cpp:76: int main(): Assertion `decode_cyclic(encoded_str) == str' failed.\n",
    "completion_id": 0,
    "perturbation_type": "for_var_outer",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <string>\n\nusing namespace std;\n\nstring encode_cyclic(string s) {\n    // returns encoded string by cycling groups of three characters. \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    {\n        i = 0;\n        for (; i * 3 < l; i++)\n        {\n            // cycle elements in each group. Unless group has fewer elements than 3.\n            x = s.substr(i * 3, 3);\n            if (x.length() == 3) x = x.substr(1) + x[0];\n            output = output + x;\n        }\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) {\n    // takes as input string encoded with encode_cyclic function. Returns decoded string. \n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++)\n    {\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output = output + x;\n    }\n    return output;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    \n    for (int i=0;i<100;i++)\n    {\n        int l=10+rand()%11;\n        string str=\"\";\n        for (int j=0;j<l;j++)\n        {\n            char chr=97+rand()%26;\n            str+=chr;\n        }\n\n        string encoded_str = encode_cyclic(str);\n        assert (decode_cyclic(encoded_str) == str);\n    }\n}\n"
      ]
    ]
  },
  "7": {
    "task_id": 42,
    "passed": true,
    "result": "passed",
    "completion_id": 0,
    "perturbation_type": "for2while",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l){\n    for(int i = 0; i < l.size(); i++){\n        l[i] += 1;\n    }\n    return l;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(incr_list({}) , {}));\n    assert (issame(incr_list({3, 2, 1}) , {4, 3, 2}));\n    assert (issame(incr_list({5, 2, 5, 2, 3, 3, 9, 0, 123}) , {6, 3, 6, 3, 4, 4, 10, 1, 124}));\n}\n"
      ]
    ]
  },
  "8": {
    "task_id": 50,
    "passed": false,
    "result": "failed: a.out: test.cpp:66: int main(): Assertion `decode_shift(encoded_str) == str' failed.\n",
    "completion_id": 0,
    "perturbation_type": "for_var_outer",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    {\n        i = 0;\n        for (; i < s.length(); i++)\n        {\n            int w = ((int) s[i] + 5 - (int) 'a') % 26 + (int) 'a';\n            out += (char) w;\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++)\n    {\n        int w = ((int) s[i] - (int) 'a') % 26 + (int) 'a';\n        out += (char) w;\n    }\n    return out;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    \n    for (int i=0;i<100;i++)\n    {\n        int l=10+rand()%11;\n        string str=\"\";\n        for (int j=0;j<l;j++)\n        {\n            char chr=97+rand()%26;\n            str+=chr;\n        }\n\n        string encoded_str = encode_shift(str);\n        assert (decode_shift(encoded_str) == str);\n    }\n}\n"
      ]
    ]
  },
  "9": {
    "task_id": 52,
    "passed": false,
    "result": "failed: compilation error: test.cpp: In function ‘bool below_threshold(std::vector<int>, int)’:\ntest.cpp:28:12: error: ‘i’ was not declared in this scope\n   28 |     for (; i < l.size(); i++)\n      |            ^\n",
    "completion_id": 0,
    "perturbation_type": "for_var_outer",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (; i < l.size(); i++)\n        if (l[i] >= t)\n            return false;\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_threshold({1, 2, 4, 10}, 100));\n    assert (not(below_threshold({1, 20, 4, 10}, 5)));\n    assert (below_threshold({1, 20, 4, 10}, 21));\n    assert (below_threshold({1, 20, 4, 10}, 22));\n    assert (below_threshold({1, 8, 4, 10}, 11));\n    assert (not(below_threshold({1, 8, 4, 10}, 10)));\n}\n"
      ]
    ]
  },
  "10": {
    "task_id": 54,
    "passed": false,
    "result": "failed: a.out: test.cpp:46: int main(): Assertion `same_chars(\"abcd\", \"dddddddabcf\") == false' failed.\n",
    "completion_id": 0,
    "perturbation_type": "for2while",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    {\n        int i = 0;\n        while (i < s0.length()) {\n            if (find(s1.begin(), s1.end(), s0[i]) == s1.end()) {\n                return false;\n            }\n            i++;\n        }\n    }\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert (same_chars(\"abcd\", \"dddddddabc\") == true);\n    assert (same_chars(\"dddddddabc\", \"abcd\") == true);\n    assert (same_chars(\"eabcd\", \"dddddddabc\") == false);\n    assert (same_chars(\"abcd\", \"dddddddabcf\") == false);\n    assert (same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert (same_chars(\"aabb\", \"aaccc\") == false);\n}\n"
      ]
    ]
  },
  "11": {
    "task_id": 59,
    "passed": true,
    "result": "passed",
    "completion_id": 0,
    "perturbation_type": "for2while",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nvector<int> prime_factors(int n) {\n    vector<int> factors;\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            factors.push_back(i);\n            while (n % i == 0) {\n                n /= i;\n            }\n        }\n        i++;\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n\nint largest_prime_factor(int n) {\n    vector<int> factors = prime_factors(n);\n    int max_factor = 0;\n    for (int factor : factors) {\n        if (factor > max_factor) {\n            max_factor = factor;\n        }\n    }\n    return max_factor;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (largest_prime_factor(15) == 5);\n    assert (largest_prime_factor(27) == 3);\n    assert (largest_prime_factor(63) == 7);\n    assert (largest_prime_factor(330) == 11);\n    assert (largest_prime_factor(13195) == 29);\n}\n"
      ]
    ]
  },
  "12": {
    "task_id": 74,
    "passed": false,
    "result": "failed: compilation error: test.cpp:53:6: error: ambiguating new declaration of ‘bool total_match(std::vector<std::__cxx11::basic_string<char> >, std::vector<std::__cxx11::basic_string<char> >)’\n   53 | bool total_match(vector<string> a,vector<string>b){\n      |      ^~~~~~~~~~~\ntest.cpp:24:16: note: old declaration ‘std::vector<std::__cxx11::basic_string<char> > total_match(std::vector<std::__cxx11::basic_string<char> >, std::vector<std::__cxx11::basic_string<char> >)’\n   24 | vector<string> total_match(vector<string> lst1, vector<string> lst2) {\n      |                ^~~~~~~~~~~\nIn file included from test.cpp:52:\ntest.cpp: In function ‘int main()’:\ntest.cpp:62:5: error: invalid static_cast from type ‘std::vector<std::__cxx11::basic_string<char> >’ to type ‘bool’\n   62 |     assert (total_match(total_match({}, {}) , {}));\n      |     ^~~~~~\ntest.cpp:63:5: error: invalid static_cast from type ‘std::vector<std::__cxx11::basic_string<char> >’ to type ‘bool’\n   63 |     assert (total_match(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\"}) , {\"hi\", \"hi\"}));\n      |     ^~~~~~\ntest.cpp:64:5: error: invalid static_cast from type ‘std::vector<std::__cxx11::basic_string<char> >’ to type ‘bool’\n   64 |     assert (total_match(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) , {\"hi\", \"admin\"}));\n      |     ^~~~~~\ntest.cpp:65:5: error: invalid static_cast from type ‘std::vector<std::__cxx11::basic_string<char> >’ to type ‘bool’\n   65 |     assert (total_match(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) , {\"4\"}));\n      |     ^~~~~~\ntest.cpp:66:5: error: invalid static_cast from type ‘std::vector<std::__cxx11::basic_string<char> >’ to type ‘bool’\n   66 |     assert (total_match(total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) , {\"hI\", \"Hi\"}));\n      |     ^~~~~~\ntest.cpp:67:5: error: invalid static_cast from type ‘std::vector<std::__cxx11::basic_string<char> >’ to type ‘bool’\n   67 |     assert (total_match(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) , {\"hI\", \"hi\", \"hi\"}));\n      |     ^~~~~~\ntest.cpp:68:5: error: invalid static_cast from type ‘std::vector<std::__cxx11::basic_string<char> >’ to type ‘bool’\n   68 |     assert (total_match(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hii\"}) , {\"hi\", \"admin\"}));\n      |     ^~~~~~\ntest.cpp:69:5: error: invalid static_cast from type ‘std::vector<std::__cxx11::basic_string<char> >’ to type ‘bool’\n   69 |     assert (total_match(total_match({}, {\"this\"}) , {}));\n      |     ^~~~~~\ntest.cpp:70:5: error: invalid static_cast from type ‘std::vector<std::__cxx11::basic_string<char> >’ to type ‘bool’\n   70 |     assert (total_match(total_match({\"this\"}, {}) , {}));\n      |     ^~~~~~\n",
    "completion_id": 0,
    "perturbation_type": "for2while",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <vector>\n#include <string>\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int num1 = 0;\n    int num2 = 0;\n    int i = 0;\n\n    while (i < lst1.size()) {\n        num1 += lst1[i].length();\n        i++;\n    }\n\n    int min_len = min(num1, num2);\n\n    vector<string> result;\n    for (int j = 0; j < lst1.size(); j++) {\n        if (lst1[j].length() < min_len) {\n            result.push_back(lst1[j]);\n        }\n    }\n\n    for (int j = 0; j < lst2.size(); j++) {\n        if (lst2[j].length() < min_len) {\n            result.push_back(lst2[j]);\n        }\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool total_match(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (total_match(total_match({}, {}) , {}));\n    assert (total_match(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\"}) , {\"hi\", \"hi\"}));\n    assert (total_match(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) , {\"hi\", \"admin\"}));\n    assert (total_match(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) , {\"4\"}));\n    assert (total_match(total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) , {\"hI\", \"Hi\"}));\n    assert (total_match(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) , {\"hI\", \"hi\", \"hi\"}));\n    assert (total_match(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hii\"}) , {\"hi\", \"admin\"}));\n    assert (total_match(total_match({}, {\"this\"}) , {}));\n    assert (total_match(total_match({\"this\"}, {}) , {}));\n}\n"
      ]
    ]
  },
  "13": {
    "task_id": 77,
    "passed": true,
    "result": "passed",
    "completion_id": 0,
    "perturbation_type": "for_var_outer",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n/*\nWrite a function that takes an integer a and returns true \nif this ingeger is a cube of some integer number.\nNote: you may assume the input is always valid.\nExamples:\niscube(1) ==> true\niscube(2) ==> false\niscube(-1) ==> true\niscube(64) ==> true\niscube(0) ==> true\niscube(180) ==> false\n*/\n#include <math.h>\nusing namespace std;\nbool iscuber(int a) {\n    {\n        int i = 0;\n        for (; i * i * i <= abs(a); i++) {\n            if (i * i * i == abs(a)) return true;\n        }\n    }\n    return false;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (iscuber(1) == true);\n    assert (iscuber(2) == false);\n    assert (iscuber(-1) == true);\n    assert (iscuber(64) == true);\n    assert (iscuber(180) == false);\n    assert (iscuber(1000) == true);\n    assert (iscuber(0) == true);\n    assert (iscuber(1729) == false);\n}\n"
      ]
    ]
  },
  "14": {
    "task_id": 84,
    "passed": false,
    "result": "failed: a.out: test.cpp:44: int main(): Assertion `solve(1000) == \"1\"' failed.\n",
    "completion_id": 0,
    "perturbation_type": "for_var_outer",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <string>\nusing namespace std;\n\nstring solve(int N){\n    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    {\n        int i=0;\n        while(i<str.length()){\n            sum+=str[i]-'0';\n            i++;\n        }\n    }\n    string binary = \"\";\n    for (int j = 0; j < sum; j++) {\n        binary = (binary + \"1\") + (binary == \"\" ? \"0\" : \"\");\n    }\n    return binary;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solve(1000) == \"1\");\n    assert (solve(150) == \"110\");\n    assert (solve(147) == \"1100\");\n    assert (solve(333) == \"1001\");\n    assert (solve(963) == \"10010\");\n}\n"
      ]
    ]
  },
  "15": {
    "task_id": 94,
    "passed": false,
    "result": "failed: a.out: test.cpp:49: int main(): Assertion `skjkasdkd({0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3}) == 10' failed.\n",
    "completion_id": 0,
    "perturbation_type": "for_var_outer",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint skjkasdkd(vector<int> lst){\n    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            {\n                int j=2;\n                while (j*j<=lst[i]) {\n                    if (lst[i]%j==0) {\n                        prime=false;\n                        break;\n                    }\n                    j++;\n                }\n            }\n            if (prime && lst[i]>largest) largest = lst[i];\n        }\n    return largest;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (skjkasdkd({0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3}) == 10);\n    assert (skjkasdkd({1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1}) == 25);\n    assert (skjkasdkd({1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3}) == 13);\n    assert (skjkasdkd({0,724,32,71,99,32,6,0,5,91,83,0,5,6}) == 11);\n    assert (skjkasdkd({0,81,12,3,1,21}) == 3);\n    assert (skjkasdkd({0,8,1,2,1,7}) == 7);\n    assert (skjkasdkd({8191}) == 19);\n    assert (skjkasdkd({8191, 123456, 127, 7}) == 19);\n    assert (skjkasdkd({127, 97, 8192}) == 10);\n}\n"
      ]
    ]
  },
  "16": {
    "task_id": 110,
    "passed": false,
    "result": "failed: a.out: test.cpp:39: int main(): Assertion `exchange({1, 2, 3, 4}, {1, 2, 3, 4}) == \"YES\"' failed.\n",
    "completion_id": 0,
    "perturbation_type": "for_var_outer",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <vector>\n#include <string>\n\nstring exchange(const vector<int>& lst1, const vector<int>& lst2) {\n    int num = 0;\n    {\n        int i = 0;\n        for (; i < lst1.size(); i++)\n        {\n            if (lst1[i] % 2 == 0) num += 1;\n        }\n    }\n    if (num == lst1.size()) return \"YES\";\n    else return \"NO\";\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (exchange({1, 2, 3, 4}, {1, 2, 3, 4}) == \"YES\");\n    assert (exchange({1, 2, 3, 4}, {1, 5, 3, 4}) == \"NO\");\n    assert (exchange({1, 2, 3, 4}, {2, 1, 4, 3}) == \"YES\" );\n    assert (exchange({5, 7, 3}, {2, 6, 4}) == \"YES\");\n    assert (exchange({5, 7, 3}, {2, 6, 3}) == \"NO\" );\n    assert (exchange({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}) == \"NO\");\n    assert (exchange({100, 200}, {200, 200}) == \"YES\");\n}\n"
      ]
    ]
  },
  "17": {
    "task_id": 112,
    "passed": false,
    "result": "failed: compilation error: test.cpp: In function ‘std::vector<std::__cxx11::basic_string<char> > reverse_delete(std::string, std::string)’:\ntest.cpp:37:35: error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n   37 |     return {n, \"true\" == n.length() ? \"True\" : \"False\"};\n      |                                   ^\n",
    "completion_id": 0,
    "perturbation_type": "for2while",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nvector<string> reverse_delete(string s, string c) {\n    string n = \"\";\n    {\n        int i = 0;\n        while (i < s.length()) {\n            if (find(c.begin(), c.end(), s[i]) == c.end()) {\n                n = n + s[i];\n                i++;\n            }\n        }\n    }\n    return {n, \"true\" == n.length() ? \"True\" : \"False\"};\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool reverse_delete(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (reverse_delete(reverse_delete(\"abcde\",\"ae\") , {\"bcd\",\"False\"}));\n    assert (reverse_delete(reverse_delete(\"abcdef\", \"b\") , {\"acdef\",\"False\"}));\n    assert (reverse_delete(reverse_delete(\"abcdedcba\",\"ab\") , {\"cdedc\",\"True\"}));\n    assert (reverse_delete(reverse_delete(\"dwik\",\"w\") , {\"dik\",\"False\"}));\n    assert (reverse_delete(reverse_delete(\"a\",\"a\") , {\"\",\"True\"}));\n    assert (reverse_delete(reverse_delete(\"abcdedcba\",\"\") , {\"abcdedcba\",\"True\"}));\n    assert (reverse_delete(reverse_delete(\"abcdedcba\",\"v\") , {\"abcdedcba\",\"True\"}));\n    assert (reverse_delete(reverse_delete(\"vabba\",\"v\") , {\"abba\",\"True\"}));\n    assert (reverse_delete(reverse_delete(\"mamma\", \"mia\") , {\"\", \"True\"}));\n}\n"
      ]
    ]
  },
  "18": {
    "task_id": 124,
    "passed": false,
    "result": "failed: a.out: test.cpp:54: int main(): Assertion `valid_date(\"03-11-2000\") == true' failed.\n",
    "completion_id": 0,
    "perturbation_type": "for2while",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    int mm, dd, yy;\n    if (date.length() != 10) return false;\n\n    // Check if date is in the correct format\n    if (date[3] != '-' || date[7] != '-') return false;\n\n    // Check if date is in the correct format\n    if (date[2] == '0' || date[5] == '0') return false;\n\n    // Check if the month is between 1 and 12\n    if (date[0] != '0' && (date[1] > 9 || (date[1] == '0' && date[2] != '0'))) return false;\n\n    // Check if the day is between 1 and 31 for months 1,3,5,7,8,10,12\n    if (date[1] == '0' || date[2] == '0' || (date[1] == '2' && date[2] == '0') || (date[1] == '4' && date[2] == '0') || (date[1] == '6' && date[2] == '0') || (date[1] == '8' && date[2] == '0') || (date[1] == '10' && date[2] == '0') || (date[1] == '12' && date[2] == '0')) return false;\n\n    // Check if the day is between 1 and 30 for months 4,6,9,11\n    if (date[1] == '4' || date[1] == '6' || date[1] == '9' || date[1] == '11') return false;\n\n    // Check if the day is between 1 and 29 for the month 2\n    if (date[1] == '2' && (date[2] == '0' || date[2] == '1')) return false;\n\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (valid_date(\"03-11-2000\") == true);\n    assert (valid_date(\"15-01-2012\") == false);\n    assert (valid_date(\"04-0-2040\") == false);\n    assert (valid_date(\"06-04-2020\") == true);\n    assert (valid_date(\"01-01-2007\") == true);\n    assert (valid_date(\"03-32-2011\") == false);\n    assert (valid_date(\"\") == false);\n    assert (valid_date(\"04-31-3000\") == false);\n    assert (valid_date(\"06-06-2005\") == true);\n    assert (valid_date(\"21-31-2000\") == false);\n    assert (valid_date(\"04-12-2003\") == true);\n    assert (valid_date(\"04122003\") == false);\n    assert (valid_date(\"20030412\") == false);\n    assert (valid_date(\"2003-04\") == false);\n    assert (valid_date(\"2003-04-12\") == false);\n    assert (valid_date(\"04-2003\") == false);\n}\n"
      ]
    ]
  },
  "19": {
    "task_id": 125,
    "passed": false,
    "result": "failed: compilation error: test.cpp: In function ‘std::vector<std::__cxx11::basic_string<char> > split_words(const string&)’:\ntest.cpp:31:21: error: no match for ‘operator=’ (operand types are ‘const string’ {aka ‘const std::__cxx11::basic_string<char>’} and ‘std::__cxx11::basic_string<char>’)\n   31 |         txt = txt + \" \";\n      |                     ^~~\nIn file included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/stdexcept:39,\n                 from /usr/include/c++/9/array:39,\n                 from /usr/include/c++/9/tuple:39,\n                 from /usr/include/c++/9/functional:54,\n                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n                 from test.cpp:3:\n/usr/include/c++/9/bits/basic_string.h:665:7: note: candidate: ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]’ <near match>\n  665 |       operator=(const basic_string& __str)\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:665:7: note:   passing ‘const string*’ {aka ‘const std::__cxx11::basic_string<char>*’} as ‘this’ argument discards qualifiers\n/usr/include/c++/9/bits/basic_string.h:732:7: note: candidate: ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]’ <near match>\n  732 |       operator=(basic_string&& __str)\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:732:7: note:   passing ‘const string*’ {aka ‘const std::__cxx11::basic_string<char>*’} as ‘this’ argument discards qualifiers\n/usr/include/c++/9/bits/basic_string.h:704:7: note: candidate: ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]’\n  704 |       operator=(const _CharT* __s)\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:704:31: note:   no known conversion for argument 1 from ‘std::__cxx11::basic_string<char>’ to ‘const char*’\n  704 |       operator=(const _CharT* __s)\n      |                 ~~~~~~~~~~~~~~^~~\n/usr/include/c++/9/bits/basic_string.h:715:7: note: candidate: ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(_CharT) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]’\n  715 |       operator=(_CharT __c)\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:715:24: note:   no known conversion for argument 1 from ‘std::__cxx11::basic_string<char>’ to ‘char’\n  715 |       operator=(_CharT __c)\n      |                 ~~~~~~~^~~\n/usr/include/c++/9/bits/basic_string.h:795:7: note: candidate: ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(std::initializer_list<_Tp>) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]’\n  795 |       operator=(initializer_list<_CharT> __l)\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:795:42: note:   no known conversion for argument 1 from ‘std::__cxx11::basic_string<char>’ to ‘std::initializer_list<char>’\n  795 |       operator=(initializer_list<_CharT> __l)\n      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/9/bits/basic_string.h:809:8: note: candidate: ‘template<class _Tp> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_If_sv<_Tp, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(const _Tp&) [with _Tp = _Tp; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]’\n  809 |        operator=(const _Tp& __svt)\n      |        ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:809:8: note:   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/move.h:55,\n                 from /usr/include/c++/9/bits/stl_pair.h:59,\n                 from /usr/include/c++/9/utility:70,\n                 from /usr/include/c++/9/algorithm:60,\n                 from test.cpp:3:\n/usr/include/c++/9/type_traits: In substitution of ‘template<bool _Cond, class _Tp> using enable_if_t = typename std::enable_if::type [with bool _Cond = std::integral_constant<bool, false>::value; _Tp = std::__cxx11::basic_string<char>&]’:\n/usr/include/c++/9/bits/basic_string.h:117:8:   required by substitution of ‘template<class _CharT, class _Traits, class _Alloc> template<class _Tp, class _Res> using _If_sv = std::enable_if_t<std::__and_<std::is_convertible<const _Tp&, std::basic_string_view<_CharT, _Traits> >, std::__not_<std::is_convertible<const _Tp*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>*> >, std::__not_<std::is_convertible<const _Tp&, const _CharT*> > >::value, _Res> [with _Tp = std::__cxx11::basic_string<char>; _Res = std::__cxx11::basic_string<char>&; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]’\n/usr/include/c++/9/bits/basic_string.h:809:8:   required by substitution of ‘template<class _Tp> std::__cxx11::basic_string<char>::_If_sv<_Tp, std::__cxx11::basic_string<char>&> std::__cxx11::basic_string<char>::operator=<_Tp>(const _Tp&) [with _Tp = std::__cxx11::basic_string<char>]’\ntest.cpp:31:21:   required from here\n/usr/include/c++/9/type_traits:2385:11: error: no type named ‘type’ in ‘struct std::enable_if<false, std::__cxx11::basic_string<char>&>’\n 2385 |     using enable_if_t = typename enable_if<_Cond, _Tp>::type;\n      |           ^~~~~~~~~~~\n",
    "completion_id": 0,
    "perturbation_type": "for2while",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nvector<string> split_words(const std::string& txt) {\n    int i;\n    std::string current = \"\";\n    std::vector<std::string> out = {};\n\n    if (txt.find(' ') != std::string::npos) {\n        txt = txt + \" \";\n        i = 0;\n        while (i < txt.length()) {\n            if (txt[i] == ' ') {\n                if (current.length() > 0) {\n                    out.push_back(current);\n                }\n                current = \"\";\n                i++;\n            }\n        }\n    } else {\n        out.push_back(txt);\n    }\n\n    for (const auto& word : out) {\n        int odd_count = 0;\n        for (char c : word) {\n            if (islower(c)) {\n                if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n                    odd_count++;\n                }\n            }\n        }\n        out.push_back(std::to_string(odd_count));\n    }\n\n    return out;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool split_words(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (split_words(split_words(\"Hello world!\") , {\"Hello\",\"world!\"}));\n    assert (split_words(split_words(\"Hello,world!\") , {\"Hello\",\"world!\"}));\n    assert (split_words(split_words(\"Hello world,!\") , {\"Hello\",\"world,!\"}));\n    assert (split_words(split_words(\"Hello,Hello,world !\") , {\"Hello,Hello,world\",\"!\"}));\n    assert (split_words(split_words(\"abcdef\") , {\"3\"}));\n    assert (split_words(split_words(\"aaabb\") , {\"2\"}));\n    assert (split_words(split_words(\"aaaBb\") , {\"1\"}));\n    assert (split_words(split_words(\"\") ,{\"0\"}));\n}\n"
      ]
    ]
  },
  "20": {
    "task_id": 129,
    "passed": false,
    "result": "failed: compilation error: In file included from /usr/include/features.h:461,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/os_defines.h:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/c++config.h:524,\n                 from /usr/include/c++/9/cstdlib:41,\n                 from /usr/include/c++/9/stdlib.h:36,\n                 from test.cpp:2:\n/usr/include/assert.h: In function ‘std::vector<int> minPath(std::vector<std::vector<int> >, int)’:\n/usr/include/assert.h:66:1: error: expected unqualified-id before string constant\n   66 | __BEGIN_DECLS\n      | ^~~~~~~~~~~~~\ntest.cpp:73:41: error: a function-definition is not allowed here before ‘{’ token\n   73 | bool minPath(vector<int> a,vector<int>b){\n      |                                         ^\ntest.cpp:81:11: error: a function-definition is not allowed here before ‘{’ token\n   81 | int main(){\n      |           ^\ntest.cpp:93:1: error: expected ‘}’ at end of input\n   93 | }\n      | ^\ntest.cpp:55:54: note: to match this ‘{’\n   55 | vector<int> minPath(vector<vector<int>> grid, int k) {\n      |                                                      ^\ntest.cpp:93:1: warning: no return statement in function returning non-void [-Wreturn-type]\n   93 | }\n      | ^\n",
    "completion_id": 0,
    "perturbation_type": "for_var_outer",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n\n#include <vector>\n#include <algorithm>\n\n/**\n * Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n * each cell of the grid contains a value. Every integer in the range {1, N * N}\n * inclusive appears exactly once on the cells of the grid.\n *\n * You have to find the minimum path of length k in the grid. You can start\n * from any cell, and in each step you can move to any of the neighbor cells,\n * in other words, you can go to cells which share an edge with you current\n * cell.\n * Please note that a path of length k means visiting exactly k cells (not\n * necessarily distinct).\n * You CANNOT go off the grid.\n * A path A (of length k) is considered less than a path B (of length k) if\n * after making the ordered vectors of the values on the cells that A and B go\n * through (let's call them lst_A and lst_B), lst_A is lexicographically less\n * than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n * such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n * lst_A[j] = lst_B[j].\n * It is guaranteed that the answer is unique.\n *\n * Return an ordered vector of the values on the cells that the minimum path go through.\n *\n * Examples:\n\n * Input: grid = { {1,2,3}, {4,5,6}, {7,8,9}}, k = 3\n * Output: {1, 2, 1}\n *\n * Input: grid = { {5,9,3}, {4,1,6}, {7,8,2}}, k = 1\n * Output: {1}\n */\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int i, j, x, y, min;\n    {\n        i = 0;\n        for (; i < grid.size(); i++) {\n            j = 0;\n            for (; j < grid[i].size(); j++) {\n                if (grid[i][j] == 1) {\n                    x = i;\n                    y = j;\n                }\n            }\n        }\n    }\n\n    // Initialize\n\n#undef NDEBUG\n#include<assert.h>\nbool minPath(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (minPath(minPath({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3) , {1, 2, 1}));\n    assert (minPath(minPath({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1) , {1}));\n    assert (minPath(minPath({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}, 4) , {1, 2, 1, 2}));\n    assert (minPath(minPath({{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7) , {1, 10, 1, 10, 1, 10, 1}));\n    assert (minPath(minPath({{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}}, 5) , {1, 7, 1, 7, 1}));\n    assert (minPath(minPath({{11, 8, 7, 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9) , {1, 6, 1, 6, 1, 6, 1, 6, 1}));\n    assert (minPath(minPath({{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16, 14, 4}, {11, 8, 7, 2}}, 12) , {1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6}));\n    assert (minPath(minPath({{2, 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8) , {1, 3, 1, 3, 1, 3, 1, 3}));\n    assert (minPath(minPath({{6, 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8) , {1, 5, 1, 5, 1, 5, 1, 5}));\n    assert (minPath(minPath({{1, 2}, {3, 4}}, 10) , {1, 2, 1, 2, 1, 2, 1, 2, 1, 2}));\n    assert (minPath(minPath({{1, 3}, {3, 2}}, 10) , {1, 3, 1, 3, 1, 3, 1, 3, 1, 3}));\n}\n"
      ]
    ]
  },
  "21": {
    "task_id": 137,
    "passed": false,
    "result": "failed: compilation error: test.cpp: In function ‘boost::any compare_one(boost::any, boost::any)’:\ntest.cpp:55:18: error: ‘class boost::any’ has no member named ‘value’\n   55 |         numa = a.value<double>();\n      |                  ^~~~~\ntest.cpp:55:24: error: expected primary-expression before ‘double’\n   55 |         numa = a.value<double>();\n      |                        ^~~~~~\ntest.cpp:56:18: error: ‘class boost::any’ has no member named ‘value’\n   56 |         numb = b.value<double>();\n      |                  ^~~~~\ntest.cpp:56:24: error: expected primary-expression before ‘double’\n   56 |         numb = b.value<double>();\n      |                        ^~~~~~\ntest.cpp:65:18: error: ‘class boost::any’ has no member named ‘value’\n   65 |         numa = a.value<float>();\n      |                  ^~~~~\ntest.cpp:65:24: error: expected primary-expression before ‘float’\n   65 |         numa = a.value<float>();\n      |                        ^~~~~\ntest.cpp:66:18: error: ‘class boost::any’ has no member named ‘value’\n   66 |         numb = b.value<double>();\n      |                  ^~~~~\ntest.cpp:66:24: error: expected primary-expression before ‘double’\n   66 |         numb = b.value<double>();\n      |                        ^~~~~~\ntest.cpp:75:18: error: ‘class boost::any’ has no member named ‘value’\n   75 |         numa = a.value<double>();\n      |                  ^~~~~\ntest.cpp:75:24: error: expected primary-expression before ‘double’\n   75 |         numa = a.value<double>();\n      |                        ^~~~~~\ntest.cpp:76:18: error: ‘class boost::any’ has no member named ‘value’\n   76 |         numb = b.value<float>();\n      |                  ^~~~~\ntest.cpp:76:24: error: expected primary-expression before ‘float’\n   76 |         numb = b.value<float>();\n      |                        ^~~~~\ntest.cpp:84:35: error: expected primary-expression before ‘float’\n   84 |     } else if (a.type() == typeid(float\n      |                                   ^~~~~\ntest.cpp:84:35: error: expected ‘)’ before ‘float’\n   84 |     } else if (a.type() == typeid(float\n      |                                  ~^~~~~\n      |                                   )\ntest.cpp:84:35: error: expected ‘)’ before ‘float’\n   84 |     } else if (a.type() == typeid(float\n      |               ~                   ^~~~~\n      |                                   )\ntest.cpp:96:1: error: expected statement at end of input\n   96 | }\n      | ^\ntest.cpp:96:1: error: expected ‘}’ at end of input\ntest.cpp:28:52: note: to match this ‘{’\n   28 | boost::any compare_one(boost::any a, boost::any b) {\n      |                                                    ^\ntest.cpp:96:1: warning: no return statement in function returning non-void [-Wreturn-type]\n   96 | }\n      | ^\n",
    "completion_id": 0,
    "perturbation_type": "for_var_outer",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <boost/any.hpp>\n\nboost::any compare_one(boost::any a, boost::any b) {\n    double numa, numb;\n    boost::any out;\n\n    if (a.type() == typeid(string)) {\n        string s;\n        s = boost::any_cast<string>(a);\n        if (find(s.begin(), s.end(), ',') != s.end()) {\n            int i = 0;\n            for (; i < s.length(); i++)\n                if (s[i] == ',') s = s.substr(0, i) + '.' + s.substr(i + 1);\n            numa = atof(s.c_str());\n        }\n    }\n\n    if (b.type() == typeid(string)) {\n        string s;\n        s = boost::any_cast<string>(b);\n        if (find(s.begin(), s.end(), ',') != s.end()) {\n            int i = 0;\n            for (; i < s.length(); i++)\n                if (s[i] == ',') s = s.substr(0, i) + '.' + s.substr(i + 1);\n            numb = atof(s.c_str());\n        }\n    }\n\n    if (a.type() == typeid(double) && b.type() == typeid(double)) {\n        numa = a.value<double>();\n        numb = b.value<double>();\n        if (numa > numb) {\n            out = a;\n        } else if (numa < numb) {\n            out = b;\n        } else {\n            out = a;\n        }\n    } else if (a.type() == typeid(float) && b.type() == typeid(double)) {\n        numa = a.value<float>();\n        numb = b.value<double>();\n        if (numa > numb) {\n            out = a;\n        } else if (numa < numb) {\n            out = b;\n        } else {\n            out = a;\n        }\n    } else if (a.type() == typeid(double) && b.type() == typeid(float)) {\n        numa = a.value<double>();\n        numb = b.value<float>();\n        if (numa > numb) {\n            out = a;\n        } else if (numa < numb) {\n            out = b;\n        } else {\n            out = a;\n        }\n    } else if (a.type() == typeid(float\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (boost::any_cast<int>(compare_one(1, 2)) == 2);\n    assert (boost::any_cast<double>(compare_one(1, 2.5))== 2.5);\n    assert (boost::any_cast<int>(compare_one(2, 3)) == 3);\n    assert (boost::any_cast<int>(compare_one(5, 6)) == 6);\n    assert (boost::any_cast<string>(compare_one(1, string(\"2,3\")))== \"2,3\");\n    assert (boost::any_cast<string>(compare_one(string(\"5,1\"), string(\"6\"))) == \"6\");\n    assert (boost::any_cast<string>(compare_one(string(\"1\"), string(\"2\"))) == \"2\");\n    assert (boost::any_cast<string>(compare_one(string(\"1\"), 1)) == \"None\");\n}\n"
      ]
    ]
  },
  "22": {
    "task_id": 142,
    "passed": false,
    "result": "failed: a.out: test.cpp:43: int main(): Assertion `sum_squares({1,2,3}) == 6' failed.\n",
    "completion_id": 0,
    "perturbation_type": "for2while",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n\n#include <vector>\n#include <iostream>\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    {\n        int i = 0;\n        while (i < lst.size()) {\n            if (i % 3 == 0) {\n                sum += lst[i] * lst[i];\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                sum += lst[i] * lst[i];\n            }\n            i++;\n        }\n    }\n    return sum;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_squares({1,2,3}) == 6);\n    assert (sum_squares({1,4,9}) == 14);\n    assert (sum_squares({}) == 0);\n    assert (sum_squares({1,1,1,1,1,1,1,1,1}) == 9);\n    assert (sum_squares({-1,-1,-1,-1,-1,-1,-1,-1,-1}) == -3);\n    assert (sum_squares({0}) == 0);\n    assert (sum_squares({-1,-5,2,-1,-5}) == -126);\n    assert (sum_squares({-56,-99,1,0,-2}) == 3030);\n    assert (sum_squares({-1,0,0,0,0,0,0,0,-1}) == 0);\n    assert (sum_squares({-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}) == -14196);\n    assert (sum_squares({-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}) == -1448);\n}\n"
      ]
    ]
  },
  "23": {
    "task_id": 145,
    "passed": false,
    "result": "failed: compilation error: test.cpp: In lambda function:\ntest.cpp:46:31: error: passing ‘const std::unordered_map<int, int>’ as ‘this’ argument discards qualifiers [-fpermissive]\n   46 |             if (sumdigit_map[a] == sumdigit_map[b]) {\n      |                               ^\nIn file included from /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/c++/9/functional:61,\n                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n                 from test.cpp:3:\n/usr/include/c++/9/bits/unordered_map.h:984:7: note:   in call to ‘std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type& std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type&) [with _Key = int; _Tp = int; _Hash = std::hash<int>; _Pred = std::equal_to<int>; _Alloc = std::allocator<std::pair<const int, int> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type = int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_type = int]’\n  984 |       operator[](const key_type& __k)\n      |       ^~~~~~~~\ntest.cpp:46:50: error: passing ‘const std::unordered_map<int, int>’ as ‘this’ argument discards qualifiers [-fpermissive]\n   46 |             if (sumdigit_map[a] == sumdigit_map[b]) {\n      |                                                  ^\nIn file included from /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/c++/9/functional:61,\n                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n                 from test.cpp:3:\n/usr/include/c++/9/bits/unordered_map.h:984:7: note:   in call to ‘std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type& std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type&) [with _Key = int; _Tp = int; _Hash = std::hash<int>; _Pred = std::equal_to<int>; _Alloc = std::allocator<std::pair<const int, int> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type = int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_type = int]’\n  984 |       operator[](const key_type& __k)\n      |       ^~~~~~~~\ntest.cpp:47:24: error: ‘nums’ is not captured\n   47 |                 return nums[sorted_nums.size() - 1 - a] < nums[sorted_nums.size() - 1 - b];\n      |                        ^~~~\ntest.cpp:45:22: note: the lambda has no capture-default\n   45 |         [sumdigit_map](int a, int b) {\n      |                      ^\ntest.cpp:27:41: note: ‘std::vector<int> nums’ declared here\n   27 | vector<int> order_by_points(vector<int> nums) {\n      |                             ~~~~~~~~~~~~^~~~\ntest.cpp:47:29: error: ‘sorted_nums’ is not captured\n   47 |                 return nums[sorted_nums.size() - 1 - a] < nums[sorted_nums.size() - 1 - b];\n      |                             ^~~~~~~~~~~\ntest.cpp:45:22: note: the lambda has no capture-default\n   45 |         [sumdigit_map](int a, int b) {\n      |                      ^\ntest.cpp:43:17: note: ‘std::vector<int> sorted_nums’ declared here\n   43 |     vector<int> sorted_nums = nums;\n      |                 ^~~~~~~~~~~\ntest.cpp:47:59: error: ‘nums’ is not captured\n   47 |                 return nums[sorted_nums.size() - 1 - a] < nums[sorted_nums.size() - 1 - b];\n      |                                                           ^~~~\ntest.cpp:45:22: note: the lambda has no capture-default\n   45 |         [sumdigit_map](int a, int b) {\n      |                      ^\ntest.cpp:27:41: note: ‘std::vector<int> nums’ declared here\n   27 | vector<int> order_by_points(vector<int> nums) {\n      |                             ~~~~~~~~~~~~^~~~\ntest.cpp:47:64: error: ‘sorted_nums’ is not captured\n   47 |                 return nums[sorted_nums.size() - 1 - a] < nums[sorted_nums.size() - 1 - b];\n      |                                                                ^~~~~~~~~~~\ntest.cpp:45:22: note: the lambda has no capture-default\n   45 |         [sumdigit_map](int a, int b) {\n      |                      ^\ntest.cpp:43:17: note: ‘std::vector<int> sorted_nums’ declared here\n   43 |     vector<int> sorted_nums = nums;\n      |                 ^~~~~~~~~~~\ntest.cpp:49:38: error: passing ‘const std::unordered_map<int, int>’ as ‘this’ argument discards qualifiers [-fpermissive]\n   49 |                 return sumdigit_map[a] < sumdigit_map[b];\n      |                                      ^\nIn file included from /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/c++/9/functional:61,\n                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n                 from test.cpp:3:\n/usr/include/c++/9/bits/unordered_map.h:984:7: note:   in call to ‘std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type& std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type&) [with _Key = int; _Tp = int; _Hash = std::hash<int>; _Pred = std::equal_to<int>; _Alloc = std::allocator<std::pair<const int, int> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type = int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_type = int]’\n  984 |       operator[](const key_type& __k)\n      |       ^~~~~~~~\ntest.cpp:49:56: error: passing ‘const std::unordered_map<int, int>’ as ‘this’ argument discards qualifiers [-fpermissive]\n   49 |                 return sumdigit_map[a] < sumdigit_map[b];\n      |                                                        ^\nIn file included from /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/c++/9/functional:61,\n                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n                 from test.cpp:3:\n/usr/include/c++/9/bits/unordered_map.h:984:7: note:   in call to ‘std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type& std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type&) [with _Key = int; _Tp = int; _Hash = std::hash<int>; _Pred = std::equal_to<int>; _Alloc = std::allocator<std::pair<const int, int> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type = int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_type = int]’\n  984 |       operator[](const key_type& __k)\n      |       ^~~~~~~~\n",
    "completion_id": 0,
    "perturbation_type": "for_var_outer",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a map to store the sum of digits of each number\n    unordered_map<int, int> sumdigit_map;\n    for (int i = 0; i < nums.size(); i++) {\n        string w = to_string(abs(nums[i]));\n        int sum = 0;\n        {\n            int j = 1;\n            for (; j < w.length(); j++)\n                sum += w[j] - 48;\n        }\n        if (nums[i] > 0) sum += w[0] - 48;\n        sumdigit_map[nums[i]] = sum;\n    }\n\n    // Sort the numbers based on the sum of their digits and their original index\n    vector<int> sorted_nums = nums;\n    sort(sorted_nums.begin(), sorted_nums.end(),\n        [sumdigit_map](int a, int b) {\n            if (sumdigit_map[a] == sumdigit_map[b]) {\n                return nums[sorted_nums.size() - 1 - a] < nums[sorted_nums.size() - 1 - b];\n            } else {\n                return sumdigit_map[a] < sumdigit_map[b];\n            }\n        });\n\n    return sorted_nums;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool order_by_points(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (order_by_points(order_by_points({1, 11, -1, -11, -12}) , {-1, -11, 1, -12, 11}));\n    assert (order_by_points(order_by_points({1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46}) , {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457}));\n    assert (order_by_points(order_by_points({}) , {}));\n    assert (order_by_points(order_by_points({1, -11, -32, 43, 54, -98, 2, -3}) , {-3, -32, -98, -11, 1, 2, 43, 54}));\n    assert (order_by_points(order_by_points({1,2,3,4,5,6,7,8,9,10,11}) , {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9}));\n    assert (order_by_points(order_by_points({0,6,6,-76,-21,23,4}) , {-76, -21, 0, 4, 23, 6, 6}));\n    \n}\n"
      ]
    ]
  },
  "24": {
    "task_id": 147,
    "passed": false,
    "result": "failed: a.out: test.cpp:57: int main(): Assertion `get_matrix_triples(5) == 1' failed.\n",
    "completion_id": 0,
    "perturbation_type": "for2while",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint get_matrix_triples(int n) {\n    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    {\n        int i=1;\n        while(i<=n){\n            a.push_back((i*i-i+1)%3);\n            sum.push_back(sum[sum.size()-1]);\n            sum[i][a[i-1]]+=1;\n            i++;\n        }\n    }\n    vector<vector<int>> dp(n+1, vector<int>(3, 0));\n    for(int i=1; i<=n; i++){\n        dp[i][0] = dp[i-1][0] + (a[i-1] == 0 ? 0 : 1);\n        dp[i][1] = dp[i-1][1] + (a[i-1] == 1 ? 0 : 1);\n        dp[i][2] = dp[i-1][2] + (a[i-1] == 2 ? 0 : 1);\n    }\n    vector<int> ans;\n    for(int i=1; i<=n; i++){\n        for(int j=0; j<3; j++){\n            if(dp[i][j] % 3 == 0){\n                ans.push_back(i);\n            }\n        }\n    }\n    return ans.size();\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (get_matrix_triples(5) == 1);\n    assert (get_matrix_triples(6) == 4);\n    assert (get_matrix_triples(10) == 36);\n    assert (get_matrix_triples(100) == 53361);\n}\n"
      ]
    ]
  },
  "25": {
    "task_id": 149,
    "passed": false,
    "result": "failed: a.out: test.cpp:58: int main(): Assertion `sorted_list_sum(sorted_list_sum({\"aaaa\", \"bbbb\", \"dd\", \"cc\"}) , {\"cc\", \"dd\", \"aaaa\", \"bbbb\"})' failed.\n",
    "completion_id": 0,
    "perturbation_type": "for2while",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    vector<string> out = {};\n    {\n        int i = 0;\n        while (i < lst.size()) {\n            if (lst[i].length() % 2 == 0) {\n                out.push_back(lst[i]);\n            }\n            i++;\n        }\n    }\n    string mid;\n    sort(out.begin(), out.end());\n    return out;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool sorted_list_sum(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (sorted_list_sum(sorted_list_sum({\"aa\", \"a\", \"aaa\"}) , {\"aa\"}));\n    assert (sorted_list_sum(sorted_list_sum({\"school\", \"AI\", \"asdf\", \"b\"}) , {\"AI\", \"asdf\", \"school\"}));\n    assert (sorted_list_sum(sorted_list_sum({\"d\", \"b\", \"c\", \"a\"}) , {}));\n    assert (sorted_list_sum(sorted_list_sum({\"d\", \"dcba\", \"abcd\", \"a\"}) , {\"abcd\", \"dcba\"}));\n    assert (sorted_list_sum(sorted_list_sum({\"AI\", \"ai\", \"au\"}) , {\"AI\", \"ai\", \"au\"}));\n    assert (sorted_list_sum(sorted_list_sum({\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"}) , {}));\n    assert (sorted_list_sum(sorted_list_sum({\"aaaa\", \"bbbb\", \"dd\", \"cc\"}) , {\"cc\", \"dd\", \"aaaa\", \"bbbb\"}));\n}\n"
      ]
    ]
  },
  "26": {
    "task_id": 160,
    "passed": false,
    "result": "failed: a.out: test.cpp:75: int main(): Assertion `do_algebra({\"**\", \"*\", \"+\"}, {2, 3, 4, 5}) == 37' failed.\n",
    "completion_id": 0,
    "perturbation_type": "for_var_outer",
    "evaluation_codes": [
      [
        "using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<list>\n#include<deque>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <stdlib.h>\n\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    vector<int> num={};\n    vector<int> posto={};\n    {\n        int i = 0;\n        for (; i < operand.size(); i++)\n            posto.push_back(i);\n    }\n    {\n        int i = 0;\n        for (; i < operato.size(); i++)\n            if (operato[i] == \"**\") {\n                while (posto[posto[i]] != posto[i])\n                    posto[i] = posto[posto[i]];\n                while (posto[posto[i + 1]] != posto[i + 1])\n                    posto[i + 1] = posto[posto[i + 1]];\n                operand[posto[i]] = pow(operand[posto[i]], operand[posto[i + 1]]);\n                posto[i + 1] = posto[i];\n            }\n    }\n    int result = 0;\n    for (int i = 0; i < operato.size(); i++) {\n        if (operato[i] == \"+\") {\n            result += operand[posto[i]];\n        } else if (operato[i] == \"-\") {\n            result -= operand[posto[i]];\n        } else if (operato[i] == \"*\") {\n            result *= operand[posto[i]];\n        } else if (operato[i] == \"/\") {\n            if (operand[posto[i]] != 0) {\n                result /= operand[posto[i]];\n            } else {\n                printf(\"Error: Division by zero\\n\");\n                return -1;\n            }\n        } else if (operato[i] == \"**\") {\n            result = pow(operand[posto[i]], operand[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (do_algebra({\"**\", \"*\", \"+\"}, {2, 3, 4, 5}) == 37);\n    assert (do_algebra({\"+\", \"*\", \"-\"}, {2, 3, 4, 5}) == 9);\n    assert (do_algebra({\"//\", \"*\"}, {7, 3, 4}) == 8);\n}\n"
      ]
    ]
  }
}