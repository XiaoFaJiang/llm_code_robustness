[["int mostFrequentEven(vector<int> nums) {\n    int n = nums.size();\n    map<int, int> freq;\n    for(auto x : nums)\n        freq[x]++;\n    int evefreq = 0, ans = -1;\n    for(auto y : freq) {\n        if(y.first % 2 == 0 && y.second >= evefreq) {\n            ans = y.first;\n            evefreq = y.second;\n        }\n    }\n    return ans;\n}"], ["int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\nint shortestPathAllKeys(vector<string> grid) {\n    int m = grid.size();\n    int n = grid[0].size();\n    queue<pair<pair<int, int>, int>> que;\n    vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n    int target = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                target |= 1 << (grid[i][j] - 'a');\n                continue;\n            }\n            if (grid[i][j] == '@') {\n                que.emplace(pair<int, int>(i, j), 0);\n                mapKey[i][j] = 1;\n            }\n        }\n    }\n\n    int step = 0;\n    while (!que.empty()) {\n        int size = que.size();\n        for (int s = 0; s < size; s++) {\n            int i = que.front().first.first;\n            int j = que.front().first.second;\n            int key = que.front().second;\n            que.pop();\n\n            if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                key |= 1 << (grid[i][j] - 'a');\n                if (key == target)\n                    return step;\n\n                mapKey[i][j] |= 1l << key;\n            }\n\n            for (int d = 0; d < 4; d++) {\n                int newi = i + dir[d][0];\n                int newj = j + dir[d][1];\n\n                if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                    continue;\n\n                int val = grid[newi][newj];\n                if (val == '#')\n                    continue;\n\n                if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                    continue;\n\n                if (mapKey[newi][newj] & (1l << key))\n                    continue;\n\n                mapKey[newi][newj] |= 1l << key;\n                que.emplace(pair<int, int>(newi, newj), key);\n            }\n        }\n        step++;\n    }\n    return -1;\n}"], ["string addBinary(string a, string b) {\n    int c=0;\n    string s=\"\";\n    int i=0;\n    while(i<a.length() || i<b.length() || c!=0) {\n        int x=0;\n        if(i<a.length() && a[a.length()-i-1]=='1')\n            x=1;\n        int y=0;\n        if(i<b.length() && b[b.length()-1-i]=='1')\n            y=1;\n        s=to_string((x+y+c)%2)+s;\n        c=(x+y+c)/2;\n        i++;\n    }\n    return s;\n}"], ["string longestCommonPrefix(vector<string> str) {\n    if (str.empty()) {\n        return \"\";\n    }\n    \n    sort(str.begin(), str.end()); // sorting the array\n    \n    string ans = \"\"; // creating a new empty string to store the common prefixes\n    \n    for (int i = 0; i < str[0].length(); i++) { // max iterations = length of the first string\n        if (str[0][i] != str[str.size() - 1][i]) { // checking the characters of the first and last string\n            break;\n        }\n        ans += str[0][i];\n    }\n    \n    return ans;\n} "], [""], ["int longestString(int x, int y, int z) {\n    int mn = min(x, y);\n    int cnt = 0;\n    if (x != y) {\n        cnt = 1;\n    }\n    return (mn + mn + cnt + z) * 2;\n} "], ["int findLengthOfShortestSubarray(vector<int> arr) {\n    int n = arr.size();\n    int h = n - 1, l = 0;\n\n    for (int i = h; i >= 1; i--) {\n        if (arr[i] >= arr[i - 1] && h > 0) {\n            h--;\n            break;\n        } else {\n            break;\n        }\n    }\n\n    int res = h;\n\n    for (l = 0; l < h && (l == 0 || arr[l - 1] <= arr[l]); l++) {\n        while (h < n && arr[l] > arr[h]) {\n            h++;\n        }\n\n        res = min(res, h - l - 1);\n    }\n    return res;\n}"], ["int maxLengthBetweenEqualCharacters(string s) {\n    int v[26];\n    memset(v,-1,sizeof v);\n    int ans=-1;\n    for(int i=0;i<s.size();i++) {\n        if(v[s[i]-'a']==-1) {\n            v[s[i]-'a']=i;\n        } else {\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        }\n    }\n    return ans;\n} "], ["int minDifference(vector<int> nums) {\n    if(nums.size() <= 4) return 0;\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    return min({nums[n - 4] - nums[0], nums[n - 1] - nums[3], nums[n - 3] - nums[1], nums[n - 2] - nums[2]});\n} "], ["int minOperations(string s) {\n    int n = s.size();\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (s[i] - '0' != i % 2) {\n            ans++;\n        }\n    }\n    return ans;\n}"], ["int longestValidSubstring(string word, vector<string> forbidden) {\n    vector<int> ends(word.size(), -1);\n    unordered_map<string, int> forbidden_word;\n    for (auto it : forbidden) {\n        forbidden_word[it] = 1;\n    }\n    int n = word.size();\n    for (int i = 0; i < n; i++) {\n        string temp = \"\";\n        for (int j = i; j < i + 10 && j < n; j++) {\n            temp += word[j];\n            if (forbidden_word.find(temp) != forbidden_word.end()) {\n                ends[j] = i;\n            }\n        }\n    }\n\n    int i = 0, j = 0;\n    int ans = INT_MIN;\n    while (j < n) {\n        if (ends[j] != -1) {\n            int st = ends[j];\n            if (st < i) {\n                ans = max(ans, j - i + 1);\n            } else {\n                i = st + 1;\n                ans = max(ans, j - i + 1);\n            }\n        } else {\n            ans = max(ans, j - i + 1);\n        }\n        j++;\n    }\n    return ans;\n}"], ["int myAtoi(string s) {\n    long long res = 0;\n    bool neg = false;\n    bool leading = true;\n    int n = s.size();\n    \n    for (int i = 0; i < n; i++) {\n        if (s[i] == ' ') {\n            if (leading) continue;\n            else break;\n        }\n        else if (s[i] == '-') {\n            if (i + 1 < n && isdigit(s[i + 1])) neg = true;\n            else break;\n        }\n        else if (s[i] == '+') {\n            if (i + 1 < n && isdigit(s[i + 1])) neg = false;\n            else break;\n        }\n        else if (!isdigit(s[i])) break;\n        else {\n            if (res < INT_MAX) {\n                res = res * 10 + (s[i] - '0');\n                if (i + 1 < n && !isdigit(s[i + 1])) break;\n            }\n            else break;\n            leading = false;\n        }\n    }\n\n    if (res > INT_MAX && neg) return INT_MIN;\n    if (res > INT_MAX) return INT_MAX;\n    return neg ? -1 * res : res;\n} "], ["int rangeBitwiseAnd(int left, int right) {\n    int bit1 = log2(left);\n    int bit2 = log2(right);\n    if (bit1 < bit2) {\n        return 0;\n    }\n    return (1 << bit1) | rangeBitwiseAnd((left ^ (1 << bit1)), (right ^ (1 << bit1)));\n}"], ["int hammingDistance(int x, int y) {\n    int ans = 0;\n    while (x || y) {\n        int mask = x & 1;\n        int mask2 = y & 1;\n        if (mask != mask2) {\n            ans++;\n        }\n        x >>= 1;\n        y >>= 1;\n    }\n    return ans;\n}"], ["string intToRoman(int num) {\n    string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\n    string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\n    string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\n    string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\n\n    return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\n} "], ["int halveArray(vector<int> nums) \n{\n    priority_queue<double> Q;\n\n    double sum = 0;\n    for(auto ele : nums)\n    {\n        sum += ele;\n        Q.push(ele);\n    }\n    \n    double half = sum / 2;\n    \n    int count = 0;\n    while(sum > half)\n    { \n        double max = Q.top();\n        Q.pop();\n        \n        max /= 2;\n        Q.push(max);\n        count++;\n        \n        sum -= max; // Subtract max from sum instead of adding it\n        \n        // Update half after each operation\n        half = sum / 2;\n    }\n   \n    return count;\n} "], ["int maxSumDivThree(vector<int>& nums) {\n    vector<int> dp(3);\n    for (auto a : nums) {\n        vector<int> temp(dp);\n        for (int i : temp) {\n            dp[(i + a) % 3] = max(dp[(i + a) % 3], i + a);\n        }\n    }\n    return dp[0];\n} "], ["string smallestString(string s) {\n    int temp = -1;\n    int cnt = 0;\n    for(int i = 0; i < s.size(); i++)\n    {\n        if(s[i] == 'a')\n        {\n            cnt++;\n        }\n    }\n    if(cnt == s.size())\n    {\n        s[s.size()-1] = 'z'; // Fix: Change s[s.size()] to s[s.size()-1]\n        return s;\n    }\n    else\n    {\n        for(int i = 0; i < s.size(); i++)\n        {\n            if(s[i] == 'a')\n            {\n                temp = i;\n                break;\n            }\n        }\n\n        if(temp == 0)\n        {\n            int temp1 = 1, temp2 = 1;\n            for(int i = 1 ; i < s.size(); i++)\n            {\n                if(s[i] != 'a')\n                {\n                    temp1 = i;\n                    break;\n                }\n            }\n            for(int i = temp1; i < s.size(); i++)\n            {\n                if(s[i] == 'a')\n                {\n                    temp2 = i;\n                    break;\n                }\n            }\n\n            if(temp2 > 1)\n            {\n                for(int i = temp1; i < temp2; i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n            }\n            else if(temp2 == 1)\n            {\n                for(int i = temp1; i < s.size(); i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n            }\n\n            return s;\n        }\n        else if(temp == -1)\n        {\n            for(int i = 0; i < s.size(); i++)\n            {\n                s[i] = s[i] - 1;\n            }\n            return s;\n        }\n        else\n        {\n            for(int i = 0; i < temp; i++)\n            {\n                s[i] = s[i] - 1;\n            }\n            return s;\n        }\n    }\n}"], ["string makeLargestSpecial(string s) {\n    if(s.length()==0)\n        return \"\"; //return null string if size is zero\n\n    vector<string> ans; //list to store all current special substrings\n    int count=0,i=0; //keep track of special substring starting index using \"i\" and \n                     //\"count\" to keep the track of special substring is over or not\n\n    for(int j=0;j<s.size();j++){\n        if(s[j] == '1')\n            count++;\n        else\n            count--;\n        \n        if(count==0){\n            string specialSubstring = '1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0';\n            ans.push_back(specialSubstring);\n            i = j;\n        }\n    }\n\n    sort(ans.begin(),ans.end(),greater<string>());\n    string finalString = \"\";\n    for(i=0;i<ans.size();i++){\n        finalString += ans[i];\n    }\n    return finalString;\n}"], [""], ["int finalValueAfterOperations(vector<string> operations) {\n    int x = 0;\n    for (auto& operation : operations) {\n        if (operation == \"++X\" || operation == \"X++\") x++;\n        else x--;\n    }\n    return x;\n} "], ["int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\nint shortestPathAllKeys(vector<string> grid) {\n    int m = grid.size();\n    int n = grid[0].size();\n    queue<pair<pair<int, int>, int>> que;\n    vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n    int target = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                target |= 1 << (grid[i][j] - 'a');\n                continue;\n            }\n            if (grid[i][j] == '@') {\n                que.emplace(pair<int, int>(i, j), 0);\n                mapKey[i][j] = 1;\n            }\n        }\n    }\n\n    int step = 0;\n    while (!que.empty()) {\n        int size = que.size();\n        for (int s = 0; s < size; s++) {\n            int i = que.front().first.first;\n            int j = que.front().first.second;\n            int key = que.front().second;\n            que.pop();\n\n            if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                key |= 1 << (grid[i][j] - 'a');\n                if (key == target)\n                    return step;\n                mapKey[i][j] |= 1l << key;\n            }\n\n            for (int d = 0; d < 4; d++) {\n                int newi = i + dir[d][0];\n                int newj = j + dir[d][1];\n\n                if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                    continue;\n\n                int val = grid[newi][newj];\n                if (val == '#')\n                    continue;\n\n                if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                    continue;\n\n                if (mapKey[newi][newj] & (1l << key))\n                    continue;\n\n                mapKey[newi][newj] |= 1l << key;\n                que.emplace(pair<int, int>(newi, newj), key);\n            }\n        }\n        step++;\n    }\n    return -1;\n}"], ["int magicalString(int n) {\n    string s = \"122\";\n    int i = 2, c = 1;\n    while (s.size() < n) {\n        if (s[i] == '1') {\n            c++;\n            if (s[s.size() - 1] == '2')\n                s += '1';\n            else\n                s += '2';\n        } else {\n            if (s[s.size() - 1] == '2')\n                s += \"11\";\n            else\n                s += \"22\";\n        }\n        i++;\n    }\n    while (i < n) {\n        if (s[i] == '1')\n            c++;\n        i++;\n    }\n    return c;\n}"], ["int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\n    int count = 0;\n    for(int i=0; i<customers.size(); i++) {\n        if(grumpy[i] == 0) {\n            count += customers[i];\n        }\n    }\n    \n    for(int i=0; i<customers.size(); i++) {\n        customers[i] *= grumpy[i];\n    }\n    \n    int max = 0, temp = 0;\n    for(int i=0; i<minutes; i++) {\n        temp += customers[i];\n    }\n    \n    if(max == temp) {\n        max = temp;\n    }\n    \n    for(int i=minutes; i<customers.size(); i++) {\n        temp -= customers[i - minutes];\n        temp += customers[i];\n        \n        if(max == temp) {\n            max = temp;\n        }\n    }\n\n    return count + max;\n}"], ["string reverseVowels(string s) {\n    vector<char> v;\n    for(int i = 0 ; i < s.length(); i++)\n    {\n        if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n          || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U')\n            v.push_back(s[i]);\n    }\n    reverse(v.begin(), v.end()); // Fixed function name\n    int rev = 0;\n    for(int i = 0 ; i < s.length(); i++)\n    {\n        if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n          || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U'){ // Fixed comparison operator\n            s[i] = v[rev];\n            rev++;\n        }\n    }\n    return s;\n}"], [""], ["const int inf = 0x3f3f3f3f;\nint minimumIncompatibility(vector<int> nums, int k) {\n  int n = nums.size();\n  int sz = n/k; // size of every group\n  sort(nums.begin(), nums.end());\n  int dp[1<<n][n+1];  \n  memset(dp, inf, sizeof(dp));\n  for (int i = 0; i <= n; ++i) { dp[0][i] = 0; }  \n  for (int m = 0; m < (1<<n)-1; ++m) {\n    int cnt = __builtin_popcount(m);\n    for (int i = 0; i <= n; ++i) {  \n      if (dp[m][i] == inf) { continue; }\n      if (cnt%sz == 0) {\n        int j = __builtin_ffs(~m)-1;\n        dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);\n      } else {\n        for (int j = i+1; j <= n; ++j) { \n          if (m&(1<<j) && nums[j] == nums[i]) { continue; } \n          dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);\n        }\n      }\n    }\n  }\n  return dp[(1<<n)-1][n-1] == inf? -1: dp[(1<<n)-1][n-1];\n}"], [""], ["int maxLengthBetweenEqualCharacters(string s) {\n    int v[26];\n    memset(v,-1,sizeof v);\n    int ans=-1;\n    for(int i=0;i<s.size();i++){\n        if(v[s[i]-'a']==-1){\n            v[s[i]-'a'] = i;\n        }\n        int res = i - v[s[i]-'a'] - 1; \n        ans = max(ans,res);\n    }\n    return ans;\n}"], ["string longestCommonPrefix(vector<string> str) \n{\n    sort(str.begin(), str.end()); //sorting the array\n    string ans=\"\"; \n    for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n    {\n        if(str[0][i]!=str[str.size()-1][i]) \n            break;\n        ans+=str[0][i]; // concatenate if the characters are matching\n    }\n    return ans;\n} "], ["int mostFrequentEven(vector<int> nums) {\n    int n = nums.size();\n    map<int, int> freq;\n    for(auto x : nums) {\n        if(x % 2 == 0) {\n            freq[x]++;\n        }\n    }\n    int evefreq = 0, ans = -1;\n    for(auto y : freq) {\n        if(y.second > evefreq) {\n            ans = y.first;\n            evefreq = y.second;\n        }\n    }\n    return ans;\n}"], ["int rangeBitwiseAnd(int left, int right) {\n    int bit1 = log2(left);\n    int bit2 = log2(right);\n    if (bit1 < bit2) {\n        return 0;\n    }\n    int result = left;\n    for (int i = left + 1; i <= right; i++) {\n        result &= i;\n    }\n    return result;\n}"], ["int smallestEqual(vector<int> nums) {\n    for (int i = 0; i < nums.size(); i++) {\n        if (i % 10 == nums[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"], ["string addBinary(string a, string b) {\n    int c = 0;\n    string s = \"\";\n    int i = 0;\n    while (i < a.length() || i < b.length() || c != 0) {\n        int x = 0;\n        if (i < a.length() && a[a.length() - i - 1] == '1')\n            x = 1;\n        int y = 0;\n        if (i < b.length() && b[b.length() - 1 - i] == '1')\n            y = 1;\n        s = to_string((x + y + c) % 2) + s;\n        c = (x + y + c) / 2;\n        i++;\n    }\n    return s;\n}"], ["int maxWidthOfVerticalArea(vector<vector<int>> points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n} "], ["int nthUglyNumber(int n) {\n    vector<int> dp(n);\n    dp[0] = 1;\n    int p1 = 0;\n    int p2 = 0;\n    int p3 = 0;\n    for (int i = 1; i < n; i++) {\n        int two = dp[p1] * 2;\n        int three = dp[p2] * 3;\n        int five = dp[p3] * 5;\n        dp[i] = min(two, min(three, five));\n        if (dp[i] == two)\n            p1++;\n        if (dp[i] == three)\n            p2++;\n        if (dp[i] == five)\n            p3++;\n    }\n    return dp[n - 1];\n} "], ["int minOperations(vector<int> nums) {\n   int count = 0; \n   for(int i=1; i<nums.size(); i++) {\n       if(nums[i] <= nums[i-1]) {\n           count += nums[i-1]+1-nums[i]; \n           nums[i] = nums[i-1]+1; \n       }\n   }\n   return count; \n} "], ["string smallestString(string s) {\n    int temp = -1;\n    int cnt = 0;\n    for(int i = 0; i < s.size(); i++)\n    {\n        if(s[i] == 'a')\n        {\n            cnt++;\n        }\n    }\n    if(cnt == s.size())\n    {\n        s[s.size()-1] = 'z'; // Fix: Change s[s.size()] to s[s.size()-1]\n        return s;\n    }\n    else\n    {\n        for(int i = 0; i < s.size(); i++)\n        {\n            if(s[i] == 'a')\n            {\n                temp = i;\n                break;\n            }\n        }\n\n        if(temp == 0)\n        {\n            int temp1 = 1, temp2 = 1;\n            for(int i = 1 ; i < s.size(); i++)\n            {\n                if(s[i] != 'a')\n                {\n                    temp1 = i;\n                    break;\n                }\n            }\n            for(int i = temp1; i < s.size(); i++)\n            {\n                if(s[i] == 'a')\n                {\n                    temp2 = i;\n                    break;\n                }\n            }\n\n            if(temp2 > 1)\n            {\n                for(int i = temp1; i < temp2; i++)\n                {\n                    s[i] = modifyChar(s[i]);\n                }\n            }\n            else if(temp2 == 1)\n            {\n                for(int i = temp1; i < s.size(); i++)\n                {\n                    s[i] = modifyChar(s[i]);\n                }\n            }\n\n            return s;\n        }\n        else if(temp == -1)\n        {\n            for(int i = 0; i < s.size(); i++)\n            {\n                s[i] = modifyChar(s[i]);\n            }\n            return s;\n        }\n        else\n        {\n            for(int i = 0; i < temp; i++)\n            {\n                s[i] = modifyChar(s[i]);\n            }\n            return s;\n        }\n    }\n}"], ["int maxWidthOfVerticalArea(vector<vector<int>> points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n} "], ["string reverseVowels(string s) {\n    vector<char> v;\n    for(int i = 0 ; i < s.length(); i++)\n    {\n        if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n          || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' )\n            v.push_back(s[i]);\n    }\n    reverse(v.begin(), v.end()); // Fixed: Use reverse function to reverse the vector\n    int rev = 0;\n    for(int i = 0 ; i < s.length(); i++)\n    {\n        if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n          || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I'){\n            s[i] = v[rev];\n            rev++;\n        }\n    }\n    return s;\n}"], ["int minOperations(string s) {\n    int n = s.size();\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (s[i] - '0' != i % 2) {\n            ans++;\n        }\n    }\n    return min(ans, n - ans);\n} "], ["double trimMean(vector<int> arr) {\n    int k = 0.05 * arr.size();\n    sort(arr.begin(), arr.end());\n    arr.erase(arr.begin(), arr.begin() + k);\n    arr.erase(arr.end() - k, arr.end());\n    double mean = accumulate(arr.begin(), arr.end(), 0) / static_cast<double>(arr.size());\n    return mean;\n} "], [""], [""], ["string longestCommonPrefix(vector<string> str) \n{\n    sort(str.begin(), str.end()); //sorting the array\n    string ans=\"\"; \n    for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n    {\n        if(str[0][i]!=str[str.size()-1][i]) \n            break;\n        ans+=str[0][i]; // concatenate if the characters are matching\n    }\n    return ans;\n} "], ["int maxProfit(vector<int>& prices, int fee) {\n    int n = prices.size();\n    if (n <= 1) return 0;\n    int buy = -prices[0];\n    int sell = 0;\n    for (int i = 1; i < n; i++) {\n        int prevBuy = buy;\n        buy = max(buy, sell - prices[i]);\n        sell = max(sell, prevBuy + prices[i] - fee);\n    }\n    return sell;\n} "], ["int findLengthOfShortestSubarray(vector<int> arr) {\n    int n = arr.size();\n    int h = n - 1, l = 0;\n\n    for (int i = h; i >= 1; i--) {\n        if (arr[i] >= arr[i - 1] && h > 0) {\n            h--;\n            break;\n        } else {\n            break;\n        }\n    }\n\n    int res = h;\n\n    for (l = 0; l < h && (l == 0 || arr[l - 1] <= arr[l]); l++) {\n        while (h < n && arr[l] > arr[h]) {\n            h++;\n        }\n\n        res = min(res, h - l - 1);\n    }\n    return res;\n}"], ["int findPeakElement(vector<int>& nums) {\n    int n = nums.size();\n    if (n == 1) {\n        return 0;\n    } \n    if (nums[0] > nums[1]) {\n        return 0;\n    }\n    if (nums[n-1] > nums[n-2]) {\n        return n-1;\n    }\n    int left = 1;\n    int right = n-2;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > nums[mid-1] && nums[mid] > nums[mid+1]) {\n            return mid;\n        }\n        else if (nums[mid] > nums[mid-1]) {\n            left = mid + 1;\n        }\n        else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n} "], ["int findTheWinner(int n, int k) {\n    queue<int> q;\n    for(int i=1;i<=n;i++){\n        q.push(i);\n    }\n    \n    while(q.size() != 1){\n        for(int i = 0; i < k-1; i++){\n            int f = q.front();\n            q.pop();\n            q.push(f);\n        }\n        q.pop();\n    }\n\n    return q.front();\n} "], ["int searchInsert(vector<int>& nums, int target) {\n    int l = 0;\n    int r = nums.size() - 1;\n    int m;\n    while (l <= r) {\n        m = l + (r - l) / 2;\n        if (nums[m] == target) {\n            return m;\n        } else if (nums[m] > target) {\n            r = m - 1;\n        } else {\n            l = m + 1;\n        }\n    }\n    return l;\n}"], ["int arrayPairSum(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int sum = 0;\n    for (int i = 0; i < nums.size(); i += 2) {\n        sum += nums[i];\n    }\n    return sum;\n} "], ["string longestCommonPrefix(vector<string> str) \n{\n    sort(str.begin(), str.end()); //sorting the array\n    string ans=\"\"; //creating a new empty string to store the common prefixes\n    for(int i=0;i<str[0].length();i++) \n    {\n        if(str[0][i]!=str[str.size()-1][i]) \n            break;\n        ans+=str[0][i]; // concatenate if the characters are matching\n    }\n    return ans;\n}"], ["int nthUglyNumber(int n) {\n    vector<int> dp(n);\n    dp[0] = 1;\n    int p1 = 0;\n    int p2 = 0;\n    int p3 = 0;\n    for (int i = 1; i < n; i++) {\n        int two = dp[p1] * 2;\n        int three = dp[p2] * 3;\n        int five = dp[p3] * 5;\n        dp[i] = min(two, min(three, five));\n        if (dp[i] == two)\n            p1++;\n        if (dp[i] == three)\n            p2++;\n        if (dp[i] == five)\n            p3++;\n    }\n    return dp[n - 1];\n}"], ["string reverseVowels(string s) {\n    vector<char> v;\n    for(int i = 0 ; i < s.length(); i++)\n    {\n        if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n          || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' )\n            v.push_back(s[i]);\n    }\n    reverse(v.begin(), v.end());\n    int rev = 0;\n    for(int i = 0 ; i < s.length(); i++)\n    {\n        if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n          || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I'){\n            s[i] = v[rev];\n            rev++;\n        }\n    }\n    return s;\n}"], [""], ["int longestWPI(vector<int> hours) {\n    unordered_map<int, int> mp;\n    int k = 0, ans = 0;\n    for (int i = 0; i < hours.size(); i++) {\n        if (hours[i] > 8) {\n            k++;\n        } else {\n            k--;\n        }\n        if (k > 0) {\n            ans = max(ans, i + 1);\n        } else {\n            if (mp.find(k - 1) != mp.end()) {\n                ans = max(ans, i - mp[k - 1]);\n            }\n            if (mp.find(k) == mp.end()) {\n                mp[k] = i;\n            }\n        }\n    }\n    return ans;\n}"], ["int maxWidthOfVerticalArea(vector<vector<int>> points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n} "], ["int minCostClimbingStairs(vector<int>& cost) {\n    int n = cost.size();\n    vector<int> dp(n+1, 0);\n\n    dp[0] = cost[0];\n    dp[1] = cost[1];\n\n    for(int i=2; i<=n; i++){\n        dp[i] = min(dp[i-1], dp[i-2]) + cost[i];\n    }\n\n    return min(dp[n], dp[n-1]);\n}"], ["int lengthOfLIS(vector<int> nums) {\n    vector<int> dp(nums.size(), 1); // Initialize dp array with 1, as the minimum length of subsequence is 1\n    int maxLength = 1; // Initialize maxLength with 1\n    for (int i = 1; i < nums.size(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = max(dp[i], dp[j] + 1); // Update dp[i] with the maximum length so far\n            }\n        }\n        maxLength = max(maxLength, dp[i]); // Update maxLength if dp[i] is greater\n    }\n    return maxLength;\n}"], ["int numTrees(int n) {\n    vector<int> dp(n + 1, 0);\n    dp[0] = dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= i; j++) {\n            dp[i] += dp[j - 1] * dp[i - j];\n        }\n    }\n    return dp[n];\n} "], ["int magicalString(int n) {\n    string s = \"122\";\n    int i = 2, c = 1;\n    while (s.size() < n) {\n        if (s[i] == '1') {\n            c++;\n            if (s[s.size() - 1] == '2')\n                s += '1';\n            else\n                s += '2';\n        } else {\n            if (s[s.size() - 1] == '2')\n                s += \"11\";\n            else\n                s += \"22\";\n        }\n        i++;\n    }\n    while (i < n) {\n        if (s[i] == '1')\n            c++;\n        i++;\n    }\n    return c;\n}"], ["string addStrings(string a, string b) {\n    string ret = \"\";\n    int carry = 0, i = a.size() - 1, j = b.size() - 1;\n    while (i >= 0 || j >= 0) {\n        int x = i >= 0 ? a[i--] - '0' : 0;\n        int y = j >= 0 ? b[j--] - '0' : 0;\n\n        int sm = x + y + carry;\n        ret.push_back('0' + (sm % 10));\n        carry = sm / 10;\n    }\n    if (carry > 0) {\n        ret.push_back('0' + carry);\n    }\n\n    reverse(ret.begin(), ret.end());\n\n    return ret;\n} "], ["string findTheString(vector<vector<int>> lcp) {\n    int n = lcp.size();\n    string ans = \"\";\n\n    if (lcp[0][0] != n)\n        return ans;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (lcp[i][j] != lcp[j][i] || lcp[i][j] > n - max(i, j))\n                return ans;\n            if (i + 1 < n && j + 1 < n && lcp[i][j] > 0 && lcp[i + 1][j + 1] != lcp[i][j] - 1)\n                return ans;\n        }\n    }\n\n    int t = 0;\n    for (int i = 0; i < n; i++)\n        ans += 'a';\n\n    for (int i = 0; i < n; i++) {\n        bool flag = false;\n        for (int j = i; j < n; j++) {\n            if (ans[j] == 'a' && lcp[i][j] != 0) {\n                if (t >= 26)\n                    return \"\";\n                ans[j] = 'a' + t;\n                flag = true;\n            }\n        }\n        if (flag == true)\n            t++;\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (lcp[i][j] != 0 && ans[i] != ans[j])\n                return \"\";\n        }\n    }\n\n    return ans;\n} "], ["int findTheWinner(int n, int k) {\n    vector<int> v;\n    for (int i = 1; i <= n; i++) {\n        v.push_back(i);\n    }\n    int i = 0;\n    while (v.size() > 1) {\n        i = (i + k - 1) % v.size();\n        v.erase(v.begin() + i);\n    }\n    return v[0];\n}"], ["int minCostClimbingStairs(vector<int>& cost) {\n    int n = cost.size();\n    vector<int> dp(n);\n\n    dp[0] = cost[0];\n    dp[1] = cost[1];\n\n    for(int i = 2; i < n; i++){\n        dp[i] = min(dp[i-1], dp[i-2]) + cost[i];\n    }\n\n    return min(dp[n-1], dp[n-2]);\n}"], ["string addBinary(string a, string b) {\n    int c=0;\n    string s=\"\";\n    int i=0;\n    while(i<a.length() || i<b.length() || c!=0) {\n        int x=0;\n        if(i<a.length() && a[i]=='1')\n            x=1;\n        int y=0;\n        if(i<b.length() && b[i]=='1')\n            y=1;\n        s=to_string((x+y+c)%2)+s;\n        c=(x+y+c)/2;\n        i++;\n    }\n    return s;\n} "], ["int chalkReplacer(vector<int> chalk, int k) {\n    long long sum = 0;\n    for (int i = 0; i < chalk.size(); i++) {\n        sum += chalk[i];\n    }\n\n    if (k % sum == 0) {\n        return 0;\n    }\n\n    int x = k % sum;\n    for (int i = 0; i < chalk.size(); i++) {\n        x -= chalk[i];\n        if (x < 0) {\n            return i;\n        }\n    }\n\n    return 0;\n} "], ["int chalkReplacer(vector<int> chalk, int k) {\n    long long sum = 0;\n    for (int i = 0; i < chalk.size(); i++) {\n        sum += chalk[i];\n    }\n\n    if (k % sum != 0) {\n        int x = k % sum;\n        for (int i = 0; i < chalk.size(); i++) {\n            x -= chalk[i];\n            if (x < 0) {\n                return i;\n            }\n        }\n    }\n\n    return 0;\n} "], ["int alternatingSubarray(vector<int> v) {\n    int ans = 0;\n    int cnt = 1;\n    for(int i = 0; i < v.size() - 1; i += 1) {\n        bool flag = true;\n        for(int j = i + 1; j < v.size(); j += 1) {\n            if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;\n            flag = !flag;\n            cnt += 1;\n        }\n        ans = max(ans, cnt);\n        cnt = 1; // Reset cnt for the next subarray\n    }\n    return ans <= 1 ? -1 : ans;\n}"], ["string addStrings(string a, string b) {\n    string ret = \"\";\n    int carry = 0, i = a.size() - 1, j = b.size() - 1;\n    while (i >= 0 || j >= 0) {\n        int x = i >= 0 ? a[i--] - '0' : 0;\n        int y = j >= 0 ? b[j--] - '0' : 0;\n\n        int sm = x + y + carry;\n        ret.push_back('0' + (sm % 10));\n        carry = sm / 10;\n    }\n    if (carry)\n        ret.push_back('0' + carry);\n\n    reverse(ret.begin(), ret.end());\n\n    return ret;\n}"], ["int longestSubarray(vector<int> nums, int limit) {\n    int ans = 1, l = 0, h = 0, count = 0;\n    map<int, int> mp;\n    mp[nums[l]]++;\n\n    while (h < nums.size()) {\n        mp[nums[h]]++;\n        count++;\n\n        if (prev(mp.end())->first - mp.begin()->first <= limit) {\n            ans = max(ans, count);\n        } else {\n            while (prev(mp.end())->first - mp.begin()->first > limit && l < h) {\n                if (mp[nums[l]] > 1) {\n                    mp[nums[l]]--;\n                } else {\n                    mp.erase(nums[l]);\n                }\n                count--;\n                l++;\n            }\n        }\n        h++;\n    }\n    return ans;\n}"], ["int shortestPathLength(vector<vector<int>>& graph) {\n    int n = graph.size();\n    if (n == 1) return 0;\n    set<pair<int, int>> vis;\n    queue<pair<int, pair<int, int>>> q;\n    int all = (1 << n) - 1;\n    for (int i = 0; i < n; i++) {\n        int mask = 1 << i;\n        q.push({i, {0, mask}});\n        vis.insert({i, mask});\n    }\n    while (!q.empty()) {\n        int node = q.front().first;\n        int dist = q.front().second.first;\n        int mask = q.front().second.second;\n        q.pop();\n        for (auto it : graph[node]) {\n            int newMask = (mask | (1 << it));\n            if (newMask == all)\n                return dist + 1;\n            else if (vis.count({it, newMask}))\n                continue;\n            q.push({it, {dist + 1, newMask}});\n            vis.insert({it, newMask});\n        }\n    }\n    return 0;\n}"], [""], ["int searchInsert(vector<int>& nums, int target) {\n    int l = 0;\n    int r = nums.size() - 1;\n    int m;\n    while (l <= r) {\n        m = l + (r - l) / 2;\n        if (nums[m] == target) {\n            return m;\n        } else if (nums[m] > target) {\n            r = m - 1;\n        } else {\n            l = m + 1;\n        }\n    }\n    return l;\n}"], ["int findTheWinner(int n, int k) {\n    queue<int> q;\n    for(int i=1;i<=n;i++){\n        q.push(i);\n    }\n    \n    while(q.size() != 1){\n        int i = 1;\n        while(i < k){\n            int f = q.front();\n            q.pop();\n            q.push(f);\n            i++;\n        }\n        q.pop();\n    }\n\n    return q.front();\n}"], ["string longestCommonPrefix(vector<string> str) {\n    sort(str.begin(), str.end()); //sorting the array\n    string ans=\"\"; //creating a new empty string to store the common prefixes\n    int i = 0; //initialize i outside the loop\n    for(i=0;i<str[0].length();i++) { //change <= to <\n        if(str[0][i]!=str[str.size()-1][i]) { // checking the characters of the first and last string\n            break;\n        }\n        ans+=str[0][i]; \n    }\n    return ans;\n}"], [""], ["int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\nint shortestPathAllKeys(vector<string> grid) {\n    int m = grid.size();\n    int n = grid[0].size();\n    queue<pair<pair<int, int>, int>> que;\n    vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n    int target = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                target |= 1 << (grid[i][j] - 'a');\n                continue;\n            }\n            if (grid[i][j] == '@') {\n                que.emplace(pair<int, int>(i, j), 0);\n                mapKey[i][j] = 1;\n            }\n        }\n    }\n\n    int step = 0;\n    while (!que.empty()) {\n        int size = que.size();\n        for (int s = 0; s < size; s++) {\n            int i = que.front().first.first;\n            int j = que.front().first.second;\n            int key = que.front().second;\n            que.pop();\n\n            if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                key |= 1 << (grid[i][j] - 'a');\n                if (key == target)\n                    return step;\n\n                mapKey[i][j] |= 1l << key;\n            }\n\n            for (int d = 0; d < 4; d++) {\n                int newi = i + dir[d][0];\n                int newj = j + dir[d][1];\n\n                if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                    continue;\n\n                int val = grid[newi][newj];\n                if (val == '#')\n                    continue;\n\n                if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                    continue;\n\n                if (mapKey[newi][newj] & (1l << key))\n                    continue;\n\n                mapKey[newi][newj] |= 1l << key;\n                que.emplace(pair<int, int>(newi, newj), key);\n            }\n        }\n        step++;\n    }\n    return -1;\n}"], ["int lengthOfLIS(vector<int> nums) {\n    int n = nums.size();\n    if (n == 0) {\n        return 0;\n    }\n    vector<int> dp(n, 1);\n    int maxLength = 1;\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n        maxLength = max(maxLength, dp[i]);\n    }\n    return maxLength;\n}"], ["int maxProfit(vector<int>& prices, int fee) {\n    int n = prices.size();\n    if (n <= 1) return 0;\n    int buy = -prices[0];\n    int sell = 0;\n    for (int i = 1; i < n; i++) {\n        int prevBuy = buy;\n        buy = max(buy, sell - prices[i]);\n        sell = max(sell, prevBuy + prices[i] - fee);\n    }\n    return sell;\n} "], ["int maxStarSum(vector<int> vals, vector<vector<int>> edges, int k) \n{\n    int n = vals.size();\n    vector<vector<pair<int, int>>> adj(n);\n    for (vector<int> edge : edges)\n    {\n        int startNode = edge[0], startNodeVal = vals[startNode];\n        int endNode = edge[1], endNodeVal = vals[endNode];\n        adj[startNode].push_back({endNodeVal, endNode});\n        adj[endNode].push_back({startNodeVal, startNode});\n    }\n    \n    int mxSum = INT_MIN;\n    for (int node = 0; node < n; node++)\n    {\n        sort(adj[node].begin(), adj[node].end(), greater<pair<int, int>>()); // sort the neighbors based on decreasing \"values\"\n        int neighborSize = adj[node].size();\n        int sum = vals[node];\n        for (int i = 0; i < min(k, neighborSize); i++) // iterate over the first k neighbors\n        {\n            int val = adj[node][i].first;\n            if (val < 0) break; // if value of neighbor is < 0, it would decrease sum so \"break\", \n                                // as the neighbors left to it would also have negative values\n            sum += val;\n        }\n        mxSum = max(mxSum, sum);\n    }\n    \n    return mxSum;\n} "], ["int mostFrequentEven(vector<int> nums) {\n    int n = nums.size();\n    map<int, int> freq;\n    for(auto x : nums) {\n        freq[x]++;\n    }\n    int evefreq = 0, ans = -1;\n    for(auto y : freq) {\n        if(y.first % 2 == 0 && y.second > evefreq) {\n            ans = y.first;\n            evefreq = y.second;\n        }\n    }\n    return ans;\n}"], ["const int inf = 0x3f3f3f3f;\nint minimumIncompatibility(vector<int> nums, int k) {\n  int n = nums.size();\n  int sz = n/k; // size of every group\n  sort(nums.begin(), nums.end());\n  int dp[1<<n][n+1];  \n  memset(dp, inf, sizeof(dp));\n  for (int i = 0; i <= n; ++i) { dp[0][i] = 0; }  \n  for (int m = 0; m < (1<<n)-1; ++m) {\n    int cnt = __builtin_popcount(m);\n    for (int i = 0; i <= n; ++i) {  \n      if (dp[m][i] == inf) { continue; }\n      if (cnt%sz == 0) {\n        int j = __builtin_ffs(~m)-1;\n        dp[m|(1<<j)][j] = dp[m][i] + nums[j] - nums[i]; // Fixed code\n      } else {\n        for (int j = i+1; j <= n; ++j) { \n          if (m&(1<<j) || nums[j] == nums[i]) { continue; }\n          dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);\n        }\n      }\n    }\n  }\n  return dp[(1<<n)-1][n] == inf? -1: dp[(1<<n)-1][n];  \n}"], [""], ["string longestCommonPrefix(vector<string> str) \n{\n    sort(str.begin(), str.end()); //sorting the array\n    string ans=\"\"; //creating a new empty string to store the common prefixes\n    for(int i=0;i<str[0].length();i++) \n    {\n        if(str[0][i]!=str[str.size()-1][i]) \n            break;\n        ans+=str[0][i]; // concatenate if the characters are matching\n    }\n    return ans;\n}"], [""], ["int minDifference(vector<int> nums) {\n    if(nums.size() <= 4) return 0;\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    return min({nums[n - 4] - nums[0], nums[n - 1] - nums[3], nums[n - 3] - nums[1], nums[n - 2] - nums[2]});\n} "], ["int closetTarget(vector<string> words, string target, int startIndex) {\n    int n = words.size();\n    int ind = find(words.begin(), words.end(), target) - words.begin();\n    if (ind == n) return -1;\n    if (words[startIndex] == target) return 0;\n    \n    int i = startIndex - 1;\n    int j = startIndex + 1;\n    int cnt1 = 0;\n    int cnt2 = 0;\n    \n    while (true) {\n        cnt1++;\n        cnt2++;\n        \n        if ((i >= 0 && words[i % n] == target) || words[(n + i) % n] == target) {\n            return cnt1;\n        }\n        \n        if ((j < n && words[j % n] == target) || words[(n + j) % n] == target) {\n            return cnt2;\n        }\n        \n        i--;\n        j++;\n    }\n    \n    return -1; \n}"], ["int maxWidthOfVerticalArea(vector<vector<int>> points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n} "], ["int distanceBetweenBusStops(vector<int> distance, int start, int destination) {\n    int dis1 = 0, dis2 = 0;\n\n    // Swapping the values of start and destination, if destination is smaller than start\n    if (start > destination) {\n        swap(start, destination);\n    }\n\n    // Checking Forward distance\n    for (int i = start; i < destination; i++) {\n        dis1 += distance[i];\n    }\n\n    // Checking Backward distance\n    for (int i = destination; i < start + distance.size(); i++) {\n        dis2 += distance[i % distance.size()];\n    }\n\n    // Result\n    return min(dis1, dis2);\n}"], ["int numTrees(int n) {\n    vector<int> dp(n + 1, 0);\n    dp[0] = dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= i; j++) {\n            dp[i] += dp[j - 1] * dp[i - j];\n        }\n    }\n    return dp[n];\n} "], ["string reverseVowels(string s) {\n    vector<char> v;\n    for(int i = 0 ; i < s.length(); i++)\n    {\n        if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n          || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U')\n            v.push_back(s[i]);\n    }\n    reverse(v.begin(), v.end());\n    int rev = 0;\n    for(int i = 0 ; i < s.length(); i++)\n    {\n        if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n          || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U'){\n            s[i] = v[rev];\n            rev++;\n        }\n    }\n    return s;\n}"], ["int partitionString(string s) {\n    set<char> st;\n    int g = 0;\n    for (int i = 0; i < s.size(); i++) {\n        if (st.find(s[i]) != st.end()) {\n            st.clear();\n            st.insert(s[i]);\n            g++;\n        }\n        else {\n            st.insert(s[i]);\n        }\n    }\n    return g + 1;\n}"], ["double trimMean(vector<int> arr) {\n    int k = 0.05 * arr.size();\n    sort(arr.begin(), arr.end());\n    arr.erase(arr.begin(), arr.begin() + k);\n    arr.erase(arr.end() - k, arr.end());\n    double mean = accumulate(arr.begin(), arr.end(), 0) / static_cast<double>(arr.size());\n    return mean;\n} "], ["int maxLengthBetweenEqualCharacters(string s) {\n    int v[26];\n    memset(v,-1,sizeof v);\n    int ans=-1;\n    for(int i=0;i<s.size();i++){\n        if(v[s[i]-'a']==-1){\n            v[s[i]-'a']=i;\n        }\n        else{\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        }\n    }\n    return ans;\n} "], ["int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto& p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n}"], ["int minNumber(vector<int> nums1, vector<int> nums2) {\n    map<int,int> mp;\n    for(auto x: nums1) mp[x]++;\n    for(auto x: nums2) mp[x]++;\n    int mn1 = *min_element(nums1.begin(), nums1.end()); \n    int mn2 = *min_element(nums2.begin(), nums2.end());\n    for(auto x: mp){\n        if(x.second > 1 && (x.first == mn1 || x.first == mn2)) {\n            return x.first;\n        }\n    }\n    string s;\n    if(mn1 < mn2) {\n        s = to_string(mn1) + to_string(mn2);\n    } else {\n        s = to_string(mn2) + to_string(mn1);\n    }\n    return stoi(s);\n}"], ["int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\nint shortestPathAllKeys(vector<string> grid) {\n    int m = grid.size();\n    int n = grid[0].size();\n    queue<pair<pair<int, int>, int>> que;\n    vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n    int target = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                target |= 1 << (grid[i][j] - 'a');\n                continue;\n            }\n\n            if (grid[i][j] == '@') {\n                que.emplace(pair<int, int>(i, j), 0);\n                mapKey[i][j] = 1;\n            }\n        }\n    }\n\n    int step = 0;\n    while (!que.empty()) {\n        int size = que.size();\n        for (int s = 0; s < size; s++) {\n            int i = que.front().first.first;\n            int j = que.front().first.second;\n            int key = que.front().second;\n            que.pop();\n            \n            if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                key |= 1 << (grid[i][j] - 'a');\n                if (key == target)\n                    return step;\n\n                mapKey[i][j] |= 1l << key;\n            }\n\n            for (int d = 0; d < 4; d++) {\n                int newi = i + dir[d][0];\n                int newj = j + dir[d][1];\n                \n                if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                    continue;\n                    \n                int val = grid[newi][newj];\n                if (val == '#')\n                    continue;\n                    \n                if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                    continue;\n                    \n                if (mapKey[newi][newj] & (1l << key))\n                    continue;\n                    \n                mapKey[newi][newj] |= 1l << key;\n                que.emplace(pair<int, int>(newi, newj), key);\n            }\n        }\n        step++;\n    }\n    return -1;\n}"], ["string makeLargestSpecial(string s) {\n    if(s.length()==0)\n        return \"\";\n\n    vector<string> ans;\n    int count=0,i=0;\n\n    for(int j=0;j<s.size();j++){\n        if(s[j] == '1')\n            count++;\n        else\n            count--;\n\n        if(count==0){\n            ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0');\n            i = j+1;\n        }\n    }\n\n    sort(ans.begin(),ans.end(),greater<string>());\n    string finalString = \"\";\n    for(i=0;i<ans.size();i++){\n        finalString += ans[i];\n    }\n    return finalString;\n}"], ["int longestSubarray(vector<int> nums, int limit) {\n    int ans = 1, l = 0, h = 1, count = 1;\n    map<int, int> mp;\n    mp[nums[l]]++;\n\n    while (h < nums.size()) {\n        mp[nums[h]]++;\n        count++;\n\n        if (prev(mp.end())->first - mp.begin()->first <= limit) { // checking the diff \n            ans = max(ans, count); // giving the size of subarray that may make our answer\n        } else {\n            // If diff is more than limit then we'll start deleting the indexes from left side until we get the max and minimum value such that diff is in range\n            while (prev(mp.end())->first - mp.begin()->first > limit && l < h) {\n                if (mp[nums[l]] > 1) {\n                    mp[nums[l]]--;\n                } else {\n                    mp.erase(nums[l]);\n                }\n                count--;\n                l++;\n            }\n        }\n        h++;\n    }\n    return ans;\n}"]]