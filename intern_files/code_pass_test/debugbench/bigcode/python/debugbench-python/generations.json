[["def maximumNumber(num: str, change: List[int]) -> str:\n    num = list(num)\n    on = False \n    for i, ch in enumerate(num): \n        x = int(ch)\n        if x < change[x]: \n            on = True\n            num[i] = str(change[x])\n        elif x > change[x] and on: \n            break\n    return \"\".join(num)\n"], [""], ["def findAllRecipes(recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n    from collections import defaultdict\n    \n    dct = defaultdict(lambda: [])\n    indegree = {}\n    n = len(recipes)\n\n    for i in recipes:\n        indegree[i] = 0\n\n    for i in range(n):\n        for j in ingredients[i]:\n            indegree[j] = 0\n\n    for i in range(n):\n        for j in ingredients[i]:\n            dct[j].append(recipes[i])\n            indegree[recipes[i]] += 1\n\n    st = []\n    for i in indegree:\n        if indegree[i] == 0:\n            st.append(i)\n    \n    flst = []\n    ans = defaultdict(lambda: [])\n    while st:\n        x = st.pop(0)\n        for i in dct[x]:\n            for j in ans[x]:\n                if j not in ans[i]:\n                    ans[i].append(j)\n            ans[i].append(x)\n            indegree[i] -= 1\n            if indegree[i] == 0:\n                st.append(i)\n        if x in recipes:\n            for k in ans[x]:\n                if k not in supplies:\n                    break\n            else:\n                flst.append(x)\n                supplies.append(x)\n\n    return flst\n"], [""], ["def isTransformable(s: str, t: str) -> bool:\n    indexes = collections.defaultdict(collections.deque)\n    for index, character in enumerate(s):\n        indexes[int(character)].append(index)\n    unique_t_values = set([int(t_i) for t_i in t])\n    for t_v in unique_t_values:\n        if t_v not in indexes:\n            return False\n    for character in t:\n        character_designation = int(character)\n        if character_designation not in indexes:\n            return False\n        for lesser_character in range(character_designation):\n            if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0]:\n                return False\n        indexes[character_designation].popleft()\n        if len(indexes[character_designation]) == 0:\n            indexes.pop(character_designation)\n    return True\n"], ["def areAlmostEqual(s1: str, s2: str) -> bool:\n    if len(s1) != len(s2):\n        return False\n    if s1 == s2:\n        return True\n    diff = []\n    for i in range(len(s1)):\n        if s1[i] != s2[i]:\n            diff.append([s1[i], s2[i]])\n    if len(diff) == 2 and diff[0] == diff[1][::-1]:\n        return True\n    else:\n        return False\n"], ["def isPossibleToCutPath(grid: List[List[int]]) -> bool:\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (0, 1)]  # Fix the direction list\n\n    def dfs(i: int, j: int) -> None:\n        grid[i][j] = 2\n        for di, dj in dirs:\n            if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1:\n                dfs(i + di, j + dj)\n\n    dfs(0, 0)  # Start the dfs from (0, 0)\n\n    dq = collections.deque([(m - 1, n - 1)])  # Start the bfs from (m-1, n-1)\n    grid[m - 1][n - 1] = 0  # Set the value of (m-1, n-1) to 0\n    while dq:\n        i, j = dq.popleft()\n        if i == 0 and j == 0:  # If we reach (0, 0), return True\n            return True\n        for di, dj in dirs:\n            if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2:\n                dq.append((i + di, j + dj))\n                grid[i + di][j + dj] = 0\n\n    return False  # If we cannot reach (0, 0), return False\n\n"], [""], ["def maxAbsValExpr(arr1: List[int], arr2: List[int]) -> int:\n    val1,val2,val3,val4=[],[],[],[]\n    for i in range(len(arr1)):\n        val1.append(arr1[i]+arr2[i]+i)\n        val2.append(arr1[i]-arr2[i]+i)\n        val3.append(-arr1[i]+arr2[i]+i)\n        val4.append(-arr1[i]-arr2[i]+i)\n    ans=0\n    ans=max(ans,max(val1)-min(val1))\n    ans=max(ans,max(val2)-min(val2))\n    ans=max(ans,max(val3)-min(val3))\n    ans=max(ans,max(val4)-min(val4))\n    return ans\n"], ["def minCost(grid: List[List[int]]) -> int:\n    m, n, cost, queue = len(grid), len(grid[0]), 0, deque()\n    M, N = range(m), range(n)\n\n    seen = lambda x,y : not x in M or not y in N or not grid[x][y]\n    dir = ((),(0,1), (0,-1), (1,0), (-1,0))\n\n    def dfs(x: int,y: int)->None:\n        while not seen(x,y):\n            (dx,dy), grid[x][y] = dir[grid[x][y]], None\n            queue.append((x,y))\n            x,y = x+dx, y+dy\n        return\n\n    dfs(0, 0)\n\n    while queue:\n        if (m-1, n-1) in queue: return cost\n        cost += 1\n        q = len(queue)\n\n        for _ in range(q):\n            x, y = queue.popleft()\n            for dx,dy in dir[1:]:\n                dfs(x+dx, y+dy)\n\n    return cost\n"], [""], ["def maxProfit(prices: List[int]) -> int:\n    if len(prices) < 2:\n        return 0\n    \n    profit = 0\n    stockBuy = prices[0]\n    \n    for i in range(1, len(prices)):\n        if prices[i] > stockBuy:\n            profit += prices[i] - stockBuy\n        stockBuy = prices[i]\n    \n    return profit\n"], ["from typing import List\nimport collections\n\ndef findSubstring(s: str, words: List[str]) -> List[int]:\n    wlen = len(words[0])\n    slen = wlen * len(words)\n    track = dict()\n    occ = collections.Counter(words)\n\n    def test():\n        for key, val in track.items():\n            if val != occ[key]:\n                return False\n        return True\n\n    res = []\n\n    for k in range(wlen):\n        for i in words:\n            track.update({i: 0})\n        for i in range(k, slen + k, wlen):\n            w = s[i:i + wlen]\n            if w in words:\n                track.update({w: track[w] + 1})\n        if test():\n            res.append(k)\n\n        for i in range(wlen + k, len(s) - slen + 1, wlen):\n            nw = s[i + slen - wlen:i + slen]\n            pw = s[i - wlen:i]\n            if nw in words:\n                track.update({nw: track[nw] + 1})\n            if pw in words:\n                track.update({pw: track[pw] - 1})\n            if test():\n                res.append(i)\n    \n    return res"], ["def findTheString(lcp: List[List[int]]) -> str:\n    # simple validation\n    n = len(lcp)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lcp[i][j] != lcp[j][i]:\n                return ''\n            if lcp[i][j] > n - j:\n                return ''\n    for i in range(n):\n        if lcp[i][i] != n - i:\n            return ''\n    \n    # build pattern - the only possible candidate for answer\n    pattern = [None for _ in range(n)]\n    next_el_ind = 0\n    for i in range(n):\n        if pattern[i] is not None:\n            continue\n        pattern[i] = next_el_ind\n        next_el_ind += 1\n        for j in range(i+1, n):\n            if lcp[i][j] > 0:\n                if pattern[j] is not None and pattern[j] != pattern[i]:\n                    return ''\n                pattern[j] = pattern[i]\n\n    # check if lcp is valid - check that pattern's lcp == original lcp\n    pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            if pattern[i] == pattern[j]:\n                if max(i, j) + 1 < n:\n                    pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                else:\n                    pattern_lcp[i][j] = 1\n    for i in range(n):\n        for j in range(n):\n            if lcp[i][j] != pattern_lcp[i][j]:\n                return ''\n\n    # check that answer has no more than 26 distinct elements\n    if max(pattern) > ord('z') - ord('a'):\n        return ''\n\n    return ''.join(chr(ord('a') + ind) for ind in pattern)"], ["def plusOne(digits: List[int]) -> List[int]:\n    carry = 1\n    for i in range(len(digits)-1, -1, -1):\n        digits[i] += carry\n        carry = digits[i] // 10\n        digits[i] %= 10\n    if carry:\n        digits.insert(0, carry)\n    return digits\n"], [""], [""], [""], [""], [""], [""], ["def getMinDistance(nums: List[int], target: int, start: int) -> int:\n    curVal = len(nums)\n    for i in range(start, len(nums)):\n        if nums[i] == target:\n            curVal = min(curVal, abs(i - start))\n            break\n    j = start\n    while j >= 0:\n        if nums[j] == target:\n            curVal = min(curVal, abs(j - start))\n            break\n        j -= 1\n    return curVal\n"], [""], ["def canThreePartsEqualSum(arr: List[int]) -> bool:\n    total = sum(arr)\n    each_sum = total // 3\n    if total % 3 != 0:\n        return False\n    sumi = count = 0\n    for x in arr:\n        sumi += x\n        if sumi == each_sum:\n            sumi = 0\n            count += 1\n        if count == 2:\n            return True\n    return False\n"], [""], [""], [""], ["def sortString(s: str) -> str:\n    freq = {}\n    letters = sorted(set(s))\n    res = \"\"\n    for i in s:\n        if i in freq:\n            freq[i]+=1\n        else:\n            freq[i] = 1\n    while freq:\n        for i in letters:\n            if i in freq:\n                if freq[i]>0:\n                    res+=i\n                    freq[i]-=1\n                    if freq[i] == 0:\n                        del freq[i]\n        for i in letters[::-1]:\n            if i  in freq:\n                if freq[i]>0:\n                    res+=i\n                    freq[i]-=1\n                    if freq[i] == 0:\n                        del freq[i]\n    return res\n"], [""], [""], ["def maxPerformance(n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n    MOD = 10**9 + 7\n\n    top_k_speeds = []\n    res, top_k_sum = 0, 0\n\n    pairs = [(e, s) for e, s in zip(efficiency, speed)]\n    pairs.sort(reverse=True)  # Sort in descending order of efficiency\n\n    for e, s in pairs:\n        heapq.heappush(top_k_speeds, s)\n        top_k_sum += s\n\n        if len(top_k_speeds) > k:\n            top_k_sum -= heapq.heappop(top_k_speeds)\n\n        res = max(res, e * top_k_sum)\n    \n    return res % MOD\n"], [""], [""], ["def sumSubarrayMins(arr: List[int]) -> int:\n    stack = []\n    res = 0\n    arr = [float('-inf')] + arr + [float('-inf')]\n    for i, num in enumerate(arr):\n        while stack and arr[stack[-1]] > num:\n            cur = stack.pop()\n            res += arr[cur] * (i - cur) * (cur - stack[-1])\n        stack.append(i)\n    return res % (10**9 + 7)\n"], ["def canEat(candiesCount: List[int], queries: List[List[int]]) -> List[bool]:\n    prefix = [0]\n    for x in candiesCount: \n        prefix.append(prefix[-1] + x) # prefix sum \n    answer = []\n    for t, day, cap in queries:\n        min_candies = prefix[t] // cap\n        max_candies = prefix[t+1]\n        answer.append(min_candies <= day < max_candies)\n    return answer\n"], ["def isIsomorphic(s: str, t: str) -> bool:\n    if len(s) != len(t):\n        return False\n    \n    mapping = {}\n    mapped_chars = set()\n    \n    for i in range(len(s)):\n        if s[i] in mapping:\n            if mapping[s[i]] != t[i]:\n                return False\n        else:\n            if t[i] in mapped_chars:\n                return False\n            mapping[s[i]] = t[i]\n            mapped_chars.add(t[i])\n    \n    return True\n"], [""], [""], ["def minimumDifference(nums: List[int], k: int) -> int:\n    nums.sort()\n    min_diff = float(\"inf\")\n    for i in range(len(nums) - k + 1):\n        min_diff = min(min_diff, nums[i+k-1] - nums[i])\n    return min_diff\n"], ["def findComplement(num: int) -> int:\n    com = ''\n    while num > 0 :\n        if num % 2 == 1:\n            com += '0'\n        else:\n            com += '1'\n        num = num // 2\n    return int(com[::-1], 2)"], ["def reachableNodes(n: int, edges: List[List[int]], restricted: List[int]) -> int:\n    adj_list = defaultdict(list)\n    for x, y in edges:\n        adj_list[x].append(y)\n        adj_list[y].append(x)\n\n    que = deque()\n    que.append(0)\n    result = 0\n    visited = set()\n    for node in restricted:\n        visited.add(node)\n\n    while que:\n        cur = que.popleft()\n        if cur in visited:\n            continue    \n        visited.add(cur)\n        result += 1\n        print(\"Current node:\", cur)  # Fixed the bug by using print instead of Console.WriteLine\n        for node in adj_list[cur]:\n            que.append(node)\n    \n    return result\n"], [""], ["def minimumPartition(s: str, k: int) -> int:\n    curr, ans = 0, 1\n    for d in s:\n        if int(d) > k:\n            return -1\n        curr = 10 * curr + int(d)\n        if curr > k:\n            ans += 1\n            curr = int(d)\n    return ans\n"], [""], [""], ["def findAllRecipes(recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n    from collections import defaultdict\n\n    dct = defaultdict(list)\n    indegree = defaultdict(int)\n    n = len(recipes)\n\n    for i in recipes:\n        indegree[i] = 0\n\n    for i in range(n):\n        for j in ingredients[i]:\n            indegree[j] = 0\n\n    for i in range(n):\n        for j in ingredients[i]:\n            dct[j].append(recipes[i])\n            indegree[recipes[i]] += 1\n\n    st = []\n    for i in indegree:\n        if indegree[i] == 0:\n            st.append(i)\n\n    flst = []\n    ans = defaultdict(list)\n    while st:\n        x = st.pop(0)\n        for i in dct[x]:\n            for j in ans[x]:\n                if j not in ans[i]:\n                    ans[i].append(j)\n            ans[i].append(x)\n            indegree[i] -= 1\n            if indegree[i] == 0:\n                st.append(i)\n        if x in recipes:\n            for k in ans[x]:\n                if k not in supplies:\n                    break\n            else:\n                flst.append(x)\n                supplies.append(x)\n\n    return flst\n"], ["def isReachable(targetX: int, targetY: int) -> bool:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    d = gcd(targetX, targetY)\n    while d != 1:\n        if d & 1:\n            return False\n        d >>= 1\n    return True\n"], ["import math\n\ndef calPoints(operations: List[str]) -> int:\n    stack = []\n    for i in operations:\n        if i == 'D':\n            stack.append(2 * stack[-1])\n        elif i == 'C':\n            stack.pop()\n        elif i == '+':\n            stack.append(stack[-1] + stack[-2])\n        else:\n            stack.append(int(i))\n    return sum(stack)\n"], [""], [""], ["def sortArray(self, nums: List[int]) -> List[int]:\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        merged = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged\n\n    def mergeSort(nums: List[int]) -> List[int]:\n        if len(nums) <= 1:\n            return nums\n        mid = len(nums) // 2\n        left = mergeSort(nums[:mid])\n        right = mergeSort(nums[mid:])\n        return merge(left, right)\n\n    return mergeSort(nums)\n"], [""], [""], ["def findMaxK(nums: List[int]) -> int:\n    nums = sorted(nums, reverse=True)\n    s = set(nums)\n    for i in range(len(nums)):\n        if -nums[i] in s:\n            return nums[i]\n    return -1\n"], ["def selfDividingNumbers(left: int, right: int) -> List[int]:\n    res = []\n    for i in range(left, right + 1):\n        ch = True\n        for j in str(i):\n            if j != '0':\n                if i % int(j) != 0:\n                    ch = False\n                    break\n            else:\n                ch = False\n                break\n        if ch:\n            res.append(i)\n    return res\n"], ["def findMiddleIndex(nums: List[int]) -> int:\n    def dnc(l, r, lo, hi):\n        if l == r - 1:\n            return l if lo == hi else -1\n        \n        mid = (l + r) // 2\n        right = sum(nums[mid+1:r]) # Adjusted the range for right sum\n        left = sum(nums[l:mid])\n        \n        left_ind = dnc(l, mid, lo, hi + right) # Removed the \"var\" keyword\n        return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)\n    return dnc(0, len(nums), 0, 0)\n"], ["def canPlaceFlowers(flowerbed: List[int], n: int) -> bool:\n    flowerbed = [0] + flowerbed + [0]\n    for i in range(1, len(flowerbed)-1):\n        if flowerbed[i] == 0 and flowerbed[i+1] == 0 and flowerbed[i-1] == 0:\n            flowerbed[i] = 1\n            n -= 1\n        elif flowerbed[i] == 1:\n            n -= 1\n    if n <= 0:\n        return True\n    return False\n"], [""], ["def fib(n: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    Fib = [-1 for _ in range(n+1)]\n    Fib[0] = 0\n    Fib[1] = 1\n    return fib_helper(n, Fib)\n\ndef fib_helper(n, Fib):\n    if Fib[n] != -1:\n        return Fib[n]\n    Fib[n] = fib_helper(n-1, Fib) + fib_helper(n-2, Fib)\n    return Fib[n]"], [""], [""], [""], [""], [""], [""], [""], ["from typing import List\n\ndef maxAbsValExpr(arr1: List[int], arr2: List[int]) -> int:\n    val1,val2,val3,val4=[],[],[],[]\n    for i in range(len(arr1)):\n        val1.append(i+arr1[i]+arr2[i])\n        val2.append(i+arr1[i]-arr2[i])\n        val3.append(i-arr1[i]+arr2[i])\n        val4.append(i-arr1[i]-arr2[i])\n    ans=0\n    ans=max(ans,max(val1)-min(val1))\n    ans=max(ans,max(val2)-min(val2))\n    ans=max(ans,max(val3)-min(val3))\n    ans=max(ans,max(val4)-min(val4))\n    return ans\n"], ["def nextGreaterElement(nums1: List[int], nums2: List[int]) -> List[int]:\n    out=[]\n    for i in range(0,len(nums1)):\n        if(nums2.index(nums1[i])==len(nums2)-1):\n            out.append(-1)\n        else:\n            j=nums2.index(nums1[i])+1\n            while(j < len(nums2)):\n                if(nums1[i]<nums2[j]):\n                    out.append(nums2[j])\n                    break\n                if(j==len(nums2)-1):\n                    out.append(-1)\n                    break\n                j+=1\n    return out\n"], ["def canThreePartsEqualSum(arr: List[int]) -> bool:\n    total = sum(arr)\n    each_sum = total//3\n    if total % 3 != 0: \n        return False\n    sumi = count = 0\n    for x in arr:\n        sumi += x\n        if sumi == each_sum:\n            sumi = 0\n            count += 1\n        if count == 2:\n            return True\n    return False\n"], [""], [""], ["def sortArray(nums: List[int]) -> List[int]:\n    def mergeSort(nums):\n        if len(nums) <= 1:\n            return nums\n        \n        mid = len(nums) // 2\n        left = mergeSort(nums[:mid])\n        right = mergeSort(nums[mid:])\n        \n        return merge(left, right)\n    \n    def merge(left, right):\n        result = []\n        i = j = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        \n        result.extend(left[i:])\n        result.extend(right[j:])\n        \n        return result\n    \n    return mergeSort(nums)"], ["from collections import defaultdict\nfrom typing import List\n\ndef fourSumCount(nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n    dictionary = defaultdict(int)\n    for n1 in nums1:\n        for n2 in nums2:\n            numberNeeded = -(n1 + n2)\n            dictionary[numberNeeded] += 1\n            \n    numberOfTuples = 0\n    for n3 in nums3:\n        for n4 in nums4:\n            numberOfTuples += dictionary[n3 + n4]\n        \n    return numberOfTuples"], [""], ["from functools import lru_cache\nfrom itertools import chain\nfrom typing import List\n\ndef minCost(n: int, cuts: List[int]) -> int:\n    cuts = sorted(chain(cuts, [0, n]))\n\n    @lru_cache(None)\n    def dfs(l, r):\n        length, M = cuts[r] - cuts[l], range(l + 1, r)\n        return min((dfs(l, i) + dfs(i, r) for i in M), default=-length) + length\n\n    return dfs(0, len(cuts) - 1)"], ["def fizzBuzz(n: int) -> List[str]:\n    l = []\n    for i in range(1,n+1):\n        if i%3==0 and i%5==0:\n            l.append(\"FizzBuzz\")\n        elif i%3==0:\n            l.append(\"Fizz\")\n        elif i%5==0:\n            l.append(\"Buzz\")\n        else:\n            l.append(str(i))\n    return l\n"], [""], ["def longestValidSubstring(word: str, forbidden: List[str]) -> int:\n    trie = {}\n    for f in forbidden:\n        t = trie\n        for c in f:\n            if c not in t:\n                t[c] = {}\n            t = t[c]\n        t[\"end\"] = True\n    \n    def isForbidden(s):\n        t = trie\n        counter = 0\n        for c in s:\n            if c not in t:\n                return False\n            t = t[c]\n            counter += 1\n            if \"end\" in t:\n                return counter\n        return False\n    \n    res = 0\n    j = len(word)\n    for i in range(len(word) - 1, -1, -1):\n        truc = isForbidden(word[i:j])\n        if truc:\n            j = i + truc - 1\n            # Remove the undefinedFunction call\n        res = max(res, j - i)\n    return res\n"], [""], [""], [""], ["def isPossible(n: int, edges: list[list[int]]) -> bool:\n    neighbors = [set() for _ in range(n)]\n    for edge in edges:\n        a, b = edge\n        a -= 1\n        b -= 1\n        neighbors[a].add(b)\n        neighbors[b].add(a)\n    oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\n    numOdd = len(oddDegreesNodes)\n    if numOdd == 0:\n        return True\n    elif numOdd == 4:\n        # Only possible if there are two pairs of vertices which are not connected\n        o1, o2, o3, o4 = oddDegreesNodes\n        return checkOddNeighbors(neighbors, o1, o2, o3, o4)\n    elif numOdd == 2:\n        # Only possible if both not connected or both connected but there is another node to connect to\n        o1, o2 = oddDegreesNodes\n        if o1 not in neighbors[o2]:\n            # Case 1: Not connected\n            return True\n        # Case 2\n        bothConnectedTo = neighbors[o1] & neighbors[o2]\n        # Oops, no other node to connect to!\n        return len(bothConnectedTo) != n\n    return False\n\ndef checkOddNeighbors(neighbors, o1, o2, o3, o4):\n    if o3 in neighbors[o1] or o4 in neighbors[o2]:\n        return True\n    if o4 in neighbors[o1] or o3 in neighbors[o2]:\n        return True\n    return False\n"], ["def validPartition(nums: List[int]) -> bool:\n    checks = (True, False, nums[0] == nums[1])\n    \n    for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\n        checks = (checks[1], checks[2],\n                  (checks[1] and curr == prev1) or\n                  (checks[0] and curr == prev1 == prev2) or\n                  (checks[0] and curr == prev1+1 == prev2+2))   \n    \n    return checks[2]"], [""], [""], ["def minimumObstacles(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    q = collections.deque([(0, 0, 0)])\n    while q:\n        d, i, j = q.popleft()\n        if i == m - 1 and j == n - 1: return d\n        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ci, cj = i + di, j + dj\n            if 0 <= ci < m and 0 <= cj < n:\n                if d + grid[ci][cj] < distance[ci][cj]:\n                    distance[ci][cj] = d + grid[ci][cj]\n                    if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                    else: q.appendleft((distance[ci][cj], ci, cj))\n    return distance[m - 1][n - 1]"], ["def componentValue(nums: List[int], edges: List[List[int]]) -> int:\n    tree = [[] for _ in nums]\n    for u, v in edges: \n        tree[u].append(v)\n        tree[v].append(u)\n    \n    def fn(u, p):\n        \"\"\"Post-order dfs.\"\"\"\n        ans = nums[u]\n        for v in tree[u]: \n            if v != p: ans += fn(v, u)  # Removed 'self.' before 'fn(v, u)'\n        return 0 if ans == cand else ans\n    \n    total = sum(nums)\n    for cand in range(1, total//2+1): \n        if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\n    return 0\n"], ["def nextGreaterElement(nums1: List[int], nums2: List[int]) -> List[int]:\n    l = []\n    for i in nums1:\n        count = 0\n        for j in range(nums2.index(i), len(nums2)):\n            if nums2[j] > i:\n                l.append(nums2[j])\n                count += 1\n                break\n        if count == 0:\n            l.append(-1)\n    return l\n"], ["def fizzBuzz(n: int) -> List[str]:\n    arr=[]\n    for i in range(1, n+1):\n        if i % 3 == 0 and i % 5 == 0:\n            arr.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            arr.append(\"Fizz\")\n        elif i % 5 == 0:\n            arr.append(\"Buzz\")\n        else:\n            arr.append(str(i))\n    return arr\n"], ["def longestWPI(A):\n    curr, ans, D = 0, 0, {}\n    for e, i in enumerate(A):\n        curr += 1 if i > 8 else -1\n        D[curr] = D.get(curr, e)\n        ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 1, e))\n    return ans\n"], [""], ["def findPeakElement(nums: List[int]) -> int:\n    n = len(nums)\n    low = 0\n    high = n - 1\n    \n    if n == 1:\n        return 0\n    \n    while low <= high:\n        mid = (low + high) // 2\n        \n        if (mid == 0 or nums[mid] >= nums[mid - 1]) and (mid == n - 1 or nums[mid] >= nums[mid + 1]):\n            return mid\n        elif nums[mid] < nums[mid + 1]:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return -1\n"], ["def distributeCandies(candyType: List[int]) -> int:\n    return min(len(candyType)//2, len(set(candyType)))"], ["def numMagicSquaresInside(grid: List[List[int]]) -> int:\n    M, N = len(grid), len(grid[0])\n    res = 0\n\n    solution = [((2, 7, 6), (9, 5, 1), (4, 3, 8)), ((3, 5, 7), (8, 1, 6), (4, 9, 2)), ((1, 5, 9), (8, 3, 4), (6, 7, 2)), ((6, 1, 8), (7, 5, 3), (2, 9, 4)), ((9, 4, 2), (7, 3, 5), (6, 1, 8))]\n\n    for i in range(M-2):\n        for j in range(N-2):\n            arr = []\n\n            for k in range(3):\n                if k + i >= M:\n                    break\n                arr.append(tuple(grid[i + k][j:j + 3]))\n            \n            arr.sort(key=lambda x: x[0])\n\n            if tuple(arr) in solution:\n                res += 1\n            else:\n                for row in arr:\n                    row = row[::-1]\n\n                if tuple(arr) in solution:\n                    res += 1\n    \n    return res\n"], ["def sortString(s: str) -> str:\n    freq = {}\n    letters = sorted(set(s))\n    res = \"\"\n    for i in s:\n        if i in freq:\n            freq[i] += 1\n        else:\n            freq[i] = 1\n    while freq:\n        for i in letters:\n            if i in freq and freq[i] > 0:\n                res += i\n                freq[i] -= 1\n                if freq[i] == 0:\n                    del freq[i]\n\n        for i in letters[::-1]:\n            if i in freq and freq[i] > 0:\n                res += i\n                freq[i] -= 1\n                if freq[i] == 0:\n                    del freq[i]\n\n    return res\n"], ["def capitalizeTitle(title: str) -> str:\n    li = title.split()\n    for i, l in enumerate(li):\n        if len(l) <= 2:\n            li[i] = l.lower()\n        else:\n            li[i] = l[0].upper() + l[1:].lower()\n    return ' '.join(li)"], [""], ["def minDistance(word1: str, word2: str) -> int:\n    m=len(word1)\n    n=len(word2)\n    dp=[]\n    for i in range (m+1):\n        dp.append([0]*(n+1))\n    for i in range (m+1):\n        dp[i][0]=i\n    for i in range (n+1):\n        dp[0][i]=i\n    for i in range (1,m+1):\n        for j in range (1,n+1):\n            if word1[i-1]==word2[j-1]:\n                dp[i][j]=dp[i-1][j-1]\n            else:\n                dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1\n    return dp[-1][-1]"], ["def checkValid(matrix: List[List[int]]) -> bool:\n    n = len(matrix)\n    dp_col = [[False for _ in range(n)] for _ in range(n)]\n    dp_row = [[False for _ in range(n)] for _ in range(n)]\n    \n    return helper(matrix, dp_row, dp_col)\n\ndef helper(matrix, dp_row, dp_col):\n    n = len(matrix)\n    for i in range(n):\n        for j in range(n):\n            if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\n                return False\n            dp_row[i][matrix[i][j]-1] = True\n            dp_col[j][matrix[i][j]-1] = True\n    return True\n"], ["from typing import List\n\ndef smallerNumbersThanCurrent(nums: List[int]) -> List[int]:\n    count = [0] * 101\n    res = []\n    for num in nums:\n        count[num] += 1 \n    for num in nums:\n        res.append(sum(count[:num]))\n    return res\n"]]