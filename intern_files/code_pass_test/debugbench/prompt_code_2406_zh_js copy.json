[
    {
        "id": "2996",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的整数数组 nums 。如果一个前缀 nums[0..i] 满足对于 1 <= j <= i 的所有元素都有 nums[j] = nums[j - 1] + 1 ，那么我们称这个前缀是一个 顺序前缀 。特殊情况是，只包含 nums[0] 的前缀也是一个 顺序前缀 。请你返回 nums 中没有出现过的 最小 整数 x ，满足 x 大于等于 最长 顺序前缀的和。\n示例 1：\n输入nums = [1,2,3,2,5]\n输出：6示例 2：\n输入nums = [3,4,5,1,12,14,13]\n输出：15\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 50\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar missingInteger = function(nums) {",
        "prompt_chat": "给你一个下标从 0 开始的整数数组 nums 。如果一个前缀 nums[0..i] 满足对于 1 <= j <= i 的所有元素都有 nums[j] = nums[j - 1] + 1 ，那么我们称这个前缀是一个 顺序前缀 。特殊情况是，只包含 nums[0] 的前缀也是一个 顺序前缀 。请你返回 nums 中没有出现过的 最小 整数 x ，满足 x 大于等于 最长 顺序前缀的和。\n示例 1：\n输入nums = [1,2,3,2,5]\n输出：6示例 2：\n输入nums = [3,4,5,1,12,14,13]\n输出：15\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 50\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar missingInteger = function(nums) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar missingInteger = function(nums) {\n    let sum = nums[0]\n    for(let i = 1; i < nums.length; i++){\n        if(nums[i] !== nums[i - 1] + 1) break \n        sum += nums[i]\n    }\n    let set = new Set(nums)\n    while(set.has(sum)) sum++\n    return sum \n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(missingInteger([1,2,3,2,5]), 6, \"Test 1 Error!\");\nassert.deepEqual(missingInteger([3,4,5,1,12,14,13]), 15, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar missingInteger = function(nums) {",
        "function_name": "missingInteger",
        "difficulty_level": "Easy",
        "time": "20240106"
    },
    {
        "id": "2997",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的整数数组 nums 和一个正整数 k 。你可以对数组执行以下操作 任意次：\n选择数组里的 任意 一个元素，并将它的 二进制 表示 翻转 一个数位，翻转数位表示将 0 变成 1 或者将 1 变成 0 。\n你的目标是让数组里 所有 元素的按位异或和得到 k ，请你返回达成这一目标的 最少 操作次数。\n注意，你也可以将一个数的前导 0 翻转。比方说，数字 (101)_2 翻转第四个数位，得到 (1101)_2 。\n示例 1：\n输入nums = [2,1,3,4], k = 1\n输出：2示例 2：\n输入nums = [2,0,2,0], k = 0\n输出：0\n\n提示：\n1 <= nums.length <= 10^5\n0 <= nums[i] <= 10^6\n0 <= k <= 10^6\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(nums, k) {",
        "prompt_chat": "给你一个下标从 0 开始的整数数组 nums 和一个正整数 k 。你可以对数组执行以下操作 任意次：\n选择数组里的 任意 一个元素，并将它的 二进制 表示 翻转 一个数位，翻转数位表示将 0 变成 1 或者将 1 变成 0 。\n你的目标是让数组里 所有 元素的按位异或和得到 k ，请你返回达成这一目标的 最少 操作次数。\n注意，你也可以将一个数的前导 0 翻转。比方说，数字 (101)_2 翻转第四个数位，得到 (1101)_2 。\n示例 1：\n输入nums = [2,1,3,4], k = 1\n输出：2示例 2：\n输入nums = [2,0,2,0], k = 0\n输出：0\n\n提示：\n1 <= nums.length <= 10^5\n0 <= nums[i] <= 10^6\n0 <= k <= 10^6\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(nums, k) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(nums, k) {\n    const num = nums.reduce((t, v) => t ^ v, 0) ^ k\n    let cnt = 0\n    for (let i = 0; i < 32; i++) {\n        cnt += (num >> i) & 1\n    }\n    return cnt\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minOperations([2,1,3,4],1), 2, \"Test 1 Error!\");\nassert.deepEqual(minOperations([2,0,2,0],0), 0, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(nums, k) {",
        "function_name": "minOperations",
        "difficulty_level": "Middle",
        "time": "20240106"
    },
    {
        "id": "2998",
        "prompt_base": "\"\"\"\n给你两个正整数 x 和 y 。一次操作中，你可以执行以下四种操作之一：\n如果 x 是 11 的倍数，将 x 除以 11 。\n如果 x 是 5 的倍数，将 x 除以 5 。\n将 x 减 1 。\n将 x 加 1 。\n请你返回让 x 和 y 相等的 最少 操作次数。\n示例 1：\n输入x = 26, y = 1\n输出：3示例 2：\n输入x = 54, y = 2\n输出：4\n\n提示：\n1 <= x, y <= 10^4\n\"\"\"\n\n/**\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nvar minimumOperationsToMakeEqual = function(x, y) {",
        "prompt_chat": "给你两个正整数 x 和 y 。一次操作中，你可以执行以下四种操作之一：\n如果 x 是 11 的倍数，将 x 除以 11 。\n如果 x 是 5 的倍数，将 x 除以 5 。\n将 x 减 1 。\n将 x 加 1 。\n请你返回让 x 和 y 相等的 最少 操作次数。\n示例 1：\n输入x = 26, y = 1\n输出：3示例 2：\n输入x = 54, y = 2\n输出：4\n\n提示：\n1 <= x, y <= 10^4\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nvar minimumOperationsToMakeEqual = function(x, y) {\n```",
        "solution": "/**\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\n\nvar minimumOperationsToMakeEqual = function(x, y) {\n    let memo = new Map();\n    return minimun(x, y);\n\n    function minimun(x,y) {\n        if (x <= y) { // 逐步加1到达，其他操作均为减少操作 不可行\n            return y-x;\n        }\n        if (memo.has(x)) {\n            return memo.get(x);\n        }\n\n        let ans = x - y;// 减一操作需要的次数\n        // 减一操作，去除不是11的倍数部分(x%11)，剩余的用除11操作\n        // 实际上应该是 minimumOperationsToMakeEqual((x-x%11)/11, y) \n        // (x-x%11)/11 数值上等价于 x/11\n        ans = Math.min(ans, minimun(Math.floor(x/11), y) + (x%11) + 1);\n        // 加一操作到达11的倍数，先加，再去除以11\n        // (x+(11- x%11))/11 = x/11+1+(x%11)/11 = x/11+1\n        ans = Math.min(ans, minimun(Math.floor(x/11)+1, y) + (11- x%11) + 1);\n\n        ans = Math.min(ans, minimun(Math.floor(x/5), y) + (x%5) + 1);\n        ans = Math.min(ans, minimun(Math.floor(x/5)+1, y) + (5- x%5) + 1);\n\n        memo.set(x, ans);\n        return ans;\n    }   \n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumOperationsToMakeEqual(26,1), 3, \"Test 1 Error!\");\nassert.deepEqual(minimumOperationsToMakeEqual(54,2), 4, \"Test 2 Error!\");\nassert.deepEqual(minimumOperationsToMakeEqual(25,30), 5, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nvar minimumOperationsToMakeEqual = function(x, y) {",
        "function_name": "minimumOperationsToMakeEqual",
        "difficulty_level": "Middle",
        "time": "20240106"
    },
    {
        "id": "2999",
        "prompt_base": "\"\"\"\n给你三个整数 start ，finish 和 limit 。同时给你一个下标从 0 开始的字符串 s ，表示一个 正 整数。\n如果一个 正 整数 x 末尾部分是 s （换句话说，s 是 x 的 后缀），且 x 中的每个数位至多是 limit ，那么我们称 x 是 强大的 。\n请你返回区间 [start..finish] 内强大整数的 总数目 。\n如果一个字符串 x 是 y 中某个下标开始（包括 0 ），到下标为 y.length - 1 结束的子字符串，那么我们称 x 是 y 的一个后缀。比方说，25 是 5125 的一个后缀，但不是 512 的后缀。\n示例 1：\n输入start = 1, finish = 6000, limit = 4, s = \"124\"\n输出：5示例 2：\n输入start = 15, finish = 215, limit = 6, s = \"10\"\n输出：2\n\n提示：\n1 <= start <= finish <= 10^15\n1 <= limit <= 9\n1 <= s.length <= floor(log10(finish)) + 1\ns 数位中每个数字都小于等于 limit 。\ns 不包含任何前导 0 。\n\"\"\"\n\n/**\n * @param {number} start\n * @param {number} finish\n * @param {number} limit\n * @param {string} s\n * @return {number}\n */\nvar numberOfPowerfulInt = function(start, finish, limit, s) {",
        "prompt_chat": "给你三个整数 start ，finish 和 limit 。同时给你一个下标从 0 开始的字符串 s ，表示一个 正 整数。\n如果一个 正 整数 x 末尾部分是 s （换句话说，s 是 x 的 后缀），且 x 中的每个数位至多是 limit ，那么我们称 x 是 强大的 。\n请你返回区间 [start..finish] 内强大整数的 总数目 。\n如果一个字符串 x 是 y 中某个下标开始（包括 0 ），到下标为 y.length - 1 结束的子字符串，那么我们称 x 是 y 的一个后缀。比方说，25 是 5125 的一个后缀，但不是 512 的后缀。\n示例 1：\n输入start = 1, finish = 6000, limit = 4, s = \"124\"\n输出：5示例 2：\n输入start = 15, finish = 215, limit = 6, s = \"10\"\n输出：2\n\n提示：\n1 <= start <= finish <= 10^15\n1 <= limit <= 9\n1 <= s.length <= floor(log10(finish)) + 1\ns 数位中每个数字都小于等于 limit 。\ns 不包含任何前导 0 。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} start\n * @param {number} finish\n * @param {number} limit\n * @param {string} s\n * @return {number}\n */\nvar numberOfPowerfulInt = function(start, finish, limit, s) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(numberOfPowerfulInt(1,6000,4,\"124\"), 5, \"Test 1 Error!\");\nassert.deepEqual(numberOfPowerfulInt(15,215,6,\"10\"), 2, \"Test 2 Error!\");\nassert.deepEqual(numberOfPowerfulInt(1000,2000,4,\"3000\"), 0, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} start\n * @param {number} finish\n * @param {number} limit\n * @param {string} s\n * @return {number}\n */\nvar numberOfPowerfulInt = function(start, finish, limit, s) {",
        "function_name": "numberOfPowerfulInt",
        "difficulty_level": "Hard",
        "time": "20240106"
    },
    {
        "id": "3000",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的二维整数数组 dimensions。\n对于所有下标 i（0 <= i < dimensions.length），dimensions[i][0] 表示矩形 i 的长度，而 dimensions[i][1] 表示矩形 i 的宽度。\n返回对角线最长的矩形的 面积 。如果存在多个对角线长度相同的矩形，返回面积最大的矩形的面积。\n示例 1：\n输入dimensions = [[9,3],[8,6]]\n输出：48示例 2：\n输入dimensions = [[3,4],[4,3]]\n输出：12\n\n提示：\n1 <= dimensions.length <= 100\ndimensions[i].length == 2\n1 <= dimensions[i][0], dimensions[i][1] <= 100\n\"\"\"\n\n/**\n * @param {number[][]} dimensions\n * @return {number}\n */\nvar areaOfMaxDiagonal = function(dimensions) {",
        "prompt_chat": "给你一个下标从 0 开始的二维整数数组 dimensions。\n对于所有下标 i（0 <= i < dimensions.length），dimensions[i][0] 表示矩形 i 的长度，而 dimensions[i][1] 表示矩形 i 的宽度。\n返回对角线最长的矩形的 面积 。如果存在多个对角线长度相同的矩形，返回面积最大的矩形的面积。\n示例 1：\n输入dimensions = [[9,3],[8,6]]\n输出：48示例 2：\n输入dimensions = [[3,4],[4,3]]\n输出：12\n\n提示：\n1 <= dimensions.length <= 100\ndimensions[i].length == 2\n1 <= dimensions[i][0], dimensions[i][1] <= 100\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} dimensions\n * @return {number}\n */\nvar areaOfMaxDiagonal = function(dimensions) {\n```",
        "solution": "/**\n * @param {number[][]} dimensions\n * @return {number}\n */\nvar areaOfMaxDiagonal = function(dimensions) {\n    let max = 0, ans = []\n    for(let [a,b] of dimensions){\n        let t = a**2 + b**2 \n        if(max < t){\n            max = t \n            ans = [[a,b]]\n        }else if(max === t){\n            ans.push([a,b])\n        }\n    }\n    return Math.max(...ans.map(v => v[0]*v[1]))\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(areaOfMaxDiagonal([[9,3],[8,6]]), 48, \"Test 1 Error!\");\nassert.deepEqual(areaOfMaxDiagonal([[3,4],[4,3]]), 12, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} dimensions\n * @return {number}\n */\nvar areaOfMaxDiagonal = function(dimensions) {",
        "function_name": "areaOfMaxDiagonal",
        "difficulty_level": "Easy",
        "time": "20240107"
    },
    {
        "id": "3001",
        "prompt_base": "\"\"\"\n现有一个下标从 1 开始的 8 x 8 棋盘，上面有 3 枚棋子。\n给你 6 个整数 a 、b 、c 、d 、e 和 f ，其中：\n(a, b) 表示白色车的位置。\n(c, d) 表示白色象的位置。\n(e, f) 表示黑皇后的位置。\n假定你只能移动白色棋子，返回捕获黑皇后所需的最少移动次数。\n请注意：\n车可以向垂直或水平方向移动任意数量的格子，但不能跳过其他棋子。\n象可以沿对角线方向移动任意数量的格子，但不能跳过其他棋子。\n如果车或象能移向皇后所在的格子，则认为它们可以捕获皇后。\n皇后不能移动。\n示例 1：\n输入a = 1, b = 1, c = 8, d = 8, e = 2, f = 3\n输出：2示例 2：\n输入a = 5, b = 3, c = 3, d = 4, e = 5, f = 2\n输出：1\n\n提示：\n1 <= a, b, c, d, e, f <= 8\n两枚棋子不会同时出现在同一个格子上。\n\"\"\"\n\n/**\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @param {number} d\n * @param {number} e\n * @param {number} f\n * @return {number}\n */\nvar minMovesToCaptureTheQueen = function(a, b, c, d, e, f) {",
        "prompt_chat": "现有一个下标从 1 开始的 8 x 8 棋盘，上面有 3 枚棋子。\n给你 6 个整数 a 、b 、c 、d 、e 和 f ，其中：\n(a, b) 表示白色车的位置。\n(c, d) 表示白色象的位置。\n(e, f) 表示黑皇后的位置。\n假定你只能移动白色棋子，返回捕获黑皇后所需的最少移动次数。\n请注意：\n车可以向垂直或水平方向移动任意数量的格子，但不能跳过其他棋子。\n象可以沿对角线方向移动任意数量的格子，但不能跳过其他棋子。\n如果车或象能移向皇后所在的格子，则认为它们可以捕获皇后。\n皇后不能移动。\n示例 1：\n输入a = 1, b = 1, c = 8, d = 8, e = 2, f = 3\n输出：2示例 2：\n输入a = 5, b = 3, c = 3, d = 4, e = 5, f = 2\n输出：1\n\n提示：\n1 <= a, b, c, d, e, f <= 8\n两枚棋子不会同时出现在同一个格子上。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @param {number} d\n * @param {number} e\n * @param {number} f\n * @return {number}\n */\nvar minMovesToCaptureTheQueen = function(a, b, c, d, e, f) {\n```",
        "solution": "var minMovesToCaptureTheQueen = function(a, b, c, d, e, f) {\n    if (a === e && (a!==c || (a===c && (d<Math.min(b,f) || d> Math.max(b,f))))) return 1\n    if (b ===f && (b!==d || (b===d && (c<Math.min(a,e) || c> Math.max(a,e))))) return 1\n    if (f-d === e-c && (b-d !== a-c || (b<Math.min(d,f)  || b> Math.max(d,f)))) return 1\n    if (f-d === c-e && (b-d !== c-a || (b<Math.min(d,f)  || b> Math.max(d,f)))) return 1\n\n    return 2\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minMovesToCaptureTheQueen(1,1,8,8,2,3), 2, \"Test 1 Error!\");\nassert.deepEqual(minMovesToCaptureTheQueen(5,3,3,4,5,2), 1, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @param {number} d\n * @param {number} e\n * @param {number} f\n * @return {number}\n */\nvar minMovesToCaptureTheQueen = function(a, b, c, d, e, f) {",
        "function_name": "minMovesToCaptureTheQueen",
        "difficulty_level": "Middle",
        "time": "20240107"
    },
    {
        "id": "3002",
        "prompt_base": "\"\"\"\n给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，它们的长度都是偶数 n 。\n你必须从 nums1 中移除 n / 2 个元素，同时从 nums2 中也移除 n / 2 个元素。移除之后，你将 nums1 和 nums2 中剩下的元素插入到集合 s 中。\n返回集合 s可能的 最多 包含多少元素。\n示例 1：\n输入nums1 = [1,2,1,2], nums2 = [1,1,1,1]\n输出：2示例 2：\n输入nums1 = [1,2,3,4,5,6], nums2 = [2,3,2,3,2,3]\n输出：5\n\n提示：\nn == nums1.length == nums2.length\n1 <= n <= 2 * 10^4\nn是偶数。\n1 <= nums1[i], nums2[i] <= 10^9\n\"\"\"\n\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar maximumSetSize = function(nums1, nums2) {",
        "prompt_chat": "给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，它们的长度都是偶数 n 。\n你必须从 nums1 中移除 n / 2 个元素，同时从 nums2 中也移除 n / 2 个元素。移除之后，你将 nums1 和 nums2 中剩下的元素插入到集合 s 中。\n返回集合 s可能的 最多 包含多少元素。\n示例 1：\n输入nums1 = [1,2,1,2], nums2 = [1,1,1,1]\n输出：2示例 2：\n输入nums1 = [1,2,3,4,5,6], nums2 = [2,3,2,3,2,3]\n输出：5\n\n提示：\nn == nums1.length == nums2.length\n1 <= n <= 2 * 10^4\nn是偶数。\n1 <= nums1[i], nums2[i] <= 10^9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar maximumSetSize = function(nums1, nums2) {\n```",
        "solution": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar maximumSetSize = function(nums1, nums2) {\n    const n = nums1.length    \n    // set.size 为合并数组的不重复最大值\n    const set = new Set([...nums1, ...nums2])\n    const set1 = new Set(nums1)\n    const set2 = new Set(nums2)\n\n    // count1 为 nums1 操作后不重复元素的最大值\n    const count1 = Math.min(set1.size, n/2)\n    // count2 为 nums2 操作后不重复元素的最大值\n    const count2 = Math.min(set2.size, n/2)\n\n    // 结果不能操作以上任意一种上限，取两者中最小值\n    return Math.min(set.size, count1 + count2) \n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maximumSetSize([1,2,1,2],[1,1,1,1]), 2, \"Test 1 Error!\");\nassert.deepEqual(maximumSetSize([1,2,3,4,5,6],[2,3,2,3,2,3]), 5, \"Test 2 Error!\");\nassert.deepEqual(maximumSetSize([1,1,2,2,3,3],[4,4,5,5,6,6]), 6, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar maximumSetSize = function(nums1, nums2) {",
        "function_name": "maximumSetSize",
        "difficulty_level": "Middle",
        "time": "20240107"
    },
    {
        "id": "3003",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的字符串 s 和一个整数 k。\n你需要执行以下分割操作，直到字符串 s 变为 空：\n选择 s 的最长 前缀，该前缀最多包含 k 个 不同 字符。\n删除 这个前缀，并将分割数量加一。如果有剩余字符，它们在 s 中保持原来的顺序。\n执行操作之 前 ，你可以将 s 中 至多一处 下标的对应字符更改为另一个小写英文字母。\n在最优选择情形下改变至多一处下标对应字符后，用整数表示并返回操作结束时得到的 最大 分割数量。\n示例 1：\n输入s = \"accca\", k = 2\n输出：3示例 2：\n输入s = \"aabaab\", k = 3\n输出：1\n\n提示：\n1 <= s.length <= 10^4\ns 只包含小写英文字母。\n1 <= k <= 26\n\"\"\"\n\n/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar maxPartitionsAfterOperations = function(s, k) {",
        "prompt_chat": "给你一个下标从 0 开始的字符串 s 和一个整数 k。\n你需要执行以下分割操作，直到字符串 s 变为 空：\n选择 s 的最长 前缀，该前缀最多包含 k 个 不同 字符。\n删除 这个前缀，并将分割数量加一。如果有剩余字符，它们在 s 中保持原来的顺序。\n执行操作之 前 ，你可以将 s 中 至多一处 下标的对应字符更改为另一个小写英文字母。\n在最优选择情形下改变至多一处下标对应字符后，用整数表示并返回操作结束时得到的 最大 分割数量。\n示例 1：\n输入s = \"accca\", k = 2\n输出：3示例 2：\n输入s = \"aabaab\", k = 3\n输出：1\n\n提示：\n1 <= s.length <= 10^4\ns 只包含小写英文字母。\n1 <= k <= 26\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar maxPartitionsAfterOperations = function(s, k) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maxPartitionsAfterOperations(\"accca\",2), 3, \"Test 1 Error!\");\nassert.deepEqual(maxPartitionsAfterOperations(\"aabaab\",3), 1, \"Test 2 Error!\");\nassert.deepEqual(maxPartitionsAfterOperations(\"xxyz\",1), 4, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar maxPartitionsAfterOperations = function(s, k) {",
        "function_name": "maxPartitionsAfterOperations",
        "difficulty_level": "Hard",
        "time": "20240107"
    },
    {
        "id": "3005",
        "prompt_base": "\"\"\"\n给你一个由 正整数 组成的数组 nums 。返回数组 nums 中所有具有 最大 频率的元素的 总频率 。元素的 频率 是指该元素在数组中出现的次数。\n示例 1：\n输入nums = [1,2,2,3,1,4]\n输出：4示例 2：\n输入nums = [1,2,3,4,5]\n输出：5\n\n提示：\n1 <= nums.length <= 100\n1 <= nums[i] <= 100\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxFrequencyElements = function(nums) {",
        "prompt_chat": "给你一个由 正整数 组成的数组 nums 。返回数组 nums 中所有具有 最大 频率的元素的 总频率 。元素的 频率 是指该元素在数组中出现的次数。\n示例 1：\n输入nums = [1,2,2,3,1,4]\n输出：4示例 2：\n输入nums = [1,2,3,4,5]\n输出：5\n\n提示：\n1 <= nums.length <= 100\n1 <= nums[i] <= 100\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxFrequencyElements = function(nums) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxFrequencyElements = function (nums) {\n    if (new Set(nums).size == nums.length) {\n        return nums.length\n    }\n    let arr = [], count = 1, maxcount = 0\n\n\n    for (let i = 0; i < nums.length; i++) {\n        count = 1\n        for (let j = i + 1; j < nums.length; j++) {\n\n            if (nums[j] == nums[i]) {\n                count++\n            }\n\n        }\n        arr.push(count)\n    }\n\n  \n    let max = Math.max(...arr)\n    console.log(arr)\n    arr.forEach(e => {\n        if (e == max) {\n            maxcount = maxcount + e\n        }\n    })\n\n\n    return maxcount\n\n\n\n\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maxFrequencyElements([1,2,2,3,1,4]), 4, \"Test 1 Error!\");\nassert.deepEqual(maxFrequencyElements([1,2,3,4,5]), 5, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxFrequencyElements = function(nums) {",
        "function_name": "maxFrequencyElements",
        "difficulty_level": "Easy",
        "time": "20240114"
    },
    {
        "id": "3006",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的字符串 s 、字符串 a 、字符串 b 和一个整数 k 。\n如果下标 i 满足以下条件，则认为它是一个 美丽下标：\n0 <= i <= s.length - a.length\ns[i..(i + a.length - 1)] == a\n存在下标 j 使得：\n0 <= j <= s.length - b.length\ns[j..(j + b.length - 1)] == b\n|j - i| <= k\n以数组形式按 从小到大排序 返回美丽下标。\n示例 1：\n输入s = \"isawsquirrelnearmysquirrelhouseohmy\", a = \"my\", b = \"squirrel\", k = 15\n输出：[16,33]示例 2：\n输入s = \"abcd\", a = \"a\", b = \"a\", k = 4\n输出：[0]\n\n提示：\n1 <= k <= s.length <= 10^5\n1 <= a.length, b.length <= 10\ns、a、和 b 只包含小写英文字母。\n\"\"\"\n\n/**\n * @param {string} s\n * @param {string} a\n * @param {string} b\n * @param {number} k\n * @return {number[]}\n */\nvar beautifulIndices = function(s, a, b, k) {",
        "prompt_chat": "给你一个下标从 0 开始的字符串 s 、字符串 a 、字符串 b 和一个整数 k 。\n如果下标 i 满足以下条件，则认为它是一个 美丽下标：\n0 <= i <= s.length - a.length\ns[i..(i + a.length - 1)] == a\n存在下标 j 使得：\n0 <= j <= s.length - b.length\ns[j..(j + b.length - 1)] == b\n|j - i| <= k\n以数组形式按 从小到大排序 返回美丽下标。\n示例 1：\n输入s = \"isawsquirrelnearmysquirrelhouseohmy\", a = \"my\", b = \"squirrel\", k = 15\n输出：[16,33]示例 2：\n输入s = \"abcd\", a = \"a\", b = \"a\", k = 4\n输出：[0]\n\n提示：\n1 <= k <= s.length <= 10^5\n1 <= a.length, b.length <= 10\ns、a、和 b 只包含小写英文字母。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} s\n * @param {string} a\n * @param {string} b\n * @param {number} k\n * @return {number[]}\n */\nvar beautifulIndices = function(s, a, b, k) {\n```",
        "solution": "/**\n * @param {string} s\n * @param {string} a\n * @param {string} b\n * @param {number} k\n * @return {number[]}\n */\nvar beautifulIndices = function (s, a, b, k) {\n    let res = []\n    for (let i = 0; i < s.length; i++) {\n        const strA = s.substring(i, a.length + i)\n        if (strA !== a) continue\n        const strSub = s.substring(i - k, i + k + b.length)\n        if (strSub.includes(b)) res.push(i)\n    }\n    return res\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(beautifulIndices(\"isawsquirrelnearmysquirrelhouseohmy\",\"my\",\"squirrel\",15), [16,33], \"Test 1 Error!\");\nassert.deepEqual(beautifulIndices(\"abcd\",\"a\",\"a\",4), [0], \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} s\n * @param {string} a\n * @param {string} b\n * @param {number} k\n * @return {number[]}\n */\nvar beautifulIndices = function(s, a, b, k) {",
        "function_name": "beautifulIndices",
        "difficulty_level": "Middle",
        "time": "20240114"
    },
    {
        "id": "3007",
        "prompt_base": "\"\"\"\n给你一个整数 k 和一个整数 x 。整数 num 的价值是它的二进制表示中在 x，2x，3x 等位置处 设置位 的数目（从最低有效位开始）。下面的表格包含了如何计算价值的例子。\n| x | num | Binary Representation | Price |\n| - | --- | --------------------- | ----- |\n| 1 | 13  | 000001101             | 3     |\n| 2 | 13  | 000001101             | 1     |\n| 2 | 233 | 011101001             | 3     |\n| 3 | 13  | 000001101             | 1     |\n| 3 | 362 | 101101010             | 2     |\nnum 的 累加价值 是从 1 到 num 的数字的 总 价值。如果 num 的累加价值小于或等于 k 则被认为是 廉价 的。请你返回 最大 的廉价数字。\n示例 1：\n输入k = 9, x = 1\n输出：6示例 2：\n输入k = 7, x = 2\n输出：9\n\n提示：\n1 <= k <= 10^15\n1 <= x <= 8\n\"\"\"\n\n/**\n * @param {number} k\n * @param {number} x\n * @return {number}\n */\nvar findMaximumNumber = function(k, x) {",
        "prompt_chat": "给你一个整数 k 和一个整数 x 。整数 num 的价值是它的二进制表示中在 x，2x，3x 等位置处 设置位 的数目（从最低有效位开始）。下面的表格包含了如何计算价值的例子。\n| x | num | Binary Representation | Price |\n| - | --- | --------------------- | ----- |\n| 1 | 13  | 000001101             | 3     |\n| 2 | 13  | 000001101             | 1     |\n| 2 | 233 | 011101001             | 3     |\n| 3 | 13  | 000001101             | 1     |\n| 3 | 362 | 101101010             | 2     |\nnum 的 累加价值 是从 1 到 num 的数字的 总 价值。如果 num 的累加价值小于或等于 k 则被认为是 廉价 的。请你返回 最大 的廉价数字。\n示例 1：\n输入k = 9, x = 1\n输出：6示例 2：\n输入k = 7, x = 2\n输出：9\n\n提示：\n1 <= k <= 10^15\n1 <= x <= 8\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} k\n * @param {number} x\n * @return {number}\n */\nvar findMaximumNumber = function(k, x) {\n```",
        "solution": "function findMaximumNumber(k, x) {\n    let lowerBound = 0, upperBound = Math.pow(10, 18);\n    let binaryThreshold = 1 << (x - 1);\n    let doubleThreshold = 1 << x;\n\n    while (lowerBound <= upperBound) {\n        let mid = Math.floor((lowerBound + upperBound) / 2);\n        let currentRange = binaryThreshold;\n        let valueSum = 0;\n\n        while (currentRange <= mid) {\n            let completeCycles = Math.floor(mid / (2 * currentRange));\n            let remainingNumbers = mid % (2 * currentRange);\n            valueSum += completeCycles * currentRange + Math.max(0, remainingNumbers - currentRange + 1);\n            currentRange *= doubleThreshold;\n        }\n\n        if (valueSum > k) {\n            upperBound = mid - 1;\n        } else {\n            lowerBound = mid + 1;\n        }\n    }\n\n    return upperBound;\n}",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(findMaximumNumber(9,1), 6, \"Test 1 Error!\");\nassert.deepEqual(findMaximumNumber(7,2), 9, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} k\n * @param {number} x\n * @return {number}\n */\nvar findMaximumNumber = function(k, x) {",
        "function_name": "findMaximumNumber",
        "difficulty_level": "Middle",
        "time": "20240114"
    },
    {
        "id": "3008",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的字符串 s 、字符串 a 、字符串 b 和一个整数 k 。\n如果下标 i 满足以下条件，则认为它是一个 美丽下标 ：\n0 <= i <= s.length - a.length\ns[i..(i + a.length - 1)] == a\n存在下标 j 使得：\n0 <= j <= s.length - b.length\ns[j..(j + b.length - 1)] == b\n|j - i| <= k\n以数组形式按 从小到大排序 返回美丽下标。\n示例 1：\n输入s = \"isawsquirrelnearmysquirrelhouseohmy\", a = \"my\", b = \"squirrel\", k = 15\n输出：[16,33]示例 2：\n输入s = \"abcd\", a = \"a\", b = \"a\", k = 4\n输出：[0]\n\n提示：\n1 <= k <= s.length <= 5 * 10^5\n1 <= a.length, b.length <= 5 * 10^5\ns、a、和 b 只包含小写英文字母。\n\"\"\"\n\n/**\n * @param {string} s\n * @param {string} a\n * @param {string} b\n * @param {number} k\n * @return {number[]}\n */\nvar beautifulIndices = function(s, a, b, k) {",
        "prompt_chat": "给你一个下标从 0 开始的字符串 s 、字符串 a 、字符串 b 和一个整数 k 。\n如果下标 i 满足以下条件，则认为它是一个 美丽下标 ：\n0 <= i <= s.length - a.length\ns[i..(i + a.length - 1)] == a\n存在下标 j 使得：\n0 <= j <= s.length - b.length\ns[j..(j + b.length - 1)] == b\n|j - i| <= k\n以数组形式按 从小到大排序 返回美丽下标。\n示例 1：\n输入s = \"isawsquirrelnearmysquirrelhouseohmy\", a = \"my\", b = \"squirrel\", k = 15\n输出：[16,33]示例 2：\n输入s = \"abcd\", a = \"a\", b = \"a\", k = 4\n输出：[0]\n\n提示：\n1 <= k <= s.length <= 5 * 10^5\n1 <= a.length, b.length <= 5 * 10^5\ns、a、和 b 只包含小写英文字母。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} s\n * @param {string} a\n * @param {string} b\n * @param {number} k\n * @return {number[]}\n */\nvar beautifulIndices = function(s, a, b, k) {\n```",
        "solution": "var findAllStrStr = function(haystack, needle) {\n    if (needle.length === 0) return [];\n\n    let next = [0];\n    let j = 0;\n    for (let i = 1; i < needle.length; i++) {\n        while (j > 0 && needle[i] !== needle[j]) {\n            j = next[j - 1];\n        }\n        if (needle[i] === needle[j]) {\n            j++;\n        }\n        next[i] = j;\n    }\n\n    let positions = [];\n    j = 0;\n    for (let i = 0; i < haystack.length; i++) {\n        while (j > 0 && haystack[i] !== needle[j]) {\n            j = next[j - 1];\n        }\n        if (haystack[i] === needle[j]) {\n            j++;\n        }\n        if (j === needle.length) {\n            positions.push(i - needle.length + 1);\n            j = next[j - 1];\n        }\n    }\n    return positions;\n};\n\n/**\n * @param {string} s\n * @param {string} a\n * @param {string} b\n * @param {number} k\n * @return {number[]}\n */\nvar beautifulIndices = function(s, a, b, k) {\n    const arrA = findAllStrStr(s,a)\n    const arrB = findAllStrStr(s,b)\n\n    const ans = []\n    \n    let j = 0\n    for (let i = 0; i < arrA.length; i++) {\n        while (arrA[i] + k >= arrB[j]) {\n            if (arrA[i] - k <= arrB[j] ) {\n                ans.push(arrA[i])\n                break\n            }\n            j++\n        }\n    }\n    return ans\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(beautifulIndices(\"isawsquirrelnearmysquirrelhouseohmy\",\"my\",\"squirrel\",15), [16,33], \"Test 1 Error!\");\nassert.deepEqual(beautifulIndices(\"abcd\",\"a\",\"a\",4), [0], \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} s\n * @param {string} a\n * @param {string} b\n * @param {number} k\n * @return {number[]}\n */\nvar beautifulIndices = function(s, a, b, k) {",
        "function_name": "beautifulIndices",
        "difficulty_level": "Hard",
        "time": "20240114"
    },
    {
        "id": "3010",
        "prompt_base": "\"\"\"\n给你一个长度为 n 的整数数组 nums 。一个数组的 代价 是它的 第一个 元素。比方说，[1,2,3] 的代价是 1 ，[3,4,1] 的代价是 3 。你需要将 nums 分成 3 个 连续且没有交集 的子数组。请你返回这些子数组的 最小 代价 总和 。\n示例 1：\n输入nums = [1,2,3,12]\n输出：6示例 2：\n输入nums = [5,4,3]\n输出：12\n\n提示：\n3 <= n <= 50\n1 <= nums[i] <= 50\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumCost = function(nums) {",
        "prompt_chat": "给你一个长度为 n 的整数数组 nums 。一个数组的 代价 是它的 第一个 元素。比方说，[1,2,3] 的代价是 1 ，[3,4,1] 的代价是 3 。你需要将 nums 分成 3 个 连续且没有交集 的子数组。请你返回这些子数组的 最小 代价 总和 。\n示例 1：\n输入nums = [1,2,3,12]\n输出：6示例 2：\n输入nums = [5,4,3]\n输出：12\n\n提示：\n3 <= n <= 50\n1 <= nums[i] <= 50\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumCost = function(nums) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumCost = function(nums) {\n    let x = nums[0]\n    let [a,b] = nums.slice(1).sort((a,b) => a - b)\n    return x + a + b\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumCost([1,2,3,12]), 6, \"Test 1 Error!\");\nassert.deepEqual(minimumCost([5,4,3]), 12, \"Test 2 Error!\");\nassert.deepEqual(minimumCost([10,3,1,1]), 12, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumCost = function(nums) {",
        "function_name": "minimumCost",
        "difficulty_level": "Easy",
        "time": "20240120"
    },
    {
        "id": "3011",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始且全是 正 整数的数组 nums 。\n一次 操作 中，如果两个 相邻 元素在二进制下 设置位 的数目 相同 ，那么你可以将这两个元素交换。你可以执行这个操作 任意次 （也可以 0 次）。\n如果你可以使数组变为非降序，请你返回 true ，否则返回 false 。\n示例 1：\n输入nums = [8,4,2,30,15]\n输出：true示例 2：\n输入nums = [1,2,3,4,5]\n输出：true\n\n提示：\n1 <= nums.length <= 100\n1 <= nums[i] <= 2^8\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canSortArray = function(nums) {",
        "prompt_chat": "给你一个下标从 0 开始且全是 正 整数的数组 nums 。\n一次 操作 中，如果两个 相邻 元素在二进制下 设置位 的数目 相同 ，那么你可以将这两个元素交换。你可以执行这个操作 任意次 （也可以 0 次）。\n如果你可以使数组变为非降序，请你返回 true ，否则返回 false 。\n示例 1：\n输入nums = [8,4,2,30,15]\n输出：true示例 2：\n输入nums = [1,2,3,4,5]\n输出：true\n\n提示：\n1 <= nums.length <= 100\n1 <= nums[i] <= 2^8\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canSortArray = function(nums) {\n```",
        "solution": "var canSortArray = function(nums) {\n    let lastCnt = 0;\n    let lastGroupMax = 0;\n    let curGroupMax = 0;\n\n    for (let num of nums) {\n        let curCnt = countBits(num);\n        if (curCnt === lastCnt) {\n            curGroupMax = Math.max(curGroupMax, num);\n        } else {\n            lastCnt = curCnt;\n            lastGroupMax = curGroupMax;\n            curGroupMax = num;\n        }\n        if (num < lastGroupMax) {\n            return false;\n        }\n    }\n    return true;\n};\n\nconst countBits = (num) => {\n    let count = 0;\n    while (num !== 0) {\n        count++;\n        num &= num - 1;\n    }\n    return count;\n}",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(canSortArray([8,4,2,30,15]), true, \"Test 1 Error!\");\nassert.deepEqual(canSortArray([1,2,3,4,5]), true, \"Test 2 Error!\");\nassert.deepEqual(canSortArray([3,16,8,4,2]), false, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canSortArray = function(nums) {",
        "function_name": "canSortArray",
        "difficulty_level": "Middle",
        "time": "20240120"
    },
    {
        "id": "3012",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的整数数组 nums ，它只包含 正 整数。\n你的任务是通过进行以下操作 任意次 （可以是 0 次） 最小化 nums 的长度：\n在 nums 中选择 两个不同 的下标 i 和 j ，满足 nums[i] > 0 且 nums[j] > 0 。\n将结果 nums[i] % nums[j] 插入 nums 的结尾。\n将 nums 中下标为 i 和 j 的元素删除。\n请你返回一个整数，它表示进行任意次操作以后 nums 的 最小长度 。\n示例 1：\n输入nums = [1,4,3,1]\n输出：1示例 2：\n输入nums = [5,5,5,10,5]\n输出：2\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumArrayLength = function(nums) {",
        "prompt_chat": "给你一个下标从 0 开始的整数数组 nums ，它只包含 正 整数。\n你的任务是通过进行以下操作 任意次 （可以是 0 次） 最小化 nums 的长度：\n在 nums 中选择 两个不同 的下标 i 和 j ，满足 nums[i] > 0 且 nums[j] > 0 。\n将结果 nums[i] % nums[j] 插入 nums 的结尾。\n将 nums 中下标为 i 和 j 的元素删除。\n请你返回一个整数，它表示进行任意次操作以后 nums 的 最小长度 。\n示例 1：\n输入nums = [1,4,3,1]\n输出：1示例 2：\n输入nums = [5,5,5,10,5]\n输出：2\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumArrayLength = function(nums) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @return {number}\n */\n\n//参考\n//https://leetcode.cn/problems/minimize-length-of-array-using-operations/\n\n/** \n核心思路:\n1. 观察规律, 构造一个极限贪心情况\nnums=[2,3,4,5,6]，每次操作都可以选择 2 和另一个数字 x, 最后必定只会剩下2，nums的长度为1（没有比这更理想的结果了）\n\n2. 突破口\n但凡能够构造出一个小于当前数组中最小值的新数字，就能达成step 1中的情形，也就可以直接返回1\n用这两个例子来思考\n//[2,2,2,2,2,2,2,2,4,5,8]\n//[2,2,2,2,2,2,2,2,4,6,8]\n\n//[2,2,2,2,2,2,2,2,4,5,8]\nnums[i]: 5, nums[j]: 2,  新数字为1， 1 < 当前最小值，为孤立的最小数字\n[2,2,2,2,2,2,2,2,4,5,8] => [2,2,2,2,2,2,2,4,8,1]\n因为顺序对结果没有关系, 整理成  [1,2,2,2,2,2,2,2,4,8] => 达到step1的情形\n\n//[2,2,2,2,2,2,2,2,4,6,8]\nnums[i]: 6, nums[j]: 2, 新数字为0， 因为0 是不能被选择的，以后只会徒增更多的0,不是最优的选择\n//[2,2,2,2,2,2,2,2,4,6,8] => 只能把所有不是2的数字给删除了 => [2,2,2,2,2,2,2,2] => \n采取以2换1策略 => [1,1,1,1]\n*/\nvar minimumArrayLength = function(nums) {\n  const min = Math.min(...nums);\n  for (const num of nums) {\n    if (num % min !== 0) {\n      return 1;//达到极限贪心情形\n    }\n  }\n  const numOfMin = nums.filter(num => num === min).length;\n  return Math.ceil(numOfMin / 2);//以2换1\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumArrayLength([1,4,3,1]), 1, \"Test 1 Error!\");\nassert.deepEqual(minimumArrayLength([5,5,5,10,5]), 2, \"Test 2 Error!\");\nassert.deepEqual(minimumArrayLength([2,3,4]), 1, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumArrayLength = function(nums) {",
        "function_name": "minimumArrayLength",
        "difficulty_level": "Middle",
        "time": "20240120"
    },
    {
        "id": "3013",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始长度为 n 的整数数组 nums 和两个 正 整数 k 和 dist 。\n一个数组的 代价 是数组中的 第一个 元素。比方说，[1,2,3] 的代价为 1 ，[3,4,1] 的代价为 3 。\n你需要将 nums 分割成 k 个 连续且互不相交 的子数组，满足 第二 个子数组与第 k 个子数组中第一个元素的下标距离 不超过 dist 。换句话说，如果你将 nums 分割成子数组 nums[0..(i_1 - 1)], nums[i_1..(i_2 - 1)], ..., nums[i_{k-1}..(n - 1)] ，那么它需要满足 i_{k-1} - i1 <= dist 。\n请你返回这些子数组的 最小 总代价。\n示例 1：\n输入nums = [1,3,2,6,4,2], k = 3, dist = 3\n输出：5示例 2：\n输入nums = [10,1,2,2,2,1], k = 4, dist = 3\n输出：15\n\n提示：\n3 <= n <= 10^5\n1 <= nums[i] <= 10^9\n3 <= k <= n\nk - 2 <= dist <= n - 2\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number} dist\n * @return {number}\n */\nvar minimumCost = function(nums, k, dist) {",
        "prompt_chat": "给你一个下标从 0 开始长度为 n 的整数数组 nums 和两个 正 整数 k 和 dist 。\n一个数组的 代价 是数组中的 第一个 元素。比方说，[1,2,3] 的代价为 1 ，[3,4,1] 的代价为 3 。\n你需要将 nums 分割成 k 个 连续且互不相交 的子数组，满足 第二 个子数组与第 k 个子数组中第一个元素的下标距离 不超过 dist 。换句话说，如果你将 nums 分割成子数组 nums[0..(i_1 - 1)], nums[i_1..(i_2 - 1)], ..., nums[i_{k-1}..(n - 1)] ，那么它需要满足 i_{k-1} - i1 <= dist 。\n请你返回这些子数组的 最小 总代价。\n示例 1：\n输入nums = [1,3,2,6,4,2], k = 3, dist = 3\n输出：5示例 2：\n输入nums = [10,1,2,2,2,1], k = 4, dist = 3\n输出：15\n\n提示：\n3 <= n <= 10^5\n1 <= nums[i] <= 10^9\n3 <= k <= n\nk - 2 <= dist <= n - 2\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number} dist\n * @return {number}\n */\nvar minimumCost = function(nums, k, dist) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumCost([1,3,2,6,4,2],3,3), 5, \"Test 1 Error!\");\nassert.deepEqual(minimumCost([10,1,2,2,2,1],4,3), 15, \"Test 2 Error!\");\nassert.deepEqual(minimumCost([10,8,18,9],3,1), 36, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number} dist\n * @return {number}\n */\nvar minimumCost = function(nums, k, dist) {",
        "function_name": "minimumCost",
        "difficulty_level": "Hard",
        "time": "20240120"
    },
    {
        "id": "3014",
        "prompt_base": "\"\"\"\n给你一个字符串 word，由 不同 小写英文字母组成。\n电话键盘上的按键与 不同 小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 2 对应 [\\\"a\\\",\\\"b\\\",\\\"c\\\"]，我们需要按一次键来输入 \\\"a\\\"，按两次键来输入 \\\"b\\\"，按三次键来输入 \\\"c\\\"。\n现在允许你将编号为 2 到 9 的按键重新映射到 不同 字母集合。每个按键可以映射到 任意数量 的字母，但每个字母 必须 恰好 映射到 一个 按键上。你需要找到输入字符串 word 所需的 最少 按键次数。\n返回重新映射按键后输入 word 所需的 最少 按键次数。\n下面给出了一种电话键盘上字母到按键的映射作为示例。注意 1，*，# 和 0 不 对应任何字母。\n示例 1：\n输入word = \"abcde\"\n输出：5示例 2：\n输入word = \"xycdefghij\"\n输出：12\n\n提示：\n1 <= word.length <= 26\nword 仅由小写英文字母组成。\nword 中的所有字母互不相同。\n\"\"\"\n\n/**\n * @param {string} word\n * @return {number}\n */\nvar minimumPushes = function(word) {",
        "prompt_chat": "给你一个字符串 word，由 不同 小写英文字母组成。\n电话键盘上的按键与 不同 小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 2 对应 [\\\"a\\\",\\\"b\\\",\\\"c\\\"]，我们需要按一次键来输入 \\\"a\\\"，按两次键来输入 \\\"b\\\"，按三次键来输入 \\\"c\\\"。\n现在允许你将编号为 2 到 9 的按键重新映射到 不同 字母集合。每个按键可以映射到 任意数量 的字母，但每个字母 必须 恰好 映射到 一个 按键上。你需要找到输入字符串 word 所需的 最少 按键次数。\n返回重新映射按键后输入 word 所需的 最少 按键次数。\n下面给出了一种电话键盘上字母到按键的映射作为示例。注意 1，*，# 和 0 不 对应任何字母。\n示例 1：\n输入word = \"abcde\"\n输出：5示例 2：\n输入word = \"xycdefghij\"\n输出：12\n\n提示：\n1 <= word.length <= 26\nword 仅由小写英文字母组成。\nword 中的所有字母互不相同。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} word\n * @return {number}\n */\nvar minimumPushes = function(word) {\n```",
        "solution": "/**\n * @param {string} word\n * @return {number}\n */\nvar minimumPushes = function(word) {\n    let n = word.length, k = n/8 >> 0, r = n % 8 \n    return 4*k*(k + 1) + (k + 1)*r\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumPushes(\"abcde\"), 5, \"Test 1 Error!\");\nassert.deepEqual(minimumPushes(\"xycdefghij\"), 12, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} word\n * @return {number}\n */\nvar minimumPushes = function(word) {",
        "function_name": "minimumPushes",
        "difficulty_level": "Easy",
        "time": "20240121"
    },
    {
        "id": "3015",
        "prompt_base": "\"\"\"\n给你三个 正整数 n 、x 和 y 。在城市中，存在编号从 1 到 n 的房屋，由 n 条街道相连。对所有 1 <= i < n ，都存在一条街道连接编号为 i 的房屋与编号为 i + 1 的房屋。另存在一条街道连接编号为 x 的房屋与编号为 y 的房屋。\n对于每个 k（1 <= k <= n），你需要找出所有满足要求的 房屋对 [house_1, house_2] ，即从 house_1 到 house_2 需要经过的 最少 街道数为 k 。\n返回一个下标从 1 开始且长度为 n 的数组 result ，其中 result[k] 表示所有满足要求的房屋对的数量，即从一个房屋到另一个房屋需要经过的 最少 街道数为 k 。\n注意，x 与 y 可以 相等 。\n示例 1：\n输入n = 3, x = 1, y = 3\n输出：[6,0,0]示例 2：\n输入n = 5, x = 2, y = 4\n输出：[10,8,2,0,0]\n\n提示：\n2 <= n <= 100\n1 <= x, y <= n\n\"\"\"\n\n/**\n * @param {number} n\n * @param {number} x\n * @param {number} y\n * @return {number[]}\n */\nvar countOfPairs = function(n, x, y) {",
        "prompt_chat": "给你三个 正整数 n 、x 和 y 。在城市中，存在编号从 1 到 n 的房屋，由 n 条街道相连。对所有 1 <= i < n ，都存在一条街道连接编号为 i 的房屋与编号为 i + 1 的房屋。另存在一条街道连接编号为 x 的房屋与编号为 y 的房屋。\n对于每个 k（1 <= k <= n），你需要找出所有满足要求的 房屋对 [house_1, house_2] ，即从 house_1 到 house_2 需要经过的 最少 街道数为 k 。\n返回一个下标从 1 开始且长度为 n 的数组 result ，其中 result[k] 表示所有满足要求的房屋对的数量，即从一个房屋到另一个房屋需要经过的 最少 街道数为 k 。\n注意，x 与 y 可以 相等 。\n示例 1：\n输入n = 3, x = 1, y = 3\n输出：[6,0,0]示例 2：\n输入n = 5, x = 2, y = 4\n输出：[10,8,2,0,0]\n\n提示：\n2 <= n <= 100\n1 <= x, y <= n\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} n\n * @param {number} x\n * @param {number} y\n * @return {number[]}\n */\nvar countOfPairs = function(n, x, y) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(countOfPairs(3,1,3), [6,0,0], \"Test 1 Error!\");\nassert.deepEqual(countOfPairs(5,2,4), [10,8,2,0,0], \"Test 2 Error!\");\nassert.deepEqual(countOfPairs(4,1,1), [6,4,2,0], \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} n\n * @param {number} x\n * @param {number} y\n * @return {number[]}\n */\nvar countOfPairs = function(n, x, y) {",
        "function_name": "countOfPairs",
        "difficulty_level": "Middle",
        "time": "20240121"
    },
    {
        "id": "3016",
        "prompt_base": "\"\"\"\n给你一个字符串 word，由小写英文字母组成。电话键盘上的按键与 不同 小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 2 对应 [\\\"a\\\",\\\"b\\\",\\\"c\\\"]，我们需要按一次键来输入 \\\"a\\\"，按两次键来输入 \\\"b\\\"，按三次键来输入 \\\"c\\\"。\n现在允许你将编号为 2 到 9 的按键重新映射到 不同 字母集合。每个按键可以映射到 任意数量 的字母，但每个字母 必须 恰好 映射到 一个 按键上。你需要找到输入字符串 word 所需的 最少 按键次数。\n返回重新映射按键后输入 word 所需的 最少 按键次数。\n下面给出了一种电话键盘上字母到按键的映射作为示例。注意 1，*，# 和 0 不 对应任何字母。\n示例 1：\n输入word = \"abcde\"\n输出：5示例 2：\n输入word = \"xyzxyzxyzxyz\"\n输出：12\n\n提示：\n1 <= word.length <= 10^5\nword 仅由小写英文字母组成。\n\"\"\"\n\n/**\n * @param {string} word\n * @return {number}\n */\nvar minimumPushes = function(word) {",
        "prompt_chat": "给你一个字符串 word，由小写英文字母组成。电话键盘上的按键与 不同 小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 2 对应 [\\\"a\\\",\\\"b\\\",\\\"c\\\"]，我们需要按一次键来输入 \\\"a\\\"，按两次键来输入 \\\"b\\\"，按三次键来输入 \\\"c\\\"。\n现在允许你将编号为 2 到 9 的按键重新映射到 不同 字母集合。每个按键可以映射到 任意数量 的字母，但每个字母 必须 恰好 映射到 一个 按键上。你需要找到输入字符串 word 所需的 最少 按键次数。\n返回重新映射按键后输入 word 所需的 最少 按键次数。\n下面给出了一种电话键盘上字母到按键的映射作为示例。注意 1，*，# 和 0 不 对应任何字母。\n示例 1：\n输入word = \"abcde\"\n输出：5示例 2：\n输入word = \"xyzxyzxyzxyz\"\n输出：12\n\n提示：\n1 <= word.length <= 10^5\nword 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} word\n * @return {number}\n */\nvar minimumPushes = function(word) {\n```",
        "solution": "/**\n * @param {string} word\n * @return {number}\n */\nvar minimumPushes = function(word) {\n    // 保存单词出现次数\n    const map = new Map()\n    for (let i = 0; i < word.length; i++) {\n        map.set(word[i], map.get(word[i]) ? map.get(word[i]) + 1 : 1)\n    }\n\n    // 依照出现次数排序\n    const arr = Array.from(map)\n    const _word = arr.sort((a, b) => (b[1] - a[1])).map(el => (el[0])).join('')\n\n    // 计算总数\n    let sum = 0\n    for (let i = 0; i < _word.length; i++) {\n        sum += map.get(_word[i]) * Math.floor(i / 8 + 1)\n    }\n    return sum\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumPushes(\"abcde\"), 5, \"Test 1 Error!\");\nassert.deepEqual(minimumPushes(\"xyzxyzxyzxyz\"), 12, \"Test 2 Error!\");\nassert.deepEqual(minimumPushes(\"aabbccddeeffgghhiiiiii\"), 24, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} word\n * @return {number}\n */\nvar minimumPushes = function(word) {",
        "function_name": "minimumPushes",
        "difficulty_level": "Middle",
        "time": "20240121"
    },
    {
        "id": "3017",
        "prompt_base": "\"\"\"\n给你三个 正整数 n 、x 和 y 。在城市中，存在编号从 1 到 n 的房屋，由 n 条街道相连。对所有 1 <= i < n ，都存在一条街道连接编号为 i 的房屋与编号为 i + 1 的房屋。另存在一条街道连接编号为 x 的房屋与编号为 y 的房屋。\n对于每个 k（1 <= k <= n），你需要找出所有满足要求的 房屋对 [house_1, house_2] ，即从 house_1 到 house_2 需要经过的 最少 街道数为 k 。\n返回一个下标从 1 开始且长度为 n 的数组 result ，其中 result[k] 表示所有满足要求的房屋对的数量，即从一个房屋到另一个房屋需要经过的 最少 街道数为 k 。\n注意，x 与 y 可以 相等 。\n示例 1：\n输入n = 3, x = 1, y = 3\n输出：[6,0,0]示例 2：\n输入n = 5, x = 2, y = 4\n输出：[10,8,2,0,0]\n\n提示：\n2 <= n <= 10^5\n1 <= x, y <= n\n\"\"\"\n\n/**\n * @param {number} n\n * @param {number} x\n * @param {number} y\n * @return {number[]}\n */\nvar countOfPairs = function(n, x, y) {",
        "prompt_chat": "给你三个 正整数 n 、x 和 y 。在城市中，存在编号从 1 到 n 的房屋，由 n 条街道相连。对所有 1 <= i < n ，都存在一条街道连接编号为 i 的房屋与编号为 i + 1 的房屋。另存在一条街道连接编号为 x 的房屋与编号为 y 的房屋。\n对于每个 k（1 <= k <= n），你需要找出所有满足要求的 房屋对 [house_1, house_2] ，即从 house_1 到 house_2 需要经过的 最少 街道数为 k 。\n返回一个下标从 1 开始且长度为 n 的数组 result ，其中 result[k] 表示所有满足要求的房屋对的数量，即从一个房屋到另一个房屋需要经过的 最少 街道数为 k 。\n注意，x 与 y 可以 相等 。\n示例 1：\n输入n = 3, x = 1, y = 3\n输出：[6,0,0]示例 2：\n输入n = 5, x = 2, y = 4\n输出：[10,8,2,0,0]\n\n提示：\n2 <= n <= 10^5\n1 <= x, y <= n\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} n\n * @param {number} x\n * @param {number} y\n * @return {number[]}\n */\nvar countOfPairs = function(n, x, y) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(countOfPairs(3,1,3), [6,0,0], \"Test 1 Error!\");\nassert.deepEqual(countOfPairs(5,2,4), [10,8,2,0,0], \"Test 2 Error!\");\nassert.deepEqual(countOfPairs(4,1,1), [6,4,2,0], \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} n\n * @param {number} x\n * @param {number} y\n * @return {number[]}\n */\nvar countOfPairs = function(n, x, y) {",
        "function_name": "countOfPairs",
        "difficulty_level": "Hard",
        "time": "20240121"
    },
    {
        "id": "3019",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的字符串 s ，该字符串由用户输入。按键变更的定义是：使用与上次使用的按键不同的键。例如 s = \\\"ab\\\" 表示按键变更一次，而 s = \\\"bBBb\\\" 不存在按键变更。\n返回用户输入过程中按键变更的次数。\n注意：shift 或 caps lock 等修饰键不计入按键变更，也就是说，如果用户先输入字母 'a' 然后输入字母 'A' ，不算作按键变更。\n示例 1：\n输入s = \"aAbBcC\"\n输出：2示例 2：\n输入s = \"AaAaAaaA\"\n输出：0\n\n提示：\n1 <= s.length <= 100\ns 仅由英文大写字母和小写字母组成。\n\"\"\"\n\n/**\n * @param {string} s\n * @return {number}\n */\nvar countKeyChanges = function(s) {",
        "prompt_chat": "给你一个下标从 0 开始的字符串 s ，该字符串由用户输入。按键变更的定义是：使用与上次使用的按键不同的键。例如 s = \\\"ab\\\" 表示按键变更一次，而 s = \\\"bBBb\\\" 不存在按键变更。\n返回用户输入过程中按键变更的次数。\n注意：shift 或 caps lock 等修饰键不计入按键变更，也就是说，如果用户先输入字母 'a' 然后输入字母 'A' ，不算作按键变更。\n示例 1：\n输入s = \"aAbBcC\"\n输出：2示例 2：\n输入s = \"AaAaAaaA\"\n输出：0\n\n提示：\n1 <= s.length <= 100\ns 仅由英文大写字母和小写字母组成。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar countKeyChanges = function(s) {\n```",
        "solution": "/**\n * @param {string} s\n * @return {number}\n */\nvar countKeyChanges = function(s) {\n    s=s.toUpperCase()\n    let num = 0\n    let key = s[0]\n    for(let i = 0 ; i < s.length ; i ++){\n        if(key != s[i]){\n            num+=1\n            key = s[i]\n        }\n    }\n    return num\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(countKeyChanges(\"aAbBcC\"), 2, \"Test 1 Error!\");\nassert.deepEqual(countKeyChanges(\"AaAaAaaA\"), 0, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} s\n * @return {number}\n */\nvar countKeyChanges = function(s) {",
        "function_name": "countKeyChanges",
        "difficulty_level": "Easy",
        "time": "20240128"
    },
    {
        "id": "3020",
        "prompt_base": "\"\"\"\n给你一个 正整数 数组 nums 。\n你需要从数组中选出一个满足下述条件的子集：\n你可以将选中的元素放置在一个下标从 0 开始的数组中，并使其遵循以下模式：[x, x^2, x^4, ..., x^{k/2}, x^k, x^{k/2}, ..., x^4, x^2, x]（注意，k 可以是任何 非负 的 2 的幂）。例如，[2, 4, 16, 4, 2] 和 [3, 9, 3] 都符合这一模式，而 [2, 4, 8, 4, 2] 则不符合。\n返回满足这些条件的子集中，元素数量的 最大值 。\n示例 1：\n输入nums = [5,4,1,2,2]\n输出：3示例 2：\n输入nums = [1,3,2,4]\n输出：1\n\n提示：\n2 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumLength = function(nums) {",
        "prompt_chat": "给你一个 正整数 数组 nums 。\n你需要从数组中选出一个满足下述条件的子集：\n你可以将选中的元素放置在一个下标从 0 开始的数组中，并使其遵循以下模式：[x, x^2, x^4, ..., x^{k/2}, x^k, x^{k/2}, ..., x^4, x^2, x]（注意，k 可以是任何 非负 的 2 的幂）。例如，[2, 4, 16, 4, 2] 和 [3, 9, 3] 都符合这一模式，而 [2, 4, 8, 4, 2] 则不符合。\n返回满足这些条件的子集中，元素数量的 最大值 。\n示例 1：\n输入nums = [5,4,1,2,2]\n输出：3示例 2：\n输入nums = [1,3,2,4]\n输出：1\n\n提示：\n2 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumLength = function(nums) {\n```",
        "solution": "var maximumLength = function(nums) {\n    // 记录每个元素出现次数\n    const map = new Map()\n    for (let i = 0; i < nums.length; i++) {\n        map.set(nums[i], map.get(nums[i]) ? map.get(nums[i]) + 1 : 1)\n    }\n\n    // 数组去重\n    const set = new Set(nums)\n    const _nums = Array.from(set)\n\n    let count = 1\n    let max = 0\n    for (let i = 0; i < _nums.length; i++) {\n        let middle = _nums[i]\n        // 中心元素为1时所有元素为1\n        if (middle === 1) {\n            max = Math.max(map.get(1) % 2 === 1 ? map.get(1) : map.get(1) - 1, max)\n            continue\n        }\n        // 以当前元素为中心组成数组\n        while(map.get(Math.sqrt(middle)) >= 2) {\n            count += 2\n            middle = Math.sqrt(middle)\n        }\n        max = Math.max(count, max)\n        count = 1\n    }\n    \n    return max\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maximumLength([5,4,1,2,2]), 3, \"Test 1 Error!\");\nassert.deepEqual(maximumLength([1,3,2,4]), 1, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumLength = function(nums) {",
        "function_name": "maximumLength",
        "difficulty_level": "Middle",
        "time": "20240128"
    },
    {
        "id": "3021",
        "prompt_base": "\"\"\"\nAlice 和 Bob 在一个长满鲜花的环形草地玩一个回合制游戏。环形的草地上有一些鲜花，Alice 到 Bob 之间顺时针有 x 朵鲜花，逆时针有 y 朵鲜花。游戏过程如下：\nAlice 先行动。\n每一次行动中，当前玩家必须选择顺时针或者逆时针，然后在这个方向上摘一朵鲜花。\n一次行动结束后，如果所有鲜花都被摘完了，那么 当前 玩家抓住对手并赢得游戏的胜利。\n给你两个整数 n 和 m ，你的任务是求出满足以下条件的所有 (x, y) 对：\n按照上述规则，Alice 必须赢得游戏。\nAlice 顺时针方向上的鲜花数目 x 必须在区间 [1,n] 之间。\nAlice 逆时针方向上的鲜花数目 y 必须在区间 [1,m] 之间。\n请你返回满足题目描述的数对 (x, y) 的数目。\n示例 1：\n输入n = 3, m = 2\n输出：3示例 2：\n输入n = 1, m = 1\n输出：0\n\n提示：\n1 <= n, m <= 10^5\n\"\"\"\n\n/**\n * @param {number} n\n * @param {number} m\n * @return {number}\n */\nvar flowerGame = function(n, m) {",
        "prompt_chat": "Alice 和 Bob 在一个长满鲜花的环形草地玩一个回合制游戏。环形的草地上有一些鲜花，Alice 到 Bob 之间顺时针有 x 朵鲜花，逆时针有 y 朵鲜花。游戏过程如下：\nAlice 先行动。\n每一次行动中，当前玩家必须选择顺时针或者逆时针，然后在这个方向上摘一朵鲜花。\n一次行动结束后，如果所有鲜花都被摘完了，那么 当前 玩家抓住对手并赢得游戏的胜利。\n给你两个整数 n 和 m ，你的任务是求出满足以下条件的所有 (x, y) 对：\n按照上述规则，Alice 必须赢得游戏。\nAlice 顺时针方向上的鲜花数目 x 必须在区间 [1,n] 之间。\nAlice 逆时针方向上的鲜花数目 y 必须在区间 [1,m] 之间。\n请你返回满足题目描述的数对 (x, y) 的数目。\n示例 1：\n输入n = 3, m = 2\n输出：3示例 2：\n输入n = 1, m = 1\n输出：0\n\n提示：\n1 <= n, m <= 10^5\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} n\n * @param {number} m\n * @return {number}\n */\nvar flowerGame = function(n, m) {\n```",
        "solution": "/**\n * @param {number} n\n * @param {number} m\n * @return {number}\n */\nvar flowerGame = function(n, m) {\n    // let x = Math.ceil(n/2)\n    // let y = m-Math.ceil(m/2)\n    // let a = n-Math.ceil(n/2)\n    // let b = Math.ceil(m/2)\n    // return x*y+a*b\n    return Math.ceil(n/2)*(m-Math.ceil(m/2)) + (n-Math.ceil(n/2))*Math.ceil(m/2)\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(flowerGame(3,2), 3, \"Test 1 Error!\");\nassert.deepEqual(flowerGame(1,1), 0, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} n\n * @param {number} m\n * @return {number}\n */\nvar flowerGame = function(n, m) {",
        "function_name": "flowerGame",
        "difficulty_level": "Middle",
        "time": "20240128"
    },
    {
        "id": "3022",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。一次操作中，你可以选择 nums 中满足 0 <= i < nums.length - 1 的一个下标 i ，并将 nums[i] 和 nums[i + 1] 替换为数字 nums[i] & nums[i + 1] ，其中 & 表示按位 AND 操作。\n请你返回 至多 k 次操作以内，使 nums 中所有剩余元素按位 OR 结果的 最小值 。\n示例 1：\n输入nums = [3,5,3,2,7], k = 2\n输出：3示例 2：\n输入nums = [7,3,15,14,2,8], k = 4\n输出：2\n\n提示：\n1 <= nums.length <= 10^5\n0 <= nums[i] < 2^30\n0 <= k < nums.length\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOrAfterOperations = function(nums, k) {",
        "prompt_chat": "给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。一次操作中，你可以选择 nums 中满足 0 <= i < nums.length - 1 的一个下标 i ，并将 nums[i] 和 nums[i + 1] 替换为数字 nums[i] & nums[i + 1] ，其中 & 表示按位 AND 操作。\n请你返回 至多 k 次操作以内，使 nums 中所有剩余元素按位 OR 结果的 最小值 。\n示例 1：\n输入nums = [3,5,3,2,7], k = 2\n输出：3示例 2：\n输入nums = [7,3,15,14,2,8], k = 4\n输出：2\n\n提示：\n1 <= nums.length <= 10^5\n0 <= nums[i] < 2^30\n0 <= k < nums.length\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOrAfterOperations = function(nums, k) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minOrAfterOperations([3,5,3,2,7],2), 3, \"Test 1 Error!\");\nassert.deepEqual(minOrAfterOperations([7,3,15,14,2,8],4), 2, \"Test 2 Error!\");\nassert.deepEqual(minOrAfterOperations([10,7,10,3,9,14,9,4],1), 15, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOrAfterOperations = function(nums, k) {",
        "function_name": "minOrAfterOperations",
        "difficulty_level": "Hard",
        "time": "20240128"
    },
    {
        "id": "3024",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始长度为 3 的整数数组 nums ，需要用它们来构造三角形。\n如果一个三角形的所有边长度相等，那么这个三角形称为 equilateral 。\n如果一个三角形恰好有两条边长度相等，那么这个三角形称为 isosceles 。\n如果一个三角形三条边的长度互不相同，那么这个三角形称为 scalene 。\n如果这个数组无法构成一个三角形，请你返回字符串 \\\"none\\\" ，否则返回一个字符串表示这个三角形的类型。\n示例 1：\n输入nums = [3,3,3]\n输出：\"equilateral\"示例 2：\n输入nums = [3,4,5]\n输出：\"scalene\"\n\n提示：\nnums.length == 3\n1 <= nums[i] <= 100\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {string}\n */\nvar triangleType = function(nums) {",
        "prompt_chat": "给你一个下标从 0 开始长度为 3 的整数数组 nums ，需要用它们来构造三角形。\n如果一个三角形的所有边长度相等，那么这个三角形称为 equilateral 。\n如果一个三角形恰好有两条边长度相等，那么这个三角形称为 isosceles 。\n如果一个三角形三条边的长度互不相同，那么这个三角形称为 scalene 。\n如果这个数组无法构成一个三角形，请你返回字符串 \\\"none\\\" ，否则返回一个字符串表示这个三角形的类型。\n示例 1：\n输入nums = [3,3,3]\n输出：\"equilateral\"示例 2：\n输入nums = [3,4,5]\n输出：\"scalene\"\n\n提示：\nnums.length == 3\n1 <= nums[i] <= 100\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {string}\n */\nvar triangleType = function(nums) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @return {string}\n */\nvar triangleType = function(nums) {\n    if (nums[0] + nums[1] <= nums[2] || nums[1] + nums[2] <= nums[0] || nums[0] + nums[2] <= nums[1]) return 'none'\n    if (nums[0] === nums[1] && nums[1] === nums[2]) return 'equilateral'\n    if (nums[0] === nums[1] || nums[1] === nums[2] || nums[0] === nums[2]) return 'isosceles'\n    return 'scalene'\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(triangleType([3,3,3]), \"equilateral\", \"Test 1 Error!\");\nassert.deepEqual(triangleType([3,4,5]), \"scalene\", \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {string}\n */\nvar triangleType = function(nums) {",
        "function_name": "triangleType",
        "difficulty_level": "Easy",
        "time": "20240203"
    },
    {
        "id": "3025",
        "prompt_base": "\"\"\"\n给你一个  n x 2 的二维数组 points ，它表示二维平面上的一些点坐标，其中 points[i] = [x_i, y_i] 。\n计算点对 (A, B) 的数量，其中\nA 在 B 的左上角，并且\n它们形成的长方形中（或直线上）没有其它点（包括边界）。\n返回数量。\n示例 1：\n输入points = [[1,1],[2,2],[3,3]]\n输出：0示例 2：\n输入points = [[6,2],[4,4],[2,6]]\n输出：2\n\n提示：\n2 <= n <= 50\npoints[i].length == 2\n0 <= points[i][0], points[i][1] <= 50\npoints[i] 点对两两不同。\n\"\"\"\n\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfPairs = function(points) {",
        "prompt_chat": "给你一个  n x 2 的二维数组 points ，它表示二维平面上的一些点坐标，其中 points[i] = [x_i, y_i] 。\n计算点对 (A, B) 的数量，其中\nA 在 B 的左上角，并且\n它们形成的长方形中（或直线上）没有其它点（包括边界）。\n返回数量。\n示例 1：\n输入points = [[1,1],[2,2],[3,3]]\n输出：0示例 2：\n输入points = [[6,2],[4,4],[2,6]]\n输出：2\n\n提示：\n2 <= n <= 50\npoints[i].length == 2\n0 <= points[i][0], points[i][1] <= 50\npoints[i] 点对两两不同。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfPairs = function(points) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(numberOfPairs([[1,1],[2,2],[3,3]]), 0, \"Test 1 Error!\");\nassert.deepEqual(numberOfPairs([[6,2],[4,4],[2,6]]), 2, \"Test 2 Error!\");\nassert.deepEqual(numberOfPairs([[3,1],[1,3],[1,1]]), 2, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfPairs = function(points) {",
        "function_name": "numberOfPairs",
        "difficulty_level": "Middle",
        "time": "20240203"
    },
    {
        "id": "3026",
        "prompt_base": "\"\"\"\n给你一个长度为 n 的数组 nums 和一个 正 整数 k 。\n如果 nums 的一个子数组中，第一个元素和最后一个元素 差的绝对值恰好 为 k ，我们称这个子数组为 好 的。换句话说，如果子数组 nums[i..j] 满足 |nums[i] - nums[j]| == k ，那么它是一个好子数组。\n请你返回 nums 中 好 子数组的 最大 和，如果没有好子数组，返回 0 。\n示例 1：\n输入nums = [1,2,3,4,5,6], k = 1\n输出：11示例 2：\n输入nums = [-1,3,2,4,5], k = 3\n输出：11\n\n提示：\n2 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9\n1 <= k <= 10^9\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumSubarraySum = function(nums, k) {",
        "prompt_chat": "给你一个长度为 n 的数组 nums 和一个 正 整数 k 。\n如果 nums 的一个子数组中，第一个元素和最后一个元素 差的绝对值恰好 为 k ，我们称这个子数组为 好 的。换句话说，如果子数组 nums[i..j] 满足 |nums[i] - nums[j]| == k ，那么它是一个好子数组。\n请你返回 nums 中 好 子数组的 最大 和，如果没有好子数组，返回 0 。\n示例 1：\n输入nums = [1,2,3,4,5,6], k = 1\n输出：11示例 2：\n输入nums = [-1,3,2,4,5], k = 3\n输出：11\n\n提示：\n2 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9\n1 <= k <= 10^9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumSubarraySum = function(nums, k) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumSubarraySum = function(nums, k) {\n    // 暴力算法超时\n    // let max = - Number.MAX_VALUE\n    // let sum = 0\n    // let count = 0\n    // for (let left = 0; left < nums.length; left++) {\n    //     sum = nums[left]\n    //     for (let right = left + 1; right < nums.length; right++) {\n    //         sum += nums[right]\n    //         if (Math.abs(nums[left] - nums[right]) === k) {\n    //             count += 1\n    //             max = Math.max(sum, max)\n    //         }\n    //     }\n    // }\n    // return count > 0 ? max : 0\n    \n    // 前缀和\n    const map = new Map()\n    let sum = 0\n    let max = - Number.MAX_VALUE\n    for (let num of nums) {\n        sum += num\n        if (!map.has(num)) {\n            map.set(num, sum - num)\n        }\n        if (map.has(num)) {\n            map.set(num, Math.min(sum - num, map.get(num)))\n        }\n        if (map.has(num - k)) {\n            max = Math.max(max, sum - map.get(num - k))\n        }\n        if (map.has(num + k)) {\n            max = Math.max(max, sum - map.get(num + k))\n        }\n    }\n    return max === - Number.MAX_VALUE ? 0 : max\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maximumSubarraySum([1,2,3,4,5,6],1), 11, \"Test 1 Error!\");\nassert.deepEqual(maximumSubarraySum([-1,3,2,4,5],3), 11, \"Test 2 Error!\");\nassert.deepEqual(maximumSubarraySum([-1,-2,-3,-4],2), -6, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumSubarraySum = function(nums, k) {",
        "function_name": "maximumSubarraySum",
        "difficulty_level": "Middle",
        "time": "20240203"
    },
    {
        "id": "3027",
        "prompt_base": "\"\"\"\n给你一个  n x 2 的二维数组 points ，它表示二维平面上的一些点坐标，其中 points[i] = [x_i, y_i] 。\n我们定义 x 轴的正方向为 右 （x 轴递增的方向），x 轴的负方向为 左 （x 轴递减的方向）。类似的，我们定义 y 轴的正方向为 上 （y 轴递增的方向），y 轴的负方向为 下 （y 轴递减的方向）。\n你需要安排这 n 个人的站位，这 n 个人中包括 Alice 和 Bob 。你需要确保每个点处 恰好 有 一个 人。同时，Alice 想跟 Bob 单独玩耍，所以 Alice 会以 Alice 的坐标为 左上角 ，Bob 的坐标为 右下角 建立一个矩形的围栏（注意，围栏可能 不 包含任何区域，也就是说围栏可能是一条线段）。如果围栏的 内部 或者 边缘 上有任何其他人，Alice 都会难过。\n请你在确保 Alice 不会 难过的前提下，返回 Alice 和 Bob 可以选择的 点对 数目。\n注意，Alice 建立的围栏必须确保 Alice 的位置是矩形的左上角，Bob 的位置是矩形的右下角。比方说，以 (1, 1) ，(1, 3) ，(3, 1) 和 (3, 3) 为矩形的四个角，给定下图的两个输入，Alice 都不能建立围栏，原因如下：\n图一中，Alice 在 (3, 3) 且 Bob 在 (1, 1) ，Alice 的位置不是左上角且 Bob 的位置不是右下角。\n图二中，Alice 在 (1, 3) 且 Bob 在 (1, 1) ，Bob 的位置不是在围栏的右下角。\n示例 1：\n输入points = [[1,1],[2,2],[3,3]]\n输出：0示例 2：\n输入points = [[6,2],[4,4],[2,6]]\n输出：2\n\n提示：\n2 <= n <= 1000\npoints[i].length == 2\n-10^9 <= points[i][0], points[i][1] <= 10^9\npoints[i] 点对两两不同。\n\"\"\"\n\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfPairs = function(points) {",
        "prompt_chat": "给你一个  n x 2 的二维数组 points ，它表示二维平面上的一些点坐标，其中 points[i] = [x_i, y_i] 。\n我们定义 x 轴的正方向为 右 （x 轴递增的方向），x 轴的负方向为 左 （x 轴递减的方向）。类似的，我们定义 y 轴的正方向为 上 （y 轴递增的方向），y 轴的负方向为 下 （y 轴递减的方向）。\n你需要安排这 n 个人的站位，这 n 个人中包括 Alice 和 Bob 。你需要确保每个点处 恰好 有 一个 人。同时，Alice 想跟 Bob 单独玩耍，所以 Alice 会以 Alice 的坐标为 左上角 ，Bob 的坐标为 右下角 建立一个矩形的围栏（注意，围栏可能 不 包含任何区域，也就是说围栏可能是一条线段）。如果围栏的 内部 或者 边缘 上有任何其他人，Alice 都会难过。\n请你在确保 Alice 不会 难过的前提下，返回 Alice 和 Bob 可以选择的 点对 数目。\n注意，Alice 建立的围栏必须确保 Alice 的位置是矩形的左上角，Bob 的位置是矩形的右下角。比方说，以 (1, 1) ，(1, 3) ，(3, 1) 和 (3, 3) 为矩形的四个角，给定下图的两个输入，Alice 都不能建立围栏，原因如下：\n图一中，Alice 在 (3, 3) 且 Bob 在 (1, 1) ，Alice 的位置不是左上角且 Bob 的位置不是右下角。\n图二中，Alice 在 (1, 3) 且 Bob 在 (1, 1) ，Bob 的位置不是在围栏的右下角。\n示例 1：\n输入points = [[1,1],[2,2],[3,3]]\n输出：0示例 2：\n输入points = [[6,2],[4,4],[2,6]]\n输出：2\n\n提示：\n2 <= n <= 1000\npoints[i].length == 2\n-10^9 <= points[i][0], points[i][1] <= 10^9\npoints[i] 点对两两不同。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfPairs = function(points) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(numberOfPairs([[1,1],[2,2],[3,3]]), 0, \"Test 1 Error!\");\nassert.deepEqual(numberOfPairs([[6,2],[4,4],[2,6]]), 2, \"Test 2 Error!\");\nassert.deepEqual(numberOfPairs([[3,1],[1,3],[1,1]]), 2, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfPairs = function(points) {",
        "function_name": "numberOfPairs",
        "difficulty_level": "Hard",
        "time": "20240203"
    },
    {
        "id": "3028",
        "prompt_base": "\"\"\"\n边界上有一只蚂蚁，它有时向 左 走，有时向 右 走。\n给你一个 非零 整数数组 nums 。蚂蚁会按顺序读取 nums 中的元素，从第一个元素开始直到结束。每一步，蚂蚁会根据当前元素的值移动：\n如果 nums[i] < 0 ，向 左 移动 -nums[i]单位。\n如果 nums[i] > 0 ，向 右 移动 nums[i]单位。\n返回蚂蚁 返回 到边界上的次数。\n注意：\n边界两侧有无限的空间。\n只有在蚂蚁移动了 |nums[i]| 单位后才检查它是否位于边界上。换句话说，如果蚂蚁只是在移动过程中穿过了边界，则不会计算在内。\n示例 1：\n输入nums = [2,3,-5]\n输出：1示例 2：\n输入nums = [3,2,-3,-4]\n输出：0\n\n提示：\n1 <= nums.length <= 100\n-10 <= nums[i] <= 10\nnums[i] != 0\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar returnToBoundaryCount = function(nums) {",
        "prompt_chat": "边界上有一只蚂蚁，它有时向 左 走，有时向 右 走。\n给你一个 非零 整数数组 nums 。蚂蚁会按顺序读取 nums 中的元素，从第一个元素开始直到结束。每一步，蚂蚁会根据当前元素的值移动：\n如果 nums[i] < 0 ，向 左 移动 -nums[i]单位。\n如果 nums[i] > 0 ，向 右 移动 nums[i]单位。\n返回蚂蚁 返回 到边界上的次数。\n注意：\n边界两侧有无限的空间。\n只有在蚂蚁移动了 |nums[i]| 单位后才检查它是否位于边界上。换句话说，如果蚂蚁只是在移动过程中穿过了边界，则不会计算在内。\n示例 1：\n输入nums = [2,3,-5]\n输出：1示例 2：\n输入nums = [3,2,-3,-4]\n输出：0\n\n提示：\n1 <= nums.length <= 100\n-10 <= nums[i] <= 10\nnums[i] != 0\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar returnToBoundaryCount = function(nums) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar returnToBoundaryCount = function (nums) {\n    let sum = 0, res = 0\n    nums.forEach(item => {\n        sum += item\n        if (sum === 0) {\n            res += 1\n        }\n    })\n    return res\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(returnToBoundaryCount([2,3,-5]), 1, \"Test 1 Error!\");\nassert.deepEqual(returnToBoundaryCount([3,2,-3,-4]), 0, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar returnToBoundaryCount = function(nums) {",
        "function_name": "returnToBoundaryCount",
        "difficulty_level": "Easy",
        "time": "20240204"
    },
    {
        "id": "3029",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的字符串 word 和一个整数 k 。\n在每一秒，你必须执行以下操作：\n移除 word 的前 k 个字符。\n在 word 的末尾添加 k 个任意字符。\n注意 添加的字符不必和移除的字符相同。但是，必须在每一秒钟都执行 两种 操作。\n返回将 word 恢复到其 初始 状态所需的 最短 时间（该时间必须大于零）。\n示例 1：\n输入word = \"abacaba\", k = 3\n输出：2示例 2：\n输入word = \"abacaba\", k = 4\n输出：1\n\n提示：\n1 <= word.length <= 50\n1 <= k <= word.length\nword仅由小写英文字母组成。\n\"\"\"\n\n/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar minimumTimeToInitialState = function(word, k) {",
        "prompt_chat": "给你一个下标从 0 开始的字符串 word 和一个整数 k 。\n在每一秒，你必须执行以下操作：\n移除 word 的前 k 个字符。\n在 word 的末尾添加 k 个任意字符。\n注意 添加的字符不必和移除的字符相同。但是，必须在每一秒钟都执行 两种 操作。\n返回将 word 恢复到其 初始 状态所需的 最短 时间（该时间必须大于零）。\n示例 1：\n输入word = \"abacaba\", k = 3\n输出：2示例 2：\n输入word = \"abacaba\", k = 4\n输出：1\n\n提示：\n1 <= word.length <= 50\n1 <= k <= word.length\nword仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar minimumTimeToInitialState = function(word, k) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumTimeToInitialState(\"abacaba\",3), 2, \"Test 1 Error!\");\nassert.deepEqual(minimumTimeToInitialState(\"abacaba\",4), 1, \"Test 2 Error!\");\nassert.deepEqual(minimumTimeToInitialState(\"abcbabcd\",2), 4, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar minimumTimeToInitialState = function(word, k) {",
        "function_name": "minimumTimeToInitialState",
        "difficulty_level": "Middle",
        "time": "20240204"
    },
    {
        "id": "3030",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始、大小为 m x n 的网格 image ，表示一个灰度图像，其中 image[i][j] 表示在范围 [0..255] 内的某个像素强度。另给你一个 非负 整数 threshold 。\n如果 image[a][b] 和 image[c][d] 满足 |a - c| + |b - d| == 1 ，则称这两个像素是 相邻像素 。\n区域 是一个 3 x 3 的子网格，且满足区域中任意两个 相邻 像素之间，像素强度的 绝对差 小于或等于 threshold 。\n区域 内的所有像素都认为属于该区域，而一个像素 可以 属于 多个 区域。\n你需要计算一个下标从 0 开始、大小为 m x n 的网格 result ，其中 result[i][j] 是 image[i][j] 所属区域的 平均 强度，向下取整 到最接近的整数。如果 image[i][j] 属于多个区域，result[i][j] 是这些区域的 “取整后的平均强度” 的 平均值，也 向下取整 到最接近的整数。如果 image[i][j] 不属于任何区域，则 result[i][j] 等于 image[i][j] 。\n返回网格 result 。\n示例 1：\n输入image = [[5,6,7,10],[8,9,10,10],[11,12,13,10]], threshold = 3\n输出：[[9,9,9,9],[9,9,9,9],[9,9,9,9]]示例 2：\n输入image = [[10,20,30],[15,25,35],[20,30,40],[25,35,45]], threshold = 12\n输出：[[25,25,25],[27,27,27],[27,27,27],[30,30,30]]\n\n提示：\n3 <= n, m <= 500\n0 <= image[i][j] <= 255\n0 <= threshold <= 255\n\"\"\"\n\n/**\n * @param {number[][]} image\n * @param {number} threshold\n * @return {number[][]}\n */\nvar resultGrid = function(image, threshold) {",
        "prompt_chat": "给你一个下标从 0 开始、大小为 m x n 的网格 image ，表示一个灰度图像，其中 image[i][j] 表示在范围 [0..255] 内的某个像素强度。另给你一个 非负 整数 threshold 。\n如果 image[a][b] 和 image[c][d] 满足 |a - c| + |b - d| == 1 ，则称这两个像素是 相邻像素 。\n区域 是一个 3 x 3 的子网格，且满足区域中任意两个 相邻 像素之间，像素强度的 绝对差 小于或等于 threshold 。\n区域 内的所有像素都认为属于该区域，而一个像素 可以 属于 多个 区域。\n你需要计算一个下标从 0 开始、大小为 m x n 的网格 result ，其中 result[i][j] 是 image[i][j] 所属区域的 平均 强度，向下取整 到最接近的整数。如果 image[i][j] 属于多个区域，result[i][j] 是这些区域的 “取整后的平均强度” 的 平均值，也 向下取整 到最接近的整数。如果 image[i][j] 不属于任何区域，则 result[i][j] 等于 image[i][j] 。\n返回网格 result 。\n示例 1：\n输入image = [[5,6,7,10],[8,9,10,10],[11,12,13,10]], threshold = 3\n输出：[[9,9,9,9],[9,9,9,9],[9,9,9,9]]示例 2：\n输入image = [[10,20,30],[15,25,35],[20,30,40],[25,35,45]], threshold = 12\n输出：[[25,25,25],[27,27,27],[27,27,27],[30,30,30]]\n\n提示：\n3 <= n, m <= 500\n0 <= image[i][j] <= 255\n0 <= threshold <= 255\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} image\n * @param {number} threshold\n * @return {number[][]}\n */\nvar resultGrid = function(image, threshold) {\n```",
        "solution": "/**\n * @param {number[][]} image\n * @param {number} threshold\n * @return {number[][]}\n */\nvar resultGrid = function (image, threshold) {\n  // 和image相同尺寸的二维数组并填充null\n  let res = image.map((innerArr) => innerArr.map(() => null));\n  // 寻找区域的左上角第一个元素\n  for (let i = 0; i < image.length - 2; i++) {\n    for (let j = 0; j < image[i].length - 2; j++) {\n      if (\n        !(Math.abs(image[i][j] - image[i + 1][j]) > threshold) &&\n        !(Math.abs(image[i][j] - image[i][j + 1]) > threshold) &&\n        !(Math.abs(image[i][j + 1] - image[i + 1][j + 1]) > threshold) &&\n        !(Math.abs(image[i][j + 1] - image[i][j + 2]) > threshold) &&\n        !(Math.abs(image[i][j + 2] - image[i + 1][j + 2]) > threshold) &&\n        !(Math.abs(image[i + 1][j] - image[i + 1][j + 1]) > threshold) &&\n        !(Math.abs(image[i + 1][j] - image[i + 2][j]) > threshold) &&\n        !(Math.abs(image[i + 2][j] - image[i + 2][j + 1]) > threshold) &&\n        !(Math.abs(image[i + 1][j + 1] - image[i + 2][j + 1]) > threshold) &&\n        !(Math.abs(image[i + 1][j + 1] - image[i + 1][j + 2]) > threshold) &&\n        !(Math.abs(image[i + 2][j + 1] - image[i + 2][j + 2]) > threshold) &&\n        !(Math.abs(image[i + 1][j + 2] - image[i + 2][j + 2]) > threshold)\n      ) {\n        // 这符合区域\n        // 累加并统计累加次数方便日后求均值\n        for (let a = 0; a < 3; a++) {\n          for (let b = 0; b < 3; b++) {\n            // 第一次先把null转成对象\n            if (!res[i + a][j + b])\n              res[i + a][j + b] = {\n                value: 0,\n                num: 0,\n              };\n            // 后续累加并记录累加次数\n            res[i + a][j + b].value += Math.floor(\n              (image[i][j] +\n                image[i][j + 1] +\n                image[i][j + 2] +\n                image[i + 1][j] +\n                image[i + 1][j + 1] +\n                image[i + 1][j + 2] +\n                image[i + 2][j] +\n                image[i + 2][j + 1] +\n                image[i + 2][j + 2]) /\n              9\n            );\n            res[i + a][j + b].num++;\n          }\n        }\n      }\n    }\n  }\n  res = res.map((v, i) => {\n    return v.map((item, j) => {\n      // 求均值\n      if (item) {\n        return Math.floor(item.value / item.num);\n      } else {\n        // 没有所属的区域\n        return image[i][j];\n      }\n    });\n  });\n  return res;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(resultGrid([[5,6,7,10],[8,9,10,10],[11,12,13,10]],3), [[9,9,9,9],[9,9,9,9],[9,9,9,9]], \"Test 1 Error!\");\nassert.deepEqual(resultGrid([[10,20,30],[15,25,35],[20,30,40],[25,35,45]],12), [[25,25,25],[27,27,27],[27,27,27],[30,30,30]], \"Test 2 Error!\");\nassert.deepEqual(resultGrid([[5,6,7],[8,9,10],[11,12,13]],1), [[5,6,7],[8,9,10],[11,12,13]], \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} image\n * @param {number} threshold\n * @return {number[][]}\n */\nvar resultGrid = function(image, threshold) {",
        "function_name": "resultGrid",
        "difficulty_level": "Middle",
        "time": "20240204"
    },
    {
        "id": "3031",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的字符串 word 和一个整数 k 。\n在每一秒，你必须执行以下操作：\n移除 word 的前 k 个字符。\n在 word 的末尾添加 k 个任意字符。\n注意 添加的字符不必和移除的字符相同。但是，必须在每一秒钟都执行 两种 操作。\n返回将 word 恢复到其 初始 状态所需的 最短 时间（该时间必须大于零）。\n示例 1：\n输入word = \"abacaba\", k = 3\n输出：2示例 2：\n输入word = \"abacaba\", k = 4\n输出：1\n\n提示：\n1 <= word.length <= 10^6\n1 <= k <= word.length\nword仅由小写英文字母组成。\n\"\"\"\n\n/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar minimumTimeToInitialState = function(word, k) {",
        "prompt_chat": "给你一个下标从 0 开始的字符串 word 和一个整数 k 。\n在每一秒，你必须执行以下操作：\n移除 word 的前 k 个字符。\n在 word 的末尾添加 k 个任意字符。\n注意 添加的字符不必和移除的字符相同。但是，必须在每一秒钟都执行 两种 操作。\n返回将 word 恢复到其 初始 状态所需的 最短 时间（该时间必须大于零）。\n示例 1：\n输入word = \"abacaba\", k = 3\n输出：2示例 2：\n输入word = \"abacaba\", k = 4\n输出：1\n\n提示：\n1 <= word.length <= 10^6\n1 <= k <= word.length\nword仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar minimumTimeToInitialState = function(word, k) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumTimeToInitialState(\"abacaba\",3), 2, \"Test 1 Error!\");\nassert.deepEqual(minimumTimeToInitialState(\"abacaba\",4), 1, \"Test 2 Error!\");\nassert.deepEqual(minimumTimeToInitialState(\"abcbabcd\",2), 4, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar minimumTimeToInitialState = function(word, k) {",
        "function_name": "minimumTimeToInitialState",
        "difficulty_level": "Hard",
        "time": "20240204"
    },
    {
        "id": "3033",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始、大小为 m x n 的整数矩阵 matrix ，新建一个下标从 0 开始、名为 answer 的矩阵。使 answer 与 matrix 相等，接着将其中每个值为 -1 的元素替换为所在列的 最大 元素。\n返回矩阵 answer 。\n示例 1：\n输入matrix = [[1,2,-1],[4,-1,6],[7,8,9]]\n输出：[[1,2,9],[4,8,6],[7,8,9]]示例 2：\n输入matrix = [[3,-1],[5,2]]\n输出：[[3,2],[5,2]]\n\n提示：\nm == matrix.length\nn == matrix[i].length\n2 <= m, n <= 50\n-1 <= matrix[i][j] <= 100\n测试用例中生成的输入满足每列至少包含一个非负整数。\n\"\"\"\n\n/**\n * @param {number[][]} matrix\n * @return {number[][]}\n */\nvar modifiedMatrix = function(matrix) {",
        "prompt_chat": "给你一个下标从 0 开始、大小为 m x n 的整数矩阵 matrix ，新建一个下标从 0 开始、名为 answer 的矩阵。使 answer 与 matrix 相等，接着将其中每个值为 -1 的元素替换为所在列的 最大 元素。\n返回矩阵 answer 。\n示例 1：\n输入matrix = [[1,2,-1],[4,-1,6],[7,8,9]]\n输出：[[1,2,9],[4,8,6],[7,8,9]]示例 2：\n输入matrix = [[3,-1],[5,2]]\n输出：[[3,2],[5,2]]\n\n提示：\nm == matrix.length\nn == matrix[i].length\n2 <= m, n <= 50\n-1 <= matrix[i][j] <= 100\n测试用例中生成的输入满足每列至少包含一个非负整数。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} matrix\n * @return {number[][]}\n */\nvar modifiedMatrix = function(matrix) {\n```",
        "solution": "var modifiedMatrix = function(matrix) {\n    let n = matrix.length;\n    let m = matrix[0].length;\n    for (let j = 0; j < m; j++) {\n        let zd = -1;\n        for (let i = 0; i < n; i++) {\n            zd = Math.max(zd, matrix[i][j]);\n        }\n        for (let i = 0; i < n; i++) {\n            if (matrix[i][j] == -1) {\n                matrix[i][j] = zd;\n            }\n        }\n    }\n    return matrix;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(modifiedMatrix([[1,2,-1],[4,-1,6],[7,8,9]]), [[1,2,9],[4,8,6],[7,8,9]], \"Test 1 Error!\");\nassert.deepEqual(modifiedMatrix([[3,-1],[5,2]]), [[3,2],[5,2]], \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} matrix\n * @return {number[][]}\n */\nvar modifiedMatrix = function(matrix) {",
        "function_name": "modifiedMatrix",
        "difficulty_level": "Easy",
        "time": "20240211"
    },
    {
        "id": "3034",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始长度为 n 的整数数组 nums ，和一个下标从 0 开始长度为 m 的整数数组 pattern ，pattern 数组只包含整数 -1 ，0 和 1 。\n大小为 m + 1 的子数组 nums[i..j] 如果对于每个元素 pattern[k] 都满足以下条件，那么我们说这个子数组匹配模式数组 pattern ：\n如果 pattern[k] == 1 ，那么 nums[i + k + 1] > nums[i + k]\n如果 pattern[k] == 0 ，那么 nums[i + k + 1] == nums[i + k]\n如果 pattern[k] == -1 ，那么 nums[i + k + 1] < nums[i + k]\n请你返回匹配 pattern 的 nums 子数组的 数目 。\n示例 1：\n输入nums = [1,2,3,4,5,6], pattern = [1,1]\n输出：4示例 2：\n输入nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]\n输出：2\n\n提示：\n2 <= n == nums.length <= 100\n1 <= nums[i] <= 10^9\n1 <= m == pattern.length < n\n-1 <= pattern[i] <= 1\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number[]} pattern\n * @return {number}\n */\nvar countMatchingSubarrays = function(nums, pattern) {",
        "prompt_chat": "给你一个下标从 0 开始长度为 n 的整数数组 nums ，和一个下标从 0 开始长度为 m 的整数数组 pattern ，pattern 数组只包含整数 -1 ，0 和 1 。\n大小为 m + 1 的子数组 nums[i..j] 如果对于每个元素 pattern[k] 都满足以下条件，那么我们说这个子数组匹配模式数组 pattern ：\n如果 pattern[k] == 1 ，那么 nums[i + k + 1] > nums[i + k]\n如果 pattern[k] == 0 ，那么 nums[i + k + 1] == nums[i + k]\n如果 pattern[k] == -1 ，那么 nums[i + k + 1] < nums[i + k]\n请你返回匹配 pattern 的 nums 子数组的 数目 。\n示例 1：\n输入nums = [1,2,3,4,5,6], pattern = [1,1]\n输出：4示例 2：\n输入nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]\n输出：2\n\n提示：\n2 <= n == nums.length <= 100\n1 <= nums[i] <= 10^9\n1 <= m == pattern.length < n\n-1 <= pattern[i] <= 1\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number[]} pattern\n * @return {number}\n */\nvar countMatchingSubarrays = function(nums, pattern) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @param {number[]} pattern\n * @return {number}\n */\nvar countMatchingSubarrays = function (nums, pattern) {\n  const obj = {\n    '-1': 'D',\n    '0': 'E',\n    '1': 'I',\n  }\n  const p = pattern.map(item => obj[item]).join('');\n\n  const n = nums.length;\n  let str = '';\n  for (let i = 0; i < n - 1; i++) {\n    if (nums[i + 1] > nums[i]) {\n      str += obj['1'];\n    } else if (nums[i + 1] === nums[i]) {\n      str += obj['0'];\n    } else {\n      str += obj['-1'];\n    }\n  }\n\n  let idx = -1;\n  let ans = 0;\n  while ((idx = str.indexOf(p, idx + 1)) !== -1) {\n    ans++;\n  }\n  return ans;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(countMatchingSubarrays([1,2,3,4,5,6],[1,1]), 4, \"Test 1 Error!\");\nassert.deepEqual(countMatchingSubarrays([1,4,4,1,3,5,5,3],[1,0,-1]), 2, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number[]} pattern\n * @return {number}\n */\nvar countMatchingSubarrays = function(nums, pattern) {",
        "function_name": "countMatchingSubarrays",
        "difficulty_level": "Middle",
        "time": "20240211"
    },
    {
        "id": "3035",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的字符串数组 words ，数组的长度为 n ，且包含下标从 0 开始的若干字符串。\n你可以执行以下操作 任意 次数（包括零次）：\n选择整数i、j、x和y，满足0 <= i, j < n，0 <= x < words[i].length，0 <= y < words[j].length，交换 字符 words[i][x] 和 words[j][y] 。\n返回一个整数，表示在执行一些操作后，words 中可以包含的回文串的 最大 数量。\n注意：在操作过程中，i 和 j 可以相等。\n示例 1：\n输入words = [\"abbb\",\"ba\",\"aa\"]\n输出：3示例 2：\n输入words = [\"abc\",\"ab\"]\n输出：2\n\n提示：\n1 <= words.length <= 1000\n1 <= words[i].length <= 100\nwords[i] 仅由小写英文字母组成。\n\"\"\"\n\n/**\n * @param {string[]} words\n * @return {number}\n */\nvar maxPalindromesAfterOperations = function(words) {",
        "prompt_chat": "给你一个下标从 0 开始的字符串数组 words ，数组的长度为 n ，且包含下标从 0 开始的若干字符串。\n你可以执行以下操作 任意 次数（包括零次）：\n选择整数i、j、x和y，满足0 <= i, j < n，0 <= x < words[i].length，0 <= y < words[j].length，交换 字符 words[i][x] 和 words[j][y] 。\n返回一个整数，表示在执行一些操作后，words 中可以包含的回文串的 最大 数量。\n注意：在操作过程中，i 和 j 可以相等。\n示例 1：\n输入words = [\"abbb\",\"ba\",\"aa\"]\n输出：3示例 2：\n输入words = [\"abc\",\"ab\"]\n输出：2\n\n提示：\n1 <= words.length <= 1000\n1 <= words[i].length <= 100\nwords[i] 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string[]} words\n * @return {number}\n */\nvar maxPalindromesAfterOperations = function(words) {\n```",
        "solution": "/**\n * @param {string[]} words\n * @return {number}\n */\nvar maxPalindromesAfterOperations = function(words) {\n    //统计每个字母出现的次数\n    const arr=new Array(26).fill(0)\n    for(const word of words){\n        for(const s of word){\n            const i=s.charCodeAt()-'a'.charCodeAt()\n            arr[i]+=1\n        }\n    }\n\n    //计算可以用来组成回文串的一侧的字母的个数\n    let left=arr.reduce((pre,cur)=>pre+=(cur>>1),0)\n\n    //按照字符串长度，从小到大填入字母\n    let ans=0\n    words.sort((a,b)=>(a.length-b.length))\n        for(const word of words){\n            const len=word.length>>1\n            if(left<len){\n                break\n            }\n            left-=len\n            ans+=1\n        }\n    return ans\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maxPalindromesAfterOperations([\"abbb\",\"ba\",\"aa\"]), 3, \"Test 1 Error!\");\nassert.deepEqual(maxPalindromesAfterOperations([\"abc\",\"ab\"]), 2, \"Test 2 Error!\");\nassert.deepEqual(maxPalindromesAfterOperations([\"cd\",\"ef\",\"a\"]), 1, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string[]} words\n * @return {number}\n */\nvar maxPalindromesAfterOperations = function(words) {",
        "function_name": "maxPalindromesAfterOperations",
        "difficulty_level": "Middle",
        "time": "20240211"
    },
    {
        "id": "3036",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始长度为 n 的整数数组 nums ，和一个下标从 0 开始长度为 m 的整数数组 pattern ，pattern 数组只包含整数 -1 ，0 和 1 。\n大小为 m + 1 的子数组 nums[i..j] 如果对于每个元素 pattern[k] 都满足以下条件，那么我们说这个子数组匹配模式数组 pattern ：\n如果 pattern[k] == 1 ，那么 nums[i + k + 1] > nums[i + k]\n如果 pattern[k] == 0 ，那么 nums[i + k + 1] == nums[i + k]\n如果 pattern[k] == -1 ，那么 nums[i + k + 1] < nums[i + k]\n请你返回匹配 pattern 的 nums 子数组的 数目 。\n示例 1：\n输入nums = [1,2,3,4,5,6], pattern = [1,1]\n输出：4示例 2：\n输入nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]\n输出：2\n\n提示：\n2 <= n == nums.length <= 10^6\n1 <= nums[i] <= 10^9\n1 <= m == pattern.length < n\n-1 <= pattern[i] <= 1\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number[]} pattern\n * @return {number}\n */\nvar countMatchingSubarrays = function(nums, pattern) {",
        "prompt_chat": "给你一个下标从 0 开始长度为 n 的整数数组 nums ，和一个下标从 0 开始长度为 m 的整数数组 pattern ，pattern 数组只包含整数 -1 ，0 和 1 。\n大小为 m + 1 的子数组 nums[i..j] 如果对于每个元素 pattern[k] 都满足以下条件，那么我们说这个子数组匹配模式数组 pattern ：\n如果 pattern[k] == 1 ，那么 nums[i + k + 1] > nums[i + k]\n如果 pattern[k] == 0 ，那么 nums[i + k + 1] == nums[i + k]\n如果 pattern[k] == -1 ，那么 nums[i + k + 1] < nums[i + k]\n请你返回匹配 pattern 的 nums 子数组的 数目 。\n示例 1：\n输入nums = [1,2,3,4,5,6], pattern = [1,1]\n输出：4示例 2：\n输入nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]\n输出：2\n\n提示：\n2 <= n == nums.length <= 10^6\n1 <= nums[i] <= 10^9\n1 <= m == pattern.length < n\n-1 <= pattern[i] <= 1\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number[]} pattern\n * @return {number}\n */\nvar countMatchingSubarrays = function(nums, pattern) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @param {number[]} pattern\n * @return {number}\n */\nvar countMatchingSubarrays = function(nums, pattern) {\nlet n=nums.length\nconst nstr=[]\nfor(let i=0;i<n-1;i++){\n    let diff=nums[i]-nums[i+1]\n    if(diff<0){\n        nstr.push(1)\n    }else if(diff==0){\n nstr.push(0)\n    }else{\n nstr.push(2)\n    }\n}\nconst s = nstr.join('');\nconst p = pattern.map((item)=>{\n    if(item==-1){\n        return 2\n    }else{\n        return item\n    }\n}).join('')\n\nreturn match(s,p).length\nfunction match(str, pattern) {\n  const n = str.length;\n  const m = pattern.length;\n  \n  // 生成 next 数组\n  const next = Array(m).fill(0);\n  for (let i = 1, j = 0; i < m; i++) {\n    while (j > 0 && pattern[i] !== pattern[j]) {\n      j = next[j - 1];\n    }\n    if (pattern[i] === pattern[j]) {\n      j++;\n    }\n    next[i] = j;\n  }\n  \n  // 匹配字符串\n  const res = [];\n  for (let i = 0, j = 0; i < n; i++) {\n    while (j > 0 && str[i] !== pattern[j]) {\n      j = next[j - 1];\n    }\n    if (str[i] === pattern[j]) {\n      j++;\n    }\n    if (j === m) {\n      res.push(i - m + 1);\n      j = next[j - 1];\n    }\n  }\n  \n  return res; // 返回所有匹配的起始位置\n}\n\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(countMatchingSubarrays([1,2,3,4,5,6],[1,1]), 4, \"Test 1 Error!\");\nassert.deepEqual(countMatchingSubarrays([1,4,4,1,3,5,5,3],[1,0,-1]), 2, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number[]} pattern\n * @return {number}\n */\nvar countMatchingSubarrays = function(nums, pattern) {",
        "function_name": "countMatchingSubarrays",
        "difficulty_level": "Hard",
        "time": "20240211"
    },
    {
        "id": "3038",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums ，如果 nums 至少 包含 2 个元素，你可以执行以下操作：\n选择 nums 中的前两个元素并将它们删除。\n一次操作的 分数 是被删除元素的和。\n在确保 所有操作分数相同 的前提下，请你求出 最多 能进行多少次操作。\n请你返回按照上述要求 最多 可以进行的操作次数。\n示例 1：\n输入nums = [3,2,1,4,5]\n输出：2示例 2：\n输入nums = [3,2,6,1,4]\n输出：1\n\n提示：\n2 <= nums.length <= 100\n1 <= nums[i] <= 1000\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxOperations = function(nums) {",
        "prompt_chat": "给你一个整数数组 nums ，如果 nums 至少 包含 2 个元素，你可以执行以下操作：\n选择 nums 中的前两个元素并将它们删除。\n一次操作的 分数 是被删除元素的和。\n在确保 所有操作分数相同 的前提下，请你求出 最多 能进行多少次操作。\n请你返回按照上述要求 最多 可以进行的操作次数。\n示例 1：\n输入nums = [3,2,1,4,5]\n输出：2示例 2：\n输入nums = [3,2,6,1,4]\n输出：1\n\n提示：\n2 <= nums.length <= 100\n1 <= nums[i] <= 1000\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxOperations = function(nums) {\n```",
        "solution": "var maxOperations = function(nums) {\n    let n = nums.length, t = 0;\n    for (let i = 1; i < n; i += 2) {\n        if (nums[i] + nums[i - 1] != nums[1] + nums[0]) {\n            break;\n        }\n        t++;\n    }\n    return t;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maxOperations([3,2,1,4,5]), 2, \"Test 1 Error!\");\nassert.deepEqual(maxOperations([3,2,6,1,4]), 1, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxOperations = function(nums) {",
        "function_name": "maxOperations",
        "difficulty_level": "Easy",
        "time": "20240217"
    },
    {
        "id": "3039",
        "prompt_base": "\"\"\"\n给你一个字符串 s 。请你进行以下操作直到 s 为 空 ：\n每次操作 依次 遍历 'a' 到 'z'，如果当前字符出现在 s 中，那么删除出现位置 最早 的该字符（如果存在的话）。\n例如，最初 s = \\\"aabcbbca\\\"。我们执行下述操作：\n移除下划线的字符  s = \\\"\\undeline{a}a\\underline{bc}bbca\\\"。结果字符串为 s = \\\"abbca\\\"。\n移除下划线的字符  s = \\\"\\underline{ab}b\\underline{c}a\\\"。结果字符串为 s = \\\"ba\\\"。\n移除下划线的字符  s = \\\"\\underline{ba}\\\"。结果字符串为 s = \\\"\\\"。\n请你返回进行 最后 一次操作 之前 的字符串 s 。在上面的例子中，答案是 \\\"ba\\\"。\n示例 1：\n输入s = \"aabcbbca\"\n输出：\"ba\"示例 2：\n输入s = \"abcd\"\n输出：\"abcd\"\n\n提示：\n1 <= s.length <= 5 * 10^5\ns 只包含小写英文字母。\n\"\"\"\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar lastNonEmptyString = function(s) {",
        "prompt_chat": "给你一个字符串 s 。请你进行以下操作直到 s 为 空 ：\n每次操作 依次 遍历 'a' 到 'z'，如果当前字符出现在 s 中，那么删除出现位置 最早 的该字符（如果存在的话）。\n例如，最初 s = \\\"aabcbbca\\\"。我们执行下述操作：\n移除下划线的字符  s = \\\"\\undeline{a}a\\underline{bc}bbca\\\"。结果字符串为 s = \\\"abbca\\\"。\n移除下划线的字符  s = \\\"\\underline{ab}b\\underline{c}a\\\"。结果字符串为 s = \\\"ba\\\"。\n移除下划线的字符  s = \\\"\\underline{ba}\\\"。结果字符串为 s = \\\"\\\"。\n请你返回进行 最后 一次操作 之前 的字符串 s 。在上面的例子中，答案是 \\\"ba\\\"。\n示例 1：\n输入s = \"aabcbbca\"\n输出：\"ba\"示例 2：\n输入s = \"abcd\"\n输出：\"abcd\"\n\n提示：\n1 <= s.length <= 5 * 10^5\ns 只包含小写英文字母。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar lastNonEmptyString = function(s) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(lastNonEmptyString(\"aabcbbca\"), \"ba\", \"Test 1 Error!\");\nassert.deepEqual(lastNonEmptyString(\"abcd\"), \"abcd\", \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} s\n * @return {string}\n */\nvar lastNonEmptyString = function(s) {",
        "function_name": "lastNonEmptyString",
        "difficulty_level": "Middle",
        "time": "20240217"
    },
    {
        "id": "3040",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums ，如果 nums 至少 包含 2 个元素，你可以执行以下操作中的 任意 一个：\n选择 nums 中最前面两个元素并且删除它们。\n选择 nums 中最后两个元素并且删除它们。\n选择 nums 中第一个和最后一个元素并且删除它们。\n一次操作的 分数 是被删除元素的和。\n在确保 所有操作分数相同 的前提下，请你求出 最多 能进行多少次操作。\n请你返回按照上述要求 最多 可以进行的操作次数。\n示例 1：\n输入nums = [3,2,1,2,3,4]\n输出：3示例 2：\n输入nums = [3,2,6,1,4]\n输出：2\n\n提示：\n2 <= nums.length <= 2000\n1 <= nums[i] <= 1000\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxOperations = function(nums) {",
        "prompt_chat": "给你一个整数数组 nums ，如果 nums 至少 包含 2 个元素，你可以执行以下操作中的 任意 一个：\n选择 nums 中最前面两个元素并且删除它们。\n选择 nums 中最后两个元素并且删除它们。\n选择 nums 中第一个和最后一个元素并且删除它们。\n一次操作的 分数 是被删除元素的和。\n在确保 所有操作分数相同 的前提下，请你求出 最多 能进行多少次操作。\n请你返回按照上述要求 最多 可以进行的操作次数。\n示例 1：\n输入nums = [3,2,1,2,3,4]\n输出：3示例 2：\n输入nums = [3,2,6,1,4]\n输出：2\n\n提示：\n2 <= nums.length <= 2000\n1 <= nums[i] <= 1000\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxOperations = function(nums) {\n```",
        "solution": "var maxOperations = function(nums) {\n    const n = nums.length;\n    const helper = (i, j, target) => {\n        const memo = Array.from({ length: n }, () => Array(n).fill(-1));\n        const dfs = (i, j) => {\n            if (i >= j) {\n                return 0;\n            }\n            if (memo[i][j] != -1) {\n                return memo[i][j];\n            }\n            let ans = 0;\n            if (nums[i] + nums[i + 1] == target) {\n                ans = Math.max(ans, 1 + dfs(i + 2, j));\n            }\n            if (nums[j - 1] + nums[j] == target) {\n                ans = Math.max(ans, 1 + dfs(i, j - 2));\n            }\n            if (nums[i] + nums[j] == target) {\n                ans = Math.max(ans, 1 + dfs(i + 1, j - 1));\n            }\n            memo[i][j] = ans;\n            return ans;\n        }\n        return dfs(i, j);\n    }\n\n    let res = 0;\n    res = Math.max(res, helper(0, n - 1, nums[0] + nums[n - 1]));\n    res = Math.max(res, helper(0, n - 1, nums[0] + nums[1]));\n    res = Math.max(res, helper(0, n - 1, nums[n - 2] + nums[n - 1]));\n    return res;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maxOperations([3,2,1,2,3,4]), 3, \"Test 1 Error!\");\nassert.deepEqual(maxOperations([3,2,6,1,4]), 2, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxOperations = function(nums) {",
        "function_name": "maxOperations",
        "difficulty_level": "Middle",
        "time": "20240217"
    },
    {
        "id": "3041",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始只包含 正 整数的数组 nums 。一开始，你可以将数组中 任意数量 元素增加 至多 1 。\n修改后，你可以从最终数组中选择 一个或者更多 元素，并确保这些元素升序排序后是 连续 的。比方说，[3, 4, 5] 是连续的，但是 [3, 4, 6] 和 [1, 1, 2, 3] 不是连续的。\n请你返回 最多 可以选出的元素数目。\n示例 1：\n输入nums = [2,1,5,1,1]\n输出：3示例 2：\n输入nums = [1,4,7,10]\n输出：1\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^6\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSelectedElements = function(nums) {",
        "prompt_chat": "给你一个下标从 0 开始只包含 正 整数的数组 nums 。一开始，你可以将数组中 任意数量 元素增加 至多 1 。\n修改后，你可以从最终数组中选择 一个或者更多 元素，并确保这些元素升序排序后是 连续 的。比方说，[3, 4, 5] 是连续的，但是 [3, 4, 6] 和 [1, 1, 2, 3] 不是连续的。\n请你返回 最多 可以选出的元素数目。\n示例 1：\n输入nums = [2,1,5,1,1]\n输出：3示例 2：\n输入nums = [1,4,7,10]\n输出：1\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^6\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSelectedElements = function(nums) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSelectedElements = function(nums) {\n    const sortSums = nums.sort((a,b) => a-b)\n    const len = nums.length;\n    let count = 0\n    for(let i = 0; i < len - count; i++) {\n        let cur = sortSums[i]\n        let cLen = 1;\n        for(let j = i + 1; j < len; j++) {\n            const item = sortSums[j]\n            if(item < cur) {\n                continue;\n            }\n            if(item === cur) {\n                cur++;\n                cLen++\n                continue;\n            }\n            if(item === cur + 1) {\n\n                cur++;\n                cLen++\n                continue;\n            }\n            if(item > cur + 1) {\n                if(item > cur + 2) {\n                    // 相差大于2 开头直接跳到 j 因为后面 i ++ 所以这里 j 需要 - 1\n                    i = j - 1;\n                }\n                break;\n            }\n        }\n        count = Math.max(count, cLen)\n        cur = sortSums[i] + 1\n        cLen = 1;\n        for(let j = i + 1; j < len; j++) {\n            const item = sortSums[j]\n            if(item < cur) {\n                continue;\n            }\n            if(item === cur) {\n                cur++;\n                cLen++\n                continue;\n            }\n            if(item === cur + 1) {\n                cur++;\n                cLen++\n                continue;\n            }\n            if(item > cur + 1) {\n                if(item > cur + 2) {\n                    i = j - 1;\n                }\n                break;\n            }\n        }\n        count = Math.max(count, cLen)\n    }\n    return count\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maxSelectedElements([2,1,5,1,1]), 3, \"Test 1 Error!\");\nassert.deepEqual(maxSelectedElements([1,4,7,10]), 1, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSelectedElements = function(nums) {",
        "function_name": "maxSelectedElements",
        "difficulty_level": "Hard",
        "time": "20240217"
    },
    {
        "id": "3042",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的字符串数组 words。\n定义一个 布尔 函数 isPrefixAndSuffix ，它接受两个字符串参数 str1 和 str2 ：\n当 str1 同时是 str2 的前缀（prefix）和后缀（suffix）时，isPrefixAndSuffix(str1, str2) 返回 true，否则返回 false。\n例如，isPrefixAndSuffix(\\\"aba\\\", \\\"ababa\\\") 返回 true，因为 \\\"aba\\\" 既是 \\\"ababa\\\" 的前缀，也是 \\\"ababa\\\" 的后缀，但是 isPrefixAndSuffix(\\\"abc\\\", \\\"abcd\\\") 返回 false。\n以整数形式，返回满足 i < j 且 isPrefixAndSuffix(words[i], words[j]) 为 true 的下标对 (i, j) 的 数量 。\n示例 1：\n输入words = [\"a\",\"aba\",\"ababa\",\"aa\"]\n输出：4示例 2：\n输入words = [\"pa\",\"papa\",\"ma\",\"mama\"]\n输出：2\n\n提示：\n1 <= words.length <= 50\n1 <= words[i].length <= 10\nwords[i] 仅由小写英文字母组成。\n\"\"\"\n\n/**\n * @param {string[]} words\n * @return {number}\n */\nvar countPrefixSuffixPairs = function(words) {",
        "prompt_chat": "给你一个下标从 0 开始的字符串数组 words。\n定义一个 布尔 函数 isPrefixAndSuffix ，它接受两个字符串参数 str1 和 str2 ：\n当 str1 同时是 str2 的前缀（prefix）和后缀（suffix）时，isPrefixAndSuffix(str1, str2) 返回 true，否则返回 false。\n例如，isPrefixAndSuffix(\\\"aba\\\", \\\"ababa\\\") 返回 true，因为 \\\"aba\\\" 既是 \\\"ababa\\\" 的前缀，也是 \\\"ababa\\\" 的后缀，但是 isPrefixAndSuffix(\\\"abc\\\", \\\"abcd\\\") 返回 false。\n以整数形式，返回满足 i < j 且 isPrefixAndSuffix(words[i], words[j]) 为 true 的下标对 (i, j) 的 数量 。\n示例 1：\n输入words = [\"a\",\"aba\",\"ababa\",\"aa\"]\n输出：4示例 2：\n输入words = [\"pa\",\"papa\",\"ma\",\"mama\"]\n输出：2\n\n提示：\n1 <= words.length <= 50\n1 <= words[i].length <= 10\nwords[i] 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string[]} words\n * @return {number}\n */\nvar countPrefixSuffixPairs = function(words) {\n```",
        "solution": "/**\n * @param {string[]} words\n * @return {number}\n */\nvar countPrefixSuffixPairs = function(words) {\n  let count = 0;\n\n    for (let i = 0; i < words.length; i++) {\n        for (let j = i + 1; j < words.length; j++) {\n            if (words[i].length <= words[j].length && \n                words[j].startsWith(words[i]) && \n                words[j].endsWith(words[i])) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(countPrefixSuffixPairs([\"a\",\"aba\",\"ababa\",\"aa\"]), 4, \"Test 1 Error!\");\nassert.deepEqual(countPrefixSuffixPairs([\"pa\",\"papa\",\"ma\",\"mama\"]), 2, \"Test 2 Error!\");\nassert.deepEqual(countPrefixSuffixPairs([\"abab\",\"ab\"]), 0, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string[]} words\n * @return {number}\n */\nvar countPrefixSuffixPairs = function(words) {",
        "function_name": "countPrefixSuffixPairs",
        "difficulty_level": "Easy",
        "time": "20240218"
    },
    {
        "id": "3043",
        "prompt_base": "\"\"\"\n给你两个 正整数 数组 arr1 和 arr2 。正整数的 前缀 是其 最左边 的一位或多位数字组成的整数。例如，123 是整数 12345 的前缀，而 234 不是 。\n设若整数 c 是整数 a 和 b 的 公共前缀 ，那么 c 需要同时是 a 和 b 的前缀。例如，5655359 和 56554 有公共前缀 565 ，而 1223 和 43456 没有 公共前缀。\n你需要找出属于 arr1 的整数 x 和属于 arr2 的整数 y 组成的所有数对 (x, y) 之中最长的公共前缀的长度。\n返回所有数对之中最长公共前缀的长度。如果它们之间不存在公共前缀，则返回 0 。\n示例 1：\n输入arr1 = [1,10,100], arr2 = [1000]\n输出：3示例 2：\n输入arr1 = [1,2,3], arr2 = [4,4,4]\n输出：0\n\n提示：\n1 <= arr1.length, arr2.length <= 5 * 10^4\n1 <= arr1[i], arr2[i] <= 10^8\n\"\"\"\n\n/**\n * @param {number[]} arr1\n * @param {number[]} arr2\n * @return {number}\n */\nvar longestCommonPrefix = function(arr1, arr2) {",
        "prompt_chat": "给你两个 正整数 数组 arr1 和 arr2 。正整数的 前缀 是其 最左边 的一位或多位数字组成的整数。例如，123 是整数 12345 的前缀，而 234 不是 。\n设若整数 c 是整数 a 和 b 的 公共前缀 ，那么 c 需要同时是 a 和 b 的前缀。例如，5655359 和 56554 有公共前缀 565 ，而 1223 和 43456 没有 公共前缀。\n你需要找出属于 arr1 的整数 x 和属于 arr2 的整数 y 组成的所有数对 (x, y) 之中最长的公共前缀的长度。\n返回所有数对之中最长公共前缀的长度。如果它们之间不存在公共前缀，则返回 0 。\n示例 1：\n输入arr1 = [1,10,100], arr2 = [1000]\n输出：3示例 2：\n输入arr1 = [1,2,3], arr2 = [4,4,4]\n输出：0\n\n提示：\n1 <= arr1.length, arr2.length <= 5 * 10^4\n1 <= arr1[i], arr2[i] <= 10^8\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} arr1\n * @param {number[]} arr2\n * @return {number}\n */\nvar longestCommonPrefix = function(arr1, arr2) {\n```",
        "solution": "/**\n * @param {number[]} arr1\n * @param {number[]} arr2\n * @return {number}\n */\nvar longestCommonPrefix = function(arr1, arr2) {\n    let set = new Set(), max = 0\n    for(let x of arr2){\n        for(let y = x; y > 0; y = y/10 >> 0  ){\n            set.add(y)\n        }\n    }\n    for(let x of arr1){\n       let len = 0 \n       for(let y = x; y > 0; y = y/10 >> 0) len++\n       for(let y = x; y > 0; y = y/10 >> 0){\n         if(set.has(y)){\n             max = Math.max(max, len)\n             break\n         }\n         len--\n       }\n    }\n    return max  \n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(longestCommonPrefix([1,10,100],[1000]), 3, \"Test 1 Error!\");\nassert.deepEqual(longestCommonPrefix([1,2,3],[4,4,4]), 0, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} arr1\n * @param {number[]} arr2\n * @return {number}\n */\nvar longestCommonPrefix = function(arr1, arr2) {",
        "function_name": "longestCommonPrefix",
        "difficulty_level": "Middle",
        "time": "20240218"
    },
    {
        "id": "3044",
        "prompt_base": "\"\"\"\n给你一个大小为 m x n 、下标从 0 开始的二维矩阵 mat 。在每个单元格，你可以按以下方式生成数字：\n最多有 8 条路径可以选择：东，东南，南，西南，西，西北，北，东北。\n选择其中一条路径，沿着这个方向移动，并且将路径上的数字添加到正在形成的数字后面。\n注意，每一步都会生成数字，例如，如果路径上的数字是 1, 9, 1，那么在这个方向上会生成三个数字：1, 19, 191 。\n返回在遍历矩阵所创建的所有数字中，出现频率最高的、大于 10的质数；如果不存在这样的质数，则返回 -1 。如果存在多个出现频率最高的质数，那么返回其中最大的那个。\n注意：移动过程中不允许改变方向。\n示例 1：\n输入mat = [[1,1],[9,9],[1,1]]\n输出：19示例 2：\n输入mat = [[7]]\n输出：-1\n\n提示：\nm == mat.length\nn == mat[i].length\n1 <= m, n <= 6\n1 <= mat[i][j] <= 9\n\"\"\"\n\n/**\n * @param {number[][]} mat\n * @return {number}\n */\nvar mostFrequentPrime = function(mat) {",
        "prompt_chat": "给你一个大小为 m x n 、下标从 0 开始的二维矩阵 mat 。在每个单元格，你可以按以下方式生成数字：\n最多有 8 条路径可以选择：东，东南，南，西南，西，西北，北，东北。\n选择其中一条路径，沿着这个方向移动，并且将路径上的数字添加到正在形成的数字后面。\n注意，每一步都会生成数字，例如，如果路径上的数字是 1, 9, 1，那么在这个方向上会生成三个数字：1, 19, 191 。\n返回在遍历矩阵所创建的所有数字中，出现频率最高的、大于 10的质数；如果不存在这样的质数，则返回 -1 。如果存在多个出现频率最高的质数，那么返回其中最大的那个。\n注意：移动过程中不允许改变方向。\n示例 1：\n输入mat = [[1,1],[9,9],[1,1]]\n输出：19示例 2：\n输入mat = [[7]]\n输出：-1\n\n提示：\nm == mat.length\nn == mat[i].length\n1 <= m, n <= 6\n1 <= mat[i][j] <= 9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} mat\n * @return {number}\n */\nvar mostFrequentPrime = function(mat) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(mostFrequentPrime([[1,1],[9,9],[1,1]]), 19, \"Test 1 Error!\");\nassert.deepEqual(mostFrequentPrime([[7]]), -1, \"Test 2 Error!\");\nassert.deepEqual(mostFrequentPrime([[9,7,8],[4,6,5],[2,8,6]]), 97, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} mat\n * @return {number}\n */\nvar mostFrequentPrime = function(mat) {",
        "function_name": "mostFrequentPrime",
        "difficulty_level": "Middle",
        "time": "20240218"
    },
    {
        "id": "3045",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的字符串数组 words 。\n定义一个 布尔 函数 isPrefixAndSuffix ，它接受两个字符串参数 str1 和 str2 ：\n当 str1 同时是 str2 的前缀（prefix）和后缀（suffix）时，isPrefixAndSuffix(str1, str2) 返回 true，否则返回 false。\n例如，isPrefixAndSuffix(\\\"aba\\\", \\\"ababa\\\") 返回 true，因为 \\\"aba\\\" 既是 \\\"ababa\\\" 的前缀，也是 \\\"ababa\\\" 的后缀，但是 isPrefixAndSuffix(\\\"abc\\\", \\\"abcd\\\") 返回 false。\n以整数形式，返回满足 i < j 且 isPrefixAndSuffix(words[i], words[j]) 为 true 的下标对 (i, j) 的 数量 。\n示例 1：\n输入words = [\"a\",\"aba\",\"ababa\",\"aa\"]\n输出：4示例 2：\n输入words = [\"pa\",\"papa\",\"ma\",\"mama\"]\n输出：2\n\n提示：\n1 <= words.length <= 10^5\n1 <= words[i].length <= 10^5\nwords[i] 仅由小写英文字母组成。\n所有 words[i] 的长度之和不超过 5 * 10^5 。\n\"\"\"\n\n/**\n * @param {string[]} words\n * @return {number}\n */\nvar countPrefixSuffixPairs = function(words) {",
        "prompt_chat": "给你一个下标从 0 开始的字符串数组 words 。\n定义一个 布尔 函数 isPrefixAndSuffix ，它接受两个字符串参数 str1 和 str2 ：\n当 str1 同时是 str2 的前缀（prefix）和后缀（suffix）时，isPrefixAndSuffix(str1, str2) 返回 true，否则返回 false。\n例如，isPrefixAndSuffix(\\\"aba\\\", \\\"ababa\\\") 返回 true，因为 \\\"aba\\\" 既是 \\\"ababa\\\" 的前缀，也是 \\\"ababa\\\" 的后缀，但是 isPrefixAndSuffix(\\\"abc\\\", \\\"abcd\\\") 返回 false。\n以整数形式，返回满足 i < j 且 isPrefixAndSuffix(words[i], words[j]) 为 true 的下标对 (i, j) 的 数量 。\n示例 1：\n输入words = [\"a\",\"aba\",\"ababa\",\"aa\"]\n输出：4示例 2：\n输入words = [\"pa\",\"papa\",\"ma\",\"mama\"]\n输出：2\n\n提示：\n1 <= words.length <= 10^5\n1 <= words[i].length <= 10^5\nwords[i] 仅由小写英文字母组成。\n所有 words[i] 的长度之和不超过 5 * 10^5 。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string[]} words\n * @return {number}\n */\nvar countPrefixSuffixPairs = function(words) {\n```",
        "solution": "/**\n * @param {string[]} words\n * @return {number}\n */\nvar countPrefixSuffixPairs = function(words) {\n    const map = new Map()\n    let ans = 0\n    const strHash = () => {\n        return {\n            hash: 0,\n            basePower: 1,\n            mod: 1000000000,\n            base: 666,\n            pushChar: function (x) {\n                this.hash = (x.charCodeAt() * this.basePower + this.hash) % this.mod\n                this.basePower = (this.basePower * this.base) % this.mod\n            },\n            unShiftChar: function (x) {\n                this.hash = (this.hash * this.base + x.charCodeAt()) % this.mod\n                this.basePower = (this.basePower * this.base) % this.mod\n            }\n        }\n    }\n    for (let word of words) {\n        let len = word.length\n        let l = strHash(), r = strHash()\n        for (let i = 0, j = len - 1; i < len; i++, j--) {\n            l.pushChar(word[i])\n            r.unShiftChar(word[j])\n            if (l.hash === r.hash && map.has(l.hash)) {\n                ans += map.get(l.hash)\n            }\n        }\n        map.set(l.hash, (map.get(l.hash) || 0) + 1)\n    }\n    return ans\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(countPrefixSuffixPairs([\"a\",\"aba\",\"ababa\",\"aa\"]), 4, \"Test 1 Error!\");\nassert.deepEqual(countPrefixSuffixPairs([\"pa\",\"papa\",\"ma\",\"mama\"]), 2, \"Test 2 Error!\");\nassert.deepEqual(countPrefixSuffixPairs([\"abab\",\"ab\"]), 0, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string[]} words\n * @return {number}\n */\nvar countPrefixSuffixPairs = function(words) {",
        "function_name": "countPrefixSuffixPairs",
        "difficulty_level": "Hard",
        "time": "20240218"
    },
    {
        "id": "3046",
        "prompt_base": "\"\"\"\n给你一个长度为 偶数 的整数数组 nums 。你需要将这个数组分割成 nums1 和 nums2 两部分，要求：\nnums1.length == nums2.length == nums.length / 2 。\nnums1 应包含 互不相同 的元素。\nnums2也应包含 互不相同 的元素。\n如果能够分割数组就返回 true ，否则返回 false 。\n示例 1：\n输入nums = [1,1,2,2,3,4]\n输出：true示例 2：\n输入nums = [1,1,1,1]\n输出：false\n\n提示：\n1 <= nums.length <= 100\nnums.length % 2 == 0\n1 <= nums[i] <= 100\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar isPossibleToSplit = function(nums) {",
        "prompt_chat": "给你一个长度为 偶数 的整数数组 nums 。你需要将这个数组分割成 nums1 和 nums2 两部分，要求：\nnums1.length == nums2.length == nums.length / 2 。\nnums1 应包含 互不相同 的元素。\nnums2也应包含 互不相同 的元素。\n如果能够分割数组就返回 true ，否则返回 false 。\n示例 1：\n输入nums = [1,1,2,2,3,4]\n输出：true示例 2：\n输入nums = [1,1,1,1]\n输出：false\n\n提示：\n1 <= nums.length <= 100\nnums.length % 2 == 0\n1 <= nums[i] <= 100\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar isPossibleToSplit = function(nums) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar isPossibleToSplit = function(nums) {\n    let map =new Map()\n    for(let i of nums){\n        if(map.has(i)){\n            let time=map.get(i)\n            map.set(i,time+1)\n            if(time+1>2){\n                return false\n            }\n        }else{\n            map.set(i,1)\n        }\n    }\n    return true\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(isPossibleToSplit([1,1,2,2,3,4]), true, \"Test 1 Error!\");\nassert.deepEqual(isPossibleToSplit([1,1,1,1]), false, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar isPossibleToSplit = function(nums) {",
        "function_name": "isPossibleToSplit",
        "difficulty_level": "Easy",
        "time": "20240225"
    },
    {
        "id": "3047",
        "prompt_base": "\"\"\"\n在二维平面上存在 n 个矩形。给你两个下标从 0 开始的二维整数数组 bottomLeft 和 topRight，两个数组的大小都是 n x 2 ，其中 bottomLeft[i] 和 topRight[i] 分别代表第 i 个矩形的 左下角 和 右上角 坐标。\n我们定义 向右 的方向为 x 轴正半轴（x 坐标增加），向左 的方向为 x 轴负半轴（x 坐标减少）。同样地，定义 向上 的方向为 y 轴正半轴（y 坐标增加），向下 的方向为 y 轴负半轴（y 坐标减少）。\n你可以选择一个区域，该区域由两个矩形的 交集 形成。你需要找出能够放入该区域 内 的 最大 正方形面积，并选择最优解。\n返回能够放入交集区域的正方形的 最大 可能面积，如果矩形之间不存在任何交集区域，则返回 0。\n示例 1：\n输入bottomLeft = [[1,1],[2,2],[3,1]], topRight = [[3,3],[4,4],[6,6]]\n输出：1示例 2：\n输入bottomLeft = [[1,1],[2,2],[1,2]], topRight = [[3,3],[4,4],[3,4]]\n输出：1\n\n提示：\nn == bottomLeft.length == topRight.length\n2 <= n <= 10^3\nbottomLeft[i].length == topRight[i].length == 2\n1 <= bottomLeft[i][0], bottomLeft[i][1] <= 10^7\n1 <= topRight[i][0], topRight[i][1] <= 10^7\nbottomLeft[i][0] < topRight[i][0]\nbottomLeft[i][1] < topRight[i][1]\n\"\"\"\n\n/**\n * @param {number[][]} bottomLeft\n * @param {number[][]} topRight\n * @return {number}\n */\nvar largestSquareArea = function(bottomLeft, topRight) {",
        "prompt_chat": "在二维平面上存在 n 个矩形。给你两个下标从 0 开始的二维整数数组 bottomLeft 和 topRight，两个数组的大小都是 n x 2 ，其中 bottomLeft[i] 和 topRight[i] 分别代表第 i 个矩形的 左下角 和 右上角 坐标。\n我们定义 向右 的方向为 x 轴正半轴（x 坐标增加），向左 的方向为 x 轴负半轴（x 坐标减少）。同样地，定义 向上 的方向为 y 轴正半轴（y 坐标增加），向下 的方向为 y 轴负半轴（y 坐标减少）。\n你可以选择一个区域，该区域由两个矩形的 交集 形成。你需要找出能够放入该区域 内 的 最大 正方形面积，并选择最优解。\n返回能够放入交集区域的正方形的 最大 可能面积，如果矩形之间不存在任何交集区域，则返回 0。\n示例 1：\n输入bottomLeft = [[1,1],[2,2],[3,1]], topRight = [[3,3],[4,4],[6,6]]\n输出：1示例 2：\n输入bottomLeft = [[1,1],[2,2],[1,2]], topRight = [[3,3],[4,4],[3,4]]\n输出：1\n\n提示：\nn == bottomLeft.length == topRight.length\n2 <= n <= 10^3\nbottomLeft[i].length == topRight[i].length == 2\n1 <= bottomLeft[i][0], bottomLeft[i][1] <= 10^7\n1 <= topRight[i][0], topRight[i][1] <= 10^7\nbottomLeft[i][0] < topRight[i][0]\nbottomLeft[i][1] < topRight[i][1]\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} bottomLeft\n * @param {number[][]} topRight\n * @return {number}\n */\nvar largestSquareArea = function(bottomLeft, topRight) {\n```",
        "solution": "var largestSquareArea = function(bottomLeft, topRight) {\n    let maxSquareArea = 0;\n    let n = bottomLeft.length;\n    for (let i = 0; i < n; i++) {\n        let bottomLeft1 = bottomLeft[i];\n        let topRight1 = topRight[i];\n        for (let j = i + 1; j < n; j++) {\n            let bottomLeft2 = bottomLeft[j];\n            let topRight2 = topRight[j];\n            let squareArea = overlapSquareArea(bottomLeft1, topRight1, bottomLeft2, topRight2);\n            maxSquareArea = Math.max(maxSquareArea, squareArea);\n        }\n    }\n    return maxSquareArea;\n}\n\nvar overlapSquareArea = function(bottomLeft1, topRight1, bottomLeft2, topRight2) {\n    let overlapWidth = Math.max(Math.min(topRight1[0], topRight2[0]) - Math.max(bottomLeft1[0], bottomLeft2[0]), 0);\n    let overlapHeight = Math.max(Math.min(topRight1[1], topRight2[1]) - Math.max(bottomLeft1[1], bottomLeft2[1]), 0);\n    let side = Math.min(overlapWidth, overlapHeight);\n    return side * side;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(largestSquareArea([[1,1],[2,2],[3,1]],[[3,3],[4,4],[6,6]]), 1, \"Test 1 Error!\");\nassert.deepEqual(largestSquareArea([[1,1],[2,2],[1,2]],[[3,3],[4,4],[3,4]]), 1, \"Test 2 Error!\");\nassert.deepEqual(largestSquareArea([[1,1],[3,3],[3,1]],[[2,2],[4,4],[4,2]]), 0, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} bottomLeft\n * @param {number[][]} topRight\n * @return {number}\n */\nvar largestSquareArea = function(bottomLeft, topRight) {",
        "function_name": "largestSquareArea",
        "difficulty_level": "Middle",
        "time": "20240225"
    },
    {
        "id": "3048",
        "prompt_base": "\"\"\"\n给你两个下标从 1 开始的整数数组 nums 和 changeIndices ，数组的长度分别为 n 和 m。一开始，nums 中所有下标都是未标记的，你的任务是标记 nums 中 所有 下标。\n从第 1 秒到第 m 秒（包括 第 m 秒），对于每一秒 s ，你可以执行以下操作 之一 ：\n选择范围 [1, n] 中的一个下标 i ，并且将 nums[i] 减少 1 。\n如果 nums[changeIndices[s]] 等于 0 ，标记 下标 changeIndices[s] 。\n什么也不做。\n请你返回范围 [1, m] 中的一个整数，表示最优操作下，标记 nums 中 所有 下标的 最早秒数 ，如果无法标记所有下标，返回 -1 。\n示例 1：\n输入nums = [2,2,0], changeIndices = [2,2,2,2,3,2,2,1]\n输出：8示例 2：\n输入nums = [1,3], changeIndices = [1,1,1,2,1,1,1]\n输出：6\n\n提示：\n1 <= n == nums.length <= 2000\n0 <= nums[i] <= 10^9\n1 <= m == changeIndices.length <= 2000\n1 <= changeIndices[i] <= n\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number[]} changeIndices\n * @return {number}\n */\nvar earliestSecondToMarkIndices = function(nums, changeIndices) {",
        "prompt_chat": "给你两个下标从 1 开始的整数数组 nums 和 changeIndices ，数组的长度分别为 n 和 m。一开始，nums 中所有下标都是未标记的，你的任务是标记 nums 中 所有 下标。\n从第 1 秒到第 m 秒（包括 第 m 秒），对于每一秒 s ，你可以执行以下操作 之一 ：\n选择范围 [1, n] 中的一个下标 i ，并且将 nums[i] 减少 1 。\n如果 nums[changeIndices[s]] 等于 0 ，标记 下标 changeIndices[s] 。\n什么也不做。\n请你返回范围 [1, m] 中的一个整数，表示最优操作下，标记 nums 中 所有 下标的 最早秒数 ，如果无法标记所有下标，返回 -1 。\n示例 1：\n输入nums = [2,2,0], changeIndices = [2,2,2,2,3,2,2,1]\n输出：8示例 2：\n输入nums = [1,3], changeIndices = [1,1,1,2,1,1,1]\n输出：6\n\n提示：\n1 <= n == nums.length <= 2000\n0 <= nums[i] <= 10^9\n1 <= m == changeIndices.length <= 2000\n1 <= changeIndices[i] <= n\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number[]} changeIndices\n * @return {number}\n */\nvar earliestSecondToMarkIndices = function(nums, changeIndices) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @param {number[]} changeIndices\n * @return {number}\n */\n\n //参考灵神直播内容 https://space.bilibili.com/206214\nvar earliestSecondToMarkIndices = function(nums, changeIndices) {\n\n  //把nums看作考试科目列表, i: 考试科目(examId) nums[i]: 参加此项考试需要的努力值\n  //把changeIndices看作考试时间表, i: 日期(day) , changeIndices[i]: 考试科目(examId)\n  const n = nums.length;\n  const m = changeIndices.length;\n\n  const check = (maxDay) => {\n    //lastExamDay: 每门考试最后一天考试的时间\n    const lastExamDay = new Array(n).fill(-1);\n    for (let day = 0; day < maxDay; day++) {\n      // -1:  从 1-based 转成 0-based\n      lastExamDay[changeIndices[day] - 1] = day;\n    }\n\n    //检查是否每一门考试都囊括在了 [0 - maxDay) 区间\n    for (let examId = 0; examId < n; examId++) {\n      const day = lastExamDay[examId];\n      //当前examId没有办法在[0 - maxDay)之间安排考试\n      if (day === -1) {\n        return false;\n      }\n    }\n\n\n    let cnt = 0; //cnt: 累计的努力值\n    for (let day = 0; day < maxDay; day++) {\n      const examId = lastExamDay.findIndex(date => date === day);\n      if (examId >= 0) {\n         //努力值不足，没法进行考试\n         if (cnt < nums[examId]) {\n           return false;\n         }\n        //努力值足够， 进行考试并消耗努力值\n        cnt -= nums[examId];\n      } else {\n        //没有考试， 累计努力值\n        cnt += 1;\n      }\n    }\n    \n    return true;\n  }\n\n  //二分查找答案\n  let left = 0, right = m + 1;\n  while (left <= right) {\n    //mid： 当前天数\n    const mid = Math.floor((right - left) / 2) + left;\n    \n    if (check(mid)) {\n      //当前天数足够应付考试, 继续压缩时间\n      right = mid - 1;\n    } else {\n      //当前天数不足够应付考试, 放宽时间\n      left = mid + 1;\n    }\n  }\n  return left > m ? -1 : left;\n\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(earliestSecondToMarkIndices([2,2,0],[2,2,2,2,3,2,2,1]), 8, \"Test 1 Error!\");\nassert.deepEqual(earliestSecondToMarkIndices([1,3],[1,1,1,2,1,1,1]), 6, \"Test 2 Error!\");\nassert.deepEqual(earliestSecondToMarkIndices([0,1],[2,2,2]), -1, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number[]} changeIndices\n * @return {number}\n */\nvar earliestSecondToMarkIndices = function(nums, changeIndices) {",
        "function_name": "earliestSecondToMarkIndices",
        "difficulty_level": "Middle",
        "time": "20240225"
    },
    {
        "id": "3049",
        "prompt_base": "\"\"\"\n给你两个下标从 1 开始的整数数组 nums 和 changeIndices ，数组的长度分别为 n 和 m 。一开始，nums 中所有下标都是未标记的，你的任务是标记 nums 中 所有 下标。\n从第 1 秒到第 m 秒（包括 第 m 秒），对于每一秒 s ，你可以执行以下操作 之一 ：\n选择范围 [1, n] 中的一个下标 i ，并且将 nums[i] 减少 1 。\n将 nums[changeIndices[s]] 设置成任意的 非负 整数。\n选择范围 [1, n] 中的一个下标 i ， 满足 nums[i] 等于 0, 并 标记 下标 i 。\n什么也不做。\n请你返回范围 [1, m] 中的一个整数，表示最优操作下，标记 nums 中 所有 下标的 最早秒数 ，如果无法标记所有下标，返回 -1 。\n示例 1：\n输入nums = [3,2,3], changeIndices = [1,3,2,2,2,2,3]\n输出：6示例 2：\n输入nums = [0,0,1,2], changeIndices = [1,2,1,2,1,2,1,2]\n输出：7\n\n提示：\n1 <= n == nums.length <= 5000\n0 <= nums[i] <= 10^9\n1 <= m == changeIndices.length <= 5000\n1 <= changeIndices[i] <= n\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number[]} changeIndices\n * @return {number}\n */\nvar earliestSecondToMarkIndices = function(nums, changeIndices) {",
        "prompt_chat": "给你两个下标从 1 开始的整数数组 nums 和 changeIndices ，数组的长度分别为 n 和 m 。一开始，nums 中所有下标都是未标记的，你的任务是标记 nums 中 所有 下标。\n从第 1 秒到第 m 秒（包括 第 m 秒），对于每一秒 s ，你可以执行以下操作 之一 ：\n选择范围 [1, n] 中的一个下标 i ，并且将 nums[i] 减少 1 。\n将 nums[changeIndices[s]] 设置成任意的 非负 整数。\n选择范围 [1, n] 中的一个下标 i ， 满足 nums[i] 等于 0, 并 标记 下标 i 。\n什么也不做。\n请你返回范围 [1, m] 中的一个整数，表示最优操作下，标记 nums 中 所有 下标的 最早秒数 ，如果无法标记所有下标，返回 -1 。\n示例 1：\n输入nums = [3,2,3], changeIndices = [1,3,2,2,2,2,3]\n输出：6示例 2：\n输入nums = [0,0,1,2], changeIndices = [1,2,1,2,1,2,1,2]\n输出：7\n\n提示：\n1 <= n == nums.length <= 5000\n0 <= nums[i] <= 10^9\n1 <= m == changeIndices.length <= 5000\n1 <= changeIndices[i] <= n\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number[]} changeIndices\n * @return {number}\n */\nvar earliestSecondToMarkIndices = function(nums, changeIndices) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(earliestSecondToMarkIndices([3,2,3],[1,3,2,2,2,2,3]), 6, \"Test 1 Error!\");\nassert.deepEqual(earliestSecondToMarkIndices([0,0,1,2],[1,2,1,2,1,2,1,2]), 7, \"Test 2 Error!\");\nassert.deepEqual(earliestSecondToMarkIndices([1,2,3],[1,2,3]), -1, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number[]} changeIndices\n * @return {number}\n */\nvar earliestSecondToMarkIndices = function(nums, changeIndices) {",
        "function_name": "earliestSecondToMarkIndices",
        "difficulty_level": "Hard",
        "time": "20240225"
    },
    {
        "id": "3065",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的整数数组 nums 和一个整数 k。\n一次操作中，你可以删除 nums 中的最小元素。\n你需要使数组中的所有元素都大于或等于 k ，请你返回需要的 最少 操作次数。\n示例 1：\n输入nums = [2,11,10,1,3], k = 10\n输出：3示例 2：\n输入nums = [1,1,2,4,9], k = 1\n输出：0\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 10^9\n1 <= k <= 10^9\n输入保证至少有一个满足 nums[i] >= k 的下标 i 存在。\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(nums, k) {",
        "prompt_chat": "给你一个下标从 0 开始的整数数组 nums 和一个整数 k。\n一次操作中，你可以删除 nums 中的最小元素。\n你需要使数组中的所有元素都大于或等于 k ，请你返回需要的 最少 操作次数。\n示例 1：\n输入nums = [2,11,10,1,3], k = 10\n输出：3示例 2：\n输入nums = [1,1,2,4,9], k = 1\n输出：0\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 10^9\n1 <= k <= 10^9\n输入保证至少有一个满足 nums[i] >= k 的下标 i 存在。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(nums, k) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(nums, k) {\n    return nums.filter(v => v < k).length\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minOperations([2,11,10,1,3],10), 3, \"Test 1 Error!\");\nassert.deepEqual(minOperations([1,1,2,4,9],1), 0, \"Test 2 Error!\");\nassert.deepEqual(minOperations([1,1,2,4,9],9), 4, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(nums, k) {",
        "function_name": "minOperations",
        "difficulty_level": "Easy",
        "time": "20240302"
    },
    {
        "id": "3066",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的整数数组 nums 和一个整数 k。\n一次操作中，你将执行：\n选择 nums 中最小的两个整数 x 和 y。\n将 x 和 y 从 nums 中删除。\n将 min(x, y) * 2 + max(x, y) 添加到数组中的任意位置。\n注意，只有当 nums 至少包含两个元素时，你才可以执行以上操作。\n你需要使数组中的所有元素都大于或等于 k ，请你返回需要的 最少 操作次数。\n示例 1：\n输入nums = [2,11,10,1,3], k = 10\n输出：2示例 2：\n输入nums = [1,1,2,4,9], k = 20\n输出：4\n\n提示：\n2 <= nums.length <= 2 * 10^5\n1 <= nums[i] <= 10^9\n1 <= k <= 10^9\n输入保证答案一定存在，也就是说一定存在一个操作序列使数组中所有元素都大于等于 k 。\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(nums, k) {",
        "prompt_chat": "给你一个下标从 0 开始的整数数组 nums 和一个整数 k。\n一次操作中，你将执行：\n选择 nums 中最小的两个整数 x 和 y。\n将 x 和 y 从 nums 中删除。\n将 min(x, y) * 2 + max(x, y) 添加到数组中的任意位置。\n注意，只有当 nums 至少包含两个元素时，你才可以执行以上操作。\n你需要使数组中的所有元素都大于或等于 k ，请你返回需要的 最少 操作次数。\n示例 1：\n输入nums = [2,11,10,1,3], k = 10\n输出：2示例 2：\n输入nums = [1,1,2,4,9], k = 20\n输出：4\n\n提示：\n2 <= nums.length <= 2 * 10^5\n1 <= nums[i] <= 10^9\n1 <= k <= 10^9\n输入保证答案一定存在，也就是说一定存在一个操作序列使数组中所有元素都大于等于 k 。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(nums, k) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(nums, k) {\n    let q = new MinPriorityQueue()\n    for(let x of nums){\n        q.enqueue(x)\n    }\n    let ans = 0\n    while(q.front().element < k){\n       let x = q.dequeue(), y = q.dequeue()\n       ans++\n       q.enqueue(Math.min(x,y)*2 + Math.max(x,y))\n    }\n    return ans \n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minOperations([2,11,10,1,3],10), 2, \"Test 1 Error!\");\nassert.deepEqual(minOperations([1,1,2,4,9],20), 4, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(nums, k) {",
        "function_name": "minOperations",
        "difficulty_level": "Middle",
        "time": "20240302"
    },
    {
        "id": "3067",
        "prompt_base": "\"\"\"\n给你一棵无根带权树，树中总共有 n 个节点，分别表示 n 个服务器，服务器从 0 到 n - 1 编号。同时给你一个数组 edges ，其中 edges[i] = [a_i, b_i, weight_i] 表示节点 a_i 和 b_i 之间有一条双向边，边的权值为 weight_i 。再给你一个整数 signalSpeed。\n如果两台服务器 a 和 b 是通过服务器 c 可连接的，则：\na < b ，a != c 且 b != c 。\n从 c 到 a 的距离是可以被 signalSpeed 整除的。\n从 c 到 b 的距离是可以被 signalSpeed 整除的。\n从 c 到 b 的路径与从 c 到 a 的路径没有任何公共边。\n请你返回一个长度为 n 的整数数组 count ，其中 count[i] 表示通过服务器 i 可连接 的服务器对的 数目 。\n示例 1：\n输入edges = [[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], signalSpeed = 1\n输出：[0,4,6,6,4,0]示例 2：\n输入edges = [[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], signalSpeed = 3\n输出：[2,0,0,0,0,0,2]\n\n提示：\n2 <= n <= 1000\nedges.length == n - 1\nedges[i].length == 3\n0 <= a_i, b_i < n\nedges[i] = [a_i, b_i, weight_i]\n1 <= weight_i <= 10^6\n1 <= signalSpeed <= 10^6\n输入保证 edges 构成一棵合法的树。\n\"\"\"\n\n/**\n * @param {number[][]} edges\n * @param {number} signalSpeed\n * @return {number[]}\n */\nvar countPairsOfConnectableServers = function(edges, signalSpeed) {",
        "prompt_chat": "给你一棵无根带权树，树中总共有 n 个节点，分别表示 n 个服务器，服务器从 0 到 n - 1 编号。同时给你一个数组 edges ，其中 edges[i] = [a_i, b_i, weight_i] 表示节点 a_i 和 b_i 之间有一条双向边，边的权值为 weight_i 。再给你一个整数 signalSpeed。\n如果两台服务器 a 和 b 是通过服务器 c 可连接的，则：\na < b ，a != c 且 b != c 。\n从 c 到 a 的距离是可以被 signalSpeed 整除的。\n从 c 到 b 的距离是可以被 signalSpeed 整除的。\n从 c 到 b 的路径与从 c 到 a 的路径没有任何公共边。\n请你返回一个长度为 n 的整数数组 count ，其中 count[i] 表示通过服务器 i 可连接 的服务器对的 数目 。\n示例 1：\n输入edges = [[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], signalSpeed = 1\n输出：[0,4,6,6,4,0]示例 2：\n输入edges = [[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], signalSpeed = 3\n输出：[2,0,0,0,0,0,2]\n\n提示：\n2 <= n <= 1000\nedges.length == n - 1\nedges[i].length == 3\n0 <= a_i, b_i < n\nedges[i] = [a_i, b_i, weight_i]\n1 <= weight_i <= 10^6\n1 <= signalSpeed <= 10^6\n输入保证 edges 构成一棵合法的树。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} edges\n * @param {number} signalSpeed\n * @return {number[]}\n */\nvar countPairsOfConnectableServers = function(edges, signalSpeed) {\n```",
        "solution": "var countPairsOfConnectableServers = function(edges, signalSpeed) {\n    const n = edges.length + 1;\n    const graph = Array.from({ length: n }, () => []);\n    for (const [u, v, w] of edges) {\n        graph[u].push([v, w]);\n        graph[v].push([u, w]);\n    }\n\n    const dfs = (p, root, curr) => {\n        let res = 0;\n        if (curr === 0) {\n            res++;\n        }\n        for (const [v, cost] of graph[p]) {\n            if (v !== root) {\n                res += dfs(v, p, (curr + cost) % signalSpeed);\n            }\n        }\n        return res;\n    };\n\n    const res = Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        let pre = 0;\n        for (const [v, cost] of graph[i]) {\n            const cnt = dfs(v, i, cost % signalSpeed);\n            res[i] += pre * cnt;\n            pre += cnt;\n        }\n    }\n    return res;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(countPairsOfConnectableServers([[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]],1), [0,4,6,6,4,0], \"Test 1 Error!\");\nassert.deepEqual(countPairsOfConnectableServers([[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]],3), [2,0,0,0,0,0,2], \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} edges\n * @param {number} signalSpeed\n * @return {number[]}\n */\nvar countPairsOfConnectableServers = function(edges, signalSpeed) {",
        "function_name": "countPairsOfConnectableServers",
        "difficulty_level": "Middle",
        "time": "20240302"
    },
    {
        "id": "3068",
        "prompt_base": "\"\"\"\n给你一棵 n 个节点的 无向 树，节点从 0 到 n - 1 编号。树以长度为 n - 1 下标从 0 开始的二维整数数组 edges 的形式给你，其中 edges[i] = [u_i, v_i] 表示树中节点 u_i 和 v_i 之间有一条边。同时给你一个 正 整数 k 和一个长度为 n 下标从 0 开始的 非负 整数数组 nums ，其中 nums[i] 表示节点 i 的 价值 。\nAlice 想 最大化 树中所有节点价值之和。为了实现这一目标，Alice 可以执行以下操作 任意 次（包括 0 次）：\n选择连接节点 u 和 v 的边 [u, v] ，并将它们的值更新为：\nnums[u] = nums[u] XOR k\nnums[v] = nums[v] XOR k\n请你返回 Alice 通过执行以上操作 任意次 后，可以得到所有节点 价值之和 的 最大值 。\n示例 1：\n输入nums = [1,2,1], k = 3, edges = [[0,1],[0,2]]\n输出：6示例 2：\n输入nums = [2,3], k = 7, edges = [[0,1]]\n输出：9\n\n提示：\n2 <= n == nums.length <= 2 * 10^4\n1 <= k <= 10^9\n0 <= nums[i] <= 10^9\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\n输入保证 edges 构成一棵合法的树。\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number[][]} edges\n * @return {number}\n */\nvar maximumValueSum = function(nums, k, edges) {",
        "prompt_chat": "给你一棵 n 个节点的 无向 树，节点从 0 到 n - 1 编号。树以长度为 n - 1 下标从 0 开始的二维整数数组 edges 的形式给你，其中 edges[i] = [u_i, v_i] 表示树中节点 u_i 和 v_i 之间有一条边。同时给你一个 正 整数 k 和一个长度为 n 下标从 0 开始的 非负 整数数组 nums ，其中 nums[i] 表示节点 i 的 价值 。\nAlice 想 最大化 树中所有节点价值之和。为了实现这一目标，Alice 可以执行以下操作 任意 次（包括 0 次）：\n选择连接节点 u 和 v 的边 [u, v] ，并将它们的值更新为：\nnums[u] = nums[u] XOR k\nnums[v] = nums[v] XOR k\n请你返回 Alice 通过执行以上操作 任意次 后，可以得到所有节点 价值之和 的 最大值 。\n示例 1：\n输入nums = [1,2,1], k = 3, edges = [[0,1],[0,2]]\n输出：6示例 2：\n输入nums = [2,3], k = 7, edges = [[0,1]]\n输出：9\n\n提示：\n2 <= n == nums.length <= 2 * 10^4\n1 <= k <= 10^9\n0 <= nums[i] <= 10^9\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\n输入保证 edges 构成一棵合法的树。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number[][]} edges\n * @return {number}\n */\nvar maximumValueSum = function(nums, k, edges) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maximumValueSum([1,2,1],3,[[0,1],[0,2]]), 6, \"Test 1 Error!\");\nassert.deepEqual(maximumValueSum([2,3],7,[[0,1]]), 9, \"Test 2 Error!\");\nassert.deepEqual(maximumValueSum([7,7,7,7,7,7],3,[[0,1],[0,2],[0,3],[0,4],[0,5]]), 42, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number[][]} edges\n * @return {number}\n */\nvar maximumValueSum = function(nums, k, edges) {",
        "function_name": "maximumValueSum",
        "difficulty_level": "Hard",
        "time": "20240302"
    },
    {
        "id": "3069",
        "prompt_base": "\"\"\"\n给你一个下标从 1 开始、包含 不同 整数的数组 nums ，数组长度为 n 。\n你需要通过 n 次操作，将 nums 中的所有元素分配到两个数组 arr1 和 arr2 中。在第一次操作中，将 nums[1] 追加到 arr1 。在第二次操作中，将 nums[2] 追加到 arr2 。之后，在第 i 次操作中：\n如果 arr1 的最后一个元素 大于 arr2 的最后一个元素，就将 nums[i] 追加到 arr1 。否则，将 nums[i] 追加到 arr2 。\n通过连接数组 arr1 和 arr2 形成数组 result 。例如，如果 arr1 == [1,2,3] 且 arr2 == [4,5,6] ，那么 result = [1,2,3,4,5,6] 。\n返回数组 result 。\n示例 1：\n输入nums = [2,1,3]\n输出：[2,3,1]示例 2：\n输入nums = [5,4,3,8]\n输出：[5,3,4,8]\n\n提示：\n3 <= n <= 50\n1 <= nums[i] <= 100\nnums中的所有元素都互不相同。\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar resultArray = function(nums) {",
        "prompt_chat": "给你一个下标从 1 开始、包含 不同 整数的数组 nums ，数组长度为 n 。\n你需要通过 n 次操作，将 nums 中的所有元素分配到两个数组 arr1 和 arr2 中。在第一次操作中，将 nums[1] 追加到 arr1 。在第二次操作中，将 nums[2] 追加到 arr2 。之后，在第 i 次操作中：\n如果 arr1 的最后一个元素 大于 arr2 的最后一个元素，就将 nums[i] 追加到 arr1 。否则，将 nums[i] 追加到 arr2 。\n通过连接数组 arr1 和 arr2 形成数组 result 。例如，如果 arr1 == [1,2,3] 且 arr2 == [4,5,6] ，那么 result = [1,2,3,4,5,6] 。\n返回数组 result 。\n示例 1：\n输入nums = [2,1,3]\n输出：[2,3,1]示例 2：\n输入nums = [5,4,3,8]\n输出：[5,3,4,8]\n\n提示：\n3 <= n <= 50\n1 <= nums[i] <= 100\nnums中的所有元素都互不相同。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar resultArray = function(nums) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar resultArray = function(nums) {\n    let a = [nums[0]], b = [nums[1]]\n    for(let i = 2; i < nums.length; i++){\n        if(a.at(-1) > b.at(-1)) a.push(nums[i])\n        else b.push(nums[i])\n    }\n    return a.concat(b)\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(resultArray([2,1,3]), [2,3,1], \"Test 1 Error!\");\nassert.deepEqual(resultArray([5,4,3,8]), [5,3,4,8], \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar resultArray = function(nums) {",
        "function_name": "resultArray",
        "difficulty_level": "Easy",
        "time": "20240303"
    },
    {
        "id": "3070",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的整数矩阵 grid 和一个整数 k。返回包含 grid 左上角元素、元素和小于或等于 k 的 \n子矩阵\n的数目。\n示例 1：\n输入grid = [[7,6,3],[6,6,1]], k = 18\n输出：4示例 2：\n输入grid = [[7,2,9],[1,5,0],[2,6,6]], k = 20\n输出：6\n\n提示：\nm == grid.length\nn == grid[i].length\n1 <= n, m <= 1000\n0 <= grid[i][j] <= 1000\n1 <= k <= 10^9\n\"\"\"\n\n/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number}\n */\nvar countSubmatrices = function(grid, k) {",
        "prompt_chat": "给你一个下标从 0 开始的整数矩阵 grid 和一个整数 k。返回包含 grid 左上角元素、元素和小于或等于 k 的 \n子矩阵\n的数目。\n示例 1：\n输入grid = [[7,6,3],[6,6,1]], k = 18\n输出：4示例 2：\n输入grid = [[7,2,9],[1,5,0],[2,6,6]], k = 20\n输出：6\n\n提示：\nm == grid.length\nn == grid[i].length\n1 <= n, m <= 1000\n0 <= grid[i][j] <= 1000\n1 <= k <= 10^9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number}\n */\nvar countSubmatrices = function(grid, k) {\n```",
        "solution": "/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number}\n */\nvar countSubmatrices = function(grid, k) {\n  let num = 0;\n  let temp = [...grid[0]];\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      if (temp.slice(0, j + 1).reduce((a, b) => a + b, 0) <= k) {\n        num++;\n      }\n      if (j === grid[0].length - 1 && i < grid.length - 1) {\n        temp = temp.map((item, index) => item + grid[i + 1][index]);\n      }\n    }\n  }\n  return num;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(countSubmatrices([[7,6,3],[6,6,1]],18), 4, \"Test 1 Error!\");\nassert.deepEqual(countSubmatrices([[7,2,9],[1,5,0],[2,6,6]],20), 6, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number}\n */\nvar countSubmatrices = function(grid, k) {",
        "function_name": "countSubmatrices",
        "difficulty_level": "Middle",
        "time": "20240303"
    },
    {
        "id": "3071",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始、大小为 n x n 的矩阵 grid ，其中 n 为奇数，且 grid[r][c] 的值为 0 、1 或 2 。如果一个单元格属于以下三条线中的任一一条，我们就认为它是字母 Y 的一部分：\n从左上角单元格开始到矩阵中心单元格结束的对角线。\n从右上角单元格开始到矩阵中心单元格结束的对角线。\n从中心单元格开始到矩阵底部边界结束的垂直线。\n当且仅当满足以下全部条件时，可以判定矩阵上写有字母 Y ：\n属于 Y 的所有单元格的值相等。\n不属于 Y 的所有单元格的值相等。\n属于 Y 的单元格的值与不属于Y的单元格的值不同。\n每次操作你可以将任意单元格的值改变为 0 、1 或 2 。返回在矩阵上写出字母 Y 所需的 最少 操作次数。\n示例 1：\n输入grid = [[1,2,2],[1,1,0],[0,1,0]]\n输出：3示例 2：\n输入grid = [[0,1,0,1,0],[2,1,0,1,2],[2,2,2,0,1],[2,2,2,2,2],[2,1,2,2,2]]\n输出：12\n\n提示：\n3 <= n <= 49\nn == grid.length == grid[i].length\n0 <= grid[i][j] <= 2\nn 为奇数。\n\"\"\"\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumOperationsToWriteY = function(grid) {",
        "prompt_chat": "给你一个下标从 0 开始、大小为 n x n 的矩阵 grid ，其中 n 为奇数，且 grid[r][c] 的值为 0 、1 或 2 。如果一个单元格属于以下三条线中的任一一条，我们就认为它是字母 Y 的一部分：\n从左上角单元格开始到矩阵中心单元格结束的对角线。\n从右上角单元格开始到矩阵中心单元格结束的对角线。\n从中心单元格开始到矩阵底部边界结束的垂直线。\n当且仅当满足以下全部条件时，可以判定矩阵上写有字母 Y ：\n属于 Y 的所有单元格的值相等。\n不属于 Y 的所有单元格的值相等。\n属于 Y 的单元格的值与不属于Y的单元格的值不同。\n每次操作你可以将任意单元格的值改变为 0 、1 或 2 。返回在矩阵上写出字母 Y 所需的 最少 操作次数。\n示例 1：\n输入grid = [[1,2,2],[1,1,0],[0,1,0]]\n输出：3示例 2：\n输入grid = [[0,1,0,1,0],[2,1,0,1,2],[2,2,2,0,1],[2,2,2,2,2],[2,1,2,2,2]]\n输出：12\n\n提示：\n3 <= n <= 49\nn == grid.length == grid[i].length\n0 <= grid[i][j] <= 2\nn 为奇数。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumOperationsToWriteY = function(grid) {\n```",
        "solution": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumOperationsToWriteY = function (grid) {\n    let n = grid.length;\n    let m = Math.floor(n / 2);\n    let temp = [];\n    let ans = [];\n    for (let i = 0; i < n; i++) {\n        if (i < m) {\n            temp.push(grid[i][i]);\n            temp.push(grid[i][n - i - 1]);\n        } else temp.push(grid[i][m]);\n        for (let j = 0; j < n; j++) {\n            if (i < m) {\n                if (j !== i && j !== n - i - 1) {\n                    ans.push(grid[i][j]);\n                }\n            } else {\n                if (j !== m) ans.push(grid[i][j]);\n            }\n        }\n    }\n    let num = findMostFrequent(temp);\n    let count = findMostFrequent(ans);\n    if (num[0].number === count[0].number) {\n        if (\n            num[0].number === num[1].number &&\n            count[0].number === count[1].number\n        ) {\n            return num[0].count;\n        }\n        if (count[0].number === count[1].number) {\n            return ans.length - count[0].count + temp.length - num[1].count;\n        }\n        if (num[0].number === num[1].number) {\n            return ans.length - count[1].count + temp.length - num[0].count;\n        }\n        if (num[0].count - num[1].count > count[0].count - count[1].count) {\n            return ans.length - count[1].count + temp.length - num[0].count;\n        } else {\n            return ans.length - count[0].count + temp.length - num[1].count;\n        }\n    } else {\n        return ans.length - count[0].count + temp.length - num[0].count;\n    }\n};\n\nfunction findMostFrequent(arr) {\n    let frequency = {};\n    // 计算每个数字的出现次数\n    arr.forEach((num) => {\n        frequency[num] = (frequency[num] || 0) + 1;\n    });\n    let a = Object.keys(frequency).sort((a, b) => frequency[b] - frequency[a]);\n    if (a.length >= 2) {\n        return [\n            { number: a[0], count: frequency[a[0]] },\n            { number: a[1], count: frequency[a[1]] },\n        ];\n    } else {\n        return [\n            { number: a[0], count: frequency[a[0]] },\n            { number: a[0], count: frequency[a[0]] },\n        ];\n    }\n}",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumOperationsToWriteY([[1,2,2],[1,1,0],[0,1,0]]), 3, \"Test 1 Error!\");\nassert.deepEqual(minimumOperationsToWriteY([[0,1,0,1,0],[2,1,0,1,2],[2,2,2,0,1],[2,2,2,2,2],[2,1,2,2,2]]), 12, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumOperationsToWriteY = function(grid) {",
        "function_name": "minimumOperationsToWriteY",
        "difficulty_level": "Middle",
        "time": "20240303"
    },
    {
        "id": "3072",
        "prompt_base": "\"\"\"\n给你一个下标从 1 开始、长度为 n 的整数数组 nums 。\n现定义函数 greaterCount ，使得 greaterCount(arr, val) 返回数组 arr 中 严格大于 val 的元素数量。\n你需要使用 n 次操作，将 nums 的所有元素分配到两个数组 arr1 和 arr2 中。在第一次操作中，将 nums[1] 追加到 arr1 。在第二次操作中，将 nums[2] 追加到 arr2 。之后，在第 i 次操作中：\n如果 greaterCount(arr1, nums[i]) > greaterCount(arr2, nums[i]) ，将 nums[i] 追加到 arr1 。\n如果 greaterCount(arr1, nums[i]) < greaterCount(arr2, nums[i]) ，将 nums[i] 追加到 arr2 。\n如果 greaterCount(arr1, nums[i]) == greaterCount(arr2, nums[i]) ，将 nums[i] 追加到元素数量较少的数组中。\n如果仍然相等，那么将 nums[i] 追加到 arr1 。\n连接数组 arr1 和 arr2 形成数组 result 。例如，如果 arr1 == [1,2,3] 且 arr2 == [4,5,6] ，那么 result = [1,2,3,4,5,6] 。\n返回整数数组 result 。\n示例 1：\n输入nums = [2,1,3,3]\n输出：[2,3,1,3]示例 2：\n输入nums = [5,14,3,1,2]\n输出：[5,3,1,2,14]\n\n提示：\n3 <= n <= 10^5\n1 <= nums[i] <= 10^9\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar resultArray = function(nums) {",
        "prompt_chat": "给你一个下标从 1 开始、长度为 n 的整数数组 nums 。\n现定义函数 greaterCount ，使得 greaterCount(arr, val) 返回数组 arr 中 严格大于 val 的元素数量。\n你需要使用 n 次操作，将 nums 的所有元素分配到两个数组 arr1 和 arr2 中。在第一次操作中，将 nums[1] 追加到 arr1 。在第二次操作中，将 nums[2] 追加到 arr2 。之后，在第 i 次操作中：\n如果 greaterCount(arr1, nums[i]) > greaterCount(arr2, nums[i]) ，将 nums[i] 追加到 arr1 。\n如果 greaterCount(arr1, nums[i]) < greaterCount(arr2, nums[i]) ，将 nums[i] 追加到 arr2 。\n如果 greaterCount(arr1, nums[i]) == greaterCount(arr2, nums[i]) ，将 nums[i] 追加到元素数量较少的数组中。\n如果仍然相等，那么将 nums[i] 追加到 arr1 。\n连接数组 arr1 和 arr2 形成数组 result 。例如，如果 arr1 == [1,2,3] 且 arr2 == [4,5,6] ，那么 result = [1,2,3,4,5,6] 。\n返回整数数组 result 。\n示例 1：\n输入nums = [2,1,3,3]\n输出：[2,3,1,3]示例 2：\n输入nums = [5,14,3,1,2]\n输出：[5,3,1,2,14]\n\n提示：\n3 <= n <= 10^5\n1 <= nums[i] <= 10^9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar resultArray = function(nums) {\n```",
        "solution": "class BinaryIndexedTree {\n    constructor(n) {\n        this.tree = new Array(n + 1).fill(0);\n    }\n\n    add(i) {\n        while (i < this.tree.length) {\n            this.tree[i]++;\n            i += i & -i;\n        }\n    }\n\n    get(i) {\n        let sum = 0;\n        while (i > 0) {\n            sum += this.tree[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n}\n\nvar resultArray = function(nums) {\n    const n = nums.length;\n    const sortedNums = [...nums].sort((a, b) => a - b);\n    const index = {};\n    for (let i = 0; i < n; i++) {\n        index[sortedNums[i]] = i + 1;\n    }\n\n    const arr1 = [nums[0]];\n    const arr2 = [nums[1]];\n    const tree1 = new BinaryIndexedTree(n);\n    const tree2 = new BinaryIndexedTree(n);\n    tree1.add(index[nums[0]]);\n    tree2.add(index[nums[1]]);\n\n    for (let i = 2; i < n; i++) {\n        const count1 = arr1.length - tree1.get(index[nums[i]]);\n        const count2 = arr2.length - tree2.get(index[nums[i]]);\n        if (count1 > count2 || (count1 === count2 && arr1.length <= arr2.length)) {\n            arr1.push(nums[i]);\n            tree1.add(index[nums[i]]);\n        } else {\n            arr2.push(nums[i]);\n            tree2.add(index[nums[i]]);\n        }\n    }\n\n    return arr1.concat(arr2);\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(resultArray([2,1,3,3]), [2,3,1,3], \"Test 1 Error!\");\nassert.deepEqual(resultArray([5,14,3,1,2]), [5,3,1,2,14], \"Test 2 Error!\");\nassert.deepEqual(resultArray([3,3,3,3]), [3,3,3,3], \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar resultArray = function(nums) {",
        "function_name": "resultArray",
        "difficulty_level": "Hard",
        "time": "20240303"
    },
    {
        "id": "3074",
        "prompt_base": "\"\"\"\n给你一个长度为 n 的数组 apple 和另一个长度为 m 的数组 capacity 。\n一共有 n 个包裹，其中第 i 个包裹中装着 apple[i] 个苹果。同时，还有 m 个箱子，第 i 个箱子的容量为 capacity[i] 个苹果。\n请你选择一些箱子来将这 n 个包裹中的苹果重新分装到箱子中，返回你需要选择的箱子的 最小 数量。\n注意，同一个包裹中的苹果可以分装到不同的箱子中。\n示例 1：\n输入apple = [1,3,2], capacity = [4,3,1,5,2]\n输出：2示例 2：\n输入apple = [5,5,5], capacity = [2,4,2,7]\n输出：4\n\n提示：\n1 <= n == apple.length <= 50\n1 <= m == capacity.length <= 50\n1 <= apple[i], capacity[i] <= 50\n输入数据保证可以将包裹中的苹果重新分装到箱子中。\n\"\"\"\n\n/**\n * @param {number[]} apple\n * @param {number[]} capacity\n * @return {number}\n */\nvar minimumBoxes = function(apple, capacity) {",
        "prompt_chat": "给你一个长度为 n 的数组 apple 和另一个长度为 m 的数组 capacity 。\n一共有 n 个包裹，其中第 i 个包裹中装着 apple[i] 个苹果。同时，还有 m 个箱子，第 i 个箱子的容量为 capacity[i] 个苹果。\n请你选择一些箱子来将这 n 个包裹中的苹果重新分装到箱子中，返回你需要选择的箱子的 最小 数量。\n注意，同一个包裹中的苹果可以分装到不同的箱子中。\n示例 1：\n输入apple = [1,3,2], capacity = [4,3,1,5,2]\n输出：2示例 2：\n输入apple = [5,5,5], capacity = [2,4,2,7]\n输出：4\n\n提示：\n1 <= n == apple.length <= 50\n1 <= m == capacity.length <= 50\n1 <= apple[i], capacity[i] <= 50\n输入数据保证可以将包裹中的苹果重新分装到箱子中。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} apple\n * @param {number[]} capacity\n * @return {number}\n */\nvar minimumBoxes = function(apple, capacity) {\n```",
        "solution": "/**\n * @param {number[]} apple\n * @param {number[]} capacity\n * @return {number}\n */\nvar minimumBoxes = function(apple, capacity) {\n    let sum = apple.reduce((a,b) => a + b, 0), c = 0, i = 0 \n    capacity.sort((a,b) => b - a)\n    while(sum > 0){\n        sum -= capacity[i++]\n        c++\n    }\n    return c \n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumBoxes([1,3,2],[4,3,1,5,2]), 2, \"Test 1 Error!\");\nassert.deepEqual(minimumBoxes([5,5,5],[2,4,2,7]), 4, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} apple\n * @param {number[]} capacity\n * @return {number}\n */\nvar minimumBoxes = function(apple, capacity) {",
        "function_name": "minimumBoxes",
        "difficulty_level": "Easy",
        "time": "20240310"
    },
    {
        "id": "3075",
        "prompt_base": "\"\"\"\n给你一个长度为 n 的数组 happiness ，以及一个 正整数 k 。\nn 个孩子站成一队，其中第 i 个孩子的 幸福值 是 happiness[i] 。你计划组织 k 轮筛选从这 n 个孩子中选出 k 个孩子。\n在每一轮选择一个孩子时，所有 尚未 被选中的孩子的 幸福值 将减少 1 。注意，幸福值 不能 变成负数，且只有在它是正数的情况下才会减少。\n选择 k 个孩子，并使你选中的孩子幸福值之和最大，返回你能够得到的 最大值 。\n示例 1：\n输入happiness = [1,2,3], k = 2\n输出：4示例 2：\n输入happiness = [1,1,1,1], k = 2\n输出：1\n\n提示：\n1 <= n == happiness.length <= 2 * 10^5\n1 <= happiness[i] <= 10^8\n1 <= k <= n\n\"\"\"\n\n/**\n * @param {number[]} happiness\n * @param {number} k\n * @return {number}\n */\nvar maximumHappinessSum = function(happiness, k) {",
        "prompt_chat": "给你一个长度为 n 的数组 happiness ，以及一个 正整数 k 。\nn 个孩子站成一队，其中第 i 个孩子的 幸福值 是 happiness[i] 。你计划组织 k 轮筛选从这 n 个孩子中选出 k 个孩子。\n在每一轮选择一个孩子时，所有 尚未 被选中的孩子的 幸福值 将减少 1 。注意，幸福值 不能 变成负数，且只有在它是正数的情况下才会减少。\n选择 k 个孩子，并使你选中的孩子幸福值之和最大，返回你能够得到的 最大值 。\n示例 1：\n输入happiness = [1,2,3], k = 2\n输出：4示例 2：\n输入happiness = [1,1,1,1], k = 2\n输出：1\n\n提示：\n1 <= n == happiness.length <= 2 * 10^5\n1 <= happiness[i] <= 10^8\n1 <= k <= n\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} happiness\n * @param {number} k\n * @return {number}\n */\nvar maximumHappinessSum = function(happiness, k) {\n```",
        "solution": "/**\n * @param {number[]} happiness\n * @param {number} k\n * @return {number}\n */\nvar maximumHappinessSum = function (happiness, k) {\n    happiness.sort((a, b) => b - a);\n    let num = 0;\n    for (let i = 0; i < k; i++) {\n        let t = happiness[i] - i;\n        if (t < 0) {\n            return num;\n        }\n        num += t;\n    }\n    return num;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maximumHappinessSum([1,2,3],2), 4, \"Test 1 Error!\");\nassert.deepEqual(maximumHappinessSum([1,1,1,1],2), 1, \"Test 2 Error!\");\nassert.deepEqual(maximumHappinessSum([2,3,4,5],1), 5, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} happiness\n * @param {number} k\n * @return {number}\n */\nvar maximumHappinessSum = function(happiness, k) {",
        "function_name": "maximumHappinessSum",
        "difficulty_level": "Middle",
        "time": "20240310"
    },
    {
        "id": "3076",
        "prompt_base": "\"\"\"\n给你一个数组 arr ，数组中有 n 个 非空 字符串。\n请你求出一个长度为 n 的字符串 answer ，满足：\nanswer[i] 是 arr[i] 最短 的子字符串，且它不是 arr 中其他任何字符串的子字符串。如果有多个这样的子字符串存在，answer[i] 应该是它们中字典序最小的一个。如果不存在这样的子字符串，answer[i] 为空字符串。\n请你返回数组 answer 。\n示例 1：\n输入arr = [\"cab\",\"ad\",\"bad\",\"c\"]\n输出：[\"ab\",\"\",\"ba\",\"\"]示例 2：\n输入arr = [\"abc\",\"bcd\",\"abcd\"]\n输出：[\"\",\"\",\"abcd\"]\n\n提示：\nn == arr.length\n2 <= n <= 100\n1 <= arr[i].length <= 20\narr[i] 只包含小写英文字母。\n\"\"\"\n\n/**\n * @param {string[]} arr\n * @return {string[]}\n */\nvar shortestSubstrings = function(arr) {",
        "prompt_chat": "给你一个数组 arr ，数组中有 n 个 非空 字符串。\n请你求出一个长度为 n 的字符串 answer ，满足：\nanswer[i] 是 arr[i] 最短 的子字符串，且它不是 arr 中其他任何字符串的子字符串。如果有多个这样的子字符串存在，answer[i] 应该是它们中字典序最小的一个。如果不存在这样的子字符串，answer[i] 为空字符串。\n请你返回数组 answer 。\n示例 1：\n输入arr = [\"cab\",\"ad\",\"bad\",\"c\"]\n输出：[\"ab\",\"\",\"ba\",\"\"]示例 2：\n输入arr = [\"abc\",\"bcd\",\"abcd\"]\n输出：[\"\",\"\",\"abcd\"]\n\n提示：\nn == arr.length\n2 <= n <= 100\n1 <= arr[i].length <= 20\narr[i] 只包含小写英文字母。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string[]} arr\n * @return {string[]}\n */\nvar shortestSubstrings = function(arr) {\n```",
        "solution": "/**\n * @param {string[]} arr\n * @return {string[]}\n */\nvar shortestSubstrings = function(arr) {\n  function isUniqueSubstring(index, substring, strings) {\n    for (let i = 0; i < strings.length; i++) {\n      if (i !== index && strings[i].includes(substring)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  const answer = [];\n  for (const [t, originalString] of arr.entries()) {\n    let shortest = \"\";\n    for (let i = 0; i < originalString.length; i++) {\n      for (let j = i + 1; j <= originalString.length; j++) {\n        const substring = originalString.substring(i, j);\n        if (\n          isUniqueSubstring(t, substring, arr) &&\n          (shortest === \"\" || substring.length < shortest.length)\n        ) {\n          shortest = substring;\n        } else if (\n          isUniqueSubstring(t, substring, arr) &&\n          substring.length === shortest.length &&\n          substring < shortest\n        ) {\n          shortest = substring;\n        }\n      }\n    }\n    answer.push(shortest);\n  }\n  return answer;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(shortestSubstrings([\"cab\",\"ad\",\"bad\",\"c\"]), [\"ab\",\"\",\"ba\",\"\"], \"Test 1 Error!\");\nassert.deepEqual(shortestSubstrings([\"abc\",\"bcd\",\"abcd\"]), [\"\",\"\",\"abcd\"], \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string[]} arr\n * @return {string[]}\n */\nvar shortestSubstrings = function(arr) {",
        "function_name": "shortestSubstrings",
        "difficulty_level": "Middle",
        "time": "20240310"
    },
    {
        "id": "3077",
        "prompt_base": "\"\"\"\n给你一个长度为 n 下标从 0 开始的整数数组 nums 和一个 正奇数 整数 k 。\nx 个子数组的能量值定义为 strength = sum[1] * x - sum[2] * (x - 1) + sum[3] * (x - 2) - sum[4] * (x - 3) + ... + sum[x] * 1 ，其中 sum[i] 是第 i 个子数组的和。更正式的，能量值是满足 1 <= i <= x 的所有 i 对应的 (-1)^{i+1} * sum[i] * (x - i + 1) 之和。\n你需要在 nums 中选择 k 个 不相交子数组 ，使得 能量值最大 。\n请你返回可以得到的 最大能量值 。\n注意，选出来的所有子数组 不 需要覆盖整个数组。\n示例 1：\n输入nums = [1,2,3,-1,2], k = 3\n输出：22示例 2：\n输入nums = [12,-2,-2,-2,-2], k = 5\n输出：64\n\n提示：\n1 <= n <= 10^4\n-10^9 <= nums[i] <= 10^9\n1 <= k <= n\n1 <= n * k <= 10^6\nk 是奇数。\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumStrength = function(nums, k) {",
        "prompt_chat": "给你一个长度为 n 下标从 0 开始的整数数组 nums 和一个 正奇数 整数 k 。\nx 个子数组的能量值定义为 strength = sum[1] * x - sum[2] * (x - 1) + sum[3] * (x - 2) - sum[4] * (x - 3) + ... + sum[x] * 1 ，其中 sum[i] 是第 i 个子数组的和。更正式的，能量值是满足 1 <= i <= x 的所有 i 对应的 (-1)^{i+1} * sum[i] * (x - i + 1) 之和。\n你需要在 nums 中选择 k 个 不相交子数组 ，使得 能量值最大 。\n请你返回可以得到的 最大能量值 。\n注意，选出来的所有子数组 不 需要覆盖整个数组。\n示例 1：\n输入nums = [1,2,3,-1,2], k = 3\n输出：22示例 2：\n输入nums = [12,-2,-2,-2,-2], k = 5\n输出：64\n\n提示：\n1 <= n <= 10^4\n-10^9 <= nums[i] <= 10^9\n1 <= k <= n\n1 <= n * k <= 10^6\nk 是奇数。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumStrength = function(nums, k) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maximumStrength([1,2,3,-1,2],3), 22, \"Test 1 Error!\");\nassert.deepEqual(maximumStrength([12,-2,-2,-2,-2],5), 64, \"Test 2 Error!\");\nassert.deepEqual(maximumStrength([-1,-2,-3],1), -1, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumStrength = function(nums, k) {",
        "function_name": "maximumStrength",
        "difficulty_level": "Hard",
        "time": "20240310"
    },
    {
        "id": "3079",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums ，数组中的元素都是 正 整数。定义一个加密函数 encrypt ，encrypt(x) 将一个整数 x 中 每一个 数位都用 x 中的 最大 数位替换。比方说 encrypt(523) = 555 且 encrypt(213) = 333 。\n请你返回数组中所有元素加密后的 和 。\n示例 1：\n输入nums = [1,2,3]\n输出：6示例 2：\n输入nums = [10,21,31]\n输出：66\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 1000\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumOfEncryptedInt = function(nums) {",
        "prompt_chat": "给你一个整数数组 nums ，数组中的元素都是 正 整数。定义一个加密函数 encrypt ，encrypt(x) 将一个整数 x 中 每一个 数位都用 x 中的 最大 数位替换。比方说 encrypt(523) = 555 且 encrypt(213) = 333 。\n请你返回数组中所有元素加密后的 和 。\n示例 1：\n输入nums = [1,2,3]\n输出：6示例 2：\n输入nums = [10,21,31]\n输出：66\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 1000\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumOfEncryptedInt = function(nums) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumOfEncryptedInt = function(nums) {\n    let ans = 0 \n    for(let x of nums){\n       let b = 0, max = 0 \n       while(x){\n         max = Math.max(max, x % 10)\n         x = x/10 >> 0 \n         b = b*10 + 1\n       } \n       ans += max*b \n    }\n    return ans \n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(sumOfEncryptedInt([1,2,3]), 6, \"Test 1 Error!\");\nassert.deepEqual(sumOfEncryptedInt([10,21,31]), 66, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumOfEncryptedInt = function(nums) {",
        "function_name": "sumOfEncryptedInt",
        "difficulty_level": "Easy",
        "time": "20240316"
    },
    {
        "id": "3080",
        "prompt_base": "\"\"\"\n给你一个长度为 n 下标从 0 开始的正整数数组 nums 。同时给你一个长度为 m 的二维操作数组 queries ，其中 queries[i] = [index_i, k_i] 。\n一开始，数组中的所有元素都 未标记 。你需要依次对数组执行 m 次操作，第 i 次操作中，你需要执行：\n如果下标 index_i 对应的元素还没标记，那么标记这个元素。\n然后标记 k_i 个数组中还没有标记的 最小 元素。如果有元素的值相等，那么优先标记它们中下标较小的。如果少于 k_i 个未标记元素存在，那么将它们全部标记。\n请你返回一个长度为 m 的数组 answer ，其中 answer[i]是第 i 次操作后数组中还没标记元素的 和 。\n示例 1：\n输入nums = [1,2,2,1,2,3,1], queries = [[1,2],[3,3],[4,2]]\n输出：[8,3,0]示例 2：\n输入nums = [1,4,2,3], queries = [[0,1]]\n输出：[7]\n\n提示：\nn == nums.length\nm == queries.length\n1 <= m <= n <= 10^5\n1 <= nums[i] <= 10^5\nqueries[i].length == 2\n0 <= index_i, k_i <= n - 1\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar unmarkedSumArray = function(nums, queries) {",
        "prompt_chat": "给你一个长度为 n 下标从 0 开始的正整数数组 nums 。同时给你一个长度为 m 的二维操作数组 queries ，其中 queries[i] = [index_i, k_i] 。\n一开始，数组中的所有元素都 未标记 。你需要依次对数组执行 m 次操作，第 i 次操作中，你需要执行：\n如果下标 index_i 对应的元素还没标记，那么标记这个元素。\n然后标记 k_i 个数组中还没有标记的 最小 元素。如果有元素的值相等，那么优先标记它们中下标较小的。如果少于 k_i 个未标记元素存在，那么将它们全部标记。\n请你返回一个长度为 m 的数组 answer ，其中 answer[i]是第 i 次操作后数组中还没标记元素的 和 。\n示例 1：\n输入nums = [1,2,2,1,2,3,1], queries = [[1,2],[3,3],[4,2]]\n输出：[8,3,0]示例 2：\n输入nums = [1,4,2,3], queries = [[0,1]]\n输出：[7]\n\n提示：\nn == nums.length\nm == queries.length\n1 <= m <= n <= 10^5\n1 <= nums[i] <= 10^5\nqueries[i].length == 2\n0 <= index_i, k_i <= n - 1\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar unmarkedSumArray = function(nums, queries) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar unmarkedSumArray = function(nums, queries) {\n\n  const n = nums.length;\n  const m = queries.length;\n\n  //1. 建立 v-index 映射\n  const vi = new Array(n).fill().map(() => new Array(2));\n  for (let i = 0; i < n; i++) {\n    vi[i] = [nums[i], i];\n  }\n  //2. 根据排序 （sort稳定排序):\n  //稳定排序： The comparator returns the same result with the same pair of input.\n  vi.sort((a, b) => {\n    // if (a[0] !== b[0]) {\n    //   return a[0] - b[0];\n    // }\n    // return a[1] - b[1];\n      return a[0] - b[0];\n  });\n\n  const ans = new Array(m).fill(0);\n  //先算出总和\n  let sum = nums.reduce((acc, cur) => acc + cur);\n  //Mark 下标的set\n  const mark = new Set();\n  //已经按照优先级排好了序 ,可以按照从左到右的顺序来遍历 vi\n  let viIndex = 0;\n\n  //遍历queries\n  for (let i = 0; i < m; i++) {\n    let [index, k] = queries[i];\n    if (!mark.has(index)) {\n      sum -= nums[index];\n      mark.add(index);\n    }\n    //连续mark k 个值，每次mark 都更新sum, k 和 mark set\n    for (; viIndex < n && k > 0; viIndex++) {\n      const idx = vi[viIndex][1];\n      const val = vi[viIndex][0]; \n      if (!mark.has(idx)) {\n        sum -= val;\n        k--;\n        mark.add(idx);\n      }\n    }\n\n    //mark完， sum更新完之后, 此时sum就是当前queries 的答案.\n    ans[i] = sum;\n  }\n  return ans;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(unmarkedSumArray([1,2,2,1,2,3,1],[[1,2],[3,3],[4,2]]), [8,3,0], \"Test 1 Error!\");\nassert.deepEqual(unmarkedSumArray([1,4,2,3],[[0,1]]), [7], \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar unmarkedSumArray = function(nums, queries) {",
        "function_name": "unmarkedSumArray",
        "difficulty_level": "Middle",
        "time": "20240316"
    },
    {
        "id": "3081",
        "prompt_base": "\"\"\"\n给你一个字符串 s 。s[i] 要么是小写英文字母，要么是问号 '?' 。\n对于长度为 m 且 只 含有小写英文字母的字符串 t ，我们定义函数 cost(i) 为下标 i 之前（也就是范围 [0, i - 1] 中）出现过与 t[i] 相同 字符出现的次数。\n字符串 t 的 分数 为所有下标 i 的 cost(i) 之 和 。比方说，字符串 t = \\\"aab\\\" ：\ncost(0) = 0\ncost(1) = 1\ncost(2) = 0\n所以，字符串 \\\"aab\\\" 的分数为 0 + 1 + 0 = 1 。\n你的任务是用小写英文字母 替换 s 中 所有 问号，使 s 的 分数最小 。\n请你返回替换所有问号 '?' 之后且分数最小的字符串。如果有多个字符串的 分数最小 ，那么返回字典序最小的一个。\n示例 1：\n输入s = \"???\"\n输出：\"abc\"示例 2：\n输入s = \"a?a?\"\n输出：\"abac\"\n\n提示：\n1 <= s.length <= 10^5\ns[i] 要么是小写英文字母，要么是 '?' 。\n\"\"\"\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar minimizeStringValue = function(s) {",
        "prompt_chat": "给你一个字符串 s 。s[i] 要么是小写英文字母，要么是问号 '?' 。\n对于长度为 m 且 只 含有小写英文字母的字符串 t ，我们定义函数 cost(i) 为下标 i 之前（也就是范围 [0, i - 1] 中）出现过与 t[i] 相同 字符出现的次数。\n字符串 t 的 分数 为所有下标 i 的 cost(i) 之 和 。比方说，字符串 t = \\\"aab\\\" ：\ncost(0) = 0\ncost(1) = 1\ncost(2) = 0\n所以，字符串 \\\"aab\\\" 的分数为 0 + 1 + 0 = 1 。\n你的任务是用小写英文字母 替换 s 中 所有 问号，使 s 的 分数最小 。\n请你返回替换所有问号 '?' 之后且分数最小的字符串。如果有多个字符串的 分数最小 ，那么返回字典序最小的一个。\n示例 1：\n输入s = \"???\"\n输出：\"abc\"示例 2：\n输入s = \"a?a?\"\n输出：\"abac\"\n\n提示：\n1 <= s.length <= 10^5\ns[i] 要么是小写英文字母，要么是 '?' 。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar minimizeStringValue = function(s) {\n```",
        "solution": "/**\n * @param {string} s\n * @return {string}\n */\nvar minimizeStringValue = function(s) {\n\n  //1. 利用最小堆优先级队列 整理好替换'?'的逻辑顺序\n  const minHeap = new MinPriorityQueue({\n    compare: (a, b) => {\n      if (a[0] !== b[0]) {\n        return a[0] - b[0];\n      }\n      return a[1] - b[1];\n    }\n  });\n\n  //2. 设定计数器 \n  // - 记录每个小写字母出现的次数\n  // - 记录 ? 符号在原 s中的下标, 等会儿用作替换 \n  const cnt = new Array(26).fill(0);\n  const questionIdx = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === '?') {\n      questionIdx.push(i);\n    } else {\n      const index = s[i].charCodeAt(0) - 'a'.charCodeAt(0);\n      cnt[index]++;\n    }\n  }\n\n  //3. 把s中小写字母的计数放入优先级队列中 初始化优先级队列\n  for (let i = 0; i < cnt.length; i++) {\n      minHeap.enqueue([cnt[i], i]);\n  }\n\n  //因为Javascript的字符串是immutable的, 所以转成mutable的数组，等会儿按照questionIdx替换？符号\n  const ans = s.split('');\n\n  //先把需要替换的字符准备好, 细节: 等会儿需要先排序后替换\n  const tmp = new Array(questionIdx.length).fill(0);\n\n  //4.1 先准备\n  for (let i = 0; i < tmp.length; i++) {\n    //利用优先级队列的性质来准备需要替换的字符\n    const [dequeueCnt, dequeueIndex] = minHeap.dequeue();\n    tmp[i] = dequeueIndex;\n    minHeap.enqueue([dequeueCnt + 1, dequeueIndex]);\n  }\n  //4.2 再排序\n  tmp.sort((a, b) => a - b);\n  //4.3 后替换\n  for (let i = 0; i < tmp.length; i++) {\n    const idx = questionIdx[i];\n    ans[idx] = String.fromCharCode(tmp[i] + 'a'.charCodeAt(0));\n  }\n  return ans.join('');\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimizeStringValue(\"???\"), \"abc\", \"Test 1 Error!\");\nassert.deepEqual(minimizeStringValue(\"a?a?\"), \"abac\", \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} s\n * @return {string}\n */\nvar minimizeStringValue = function(s) {",
        "function_name": "minimizeStringValue",
        "difficulty_level": "Middle",
        "time": "20240316"
    },
    {
        "id": "3082",
        "prompt_base": "\"\"\"\n给你一个长度为 n 的整数数组 nums 和一个 正 整数 k 。\n一个整数数组的 能量 定义为和 等于 k 的子序列的数目。\n请你返回 nums 中所有子序列的 能量和 。\n由于答案可能很大，请你将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入nums = [1,2,3], k = 3\n输出：6示例 2：\n输入nums = [2,3,3], k = 5\n输出：4\n\n提示：\n1 <= n <= 100\n1 <= nums[i] <= 10^4\n1 <= k <= 100\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar sumOfPower = function(nums, k) {",
        "prompt_chat": "给你一个长度为 n 的整数数组 nums 和一个 正 整数 k 。\n一个整数数组的 能量 定义为和 等于 k 的子序列的数目。\n请你返回 nums 中所有子序列的 能量和 。\n由于答案可能很大，请你将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入nums = [1,2,3], k = 3\n输出：6示例 2：\n输入nums = [2,3,3], k = 5\n输出：4\n\n提示：\n1 <= n <= 100\n1 <= nums[i] <= 10^4\n1 <= k <= 100\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar sumOfPower = function(nums, k) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(sumOfPower([1,2,3],3), 6, \"Test 1 Error!\");\nassert.deepEqual(sumOfPower([2,3,3],5), 4, \"Test 2 Error!\");\nassert.deepEqual(sumOfPower([1,2,3],7), 0, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar sumOfPower = function(nums, k) {",
        "function_name": "sumOfPower",
        "difficulty_level": "Hard",
        "time": "20240316"
    },
    {
        "id": "3083",
        "prompt_base": "\"\"\"\n给你一个字符串 s ，请你判断字符串 s 是否存在一个长度为 2 的子字符串，在其反转后的字符串中也出现。\n如果存在这样的子字符串，返回 true；如果不存在，返回 false 。\n示例 1：\n输入s = \"leetcode\"\n输出：true示例 2：\n输入s = \"abcba\"\n输出：true\n\n提示：\n1 <= s.length <= 100\n字符串 s 仅由小写英文字母组成。\n\"\"\"\n\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isSubstringPresent = function(s) {",
        "prompt_chat": "给你一个字符串 s ，请你判断字符串 s 是否存在一个长度为 2 的子字符串，在其反转后的字符串中也出现。\n如果存在这样的子字符串，返回 true；如果不存在，返回 false 。\n示例 1：\n输入s = \"leetcode\"\n输出：true示例 2：\n输入s = \"abcba\"\n输出：true\n\n提示：\n1 <= s.length <= 100\n字符串 s 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isSubstringPresent = function(s) {\n```",
        "solution": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar isSubstringPresent = function(s) {\n    let i\n    let tmp = s.split('').reverse().join('')\n    for(i = 0;i < s.length-1;i ++){\n        let cur = s[i] + s[i+1] //假设为AB\n        // 正则匹配反转字符串有出现形如AB则返回true\n        if(tmp.match(cur)){\n            return true\n        }\n    }\n    // 没有匹配到结果返回false\n    return false\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(isSubstringPresent(\"leetcode\"), true, \"Test 1 Error!\");\nassert.deepEqual(isSubstringPresent(\"abcba\"), true, \"Test 2 Error!\");\nassert.deepEqual(isSubstringPresent(\"abcd\"), false, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar isSubstringPresent = function(s) {",
        "function_name": "isSubstringPresent",
        "difficulty_level": "Easy",
        "time": "20240317"
    },
    {
        "id": "3084",
        "prompt_base": "\"\"\"\n给你一个字符串 s 和一个字符 c 。返回在字符串 s 中并且以 c 字符开头和结尾的非空子字符串的总数。\n示例 1：\n输入s = \"abada\", c = \"a\"\n输出：6示例 2：\n输入s = \"zzz\", c = \"z\"\n输出：6\n\n提示：\n1 <= s.length <= 10^5\ns 和 c 均由小写英文字母组成。\n\"\"\"\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number}\n */\nvar countSubstrings = function(s, c) {",
        "prompt_chat": "给你一个字符串 s 和一个字符 c 。返回在字符串 s 中并且以 c 字符开头和结尾的非空子字符串的总数。\n示例 1：\n输入s = \"abada\", c = \"a\"\n输出：6示例 2：\n输入s = \"zzz\", c = \"z\"\n输出：6\n\n提示：\n1 <= s.length <= 10^5\ns 和 c 均由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number}\n */\nvar countSubstrings = function(s, c) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(countSubstrings(\"abada\",\"a\"), 6, \"Test 1 Error!\");\nassert.deepEqual(countSubstrings(\"zzz\",\"z\"), 6, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} s\n * @param {character} c\n * @return {number}\n */\nvar countSubstrings = function(s, c) {",
        "function_name": "countSubstrings",
        "difficulty_level": "Middle",
        "time": "20240317"
    },
    {
        "id": "3085",
        "prompt_base": "\"\"\"\n给你一个字符串 word 和一个整数 k。\n如果 |freq(word[i]) - freq(word[j])| <= k 对于字符串中所有下标 i 和 j  都成立，则认为 word 是 k 特殊字符串。\n此处，freq(x) 表示字符 x 在 word 中的出现频率，而 |y| 表示 y 的绝对值。\n返回使 word 成为 k 特殊字符串 需要删除的字符的最小数量。\n示例 1：\n输入word = \"aabcaba\", k = 0\n输出：3示例 2：\n输入word = \"dabdcbdcdcd\", k = 2\n输出：2\n\n提示：\n1 <= word.length <= 10^5\n0 <= k <= 10^5\nword 仅由小写英文字母组成。\n\"\"\"\n\n/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar minimumDeletions = function(word, k) {",
        "prompt_chat": "给你一个字符串 word 和一个整数 k。\n如果 |freq(word[i]) - freq(word[j])| <= k 对于字符串中所有下标 i 和 j  都成立，则认为 word 是 k 特殊字符串。\n此处，freq(x) 表示字符 x 在 word 中的出现频率，而 |y| 表示 y 的绝对值。\n返回使 word 成为 k 特殊字符串 需要删除的字符的最小数量。\n示例 1：\n输入word = \"aabcaba\", k = 0\n输出：3示例 2：\n输入word = \"dabdcbdcdcd\", k = 2\n输出：2\n\n提示：\n1 <= word.length <= 10^5\n0 <= k <= 10^5\nword 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar minimumDeletions = function(word, k) {\n```",
        "solution": "/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar minimumDeletions = function(word, k) {\n    let freq = new Map();\n    for (let char of word) {\n        freq.set(char, (freq.get(char) || 0) + 1);\n    }\n    let res=0;\n    for(const [key,value] of freq){\n        const maxValue = value+k,minValue = value-k;\n        let curMaxCover1 = 0,curMaxCover2 = 0;\n        for(let [key,value2] of freq){\n            if(value2>=value && value2<=maxValue){\n                curMaxCover1 += value2;\n            }else if(value2>maxValue){\n                curMaxCover1 += maxValue;\n            }\n            if(value2<=value && value2>=minValue){\n                curMaxCover2 += value2;\n            }else if(value2>value){\n                curMaxCover2 += value;\n            }\n        }\n        res = Math.max(res,curMaxCover1,curMaxCover2);\n\n    }\n    return word.length - res;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumDeletions(\"aabcaba\",0), 3, \"Test 1 Error!\");\nassert.deepEqual(minimumDeletions(\"dabdcbdcdcd\",2), 2, \"Test 2 Error!\");\nassert.deepEqual(minimumDeletions(\"aaabaaa\",2), 1, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar minimumDeletions = function(word, k) {",
        "function_name": "minimumDeletions",
        "difficulty_level": "Middle",
        "time": "20240317"
    },
    {
        "id": "3086",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的二进制数组 nums，其长度为 n ；另给你一个 正整数 k 以及一个 非负整数 maxChanges 。\nAlice 在玩一个游戏，游戏的目标是让 Alice 使用 最少 数量的 行动 次数从 nums 中拾起 k 个 1 。游戏开始时，Alice 可以选择数组 [0, n - 1] 范围内的任何索引 aliceIndex 站立。如果 nums[aliceIndex] == 1 ，Alice 会拾起一个 1 ，并且 nums[aliceIndex] 变成0（这 不算 作一次行动）。之后，Alice 可以执行 任意数量 的 行动（包括零次），在每次行动中 Alice 必须 恰好 执行以下动作之一：\n选择任意一个下标 j != aliceIndex 且满足 nums[j] == 0 ，然后将 nums[j] 设置为 1 。这个动作最多可以执行 maxChanges 次。\n选择任意两个相邻的下标 x 和 y（|x - y| == 1）且满足 nums[x] == 1, nums[y] == 0 ，然后交换它们的值（将 nums[y] = 1 和 nums[x] = 0）。如果 y == aliceIndex，在这次行动后 Alice 拾起一个 1 ，并且 nums[y] 变成 0 。\n返回 Alice 拾起 恰好 k 个 1 所需的 最少 行动次数。\n示例 1：\n输入nums = [1,1,0,0,0,1,1,0,0,1], k = 3, maxChanges = 1\n输出：3示例 2：\n输入nums = [0,0,0,0], k = 2, maxChanges = 3\n输出：4\n\n提示：\n2 <= n <= 10^5\n0 <= nums[i] <= 1\n1 <= k <= 10^5\n0 <= maxChanges <= 10^5\nmaxChanges + sum(nums) >= k\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number} maxChanges\n * @return {number}\n */\nvar minimumMoves = function(nums, k, maxChanges) {",
        "prompt_chat": "给你一个下标从 0 开始的二进制数组 nums，其长度为 n ；另给你一个 正整数 k 以及一个 非负整数 maxChanges 。\nAlice 在玩一个游戏，游戏的目标是让 Alice 使用 最少 数量的 行动 次数从 nums 中拾起 k 个 1 。游戏开始时，Alice 可以选择数组 [0, n - 1] 范围内的任何索引 aliceIndex 站立。如果 nums[aliceIndex] == 1 ，Alice 会拾起一个 1 ，并且 nums[aliceIndex] 变成0（这 不算 作一次行动）。之后，Alice 可以执行 任意数量 的 行动（包括零次），在每次行动中 Alice 必须 恰好 执行以下动作之一：\n选择任意一个下标 j != aliceIndex 且满足 nums[j] == 0 ，然后将 nums[j] 设置为 1 。这个动作最多可以执行 maxChanges 次。\n选择任意两个相邻的下标 x 和 y（|x - y| == 1）且满足 nums[x] == 1, nums[y] == 0 ，然后交换它们的值（将 nums[y] = 1 和 nums[x] = 0）。如果 y == aliceIndex，在这次行动后 Alice 拾起一个 1 ，并且 nums[y] 变成 0 。\n返回 Alice 拾起 恰好 k 个 1 所需的 最少 行动次数。\n示例 1：\n输入nums = [1,1,0,0,0,1,1,0,0,1], k = 3, maxChanges = 1\n输出：3示例 2：\n输入nums = [0,0,0,0], k = 2, maxChanges = 3\n输出：4\n\n提示：\n2 <= n <= 10^5\n0 <= nums[i] <= 1\n1 <= k <= 10^5\n0 <= maxChanges <= 10^5\nmaxChanges + sum(nums) >= k\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number} maxChanges\n * @return {number}\n */\nvar minimumMoves = function(nums, k, maxChanges) {\n```",
        "solution": "var f = function(i, nums) {\n    let x = nums[i];\n    if (i - 1 >= 0) {\n        x += nums[i - 1];\n    }\n    if (i + 1 < nums.length) {\n        x += nums[i + 1];\n    }\n    return x;\n};\n\nvar minimumMoves = function(nums, k, maxChanges) {\n    let n = nums.length;\n\n    let indexSum = new Array(n + 1).fill(0), sum = new Array(n + 1).fill(0);\n    for (let i = 0; i < n; i++) {\n        indexSum[i + 1] = indexSum[i] + nums[i] * i;\n        sum[i + 1] = sum[i] + nums[i];\n    }\n    let res = Infinity;\n    for (let i = 0; i < n; i++) {\n        if (f(i, nums) + maxChanges >= k) {\n            if (k <= f(i, nums)) {\n                res = Math.min(res, k - nums[i]);\n            } else {\n                res = Math.min(res, 2 * k - f(i, nums) - nums[i]);\n            }\n            continue;\n        }\n        let left = 0, right = n;\n        while (left <= right) {\n            let mid = Math.floor((left + right) / 2);\n            let i1 = Math.max(i - mid, 0), i2 = Math.min(i + mid, n - 1);\n            if (sum[i2 + 1] - sum[i1] >= k - maxChanges) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        let i1 = Math.max(i - left, 0), i2 = Math.min(i + left, n - 1);\n        if (sum[i2 + 1] - sum[i1] > k - maxChanges) {\n            i1++;\n        }\n        let count1 = sum[i + 1] - sum[i1], count2 = sum[i2 + 1] - sum[i + 1];\n        res = Math.min(res, indexSum[i2 + 1] - indexSum[i + 1] - i * count2 + i * count1 - (indexSum[i + 1] - indexSum[i1]) + 2 * maxChanges);\n    }\n    return res;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumMoves([1,1,0,0,0,1,1,0,0,1],3,1), 3, \"Test 1 Error!\");\nassert.deepEqual(minimumMoves([0,0,0,0],2,3), 4, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number} maxChanges\n * @return {number}\n */\nvar minimumMoves = function(nums, k, maxChanges) {",
        "function_name": "minimumMoves",
        "difficulty_level": "Hard",
        "time": "20240317"
    },
    {
        "id": "3090",
        "prompt_base": "\"\"\"\n给你一个字符串 s ，请找出满足每个字符最多出现两次的最长子字符串，并返回该\n子字符串\n的 最大 长度。\n示例 1：\n输入s = \"bcbbbcba\"\n输出：4示例 2：\n输入s = \"aaaa\"\n输出：2\n\n提示：\n2 <= s.length <= 100\ns 仅由小写英文字母组成。\n\"\"\"\n\n/**\n * @param {string} s\n * @return {number}\n */\nvar maximumLengthSubstring = function(s) {",
        "prompt_chat": "给你一个字符串 s ，请找出满足每个字符最多出现两次的最长子字符串，并返回该\n子字符串\n的 最大 长度。\n示例 1：\n输入s = \"bcbbbcba\"\n输出：4示例 2：\n输入s = \"aaaa\"\n输出：2\n\n提示：\n2 <= s.length <= 100\ns 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar maximumLengthSubstring = function(s) {\n```",
        "solution": "/**\n * @param {string} s\n * @return {number}\n */\nvar maximumLengthSubstring = function(s) {\nlet len = s.length;\n  let result = [];\n  let max = 0;\n  let i = 0;\n  let j = 0;\n  while (i < len && j < len && i <= j) {\n    result.push(s[j]);\n    if (result.filter((item) => item === s[j]).length < 3) {\n      j++;\n      max = Math.max(max, result.length);\n    } else {\n      max = Math.max(max, result.length - 1);\n      i = i + 1;\n      j = i;\n      result = [];\n    }\n  }\n  return max;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maximumLengthSubstring(\"bcbbbcba\"), 4, \"Test 1 Error!\");\nassert.deepEqual(maximumLengthSubstring(\"aaaa\"), 2, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} s\n * @return {number}\n */\nvar maximumLengthSubstring = function(s) {",
        "function_name": "maximumLengthSubstring",
        "difficulty_level": "Easy",
        "time": "20240324"
    },
    {
        "id": "3091",
        "prompt_base": "\"\"\"\n给你一个正整数 k 。最初，你有一个数组 nums = [1] 。\n你可以对数组执行以下 任意 操作 任意 次数（可能为零）：\n选择数组中的任何一个元素，然后将它的值 增加 1 。\n复制数组中的任何一个元素，然后将它附加到数组的末尾。\n返回使得最终数组元素之 和 大于或等于 k 所需的 最少 操作次数。\n示例 1：\n输入k = 11\n输出：5示例 2：\n输入k = 1\n输出：0\n\n提示：\n1 <= k <= 105\n\"\"\"\n\n/**\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(k) {",
        "prompt_chat": "给你一个正整数 k 。最初，你有一个数组 nums = [1] 。\n你可以对数组执行以下 任意 操作 任意 次数（可能为零）：\n选择数组中的任何一个元素，然后将它的值 增加 1 。\n复制数组中的任何一个元素，然后将它附加到数组的末尾。\n返回使得最终数组元素之 和 大于或等于 k 所需的 最少 操作次数。\n示例 1：\n输入k = 11\n输出：5示例 2：\n输入k = 1\n输出：0\n\n提示：\n1 <= k <= 105\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(k) {\n```",
        "solution": "/**\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(k) {\n  if (k === 1) return 0\n  // (1 + n ) * m > k 求 n + m 最小值\n  let num = 1\n  let res = Infinity\n\n  for (let i = 1; i < k; i++) {\n    let m = Math.ceil((k - (num + i)) / (num + i))\n    if (res >= m + i) {\n      res = m + i\n    } else {\n      return res\n    }\n  }\n\n  return res\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minOperations(11), 5, \"Test 1 Error!\");\nassert.deepEqual(minOperations(1), 0, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(k) {",
        "function_name": "minOperations",
        "difficulty_level": "Middle",
        "time": "20240324"
    },
    {
        "id": "3092",
        "prompt_base": "\"\"\"\n你需要在一个集合里动态记录 ID 的出现频率。给你两个长度都为 n 的整数数组 nums 和 freq ，nums 中每一个元素表示一个 ID ，对应的 freq 中的元素表示这个 ID 在集合中此次操作后需要增加或者减少的数目。\n增加 ID 的数目：如果 freq[i] 是正数，那么 freq[i] 个 ID 为 nums[i] 的元素在第 i 步操作后会添加到集合中。\n减少 ID 的数目：如果 freq[i] 是负数，那么 -freq[i] 个 ID 为 nums[i] 的元素在第 i 步操作后会从集合中删除。\n请你返回一个长度为 n 的数组 ans ，其中 ans[i] 表示第 i 步操作后出现频率最高的 ID 数目 ，如果在某次操作后集合为空，那么 ans[i] 为 0 。\n示例 1：\n输入nums = [2,3,2,1], freq = [3,2,-3,1]\n输出：[3,3,2,2]示例 2：\n输入nums = [5,5,3], freq = [2,-2,1]\n输出：[2,0,1]\n\n提示：\n1 <= nums.length == freq.length <= 10^5\n1 <= nums[i] <= 10^5\n-10^5 <= freq[i] <= 10^5\nfreq[i] != 0\n输入保证任何操作后，集合中的元素出现次数不会为负数。\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number[]} freq\n * @return {number[]}\n */\nvar mostFrequentIDs = function(nums, freq) {",
        "prompt_chat": "你需要在一个集合里动态记录 ID 的出现频率。给你两个长度都为 n 的整数数组 nums 和 freq ，nums 中每一个元素表示一个 ID ，对应的 freq 中的元素表示这个 ID 在集合中此次操作后需要增加或者减少的数目。\n增加 ID 的数目：如果 freq[i] 是正数，那么 freq[i] 个 ID 为 nums[i] 的元素在第 i 步操作后会添加到集合中。\n减少 ID 的数目：如果 freq[i] 是负数，那么 -freq[i] 个 ID 为 nums[i] 的元素在第 i 步操作后会从集合中删除。\n请你返回一个长度为 n 的数组 ans ，其中 ans[i] 表示第 i 步操作后出现频率最高的 ID 数目 ，如果在某次操作后集合为空，那么 ans[i] 为 0 。\n示例 1：\n输入nums = [2,3,2,1], freq = [3,2,-3,1]\n输出：[3,3,2,2]示例 2：\n输入nums = [5,5,3], freq = [2,-2,1]\n输出：[2,0,1]\n\n提示：\n1 <= nums.length == freq.length <= 10^5\n1 <= nums[i] <= 10^5\n-10^5 <= freq[i] <= 10^5\nfreq[i] != 0\n输入保证任何操作后，集合中的元素出现次数不会为负数。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number[]} freq\n * @return {number[]}\n */\nvar mostFrequentIDs = function(nums, freq) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @param {number[]} freq\n * @return {number[]}\n */\nvar mostFrequentIDs = function(nums, freq) {\n  let list = new Array(10 ** 5+1).fill(0)\n  let maxPQ = new MaxPriorityQueue({\n    priority: item => item.count,\n  })\n  return nums.map((item, idx) => {\n    list[item] += freq[idx]\n    const obj = {\n      count: list[item],\n      key: item,\n    }\n    maxPQ.enqueue(obj)\n    let o = maxPQ.front().element\n    while (o.count !== list[o.key]) {\n      maxPQ.dequeue()\n      o = maxPQ.front().element\n    }\n    return o.count\n  })\n}",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(mostFrequentIDs([2,3,2,1],[3,2,-3,1]), [3,3,2,2], \"Test 1 Error!\");\nassert.deepEqual(mostFrequentIDs([5,5,3],[2,-2,1]), [2,0,1], \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number[]} freq\n * @return {number[]}\n */\nvar mostFrequentIDs = function(nums, freq) {",
        "function_name": "mostFrequentIDs",
        "difficulty_level": "Middle",
        "time": "20240324"
    },
    {
        "id": "3093",
        "prompt_base": "\"\"\"\n给你两个字符串数组 wordsContainer 和 wordsQuery 。\n对于每个 wordsQuery[i] ，你需要从 wordsContainer 中找到一个与 wordsQuery[i] 有 最长公共后缀 的字符串。如果 wordsContainer 中有两个或者更多字符串有最长公共后缀，那么答案为长度 最短 的。如果有超过两个字符串有 相同 最短长度，那么答案为它们在 wordsContainer 中出现 更早 的一个。\n请你返回一个整数数组 ans ，其中 ans[i]是 wordsContainer中与 wordsQuery[i] 有 最长公共后缀 字符串的下标。\n示例 1：\n输入wordsContainer = [\"abcd\",\"bcd\",\"xbcd\"], wordsQuery = [\"cd\",\"bcd\",\"xyz\"]\n输出：[1,1,1]示例 2：\n输入wordsContainer = [\"abcdefgh\",\"poiuygh\",\"ghghgh\"], wordsQuery = [\"gh\",\"acbfgh\",\"acbfegh\"]\n输出：[2,0,2]\n\n提示：\n1 <= wordsContainer.length, wordsQuery.length <= 10^4\n1 <= wordsContainer[i].length <= 5 * 10^3\n1 <= wordsQuery[i].length <= 5 * 10^3\nwordsContainer[i] 只包含小写英文字母。\nwordsQuery[i] 只包含小写英文字母。\nwordsContainer[i].length 的和至多为 5 * 10^5 。\nwordsQuery[i].length 的和至多为 5 * 10^5 。\n\"\"\"\n\n/**\n * @param {string[]} wordsContainer\n * @param {string[]} wordsQuery\n * @return {number[]}\n */\nvar stringIndices = function(wordsContainer, wordsQuery) {",
        "prompt_chat": "给你两个字符串数组 wordsContainer 和 wordsQuery 。\n对于每个 wordsQuery[i] ，你需要从 wordsContainer 中找到一个与 wordsQuery[i] 有 最长公共后缀 的字符串。如果 wordsContainer 中有两个或者更多字符串有最长公共后缀，那么答案为长度 最短 的。如果有超过两个字符串有 相同 最短长度，那么答案为它们在 wordsContainer 中出现 更早 的一个。\n请你返回一个整数数组 ans ，其中 ans[i]是 wordsContainer中与 wordsQuery[i] 有 最长公共后缀 字符串的下标。\n示例 1：\n输入wordsContainer = [\"abcd\",\"bcd\",\"xbcd\"], wordsQuery = [\"cd\",\"bcd\",\"xyz\"]\n输出：[1,1,1]示例 2：\n输入wordsContainer = [\"abcdefgh\",\"poiuygh\",\"ghghgh\"], wordsQuery = [\"gh\",\"acbfgh\",\"acbfegh\"]\n输出：[2,0,2]\n\n提示：\n1 <= wordsContainer.length, wordsQuery.length <= 10^4\n1 <= wordsContainer[i].length <= 5 * 10^3\n1 <= wordsQuery[i].length <= 5 * 10^3\nwordsContainer[i] 只包含小写英文字母。\nwordsQuery[i] 只包含小写英文字母。\nwordsContainer[i].length 的和至多为 5 * 10^5 。\nwordsQuery[i].length 的和至多为 5 * 10^5 。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string[]} wordsContainer\n * @param {string[]} wordsQuery\n * @return {number[]}\n */\nvar stringIndices = function(wordsContainer, wordsQuery) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(stringIndices([\"abcd\",\"bcd\",\"xbcd\"],[\"cd\",\"bcd\",\"xyz\"]), [1,1,1], \"Test 1 Error!\");\nassert.deepEqual(stringIndices([\"abcdefgh\",\"poiuygh\",\"ghghgh\"],[\"gh\",\"acbfgh\",\"acbfegh\"]), [2,0,2], \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string[]} wordsContainer\n * @param {string[]} wordsQuery\n * @return {number[]}\n */\nvar stringIndices = function(wordsContainer, wordsQuery) {",
        "function_name": "stringIndices",
        "difficulty_level": "Hard",
        "time": "20240324"
    },
    {
        "id": "3095",
        "prompt_base": "\"\"\"\n给你一个 非负 整数数组 nums 和一个整数 k 。\n如果一个数组中所有元素的按位或运算 OR 的值 至少 为 k ，那么我们称这个数组是 特别的 。\n请你返回 nums 中 最短特别非空 子数组的长度，如果特别子数组不存在，那么返回 -1 。\n示例 1：\n输入nums = [1,2,3], k = 2\n输出：1示例 2：\n输入nums = [2,1,8], k = 10\n输出：3\n\n提示：\n1 <= nums.length <= 50\n0 <= nums[i] <= 50\n0 <= k < 64\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minimumSubarrayLength = function(nums, k) {",
        "prompt_chat": "给你一个 非负 整数数组 nums 和一个整数 k 。\n如果一个数组中所有元素的按位或运算 OR 的值 至少 为 k ，那么我们称这个数组是 特别的 。\n请你返回 nums 中 最短特别非空 子数组的长度，如果特别子数组不存在，那么返回 -1 。\n示例 1：\n输入nums = [1,2,3], k = 2\n输出：1示例 2：\n输入nums = [2,1,8], k = 10\n输出：3\n\n提示：\n1 <= nums.length <= 50\n0 <= nums[i] <= 50\n0 <= k < 64\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minimumSubarrayLength = function(nums, k) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minimumSubarrayLength = function(nums, k) {\n    let ans = 100;\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j <= nums.length; j++) {\n            let temp = nums.slice(i, j);\n            let res = temp.reduce((a, b) => a | b);\n            if (res >= k) ans = Math.min(ans, j - i);\n        }\n    }\n    return ans === 100 ? -1 : ans;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumSubarrayLength([1,2,3],2), 1, \"Test 1 Error!\");\nassert.deepEqual(minimumSubarrayLength([2,1,8],10), 3, \"Test 2 Error!\");\nassert.deepEqual(minimumSubarrayLength([1,2],0), 1, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minimumSubarrayLength = function(nums, k) {",
        "function_name": "minimumSubarrayLength",
        "difficulty_level": "Easy",
        "time": "20240330"
    },
    {
        "id": "3096",
        "prompt_base": "\"\"\"\n给你一个长度为 n 的二进制数组 possible 。\nAlice 和 Bob 正在玩一个有 n 个关卡的游戏，游戏中有一些关卡是 困难 模式，其他的关卡是 简单 模式。如果 possible[i] == 0 ，那么第 i 个关卡是 困难 模式。一个玩家通过一个简单模式的关卡可以获得 1 分，通过困难模式的关卡将失去 1 分。\n游戏的一开始，Alice 将从第 0 级开始 按顺序 完成一些关卡，然后 Bob 会完成剩下的所有关卡。\n假设两名玩家都采取最优策略，目的是 最大化 自己的得分，Alice 想知道自己 最少 需要完成多少个关卡，才能获得比 Bob 更多的分数。\n请你返回 Alice 获得比 Bob 更多的分数所需要完成的 最少 关卡数目，如果 无法 达成，那么返回 -1 。\n注意，每个玩家都至少需要完成 1 个关卡。\n示例 1：\n输入possible = [1,0,1,0]\n输出：1示例 2：\n输入possible = [1,1,1,1,1]\n输出：3\n\n提示：\n2 <= n == possible.length <= 10^5\npossible[i] 要么是 0 要么是 1 。\n\"\"\"\n\n/**\n * @param {number[]} possible\n * @return {number}\n */\nvar minimumLevels = function(possible) {",
        "prompt_chat": "给你一个长度为 n 的二进制数组 possible 。\nAlice 和 Bob 正在玩一个有 n 个关卡的游戏，游戏中有一些关卡是 困难 模式，其他的关卡是 简单 模式。如果 possible[i] == 0 ，那么第 i 个关卡是 困难 模式。一个玩家通过一个简单模式的关卡可以获得 1 分，通过困难模式的关卡将失去 1 分。\n游戏的一开始，Alice 将从第 0 级开始 按顺序 完成一些关卡，然后 Bob 会完成剩下的所有关卡。\n假设两名玩家都采取最优策略，目的是 最大化 自己的得分，Alice 想知道自己 最少 需要完成多少个关卡，才能获得比 Bob 更多的分数。\n请你返回 Alice 获得比 Bob 更多的分数所需要完成的 最少 关卡数目，如果 无法 达成，那么返回 -1 。\n注意，每个玩家都至少需要完成 1 个关卡。\n示例 1：\n输入possible = [1,0,1,0]\n输出：1示例 2：\n输入possible = [1,1,1,1,1]\n输出：3\n\n提示：\n2 <= n == possible.length <= 10^5\npossible[i] 要么是 0 要么是 1 。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} possible\n * @return {number}\n */\nvar minimumLevels = function(possible) {\n```",
        "solution": "var minimumLevels = function(possible) {\n    let sum = 0;\n    let n = possible.length;\n    for (let i = 0; i < n; i++) {\n        if (possible[i] === 1) {\n            sum++;\n        } else {\n            sum--;\n        }\n    }\n    let left = 0;\n    for (let i = 0; i < n - 1; i++) {\n        if (possible[i] === 1) {\n            left++;\n        } else {\n            left--;\n        }\n        if (left * 2 > sum) {\n            return i + 1;\n        }\n    }\n    return -1;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumLevels([1,0,1,0]), 1, \"Test 1 Error!\");\nassert.deepEqual(minimumLevels([1,1,1,1,1]), 3, \"Test 2 Error!\");\nassert.deepEqual(minimumLevels([0,0]), -1, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} possible\n * @return {number}\n */\nvar minimumLevels = function(possible) {",
        "function_name": "minimumLevels",
        "difficulty_level": "Middle",
        "time": "20240330"
    },
    {
        "id": "3097",
        "prompt_base": "\"\"\"\n给你一个 非负 整数数组 nums 和一个整数 k 。\n如果一个数组中所有元素的按位或运算 OR 的值 至少 为 k ，那么我们称这个数组是 特别的 。\n请你返回 nums 中 最短特别非空 子数组的长度，如果特别子数组不存在，那么返回 -1 。\n示例 1：\n输入nums = [1,2,3], k = 2\n输出：1示例 2：\n输入nums = [2,1,8], k = 10\n输出：3\n\n提示：\n1 <= nums.length <= 2 * 10^5\n0 <= nums[i] <= 10^9\n0 <= k <= 10^9\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minimumSubarrayLength = function(nums, k) {",
        "prompt_chat": "给你一个 非负 整数数组 nums 和一个整数 k 。\n如果一个数组中所有元素的按位或运算 OR 的值 至少 为 k ，那么我们称这个数组是 特别的 。\n请你返回 nums 中 最短特别非空 子数组的长度，如果特别子数组不存在，那么返回 -1 。\n示例 1：\n输入nums = [1,2,3], k = 2\n输出：1示例 2：\n输入nums = [2,1,8], k = 10\n输出：3\n\n提示：\n1 <= nums.length <= 2 * 10^5\n0 <= nums[i] <= 10^9\n0 <= k <= 10^9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minimumSubarrayLength = function(nums, k) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumSubarrayLength([1,2,3],2), 1, \"Test 1 Error!\");\nassert.deepEqual(minimumSubarrayLength([2,1,8],10), 3, \"Test 2 Error!\");\nassert.deepEqual(minimumSubarrayLength([1,2],0), 1, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minimumSubarrayLength = function(nums, k) {",
        "function_name": "minimumSubarrayLength",
        "difficulty_level": "Middle",
        "time": "20240330"
    },
    {
        "id": "3098",
        "prompt_base": "\"\"\"\n给你一个长度为 n 的整数数组 nums 和一个 正 整数 k 。\n一个子序列的 能量 定义为子序列中 任意 两个元素的差值绝对值的 最小值 。\n请你返回 nums 中长度 等于 k 的 所有 子序列的 能量和 。\n由于答案可能会很大，将答案对 10^9 + 7 取余 后返回。\n示例 1：\n输入nums = [1,2,3,4], k = 3\n输出：4示例 2：\n输入nums = [2,2], k = 2\n输出：0\n\n提示：\n2 <= n == nums.length <= 50\n-10^8 <= nums[i] <= 10^8\n2 <= k <= n\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar sumOfPowers = function(nums, k) {",
        "prompt_chat": "给你一个长度为 n 的整数数组 nums 和一个 正 整数 k 。\n一个子序列的 能量 定义为子序列中 任意 两个元素的差值绝对值的 最小值 。\n请你返回 nums 中长度 等于 k 的 所有 子序列的 能量和 。\n由于答案可能会很大，将答案对 10^9 + 7 取余 后返回。\n示例 1：\n输入nums = [1,2,3,4], k = 3\n输出：4示例 2：\n输入nums = [2,2], k = 2\n输出：0\n\n提示：\n2 <= n == nums.length <= 50\n-10^8 <= nums[i] <= 10^8\n2 <= k <= n\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar sumOfPowers = function(nums, k) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar sumOfPowers = function(nums, k) {\n    nums.sort((a,b) => a - b);\n    let mod = 10 ** 9 + 7;\n    let dp = new Array(nums.length).fill([]).map(_ => new Array(k + 1).fill(0).map(_ => new Map()));\n    for(let a = 0;a < nums.length;a++){\n        for(let b = a - 1;b >= 0;b--){\n            for(let c = 1;c < k;c++){\n                for(let [min,count] of dp[b][c]){\n                    let m = Math.min(min,nums[a] - nums[b]);\n                    dp[a][c + 1].set(m,((dp[a][c + 1].get(m) | 0) + count) % mod);\n                }\n            }\n        }\n        dp[a][1].set(Infinity,1);\n    }\n    let ans = 0;\n    for(let a = 0;a < nums.length;a++){\n        for(let [min,count] of dp[a][k]){\n            ans = (ans + min * count) % mod;\n        }\n    }\n    return ans;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(sumOfPowers([1,2,3,4],3), 4, \"Test 1 Error!\");\nassert.deepEqual(sumOfPowers([2,2],2), 0, \"Test 2 Error!\");\nassert.deepEqual(sumOfPowers([4,3,-1],2), 10, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar sumOfPowers = function(nums, k) {",
        "function_name": "sumOfPowers",
        "difficulty_level": "Hard",
        "time": "20240330"
    },
    {
        "id": "3099",
        "prompt_base": "\"\"\"\n如果一个整数能够被其各个数位上的数字之和整除，则称之为 哈沙德数（Harshad number）。给你一个整数 x 。如果 x 是 哈沙德数 ，则返回 x 各个数位上的数字之和，否则，返回 -1 。\n示例 1：\n输入x = 18\n输出：9示例 2：\n输入x = 23\n输出：-1\n\n提示：\n1 <= x <= 100\n\"\"\"\n\n/**\n * @param {number} x\n * @return {number}\n */\nvar sumOfTheDigitsOfHarshadNumber = function(x) {",
        "prompt_chat": "如果一个整数能够被其各个数位上的数字之和整除，则称之为 哈沙德数（Harshad number）。给你一个整数 x 。如果 x 是 哈沙德数 ，则返回 x 各个数位上的数字之和，否则，返回 -1 。\n示例 1：\n输入x = 18\n输出：9示例 2：\n输入x = 23\n输出：-1\n\n提示：\n1 <= x <= 100\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} x\n * @return {number}\n */\nvar sumOfTheDigitsOfHarshadNumber = function(x) {\n```",
        "solution": "var sumOfTheDigitsOfHarshadNumber = function(x) {\n    let s = 0;\n    for (let y = x; y != 0; y = Math.floor(y / 10)) {\n        s += y % 10;\n    }\n    return x % s ? -1 : s;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(sumOfTheDigitsOfHarshadNumber(18), 9, \"Test 1 Error!\");\nassert.deepEqual(sumOfTheDigitsOfHarshadNumber(23), -1, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} x\n * @return {number}\n */\nvar sumOfTheDigitsOfHarshadNumber = function(x) {",
        "function_name": "sumOfTheDigitsOfHarshadNumber",
        "difficulty_level": "Easy",
        "time": "20240331"
    },
    {
        "id": "3100",
        "prompt_base": "\"\"\"\n给你两个整数 numBottles 和 numExchange 。numBottles 代表你最初拥有的满水瓶数量。在一次操作中，你可以执行以下操作之一：\n喝掉任意数量的满水瓶，使它们变成空水瓶。\n用 numExchange 个空水瓶交换一个满水瓶。然后，将 numExchange 的值增加 1 。\n注意，你不能使用相同的 numExchange 值交换多批空水瓶。例如，如果 numBottles == 3 并且 numExchange == 1 ，则不能用 3 个空水瓶交换成 3 个满水瓶。\n返回你 最多 可以喝到多少瓶水。\n示例 1：\n输入numBottles = 13, numExchange = 6\n输出：15示例 2：\n输入numBottles = 10, numExchange = 3\n输出：13\n\n提示：\n1 <= numBottles <= 100 \n1 <= numExchange <= 100\n\"\"\"\n\n/**\n * @param {number} numBottles\n * @param {number} numExchange\n * @return {number}\n */\nvar maxBottlesDrunk = function(numBottles, numExchange) {",
        "prompt_chat": "给你两个整数 numBottles 和 numExchange 。numBottles 代表你最初拥有的满水瓶数量。在一次操作中，你可以执行以下操作之一：\n喝掉任意数量的满水瓶，使它们变成空水瓶。\n用 numExchange 个空水瓶交换一个满水瓶。然后，将 numExchange 的值增加 1 。\n注意，你不能使用相同的 numExchange 值交换多批空水瓶。例如，如果 numBottles == 3 并且 numExchange == 1 ，则不能用 3 个空水瓶交换成 3 个满水瓶。\n返回你 最多 可以喝到多少瓶水。\n示例 1：\n输入numBottles = 13, numExchange = 6\n输出：15示例 2：\n输入numBottles = 10, numExchange = 3\n输出：13\n\n提示：\n1 <= numBottles <= 100 \n1 <= numExchange <= 100\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} numBottles\n * @param {number} numExchange\n * @return {number}\n */\nvar maxBottlesDrunk = function(numBottles, numExchange) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maxBottlesDrunk(13,6), 15, \"Test 1 Error!\");\nassert.deepEqual(maxBottlesDrunk(10,3), 13, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} numBottles\n * @param {number} numExchange\n * @return {number}\n */\nvar maxBottlesDrunk = function(numBottles, numExchange) {",
        "function_name": "maxBottlesDrunk",
        "difficulty_level": "Middle",
        "time": "20240331"
    },
    {
        "id": "3101",
        "prompt_base": "\"\"\"\n给你一个二进制数组nums。如果一个子数组中 不存在 两个 相邻 元素的值 相同 的情况，我们称这样的子数组为 交替子数组 。\n返回数组 nums 中交替子数组的数量。\n示例 1：\n输入nums = [0,1,1,1]\n输出：5示例 2：\n输入nums = [1,0,1,0]\n输出：10\n\n提示：\n1 <= nums.length <= 10^5\nnums[i] 不是 0 就是 1 。\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar countAlternatingSubarrays = function(nums) {",
        "prompt_chat": "给你一个二进制数组nums。如果一个子数组中 不存在 两个 相邻 元素的值 相同 的情况，我们称这样的子数组为 交替子数组 。\n返回数组 nums 中交替子数组的数量。\n示例 1：\n输入nums = [0,1,1,1]\n输出：5示例 2：\n输入nums = [1,0,1,0]\n输出：10\n\n提示：\n1 <= nums.length <= 10^5\nnums[i] 不是 0 就是 1 。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar countAlternatingSubarrays = function(nums) {\n```",
        "solution": "var countAlternatingSubarrays = function(nums) {\n    let res = 0, cur = 0, pre = -1;\n    for (const a of nums) {\n        cur = (pre != a) ? cur + 1 : 1;\n        pre = a;\n        res += cur;\n    }\n    return res;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(countAlternatingSubarrays([0,1,1,1]), 5, \"Test 1 Error!\");\nassert.deepEqual(countAlternatingSubarrays([1,0,1,0]), 10, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar countAlternatingSubarrays = function(nums) {",
        "function_name": "countAlternatingSubarrays",
        "difficulty_level": "Middle",
        "time": "20240331"
    },
    {
        "id": "3102",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的数组 points ，它表示二维平面上一些点的整数坐标，其中 points[i] = [x_i, y_i] 。\n两点之间的距离定义为它们的曼哈顿距离。\n请你恰好移除一个点，返回移除后任意两点之间的 最大 距离可能的 最小 值。\n示例 1：\n输入points = [[3,10],[5,15],[10,2],[4,4]]\n输出：12示例 2：\n输入points = [[1,1],[1,1],[1,1]]\n输出：0\n\n提示：\n3 <= points.length <= 10^5\npoints[i].length == 2\n1 <= points[i][0], points[i][1] <= 10^8\n\"\"\"\n\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar minimumDistance = function(points) {",
        "prompt_chat": "给你一个下标从 0 开始的数组 points ，它表示二维平面上一些点的整数坐标，其中 points[i] = [x_i, y_i] 。\n两点之间的距离定义为它们的曼哈顿距离。\n请你恰好移除一个点，返回移除后任意两点之间的 最大 距离可能的 最小 值。\n示例 1：\n输入points = [[3,10],[5,15],[10,2],[4,4]]\n输出：12示例 2：\n输入points = [[1,1],[1,1],[1,1]]\n输出：0\n\n提示：\n3 <= points.length <= 10^5\npoints[i].length == 2\n1 <= points[i][0], points[i][1] <= 10^8\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar minimumDistance = function(points) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumDistance([[3,10],[5,15],[10,2],[4,4]]), 12, \"Test 1 Error!\");\nassert.deepEqual(minimumDistance([[1,1],[1,1],[1,1]]), 0, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} points\n * @return {number}\n */\nvar minimumDistance = function(points) {",
        "function_name": "minimumDistance",
        "difficulty_level": "Hard",
        "time": "20240331"
    },
    {
        "id": "3105",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 。返回数组 nums 中 严格递增 或 严格递减 的最长非空子数组的长度。\n示例 1：\n输入nums = [1,4,3,3,2]\n输出：2示例 2：\n输入nums = [3,3,3,3]\n输出：1\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 50\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestMonotonicSubarray = function(nums) {",
        "prompt_chat": "给你一个整数数组 nums 。返回数组 nums 中 严格递增 或 严格递减 的最长非空子数组的长度。\n示例 1：\n输入nums = [1,4,3,3,2]\n输出：2示例 2：\n输入nums = [3,3,3,3]\n输出：1\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 50\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestMonotonicSubarray = function(nums) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestMonotonicSubarray = function(nums) {\n    let ansmin = 1\n    let ansmax = 1\n    let min = 1\n    let max = 1\n    for (let i = 1; i < nums.length; i++) {\n        if(nums[i-1] > nums[i]){\n            min ++\n        }else{\n            min = 1\n        }\n        if(nums[i-1] < nums[i]){\n            max ++\n        }else{\n            max = 1\n        }\n        ansmin = Math.max(min, ansmin)\n        ansmax = Math.max(max, ansmax)\n    }\n    return  Math.max(ansmin, ansmax)\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(longestMonotonicSubarray([1,4,3,3,2]), 2, \"Test 1 Error!\");\nassert.deepEqual(longestMonotonicSubarray([3,3,3,3]), 1, \"Test 2 Error!\");\nassert.deepEqual(longestMonotonicSubarray([3,2,1]), 3, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestMonotonicSubarray = function(nums) {",
        "function_name": "longestMonotonicSubarray",
        "difficulty_level": "Easy",
        "time": "20240407"
    },
    {
        "id": "3106",
        "prompt_base": "\"\"\"\n给你一个字符串 s 和一个整数 k 。定义函数 distance(s_1, s_2) ，用于衡量两个长度为 n 的字符串 s_1 和 s_2 之间的距离，即：\n字符 'a' 到 'z' 按 循环 顺序排列，对于区间 [0, n - 1] 中的 i ，计算所有「 s_1[i] 和 s_2[i] 之间 最小距离」的 和 。例如，distance(\\\"ab\\\", \\\"cd\\\") == 4 ，且 distance(\\\"a\\\", \\\"z\\\") == 1 。\n你可以对字符串 s 执行 任意次 操作。在每次操作中，可以将 s 中的一个字母 改变 为 任意 其他小写英文字母。\n返回一个字符串，表示在执行一些操作后你可以得到的 字典序最小 的字符串 t ，且满足 distance(s, t) <= k 。\n示例 1：\n输入s = \"zbbz\", k = 3\n输出：\"aaaz\"示例 2：\n输入s = \"xaxcd\", k = 4\n输出：\"aawcd\"\n\n提示：\n1 <= s.length <= 100\n0 <= k <= 2000\ns 只包含小写英文字母。\n\"\"\"\n\n/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nvar getSmallestString = function(s, k) {",
        "prompt_chat": "给你一个字符串 s 和一个整数 k 。定义函数 distance(s_1, s_2) ，用于衡量两个长度为 n 的字符串 s_1 和 s_2 之间的距离，即：\n字符 'a' 到 'z' 按 循环 顺序排列，对于区间 [0, n - 1] 中的 i ，计算所有「 s_1[i] 和 s_2[i] 之间 最小距离」的 和 。例如，distance(\\\"ab\\\", \\\"cd\\\") == 4 ，且 distance(\\\"a\\\", \\\"z\\\") == 1 。\n你可以对字符串 s 执行 任意次 操作。在每次操作中，可以将 s 中的一个字母 改变 为 任意 其他小写英文字母。\n返回一个字符串，表示在执行一些操作后你可以得到的 字典序最小 的字符串 t ，且满足 distance(s, t) <= k 。\n示例 1：\n输入s = \"zbbz\", k = 3\n输出：\"aaaz\"示例 2：\n输入s = \"xaxcd\", k = 4\n输出：\"aawcd\"\n\n提示：\n1 <= s.length <= 100\n0 <= k <= 2000\ns 只包含小写英文字母。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nvar getSmallestString = function(s, k) {\n```",
        "solution": "/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nlet getSmallestString = function (s, k) {\n    let arr = []; //空数组，用于存放变换后得值\n    const numA = 97;\n    for (let i = 0; i < s.length; i++) {\n        let el = s[i];\n        const d = el.charCodeAt() - numA; //计算当前元素与'a'得距离\n        let distance = d > 13 ? 26 - d : d; //循环字符串，需要从两端判断看那边距离短，真实得距离是两端计算后的最小值\n        if (k > 0) {\n            if (distance <= k) {\n                arr.push(\"a\");\n                k = k - distance;\n            } else {\n                const ch1 = el.charCodeAt() + k;\n                const ch2 = el.charCodeAt() - k;\n                const minNum = Math.min(ch1, ch2);\n                arr.push(String.fromCharCode(minNum));\n                k = 0;\n            }\n        } else {\n            arr.push(el);\n        }\n    }\n    return arr.join(\"\");\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(getSmallestString(\"zbbz\",3), \"aaaz\", \"Test 1 Error!\");\nassert.deepEqual(getSmallestString(\"xaxcd\",4), \"aawcd\", \"Test 2 Error!\");\nassert.deepEqual(getSmallestString(\"lol\",0), \"lol\", \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nvar getSmallestString = function(s, k) {",
        "function_name": "getSmallestString",
        "difficulty_level": "Middle",
        "time": "20240407"
    },
    {
        "id": "3107",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 和一个 非负 整数 k 。一次操作中，你可以选择任一元素 加 1 或者减 1 。\n请你返回将 nums 中位数 变为 k 所需要的 最少 操作次数。\n一个数组的中位数指的是数组按非递减顺序排序后最中间的元素。如果数组长度为偶数，我们选择中间两个数的较大值为中位数。\n示例 1：\n输入nums = [2,5,6,8,5], k = 4\n输出：2示例 2：\n输入nums = [2,5,6,8,5], k = 7\n输出：3\n\n提示：\n1 <= nums.length <= 2 * 10^5\n1 <= nums[i] <= 10^9\n1 <= k <= 10^9\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperationsToMakeMedianK = function(nums, k) {",
        "prompt_chat": "给你一个整数数组 nums 和一个 非负 整数 k 。一次操作中，你可以选择任一元素 加 1 或者减 1 。\n请你返回将 nums 中位数 变为 k 所需要的 最少 操作次数。\n一个数组的中位数指的是数组按非递减顺序排序后最中间的元素。如果数组长度为偶数，我们选择中间两个数的较大值为中位数。\n示例 1：\n输入nums = [2,5,6,8,5], k = 4\n输出：2示例 2：\n输入nums = [2,5,6,8,5], k = 7\n输出：3\n\n提示：\n1 <= nums.length <= 2 * 10^5\n1 <= nums[i] <= 10^9\n1 <= k <= 10^9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperationsToMakeMedianK = function(nums, k) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minOperationsToMakeMedianK([2,5,6,8,5],4), 2, \"Test 1 Error!\");\nassert.deepEqual(minOperationsToMakeMedianK([2,5,6,8,5],7), 3, \"Test 2 Error!\");\nassert.deepEqual(minOperationsToMakeMedianK([1,2,3,4,5,6],4), 0, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperationsToMakeMedianK = function(nums, k) {",
        "function_name": "minOperationsToMakeMedianK",
        "difficulty_level": "Middle",
        "time": "20240407"
    },
    {
        "id": "3108",
        "prompt_base": "\"\"\"\n给你一个 n 个节点的带权无向图，节点编号为 0 到 n - 1 。给你一个整数 n 和一个数组 edges ，其中 edges[i] = [u_i, v_i, w_i] 表示节点 u_i 和 v_i 之间有一条权值为 w_i 的无向边。\n在图中，一趟旅途包含一系列节点和边。旅途开始和结束点都是图中的节点，且图中存在连接旅途中相邻节点的边。注意，一趟旅途可能访问同一条边或者同一个节点多次。\n如果旅途开始于节点 u ，结束于节点 v ，我们定义这一趟旅途的 代价 是经过的边权按位与 AND 的结果。换句话说，如果经过的边对应的边权为 w_0, w_1, w_2, ..., w_k ，那么代价为w_0 & w_1 & w_2 & ... & w_k ，其中 & 表示按位与 AND 操作。\n给你一个二维数组 query ，其中 query[i] = [s_i, t_i] 。对于每一个查询，你需要找出从节点开始 s_i ，在节点 t_i 处结束的旅途的最小代价。如果不存在这样的旅途，答案为 -1 。\n返回数组 answer ，其中 answer[i] 表示对于查询 i 的 最小 旅途代价。\n示例 1：\n输入n = 5, edges = [[0,1,7],[1,3,7],[1,2,1]], query = [[0,3],[3,4]]\n输出：[1,-1]示例 2：\n输入n = 3, edges = [[0,2,7],[0,1,15],[1,2,6],[1,2,1]], query = [[1,2]]\n输出：[0]\n\n提示：\n1 <= n <= 10^5\n0 <= edges.length <= 10^5\nedges[i].length == 3\n0 <= u_i, v_i <= n - 1\nu_i != v_i\n0 <= w_i <= 10^5\n1 <= query.length <= 10^5\nquery[i].length == 2\n0 <= s_i, t_i <= n - 1\n\"\"\"\n\n/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number[][]} query\n * @return {number[]}\n */\nvar minimumCost = function(n, edges, query) {",
        "prompt_chat": "给你一个 n 个节点的带权无向图，节点编号为 0 到 n - 1 。给你一个整数 n 和一个数组 edges ，其中 edges[i] = [u_i, v_i, w_i] 表示节点 u_i 和 v_i 之间有一条权值为 w_i 的无向边。\n在图中，一趟旅途包含一系列节点和边。旅途开始和结束点都是图中的节点，且图中存在连接旅途中相邻节点的边。注意，一趟旅途可能访问同一条边或者同一个节点多次。\n如果旅途开始于节点 u ，结束于节点 v ，我们定义这一趟旅途的 代价 是经过的边权按位与 AND 的结果。换句话说，如果经过的边对应的边权为 w_0, w_1, w_2, ..., w_k ，那么代价为w_0 & w_1 & w_2 & ... & w_k ，其中 & 表示按位与 AND 操作。\n给你一个二维数组 query ，其中 query[i] = [s_i, t_i] 。对于每一个查询，你需要找出从节点开始 s_i ，在节点 t_i 处结束的旅途的最小代价。如果不存在这样的旅途，答案为 -1 。\n返回数组 answer ，其中 answer[i] 表示对于查询 i 的 最小 旅途代价。\n示例 1：\n输入n = 5, edges = [[0,1,7],[1,3,7],[1,2,1]], query = [[0,3],[3,4]]\n输出：[1,-1]示例 2：\n输入n = 3, edges = [[0,2,7],[0,1,15],[1,2,6],[1,2,1]], query = [[1,2]]\n输出：[0]\n\n提示：\n1 <= n <= 10^5\n0 <= edges.length <= 10^5\nedges[i].length == 3\n0 <= u_i, v_i <= n - 1\nu_i != v_i\n0 <= w_i <= 10^5\n1 <= query.length <= 10^5\nquery[i].length == 2\n0 <= s_i, t_i <= n - 1\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number[][]} query\n * @return {number[]}\n */\nvar minimumCost = function(n, edges, query) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumCost(5,[[0,1,7],[1,3,7],[1,2,1]],[[0,3],[3,4]]), [1,-1], \"Test 1 Error!\");\nassert.deepEqual(minimumCost(3,[[0,2,7],[0,1,15],[1,2,6],[1,2,1]],[[1,2]]), [0], \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number[][]} query\n * @return {number[]}\n */\nvar minimumCost = function(n, edges, query) {",
        "function_name": "minimumCost",
        "difficulty_level": "Hard",
        "time": "20240407"
    },
    {
        "id": "3110",
        "prompt_base": "\"\"\"\n给你一个字符串 s 。一个字符串的 分数 定义为相邻字符 ASCII 码差值绝对值的和。请你返回 s 的 分数 。\n示例 1：\n输入s = \"hello\"\n输出：13示例 2：\n输入s = \"zaz\"\n输出：50\n\n提示：\n2 <= s.length <= 100\ns 只包含小写英文字母。\n\"\"\"\n\n/**\n * @param {string} s\n * @return {number}\n */\nvar scoreOfString = function(s) {",
        "prompt_chat": "给你一个字符串 s 。一个字符串的 分数 定义为相邻字符 ASCII 码差值绝对值的和。请你返回 s 的 分数 。\n示例 1：\n输入s = \"hello\"\n输出：13示例 2：\n输入s = \"zaz\"\n输出：50\n\n提示：\n2 <= s.length <= 100\ns 只包含小写英文字母。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar scoreOfString = function(s) {\n```",
        "solution": "/**\n * @param {string} s\n * @return {number}\n */\nvar scoreOfString = function(s) {\n    let pre = s.charCodeAt(0), ans = 0 \n    for(let i = 1; i < s.length; i++){\n       ans += Math.abs(s.charCodeAt(i) - pre)\n       pre = s.charCodeAt(i)\n    } \n    return ans \n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(scoreOfString(\"hello\"), 13, \"Test 1 Error!\");\nassert.deepEqual(scoreOfString(\"zaz\"), 50, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} s\n * @return {number}\n */\nvar scoreOfString = function(s) {",
        "function_name": "scoreOfString",
        "difficulty_level": "Easy",
        "time": "20240413"
    },
    {
        "id": "3111",
        "prompt_base": "\"\"\"\n给你一个二维整数数组 point ，其中 points[i] = [x_i, y_i] 表示二维平面内的一个点。同时给你一个整数 w 。你需要用矩形 覆盖所有 点。\n每个矩形的左下角在某个点 (x_1, 0) 处，且右上角在某个点 (x_2, y_2) 处，其中 x_1 <= x_2 且 y_2 >= 0 ，同时对于每个矩形都 必须 满足 x_2 - x_1 <= w 。\n如果一个点在矩形内或者在边上，我们说这个点被矩形覆盖了。\n请你在确保每个点都 至少 被一个矩形覆盖的前提下，最少 需要多少个矩形。\n注意：一个点可以被多个矩形覆盖。\n示例 1：\n输入points = [[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]], w = 1\n输出：2示例 2：\n输入points = [[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], w = 2\n输出：3\n\n提示：\n1 <= points.length <= 10^5\npoints[i].length == 2\n0 <= x_i == points[i][0] <= 10^9\n0 <= y_i == points[i][1] <= 10^9\n0 <= w <= 10^9\n所有点坐标 (x_i, y_i) 互不相同。\n\"\"\"\n\n/**\n* @param {number[][]} points\n * @param {number} w\n * @return {number}\n */\nvar minRectanglesToCoverPoints = function(points, w) {",
        "prompt_chat": "给你一个二维整数数组 point ，其中 points[i] = [x_i, y_i] 表示二维平面内的一个点。同时给你一个整数 w 。你需要用矩形 覆盖所有 点。\n每个矩形的左下角在某个点 (x_1, 0) 处，且右上角在某个点 (x_2, y_2) 处，其中 x_1 <= x_2 且 y_2 >= 0 ，同时对于每个矩形都 必须 满足 x_2 - x_1 <= w 。\n如果一个点在矩形内或者在边上，我们说这个点被矩形覆盖了。\n请你在确保每个点都 至少 被一个矩形覆盖的前提下，最少 需要多少个矩形。\n注意：一个点可以被多个矩形覆盖。\n示例 1：\n输入points = [[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]], w = 1\n输出：2示例 2：\n输入points = [[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], w = 2\n输出：3\n\n提示：\n1 <= points.length <= 10^5\npoints[i].length == 2\n0 <= x_i == points[i][0] <= 10^9\n0 <= y_i == points[i][1] <= 10^9\n0 <= w <= 10^9\n所有点坐标 (x_i, y_i) 互不相同。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n* @param {number[][]} points\n * @param {number} w\n * @return {number}\n */\nvar minRectanglesToCoverPoints = function(points, w) {\n```",
        "solution": "/**\n * @param {number[][]} points\n * @param {number} w\n * @return {number}\n */\nvar minRectanglesToCoverPoints = function(points, w) {\n    points.sort((a,b) => a[0] - b[0])\n    let ans = 1, start = points[0][0]\n    for(let [a] of points){\n        if(a - start <= w) continue\n        else {\n            start = a \n            ans++\n        }\n    }\n    return ans \n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minRectanglesToCoverPoints([[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]],1), 2, \"Test 1 Error!\");\nassert.deepEqual(minRectanglesToCoverPoints([[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]],2), 3, \"Test 2 Error!\");\nassert.deepEqual(minRectanglesToCoverPoints([[2,3],[1,2]],0), 2, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n* @param {number[][]} points\n * @param {number} w\n * @return {number}\n */\nvar minRectanglesToCoverPoints = function(points, w) {",
        "function_name": "minRectanglesToCoverPoints",
        "difficulty_level": "Middle",
        "time": "20240413"
    },
    {
        "id": "3112",
        "prompt_base": "\"\"\"\n给你一个二维数组 edges 表示一个 n 个点的无向图，其中 edges[i] = [u_i, v_i, length_i] 表示节点 u_i 和节点 v_i 之间有一条需要 length_i 单位时间通过的无向边。\n同时给你一个数组 disappear ，其中 disappear[i] 表示节点 i 从图中消失的时间点，在那一刻及以后，你无法再访问这个节点。\n注意，图有可能一开始是不连通的，两个节点之间也可能有多条边。\n请你返回数组 answer ，answer[i] 表示从节点 0 到节点 i 需要的 最少 单位时间。如果从节点 0 出发 无法 到达节点 i ，那么 answer[i] 为 -1 。\n示例 1：\n输入n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]\n输出：[0,-1,4]示例 2：\n输入n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]\n输出：[0,2,3]\n\n提示：\n1 <= n <= 5 * 10^4\n0 <= edges.length <= 10^5\nedges[i] == [u_i, v_i, length_i]\n0 <= u_i, v_i <= n - 1\n1 <= length_i <= 10^5\ndisappear.length == n\n1 <= disappear[i] <= 10^5\n\"\"\"\n\n/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number[]} disappear\n * @return {number[]}\n */\nvar minimumTime = function(n, edges, disappear) {",
        "prompt_chat": "给你一个二维数组 edges 表示一个 n 个点的无向图，其中 edges[i] = [u_i, v_i, length_i] 表示节点 u_i 和节点 v_i 之间有一条需要 length_i 单位时间通过的无向边。\n同时给你一个数组 disappear ，其中 disappear[i] 表示节点 i 从图中消失的时间点，在那一刻及以后，你无法再访问这个节点。\n注意，图有可能一开始是不连通的，两个节点之间也可能有多条边。\n请你返回数组 answer ，answer[i] 表示从节点 0 到节点 i 需要的 最少 单位时间。如果从节点 0 出发 无法 到达节点 i ，那么 answer[i] 为 -1 。\n示例 1：\n输入n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]\n输出：[0,-1,4]示例 2：\n输入n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]\n输出：[0,2,3]\n\n提示：\n1 <= n <= 5 * 10^4\n0 <= edges.length <= 10^5\nedges[i] == [u_i, v_i, length_i]\n0 <= u_i, v_i <= n - 1\n1 <= length_i <= 10^5\ndisappear.length == n\n1 <= disappear[i] <= 10^5\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number[]} disappear\n * @return {number[]}\n */\nvar minimumTime = function(n, edges, disappear) {\n```",
        "solution": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number[]} disappear\n * @return {number[]}\n */\nvar minimumTime = function (n, edges, disappear) {\n  let map = Array.from({length: n}, () => []);\n  let ans = new Array(n).fill(-1);\n  ans[0] = 0;\n  for (const [a, b, c] of edges) {\n    map[a].push([b, c]);\n    map[b].push([a, c]);\n  }\n  const compare = (a, b) => a[0] - b[0];\n  const pq = new PriorityQueue({compare});\n  pq.enqueue([0, 0]);\n  while (!pq.isEmpty()) {\n    const [len, to] = pq.dequeue();\n    if (len > ans[to]) continue;\n    for (const [a, b] of map[to]) {\n      const t = len + b;\n      if (t < disappear[a] && (ans[a] < 0 || t < ans[a])) {\n        ans[a] = t;\n        pq.enqueue([t, a]);\n      }\n    }\n  }\n  return ans;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumTime(3,[[0,1,2],[1,2,1],[0,2,4]],[1,1,5]), [0,-1,4], \"Test 1 Error!\");\nassert.deepEqual(minimumTime(3,[[0,1,2],[1,2,1],[0,2,4]],[1,3,5]), [0,2,3], \"Test 2 Error!\");\nassert.deepEqual(minimumTime(2,[[0,1,1]],[1,1]), [0,-1], \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number[]} disappear\n * @return {number[]}\n */\nvar minimumTime = function(n, edges, disappear) {",
        "function_name": "minimumTime",
        "difficulty_level": "Middle",
        "time": "20240413"
    },
    {
        "id": "3113",
        "prompt_base": "\"\"\"\n给你一个 正 整数数组 nums 。\n请你求出 nums 中有多少个子数组，满足子数组中 第一个 和 最后一个 元素都是这个子数组中的 最大 值。\n示例 1：\n输入nums = [1,4,3,3,2]\n输出：6示例 2：\n输入nums = [3,3,3]\n输出：6\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numberOfSubarrays = function(nums) {",
        "prompt_chat": "给你一个 正 整数数组 nums 。\n请你求出 nums 中有多少个子数组，满足子数组中 第一个 和 最后一个 元素都是这个子数组中的 最大 值。\n示例 1：\n输入nums = [1,4,3,3,2]\n输出：6示例 2：\n输入nums = [3,3,3]\n输出：6\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numberOfSubarrays = function(nums) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numberOfSubarrays = function(nums) {\n  let stack = [[Infinity, 1]]\n  let ans = 0\n  for (let item of nums) {\n    let t = stack.at(-1)\n    while (t[0] < item) {\n      stack.pop()\n      t = stack.at(-1)\n    }\n    if (item < t[0]) stack.push([item, 1])\n    else t[1]++\n    ans += stack.at(-1)[1]\n  }\n  return ans\n}",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(numberOfSubarrays([1,4,3,3,2]), 6, \"Test 1 Error!\");\nassert.deepEqual(numberOfSubarrays([3,3,3]), 6, \"Test 2 Error!\");\nassert.deepEqual(numberOfSubarrays([1]), 1, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numberOfSubarrays = function(nums) {",
        "function_name": "numberOfSubarrays",
        "difficulty_level": "Hard",
        "time": "20240413"
    },
    {
        "id": "3114",
        "prompt_base": "\"\"\"\n给你一个字符串 s，表示一个 12 小时制的时间格式，其中一些数字（可能没有）被 \"?\" 替换。\n12 小时制时间格式为 \"HH:MM\" ，其中 HH 的取值范围为 00 至 11，MM 的取值范围为 00 至 59。最早的时间为 00:00，最晚的时间为 11:59。\n你需要将 s 中的 所有 \"?\" 字符替换为数字，使得结果字符串代表的时间是一个 有效 的 12 小时制时间，并且是可能的 最晚 时间。\n返回结果字符串。\n示例 1：\n输入s = \"1?:?4\"\n输出：\"11:54\"示例 2：\n输入s = \"0?:5?\"\n输出：\"09:59\"\n\n提示：\ns.length == 5\ns[2] 是字符 \":\"\n除 s[2] 外，其他字符都是数字或 \"?\"\n输入保证在替换 \"?\" 字符后至少存在一个介于 \"00:00\" 和 \"11:59\" 之间的时间。\n\"\"\"\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar findLatestTime = function(s) {",
        "prompt_chat": "给你一个字符串 s，表示一个 12 小时制的时间格式，其中一些数字（可能没有）被 \"?\" 替换。\n12 小时制时间格式为 \"HH:MM\" ，其中 HH 的取值范围为 00 至 11，MM 的取值范围为 00 至 59。最早的时间为 00:00，最晚的时间为 11:59。\n你需要将 s 中的 所有 \"?\" 字符替换为数字，使得结果字符串代表的时间是一个 有效 的 12 小时制时间，并且是可能的 最晚 时间。\n返回结果字符串。\n示例 1：\n输入s = \"1?:?4\"\n输出：\"11:54\"示例 2：\n输入s = \"0?:5?\"\n输出：\"09:59\"\n\n提示：\ns.length == 5\ns[2] 是字符 \":\"\n除 s[2] 外，其他字符都是数字或 \"?\"\n输入保证在替换 \"?\" 字符后至少存在一个介于 \"00:00\" 和 \"11:59\" 之间的时间。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar findLatestTime = function(s) {\n```",
        "solution": "/**\n * @param {string} s\n * @return {string}\n */\nvar findLatestTime = function(s) {\n    for(let h = 11; h >= 0; h--){\n        x:for(let m = 59; m >= 0; m--){\n           let t = `${String(h).padStart(2,0)}:${String(m).padStart(2,0)}`\n           for(let i = 0; i < 5; i++)  if(t[i] !== s[i] && s[i] !== '?') continue x  \n           return t \n        }\n    }\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(findLatestTime(\"1?:?4\"), \"11:54\", \"Test 1 Error!\");\nassert.deepEqual(findLatestTime(\"0?:5?\"), \"09:59\", \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} s\n * @return {string}\n */\nvar findLatestTime = function(s) {",
        "function_name": "findLatestTime",
        "difficulty_level": "Easy",
        "time": "20240414"
    },
    {
        "id": "3115",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums。\n返回两个（不一定不同的）质数在 nums 中 下标 的 最大距离。\n示例 1：\n输入nums = [4,2,9,5,3]\n输出：3示例 2：\n输入nums = [4,8,2,8]\n输出：0\n\n提示：\n1 <= nums.length <= 3 * 10^5\n1 <= nums[i] <= 100\n输入保证 nums 中至少有一个质数。\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumPrimeDifference = function(nums) {",
        "prompt_chat": "给你一个整数数组 nums。\n返回两个（不一定不同的）质数在 nums 中 下标 的 最大距离。\n示例 1：\n输入nums = [4,2,9,5,3]\n输出：3示例 2：\n输入nums = [4,8,2,8]\n输出：0\n\n提示：\n1 <= nums.length <= 3 * 10^5\n1 <= nums[i] <= 100\n输入保证 nums 中至少有一个质数。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumPrimeDifference = function(nums) {\n```",
        "solution": "var maximumPrimeDifference = function(nums) {\n    const primes = new Set([\n        2, 3, 5, 7, 11,\n        13, 17, 19, 23, 29,\n        31, 37, 41, 43, 47,\n        53, 59, 61, 67, 71,\n        73, 79, 83, 89, 97\n    ]);\n\n    const n = nums.length;\n    let first = -1, ans = 0;\n    for (let i = 0; i < n; ++i) {\n        if (primes.has(nums[i])) {\n            if (first !== -1) {\n                ans = Math.max(ans, i - first);\n            } else {\n                first = i;\n            }\n        }\n    }\n    return ans;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maximumPrimeDifference([4,2,9,5,3]), 3, \"Test 1 Error!\");\nassert.deepEqual(maximumPrimeDifference([4,8,2,8]), 0, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumPrimeDifference = function(nums) {",
        "function_name": "maximumPrimeDifference",
        "difficulty_level": "Middle",
        "time": "20240414"
    },
    {
        "id": "3116",
        "prompt_base": "\"\"\"\n给你一个整数数组 coins 表示不同面额的硬币，另给你一个整数 k 。你有无限量的每种面额的硬币。但是，你 不能 组合使用不同面额的硬币。返回使用这些硬币能制造的 第 k^th 小 金额。\n示例 1：\n输入coins = [3,6,9], k = 3\n输出：9示例 2：\n输入coins = [5,2], k = 7\n输出：12\n\n提示：\n1 <= coins.length <= 15\n1 <= coins[i] <= 25\n1 <= k <= 2 * 10^9\ncoins 包含两两不同的整数。\n\"\"\"\n\n/**\n * @param {number[]} coins\n * @param {number} k\n * @return {number}\n */\nvar findKthSmallest = function(coins, k) {",
        "prompt_chat": "给你一个整数数组 coins 表示不同面额的硬币，另给你一个整数 k 。你有无限量的每种面额的硬币。但是，你 不能 组合使用不同面额的硬币。返回使用这些硬币能制造的 第 k^th 小 金额。\n示例 1：\n输入coins = [3,6,9], k = 3\n输出：9示例 2：\n输入coins = [5,2], k = 7\n输出：12\n\n提示：\n1 <= coins.length <= 15\n1 <= coins[i] <= 25\n1 <= k <= 2 * 10^9\ncoins 包含两两不同的整数。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} coins\n * @param {number} k\n * @return {number}\n */\nvar findKthSmallest = function(coins, k) {\n```",
        "solution": "/**\n * @param {number[]} coins\n * @param {number} k\n * @return {number}\n */\nvar findKthSmallest = function(coins, k) {\n    // 对硬币数组进行升序排序\n    coins.sort((a, b) => a - b);\n    // 最小金额的下界\n    let left = 1;\n    // 最大金额的上界\n    let right = coins[coins.length - 1] * k;\n\n    while (left < right) {\n        // 计算中间金额\n        const mid = Math.floor((left + right) / 2);\n        // 计算小于等于中间金额的金额数量\n        const count = countCoins(coins, mid);\n\n        if (count < k) {\n            // 第 k 小的金额在右半部分\n            left = mid + 1;\n        } else {\n            // 第 k 小的金额在左半部分或者就是当前中间金额\n            right = mid;\n        }\n    }\n\n    // 返回第 k 小的金额\n    return left;\n};\n\nvar countCoins = function(coins, amount) {\n    // 金额数量计数器\n    let count = 0;\n\n    // 使用容斥原理计算小于等于 amount 的金额数量\n    for (let i = 1; i < (1 << coins.length); i++) {\n        // 最小公倍数\n        let lcm = 1;\n        // 二进制中 1 的个数\n        let bitCount = 0;\n\n        for (let j = 0; j < coins.length; j++) {\n            if ((i & (1 << j)) !== 0) {\n                // 计算所选硬币的最小公倍数\n                lcm = getLCM(lcm, coins[j]);\n                // 统计二进制位 1 的个数\n                bitCount++;\n            }\n        }\n\n        // 计算小于等于 amount 的 lcm 数量\n        const amountCount = Math.floor(amount / lcm);\n        // 根据二进制位 1 的个数确定计算的正负符号\n        count += bitCount % 2 === 1 ? amountCount : -amountCount;\n    }\n\n    // 返回小于等于 amount 的金额数量\n    return count;\n};\n\n// 计算最小公倍数\nvar getLCM = function(a, b) {\n    // 使用辗转相除法计算最大公约数，再通过公式计算最小公倍数\n    return (a * b) / getGCD(a, b);\n};\n\n// 计算最大公约数\nvar getGCD = function(a, b) {\n    // 辗转相除法的终止条件\n    if (b === 0) {\n        return a;\n    }\n    // 递归计算最大公约数\n    return getGCD(b, a % b);\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(findKthSmallest([3,6,9],3), 9, \"Test 1 Error!\");\nassert.deepEqual(findKthSmallest([5,2],7), 12, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} coins\n * @param {number} k\n * @return {number}\n */\nvar findKthSmallest = function(coins, k) {",
        "function_name": "findKthSmallest",
        "difficulty_level": "Hard",
        "time": "20240414"
    },
    {
        "id": "3117",
        "prompt_base": "\"\"\"\n给你两个数组 nums 和 andValues，长度分别为 n 和 m。\n示例 1：\n输入nums = [1,4,3,3,2], andValues = [0,3,3,2]\n输出：12示例 2：\n输入nums = [2,3,5,7,7,7,5], andValues = [0,7,5]\n输出：17\n\n提示：\n1 <= n == nums.length <= 10^4\n1 <= m == andValues.length <= min(n, 10)\n1 <= nums[i] < 10^5\n0 <= andValues[j] < 10^5\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number[]} andValues\n * @return {number}\n */\nvar minimumValueSum = function(nums, andValues) {",
        "prompt_chat": "给你两个数组 nums 和 andValues，长度分别为 n 和 m。\n示例 1：\n输入nums = [1,4,3,3,2], andValues = [0,3,3,2]\n输出：12示例 2：\n输入nums = [2,3,5,7,7,7,5], andValues = [0,7,5]\n输出：17\n\n提示：\n1 <= n == nums.length <= 10^4\n1 <= m == andValues.length <= min(n, 10)\n1 <= nums[i] < 10^5\n0 <= andValues[j] < 10^5\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number[]} andValues\n * @return {number}\n */\nvar minimumValueSum = function(nums, andValues) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumValueSum([1,4,3,3,2],[0,3,3,2]), 12, \"Test 1 Error!\");\nassert.deepEqual(minimumValueSum([2,3,5,7,7,7,5],[0,7,5]), 17, \"Test 2 Error!\");\nassert.deepEqual(minimumValueSum([1,2,3,4],[2]), -1, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number[]} andValues\n * @return {number}\n */\nvar minimumValueSum = function(nums, andValues) {",
        "function_name": "minimumValueSum",
        "difficulty_level": "Hard",
        "time": "20240414"
    },
    {
        "id": "3120",
        "prompt_base": "\"\"\"\n给你一个字符串 word。如果 word 中同时存在某个字母的小写形式和大写形式，则称这个字母为 特殊字母。\n返回 word 中 特殊字母 的数量。\n示例 1：\n输入word = \"aaAbcBC\"\n输出：3示例 2：\n输入word = \"abc\"\n输出：0\n\n提示：\n1 <= word.length <= 50\nword 仅由小写和大写英文字母组成。\n\"\"\"\n\n/**\n * @param {string} word\n * @return {number}\n */\nvar numberOfSpecialChars = function(word) {",
        "prompt_chat": "给你一个字符串 word。如果 word 中同时存在某个字母的小写形式和大写形式，则称这个字母为 特殊字母。\n返回 word 中 特殊字母 的数量。\n示例 1：\n输入word = \"aaAbcBC\"\n输出：3示例 2：\n输入word = \"abc\"\n输出：0\n\n提示：\n1 <= word.length <= 50\nword 仅由小写和大写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} word\n * @return {number}\n */\nvar numberOfSpecialChars = function(word) {\n```",
        "solution": "/**\n * @param {string} word\n * @return {number}\n */\nvar numberOfSpecialChars = function(word) {\n    const ans = new Set(), set = new Set();\n    for (const w of word) {\n        let wNum = w.charCodeAt();\n        if (set.has(wNum < 97 ? wNum + 32 : wNum - 32)) {\n            ans.add(wNum < 97 ? wNum + 32 : wNum);\n        } else {\n            set.add(wNum);\n        }\n    }\n    return ans.size;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(numberOfSpecialChars(\"aaAbcBC\"), 3, \"Test 1 Error!\");\nassert.deepEqual(numberOfSpecialChars(\"abc\"), 0, \"Test 2 Error!\");\nassert.deepEqual(numberOfSpecialChars(\"abBCab\"), 1, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} word\n * @return {number}\n */\nvar numberOfSpecialChars = function(word) {",
        "function_name": "numberOfSpecialChars",
        "difficulty_level": "Easy",
        "time": "20240421"
    },
    {
        "id": "3121",
        "prompt_base": "\"\"\"\n给你一个字符串 word。如果 word 中同时出现某个字母 c 的小写形式和大写形式，并且 每个 小写形式的 c 都出现在第一个大写形式的 c 之前，则称字母 c 是一个 特殊字母 。\n返回 word 中 特殊字母 的数量。\n示例 1：\n输入word = \"aaAbcBC\"\n输出：3示例 2：\n输入word = \"abc\"\n输出：0\n\n提示：\n1 <= word.length <= 2 * 10^5\nword 仅由小写和大写英文字母组成。\n\"\"\"\n\n/**\n * @param {string} word\n * @return {number}\n */\nvar numberOfSpecialChars = function(word) {",
        "prompt_chat": "给你一个字符串 word。如果 word 中同时出现某个字母 c 的小写形式和大写形式，并且 每个 小写形式的 c 都出现在第一个大写形式的 c 之前，则称字母 c 是一个 特殊字母 。\n返回 word 中 特殊字母 的数量。\n示例 1：\n输入word = \"aaAbcBC\"\n输出：3示例 2：\n输入word = \"abc\"\n输出：0\n\n提示：\n1 <= word.length <= 2 * 10^5\nword 仅由小写和大写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} word\n * @return {number}\n */\nvar numberOfSpecialChars = function(word) {\n```",
        "solution": "/**\n * @param {string} word\n * @return {number}\n */\nvar numberOfSpecialChars = function(word) {\n    const ans = new Set(), set = new Set(), delSet = new Set(), upSet = new Set();\n    for (const w of word) {\n        let wNum = w.charCodeAt();\n        if (set.has(wNum + 32) && !upSet.has(wNum)) { // 加过b后出现了B,且且前面没有出现过B\n            ans.add(wNum);\n        } else if (wNum >= 97) { // 小写字母\n            if (ans.has(wNum - 32)) { // 小写在大写后面，一开始符合后面打破规则的需要去除\n                delSet.add(wNum);\n            } else {\n                set.add(wNum);\n            }\n        }\n        upSet.add(wNum);\n    }\n    return ans.size - delSet.size;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(numberOfSpecialChars(\"aaAbcBC\"), 3, \"Test 1 Error!\");\nassert.deepEqual(numberOfSpecialChars(\"abc\"), 0, \"Test 2 Error!\");\nassert.deepEqual(numberOfSpecialChars(\"AbBCab\"), 0, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} word\n * @return {number}\n */\nvar numberOfSpecialChars = function(word) {",
        "function_name": "numberOfSpecialChars",
        "difficulty_level": "Middle",
        "time": "20240421"
    },
    {
        "id": "3122",
        "prompt_base": "\"\"\"\n给你一个大小为 m x n 的二维矩形 grid 。每次 操作 中，你可以将 任一 格子的值修改为 任意 非负整数。完成所有操作后，你需要确保每个格子 grid[i][j] 的值满足：\n如果下面相邻格子存在的话，它们的值相等，也就是 grid[i][j] == grid[i + 1][j]（如果存在）。\n如果右边相邻格子存在的话，它们的值不相等，也就是 grid[i][j] != grid[i][j + 1]（如果存在）。\n请你返回需要的 最少 操作数目。\n示例 1：\n输入grid = [[1,0,2],[1,0,2]]\n输出：0示例 2：\n输入grid = [[1,1,1],[0,0,0]]\n输出：3\n\n提示：\n1 <= n, m <= 1000\n0 <= grid[i][j] <= 9\n\"\"\"\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumOperations = function(grid) {",
        "prompt_chat": "给你一个大小为 m x n 的二维矩形 grid 。每次 操作 中，你可以将 任一 格子的值修改为 任意 非负整数。完成所有操作后，你需要确保每个格子 grid[i][j] 的值满足：\n如果下面相邻格子存在的话，它们的值相等，也就是 grid[i][j] == grid[i + 1][j]（如果存在）。\n如果右边相邻格子存在的话，它们的值不相等，也就是 grid[i][j] != grid[i][j + 1]（如果存在）。\n请你返回需要的 最少 操作数目。\n示例 1：\n输入grid = [[1,0,2],[1,0,2]]\n输出：0示例 2：\n输入grid = [[1,1,1],[0,0,0]]\n输出：3\n\n提示：\n1 <= n, m <= 1000\n0 <= grid[i][j] <= 9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumOperations = function(grid) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumOperations([[1,0,2],[1,0,2]]), 0, \"Test 1 Error!\");\nassert.deepEqual(minimumOperations([[1,1,1],[0,0,0]]), 3, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumOperations = function(grid) {",
        "function_name": "minimumOperations",
        "difficulty_level": "Middle",
        "time": "20240421"
    },
    {
        "id": "3123",
        "prompt_base": "\"\"\"\n给你一个 n 个节点的无向带权图，节点编号为 0 到 n - 1 。图中总共有 m 条边，用二维数组 edges 表示，其中 edges[i] = [a_i, b_i, w_i] 表示节点 a_i 和 b_i 之间有一条边权为 w_i 的边。\n对于节点 0 为出发点，节点 n - 1 为结束点的所有最短路，你需要返回一个长度为 m 的 boolean 数组 answer ，如果 edges[i] 至少 在其中一条最短路上，那么 answer[i] 为 true ，否则 answer[i] 为 false 。\n请你返回数组 answer。\n注意，图可能不连通。\n示例 1：\n输入n = 6, edges = [[0,1,4],[0,2,1],[1,3,2],[1,4,3],[1,5,1],[2,3,1],[3,5,3],[4,5,2]]\n输出：[true,true,true,false,true,true,true,false]示例 2：\n输入n = 4, edges = [[2,0,1],[0,1,1],[0,3,4],[3,2,2]]\n输出：[true,false,false,true]\n\n提示：\n2 <= n <= 5 * 10^4\nm == edges.length\n1 <= m <= min(5 * 10^4, n * (n - 1) / 2)\n0 <= a_i, b_i < n\na_i != b_i\n1 <= w_i <= 10^5\n图中没有重边。\n\"\"\"\n\n/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {boolean[]}\n */\nvar findAnswer = function(n, edges) {",
        "prompt_chat": "给你一个 n 个节点的无向带权图，节点编号为 0 到 n - 1 。图中总共有 m 条边，用二维数组 edges 表示，其中 edges[i] = [a_i, b_i, w_i] 表示节点 a_i 和 b_i 之间有一条边权为 w_i 的边。\n对于节点 0 为出发点，节点 n - 1 为结束点的所有最短路，你需要返回一个长度为 m 的 boolean 数组 answer ，如果 edges[i] 至少 在其中一条最短路上，那么 answer[i] 为 true ，否则 answer[i] 为 false 。\n请你返回数组 answer。\n注意，图可能不连通。\n示例 1：\n输入n = 6, edges = [[0,1,4],[0,2,1],[1,3,2],[1,4,3],[1,5,1],[2,3,1],[3,5,3],[4,5,2]]\n输出：[true,true,true,false,true,true,true,false]示例 2：\n输入n = 4, edges = [[2,0,1],[0,1,1],[0,3,4],[3,2,2]]\n输出：[true,false,false,true]\n\n提示：\n2 <= n <= 5 * 10^4\nm == edges.length\n1 <= m <= min(5 * 10^4, n * (n - 1) / 2)\n0 <= a_i, b_i < n\na_i != b_i\n1 <= w_i <= 10^5\n图中没有重边。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {boolean[]}\n */\nvar findAnswer = function(n, edges) {\n```",
        "solution": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {boolean[]}\n */\n\n// 计算从start出发到各节点的最短路径\nfunction dijkstra(g, start) {\n    const dis = new Array(g.length).fill(Infinity)\n    dis[start] = 0\n    // https://github.com/datastructures-js/priority-queue/blob/v5/src/priorityQueue.js\n    const queue = new PriorityQueue({\n        compare: (a, b) => a.wight - b.wight\n    })\n    queue.enqueue({ node: start, wight: 0 })\n    while (!queue.isEmpty()) {\n        const { node, wight } = queue.dequeue()\n        if (wight > dis[node]) {\n            continue; \n        }\n        for (const [v, w] of g[node]) {\n            const nextW = wight + w;\n            if (nextW < dis[v]) {\n                dis[v] = nextW;\n                queue.enqueue({ node: v, wight: nextW })\n            } \n        }\n    }\n    return dis\n}\nvar findAnswer = function(n, edges) {\n    const g = Array.from({ length: n }, () => [])\n    for (const [a, b, w] of edges) {\n        g[a].push([b, w])\n        g[b].push([a, w])\n    }\n    const dis0 = dijkstra(g, 0)\n    // 从节点0无法到达n-1节点\n    if (dis0[n - 1] === Infinity) {\n        return new Array(edges.length).fill(false)\n    }\n    const dis1 = dijkstra(g, n - 1)\n    const ans = []\n    for (const [a, b, w] of edges) {\n        // 满足下面两个情况，代表至少一条最短路径会经过 a b。 \n        // 0 -> a -> b -> n - 1 的路径值等于 0 -> n - 1\n        // 0 -> b -> a -> n - 1 的路径值等于 0 -> n - 1\n        if (\n            (dis0[a] + dis1[b] + w === dis0[n - 1] ||\n            dis0[b] + dis1[a] + w === dis0[n - 1])\n        ) {\n            ans.push(true)\n        } else {\n            ans.push(false)\n        }\n    }\n    return ans\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(findAnswer(6,[[0,1,4],[0,2,1],[1,3,2],[1,4,3],[1,5,1],[2,3,1],[3,5,3],[4,5,2]]), [true,true,true,false,true,true,true,false], \"Test 1 Error!\");\nassert.deepEqual(findAnswer(4,[[2,0,1],[0,1,1],[0,3,4],[3,2,2]]), [true,false,false,true], \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {boolean[]}\n */\nvar findAnswer = function(n, edges) {",
        "function_name": "findAnswer",
        "difficulty_level": "Hard",
        "time": "20240421"
    },
    {
        "id": "3127",
        "prompt_base": "\"\"\"\n给你一个二维 3 x 3 的矩阵 grid ，每个格子都是一个字符，要么是 'B' ，要么是 'W' 。字符 'W' 表示白色，字符 'B' 表示黑色。\n你的任务是改变 至多一个 格子的颜色，使得矩阵中存在一个 2 x 2 颜色完全相同的正方形。\n如果可以得到一个相同颜色的 2 x 2 正方形，那么返回 true ，否则返回 false 。\n示例 1：\n输入grid = [[\"B\",\"W\",\"B\"],[\"B\",\"W\",\"W\"],[\"B\",\"W\",\"B\"]]\n输出：true示例 2：\n输入grid = [[\"B\",\"W\",\"B\"],[\"W\",\"B\",\"W\"],[\"B\",\"W\",\"B\"]]\n输出：false\n\n提示：\ngrid.length == 3\ngrid[i].length == 3\ngrid[i][j] 要么是 'W' ，要么是 'B' 。\n\"\"\"\n\n/**\n * @param {character[][]} grid\n * @return {boolean}\n */\nvar canMakeSquare = function(grid) {",
        "prompt_chat": "给你一个二维 3 x 3 的矩阵 grid ，每个格子都是一个字符，要么是 'B' ，要么是 'W' 。字符 'W' 表示白色，字符 'B' 表示黑色。\n你的任务是改变 至多一个 格子的颜色，使得矩阵中存在一个 2 x 2 颜色完全相同的正方形。\n如果可以得到一个相同颜色的 2 x 2 正方形，那么返回 true ，否则返回 false 。\n示例 1：\n输入grid = [[\"B\",\"W\",\"B\"],[\"B\",\"W\",\"W\"],[\"B\",\"W\",\"B\"]]\n输出：true示例 2：\n输入grid = [[\"B\",\"W\",\"B\"],[\"W\",\"B\",\"W\"],[\"B\",\"W\",\"B\"]]\n输出：false\n\n提示：\ngrid.length == 3\ngrid[i].length == 3\ngrid[i][j] 要么是 'W' ，要么是 'B' 。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {character[][]} grid\n * @return {boolean}\n */\nvar canMakeSquare = function(grid) {\n```",
        "solution": "/**\n * @param {character[][]} grid\n * @return {boolean}\n */\nvar canMakeSquare = function(grid) {\n    // 只要看中间的格子周围的颜色\n    let w;\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            if (i < 2 && j < 2) { // 只看左上角四个点\n                w = 0; // 统计白色\n                w += grid[i][j] === 'W' ? 1 : 0;\n                w += grid[i+1][j] === 'W' ? 1 : 0;\n                w += grid[i][j+1] === 'W' ? 1 : 0;\n                w += grid[i+1][j+1] === 'W' ? 1 : 0;\n                if (w !== 2) { // 符合\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(canMakeSquare([[\"B\",\"W\",\"B\"],[\"B\",\"W\",\"W\"],[\"B\",\"W\",\"B\"]]), true, \"Test 1 Error!\");\nassert.deepEqual(canMakeSquare([[\"B\",\"W\",\"B\"],[\"W\",\"B\",\"W\"],[\"B\",\"W\",\"B\"]]), false, \"Test 2 Error!\");\nassert.deepEqual(canMakeSquare([[\"B\",\"W\",\"B\"],[\"B\",\"W\",\"W\"],[\"B\",\"W\",\"W\"]]), true, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {character[][]} grid\n * @return {boolean}\n */\nvar canMakeSquare = function(grid) {",
        "function_name": "canMakeSquare",
        "difficulty_level": "Easy",
        "time": "20240427"
    },
    {
        "id": "3128",
        "prompt_base": "\"\"\"\n给你一个二维 boolean 矩阵 grid 。请你返回使用 grid 中的 3 个元素可以构建的 直角三角形 数目，且满足 3 个元素值 都 为 1 。\n注意：\n如果 grid 中 3 个元素满足：一个元素与另一个元素在 同一行，同时与第三个元素在 同一列 ，那么这 3 个元素称为一个 直角三角形 。这 3 个元素互相之间不需要相邻。\n示例 1：\n输入grid = [[0,1,0],[0,1,1],[0,1,0]]\n输出：2示例 2：\n输入grid = [[1,0,0,0],[0,1,0,1],[1,0,0,0]]\n输出：0\n\n提示：\n1 <= grid.length <= 1000\n1 <= grid[i].length <= 1000\n0 <= grid[i][j] <= 1\n\"\"\"\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar numberOfRightTriangles = function(grid) {",
        "prompt_chat": "给你一个二维 boolean 矩阵 grid 。请你返回使用 grid 中的 3 个元素可以构建的 直角三角形 数目，且满足 3 个元素值 都 为 1 。\n注意：\n如果 grid 中 3 个元素满足：一个元素与另一个元素在 同一行，同时与第三个元素在 同一列 ，那么这 3 个元素称为一个 直角三角形 。这 3 个元素互相之间不需要相邻。\n示例 1：\n输入grid = [[0,1,0],[0,1,1],[0,1,0]]\n输出：2示例 2：\n输入grid = [[1,0,0,0],[0,1,0,1],[1,0,0,0]]\n输出：0\n\n提示：\n1 <= grid.length <= 1000\n1 <= grid[i].length <= 1000\n0 <= grid[i][j] <= 1\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar numberOfRightTriangles = function(grid) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(numberOfRightTriangles([[0,1,0],[0,1,1],[0,1,0]]), 2, \"Test 1 Error!\");\nassert.deepEqual(numberOfRightTriangles([[1,0,0,0],[0,1,0,1],[1,0,0,0]]), 0, \"Test 2 Error!\");\nassert.deepEqual(numberOfRightTriangles([[1,0,1],[1,0,0],[1,0,0]]), 2, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar numberOfRightTriangles = function(grid) {",
        "function_name": "numberOfRightTriangles",
        "difficulty_level": "Middle",
        "time": "20240427"
    },
    {
        "id": "3129",
        "prompt_base": "\"\"\"\n给你 3 个正整数 zero ，one 和 limit 。\n一个 二进制数组 arr 如果满足以下条件，那么我们称它是 稳定的 ：\n0 在 arr 中出现次数 恰好 为 zero 。\n1 在 arr 中出现次数 恰好 为 one 。\narr 中每个长度超过 limit 的 子数组 都 同时 包含 0 和 1 。\n请你返回 稳定 二进制数组的 总 数目。\n由于答案可能很大，将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入zero = 1, one = 1, limit = 2\n输出：2示例 2：\n输入zero = 1, one = 2, limit = 1\n输出：1\n\n提示：\n1 <= zero, one, limit <= 200\n\"\"\"\n\n/**\n * @param {number} zero\n * @param {number} one\n * @param {number} limit\n * @return {number}\n */\nvar numberOfStableArrays = function(zero, one, limit) {",
        "prompt_chat": "给你 3 个正整数 zero ，one 和 limit 。\n一个 二进制数组 arr 如果满足以下条件，那么我们称它是 稳定的 ：\n0 在 arr 中出现次数 恰好 为 zero 。\n1 在 arr 中出现次数 恰好 为 one 。\narr 中每个长度超过 limit 的 子数组 都 同时 包含 0 和 1 。\n请你返回 稳定 二进制数组的 总 数目。\n由于答案可能很大，将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入zero = 1, one = 1, limit = 2\n输出：2示例 2：\n输入zero = 1, one = 2, limit = 1\n输出：1\n\n提示：\n1 <= zero, one, limit <= 200\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} zero\n * @param {number} one\n * @param {number} limit\n * @return {number}\n */\nvar numberOfStableArrays = function(zero, one, limit) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(numberOfStableArrays(1,1,2), 2, \"Test 1 Error!\");\nassert.deepEqual(numberOfStableArrays(1,2,1), 1, \"Test 2 Error!\");\nassert.deepEqual(numberOfStableArrays(3,3,2), 14, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} zero\n * @param {number} one\n * @param {number} limit\n * @return {number}\n */\nvar numberOfStableArrays = function(zero, one, limit) {",
        "function_name": "numberOfStableArrays",
        "difficulty_level": "Middle",
        "time": "20240427"
    },
    {
        "id": "3130",
        "prompt_base": "\"\"\"\n给你 3 个正整数 zero ，one 和 limit 。一个 二进制数组 arr 如果满足以下条件，那么我们称它是 稳定的 ：\n0 在 arr 中出现次数 恰好 为 zero 。\n1 在 arr 中出现次数 恰好 为 one 。\narr 中每个长度超过 limit 的 子数组 都 同时 包含 0 和 1 。\n请你返回 稳定 二进制数组的 总 数目。\n由于答案可能很大，将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入zero = 1, one = 1, limit = 2\n输出：2示例 2：\n输入zero = 1, one = 2, limit = 1\n输出：1\n\n提示：\n1 <= zero, one, limit <= 1000\n\"\"\"\n\n/**\n * @param {number} zero\n * @param {number} one\n * @param {number} limit\n * @return {number}\n */\nvar numberOfStableArrays = function(zero, one, limit) {",
        "prompt_chat": "给你 3 个正整数 zero ，one 和 limit 。一个 二进制数组 arr 如果满足以下条件，那么我们称它是 稳定的 ：\n0 在 arr 中出现次数 恰好 为 zero 。\n1 在 arr 中出现次数 恰好 为 one 。\narr 中每个长度超过 limit 的 子数组 都 同时 包含 0 和 1 。\n请你返回 稳定 二进制数组的 总 数目。\n由于答案可能很大，将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入zero = 1, one = 1, limit = 2\n输出：2示例 2：\n输入zero = 1, one = 2, limit = 1\n输出：1\n\n提示：\n1 <= zero, one, limit <= 1000\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} zero\n * @param {number} one\n * @param {number} limit\n * @return {number}\n */\nvar numberOfStableArrays = function(zero, one, limit) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(numberOfStableArrays(1,1,2), 2, \"Test 1 Error!\");\nassert.deepEqual(numberOfStableArrays(1,2,1), 1, \"Test 2 Error!\");\nassert.deepEqual(numberOfStableArrays(3,3,2), 14, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} zero\n * @param {number} one\n * @param {number} limit\n * @return {number}\n */\nvar numberOfStableArrays = function(zero, one, limit) {",
        "function_name": "numberOfStableArrays",
        "difficulty_level": "Hard",
        "time": "20240427"
    },
    {
        "id": "3131",
        "prompt_base": "\"\"\"\n给你两个长度相等的数组 nums1 和 nums2。\n数组 nums1 中的每个元素都与变量 x 所表示的整数相加。如果 x 为负数，则表现为元素值的减少。\n在与 x 相加后，nums1 和 nums2 相等 。当两个数组中包含相同的整数，并且这些整数出现的频次相同时，两个数组 相等 。\n返回整数 x 。\n示例 1：\n输入nums1 = [2,6,4], nums2 = [9,7,5]\n输出：3示例 2：\n输入nums1 = [10], nums2 = [5]\n输出：-5\n\n提示：\n1 <= nums1.length == nums2.length <= 100\n0 <= nums1[i], nums2[i] <= 1000\n测试用例以这样的方式生成：存在一个整数 x，使得 nums1 中的每个元素都与 x 相加后，nums1 与 nums2 相等。\n\"\"\"\n\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar addedInteger = function(nums1, nums2) {",
        "prompt_chat": "给你两个长度相等的数组 nums1 和 nums2。\n数组 nums1 中的每个元素都与变量 x 所表示的整数相加。如果 x 为负数，则表现为元素值的减少。\n在与 x 相加后，nums1 和 nums2 相等 。当两个数组中包含相同的整数，并且这些整数出现的频次相同时，两个数组 相等 。\n返回整数 x 。\n示例 1：\n输入nums1 = [2,6,4], nums2 = [9,7,5]\n输出：3示例 2：\n输入nums1 = [10], nums2 = [5]\n输出：-5\n\n提示：\n1 <= nums1.length == nums2.length <= 100\n0 <= nums1[i], nums2[i] <= 1000\n测试用例以这样的方式生成：存在一个整数 x，使得 nums1 中的每个元素都与 x 相加后，nums1 与 nums2 相等。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar addedInteger = function(nums1, nums2) {\n```",
        "solution": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar addedInteger = function(nums1, nums2) {\n    return Math.min(...nums2) - Math.min(...nums1)\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(addedInteger([2,6,4],[9,7,5]), 3, \"Test 1 Error!\");\nassert.deepEqual(addedInteger([10],[5]), -5, \"Test 2 Error!\");\nassert.deepEqual(addedInteger([1,1,1,1],[1,1,1,1]), 0, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar addedInteger = function(nums1, nums2) {",
        "function_name": "addedInteger",
        "difficulty_level": "Easy",
        "time": "20240428"
    },
    {
        "id": "3132",
        "prompt_base": "\"\"\"\n给你两个整数数组 nums1 和 nums2。\n从 nums1 中移除两个元素，并且所有其他元素都与变量 x 所表示的整数相加。如果 x 为负数，则表现为元素值的减少。\n执行上述操作后，nums1 和 nums2 相等 。当两个数组中包含相同的整数，并且这些整数出现的频次相同时，两个数组 相等 。\n返回能够实现数组相等的 最小 整数 x 。\n示例 1：\n输入nums1 = [4,20,16,12,8], nums2 = [14,18,10]\n输出：-2示例 2：\n输入nums1 = [3,5,5,3], nums2 = [7,7]\n输出：2\n\n提示：\n3 <= nums1.length <= 200\nnums2.length == nums1.length - 2\n0 <= nums1[i], nums2[i] <= 1000\n测试用例以这样的方式生成：存在一个整数 x，nums1 中的每个元素都与 x 相加后，再移除两个元素，nums1 可以与 nums2 相等。\n\"\"\"\n\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar minimumAddedInteger = function(nums1, nums2) {",
        "prompt_chat": "给你两个整数数组 nums1 和 nums2。\n从 nums1 中移除两个元素，并且所有其他元素都与变量 x 所表示的整数相加。如果 x 为负数，则表现为元素值的减少。\n执行上述操作后，nums1 和 nums2 相等 。当两个数组中包含相同的整数，并且这些整数出现的频次相同时，两个数组 相等 。\n返回能够实现数组相等的 最小 整数 x 。\n示例 1：\n输入nums1 = [4,20,16,12,8], nums2 = [14,18,10]\n输出：-2示例 2：\n输入nums1 = [3,5,5,3], nums2 = [7,7]\n输出：2\n\n提示：\n3 <= nums1.length <= 200\nnums2.length == nums1.length - 2\n0 <= nums1[i], nums2[i] <= 1000\n测试用例以这样的方式生成：存在一个整数 x，nums1 中的每个元素都与 x 相加后，再移除两个元素，nums1 可以与 nums2 相等。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar minimumAddedInteger = function(nums1, nums2) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumAddedInteger([4,20,16,12,8],[14,18,10]), -2, \"Test 1 Error!\");\nassert.deepEqual(minimumAddedInteger([3,5,5,3],[7,7]), 2, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar minimumAddedInteger = function(nums1, nums2) {",
        "function_name": "minimumAddedInteger",
        "difficulty_level": "Middle",
        "time": "20240428"
    },
    {
        "id": "3133",
        "prompt_base": "\"\"\"\n给你两个整数 n 和 x 。你需要构造一个长度为 n 的 正整数 数组 nums ，对于所有 0 <= i < n - 1 ，满足 nums[i + 1] 大于 nums[i] ，并且数组 nums 中所有元素的按位 AND 运算结果为 x 。\n返回 nums[n - 1] 可能的 最小 值。\n示例 1：\n输入n = 3, x = 4\n输出：6示例 2：\n输入n = 2, x = 7\n输出：15\n\n提示：\n1 <= n, x <= 10^8\n\"\"\"\n\n/**\n * @param {number} n\n * @param {number} x\n * @return {number}\n */\nvar minEnd = function(n, x) {",
        "prompt_chat": "给你两个整数 n 和 x 。你需要构造一个长度为 n 的 正整数 数组 nums ，对于所有 0 <= i < n - 1 ，满足 nums[i + 1] 大于 nums[i] ，并且数组 nums 中所有元素的按位 AND 运算结果为 x 。\n返回 nums[n - 1] 可能的 最小 值。\n示例 1：\n输入n = 3, x = 4\n输出：6示例 2：\n输入n = 2, x = 7\n输出：15\n\n提示：\n1 <= n, x <= 10^8\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} n\n * @param {number} x\n * @return {number}\n */\nvar minEnd = function(n, x) {\n```",
        "solution": "/**\n * @param {number} n\n * @param {number} x\n * @return {number}\n */\nvar minEnd = function(n, x) {\n  let n1 = n - 1\n  let r = x\n  let mask = 1\n  while (n1 > 0 && mask <= 1e8) {\n    while ((r & mask) > 0) {\n      mask <<= 1\n    }\n    if (n1 & 1) {\n      r |= mask\n    }\n    n1 >>= 1\n    mask <<= 1\n  }\n  if (n1 > 0) {\n    return parseInt(n1.toString(2) + mask.toString(2).slice(1), 2) + r\n  }\n  return r\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minEnd(3,4), 6, \"Test 1 Error!\");\nassert.deepEqual(minEnd(2,7), 15, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} n\n * @param {number} x\n * @return {number}\n */\nvar minEnd = function(n, x) {",
        "function_name": "minEnd",
        "difficulty_level": "Middle",
        "time": "20240428"
    },
    {
        "id": "3134",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 。数组 nums 的 唯一性数组 是一个按元素从小到大排序的数组，包含了 nums 的所有非空子数组中不同元素的个数。\n换句话说，这是由所有 0 <= i <= j < nums.length 的 distinct(nums[i..j]) 组成的递增数组。其中，distinct(nums[i..j]) 表示从下标 i 到下标 j 的子数组中不同元素的数量。\n返回 nums 唯一性数组 的 中位数 。\n注意，数组的 中位数 定义为有序数组的中间元素。如果有两个中间元素，则取值较小的那个。\n示例 1：\n输入nums = [1,2,3]\n输出：1示例 2：\n输入nums = [3,4,3,4,5]\n输出：2\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar medianOfUniquenessArray = function(nums) {",
        "prompt_chat": "给你一个整数数组 nums 。数组 nums 的 唯一性数组 是一个按元素从小到大排序的数组，包含了 nums 的所有非空子数组中不同元素的个数。\n换句话说，这是由所有 0 <= i <= j < nums.length 的 distinct(nums[i..j]) 组成的递增数组。其中，distinct(nums[i..j]) 表示从下标 i 到下标 j 的子数组中不同元素的数量。\n返回 nums 唯一性数组 的 中位数 。\n注意，数组的 中位数 定义为有序数组的中间元素。如果有两个中间元素，则取值较小的那个。\n示例 1：\n输入nums = [1,2,3]\n输出：1示例 2：\n输入nums = [3,4,3,4,5]\n输出：2\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar medianOfUniquenessArray = function(nums) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(medianOfUniquenessArray([1,2,3]), 1, \"Test 1 Error!\");\nassert.deepEqual(medianOfUniquenessArray([3,4,3,4,5]), 2, \"Test 2 Error!\");\nassert.deepEqual(medianOfUniquenessArray([4,3,5,4]), 2, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar medianOfUniquenessArray = function(nums) {",
        "function_name": "medianOfUniquenessArray",
        "difficulty_level": "Hard",
        "time": "20240428"
    },
    {
        "id": "3136",
        "prompt_base": "\"\"\"\n有效单词 需要满足以下几个条件：至少 包含 3 个字符。由数字 0-9 和英文大小写字母组成。（不必包含所有这类字符。）至少 包含一个 元音字母 。至少 包含一个 辅音字母 。\n给你一个字符串 word 。如果 word 是一个有效单词，则返回 true ，否则返回 false 。\n注意：\n'a'、'e'、'i'、'o'、'u' 及其大写形式都属于 元音字母 。\n英文中的 辅音字母 是指那些除元音字母之外的字母。\n示例 1：\n输入word = \"234Adas\"\n输出：true示例 2：\n输入word = \"b3\"\n输出：false\n\n提示：\n1 <= word.length <= 20\nword 由英文大写和小写字母、数字、'@'、'#' 和 '$' 组成。\n\"\"\"\n\n/**\n * @param {string} word\n * @return {boolean}\n */\nvar isValid = function(word) {",
        "prompt_chat": "有效单词 需要满足以下几个条件：至少 包含 3 个字符。由数字 0-9 和英文大小写字母组成。（不必包含所有这类字符。）至少 包含一个 元音字母 。至少 包含一个 辅音字母 。\n给你一个字符串 word 。如果 word 是一个有效单词，则返回 true ，否则返回 false 。\n注意：\n'a'、'e'、'i'、'o'、'u' 及其大写形式都属于 元音字母 。\n英文中的 辅音字母 是指那些除元音字母之外的字母。\n示例 1：\n输入word = \"234Adas\"\n输出：true示例 2：\n输入word = \"b3\"\n输出：false\n\n提示：\n1 <= word.length <= 20\nword 由英文大写和小写字母、数字、'@'、'#' 和 '$' 组成。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} word\n * @return {boolean}\n */\nvar isValid = function(word) {\n```",
        "solution": "/**\n * @param {string} word\n * @return {boolean}\n */\nvar isValid = function (word) {\n    const a = /[aeiou]/i.test(word)\n    const b = /[bcdfghjklmnpqrstvwxyz]/i.test(word)\n    const c = /^[0-9a-zA-z]{3,}$/igm.test(word)\n    return a && b && c\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(isValid(\"234Adas\"), true, \"Test 1 Error!\");\nassert.deepEqual(isValid(\"b3\"), false, \"Test 2 Error!\");\nassert.deepEqual(isValid(\"a3$e\"), false, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} word\n * @return {boolean}\n */\nvar isValid = function(word) {",
        "function_name": "isValid",
        "difficulty_level": "Easy",
        "time": "20240505"
    },
    {
        "id": "3137",
        "prompt_base": "\"\"\"\n给你一个长度为 n 的字符串 word 和一个整数 k ，其中 k 是 n 的因数。\n在一次操作中，你可以选择任意两个下标 i 和 j，其中 0 <= i, j < n ，且这两个下标都可以被 k 整除，然后用从 j 开始的长度为 k 的子串替换从 i 开始的长度为 k 的子串。也就是说，将子串 word[i..i + k - 1] 替换为子串 word[j..j + k - 1] 。\n返回使 word 成为 K 周期字符串 所需的 最少 操作次数。\n如果存在某个长度为 k 的字符串 s，使得 word 可以表示为任意次数连接 s ，则称字符串 word 是 K 周期字符串 。例如，如果 word == \"ababab\"，那么 word 就是 s = \"ab\" 时的 2 周期字符串 。\n示例 1：\n输入word = \"leetcodeleet\", k = 4\n输出：1示例 2：\n输入word = \"leetcoleet\", k = 2\n输出：3\n\n提示：\n1 <= n == word.length <= 10^5\n1 <= k <= word.length\nk 能整除 word.length 。\nword 仅由小写英文字母组成。\n\"\"\"\n\n/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar minimumOperationsToMakeKPeriodic = function(word, k) {",
        "prompt_chat": "给你一个长度为 n 的字符串 word 和一个整数 k ，其中 k 是 n 的因数。\n在一次操作中，你可以选择任意两个下标 i 和 j，其中 0 <= i, j < n ，且这两个下标都可以被 k 整除，然后用从 j 开始的长度为 k 的子串替换从 i 开始的长度为 k 的子串。也就是说，将子串 word[i..i + k - 1] 替换为子串 word[j..j + k - 1] 。\n返回使 word 成为 K 周期字符串 所需的 最少 操作次数。\n如果存在某个长度为 k 的字符串 s，使得 word 可以表示为任意次数连接 s ，则称字符串 word 是 K 周期字符串 。例如，如果 word == \"ababab\"，那么 word 就是 s = \"ab\" 时的 2 周期字符串 。\n示例 1：\n输入word = \"leetcodeleet\", k = 4\n输出：1示例 2：\n输入word = \"leetcoleet\", k = 2\n输出：3\n\n提示：\n1 <= n == word.length <= 10^5\n1 <= k <= word.length\nk 能整除 word.length 。\nword 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar minimumOperationsToMakeKPeriodic = function(word, k) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumOperationsToMakeKPeriodic(\"leetcodeleet\",4), 1, \"Test 1 Error!\");\nassert.deepEqual(minimumOperationsToMakeKPeriodic(\"leetcoleet\",2), 3, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar minimumOperationsToMakeKPeriodic = function(word, k) {",
        "function_name": "minimumOperationsToMakeKPeriodic",
        "difficulty_level": "Middle",
        "time": "20240505"
    },
    {
        "id": "3138",
        "prompt_base": "\"\"\"\n给你一个字符串 s ，它由某个字符串 t 和若干 t  的 同位字符串 连接而成。\n请你返回字符串 t 的 最小 可能长度。\n同位字符串 指的是重新排列一个单词得到的另外一个字符串，原来字符串中的每个字符在新字符串中都恰好只使用一次。\n示例 1：\n输入s = \"abba\"\n输出：2示例 2：\n输入s = \"cdef\"\n输出：4\n\n提示：\n1 <= s.length <= 10^5\ns 只包含小写英文字母。\n\"\"\"\n\n/**\n * @param {string} s\n * @return {number}\n */\nvar minAnagramLength = function(s) {",
        "prompt_chat": "给你一个字符串 s ，它由某个字符串 t 和若干 t  的 同位字符串 连接而成。\n请你返回字符串 t 的 最小 可能长度。\n同位字符串 指的是重新排列一个单词得到的另外一个字符串，原来字符串中的每个字符在新字符串中都恰好只使用一次。\n示例 1：\n输入s = \"abba\"\n输出：2示例 2：\n输入s = \"cdef\"\n输出：4\n\n提示：\n1 <= s.length <= 10^5\ns 只包含小写英文字母。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar minAnagramLength = function(s) {\n```",
        "solution": "/**\n * @param {string} s\n * @return {number}\n */\nvar minAnagramLength = function(s) {\n    let m = s.length\n    let n = m/2\n    let i = 1\n    while(i<=n){\n        if(m%i==0){\n            let p = new Set()\n            let j = 0\n            while(j<m/i){\n                let d = s.slice(j*i,(j+1)*i).split('').sort((a,b)=>a.charCodeAt()-b.charCodeAt()).join('')\n                p.add(d)\n                j++\n                if(p.size>1) break\n            }\n            if(p.size==1) return i\n        }\n        i++\n    }\n    return m\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minAnagramLength(\"abba\"), 2, \"Test 1 Error!\");\nassert.deepEqual(minAnagramLength(\"cdef\"), 4, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} s\n * @return {number}\n */\nvar minAnagramLength = function(s) {",
        "function_name": "minAnagramLength",
        "difficulty_level": "Middle",
        "time": "20240505"
    },
    {
        "id": "3139",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 和两个整数 cost1 和 cost2 。你可以执行以下 任一 操作 任意 次：从 nums 中选择下标 i 并且将 nums[i] 增加 1 ，开销为 cost1。选择 nums 中两个 不同 下标 i 和 j ，并且将 nums[i] 和 nums[j] 都 增加 1 ，开销为 cost2 。\n你的目标是使数组中所有元素都 相等 ，请你返回需要的 最小开销 之和。\n由于答案可能会很大，请你将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入nums = [4,1], cost1 = 5, cost2 = 2\n输出：15示例 2：\n输入nums = [2,3,3,3,5], cost1 = 2, cost2 = 1\n输出：6\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^6\n1 <= cost1 <= 10^6\n1 <= cost2 <= 10^6\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} cost1\n * @param {number} cost2\n * @return {number}\n */\nvar minCostToEqualizeArray = function(nums, cost1, cost2) {",
        "prompt_chat": "给你一个整数数组 nums 和两个整数 cost1 和 cost2 。你可以执行以下 任一 操作 任意 次：从 nums 中选择下标 i 并且将 nums[i] 增加 1 ，开销为 cost1。选择 nums 中两个 不同 下标 i 和 j ，并且将 nums[i] 和 nums[j] 都 增加 1 ，开销为 cost2 。\n你的目标是使数组中所有元素都 相等 ，请你返回需要的 最小开销 之和。\n由于答案可能会很大，请你将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入nums = [4,1], cost1 = 5, cost2 = 2\n输出：15示例 2：\n输入nums = [2,3,3,3,5], cost1 = 2, cost2 = 1\n输出：6\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^6\n1 <= cost1 <= 10^6\n1 <= cost2 <= 10^6\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} cost1\n * @param {number} cost2\n * @return {number}\n */\nvar minCostToEqualizeArray = function(nums, cost1, cost2) {\n```",
        "solution": "var minCostToEqualizeArray = function(nums, cost1, cost2) {\n    let n = nums.length\n    if(n == 1){\n        return 0\n    }\n    if(n == 2){\n        return Math.abs((nums[0] - nums[1]) * cost1) % (10**9 + 7)\n    }\n    let sum = 0\n    let min = 10 ** 6\n    let max = 0\n    for(let i of nums){ // 找到最大值最小值计算差\n        sum += i\n        if(min > i){\n            min = i\n        }\n        if(max < i){\n            max = i\n        }\n    }\n    let count = max * n - sum //至少需要填满的空间\n    let c = max - min //最大的差值\n    if(cost1 * 2 >= cost2){ //如果单选的收益大于双选，全部选择单选，没有特殊情况\n        let f = count - 2 * c //如果最大的差值比别的所有加起来都打，可能会突破最大值\n        if(f > 0){\n            let number = Math.floor(count / 2) * cost2\n            let p = [(count % 2) * cost1]\n            if(n % 2 && count % 2){ //如果只剩最后一个未填满，对比一个的值和突破一层大小对比\n                p.push((n + 1)*cost2/2)\n            }\n            return (number + Math.min(...p)) % (10**9 + 7)\n        }else{\n            let s = count - c  //出去最大的差值得到能直接双选的数量\n            let z = c - s //最大的差值减去其他差值，得到需要单选或者突破最大的情况\n            let number = [s * cost2 + z * cost1] \n            let x = z/(n - 2)\n            if(x % 1 == 0){\n                let m = (x * (n - 1))\n                number.push((m + s) * cost2)\n            }else{\n                let x1 = Math.floor(x)\n                let x2 = Math.ceil(x)\n                let m = (x1 * (n - 1))\n                number.push((z - m + x1) * cost1 + (m + s) * cost2)\n                count = (x2 * n + z)\n                m = (x2 * (n - 1))\n                let po = Math.floor(count/2) + s\n                number.push((Math.floor(count/2) + s)* cost2 + (count % 2) * cost1)\n                if(count % 2 && n % 2){\n                    number.push((po + (n + 1)/2) * cost2)\n                }\n            }\n            return (Math.min(...number) % (10**9 + 7)) % (10**9 + 7)\n        }\n    }else{\n        return (count * cost1) % (10**9 + 7)\n    }\n\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minCostToEqualizeArray([4,1],5,2), 15, \"Test 1 Error!\");\nassert.deepEqual(minCostToEqualizeArray([2,3,3,3,5],2,1), 6, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} cost1\n * @param {number} cost2\n * @return {number}\n */\nvar minCostToEqualizeArray = function(nums, cost1, cost2) {",
        "function_name": "minCostToEqualizeArray",
        "difficulty_level": "Hard",
        "time": "20240505"
    },
    {
        "id": "3142",
        "prompt_base": "\"\"\"\n给你一个大小为 m x n 的二维矩阵 grid 。你需要判断每一个格子 grid[i][j] 是否满足：\n如果它下面的格子存在，那么它需要等于它下面的格子，也就是 grid[i][j] == grid[i + 1][j] 。\n如果它右边的格子存在，那么它需要不等于它右边的格子，也就是 grid[i][j] != grid[i][j + 1] 。\n如果 所有 格子都满足以上条件，那么返回 true ，否则返回 false 。\n示例 1：\n输入grid = [[1,0,2],[1,0,2]]\n输出：true示例 2：\n输入grid =  [[1,1,1],[0,0,0]]\n输出：false\n\n提示：\n1 <= n, m <= 10\n0 <= grid[i][j] <= 9\n\"\"\"\n\n/**\n * @param {number[][]} grid\n * @return {boolean}\n */\nvar satisfiesConditions = function(grid) {",
        "prompt_chat": "给你一个大小为 m x n 的二维矩阵 grid 。你需要判断每一个格子 grid[i][j] 是否满足：\n如果它下面的格子存在，那么它需要等于它下面的格子，也就是 grid[i][j] == grid[i + 1][j] 。\n如果它右边的格子存在，那么它需要不等于它右边的格子，也就是 grid[i][j] != grid[i][j + 1] 。\n如果 所有 格子都满足以上条件，那么返回 true ，否则返回 false 。\n示例 1：\n输入grid = [[1,0,2],[1,0,2]]\n输出：true示例 2：\n输入grid =  [[1,1,1],[0,0,0]]\n输出：false\n\n提示：\n1 <= n, m <= 10\n0 <= grid[i][j] <= 9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} grid\n * @return {boolean}\n */\nvar satisfiesConditions = function(grid) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(satisfiesConditions([[1,0,2],[1,0,2]]), true, \"Test 1 Error!\");\nassert.deepEqual(satisfiesConditions( [[1,1,1],[0,0,0]]), false, \"Test 2 Error!\");\nassert.deepEqual(satisfiesConditions([[1],[2],[3]]), false, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} grid\n * @return {boolean}\n */\nvar satisfiesConditions = function(grid) {",
        "function_name": "satisfiesConditions",
        "difficulty_level": "Easy",
        "time": "20240511"
    },
    {
        "id": "3143",
        "prompt_base": "\"\"\"\n给你一个二维数组 points 和一个字符串 s ，其中 points[i] 表示第 i 个点的坐标，s[i] 表示第 i 个点的 标签 。\n如果一个正方形的中心在 (0, 0) ，所有边都平行于坐标轴，且正方形内 不 存在标签相同的两个点，那么我们称这个正方形是 合法 的。\n请你返回 合法 正方形中可以包含的 最多 点数。\n注意：\n如果一个点位于正方形的边上或者在边以内，则认为该点位于正方形内。\n正方形的边长可以为零。\n示例 1：\n输入points = [[2,2],[-1,-2],[-4,4],[-3,1],[3,-3]], s = \"abdca\"\n输出：2示例 2：\n输入points = [[1,1],[-2,-2],[-2,2]], s = \"abb\"\n输出：1\n\n提示：\n1 <= s.length, points.length <= 10^5\npoints[i].length == 2\n-10^9 <= points[i][0], points[i][1] <= 10^9\ns.length == points.length\npoints 中的点坐标互不相同。\ns 只包含小写英文字母。\n\"\"\"\n\n/**\n * @param {number[][]} points\n * @param {string} s\n * @return {number}\n */\nvar maxPointsInsideSquare = function(points, s) {",
        "prompt_chat": "给你一个二维数组 points 和一个字符串 s ，其中 points[i] 表示第 i 个点的坐标，s[i] 表示第 i 个点的 标签 。\n如果一个正方形的中心在 (0, 0) ，所有边都平行于坐标轴，且正方形内 不 存在标签相同的两个点，那么我们称这个正方形是 合法 的。\n请你返回 合法 正方形中可以包含的 最多 点数。\n注意：\n如果一个点位于正方形的边上或者在边以内，则认为该点位于正方形内。\n正方形的边长可以为零。\n示例 1：\n输入points = [[2,2],[-1,-2],[-4,4],[-3,1],[3,-3]], s = \"abdca\"\n输出：2示例 2：\n输入points = [[1,1],[-2,-2],[-2,2]], s = \"abb\"\n输出：1\n\n提示：\n1 <= s.length, points.length <= 10^5\npoints[i].length == 2\n-10^9 <= points[i][0], points[i][1] <= 10^9\ns.length == points.length\npoints 中的点坐标互不相同。\ns 只包含小写英文字母。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} points\n * @param {string} s\n * @return {number}\n */\nvar maxPointsInsideSquare = function(points, s) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maxPointsInsideSquare([[2,2],[-1,-2],[-4,4],[-3,1],[3,-3]],\"abdca\"), 2, \"Test 1 Error!\");\nassert.deepEqual(maxPointsInsideSquare([[1,1],[-2,-2],[-2,2]],\"abb\"), 1, \"Test 2 Error!\");\nassert.deepEqual(maxPointsInsideSquare([[1,1],[-1,-1],[2,-2]],\"ccd\"), 0, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} points\n * @param {string} s\n * @return {number}\n */\nvar maxPointsInsideSquare = function(points, s) {",
        "function_name": "maxPointsInsideSquare",
        "difficulty_level": "Middle",
        "time": "20240511"
    },
    {
        "id": "3144",
        "prompt_base": "\"\"\"\n给你一个字符串 s ，你需要将它分割成一个或者更多的 平衡 子字符串。比方说，s == \"ababcc\" 那么 (\"abab\", \"c\", \"c\") ，(\"ab\", \"abc\", \"c\") 和 (\"ababcc\") 都是合法分割，但是 (\"a\", \"bab\", \"cc\") ，(\"aba\", \"bc\", \"c\") 和 (\"ab\", \"abcc\") 不是，不平衡的子字符串用粗体表示。\n请你返回 s 最少 能分割成多少个平衡子字符串。\n注意：一个 平衡 字符串指的是字符串中所有字符出现的次数都相同。\n示例 1：\n输入s = \"fabccddg\"\n输出：3示例 2：\n输入s = \"abababaccddb\"\n输出：2\n\n提示：\n1 <= s.length <= 1000\ns 只包含小写英文字母。\n\"\"\"\n\n/**\n * @param {string} s\n * @return {number}\n */\nvar minimumSubstringsInPartition = function(s) {",
        "prompt_chat": "给你一个字符串 s ，你需要将它分割成一个或者更多的 平衡 子字符串。比方说，s == \"ababcc\" 那么 (\"abab\", \"c\", \"c\") ，(\"ab\", \"abc\", \"c\") 和 (\"ababcc\") 都是合法分割，但是 (\"a\", \"bab\", \"cc\") ，(\"aba\", \"bc\", \"c\") 和 (\"ab\", \"abcc\") 不是，不平衡的子字符串用粗体表示。\n请你返回 s 最少 能分割成多少个平衡子字符串。\n注意：一个 平衡 字符串指的是字符串中所有字符出现的次数都相同。\n示例 1：\n输入s = \"fabccddg\"\n输出：3示例 2：\n输入s = \"abababaccddb\"\n输出：2\n\n提示：\n1 <= s.length <= 1000\ns 只包含小写英文字母。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar minimumSubstringsInPartition = function(s) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumSubstringsInPartition(\"fabccddg\"), 3, \"Test 1 Error!\");\nassert.deepEqual(minimumSubstringsInPartition(\"abababaccddb\"), 2, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} s\n * @return {number}\n */\nvar minimumSubstringsInPartition = function(s) {",
        "function_name": "minimumSubstringsInPartition",
        "difficulty_level": "Middle",
        "time": "20240511"
    },
    {
        "id": "3145",
        "prompt_base": "\"\"\"\n一个整数 x 的 强数组 指的是满足和为 x 的二的幂的最短有序数组。比方说，11 的强数组为 [1, 2, 8] 。\n我们将每一个正整数 i （即1，2，3等等）的 强数组 连接得到数组 big_nums ，big_nums 开始部分为 [\\underline{1}, \\underline{2}, \\underline{1, 2}, \\underline{4}, \\underline{1, 4}, \\underline{2, 4}, \\underline{1, 2, 4}, 8, ...] 。\n给你一个二维整数数组 queries ，其中 queries[i] = [from_i, to_i, mod_i] ，你需要计算 (big_nums[from_i] * big_nums[from_i + 1] * ... * big_nums[to_i]) % mod_i 。\n请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。\n示例 1：\n输入queries = [[1,3,7]]\n输出：[4]示例 2：\n输入queries = [[2,5,3],[7,7,4]]\n输出：[2,2]\n\n提示：\n1 <= queries.length <= 500\nqueries[i].length == 3\n0 <= queries[i][0] <= queries[i][1] <= 10^15\n1 <= queries[i][2] <= 10^5\n\"\"\"\n\n/**\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar findProductsOfElements = function(queries) {",
        "prompt_chat": "一个整数 x 的 强数组 指的是满足和为 x 的二的幂的最短有序数组。比方说，11 的强数组为 [1, 2, 8] 。\n我们将每一个正整数 i （即1，2，3等等）的 强数组 连接得到数组 big_nums ，big_nums 开始部分为 [\\underline{1}, \\underline{2}, \\underline{1, 2}, \\underline{4}, \\underline{1, 4}, \\underline{2, 4}, \\underline{1, 2, 4}, 8, ...] 。\n给你一个二维整数数组 queries ，其中 queries[i] = [from_i, to_i, mod_i] ，你需要计算 (big_nums[from_i] * big_nums[from_i + 1] * ... * big_nums[to_i]) % mod_i 。\n请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。\n示例 1：\n输入queries = [[1,3,7]]\n输出：[4]示例 2：\n输入queries = [[2,5,3],[7,7,4]]\n输出：[2,2]\n\n提示：\n1 <= queries.length <= 500\nqueries[i].length == 3\n0 <= queries[i][0] <= queries[i][1] <= 10^15\n1 <= queries[i][2] <= 10^5\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar findProductsOfElements = function(queries) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(findProductsOfElements([[1,3,7]]), [4], \"Test 1 Error!\");\nassert.deepEqual(findProductsOfElements([[2,5,3],[7,7,4]]), [2,2], \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar findProductsOfElements = function(queries) {",
        "function_name": "findProductsOfElements",
        "difficulty_level": "Hard",
        "time": "20240511"
    },
    {
        "id": "3146",
        "prompt_base": "\"\"\"\n给你两个字符串 s 和 t，每个字符串中的字符都不重复，且 t 是 s 的一个排列。排列差 定义为 s 和 t 中每个字符在两个字符串中位置的绝对差值之和。返回 s 和 t 之间的 排列差 。\n示例 1：\n输入s = \"abc\", t = \"bac\"\n输出：2示例 2：\n输入s = \"abcde\", t = \"edbac\"\n输出：12\n\n提示：\n1 <= s.length <= 26\n每个字符在 s 中最多出现一次。\nt 是 s 的一个排列。\ns 仅由小写英文字母组成。\n\"\"\"\n\n/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nvar findPermutationDifference = function(s, t) {",
        "prompt_chat": "给你两个字符串 s 和 t，每个字符串中的字符都不重复，且 t 是 s 的一个排列。排列差 定义为 s 和 t 中每个字符在两个字符串中位置的绝对差值之和。返回 s 和 t 之间的 排列差 。\n示例 1：\n输入s = \"abc\", t = \"bac\"\n输出：2示例 2：\n输入s = \"abcde\", t = \"edbac\"\n输出：12\n\n提示：\n1 <= s.length <= 26\n每个字符在 s 中最多出现一次。\nt 是 s 的一个排列。\ns 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nvar findPermutationDifference = function(s, t) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(findPermutationDifference(\"abc\",\"bac\"), 2, \"Test 1 Error!\");\nassert.deepEqual(findPermutationDifference(\"abcde\",\"edbac\"), 12, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nvar findPermutationDifference = function(s, t) {",
        "function_name": "findPermutationDifference",
        "difficulty_level": "Easy",
        "time": "20240512"
    },
    {
        "id": "3147",
        "prompt_base": "\"\"\"\n在神秘的地牢中，n 个魔法师站成一排。每个魔法师都拥有一个属性，这个属性可以给你提供能量。有些魔法师可能会给你负能量，即从你身上吸取能量。\n你被施加了一种诅咒，当你从魔法师 i 处吸收能量后，你将被立即传送到魔法师 (i + k) 处。这一过程将重复进行，直到你到达一个不存在 (i + k) 的魔法师为止。\n换句话说，你将选择一个起点，然后以 k 为间隔跳跃，直到到达魔法师序列的末端，在过程中吸收所有的能量。\n给定一个数组 energy 和一个整数k，返回你能获得的 最大 能量。\n示例 1：\n输入energy = [5,2,-10,-5,1], k = 3\n输出：3示例 2：\n输入energy = [-2,-3,-1], k = 2\n输出：-1\n\n提示：\n1 <= energy.length <= 10^5\n-1000 <= energy[i] <= 1000\n1 <= k <= energy.length - 1\n\"\"\"\n\n/**\n * @param {number[]} energy\n * @param {number} k\n * @return {number}\n */\nvar maximumEnergy = function(energy, k) {",
        "prompt_chat": "在神秘的地牢中，n 个魔法师站成一排。每个魔法师都拥有一个属性，这个属性可以给你提供能量。有些魔法师可能会给你负能量，即从你身上吸取能量。\n你被施加了一种诅咒，当你从魔法师 i 处吸收能量后，你将被立即传送到魔法师 (i + k) 处。这一过程将重复进行，直到你到达一个不存在 (i + k) 的魔法师为止。\n换句话说，你将选择一个起点，然后以 k 为间隔跳跃，直到到达魔法师序列的末端，在过程中吸收所有的能量。\n给定一个数组 energy 和一个整数k，返回你能获得的 最大 能量。\n示例 1：\n输入energy = [5,2,-10,-5,1], k = 3\n输出：3示例 2：\n输入energy = [-2,-3,-1], k = 2\n输出：-1\n\n提示：\n1 <= energy.length <= 10^5\n-1000 <= energy[i] <= 1000\n1 <= k <= energy.length - 1\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} energy\n * @param {number} k\n * @return {number}\n */\nvar maximumEnergy = function(energy, k) {\n```",
        "solution": "/**\n * @param {number[]} energy\n * @param {number} k\n * @return {number}\n */\nvar maximumEnergy = function(energy, k) {\n    const len = energy.length;\n    let ans = -Infinity;\n    for (i = len - 1; i >= len - k; i--) { // 只有最后K个必须要是最后需要到达的魔法师\n        let cur = 0;\n        for (j = i; j >= 0; j -= k) { // 从后往前加，并取最大值\n            cur += energy[j];\n            ans = Math.max(ans, cur);\n        }\n    }\n    return ans;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maximumEnergy([5,2,-10,-5,1],3), 3, \"Test 1 Error!\");\nassert.deepEqual(maximumEnergy([-2,-3,-1],2), -1, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} energy\n * @param {number} k\n * @return {number}\n */\nvar maximumEnergy = function(energy, k) {",
        "function_name": "maximumEnergy",
        "difficulty_level": "Middle",
        "time": "20240512"
    },
    {
        "id": "3148",
        "prompt_base": "\"\"\"\n给你一个由 正整数 组成、大小为 m x n 的矩阵 grid。你可以从矩阵中的任一单元格移动到另一个位于正下方或正右侧的任意单元格（不必相邻）。从值为 c1 的单元格移动到值为 c2 的单元格的得分为 c2 - c1 。\n你可以从 任一 单元格开始，并且必须至少移动一次。\n返回你能得到的 最大 总得分。\n示例 1：\n输入grid = [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]\n输出：9示例 2：\n输入grid = [[4,3,2],[3,2,1]]\n输出：-1\n\n提示：\nm == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 10^5\n1 <= grid[i][j] <= 10^5\n\"\"\"\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar maxScore = function(grid) {",
        "prompt_chat": "给你一个由 正整数 组成、大小为 m x n 的矩阵 grid。你可以从矩阵中的任一单元格移动到另一个位于正下方或正右侧的任意单元格（不必相邻）。从值为 c1 的单元格移动到值为 c2 的单元格的得分为 c2 - c1 。\n你可以从 任一 单元格开始，并且必须至少移动一次。\n返回你能得到的 最大 总得分。\n示例 1：\n输入grid = [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]\n输出：9示例 2：\n输入grid = [[4,3,2],[3,2,1]]\n输出：-1\n\n提示：\nm == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 10^5\n1 <= grid[i][j] <= 10^5\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar maxScore = function(grid) {\n```",
        "solution": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar maxScore = function (grid) {\n  let n = grid.length;\n  let m = grid[0].length;\n  let ans = -Infinity;\n  let dp = Array.from({ length: n + 1 }, () => new Array(m + 1).fill(Infinity));\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      mn = Math.min(dp[i][j + 1], dp[i + 1][j]);\n      ans = Math.max(ans, grid[i][j] - mn);\n      dp[i + 1][j + 1] = Math.min(mn, grid[i][j]);\n    }\n  }\n  return ans\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maxScore([[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]), 9, \"Test 1 Error!\");\nassert.deepEqual(maxScore([[4,3,2],[3,2,1]]), -1, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar maxScore = function(grid) {",
        "function_name": "maxScore",
        "difficulty_level": "Middle",
        "time": "20240512"
    },
    {
        "id": "3149",
        "prompt_base": "\"\"\"\n给你一个数组 nums,它是 [0, 1, 2, ..., n - 1] 的一个 排列 。对于任意一个[0, 1, 2, ..., n - 1] 的排列 perm其 分数 定义为：score(perm) = |perm[0] - nums[perm[1]]| + |perm[1] - nums[perm[2]]| + ... + |perm[n - 1] - nums[perm[0]]|\n返回具有 最低 分数的排列 perm 。如果存在多个满足题意且分数相等的排列，则返回其中 字典序最小 的一个。\n示例 1：\n输入nums = [1,0,2]\n输出：[0,1,2]示例 2：\n输入nums = [0,2,1]\n输出：[0,2,1]\n\n提示：\n2 <= n == nums.length <= 14\nnums 是 [0, 1, 2, ..., n - 1] 的一个排列。\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar findPermutation = function(nums) {",
        "prompt_chat": "给你一个数组 nums,它是 [0, 1, 2, ..., n - 1] 的一个 排列 。对于任意一个[0, 1, 2, ..., n - 1] 的排列 perm其 分数 定义为：score(perm) = |perm[0] - nums[perm[1]]| + |perm[1] - nums[perm[2]]| + ... + |perm[n - 1] - nums[perm[0]]|\n返回具有 最低 分数的排列 perm 。如果存在多个满足题意且分数相等的排列，则返回其中 字典序最小 的一个。\n示例 1：\n输入nums = [1,0,2]\n输出：[0,1,2]示例 2：\n输入nums = [0,2,1]\n输出：[0,2,1]\n\n提示：\n2 <= n == nums.length <= 14\nnums 是 [0, 1, 2, ..., n - 1] 的一个排列。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar findPermutation = function(nums) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(findPermutation([1,0,2]), [0,1,2], \"Test 1 Error!\");\nassert.deepEqual(findPermutation([0,2,1]), [0,2,1], \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar findPermutation = function(nums) {",
        "function_name": "findPermutation",
        "difficulty_level": "Hard",
        "time": "20240512"
    },
    {
        "id": "3151",
        "prompt_base": "\"\"\"\n如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 特殊数组 。\nAging 有一个整数数组 nums。如果 nums 是一个 特殊数组 ，返回 true，否则返回 false。\n示例 1：\n输入nums = [1]\n输出：true示例 2：\n输入nums = [2,1,4]\n输出：true\n\n提示：\n1 <= nums.length <= 100\n1 <= nums[i] <= 100\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar isArraySpecial = function(nums) {",
        "prompt_chat": "如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 特殊数组 。\nAging 有一个整数数组 nums。如果 nums 是一个 特殊数组 ，返回 true，否则返回 false。\n示例 1：\n输入nums = [1]\n输出：true示例 2：\n输入nums = [2,1,4]\n输出：true\n\n提示：\n1 <= nums.length <= 100\n1 <= nums[i] <= 100\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar isArraySpecial = function(nums) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar isArraySpecial = function(nums) {\n    let x = nums[0] \n    if(x % 2) return nums.every((v,i) => i % 2  !==  v % 2 ) \n    return nums.every((v,i) => i % 2  ===  v % 2) \n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(isArraySpecial([1]), true, \"Test 1 Error!\");\nassert.deepEqual(isArraySpecial([2,1,4]), true, \"Test 2 Error!\");\nassert.deepEqual(isArraySpecial([4,3,1,6]), false, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar isArraySpecial = function(nums) {",
        "function_name": "isArraySpecial",
        "difficulty_level": "Easy",
        "time": "20240519"
    },
    {
        "id": "3152",
        "prompt_base": "\"\"\"\n如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 特殊数组 。\n周洋哥有一个整数数组 nums 和一个二维整数矩阵 queries，对于 queries[i] = [fromi, toi]，请你帮助周洋哥检查子数组 nums[fromi..toi] 是不是一个 特殊数组 。\n返回布尔数组 answer，如果 nums[fromi..toi] 是特殊数组，则 answer[i] 为 true ，否则，answer[i] 为 false 。\n示例 1：\n输入nums = [3,4,1,2,6], queries = [[0,4]]\n输出：[false]示例 2：\n输入nums = [4,3,1,6], queries = [[0,2],[2,3]]\n输出：[false,true]\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\n1 <= queries.length <= 10^5\nqueries[i].length == 2\n0 <= queries[i][0] <= queries[i][1] <= nums.length - 1\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nvar isArraySpecial = function(nums, queries) {",
        "prompt_chat": "如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 特殊数组 。\n周洋哥有一个整数数组 nums 和一个二维整数矩阵 queries，对于 queries[i] = [fromi, toi]，请你帮助周洋哥检查子数组 nums[fromi..toi] 是不是一个 特殊数组 。\n返回布尔数组 answer，如果 nums[fromi..toi] 是特殊数组，则 answer[i] 为 true ，否则，answer[i] 为 false 。\n示例 1：\n输入nums = [3,4,1,2,6], queries = [[0,4]]\n输出：[false]示例 2：\n输入nums = [4,3,1,6], queries = [[0,2],[2,3]]\n输出：[false,true]\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\n1 <= queries.length <= 10^5\nqueries[i].length == 2\n0 <= queries[i][0] <= queries[i][1] <= nums.length - 1\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nvar isArraySpecial = function(nums, queries) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nfunction isOdd(num) {\n    return num % 2 === 1;\n}\n\nfunction isSpecialPair(a, b) {\n    return (isOdd(a) && !isOdd(b)) || (!isOdd(a) && isOdd(b));\n}\n\nvar isArraySpecial = function(nums, queries) {\n    let n = nums.length;\n    let specialPairs = new Array(n).fill(0);\n\n    // 预处理，计算每个相邻的元素是否构成特殊对\n    for (let i = 0; i < n - 1; i++) {\n        if (isSpecialPair(nums[i], nums[i + 1])) {\n            specialPairs[i] = 1;\n        }\n    }\n\n    // 构建前缀和数组\n    let prefixSum = new Array(n).fill(0);\n    for (let i = 1; i < n; i++) {\n        prefixSum[i] = prefixSum[i - 1] + specialPairs[i - 1];\n    }\n\n    let res = [];\n    for (let [left, right] of queries) {\n        if (right == left) {\n            res.push(true);\n        } else {\n            // 计算区间内的特殊对数量\n            let totalSpecialPairs = prefixSum[right] - prefixSum[left];\n            // 判断是否每对都是特殊对\n            res.push(totalSpecialPairs === (right - left));\n        }\n    }\n\n    return res;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(isArraySpecial([3,4,1,2,6],[[0,4]]), [false], \"Test 1 Error!\");\nassert.deepEqual(isArraySpecial([4,3,1,6],[[0,2],[2,3]]), [false,true], \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nvar isArraySpecial = function(nums, queries) {",
        "function_name": "isArraySpecial",
        "difficulty_level": "Middle",
        "time": "20240519"
    },
    {
        "id": "3153",
        "prompt_base": "\"\"\"\n车尔尼有一个数组 nums ，它只包含 正 整数，所有正整数的数位长度都 相同 。\n两个整数的 数位不同 指的是两个整数 相同 位置上不同数字的数目。\n请车尔尼返回 nums 中 所有 整数对里，数位不同之和。\n示例 1：\n输入nums = [13,23,12]\n输出：4示例 2：\n输入nums = [10,10,10,10]\n输出：0\n\n提示：\n2 <= nums.length <= 10^5\n1 <= nums[i] < 10^9\nnums 中的整数都有相同的数位长度。\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumDigitDifferences = function(nums) {",
        "prompt_chat": "车尔尼有一个数组 nums ，它只包含 正 整数，所有正整数的数位长度都 相同 。\n两个整数的 数位不同 指的是两个整数 相同 位置上不同数字的数目。\n请车尔尼返回 nums 中 所有 整数对里，数位不同之和。\n示例 1：\n输入nums = [13,23,12]\n输出：4示例 2：\n输入nums = [10,10,10,10]\n输出：0\n\n提示：\n2 <= nums.length <= 10^5\n1 <= nums[i] < 10^9\nnums 中的整数都有相同的数位长度。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumDigitDifferences = function(nums) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumDigitDifferences = function(nums) {\n    let ans = 0;\n    let len = nums[0].toString().length; // 数位长度\n    let cnt = new Array(len).fill(0).map(() => Array(10).fill(0)); // 初始化计数数组\n\n    for (let i = 0; i < nums.length; i++) {\n        let num = nums[i];\n        let numArr = num.toString().split('').reverse(); // 将数字转成数组并翻转\n        for (let j = 0; j < numArr.length; j++) {\n            let temp = numArr[j];\n            // cnt[j][temp] 是一个二维数组，用于记录在当前数位 j 上，每个数字 temp 出现的次数。\n            /*如果 temp 在之前没有出现过：cnt[j][temp] 为 0，那么 i - cnt[j][temp] 等于 i，这表示\n            当前 nums[i] 的第 j 位 temp 与之前处理的所有 i 个数字在第 j 位上都不同，所有这些不同都会被计入 ans。\n              如果 temp 在之前出现过 cnt[j][temp] 次：那么 i - cnt[j][temp] 表示在处理 nums[i] 时，\n              之前 i 个数字中有 i - cnt[j][temp] 个数字在第 j 位上与 temp 不同。*/\n            ans += i - cnt[j][temp]; // 计算数位不同之和\n            cnt[j][temp]++; // 更新计数数组\n        }\n    }\n    return ans;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(sumDigitDifferences([13,23,12]), 4, \"Test 1 Error!\");\nassert.deepEqual(sumDigitDifferences([10,10,10,10]), 0, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumDigitDifferences = function(nums) {",
        "function_name": "sumDigitDifferences",
        "difficulty_level": "Middle",
        "time": "20240519"
    },
    {
        "id": "3154",
        "prompt_base": "\"\"\"\n给你有一个 非负 整数 k 。有一个无限长度的台阶，最低 一层编号为 0 。\n虎老师有一个整数 jump ，一开始值为 0 。虎老师从台阶 1 开始，虎老师可以使用 任意 次操作，目标是到达第 k 级台阶。假设虎老师位于台阶 i ，一次 操作 中，虎老师可以：向下走一级到 i - 1 ，但该操作 不能 连续使用，如果在台阶第 0 级也不能使用。向上走到台阶 i + 2^jump 处，然后 jump 变为 jump + 1 。\n请你返回虎老师到达台阶 k 处的总方案数。\n注意 ，虎老师可能到达台阶 k 处后，通过一些操作重新回到台阶 k 处，这视为不同的方案。\n示例 1：\n输入k = 0\n输出：2示例 2：\n输入k = 1\n输出：4\n\n提示：\n0 <= k <= 10^9\n\"\"\"\n\n/**\n * @param {number} k\n * @return {number}\n */\nvar waysToReachStair = function(k) {",
        "prompt_chat": "给你有一个 非负 整数 k 。有一个无限长度的台阶，最低 一层编号为 0 。\n虎老师有一个整数 jump ，一开始值为 0 。虎老师从台阶 1 开始，虎老师可以使用 任意 次操作，目标是到达第 k 级台阶。假设虎老师位于台阶 i ，一次 操作 中，虎老师可以：向下走一级到 i - 1 ，但该操作 不能 连续使用，如果在台阶第 0 级也不能使用。向上走到台阶 i + 2^jump 处，然后 jump 变为 jump + 1 。\n请你返回虎老师到达台阶 k 处的总方案数。\n注意 ，虎老师可能到达台阶 k 处后，通过一些操作重新回到台阶 k 处，这视为不同的方案。\n示例 1：\n输入k = 0\n输出：2示例 2：\n输入k = 1\n输出：4\n\n提示：\n0 <= k <= 10^9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} k\n * @return {number}\n */\nvar waysToReachStair = function(k) {\n```",
        "solution": "/**\n * @param {number} k\n * @return {number}\n */\nvar waysToReachStair = function(k) {\n    return dfs(1, 0, 0 , k, new Map());\n};\n\n// i表示当前楼梯数，j表示使用第2次操作j次，preDown表示前一次操作是否是向上，1表示向上，k表示目标楼梯数，memo记忆化搜索map，\n// 避免重复计算。\nfunction dfs(i, j, preDown, k, memo) {\n    if (i > k + 1) {\n        return 0;\n    }\n    let p = ((BigInt(i) << 32n) | BigInt(j) << 1n | BigInt(preDown)); // 用一个 BigInt 表示状态\n    if (memo.has(p)) { // 之前算过了\n        return memo.get(p);\n    }\n    let res = (i === k) ? 1 : 0;\n    res += dfs(i + (1 << j), j + 1, 0, k, memo); // 操作二\n    if (preDown === 0 && i > 0) {\n        res += dfs(i - 1, j, 1, k, memo); // 操作一\n    }\n    memo.set(p, res); // 记忆化\n    return res;\n}",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(waysToReachStair(0), 2, \"Test 1 Error!\");\nassert.deepEqual(waysToReachStair(1), 4, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} k\n * @return {number}\n */\nvar waysToReachStair = function(k) {",
        "function_name": "waysToReachStair",
        "difficulty_level": "Hard",
        "time": "20240519"
    },
    {
        "id": "3158",
        "prompt_base": "\"\"\"\n给你一个数组 nums ，数组中的数字 要么 出现一次，要么 出现两次。\n请你返回数组中所有出现两次数字的按位 XOR 值，如果没有数字出现过两次，返回 0 。\n示例 1：\n输入nums = [1,2,1,3]\n输出：1示例 2：\n输入nums = [1,2,3]\n输出：0\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 50\nnums 中每个数字要么出现过一次，要么出现过两次。\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar duplicateNumbersXOR = function(nums) {",
        "prompt_chat": "给你一个数组 nums ，数组中的数字 要么 出现一次，要么 出现两次。\n请你返回数组中所有出现两次数字的按位 XOR 值，如果没有数字出现过两次，返回 0 。\n示例 1：\n输入nums = [1,2,1,3]\n输出：1示例 2：\n输入nums = [1,2,3]\n输出：0\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 50\nnums 中每个数字要么出现过一次，要么出现过两次。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar duplicateNumbersXOR = function(nums) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar duplicateNumbersXOR = function (nums) {\n    let map = new Map(), res = 0;\n    nums.forEach(item => map.has(item) ? res ^= item : map.set(item, 1))\n    return res\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(duplicateNumbersXOR([1,2,1,3]), 1, \"Test 1 Error!\");\nassert.deepEqual(duplicateNumbersXOR([1,2,3]), 0, \"Test 2 Error!\");\nassert.deepEqual(duplicateNumbersXOR([1,2,2,1]), 3, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar duplicateNumbersXOR = function(nums) {",
        "function_name": "duplicateNumbersXOR",
        "difficulty_level": "Easy",
        "time": "20240525"
    },
    {
        "id": "3159",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums ，一个整数数组 queries 和一个整数 x 。\n对于每个查询 queries[i] ，你需要找到 nums 中第 queries[i] 个 x 的位置，并返回它的下标。如果数组中 x 的出现次数少于 queries[i] ，该查询的答案为 -1 。\n请你返回一个整数数组 answer ，包含所有查询的答案。\n示例 1：\n输入nums = [1,3,1,7], queries = [1,3,2,4], x = 1\n输出：[0,-1,2,-1]示例 2：\n输入nums = [1,2,3], queries = [10], x = 5\n输出：[-1]\n\n提示：\n1 <= nums.length, queries.length <= 10^5\n1 <= queries[i] <= 10^5\n1 <= nums[i], x <= 10^4\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @param {number} x\n * @return {number[]}\n */\nvar occurrencesOfElement = function(nums, queries, x) {",
        "prompt_chat": "给你一个整数数组 nums ，一个整数数组 queries 和一个整数 x 。\n对于每个查询 queries[i] ，你需要找到 nums 中第 queries[i] 个 x 的位置，并返回它的下标。如果数组中 x 的出现次数少于 queries[i] ，该查询的答案为 -1 。\n请你返回一个整数数组 answer ，包含所有查询的答案。\n示例 1：\n输入nums = [1,3,1,7], queries = [1,3,2,4], x = 1\n输出：[0,-1,2,-1]示例 2：\n输入nums = [1,2,3], queries = [10], x = 5\n输出：[-1]\n\n提示：\n1 <= nums.length, queries.length <= 10^5\n1 <= queries[i] <= 10^5\n1 <= nums[i], x <= 10^4\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @param {number} x\n * @return {number[]}\n */\nvar occurrencesOfElement = function(nums, queries, x) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @param {number} x\n * @return {number[]}\n */\nvar occurrencesOfElement = function (nums, queries, x) {\n    const l = nums.length\n    let res = [];\n    let positions = [];\n    let currentCount = 0;\n\n    for (let j = 0; j < queries.length; j++) {\n        let query = queries[j];\n        if (query <= positions.length) {\n            res.push(positions[query - 1]);\n            continue;\n        }\n        while (currentCount < l && l - currentCount + positions.length >= query) {\n            if (nums[currentCount] === x) {\n                positions.push(currentCount);\n            }\n            currentCount++;\n            if (positions.length === query) {\n                res.push(positions[query - 1]);\n                break;\n            }\n        }\n        if (positions.length < query) {\n            res.push(-1);\n        }\n    }\n\n    return res;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(occurrencesOfElement([1,3,1,7],[1,3,2,4],1), [0,-1,2,-1], \"Test 1 Error!\");\nassert.deepEqual(occurrencesOfElement([1,2,3],[10],5), [-1], \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @param {number} x\n * @return {number[]}\n */\nvar occurrencesOfElement = function(nums, queries, x) {",
        "function_name": "occurrencesOfElement",
        "difficulty_level": "Middle",
        "time": "20240525"
    },
    {
        "id": "3160",
        "prompt_base": "\"\"\"\n给你一个整数 limit 和一个大小为 n x 2 的二维数组 queries 。\n总共有 limit + 1 个球，每个球的编号为 [0, limit] 中一个 互不相同 的数字。一开始，所有球都没有颜色。queries 中每次操作的格式为 [x, y] ，你需要将球 x 染上颜色 y 。每次操作之后，你需要求出所有球中 不同 颜色的数目。\n请你返回一个长度为 n 的数组 result ，其中 result[i] 是第 i 次操作以后不同颜色的数目。\n注意 ，没有染色的球不算作一种颜色。\n示例 1：\n输入limit = 4, queries = [[1,4],[2,5],[1,3],[3,4]]\n输出：[1,2,2,3]示例 2：\n输入limit = 4, queries = [[0,1],[1,2],[2,2],[3,4],[4,5]]\n输出：[1,2,2,3,4]\n\n提示：\n1 <= limit <= 10^9\n1 <= n == queries.length <= 10^5\nqueries[i].length == 2\n0 <= queries[i][0] <= limit\n1 <= queries[i][1] <= 10^9\n\"\"\"\n\n/**\n * @param {number} limit\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar queryResults = function(limit, queries) {",
        "prompt_chat": "给你一个整数 limit 和一个大小为 n x 2 的二维数组 queries 。\n总共有 limit + 1 个球，每个球的编号为 [0, limit] 中一个 互不相同 的数字。一开始，所有球都没有颜色。queries 中每次操作的格式为 [x, y] ，你需要将球 x 染上颜色 y 。每次操作之后，你需要求出所有球中 不同 颜色的数目。\n请你返回一个长度为 n 的数组 result ，其中 result[i] 是第 i 次操作以后不同颜色的数目。\n注意 ，没有染色的球不算作一种颜色。\n示例 1：\n输入limit = 4, queries = [[1,4],[2,5],[1,3],[3,4]]\n输出：[1,2,2,3]示例 2：\n输入limit = 4, queries = [[0,1],[1,2],[2,2],[3,4],[4,5]]\n输出：[1,2,2,3,4]\n\n提示：\n1 <= limit <= 10^9\n1 <= n == queries.length <= 10^5\nqueries[i].length == 2\n0 <= queries[i][0] <= limit\n1 <= queries[i][1] <= 10^9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} limit\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar queryResults = function(limit, queries) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(queryResults(4,[[1,4],[2,5],[1,3],[3,4]]), [1,2,2,3], \"Test 1 Error!\");\nassert.deepEqual(queryResults(4,[[0,1],[1,2],[2,2],[3,4],[4,5]]), [1,2,2,3,4], \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} limit\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar queryResults = function(limit, queries) {",
        "function_name": "queryResults",
        "difficulty_level": "Middle",
        "time": "20240525"
    },
    {
        "id": "3161",
        "prompt_base": "\"\"\"\n有一条无限长的数轴，原点在 0 处，沿着 x 轴 正 方向无限延伸。\n给你一个二维数组 queries ，它包含两种操作：\n操作类型 1 ：queries[i] = [1, x] 。在距离原点 x 处建一个障碍物。数据保证当操作执行的时候，位置 x 处 没有 任何障碍物。\n操作类型 2 ：queries[i] = [2, x, sz] 。判断在数轴范围 [0, x] 内是否可以放置一个长度为 sz 的物块，这个物块需要 完全 放置在范围 [0, x] 内。如果物块与任何障碍物有重合，那么这个物块 不能 被放置，但物块可以与障碍物刚好接触。注意，你只是进行查询，并 不是 真的放置这个物块。每个查询都是相互独立的。\n请你返回一个 boolean 数组results ，如果第 i 个操作类型 2 的操作你可以放置物块，那么 results[i] 为 true ，否则为 false 。\n示例 1：\n输入queries = [[1,2],[2,3,3],[2,3,1],[2,2,2]]\n输出：[false,true,true]示例 2：\n输入queries = [[1,7],[2,7,6],[1,2],[2,7,5],[2,7,6]]\n输出：[true,true,false]\n\n提示：\n1 <= queries.length <= 15 * 10^4\n2 <= queries[i].length <= 3\n1 <= queries[i][0] <= 2\n1 <= x, sz <= min(5 * 10^4, 3 * queries.length)\n输入保证操作 1 中，x 处不会有障碍物。\n输入保证至少有一个操作类型 2 。\n\"\"\"\n\n/**\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nvar getResults = function(queries) {",
        "prompt_chat": "有一条无限长的数轴，原点在 0 处，沿着 x 轴 正 方向无限延伸。\n给你一个二维数组 queries ，它包含两种操作：\n操作类型 1 ：queries[i] = [1, x] 。在距离原点 x 处建一个障碍物。数据保证当操作执行的时候，位置 x 处 没有 任何障碍物。\n操作类型 2 ：queries[i] = [2, x, sz] 。判断在数轴范围 [0, x] 内是否可以放置一个长度为 sz 的物块，这个物块需要 完全 放置在范围 [0, x] 内。如果物块与任何障碍物有重合，那么这个物块 不能 被放置，但物块可以与障碍物刚好接触。注意，你只是进行查询，并 不是 真的放置这个物块。每个查询都是相互独立的。\n请你返回一个 boolean 数组results ，如果第 i 个操作类型 2 的操作你可以放置物块，那么 results[i] 为 true ，否则为 false 。\n示例 1：\n输入queries = [[1,2],[2,3,3],[2,3,1],[2,2,2]]\n输出：[false,true,true]示例 2：\n输入queries = [[1,7],[2,7,6],[1,2],[2,7,5],[2,7,6]]\n输出：[true,true,false]\n\n提示：\n1 <= queries.length <= 15 * 10^4\n2 <= queries[i].length <= 3\n1 <= queries[i][0] <= 2\n1 <= x, sz <= min(5 * 10^4, 3 * queries.length)\n输入保证操作 1 中，x 处不会有障碍物。\n输入保证至少有一个操作类型 2 。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nvar getResults = function(queries) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(getResults([[1,2],[2,3,3],[2,3,1],[2,2,2]]), [false,true,true], \"Test 1 Error!\");\nassert.deepEqual(getResults([[1,7],[2,7,6],[1,2],[2,7,5],[2,7,6]]), [true,true,false], \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nvar getResults = function(queries) {",
        "function_name": "getResults",
        "difficulty_level": "Hard",
        "time": "20240525"
    },
    {
        "id": "3162",
        "prompt_base": "\"\"\"\n给你两个整数数组 nums1 和 nums2，长度分别为 n 和 m。同时给你一个正整数 k。\n\n如果 nums1[i] 可以被 nums2[j] * k 整除，则称数对 (i, j) 为 优质数对（0 <= i <= n - 1, 0 <= j <= m - 1）。\n\n返回 优质数对 的总数。\n示例 1：\n输入nums1 = [1,3,4], nums2 = [1,3,4], k = 1\n输出：5示例 2：\n输入nums1 = [1,2,4,12], nums2 = [2,4], k = 3\n输出：2\n\n提示：\n1 <= n, m <= 50\n1 <= nums1[i], nums2[j] <= 50\n1 <= k <= 50\n\"\"\"\n\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number}\n */\nvar numberOfPairs = function(nums1, nums2, k) {",
        "prompt_chat": "给你两个整数数组 nums1 和 nums2，长度分别为 n 和 m。同时给你一个正整数 k。\n\n如果 nums1[i] 可以被 nums2[j] * k 整除，则称数对 (i, j) 为 优质数对（0 <= i <= n - 1, 0 <= j <= m - 1）。\n\n返回 优质数对 的总数。\n示例 1：\n输入nums1 = [1,3,4], nums2 = [1,3,4], k = 1\n输出：5示例 2：\n输入nums1 = [1,2,4,12], nums2 = [2,4], k = 3\n输出：2\n\n提示：\n1 <= n, m <= 50\n1 <= nums1[i], nums2[j] <= 50\n1 <= k <= 50\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number}\n */\nvar numberOfPairs = function(nums1, nums2, k) {\n```",
        "solution": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number}\n */\nvar numberOfPairs = function(nums1, nums2, k) {\n    let d1 = new Map();\n    \n    for (let x of nums1){\n        if (x%k===0){\n            let v = x/k;\n            for (let i=1;i<Math.floor(Math.sqrt(v)+1);i++){\n                if (v%i ===0) {\n                    if (!d1.has(i)) d1.set(i,1);\n                    else d1.set(i,d1.get(i)+1);\n                    let y = v/i;\n                    if (y!=i){\n                        if (!d1.has(y)) d1.set(y,1);\n                        else d1.set(y,d1.get(y)+1);\n                    }\n                }\n            }\n        }\n    }\n    let ans = 0;\n    for (let t of nums2){\n        if (d1.has(t)) ans += d1.get(t);\n    }\n    return ans;\n\n}",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(numberOfPairs([1,3,4],[1,3,4],1), 5, \"Test 1 Error!\");\nassert.deepEqual(numberOfPairs([1,2,4,12],[2,4],3), 2, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number}\n */\nvar numberOfPairs = function(nums1, nums2, k) {",
        "function_name": "numberOfPairs",
        "difficulty_level": "Easy",
        "time": "20240526"
    },
    {
        "id": "3163",
        "prompt_base": "\"\"\"\n给你一个字符串 word，请你使用以下算法进行压缩：从空字符串 comp 开始。当 word 不为空 时，执行以下操作：移除 word 的最长单字符前缀，该前缀由单一字符 c 重复多次组成，且该前缀长度 最多 为 9 。将前缀的长度和字符 c 追加到 comp 。\n返回字符串 comp 。\n示例 1：\n输入word = \"abcde\"\n输出：\"1a1b1c1d1e\"示例 2：\n输入word = \"aaaaaaaaaaaaaabb\"\n输出：\"9a5a2b\"\n\n提示：\n1 <= word.length <= 2 * 10^5\nword 仅由小写英文字母组成。\n\"\"\"\n\n/**\n * @param {string} word\n * @return {string}\n */\nvar compressedString = function(word) {",
        "prompt_chat": "给你一个字符串 word，请你使用以下算法进行压缩：从空字符串 comp 开始。当 word 不为空 时，执行以下操作：移除 word 的最长单字符前缀，该前缀由单一字符 c 重复多次组成，且该前缀长度 最多 为 9 。将前缀的长度和字符 c 追加到 comp 。\n返回字符串 comp 。\n示例 1：\n输入word = \"abcde\"\n输出：\"1a1b1c1d1e\"示例 2：\n输入word = \"aaaaaaaaaaaaaabb\"\n输出：\"9a5a2b\"\n\n提示：\n1 <= word.length <= 2 * 10^5\nword 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} word\n * @return {string}\n */\nvar compressedString = function(word) {\n```",
        "solution": "/**\n * @param {string} word\n * @return {string}\n */\nvar compressedString = function(word) {\n\n    let char , i , j , res = '' ;\n    i = j = 0\n    char = word[i]\n    const ok = (s , e , char)=>{\n        while(e-s >=9) {\n            res+= `9${char}`;\n            e-=9\n        }\n        if(e-s) {\n            res+= `${e-s}${char}`;\n        }\n    }\n    for( ;  i<word.length ; i++) {\n        while(char === word[j]) {\n            j++\n        }\n        ok(i , j , char);\n        i = j-1;\n        char = word[j]\n    }\n    return res\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(compressedString(\"abcde\"), \"1a1b1c1d1e\", \"Test 1 Error!\");\nassert.deepEqual(compressedString(\"aaaaaaaaaaaaaabb\"), \"9a5a2b\", \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} word\n * @return {string}\n */\nvar compressedString = function(word) {",
        "function_name": "compressedString",
        "difficulty_level": "Middle",
        "time": "20240526"
    },
    {
        "id": "3164",
        "prompt_base": "\"\"\"\n给你两个整数数组 nums1 和 nums2，长度分别为 n 和 m。同时给你一个正整数 k。\n如果 nums1[i] 可以被 nums2[j] * k 整除，则称数对 (i, j) 为 优质数对（0 <= i <= n - 1, 0 <= j <= m - 1）。\n返回 优质数对 的总数。\n示例 1：\n输入nums1 = [1,3,4], nums2 = [1,3,4], k = 1\n输出：5示例 2：\n输入nums1 = [1,2,4,12], nums2 = [2,4], k = 3\n输出：2\n\n提示：\n1 <= n, m <= 10^5\n1 <= nums1[i], nums2[j] <= 10^6\n1 <= k <= 10^3\n\"\"\"\n\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number}\n */\nvar numberOfPairs = function(nums1, nums2, k) {",
        "prompt_chat": "给你两个整数数组 nums1 和 nums2，长度分别为 n 和 m。同时给你一个正整数 k。\n如果 nums1[i] 可以被 nums2[j] * k 整除，则称数对 (i, j) 为 优质数对（0 <= i <= n - 1, 0 <= j <= m - 1）。\n返回 优质数对 的总数。\n示例 1：\n输入nums1 = [1,3,4], nums2 = [1,3,4], k = 1\n输出：5示例 2：\n输入nums1 = [1,2,4,12], nums2 = [2,4], k = 3\n输出：2\n\n提示：\n1 <= n, m <= 10^5\n1 <= nums1[i], nums2[j] <= 10^6\n1 <= k <= 10^3\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number}\n */\nvar numberOfPairs = function(nums1, nums2, k) {\n```",
        "solution": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number}\n */\n\nvar numberOfPairs = function(nums1, nums2, k) {\n    let d1 = new Map();\n    \n    for (let x of nums1){\n        if (x%k===0){\n            let v = x/k;\n            for (let i=1;i<Math.floor(Math.sqrt(v)+1);i++){\n                if (v%i ===0) {\n                    if (!d1.has(i)) d1.set(i,1);\n                    else d1.set(i,d1.get(i)+1);\n                    let y = v/i;\n                    if (y!=i){\n                        if (!d1.has(y)) d1.set(y,1);\n                        else d1.set(y,d1.get(y)+1);\n                    }\n                }\n            }\n        }\n    }\n    let ans = 0;\n    for (let t of nums2){\n        if (d1.has(t)) ans += d1.get(t);\n    }\n    return ans;\n\n}",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(numberOfPairs([1,3,4],[1,3,4],1), 5, \"Test 1 Error!\");\nassert.deepEqual(numberOfPairs([1,2,4,12],[2,4],3), 2, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number}\n */\nvar numberOfPairs = function(nums1, nums2, k) {",
        "function_name": "numberOfPairs",
        "difficulty_level": "Middle",
        "time": "20240526"
    },
    {
        "id": "3165",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 和一个二维数组 queries，其中 queries[i] = [posi, xi]。\n对于每个查询 i，首先将 nums[posi] 设置为 xi，然后计算查询 i 的答案，该答案为 nums 中 不包含相邻元素 的 子序列 的 最大 和。\n返回所有查询的答案之和。\n由于最终答案可能非常大，返回其对 10^9 + 7 取余 的结果。\n子序列 是指从另一个数组中删除一些或不删除元素而不改变剩余元素顺序得到的数组。\n示例 1：\n输入nums = [3,5,9], queries = [[1,-2],[0,-3]]\n输出：21示例 2：\n输入nums = [0,-1], queries = [[0,-5]]\n输出：0\n\n提示：\n1 <= nums.length <= 5 * 10^4\n-10^5 <= nums[i] <= 10^5\n1 <= queries.length <= 5 * 10^4\nqueries[i] == [posi, xi]\n0 <= posi <= nums.length - 1\n-10^5 <= xi <= 10^5\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nvar maximumSumSubsequence = function(nums, queries) {",
        "prompt_chat": "给你一个整数数组 nums 和一个二维数组 queries，其中 queries[i] = [posi, xi]。\n对于每个查询 i，首先将 nums[posi] 设置为 xi，然后计算查询 i 的答案，该答案为 nums 中 不包含相邻元素 的 子序列 的 最大 和。\n返回所有查询的答案之和。\n由于最终答案可能非常大，返回其对 10^9 + 7 取余 的结果。\n子序列 是指从另一个数组中删除一些或不删除元素而不改变剩余元素顺序得到的数组。\n示例 1：\n输入nums = [3,5,9], queries = [[1,-2],[0,-3]]\n输出：21示例 2：\n输入nums = [0,-1], queries = [[0,-5]]\n输出：0\n\n提示：\n1 <= nums.length <= 5 * 10^4\n-10^5 <= nums[i] <= 10^5\n1 <= queries.length <= 5 * 10^4\nqueries[i] == [posi, xi]\n0 <= posi <= nums.length - 1\n-10^5 <= xi <= 10^5\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nvar maximumSumSubsequence = function(nums, queries) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nvar maximumSumSubsequence = function(nums, queries) {\n    const MOD = 10**9 + 7;\n    const n = nums.length;\n    const tree = Array.from({ length: 2 << Math.ceil(Math.log2(n)) }, () => [0, 0, 0, 0]);\n\n    const dptree = (o) => {\n        tree[o][0] = Math.max(tree[2 * o][0] + tree[2 * o + 1][2], tree[2 * o][1] + tree[2 * o + 1][0]);\n        tree[o][1] = Math.max(tree[2 * o][0] + tree[2 * o + 1][3], tree[2 * o][1] + tree[2 * o + 1][1]);\n        tree[o][2] = Math.max(tree[2 * o][2] + tree[2 * o + 1][2], tree[2 * o][3] + tree[2 * o + 1][0]);\n        tree[o][3] = Math.max(tree[2 * o][2] + tree[2 * o + 1][3], tree[2 * o][3] + tree[2 * o + 1][1]);\n    };\n\n    const build = (o, l, r) => {\n        if (l === r) {\n            tree[o][3] = Math.max(nums[l], 0);\n            return;\n        }\n\n        const mid = Math.floor((l + r) / 2);\n\n        build(2 * o, l, mid);\n        build(2 * o + 1, mid + 1, r);\n\n        dptree(o);\n    };\n\n    const update = (o, l, r, i, val) => {\n        if (l === r) {\n            tree[o][3] = Math.max(val, 0);\n            return;\n        }\n\n        const mid = Math.floor((l + r) / 2);\n\n        if (i <= mid) {\n            update(2 * o, l, mid, i, val);\n        } else {\n            update(2 * o + 1, mid + 1, r, i, val);\n        }\n\n        dptree(o);\n    };\n\n    build(1, 0, n - 1);\n\n    let ans = 0;\n    for (const [j, val] of queries) {\n        update(1, 0, n - 1, j, val);\n        ans += tree[1][3];\n    }\n\n    return ans % MOD;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maximumSumSubsequence([3,5,9],[[1,-2],[0,-3]]), 21, \"Test 1 Error!\");\nassert.deepEqual(maximumSumSubsequence([0,-1],[[0,-5]]), 0, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nvar maximumSumSubsequence = function(nums, queries) {",
        "function_name": "maximumSumSubsequence",
        "difficulty_level": "Hard",
        "time": "20240526"
    },
    {
        "id": "3168",
        "prompt_base": "\"\"\"\n给你一个字符串 s，模拟每秒钟的事件 i: 如果 s[i] == 'E'，表示有一位顾客进入候诊室并占用一把椅子。如果 s[i] == 'L'，表示有一位顾客离开候诊室，从而释放一把椅子。返回保证每位进入候诊室的顾客都能有椅子坐的 最少 椅子数，假设候诊室最初是 空的 。\n示例 1：\n输入s = \"EEEEEEE\"\n输出：7示例 2：\n输入s = \"ELELEEL\"\n输出：2\n\n提示：\n1 <= s.length <= 50\n s 仅由字母 'E' 和 'L' 组成。\ns 表示一个有效的进出序列。\n\"\"\"\n\n/**\n * @param {string} s\n * @return {number}\n */\nvar minimumChairs = function(s) {",
        "prompt_chat": "给你一个字符串 s，模拟每秒钟的事件 i: 如果 s[i] == 'E'，表示有一位顾客进入候诊室并占用一把椅子。如果 s[i] == 'L'，表示有一位顾客离开候诊室，从而释放一把椅子。返回保证每位进入候诊室的顾客都能有椅子坐的 最少 椅子数，假设候诊室最初是 空的 。\n示例 1：\n输入s = \"EEEEEEE\"\n输出：7示例 2：\n输入s = \"ELELEEL\"\n输出：2\n\n提示：\n1 <= s.length <= 50\n s 仅由字母 'E' 和 'L' 组成。\ns 表示一个有效的进出序列。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar minimumChairs = function(s) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumChairs(\"EEEEEEE\"), 7, \"Test 1 Error!\");\nassert.deepEqual(minimumChairs(\"ELELEEL\"), 2, \"Test 2 Error!\");\nassert.deepEqual(minimumChairs(\"ELEELEELLL\"), 3, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} s\n * @return {number}\n */\nvar minimumChairs = function(s) {",
        "function_name": "minimumChairs",
        "difficulty_level": "Easy",
        "time": "20240602"
    },
    {
        "id": "3169",
        "prompt_base": "\"\"\"\n给你一个正整数 days，表示员工可工作的总天数（从第 1 天开始）。另给你一个二维数组 meetings，长度为 n，其中 meetings[i] = [start_i, end_i] 表示第 i 次会议的开始和结束天数（包含首尾）。\n\n返回员工可工作且没有安排会议的天数。\n\n注意：会议时间可能会有重叠。\n示例 1：\n输入days = 10, meetings = [[5,7],[1,3],[9,10]]\n输出：2示例 2：\n输入days = 5, meetings = [[2,4],[1,3]]\n输出：1\n\n提示：\n1 <= days <= 10^9 \n 1 <= meetings.length <= 10^5\nmeetings[i].length == 2\n1 <= meetings[i][0] <= meetings[i][1] <= days\n\"\"\"\n\n/**\n * @param {number} days\n * @param {number[][]} meetings\n * @return {number}\n */\nvar countDays = function(days, meetings) {",
        "prompt_chat": "给你一个正整数 days，表示员工可工作的总天数（从第 1 天开始）。另给你一个二维数组 meetings，长度为 n，其中 meetings[i] = [start_i, end_i] 表示第 i 次会议的开始和结束天数（包含首尾）。\n\n返回员工可工作且没有安排会议的天数。\n\n注意：会议时间可能会有重叠。\n示例 1：\n输入days = 10, meetings = [[5,7],[1,3],[9,10]]\n输出：2示例 2：\n输入days = 5, meetings = [[2,4],[1,3]]\n输出：1\n\n提示：\n1 <= days <= 10^9 \n 1 <= meetings.length <= 10^5\nmeetings[i].length == 2\n1 <= meetings[i][0] <= meetings[i][1] <= days\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} days\n * @param {number[][]} meetings\n * @return {number}\n */\nvar countDays = function(days, meetings) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(countDays(10,[[5,7],[1,3],[9,10]]), 2, \"Test 1 Error!\");\nassert.deepEqual(countDays(5,[[2,4],[1,3]]), 1, \"Test 2 Error!\");\nassert.deepEqual(countDays(6,[[1,6]]), 0, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} days\n * @param {number[][]} meetings\n * @return {number}\n */\nvar countDays = function(days, meetings) {",
        "function_name": "countDays",
        "difficulty_level": "Middle",
        "time": "20240602"
    },
    {
        "id": "3170",
        "prompt_base": "\"\"\"\n给你一个字符串 s 。它可能包含任意数量的 '*' 字符。你的任务是删除所有的 '*' 字符。\n\n当字符串还存在至少一个 '*' 字符时，你可以执行以下操作：删除最左边的 '*' 字符，同时删除该星号字符左边一个字典序 最小 的字符。如果有多个字典序最小的字符，你可以删除它们中的任意一个。\n\n请你返回删除所有 '*' 字符以后，剩余字符连接而成的 字典序最小 的字符串。\n示例 1：\n输入s = \"aaba*\"\n输出：\"aab\"示例 2：\n输入s = \"abc\"\n输出：\"abc\"\n\n提示：\n1 <= s.length <= 10^5 \n s 只含有小写英文字母和 '*' 字符。\n输入保证操作可以删除所有的 '*' 字符。\n\"\"\"\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar clearStars = function(s) {",
        "prompt_chat": "给你一个字符串 s 。它可能包含任意数量的 '*' 字符。你的任务是删除所有的 '*' 字符。\n\n当字符串还存在至少一个 '*' 字符时，你可以执行以下操作：删除最左边的 '*' 字符，同时删除该星号字符左边一个字典序 最小 的字符。如果有多个字典序最小的字符，你可以删除它们中的任意一个。\n\n请你返回删除所有 '*' 字符以后，剩余字符连接而成的 字典序最小 的字符串。\n示例 1：\n输入s = \"aaba*\"\n输出：\"aab\"示例 2：\n输入s = \"abc\"\n输出：\"abc\"\n\n提示：\n1 <= s.length <= 10^5 \n s 只含有小写英文字母和 '*' 字符。\n输入保证操作可以删除所有的 '*' 字符。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar clearStars = function(s) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(clearStars(\"aaba*\"), \"aab\", \"Test 1 Error!\");\nassert.deepEqual(clearStars(\"abc\"), \"abc\", \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} s\n * @return {string}\n */\nvar clearStars = function(s) {",
        "function_name": "clearStars",
        "difficulty_level": "Middle",
        "time": "20240602"
    },
    {
        "id": "3171",
        "prompt_base": "\"\"\"\n给你一个数组 nums 和一个整数 k 。你需要找到 nums 的一个 子数组 ，满足子数组中所有元素按位与运算 AND 的值与 k 的 绝对差 尽可能 小 。换言之，你需要选择一个子数组 nums[l..r] 满足 |k - (nums[l] AND nums[l + 1] ... AND nums[r])| 最小。\n\n请你返回 最小 的绝对差值。\n\n子数组是数组中连续的 非空 元素序列。\n示例 1：\n输入nums = [1,2,4,5], k = 3\n输出：1示例 2：\n输入nums = [1,2,1,2], k = 2\n输出：0\n\n提示：\n1 <= nums.length <= 10^5 \n 1 <= nums[i] <= 10^9\n1 <= k <= 10^9\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minimumDifference = function(nums, k) {",
        "prompt_chat": "给你一个数组 nums 和一个整数 k 。你需要找到 nums 的一个 子数组 ，满足子数组中所有元素按位与运算 AND 的值与 k 的 绝对差 尽可能 小 。换言之，你需要选择一个子数组 nums[l..r] 满足 |k - (nums[l] AND nums[l + 1] ... AND nums[r])| 最小。\n\n请你返回 最小 的绝对差值。\n\n子数组是数组中连续的 非空 元素序列。\n示例 1：\n输入nums = [1,2,4,5], k = 3\n输出：1示例 2：\n输入nums = [1,2,1,2], k = 2\n输出：0\n\n提示：\n1 <= nums.length <= 10^5 \n 1 <= nums[i] <= 10^9\n1 <= k <= 10^9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minimumDifference = function(nums, k) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumDifference([1,2,4,5],3), 1, \"Test 1 Error!\");\nassert.deepEqual(minimumDifference([1,2,1,2],2), 0, \"Test 2 Error!\");\nassert.deepEqual(minimumDifference([1],10), 9, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minimumDifference = function(nums, k) {",
        "function_name": "minimumDifference",
        "difficulty_level": "Hard",
        "time": "20240602"
    },
    {
        "id": "3174",
        "prompt_base": "\"\"\"\n给你一个字符串 s 。\n你的任务是重复以下操作删除 所有 数字字符：删除 第一个数字字符 以及它左边 最近 的 非数字 字符。\n请你返回删除所有数字字符以后剩下的字符串。\n示例 1：\n输入s = \"abc\"\n输出：\"abc\"示例 2：\n输入s = \"cb34\"\n输出：\"\"\n\n提示：\n1 <= s.length <= 100\ns 只包含小写英文字母和数字字符。\n输入保证所有数字都可以按以上操作被删除。\n\"\"\"\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar clearDigits = function(s) {",
        "prompt_chat": "给你一个字符串 s 。\n你的任务是重复以下操作删除 所有 数字字符：删除 第一个数字字符 以及它左边 最近 的 非数字 字符。\n请你返回删除所有数字字符以后剩下的字符串。\n示例 1：\n输入s = \"abc\"\n输出：\"abc\"示例 2：\n输入s = \"cb34\"\n输出：\"\"\n\n提示：\n1 <= s.length <= 100\ns 只包含小写英文字母和数字字符。\n输入保证所有数字都可以按以上操作被删除。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar clearDigits = function(s) {\n```",
        "solution": "/**\n * @param {string} s\n * @return {string}\n */\nvar clearDigits = function(s) {\n    let stack = []\n    for(let item of s){\n        if(item < '0' || item > '9')\n        stack.push(item)\n        else if(stack[stack.length-1] < '0' || stack[stack.length-1] > '9')\n        stack.pop()\n    }\n    return stack.join('')\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(clearDigits(\"abc\"), \"abc\", \"Test 1 Error!\");\nassert.deepEqual(clearDigits(\"cb34\"), \"\", \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {string} s\n * @return {string}\n */\nvar clearDigits = function(s) {",
        "function_name": "clearDigits",
        "difficulty_level": "Easy",
        "time": "20240608"
    },
    {
        "id": "3175",
        "prompt_base": "\"\"\"\n有 n 位玩家在进行比赛，玩家编号依次为 0 到 n - 1 。\n给你一个长度为 n 的整数数组 skills 和一个 正 整数 k ，其中 skills[i] 是第 i 位玩家的技能等级。skills 中所有整数 互不相同 。所有玩家从编号 0 到 n - 1 排成一列。\n比赛进行方式如下：\n队列中最前面两名玩家进行一场比赛，技能等级 更高 的玩家胜出。\n比赛后，获胜者保持在队列的开头，而失败者排到队列的末尾。\n这个比赛的赢家是 第一位连续 赢下 k 场比赛的玩家。\n请你返回这个比赛的赢家编号。\n示例 1：\n输入skills = [4,2,6,3,9], k = 2\n输出：2示例 2：\n输入skills = [2,5,4], k = 3\n输出：1\n\n提示：\nn == skills.length\n2 <= n <= 10^5\n1 <= k <= 10^9\n1 <= skills[i] <= 10^6\nskills 中的整数互不相同。\n\"\"\"\n\n/**\n * @param {number[]} skills\n * @param {number} k\n * @return {number}\n */\nvar findWinningPlayer = function(skills, k) {",
        "prompt_chat": "有 n 位玩家在进行比赛，玩家编号依次为 0 到 n - 1 。\n给你一个长度为 n 的整数数组 skills 和一个 正 整数 k ，其中 skills[i] 是第 i 位玩家的技能等级。skills 中所有整数 互不相同 。所有玩家从编号 0 到 n - 1 排成一列。\n比赛进行方式如下：\n队列中最前面两名玩家进行一场比赛，技能等级 更高 的玩家胜出。\n比赛后，获胜者保持在队列的开头，而失败者排到队列的末尾。\n这个比赛的赢家是 第一位连续 赢下 k 场比赛的玩家。\n请你返回这个比赛的赢家编号。\n示例 1：\n输入skills = [4,2,6,3,9], k = 2\n输出：2示例 2：\n输入skills = [2,5,4], k = 3\n输出：1\n\n提示：\nn == skills.length\n2 <= n <= 10^5\n1 <= k <= 10^9\n1 <= skills[i] <= 10^6\nskills 中的整数互不相同。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} skills\n * @param {number} k\n * @return {number}\n */\nvar findWinningPlayer = function(skills, k) {\n```",
        "solution": "var findWinningPlayer = function(skills, k) {\n    let maxSkillIndex = skills[0] > skills[1] ? 0 : 1;\n    if (k === 1) {\n        return maxSkillIndex;\n    }\n    let consecutive = 1;\n    let n = skills.length;\n    for (let i = 2; i < n; i++) {\n        if (skills[maxSkillIndex] > skills[i]) {\n            consecutive++;\n            if (consecutive === k) {\n                return maxSkillIndex;\n            }\n        } else {\n            maxSkillIndex = i;\n            consecutive = 1;\n        }\n    }\n    return maxSkillIndex;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(findWinningPlayer([4,2,6,3,9],2), 2, \"Test 1 Error!\");\nassert.deepEqual(findWinningPlayer([2,5,4],3), 1, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} skills\n * @param {number} k\n * @return {number}\n */\nvar findWinningPlayer = function(skills, k) {",
        "function_name": "findWinningPlayer",
        "difficulty_level": "Middle",
        "time": "20240608"
    },
    {
        "id": "3176",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 和一个 非负 整数 k 。如果一个整数序列 seq 满足在范围下标范围 [0, seq.length - 2] 中存在 不超过 k 个下标 i 满足 seq[i] != seq[i + 1] ，那么我们称这个整数序列为 好 序列。\n请你返回 nums 中 好 n子序列 的最长长度\n示例 1：\n输入nums = [1,2,1,1,3], k = 2\n输出：4示例 2：\n输入nums = [1,2,3,4,5,1], k = 0\n输出：2\n\n提示：\n1 <= nums.length <= 500\n1 <= nums[i] <= 10^9\n0 <= k <= min(nums.length, 25)\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumLength = function(nums, k) {",
        "prompt_chat": "给你一个整数数组 nums 和一个 非负 整数 k 。如果一个整数序列 seq 满足在范围下标范围 [0, seq.length - 2] 中存在 不超过 k 个下标 i 满足 seq[i] != seq[i + 1] ，那么我们称这个整数序列为 好 序列。\n请你返回 nums 中 好 n子序列 的最长长度\n示例 1：\n输入nums = [1,2,1,1,3], k = 2\n输出：4示例 2：\n输入nums = [1,2,3,4,5,1], k = 0\n输出：2\n\n提示：\n1 <= nums.length <= 500\n1 <= nums[i] <= 10^9\n0 <= k <= min(nums.length, 25)\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumLength = function(nums, k) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumLength = function(nums, k) {\n    let n = nums.length \n    // dp[i][m]含义为以nums[i]为结尾的子序列，有至多k对相邻元素不同的最大子序列长度\n    let dp = new Array(n).fill(0).map(() => new Array(k+1).fill(0))\n    //初始化\n    for(let i = 0;i < n;i ++)\n    dp[i][0] = 1\n    for(let i = 0;i < n;i ++){\n        // 枚举j < i\n        for(let j = i - 1;j >= 0;j --){\n            if(nums[i] == nums[j]){ //nums[j] == nums[i]说明nums[j]已经有m对相邻元素不同\n                for(let m = 0;m <= k;m ++)\n                dp[i][m] = Math.max(dp[i][m],dp[j][m]+1)\n            }else{ //nums[j] !== nums[i]说明nums[j]只有m-1对相邻元素不同\n                for(let m = 1;m <=k;m ++)\n                dp[i][m] = Math.max(dp[i][m],dp[j][m-1]+1)\n            }\n        }\n    }\n    let maxLen = 1\n    for(let i = 0;i < n;i ++){\n        for(let m = 0;m <= k;m ++){\n            maxLen = Math.max(maxLen,dp[i][m])\n        }\n    }\n    return maxLen\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maximumLength([1,2,1,1,3],2), 4, \"Test 1 Error!\");\nassert.deepEqual(maximumLength([1,2,3,4,5,1],0), 2, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumLength = function(nums, k) {",
        "function_name": "maximumLength",
        "difficulty_level": "Middle",
        "time": "20240608"
    },
    {
        "id": "3177",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 和一个 非负 整数 k 。如果一个整数序列 seq 满足在范围下标范围 [0, seq.length - 2] 中存在 不超过 k 个下标 i 满足 seq[i] != seq[i + 1] ，那么我们称这个整数序列为 好 序列。\n请你返回 nums 中 好 子序列 的最长长度\n示例 1：\n输入nums = [1,2,1,1,3], k = 2\n输出：4示例 2：\n输入nums = [1,2,3,4,5,1], k = 0\n输出：2\n\n提示：\n1 <= nums.length <= 5 * 10^3\n1 <= nums[i] <= 10^9\n0 <= k <= min(50, nums.length)\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumLength = function(nums, k) {",
        "prompt_chat": "给你一个整数数组 nums 和一个 非负 整数 k 。如果一个整数序列 seq 满足在范围下标范围 [0, seq.length - 2] 中存在 不超过 k 个下标 i 满足 seq[i] != seq[i + 1] ，那么我们称这个整数序列为 好 序列。\n请你返回 nums 中 好 子序列 的最长长度\n示例 1：\n输入nums = [1,2,1,1,3], k = 2\n输出：4示例 2：\n输入nums = [1,2,3,4,5,1], k = 0\n输出：2\n\n提示：\n1 <= nums.length <= 5 * 10^3\n1 <= nums[i] <= 10^9\n0 <= k <= min(50, nums.length)\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumLength = function(nums, k) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumLength = function(nums, k) {\n    const numToDp = new Map();\n    const maxLength = new Array(k + 1).fill(0);\n    for (const num of nums) {\n        if (!numToDp.has(num)) {\n            numToDp.set(num, new Array(k + 1).fill(0));\n        }\n        const dp = numToDp.get(num);\n        for (let i = k; i >= 0; i--) {\n            dp[i]++;\n            if (i > 0) {\n                dp[i] = Math.max(dp[i], maxLength[i - 1] + 1);\n            }\n            maxLength[i] = Math.max(maxLength[i], dp[i]);\n        }\n    }\n    return maxLength[k];\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maximumLength([1,2,1,1,3],2), 4, \"Test 1 Error!\");\nassert.deepEqual(maximumLength([1,2,3,4,5,1],0), 2, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumLength = function(nums, k) {",
        "function_name": "maximumLength",
        "difficulty_level": "Hard",
        "time": "20240608"
    },
    {
        "id": "3178",
        "prompt_base": "\"\"\"\n给你两个 正整数 n 和 k。有 n 个编号从 0 到 n - 1 的孩子按顺序从左到右站成一队。\n最初，编号为 0 的孩子拿着一个球，并且向右传球。每过一秒，拿着球的孩子就会将球传给他旁边的孩子。一旦球到达队列的 任一端 ，即编号为 0 的孩子或编号为 n - 1 的孩子处，传球方向就会 反转 。\n返回 k 秒后接到球的孩子的编号。\n示例 1：\n输入n = 3, k = 5\n输出：1示例 2：\n输入n = 5, k = 6\n输出：2\n\n提示：\n2 <= n <= 50\n1 <= k <= 50\n\"\"\"\n\n/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar numberOfChild = function(n, k) {",
        "prompt_chat": "给你两个 正整数 n 和 k。有 n 个编号从 0 到 n - 1 的孩子按顺序从左到右站成一队。\n最初，编号为 0 的孩子拿着一个球，并且向右传球。每过一秒，拿着球的孩子就会将球传给他旁边的孩子。一旦球到达队列的 任一端 ，即编号为 0 的孩子或编号为 n - 1 的孩子处，传球方向就会 反转 。\n返回 k 秒后接到球的孩子的编号。\n示例 1：\n输入n = 3, k = 5\n输出：1示例 2：\n输入n = 5, k = 6\n输出：2\n\n提示：\n2 <= n <= 50\n1 <= k <= 50\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar numberOfChild = function(n, k) {\n```",
        "solution": "var numberOfChild = function(n, k) {\n    let num = 0, direction = 1;\n    while (k > 0) {\n        if (num + direction < 0 || num + direction >= n) {\n            direction *= -1;\n        }\n        num += direction;\n        k--;\n    }\n    return num;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(numberOfChild(3,5), 1, \"Test 1 Error!\");\nassert.deepEqual(numberOfChild(5,6), 2, \"Test 2 Error!\");\nassert.deepEqual(numberOfChild(4,2), 2, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar numberOfChild = function(n, k) {",
        "function_name": "numberOfChild",
        "difficulty_level": "Easy",
        "time": "20240609"
    },
    {
        "id": "3179",
        "prompt_base": "\"\"\"\n给你两个整数 n 和 k。\n最初，你有一个长度为 n 的整数数组 a，对所有 0 <= i <= n - 1，都有 a[i] = 1 。每过一秒，你会同时更新每个元素为其前面所有元素的和加上该元素本身。例如，一秒后，a[0] 保持不变，a[1] 变为 a[0] + a[1]，a[2] 变为 a[0] + a[1] + a[2]，以此类推。\n返回 k 秒后 a[n - 1] 的值。\n由于答案可能非常大，返回其对 10^9 + 7 取余 后的结果。\n示例 1：\n输入n = 4, k = 5\n输出：56示例 2：\n输入n = 5, k = 3\n输出：35\n\n提示：\n1 <= n, k <= 1000\n\"\"\"\n\n/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar valueAfterKSeconds = function(n, k) {",
        "prompt_chat": "给你两个整数 n 和 k。\n最初，你有一个长度为 n 的整数数组 a，对所有 0 <= i <= n - 1，都有 a[i] = 1 。每过一秒，你会同时更新每个元素为其前面所有元素的和加上该元素本身。例如，一秒后，a[0] 保持不变，a[1] 变为 a[0] + a[1]，a[2] 变为 a[0] + a[1] + a[2]，以此类推。\n返回 k 秒后 a[n - 1] 的值。\n由于答案可能非常大，返回其对 10^9 + 7 取余 后的结果。\n示例 1：\n输入n = 4, k = 5\n输出：56示例 2：\n输入n = 5, k = 3\n输出：35\n\n提示：\n1 <= n, k <= 1000\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar valueAfterKSeconds = function(n, k) {\n```",
        "solution": "/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar valueAfterKSeconds = function(n, k) {\n    if (k === 0) return 1;\n    const mode = 10 ** 9 + 7;\n    let cur = [];\n    for (let i = 1; i <= n; i++) {\n        cur.push(i);\n    }\n    let temp = [];\n    k--;\n    while(k--) {\n        temp[0] = 1;\n        for (let i = 1 ; i < n ;i++) {\n            temp[i] = (temp[i - 1] + cur[i]) % mode;\n        }\n        cur = temp;\n    }\n    return cur[n - 1];\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(valueAfterKSeconds(4,5), 56, \"Test 1 Error!\");\nassert.deepEqual(valueAfterKSeconds(5,3), 35, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar valueAfterKSeconds = function(n, k) {",
        "function_name": "valueAfterKSeconds",
        "difficulty_level": "Middle",
        "time": "20240609"
    },
    {
        "id": "3180",
        "prompt_base": "\"\"\"\n给你一个整数数组 rewardValues，长度为 n，代表奖励的值。\n最初，你的总奖励 x 为 0，所有下标都是 未标记 的。你可以执行以下操作 任意次 ：\n从区间 [0, n - 1] 中选择一个 未标记 的下标 i。\n如果 rewardValues[i] 大于 你当前的总奖励 x，则将 rewardValues[i] 加到 x 上（即 x = x + rewardValues[i]），并 标记 下标 i。\n以整数形式返回执行最优操作能够获得的 最大 总奖励。\n示例 1：\n输入rewardValues = [1,1,3,3]\n输出：4示例 2：\n输入rewardValues = [1,6,4,3,2]\n输出：11\n\n提示：\n1 <= rewardValues.length <= 2000\n1 <= rewardValues[i] <= 2000\n\"\"\"\n\n/**\n * @param {number[]} rewardValues\n * @return {number}\n */\nvar maxTotalReward = function(rewardValues) {",
        "prompt_chat": "给你一个整数数组 rewardValues，长度为 n，代表奖励的值。\n最初，你的总奖励 x 为 0，所有下标都是 未标记 的。你可以执行以下操作 任意次 ：\n从区间 [0, n - 1] 中选择一个 未标记 的下标 i。\n如果 rewardValues[i] 大于 你当前的总奖励 x，则将 rewardValues[i] 加到 x 上（即 x = x + rewardValues[i]），并 标记 下标 i。\n以整数形式返回执行最优操作能够获得的 最大 总奖励。\n示例 1：\n输入rewardValues = [1,1,3,3]\n输出：4示例 2：\n输入rewardValues = [1,6,4,3,2]\n输出：11\n\n提示：\n1 <= rewardValues.length <= 2000\n1 <= rewardValues[i] <= 2000\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} rewardValues\n * @return {number}\n */\nvar maxTotalReward = function(rewardValues) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maxTotalReward([1,1,3,3]), 4, \"Test 1 Error!\");\nassert.deepEqual(maxTotalReward([1,6,4,3,2]), 11, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} rewardValues\n * @return {number}\n */\nvar maxTotalReward = function(rewardValues) {",
        "function_name": "maxTotalReward",
        "difficulty_level": "Middle",
        "time": "20240609"
    },
    {
        "id": "3181",
        "prompt_base": "\"\"\"\n给你一个整数数组 rewardValues，长度为 n，代表奖励的值。最初，你的总奖励 x 为 0，所有下标都是 未标记 的。你可以执行以下操作 任意次 ：\n从区间 [0, n - 1] 中选择一个 未标记 的下标 i。\n如果 rewardValues[i] 大于 你当前的总奖励 x，则将 rewardValues[i] 加到 x 上（即 x = x + rewardValues[i]），并 标记 下标 i。\n以整数形式返回执行最优操作能够获得的 最大 总奖励。\n示例 1：\n输入rewardValues = [1,1,3,3]\n输出：4示例 2：\n输入rewardValues = [1,6,4,3,2]\n输出：11\n\n提示：\n1 <= rewardValues.length <= 5 * 10^4\n1 <= rewardValues[i] <= 5 * 10^4\n\"\"\"\n\n/**\n * @param {number[]} rewardValues\n * @return {number}\n */\nvar maxTotalReward = function(rewardValues) {",
        "prompt_chat": "给你一个整数数组 rewardValues，长度为 n，代表奖励的值。最初，你的总奖励 x 为 0，所有下标都是 未标记 的。你可以执行以下操作 任意次 ：\n从区间 [0, n - 1] 中选择一个 未标记 的下标 i。\n如果 rewardValues[i] 大于 你当前的总奖励 x，则将 rewardValues[i] 加到 x 上（即 x = x + rewardValues[i]），并 标记 下标 i。\n以整数形式返回执行最优操作能够获得的 最大 总奖励。\n示例 1：\n输入rewardValues = [1,1,3,3]\n输出：4示例 2：\n输入rewardValues = [1,6,4,3,2]\n输出：11\n\n提示：\n1 <= rewardValues.length <= 5 * 10^4\n1 <= rewardValues[i] <= 5 * 10^4\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} rewardValues\n * @return {number}\n */\nvar maxTotalReward = function(rewardValues) {\n```",
        "solution": "var maxTotalReward = function(rewardValues) {\n    const queue = [...new Set(rewardValues)]\n    queue.sort((a, b) => a - b)\n    let ans = BigInt(1)\n    for (const num of queue) {\n        ans |= (ans & ((BigInt(1) << BigInt(num)) - BigInt(1))) << BigInt(num)\n    }\n    return ans.toString(2).length - 1\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maxTotalReward([1,1,3,3]), 4, \"Test 1 Error!\");\nassert.deepEqual(maxTotalReward([1,6,4,3,2]), 11, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} rewardValues\n * @return {number}\n */\nvar maxTotalReward = function(rewardValues) {",
        "function_name": "maxTotalReward",
        "difficulty_level": "Hard",
        "time": "20240609"
    },
    {
        "id": "3184",
        "prompt_base": "\"\"\"\n给你一个整数数组 hours，表示以 小时 为单位的时间，返回一个整数，表示满足 i < j 且 hours[i] + hours[j] 构成 整天 的下标对 i, j 的数目。\n整天 定义为时间持续时间是 24 小时的 整数倍 。\n例如，1 天是 24 小时，2 天是 48 小时，3 天是 72 小时，以此类推。\n示例 1：\n输入hours = [12,12,30,24,24]\n输出：2示例 2：\n输入hours = [72,48,24,3]\n输出：3\n\n提示：\n1 <= hours.length <= 100\n1 <= hours[i] <= 10^9\n\"\"\"\n\n/**\n * @param {number[]} hours\n * @return {number}\n */\nvar countCompleteDayPairs = function(hours) {",
        "prompt_chat": "给你一个整数数组 hours，表示以 小时 为单位的时间，返回一个整数，表示满足 i < j 且 hours[i] + hours[j] 构成 整天 的下标对 i, j 的数目。\n整天 定义为时间持续时间是 24 小时的 整数倍 。\n例如，1 天是 24 小时，2 天是 48 小时，3 天是 72 小时，以此类推。\n示例 1：\n输入hours = [12,12,30,24,24]\n输出：2示例 2：\n输入hours = [72,48,24,3]\n输出：3\n\n提示：\n1 <= hours.length <= 100\n1 <= hours[i] <= 10^9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} hours\n * @return {number}\n */\nvar countCompleteDayPairs = function(hours) {\n```",
        "solution": "/**\n * @param {number[]} hours\n * @return {number}\n */\nvar countCompleteDayPairs = function(hours) {\n    let len= hours.length\n let i =0\n let j= 0\n let cout =0\n for (; i < len;) {\n     j++\nif (i>=j){j++}\nif (j>=len) {\ni++\nj = i + 1\n}\nif ((hours[i] + hours[j]) % 24 == 0){\n    cout++\n}\n}\nreturn cout\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(countCompleteDayPairs([12,12,30,24,24]), 2, \"Test 1 Error!\");\nassert.deepEqual(countCompleteDayPairs([72,48,24,3]), 3, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} hours\n * @return {number}\n */\nvar countCompleteDayPairs = function(hours) {",
        "function_name": "countCompleteDayPairs",
        "difficulty_level": "Easy",
        "time": "20240616"
    },
    {
        "id": "3185",
        "prompt_base": "\"\"\"\n给你一个整数数组 hours，表示以 小时 为单位的时间，返回一个整数，表示满足 i < j 且 hours[i] + hours[j] 构成 整天 的下标对 i, j 的数目。\n整天 定义为时间持续时间是 24 小时的 整数倍 。\n例如，1 天是 24 小时，2 天是 48 小时，3 天是 72 小时，以此类推。\n示例 1：\n输入hours = [12,12,30,24,24]\n输出：2示例 2：\n输入hours = [72,48,24,3]\n输出：3\n\n提示：\n1 <= hours.length <= 5 * 10^5\n1 <= hours[i] <= 10^9\n\"\"\"\n\n/**\n * @param {number[]} hours\n * @return {number}\n */\nvar countCompleteDayPairs = function(hours) {",
        "prompt_chat": "给你一个整数数组 hours，表示以 小时 为单位的时间，返回一个整数，表示满足 i < j 且 hours[i] + hours[j] 构成 整天 的下标对 i, j 的数目。\n整天 定义为时间持续时间是 24 小时的 整数倍 。\n例如，1 天是 24 小时，2 天是 48 小时，3 天是 72 小时，以此类推。\n示例 1：\n输入hours = [12,12,30,24,24]\n输出：2示例 2：\n输入hours = [72,48,24,3]\n输出：3\n\n提示：\n1 <= hours.length <= 5 * 10^5\n1 <= hours[i] <= 10^9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} hours\n * @return {number}\n */\nvar countCompleteDayPairs = function(hours) {\n```",
        "solution": "function countCompleteDayPairs(hours) {\n    let res = 0\n    const map = {}\n    for(const h of hours) {\n        if(map[(24 - h%24)%24]) {\n            res += map[(24 - h%24)%24]\n        }\n        map[h % 24] = (map[h % 24] || 0) + 1\n    }\n    return res\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(countCompleteDayPairs([12,12,30,24,24]), 2, \"Test 1 Error!\");\nassert.deepEqual(countCompleteDayPairs([72,48,24,3]), 3, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} hours\n * @return {number}\n */\nvar countCompleteDayPairs = function(hours) {",
        "function_name": "countCompleteDayPairs",
        "difficulty_level": "Middle",
        "time": "20240616"
    },
    {
        "id": "3186",
        "prompt_base": "\"\"\"\n一个魔法师有许多不同的咒语。\n给你一个数组 power ，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。\n已知魔法师使用伤害值为 power[i] 的咒语时，他们就 不能 使用伤害为 power[i] - 2 ，power[i] - 1 ，power[i] + 1 或者 power[i] + 2 的咒语。\n每个咒语最多只能被使用 一次 。\n请你返回这个魔法师可以达到的伤害值之和的 最大值 。\n示例 1：\n输入power = [1,1,3,4]\n输出：6示例 2：\n输入power = [7,1,6,6]\n输出：13\n\n提示：\n1 <= power.length <= 10^5\n1 <= power[i] <= 10^9\n\"\"\"\n\n/**\n * @param {number[]} power\n * @return {number}\n */\nvar maximumTotalDamage = function(power) {",
        "prompt_chat": "一个魔法师有许多不同的咒语。\n给你一个数组 power ，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。\n已知魔法师使用伤害值为 power[i] 的咒语时，他们就 不能 使用伤害为 power[i] - 2 ，power[i] - 1 ，power[i] + 1 或者 power[i] + 2 的咒语。\n每个咒语最多只能被使用 一次 。\n请你返回这个魔法师可以达到的伤害值之和的 最大值 。\n示例 1：\n输入power = [1,1,3,4]\n输出：6示例 2：\n输入power = [7,1,6,6]\n输出：13\n\n提示：\n1 <= power.length <= 10^5\n1 <= power[i] <= 10^9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} power\n * @return {number}\n */\nvar maximumTotalDamage = function(power) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maximumTotalDamage([1,1,3,4]), 6, \"Test 1 Error!\");\nassert.deepEqual(maximumTotalDamage([7,1,6,6]), 13, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} power\n * @return {number}\n */\nvar maximumTotalDamage = function(power) {",
        "function_name": "maximumTotalDamage",
        "difficulty_level": "Middle",
        "time": "20240616"
    },
    {
        "id": "3187",
        "prompt_base": "\"\"\"\n数组 arr 中 大于 前面和后面相邻元素的元素被称为 峰值 元素。\n给你一个整数数组 nums 和一个二维整数数组 queries 。\n你需要处理以下两种类型的操作：\nqueries[i] = [1, l_i, r_i] ，求出子数组 nums[l_i..r_i] 中 峰值 元素的数目。\nqueries[i] = [2, index_i, val_i] ，将 nums[index_i] 变为 val_i 。\n请你返回一个数组 answer ，它依次包含每一个第一种操作的答案。\n注意：子数组中 第一个 和 最后一个 元素都 不是 峰值元素。\n示例 1：\n输入nums = [3,1,4,2,5], queries = [[2,3,4],[1,0,4]]\n输出：[0]示例 2：\n输入nums = [4,1,4,2,1,5], queries = [[2,2,4],[1,0,2],[1,0,4]]\n输出：[0,1]\n\n提示：\n3 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\n1 <= queries.length <= 10^5\nqueries[i][0] == 1 或者 queries[i][0] == 2\n对于所有的 i ，都有：\nqueries[i][0] == 1 ：0 <= queries[i][1] <= queries[i][2] <= nums.length - 1\nqueries[i][0] == 2 ：0 <= queries[i][1] <= nums.length - 1, 1 <= queries[i][2] <= 10^5\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar countOfPeaks = function(nums, queries) {",
        "prompt_chat": "数组 arr 中 大于 前面和后面相邻元素的元素被称为 峰值 元素。\n给你一个整数数组 nums 和一个二维整数数组 queries 。\n你需要处理以下两种类型的操作：\nqueries[i] = [1, l_i, r_i] ，求出子数组 nums[l_i..r_i] 中 峰值 元素的数目。\nqueries[i] = [2, index_i, val_i] ，将 nums[index_i] 变为 val_i 。\n请你返回一个数组 answer ，它依次包含每一个第一种操作的答案。\n注意：子数组中 第一个 和 最后一个 元素都 不是 峰值元素。\n示例 1：\n输入nums = [3,1,4,2,5], queries = [[2,3,4],[1,0,4]]\n输出：[0]示例 2：\n输入nums = [4,1,4,2,1,5], queries = [[2,2,4],[1,0,2],[1,0,4]]\n输出：[0,1]\n\n提示：\n3 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\n1 <= queries.length <= 10^5\nqueries[i][0] == 1 或者 queries[i][0] == 2\n对于所有的 i ，都有：\nqueries[i][0] == 1 ：0 <= queries[i][1] <= queries[i][2] <= nums.length - 1\nqueries[i][0] == 2 ：0 <= queries[i][1] <= nums.length - 1, 1 <= queries[i][2] <= 10^5\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar countOfPeaks = function(nums, queries) {\n```",
        "solution": "const MAX = 1_000_00n\nconst queue = []\nfor (let oMask = 1n, length = 1n; length < MAX; oMask |= oMask << length, length <<= 1n) {\n    let mask = oMask\n    for (let l = length; l < MAX; l <<= 1n) mask |= mask << (l << 1n)\n    queue.push([mask, mask << length, length])\n}\n\nfunction bitCount(num) {\n    for (const [mask, xMask, length] of queue) {\n        num = ((xMask & num) >> length) + (mask & num)\n    }\n    return num\n}\n\nvar countOfPeaks = function(nums, queries) {\n    const n = nums.length\n    if (n <= 2) return queries.filter(it => it[0] == 1).fill(0)\n    \n    let tree = 0n;\n    for (let index = 1n, m = BigInt(n - 1); index < m; index++) {\n        if (nums[index - 1n] < nums[index] && nums[index] > nums[index + 1n]) tree |= 1n << index;\n    }\n\n    const ans = []\n    let index = -1, flag1 = false, flag2 = false;\n    for (const [a,b,c] of queries) {\n        if (a == 1) {\n            if (c - b > 1) ans.push(bitCount((tree & ((1n << BigInt(c)) - 1n)) >> BigInt(b + 1)));\n            else ans.push(0);\n        } else {\n            if (nums[b] == c) continue;\n            if (b != 0 && b != n - 1) {\n                index = b\n                flag1 = nums[index - 1] < nums[index] && nums[index] > nums[index + 1]\n                flag2 = nums[index - 1] < c && c > nums[index + 1]\n                if (flag1 != flag2) tree ^= 1n << BigInt(index)\n            }\n            if (b > 1) {\n                index = b - 1\n                flag1 = nums[index - 1] < nums[index] && nums[index] > nums[index + 1]\n                flag2 = nums[index - 1] < nums[index] && nums[index] > c\n                if (flag1 != flag2) tree ^= 1n << BigInt(index)\n            }\n            if (b < n - 2) {\n                index = b + 1\n                flag1 = nums[index - 1] < nums[index] && nums[index] > nums[index + 1]\n                flag2 = c < nums[index] && nums[index] > nums[index + 1]\n                if (flag1 != flag2) tree ^= 1n << BigInt(index)\n            }\n            nums[b] = c;\n        }\n    }\n    return ans;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(countOfPeaks([3,1,4,2,5],[[2,3,4],[1,0,4]]), [0], \"Test 1 Error!\");\nassert.deepEqual(countOfPeaks([4,1,4,2,1,5],[[2,2,4],[1,0,2],[1,0,4]]), [0,1], \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar countOfPeaks = function(nums, queries) {",
        "function_name": "countOfPeaks",
        "difficulty_level": "Hard",
        "time": "20240616"
    },
    {
        "id": "3190",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 。一次操作中，你可以将 nums 中的 任意 一个元素增加或者减少 1 。\n请你返回将 nums 中所有元素都可以被 3 整除的 最少 操作次数。\n示例 1：\n输入nums = [1,2,3,4]\n输出：3示例 2：\n输入nums = [3,6,9]\n输出：0\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 50\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumOperations = function(nums) {",
        "prompt_chat": "给你一个整数数组 nums 。一次操作中，你可以将 nums 中的 任意 一个元素增加或者减少 1 。\n请你返回将 nums 中所有元素都可以被 3 整除的 最少 操作次数。\n示例 1：\n输入nums = [1,2,3,4]\n输出：3示例 2：\n输入nums = [3,6,9]\n输出：0\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 50\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumOperations = function(nums) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumOperations([1,2,3,4]), 3, \"Test 1 Error!\");\nassert.deepEqual(minimumOperations([3,6,9]), 0, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumOperations = function(nums) {",
        "function_name": "minimumOperations",
        "difficulty_level": "Easy",
        "time": "20240622"
    },
    {
        "id": "3191",
        "prompt_base": "\"\"\"\n给你一个二进制数组 nums 。你可以对数组执行以下操作 任意 次（也可以 0 次）：\n选择数组中 任意连续 3 个元素，并将它们 全部反转 。\n反转 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。\n请你返回将 nums 中所有元素变为 1 的 最少 操作次数。如果无法全部变成 1 ，返回 -1 。\n示例 1：\n输入nums = [0,1,1,1,0,0]\n输出：3示例 2：\n输入nums = [0,1,1,1]\n输出：-1\n\n提示：\n3 <= nums.length <= 10^5\n0 <= nums[i] <= 1\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minOperations = function(nums) {",
        "prompt_chat": "给你一个二进制数组 nums 。你可以对数组执行以下操作 任意 次（也可以 0 次）：\n选择数组中 任意连续 3 个元素，并将它们 全部反转 。\n反转 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。\n请你返回将 nums 中所有元素变为 1 的 最少 操作次数。如果无法全部变成 1 ，返回 -1 。\n示例 1：\n输入nums = [0,1,1,1,0,0]\n输出：3示例 2：\n输入nums = [0,1,1,1]\n输出：-1\n\n提示：\n3 <= nums.length <= 10^5\n0 <= nums[i] <= 1\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minOperations = function(nums) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minOperations = function(nums) {\n    let ans = 0, len = nums.length;\n    for (let i = 0; i < len - 2; i++) {\n        if (nums[i] === 0) {\n            nums[i + 1] ^= 1;\n            nums[i + 2] ^= 1;\n            ans++;\n        }\n    }\n    if (nums[len - 1] === 0 || nums[len - 2] === 0) {\n        return -1;\n    }\n    return ans;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minOperations([0,1,1,1,0,0]), 3, \"Test 1 Error!\");\nassert.deepEqual(minOperations([0,1,1,1]), -1, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minOperations = function(nums) {",
        "function_name": "minOperations",
        "difficulty_level": "Middle",
        "time": "20240622"
    },
    {
        "id": "3192",
        "prompt_base": "\"\"\"\n给你一个二进制数组 nums 。你可以对数组执行以下操作 任意 次（也可以 0 次）：\n选择数组中 任意 一个下标 i ，并将从下标 i 开始一直到数组末尾 所有 元素 反转 。\n反转 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。\n请你返回将 nums 中所有元素变为 1 的 最少 操作次数。\n示例 1：\n输入nums = [0,1,1,0,1]\n输出：4示例 2：\n输入nums = [1,0,0,0]\n输出：1\n\n提示：\n1 <= nums.length <= 10^5\n0 <= nums[i] <= 1\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minOperations = function(nums) {",
        "prompt_chat": "给你一个二进制数组 nums 。你可以对数组执行以下操作 任意 次（也可以 0 次）：\n选择数组中 任意 一个下标 i ，并将从下标 i 开始一直到数组末尾 所有 元素 反转 。\n反转 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。\n请你返回将 nums 中所有元素变为 1 的 最少 操作次数。\n示例 1：\n输入nums = [0,1,1,0,1]\n输出：4示例 2：\n输入nums = [1,0,0,0]\n输出：1\n\n提示：\n1 <= nums.length <= 10^5\n0 <= nums[i] <= 1\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minOperations = function(nums) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minOperations([0,1,1,0,1]), 4, \"Test 1 Error!\");\nassert.deepEqual(minOperations([1,0,0,0]), 1, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minOperations = function(nums) {",
        "function_name": "minOperations",
        "difficulty_level": "Middle",
        "time": "20240622"
    },
    {
        "id": "3193",
        "prompt_base": "\"\"\"\n给你一个整数 n 和一个二维数组 requirements ，其中 requirements[i] = [end_i, cnt_i] 表示这个要求中的末尾下标和 逆序对 的数目。\n整数数组 nums 中一个下标对 (i, j) 如果满足以下条件，那么它们被称为一个 逆序对 ：\ni < j 且 nums[i] > nums[j]\n请你返回 [0, 1, 2, ..., n - 1] 的 排列 perm 的数目，满足对 所有 的 requirements[i] 都有 perm[0..end_i] 恰好有 cnt_i 个逆序对。\n由于答案可能会很大，将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入n = 3, requirements = [[2,2],[0,0]]\n输出：2示例 2：\n输入n = 3, requirements = [[2,2],[1,1],[0,0]]\n输出：1\n\n提示：\n2 <= n <= 300\n1 <= requirements.length <= n\nrequirements[i] = [end_i, cnt_i]\n0 <= end_i <= n - 1\n0 <= cnt_i <= 400\n输入保证至少有一个 i 满足 end_i == n - 1 。\n输入保证所有的 end_i 互不相同。\n\"\"\"\n\n/**\n * @param {number} n\n * @param {number[][]} requirements\n * @return {number}\n */\nvar numberOfPermutations = function(n, requirements) {",
        "prompt_chat": "给你一个整数 n 和一个二维数组 requirements ，其中 requirements[i] = [end_i, cnt_i] 表示这个要求中的末尾下标和 逆序对 的数目。\n整数数组 nums 中一个下标对 (i, j) 如果满足以下条件，那么它们被称为一个 逆序对 ：\ni < j 且 nums[i] > nums[j]\n请你返回 [0, 1, 2, ..., n - 1] 的 排列 perm 的数目，满足对 所有 的 requirements[i] 都有 perm[0..end_i] 恰好有 cnt_i 个逆序对。\n由于答案可能会很大，将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入n = 3, requirements = [[2,2],[0,0]]\n输出：2示例 2：\n输入n = 3, requirements = [[2,2],[1,1],[0,0]]\n输出：1\n\n提示：\n2 <= n <= 300\n1 <= requirements.length <= n\nrequirements[i] = [end_i, cnt_i]\n0 <= end_i <= n - 1\n0 <= cnt_i <= 400\n输入保证至少有一个 i 满足 end_i == n - 1 。\n输入保证所有的 end_i 互不相同。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} n\n * @param {number[][]} requirements\n * @return {number}\n */\nvar numberOfPermutations = function(n, requirements) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(numberOfPermutations(3,[[2,2],[0,0]]), 2, \"Test 1 Error!\");\nassert.deepEqual(numberOfPermutations(3,[[2,2],[1,1],[0,0]]), 1, \"Test 2 Error!\");\nassert.deepEqual(numberOfPermutations(2,[[0,0],[1,0]]), 1, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} n\n * @param {number[][]} requirements\n * @return {number}\n */\nvar numberOfPermutations = function(n, requirements) {",
        "function_name": "numberOfPermutations",
        "difficulty_level": "Hard",
        "time": "20240622"
    },
    {
        "id": "3194",
        "prompt_base": "\"\"\"\n你有一个初始为空的浮点数数组 averages。另给你一个包含 n 个整数的数组 nums，其中 n 为偶数。\n你需要重复以下步骤 n / 2 次：\n从 nums 中移除 最小 的元素 minElement 和 最大 的元素 maxElement。\n将 (minElement + maxElement) / 2 加入到 averages 中。\n返回 averages 中的 最小 元素。\n示例 1：\n输入nums = [7,8,3,4,15,13,4,1]\n输出：5.5示例 2：\n输入nums = [1,9,8,3,10,5]\n输出：5.5\n\n提示：\n2 <= n == nums.length <= 50\nn 为偶数。\n1 <= nums[i] <= 50\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumAverage = function(nums) {",
        "prompt_chat": "你有一个初始为空的浮点数数组 averages。另给你一个包含 n 个整数的数组 nums，其中 n 为偶数。\n你需要重复以下步骤 n / 2 次：\n从 nums 中移除 最小 的元素 minElement 和 最大 的元素 maxElement。\n将 (minElement + maxElement) / 2 加入到 averages 中。\n返回 averages 中的 最小 元素。\n示例 1：\n输入nums = [7,8,3,4,15,13,4,1]\n输出：5.5示例 2：\n输入nums = [1,9,8,3,10,5]\n输出：5.5\n\n提示：\n2 <= n == nums.length <= 50\nn 为偶数。\n1 <= nums[i] <= 50\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumAverage = function(nums) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumAverage([7,8,3,4,15,13,4,1]), 5.5, \"Test 1 Error!\");\nassert.deepEqual(minimumAverage([1,9,8,3,10,5]), 5.5, \"Test 2 Error!\");\nassert.deepEqual(minimumAverage([1,2,3,7,8,9]), 5.0, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumAverage = function(nums) {",
        "function_name": "minimumAverage",
        "difficulty_level": "Easy",
        "time": "20240623"
    },
    {
        "id": "3195",
        "prompt_base": "\"\"\"\n给你一个二维 二进制 数组 grid。请你找出一个边在水平方向和竖直方向上、面积 最小 的矩形，并且满足 grid 中所有的 1 都在矩形的内部。\n返回这个矩形可能的 最小 面积。\n示例 1：\n输入grid = [[0,1,0],[1,0,1]]\n输出：6示例 2：\n输入grid = [[0,0],[1,0]]\n输出：1\n\n提示：\n1 <= grid.length, grid[i].length <= 1000\ngrid[i][j] 是 0 或 1。\n输入保证 grid 中至少有一个 1 。\n\"\"\"\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumArea = function(grid) {",
        "prompt_chat": "给你一个二维 二进制 数组 grid。请你找出一个边在水平方向和竖直方向上、面积 最小 的矩形，并且满足 grid 中所有的 1 都在矩形的内部。\n返回这个矩形可能的 最小 面积。\n示例 1：\n输入grid = [[0,1,0],[1,0,1]]\n输出：6示例 2：\n输入grid = [[0,0],[1,0]]\n输出：1\n\n提示：\n1 <= grid.length, grid[i].length <= 1000\ngrid[i][j] 是 0 或 1。\n输入保证 grid 中至少有一个 1 。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumArea = function(grid) {\n```",
        "solution": "function minimumArea(grid) {\n  let maxRow = Number.MIN_SAFE_INTEGER, maxCol = Number.MIN_SAFE_INTEGER\n  let minRow = Number.MAX_SAFE_INTEGER, minCol = Number.MAX_SAFE_INTEGER\n  let n = grid[0].length\n\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < n; col++) {\n      if (grid[row].indexOf(1) === -1) {\n        break\n      }\n      minCol = Math.min(minCol, grid[row].indexOf(1))\n      maxCol = Math.max(maxCol, grid[row].lastIndexOf(1))\n\n      minRow = Math.min(minRow, row)\n      maxRow = Math.max(maxRow, row)\n    }\n  }\n\n  return (maxRow - minRow + 1) * (maxCol - minCol + 1)\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumArea([[0,1,0],[1,0,1]]), 6, \"Test 1 Error!\");\nassert.deepEqual(minimumArea([[0,0],[1,0]]), 1, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumArea = function(grid) {",
        "function_name": "minimumArea",
        "difficulty_level": "Middle",
        "time": "20240623"
    },
    {
        "id": "3196",
        "prompt_base": "\"\"\"\n给你一个长度为 n 的整数数组 nums。子数组 nums[l..r]（其中 0 <= l <= r < n）的 成本 定义为：cost(l, r) = nums[l] - nums[l + 1] + ... + nums[r] * (−1)^{r − l}\n你的任务是将 nums 分割成若干子数组，使得所有子数组的成本之和 最大化，并确保每个元素 正好 属于一个子数组。\n具体来说，如果 nums 被分割成 k 个子数组，且分割点为索引 i_1, i_2, ..., i_{k − 1}（其中 0 <= i_1 < i_2 < ... < i_{k - 1} < n - 1），则总成本为：\ncost(0, i_1) + cost(i_1 + 1, i_2) + ... + cost(i_{k − 1} + 1, n − 1)\n返回在最优分割方式下的子数组成本之和的最大值。\n注意：如果 nums 没有被分割，即 k = 1，则总成本即为 cost(0, n - 1)。\n示例 1：\n输入nums = [1,-2,3,4]\n输出：10示例 2：\n输入nums = [1,-1,1,-1]\n输出：4\n\n提示：\n1 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumTotalCost = function(nums) {",
        "prompt_chat": "给你一个长度为 n 的整数数组 nums。子数组 nums[l..r]（其中 0 <= l <= r < n）的 成本 定义为：cost(l, r) = nums[l] - nums[l + 1] + ... + nums[r] * (−1)^{r − l}\n你的任务是将 nums 分割成若干子数组，使得所有子数组的成本之和 最大化，并确保每个元素 正好 属于一个子数组。\n具体来说，如果 nums 被分割成 k 个子数组，且分割点为索引 i_1, i_2, ..., i_{k − 1}（其中 0 <= i_1 < i_2 < ... < i_{k - 1} < n - 1），则总成本为：\ncost(0, i_1) + cost(i_1 + 1, i_2) + ... + cost(i_{k − 1} + 1, n − 1)\n返回在最优分割方式下的子数组成本之和的最大值。\n注意：如果 nums 没有被分割，即 k = 1，则总成本即为 cost(0, n - 1)。\n示例 1：\n输入nums = [1,-2,3,4]\n输出：10示例 2：\n输入nums = [1,-1,1,-1]\n输出：4\n\n提示：\n1 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumTotalCost = function(nums) {\n```",
        "solution": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumTotalCost = function(nums) {\n\n    if(nums.length==0) return nums[0]\n    let n = nums.length\n    let dp = new Array(nums.length).fill().map(()=>new Array(2).fill(0))\n    dp[0][0] = nums[0]\n    dp[0][1] = nums[0]\n\n    for(let i = 1;i<nums.length;i++){\n        dp[i][0] = dp[i-1][1] - nums[i]\n        dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]) + nums[i]\n    }\n    // console.log(dp)\n\n    return Math.max(dp[n-1][0],dp[n-1][1])\n\n\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maximumTotalCost([1,-2,3,4]), 10, \"Test 1 Error!\");\nassert.deepEqual(maximumTotalCost([1,-1,1,-1]), 4, \"Test 2 Error!\");\nassert.deepEqual(maximumTotalCost([0]), 0, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumTotalCost = function(nums) {",
        "function_name": "maximumTotalCost",
        "difficulty_level": "Middle",
        "time": "20240623"
    },
    {
        "id": "3197",
        "prompt_base": "\"\"\"\n给你一个二维 二进制 数组 grid。你需要找到 3 个 不重叠、面积 非零 、边在水平方向和竖直方向上的矩形，并且满足 grid 中所有的 1 都在这些矩形的内部。\n返回这些矩形面积之和的 最小 可能值。\n注意，这些矩形可以相接。\n示例 1：\n输入grid = [[1,0,1],[1,1,1]]\n输出：5示例 2：\n输入grid = [[1,0,1,0],[0,1,0,1]]\n输出：5\n\n提示：\n1 <= grid.length, grid[i].length <= 30\ngrid[i][j] 是 0 或 1。\n输入保证 grid 中至少有三个 1 。\n\"\"\"\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumSum = function(grid) {",
        "prompt_chat": "给你一个二维 二进制 数组 grid。你需要找到 3 个 不重叠、面积 非零 、边在水平方向和竖直方向上的矩形，并且满足 grid 中所有的 1 都在这些矩形的内部。\n返回这些矩形面积之和的 最小 可能值。\n注意，这些矩形可以相接。\n示例 1：\n输入grid = [[1,0,1],[1,1,1]]\n输出：5示例 2：\n输入grid = [[1,0,1,0],[0,1,0,1]]\n输出：5\n\n提示：\n1 <= grid.length, grid[i].length <= 30\ngrid[i][j] 是 0 或 1。\n输入保证 grid 中至少有三个 1 。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumSum = function(grid) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumSum([[1,0,1],[1,1,1]]), 5, \"Test 1 Error!\");\nassert.deepEqual(minimumSum([[1,0,1,0],[0,1,0,1]]), 5, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumSum = function(grid) {",
        "function_name": "minimumSum",
        "difficulty_level": "Hard",
        "time": "20240623"
    },
    {
        "id": "3200",
        "prompt_base": "\"\"\"\n给你两个整数 red 和 blue，分别表示红色球和蓝色球的数量。你需要使用这些球来组成一个三角形，满足第 1 行有 1 个球，第 2 行有 2 个球，第 3 行有 3 个球，依此类推。\n每一行的球必须是 相同 颜色，且相邻行的颜色必须 不同。\n返回可以实现的三角形的 最大 高度。\n示例 1：\n输入red = 2, blue = 4\n输出：3示例 2：\n输入red = 2, blue = 1\n输出：2\n\n提示：\n1 <= red, blue <= 100\n\"\"\"\n\n/**\n * @param {number} red\n * @param {number} blue\n * @return {number}\n */\nvar maxHeightOfTriangle = function(red, blue) {",
        "prompt_chat": "给你两个整数 red 和 blue，分别表示红色球和蓝色球的数量。你需要使用这些球来组成一个三角形，满足第 1 行有 1 个球，第 2 行有 2 个球，第 3 行有 3 个球，依此类推。\n每一行的球必须是 相同 颜色，且相邻行的颜色必须 不同。\n返回可以实现的三角形的 最大 高度。\n示例 1：\n输入red = 2, blue = 4\n输出：3示例 2：\n输入red = 2, blue = 1\n输出：2\n\n提示：\n1 <= red, blue <= 100\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number} red\n * @param {number} blue\n * @return {number}\n */\nvar maxHeightOfTriangle = function(red, blue) {\n```",
        "solution": "var maxHeightOfTriangle = function(red, blue) {\n    return Math.max(getMaxHeight([red, blue]), getMaxHeight([blue, red]));\n};\n\nvar getMaxHeight = function(counts) {\n    let height = 0;\n    let position = 0;\n    while (height + 1 <= counts[position]) {\n        height++;\n        counts[position] -= height;\n        position ^= 1;\n    }\n    return height;\n};",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maxHeightOfTriangle(2,4), 3, \"Test 1 Error!\");\nassert.deepEqual(maxHeightOfTriangle(2,1), 2, \"Test 2 Error!\");\nassert.deepEqual(maxHeightOfTriangle(1,1), 1, \"Test 3 Error!\");\nassert.deepEqual(maxHeightOfTriangle(10,1), 2, \"Test 4 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number} red\n * @param {number} blue\n * @return {number}\n */\nvar maxHeightOfTriangle = function(red, blue) {",
        "function_name": "maxHeightOfTriangle",
        "difficulty_level": "Easy",
        "time": "20240630"
    },
    {
        "id": "3201",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums。nums 的子序列 sub 的长度为 x ，如果其满足以下条件，则称其为 有效子序列：\n(sub[0] + sub[1]) % 2 == (sub[1] + sub[2]) % 2 == ... == (sub[x - 2] + sub[x - 1]) % 2\n返回 nums 的 最长的有效子序列 的长度。\n一个 子序列 指的是从原数组中删除一些元素（也可以不删除任何元素），剩余元素保持原来顺序组成的新数组。\n示例 1：\n输入nums = [1,2,3,4]\n输出：4示例 2：\n输入nums = [1,2,1,1,2,1,2]\n输出：6\n\n提示：\n2 <= nums.length <= 2 * 10^5\n1 <= nums[i] <= 10^7\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumLength = function(nums) {",
        "prompt_chat": "给你一个整数数组 nums。nums 的子序列 sub 的长度为 x ，如果其满足以下条件，则称其为 有效子序列：\n(sub[0] + sub[1]) % 2 == (sub[1] + sub[2]) % 2 == ... == (sub[x - 2] + sub[x - 1]) % 2\n返回 nums 的 最长的有效子序列 的长度。\n一个 子序列 指的是从原数组中删除一些元素（也可以不删除任何元素），剩余元素保持原来顺序组成的新数组。\n示例 1：\n输入nums = [1,2,3,4]\n输出：4示例 2：\n输入nums = [1,2,1,1,2,1,2]\n输出：6\n\n提示：\n2 <= nums.length <= 2 * 10^5\n1 <= nums[i] <= 10^7\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumLength = function(nums) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maximumLength([1,2,3,4]), 4, \"Test 1 Error!\");\nassert.deepEqual(maximumLength([1,2,1,1,2,1,2]), 6, \"Test 2 Error!\");\nassert.deepEqual(maximumLength([1,3]), 2, \"Test 3 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumLength = function(nums) {",
        "function_name": "maximumLength",
        "difficulty_level": "Middle",
        "time": "20240630"
    },
    {
        "id": "3202",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 和一个 正 整数 k 。nums 的一个 子序列 sub 的长度为 x ，如果其满足以下条件，则称其为 有效子序列 ：\n(sub[0] + sub[1]) % k == (sub[1] + sub[2]) % k == ... == (sub[x - 2] + sub[x - 1]) % k\n返回 nums 的 最长有效子序列 的长度。\n示例 1：\n输入nums = [1,2,3,4,5], k = 2\n输出：5示例 2：\n输入nums = [1,4,2,3,1,4], k = 3\n输出：4\n\n提示：\n2 <= nums.length <= 10^3\n1 <= nums[i] <= 10^7\n1 <= k <= 10^3\n\"\"\"\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumLength = function(nums, k) {",
        "prompt_chat": "给你一个整数数组 nums 和一个 正 整数 k 。nums 的一个 子序列 sub 的长度为 x ，如果其满足以下条件，则称其为 有效子序列 ：\n(sub[0] + sub[1]) % k == (sub[1] + sub[2]) % k == ... == (sub[x - 2] + sub[x - 1]) % k\n返回 nums 的 最长有效子序列 的长度。\n示例 1：\n输入nums = [1,2,3,4,5], k = 2\n输出：5示例 2：\n输入nums = [1,4,2,3,1,4], k = 3\n输出：4\n\n提示：\n2 <= nums.length <= 10^3\n1 <= nums[i] <= 10^7\n1 <= k <= 10^3\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumLength = function(nums, k) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(maximumLength([1,2,3,4,5],2), 5, \"Test 1 Error!\");\nassert.deepEqual(maximumLength([1,4,2,3,1,4],3), 4, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumLength = function(nums, k) {",
        "function_name": "maximumLength",
        "difficulty_level": "Middle",
        "time": "20240630"
    },
    {
        "id": "3203",
        "prompt_base": "\"\"\"\n给你两棵 无向 树，分别有 n 和 m 个节点，节点编号分别为 0 到 n - 1 和 0 到 m - 1 。给你两个二维整数数组 edges1 和 edges2 ，长度分别为 n - 1 和 m - 1 ，其中 edges1[i] = [a_i, b_i] 表示在第一棵树中节点 a_i 和 b_i 之间有一条边，edges2[i] = [u_i, v_i] 表示在第二棵树中节点 u_i 和 v_i 之间有一条边。\n你必须在第一棵树和第二棵树中分别选一个节点，并用一条边连接它们。\n请你返回添加边后得到的树中，最小直径 为多少。\n一棵树的 直径 指的是树中任意两个节点之间的最长路径长度。\n示例 1：\n输入edges1 = [[0,1],[0,2],[0,3]], edges2 = [[0,1]]\n输出：3示例 2：\n输入edges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]\n输出：5\n\n提示：\n1 <= n, m <= 10^5\nedges1.length == n - 1\nedges2.length == m - 1\nedges1[i].length == edges2[i].length == 2\nedges1[i] = [a_i, b_i]\n0 <= a_i, b_i < n\nedges2[i] = [u_i, v_i]\n0 <= u_i, v_i < m\n输入保证 edges1 和 edges2 分别表示一棵合法的树。\n\"\"\"\n\n/**\n * @param {number[][]} edges1\n * @param {number[][]} edges2\n * @return {number}\n */\nvar minimumDiameterAfterMerge = function(edges1, edges2) {",
        "prompt_chat": "给你两棵 无向 树，分别有 n 和 m 个节点，节点编号分别为 0 到 n - 1 和 0 到 m - 1 。给你两个二维整数数组 edges1 和 edges2 ，长度分别为 n - 1 和 m - 1 ，其中 edges1[i] = [a_i, b_i] 表示在第一棵树中节点 a_i 和 b_i 之间有一条边，edges2[i] = [u_i, v_i] 表示在第二棵树中节点 u_i 和 v_i 之间有一条边。\n你必须在第一棵树和第二棵树中分别选一个节点，并用一条边连接它们。\n请你返回添加边后得到的树中，最小直径 为多少。\n一棵树的 直径 指的是树中任意两个节点之间的最长路径长度。\n示例 1：\n输入edges1 = [[0,1],[0,2],[0,3]], edges2 = [[0,1]]\n输出：3示例 2：\n输入edges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]\n输出：5\n\n提示：\n1 <= n, m <= 10^5\nedges1.length == n - 1\nedges2.length == m - 1\nedges1[i].length == edges2[i].length == 2\nedges1[i] = [a_i, b_i]\n0 <= a_i, b_i < n\nedges2[i] = [u_i, v_i]\n0 <= u_i, v_i < m\n输入保证 edges1 和 edges2 分别表示一棵合法的树。\n\n请完成下面的代码来解决上述问题：\n```javascript\n/**\n * @param {number[][]} edges1\n * @param {number[][]} edges2\n * @return {number}\n */\nvar minimumDiameterAfterMerge = function(edges1, edges2) {\n```",
        "solution": "",
        "reference": "const assert = require(\"assert\");\nassert.deepEqual(minimumDiameterAfterMerge([[0,1],[0,2],[0,3]],[[0,1]]), 3, \"Test 1 Error!\");\nassert.deepEqual(minimumDiameterAfterMerge([[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]],[[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]), 5, \"Test 2 Error!\");",
        "class_helper": "",
        "context": "/**\n * @param {number[][]} edges1\n * @param {number[][]} edges2\n * @return {number}\n */\nvar minimumDiameterAfterMerge = function(edges1, edges2) {",
        "function_name": "minimumDiameterAfterMerge",
        "difficulty_level": "Hard",
        "time": "20240630"
    }
]