{
    "3014": {
        "description": "给你一个字符串 word，由 不同 小写英文字母组成。\n电话键盘上的按键与 不同 小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 2 对应 [\\\"a\\\",\\\"b\\\",\\\"c\\\"]，我们需要按一次键来输入 \\\"a\\\"，按两次键来输入 \\\"b\\\"，按三次键来输入 \\\"c\\\"。\n现在允许你将编号为 2 到 9 的按键重新映射到 不同 字母集合。每个按键可以映射到 任意数量 的字母，但每个字母 必须 恰好 映射到 一个 按键上。你需要找到输入字符串 word 所需的 最少 按键次数。\n返回重新映射按键后输入 word 所需的 最少 按键次数。\n下面给出了一种电话键盘上字母到按键的映射作为示例。注意 1，*，# 和 0 不 对应任何字母。",
        "difficulty_level": "Easy",
        "note": "1 <= word.length <= 26\nword 仅由小写英文字母组成。\nword 中的所有字母互不相同。",
        "codes": {
            "python": "class Solution:\n    def minimumPushes(self, word: str) -> int:\n        k, rem = divmod(len(word), 8)\n        return (k * 4 + rem) * (k + 1)\n",
            "java": "class Solution {\n    public int minimumPushes(String word) {\n        int n = word.length();\n        int k = n / 8;\n        return (k * 4 + n % 8) * (k + 1);\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumPushes(string &word) {\n        int n = word.length();\n        int k = n / 8;\n        return (k * 4 + n % 8) * (k + 1);\n    }\n};\n",
            "go": "func minimumPushes(word string) int {\nn := len(word)\nk := n / 8\nreturn (k*4 + n%8) * (k + 1)\n}\n",
            "js": "/**\n * @param {string} word\n * @return {number}\n */\nvar minimumPushes = function(word) {\n    let n = word.length, k = n/8 >> 0, r = n % 8 \n    return 4*k*(k + 1) + (k + 1)*r\n};\n"
        },
        "cases": [
            {
                "input": "[\"\\\"abcde\\\"\"]",
                "output": "[\"5\"]"
            },
            {
                "input": "[\"\\\"xycdefghij\\\"\"]",
                "output": "[\"12\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumPushes(String word) {",
            "cpp": "class Solution {\npublic:\n    int minimumPushes(string word) {",
            "go": "func minimumPushes(word string) int {\n\n}",
            "js": "/**\n * @param {string} word\n * @return {number}\n */\nvar minimumPushes = function(word) {",
            "python": "class Solution:\n    def minimumPushes(self, word: str) -> int:"
        },
        "time": "20240121",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumPushes",
            "java": "minimumPushes",
            "cpp": "minimumPushes",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumPushes(\"abcde\") == 5, \"Test 1 Error!\"\nassert my_solution.minimumPushes(\"xycdefghij\") == 12, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String word_1 = \"abcde\";\n    int ans_1 = 5;\n    assert solution.minimumPushes(word_1) == ans_1;\n    String word_2 = \"xycdefghij\";\n    int ans_2 = 12;\n    assert solution.minimumPushes(word_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string word_1 = \"abcde\";\n    int ans_1 = 5;\n    assert(my_solution_1.minimumPushes(word_1) == ans_1);\n    Solution my_solution_2;\n    string word_2 = \"xycdefghij\";\n    int ans_2 = 12;\n    assert(my_solution_2.minimumPushes(word_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "word"
            ],
            "java": [
                "word"
            ],
            "cpp": [
                "word"
            ],
            "go": [],
            "js": []
        }
    },
    "3015": {
        "description": "给你三个 正整数 n 、x 和 y 。在城市中，存在编号从 1 到 n 的房屋，由 n 条街道相连。对所有 1 <= i < n ，都存在一条街道连接编号为 i 的房屋与编号为 i + 1 的房屋。另存在一条街道连接编号为 x 的房屋与编号为 y 的房屋。\n对于每个 k（1 <= k <= n），你需要找出所有满足要求的 房屋对 [house_1, house_2] ，即从 house_1 到 house_2 需要经过的 最少 街道数为 k 。\n返回一个下标从 1 开始且长度为 n 的数组 result ，其中 result[k] 表示所有满足要求的房屋对的数量，即从一个房屋到另一个房屋需要经过的 最少 街道数为 k 。\n注意，x 与 y 可以 相等 。",
        "difficulty_level": "Middle",
        "note": "2 <= n <= 100\n1 <= x, y <= n",
        "codes": {
            "python": "class Solution:\n    def countOfPairs(self, n: int, x: int, y: int) -> List[int]:\n        if x > y:\n            x, y = y, x\n\n        diff = [0] * (n + 1)\n\n        def add(l: int, r: int, v: int) -> None:\n            if l > r: return\n            diff[l] += v\n            diff[r + 1] -= v\n\n        def update(i: int, x: int, y: int) -> None:\n            add(y - i, n - i, -1)  # 撤销 [y,n]\n            dec = y - x - 1  # 缩短的距离\n            add(y - i - dec, n - i - dec, 1)\n\n            j = (x + y + 1) // 2 + 1\n            add(j - i, y - 1 - i, -1)  # 撤销 [j, y-1]\n            add(x - i + 2, x - i + y - j + 1, 1)\n\n        def update2(i: int, x: int, y: int) -> None:\n            add(y - i, n - i, -1)  # 撤销 [y,n]\n            dec = (y - i) - (i - x + 1)  # 缩短的距离\n            add(y - i - dec, n - i - dec, 1)\n\n            j = i + (y - x + 1) // 2 + 1\n            add(j - i, y - 1 - i, -1)  # 撤销 [j, y-1]\n            add(i - x + 2, i - x + y - j + 1, 1)\n\n        for i in range(1, n + 1):\n            add(1, i - 1, 1)\n            add(1, n - i, 1)\n            if x + 1 >= y:\n                continue\n            if i <= x:\n                update(i, x, y)\n            elif i >= y:\n                update(n + 1 - i, n + 1 - y, n + 1 - x)\n            elif i < (x + y) // 2:\n                update2(i, x, y)\n            elif i > (x + y + 1) // 2:\n                update2(n + 1 - i, n + 1 - y, n + 1 - x)\n\n        return list(accumulate(diff))[1:]\n",
            "java": "class Solution {\n    public long[] countOfPairs(int n, int x, int y) {\n        if (x > y) {\n            int temp = x;\n            x = y;\n            y = temp;\n        }\n\n        diff = new int[n + 1];\n\n        for (int i = 1; i <= n; i++) {\n            add(1, i - 1, 1);\n            add(1, n - i, 1);\n            if (x + 1 >= y) {\n                continue;\n            }\n            if (i <= x) {\n                update(i, x, y, n);\n            } else if (i >= y) {\n                update(n + 1 - i, n + 1 - y, n + 1 - x, n);\n            } else if (i < (x + y) / 2) {\n                update2(i, x, y, n);\n            } else if (i > (x + y + 1) / 2) {\n                update2(n + 1 - i, n + 1 - y, n + 1 - x, n);\n            }\n        }\n\n        long[] ans = new long[n];\n        long sumD = 0;\n        for (int i = 0; i < n; i++) {\n            sumD += diff[i + 1];\n            ans[i] = sumD;\n        }\n        return ans;\n    }\n\n    private int[] diff;\n\n    private void add(int l, int r, int v) {\n        if (l > r) return;\n        diff[l] += v;\n        diff[r + 1] -= v;\n    }\n\n    private void update(int i, int x, int y, int n) {\n        add(y - i, n - i, -1); // 撤销 [y,n]\n        int dec = y - x - 1; // 缩短的距离\n        add(y - i - dec, n - i - dec, 1);\n\n        int j = (x + y + 1) / 2 + 1;\n        add(j - i, y - 1 - i, -1); // 撤销 [j, y-1]\n        add(x - i + 2, x - i + y - j + 1, 1);\n    }\n\n    private void update2(int i, int x, int y, int n) {\n        add(y - i, n - i, -1); // 撤销 [y,n]\n        int dec = (y - i) - (i - x + 1); // 缩短的距离\n        add(y - i - dec, n - i - dec, 1);\n\n        int j = i + (y - x + 1) / 2 + 1;\n        add(j - i, y - 1 - i, -1); // 撤销 [j, y-1]\n        add(i - x + 2, i - x + y - j + 1, 1);\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    vector<long long> countOfPairs(int n, int x, int y) {\n        if (x > y) {\n            swap(x, y);\n        }\n\n        vector<int> diff(n + 1);\n\n        auto add = [&](int l, int r, int v) {\n            if (l > r) return;\n            diff[l] += v;\n            diff[r + 1] -= v;\n        };\n\n        auto update = [&](int i, int x, int y) {\n            add(y - i, n - i, -1); // 撤销 [y,n]\n            int dec = y - x - 1; // 缩短的距离\n            add(y - i - dec, n - i - dec, 1);\n\n            int j = (x + y + 1) / 2 + 1;\n            add(j - i, y - 1 - i, -1); // 撤销 [j, y-1]\n            add(x - i + 2, x - i + y - j + 1, 1);\n        };\n\n        auto update2 = [&](int i, int x, int y) {\n            add(y - i, n - i, -1); // 撤销 [y,n]\n            int dec = (y - i) - (i - x + 1); // 缩短的距离\n            add(y - i - dec, n - i - dec, 1);\n\n            int j = i + (y - x + 1) / 2 + 1;\n            add(j - i, y - 1 - i, -1); // 撤销 [j, y-1]\n            add(i - x + 2, i - x + y - j + 1, 1);\n        };\n\n        for (int i = 1; i <= n; i++) {\n            add(1, i - 1, 1);\n            add(1, n - i, 1);\n            if (x + 1 >= y) {\n                continue;\n            }\n            if (i <= x) {\n                update(i, x, y);\n            } else if (i >= y) {\n                update(n + 1 - i, n + 1 - y, n + 1 - x);\n            } else if (i < (x + y) / 2) {\n                update2(i, x, y);\n            } else if (i > (x + y + 1) / 2) {\n                update2(n + 1 - i, n + 1 - y, n + 1 - x);\n            }\n        }\n\n        vector<long long> ans(n);\n        long long sum_d = 0;\n        for (int i = 0; i < n; i++) {\n            sum_d += diff[i + 1];\n            ans[i] = sum_d;\n        }\n        return ans;\n    }\n};\n",
            "go": "func countOfPairs(n, x, y int) []int64 {\nif x > y {\nx, y = y, x\n}\n\ndiff := make([]int, n+1)\nadd := func(l, r, v int) {\nif l > r {\nreturn\n}\ndiff[l] += v\ndiff[r+1] -= v\n}\n\nupdate := func(i, x, y int) {\nadd(y-i, n-i, -1) // 撤销 [y,n]\ndec := y - x - 1  // 缩短的距离\nadd(y-i-dec, n-i-dec, 1)\n\nj := (x+y+1)/2 + 1\nadd(j-i, y-1-i, -1) // 撤销 [j, y-1]\nadd(x-i+2, x-i+y-j+1, 1)\n}\n\nupdate2 := func(i, x, y int) {\nadd(y-i, n-i, -1) // 撤销 [y,n]\ndec := (y - i) - (i - x + 1) // 缩短的距离\nadd(y-i-dec, n-i-dec, 1)\n\nj := i + (y-x+1)/2 + 1\nadd(j-i, y-1-i, -1) // 撤销 [j, y-1]\nadd(i-x+2, i-x+y-j+1, 1)\n}\n\nfor i := 1; i <= n; i++ {\nadd(1, i-1, 1)\nadd(1, n-i, 1)\nif x+1 >= y {\ncontinue\n}\nif i <= x {\nupdate(i, x, y)\n} else if i >= y {\nupdate(n+1-i, n+1-y, n+1-x)\n} else if i < (x+y)/2 {\nupdate2(i, x, y)\n} else if i > (x+y+1)/2 {\nupdate2(n+1-i, n+1-y, n+1-x)\n}\n}\n\nans := make([]int64, n)\nsumD := int64(0)\nfor i, d := range diff[1:] {\nsumD += int64(d)\nans[i] = sumD\n}\nreturn ans\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"3\",\"1\",\"3\"]",
                "output": "[\"[6,0,0]\"]"
            },
            {
                "input": "[\"5\",\"2\",\"4\"]",
                "output": "[\"[10,8,2,0,0]\"]"
            },
            {
                "input": "[\"4\",\"1\",\"1\"]",
                "output": "[\"[6,4,2,0]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long[] countOfPairs(int n, int x, int y) {",
            "cpp": "class Solution {\npublic:\n    vector<long long> countOfPairs(int n, int x, int y) {",
            "go": "func countOfPairs(n int, x int, y int) []int64 {\n\n}",
            "js": "/**\n * @param {number} n\n * @param {number} x\n * @param {number} y\n * @return {number[]}\n */\nvar countOfPairs = function(n, x, y) {",
            "python": "class Solution:\n    def countOfPairs(self, n: int, x: int, y: int) -> List[int]:"
        },
        "time": "20240121",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "countOfPairs",
            "java": "countOfPairs",
            "cpp": "countOfPairs",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.countOfPairs(3, 1, 3) == [6,0,0], \"Test 1 Error!\"\nassert my_solution.countOfPairs(5, 2, 4) == [10,8,2,0,0], \"Test 2 Error!\"\nassert my_solution.countOfPairs(4, 1, 1) == [6,4,2,0], \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int n_1 = 3;\n    int x_1 = 1;\n    int y_1 = 3;\n    long[] ans_1 = {6,0,0};\n    assert Arrays.equals(solution.countOfPairs(n_1, x_1, y_1), ans_1);\n    int n_2 = 5;\n    int x_2 = 2;\n    int y_2 = 4;\n    long[] ans_2 = {10,8,2,0,0};\n    assert Arrays.equals(solution.countOfPairs(n_2, x_2, y_2), ans_2);\n    int n_3 = 4;\n    int x_3 = 1;\n    int y_3 = 1;\n    long[] ans_3 = {6,4,2,0};\n    assert Arrays.equals(solution.countOfPairs(n_3, x_3, y_3), ans_3);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int n_1 = 3;\n    int x_1 = 1;\n    int y_1 = 3;\n    vector<long long> ans_1 = {6,0,0};\n    assert(my_solution_1.countOfPairs(n_1, x_1, y_1) == ans_1);\n    Solution my_solution_2;\n    int n_2 = 5;\n    int x_2 = 2;\n    int y_2 = 4;\n    vector<long long> ans_2 = {10,8,2,0,0};\n    assert(my_solution_2.countOfPairs(n_2, x_2, y_2) == ans_2);\n    Solution my_solution_3;\n    int n_3 = 4;\n    int x_3 = 1;\n    int y_3 = 1;\n    vector<long long> ans_3 = {6,4,2,0};\n    assert(my_solution_3.countOfPairs(n_3, x_3, y_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "n",
                "x",
                "y"
            ],
            "java": [
                "n",
                "x",
                "y"
            ],
            "cpp": [
                "n",
                "x",
                "y"
            ],
            "go": [],
            "js": []
        }
    },
    "3016": {
        "description": "给你一个字符串 word，由小写英文字母组成。电话键盘上的按键与 不同 小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 2 对应 [\\\"a\\\",\\\"b\\\",\\\"c\\\"]，我们需要按一次键来输入 \\\"a\\\"，按两次键来输入 \\\"b\\\"，按三次键来输入 \\\"c\\\"。\n现在允许你将编号为 2 到 9 的按键重新映射到 不同 字母集合。每个按键可以映射到 任意数量 的字母，但每个字母 必须 恰好 映射到 一个 按键上。你需要找到输入字符串 word 所需的 最少 按键次数。\n返回重新映射按键后输入 word 所需的 最少 按键次数。\n下面给出了一种电话键盘上字母到按键的映射作为示例。注意 1，*，# 和 0 不 对应任何字母。",
        "difficulty_level": "Middle",
        "note": "1 <= word.length <= 10^5\nword 仅由小写英文字母组成。",
        "codes": {
            "python": "class Solution:\n    def minimumPushes(self, word: str) -> int:\n        a = sorted(Counter(word).values(), reverse=True)\n        return sum(c * (i // 8 + 1) for i, c in enumerate(a))\n",
            "java": "class Solution {\n    public int minimumPushes(String word) {\n        int[] cnt = new int[26];\n        for (char b : word.toCharArray()) {\n            cnt[b - 'a']++;\n        }\n        Arrays.sort(cnt);\n\n        int ans = 0;\n        for (int i = 0; i < 26; i++) {\n            ans += cnt[25 - i] * (i / 8 + 1);\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumPushes(string word) {\n        int cnt[26]{};\n        for (char b: word) {\n            cnt[b - 'a']++;\n        }\n        ranges::sort(cnt, greater<int>());\n\n        int ans = 0;\n        for (int i = 0; i < 26; i++) {\n            ans += cnt[i] * (i / 8 + 1);\n        }\n        return ans;\n    }\n};\n",
            "go": "func minimumPushes(word string) (ans int) {\ncnt := [26]int{}\nfor _, b := range word {\ncnt[b-'a']++\n}\nsort.Sort(sort.Reverse(sort.IntSlice(cnt[:])))\n\nfor i, c := range cnt {\nans += c * (i/8 + 1)\n}\nreturn\n}\n",
            "js": "/**\n * @param {string} word\n * @return {number}\n */\nvar minimumPushes = function(word) {\n    // 保存单词出现次数\n    const map = new Map()\n    for (let i = 0; i < word.length; i++) {\n        map.set(word[i], map.get(word[i]) ? map.get(word[i]) + 1 : 1)\n    }\n\n    // 依照出现次数排序\n    const arr = Array.from(map)\n    const _word = arr.sort((a, b) => (b[1] - a[1])).map(el => (el[0])).join('')\n\n    // 计算总数\n    let sum = 0\n    for (let i = 0; i < _word.length; i++) {\n        sum += map.get(_word[i]) * Math.floor(i / 8 + 1)\n    }\n    return sum\n};\n"
        },
        "cases": [
            {
                "input": "[\"\\\"abcde\\\"\"]",
                "output": "[\"5\"]"
            },
            {
                "input": "[\"\\\"xyzxyzxyzxyz\\\"\"]",
                "output": "[\"12\"]"
            },
            {
                "input": "[\"\\\"aabbccddeeffgghhiiiiii\\\"\"]",
                "output": "[\"24\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumPushes(String word) {",
            "cpp": "class Solution {\npublic:\n    int minimumPushes(string word) {",
            "go": "func minimumPushes(word string) int {\n\n}",
            "js": "/**\n * @param {string} word\n * @return {number}\n */\nvar minimumPushes = function(word) {",
            "python": "class Solution:\n    def minimumPushes(self, word: str) -> int:"
        },
        "time": "20240121",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumPushes",
            "java": "minimumPushes",
            "cpp": "minimumPushes",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumPushes(\"abcde\") == 5, \"Test 1 Error!\"\nassert my_solution.minimumPushes(\"xyzxyzxyzxyz\") == 12, \"Test 2 Error!\"\nassert my_solution.minimumPushes(\"aabbccddeeffgghhiiiiii\") == 24, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String word_1 = \"abcde\";\n    int ans_1 = 5;\n    assert solution.minimumPushes(word_1) == ans_1;\n    String word_2 = \"xyzxyzxyzxyz\";\n    int ans_2 = 12;\n    assert solution.minimumPushes(word_2) == ans_2;\n    String word_3 = \"aabbccddeeffgghhiiiiii\";\n    int ans_3 = 24;\n    assert solution.minimumPushes(word_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string word_1 = \"abcde\";\n    int ans_1 = 5;\n    assert(my_solution_1.minimumPushes(word_1) == ans_1);\n    Solution my_solution_2;\n    string word_2 = \"xyzxyzxyzxyz\";\n    int ans_2 = 12;\n    assert(my_solution_2.minimumPushes(word_2) == ans_2);\n    Solution my_solution_3;\n    string word_3 = \"aabbccddeeffgghhiiiiii\";\n    int ans_3 = 24;\n    assert(my_solution_3.minimumPushes(word_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "word"
            ],
            "java": [
                "word"
            ],
            "cpp": [
                "word"
            ],
            "go": [],
            "js": []
        }
    },
    "3017": {
        "description": "给你三个 正整数 n 、x 和 y 。在城市中，存在编号从 1 到 n 的房屋，由 n 条街道相连。对所有 1 <= i < n ，都存在一条街道连接编号为 i 的房屋与编号为 i + 1 的房屋。另存在一条街道连接编号为 x 的房屋与编号为 y 的房屋。\n对于每个 k（1 <= k <= n），你需要找出所有满足要求的 房屋对 [house_1, house_2] ，即从 house_1 到 house_2 需要经过的 最少 街道数为 k 。\n返回一个下标从 1 开始且长度为 n 的数组 result ，其中 result[k] 表示所有满足要求的房屋对的数量，即从一个房屋到另一个房屋需要经过的 最少 街道数为 k 。\n注意，x 与 y 可以 相等 。",
        "difficulty_level": "Hard",
        "note": "2 <= n <= 10^5\n1 <= x, y <= n",
        "codes": {
            "python": "class Solution:\n    def countOfPairs(self, n: int, x: int, y: int) -> List[int]:\n        if x > y:\n            x, y = y, x\n\n        if x + 1 >= y:\n            return list(range((n - 1) * 2, -1, -2))\n\n        diff = [0] * (n + 1)\n\n        def add(l: int, r: int) -> None:\n            diff[l] += 2\n            diff[r + 1] -= 2\n\n        for i in range(1, n):\n            if i <= x:\n                k = (x + y + 1) // 2\n                add(1, k - i)\n                add(x - i + 2, x - i + y - k)\n                add(x - i + 1, x - i + 1 + n - y)\n            elif i < (x + y) // 2:\n                k = i + (y - x + 1) // 2\n                add(1, k - i)\n                add(i - x + 2, i - x + y - k)\n                add(i - x + 1, i - x + 1 + n - y)\n            else:\n                add(1, n - i)\n\n        return list(accumulate(diff))[1:]\n",
            "java": "class Solution {\n    public long[] countOfPairs(int n, int x, int y) {\n        if (x > y) {\n            int temp = x;\n            x = y;\n            y = temp;\n        }\n\n        long[] ans = new long[n];\n        if (x + 1 >= y) {\n            for (int i = 1; i < n; i++) {\n                ans[i - 1] = (n - i) * 2;\n            }\n            return ans;\n        }\n\n        diff = new int[n + 1];\n        for (int i = 1; i < n; i++) {\n            if (i <= x) {\n                int k = (x + y + 1) / 2;\n                add(1, k - i);\n                add(x - i + 2, x - i + y - k);\n                add(x - i + 1, x - i + 1 + n - y);\n            } else if (i < (x + y) / 2) {\n                int k = i + (y - x + 1) / 2;\n                add(1, k - i);\n                add(i - x + 2, i - x + y - k);\n                add(i - x + 1, i - x + 1 + n - y);\n            } else {\n                add(1, n - i);\n            }\n        }\n\n        long sumD = 0;\n        for (int i = 0; i < n; i++) {\n            sumD += diff[i + 1];\n            ans[i] = sumD * 2;\n        }\n        return ans;\n    }\n\n    private int[] diff;\n\n    private void add(int l, int r) {\n        diff[l]++;\n        diff[r + 1]--;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    vector<long long> countOfPairs(int n, int x, int y) {\n        if (x > y) {\n            swap(x, y);\n        }\n\n        vector<long long> ans(n);\n        if (x + 1 >= y) {\n            for (int i = 1; i < n; i++) {\n                ans[i - 1] = (n - i) * 2;\n            }\n            return ans;\n        }\n\n        vector<int> diff(n + 1, 0);\n\n        auto add = [&](int l, int r) {\n            diff[l]++;\n            diff[r + 1]--;\n        };\n\n        for (int i = 1; i < n; i++) {\n            if (i <= x) {\n                int k = (x + y + 1) / 2;\n                add(1, k - i);\n                add(x - i + 2, x - i + y - k);\n                add(x - i + 1, x - i + 1 + n - y);\n            } else if (i < (x + y) / 2) {\n                int k = i + (y - x + 1) / 2;\n                add(1, k - i);\n                add(i - x + 2, i - x + y - k);\n                add(i - x + 1, i - x + 1 + n - y);\n            } else {\n                add(1, n - i);\n            }\n        }\n\n        long long sum_d = 0;\n        for (int i = 0; i < n; i++) {\n            sum_d += diff[i + 1];\n            ans[i] = sum_d * 2;\n        }\n        return ans;\n    }\n};\n",
            "go": "func countOfPairs(n, x, y int) []int64 {\nif x > y {\nx, y = y, x\n}\n\nans := make([]int64, n)\nif x+1 >= y {\nfor i := 1; i < n; i++ {\nans[i-1] = int64(n-i) * 2\n}\nreturn ans\n}\n\ndiff := make([]int, n+1)\nadd := func(l, r int) {\ndiff[l]++\ndiff[r+1]--\n}\n\nfor i := 1; i < n; i++ {\nif i <= x {\nk := (x + y + 1) / 2\nadd(1, k-i)\nadd(x-i+2, x-i+y-k)\nadd(x-i+1, x-i+1+n-y)\n} else if i < (x+y)/2 {\nk := i + (y-x+1)/2\nadd(1, k-i)\nadd(i-x+2, i-x+y-k)\nadd(i-x+1, i-x+1+n-y)\n} else {\nadd(1, n-i)\n}\n}\n\nsumD := int64(0)\nfor i, d := range diff[1:] {\nsumD += int64(d)\nans[i] = sumD * 2\n}\nreturn ans\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"3\",\"1\",\"3\"]",
                "output": "[\"[6,0,0]\"]"
            },
            {
                "input": "[\"5\",\"2\",\"4\"]",
                "output": "[\"[10,8,2,0,0]\"]"
            },
            {
                "input": "[\"4\",\"1\",\"1\"]",
                "output": "[\"[6,4,2,0]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long[] countOfPairs(int n, int x, int y) {",
            "cpp": "class Solution {\npublic:\n    vector<long long> countOfPairs(int n, int x, int y) {",
            "go": "func countOfPairs(n int, x int, y int) []int64 {\n\n}",
            "js": "/**\n * @param {number} n\n * @param {number} x\n * @param {number} y\n * @return {number[]}\n */\nvar countOfPairs = function(n, x, y) {",
            "python": "class Solution:\n    def countOfPairs(self, n: int, x: int, y: int) -> List[int]:"
        },
        "time": "20240121",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "countOfPairs",
            "java": "countOfPairs",
            "cpp": "countOfPairs",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.countOfPairs(3, 1, 3) == [6,0,0], \"Test 1 Error!\"\nassert my_solution.countOfPairs(5, 2, 4) == [10,8,2,0,0], \"Test 2 Error!\"\nassert my_solution.countOfPairs(4, 1, 1) == [6,4,2,0], \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int n_1 = 3;\n    int x_1 = 1;\n    int y_1 = 3;\n    long[] ans_1 = {6,0,0};\n    assert Arrays.equals(solution.countOfPairs(n_1, x_1, y_1), ans_1);\n    int n_2 = 5;\n    int x_2 = 2;\n    int y_2 = 4;\n    long[] ans_2 = {10,8,2,0,0};\n    assert Arrays.equals(solution.countOfPairs(n_2, x_2, y_2), ans_2);\n    int n_3 = 4;\n    int x_3 = 1;\n    int y_3 = 1;\n    long[] ans_3 = {6,4,2,0};\n    assert Arrays.equals(solution.countOfPairs(n_3, x_3, y_3), ans_3);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int n_1 = 3;\n    int x_1 = 1;\n    int y_1 = 3;\n    vector<long long> ans_1 = {6,0,0};\n    assert(my_solution_1.countOfPairs(n_1, x_1, y_1) == ans_1);\n    Solution my_solution_2;\n    int n_2 = 5;\n    int x_2 = 2;\n    int y_2 = 4;\n    vector<long long> ans_2 = {10,8,2,0,0};\n    assert(my_solution_2.countOfPairs(n_2, x_2, y_2) == ans_2);\n    Solution my_solution_3;\n    int n_3 = 4;\n    int x_3 = 1;\n    int y_3 = 1;\n    vector<long long> ans_3 = {6,4,2,0};\n    assert(my_solution_3.countOfPairs(n_3, x_3, y_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "n",
                "x",
                "y"
            ],
            "java": [
                "n",
                "x",
                "y"
            ],
            "cpp": [
                "n",
                "x",
                "y"
            ],
            "go": [],
            "js": []
        }
    },
    "3019": {
        "description": "给你一个下标从 0 开始的字符串 s ，该字符串由用户输入。按键变更的定义是：使用与上次使用的按键不同的键。例如 s = \\\"ab\\\" 表示按键变更一次，而 s = \\\"bBBb\\\" 不存在按键变更。\n返回用户输入过程中按键变更的次数。\n注意：shift 或 caps lock 等修饰键不计入按键变更，也就是说，如果用户先输入字母 'a' 然后输入字母 'A' ，不算作按键变更。",
        "difficulty_level": "Easy",
        "note": "1 <= s.length <= 100\ns 仅由英文大写字母和小写字母组成。",
        "codes": {
            "python": "class Solution:\n    def countKeyChanges(self, s: str) -> int:\n        return sum(x != y for x, y in pairwise(s.lower()))\n",
            "java": "class Solution {\n    public int countKeyChanges(String s) {\n        int ans = 0;\n        for (int i = 1; i < s.length(); i++) {\n            if ((s.charAt(i - 1) & 31) != (s.charAt(i) & 31)) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int countKeyChanges(string s) {\n        int ans = 0;\n        for (int i = 1; i < s.length(); i++) {\n            ans += (s[i - 1] & 31) != (s[i] & 31);\n        }\n        return ans;\n    }\n};\n",
            "go": "func countKeyChanges(s string) (ans int) {\nfor i := 1; i < len(s); i++ {\nif s[i-1]&31 != s[i]&31 {\nans++\n}\n}\nreturn\n}\n",
            "js": "/**\n * @param {string} s\n * @return {number}\n */\nvar countKeyChanges = function(s) {\n    s=s.toUpperCase()\n    let num = 0\n    let key = s[0]\n    for(let i = 0 ; i < s.length ; i ++){\n        if(key != s[i]){\n            num+=1\n            key = s[i]\n        }\n    }\n    return num\n};\n"
        },
        "cases": [
            {
                "input": "[\"\\\"aAbBcC\\\"\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"\\\"AaAaAaaA\\\"\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int countKeyChanges(String s) {",
            "cpp": "class Solution {\npublic:\n    int countKeyChanges(string s) {",
            "go": "func countKeyChanges(s string) int {\n\n}",
            "js": "/**\n * @param {string} s\n * @return {number}\n */\nvar countKeyChanges = function(s) {",
            "python": "class Solution:\n    def countKeyChanges(self, s: str) -> int:"
        },
        "time": "20240128",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "countKeyChanges",
            "java": "countKeyChanges",
            "cpp": "countKeyChanges",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.countKeyChanges(\"aAbBcC\") == 2, \"Test 1 Error!\"\nassert my_solution.countKeyChanges(\"AaAaAaaA\") == 0, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String s_1 = \"aAbBcC\";\n    int ans_1 = 2;\n    assert solution.countKeyChanges(s_1) == ans_1;\n    String s_2 = \"AaAaAaaA\";\n    int ans_2 = 0;\n    assert solution.countKeyChanges(s_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string s_1 = \"aAbBcC\";\n    int ans_1 = 2;\n    assert(my_solution_1.countKeyChanges(s_1) == ans_1);\n    Solution my_solution_2;\n    string s_2 = \"AaAaAaaA\";\n    int ans_2 = 0;\n    assert(my_solution_2.countKeyChanges(s_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "s"
            ],
            "java": [
                "s"
            ],
            "cpp": [
                "s"
            ],
            "go": [],
            "js": []
        }
    },
    "3020": {
        "description": "给你一个 正整数 数组 nums 。\n你需要从数组中选出一个满足下述条件的子集：\n你可以将选中的元素放置在一个下标从 0 开始的数组中，并使其遵循以下模式：[x, x^2, x^4, ..., x^{k/2}, x^k, x^{k/2}, ..., x^4, x^2, x]（注意，k 可以是任何 非负 的 2 的幂）。例如，[2, 4, 16, 4, 2] 和 [3, 9, 3] 都符合这一模式，而 [2, 4, 8, 4, 2] 则不符合。\n返回满足这些条件的子集中，元素数量的 最大值 。",
        "difficulty_level": "Middle",
        "note": "2 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9",
        "codes": {
            "python": "class Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        ans = cnt[1] - 1 | 1  # 奇数\n        del cnt[1]\n        for x in cnt:\n            res = 0\n            while cnt[x] > 1:\n                res += 2\n                x *= x\n            ans = max(ans, res + (1 if x in cnt else -1))  # 保证 res 是奇数\n        return ans\n",
            "java": "class Solution {\n    public int maximumLength(int[] nums) {\n        HashMap<Long, Integer> cnt = new HashMap<>();\n        for (int x : nums) {\n            cnt.merge((long) x, 1, Integer::sum);\n        }\n        Integer c1 = cnt.remove(1L);\n        int ans = c1 != null ? c1 - 1 | 1 : 0;\n        for (long x : cnt.keySet()) {\n            int res = 0;\n            for (; cnt.getOrDefault(x, 0) > 1; x *= x) {\n                res += 2;\n            }\n            ans = Math.max(ans, res + (cnt.containsKey(x) ? 1 : -1)); // 保证 res 是奇数\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int maximumLength(vector<int> &nums) {\n        unordered_map<long long, int> cnt;\n        for (int x : nums) {\n            cnt[x]++;\n        }\n        int ans = cnt[1] - 1 | 1; // 奇数\n        cnt.erase(1);\n        for (auto &[num, _] : cnt) {\n            int res = 0;\n            long long x = num;\n            for (; cnt.contains(x) && cnt[x] > 1; x *= x) {\n                res += 2; \n            }\n            ans = max(ans, res + (cnt.contains(x) ? 1 : -1)); // 保证 res 是奇数\n        }\n        return ans;\n    }\n};\n",
            "go": "func maximumLength(nums []int) int {\ncnt := map[int]int{}\nfor _, x := range nums {\ncnt[x]++\n}\nans := cnt[1] - 1 | 1 // 奇数\ndelete(cnt, 1)\nfor x := range cnt {\nres := 0\nfor ; cnt[x] > 1; x *= x {\nres += 2\n}\nres += cnt[x]\nans = max(ans, res-1|1) // 保证 res 是奇数\n}\nreturn ans\n}\n",
            "js": "var maximumLength = function(nums) {\n    // 记录每个元素出现次数\n    const map = new Map()\n    for (let i = 0; i < nums.length; i++) {\n        map.set(nums[i], map.get(nums[i]) ? map.get(nums[i]) + 1 : 1)\n    }\n\n    // 数组去重\n    const set = new Set(nums)\n    const _nums = Array.from(set)\n\n    let count = 1\n    let max = 0\n    for (let i = 0; i < _nums.length; i++) {\n        let middle = _nums[i]\n        // 中心元素为1时所有元素为1\n        if (middle === 1) {\n            max = Math.max(map.get(1) % 2 === 1 ? map.get(1) : map.get(1) - 1, max)\n            continue\n        }\n        // 以当前元素为中心组成数组\n        while(map.get(Math.sqrt(middle)) >= 2) {\n            count += 2\n            middle = Math.sqrt(middle)\n        }\n        max = Math.max(count, max)\n        count = 1\n    }\n    \n    return max\n};\n"
        },
        "cases": [
            {
                "input": "[\"[5,4,1,2,2]\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[1,3,2,4]\"]",
                "output": "[\"1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maximumLength(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    int maximumLength(vector<int>& nums) {",
            "go": "func maximumLength(nums []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumLength = function(nums) {",
            "python": "class Solution:\n    def maximumLength(self, nums: List[int]) -> int:"
        },
        "time": "20240128",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maximumLength",
            "java": "maximumLength",
            "cpp": "maximumLength",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maximumLength([5,4,1,2,2]) == 3, \"Test 1 Error!\"\nassert my_solution.maximumLength([1,3,2,4]) == 1, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {5,4,1,2,2};\n    int ans_1 = 3;\n    assert solution.maximumLength(nums_1) == ans_1;\n    int[] nums_2 = {1,3,2,4};\n    int ans_2 = 1;\n    assert solution.maximumLength(nums_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {5,4,1,2,2};\n    int ans_1 = 3;\n    assert(my_solution_1.maximumLength(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,3,2,4};\n    int ans_2 = 1;\n    assert(my_solution_2.maximumLength(nums_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3021": {
        "description": "Alice 和 Bob 在一个长满鲜花的环形草地玩一个回合制游戏。环形的草地上有一些鲜花，Alice 到 Bob 之间顺时针有 x 朵鲜花，逆时针有 y 朵鲜花。游戏过程如下：\nAlice 先行动。\n每一次行动中，当前玩家必须选择顺时针或者逆时针，然后在这个方向上摘一朵鲜花。\n一次行动结束后，如果所有鲜花都被摘完了，那么 当前 玩家抓住对手并赢得游戏的胜利。\n给你两个整数 n 和 m ，你的任务是求出满足以下条件的所有 (x, y) 对：\n按照上述规则，Alice 必须赢得游戏。\nAlice 顺时针方向上的鲜花数目 x 必须在区间 [1,n] 之间。\nAlice 逆时针方向上的鲜花数目 y 必须在区间 [1,m] 之间。\n请你返回满足题目描述的数对 (x, y) 的数目。",
        "difficulty_level": "Middle",
        "note": "1 <= n, m <= 10^5",
        "codes": {
            "python": "class Solution:\n    def flowerGame(self, n: int, m: int) -> int:\n        return n * m // 2\n",
            "java": "class Solution {\n    public long flowerGame(int n, int m) {\n        return (long) n * m / 2;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long flowerGame(int n, int m) {\n        return (long long) n * m / 2;\n    }\n};\n",
            "go": "func flowerGame(n, m int) int64 {\nreturn int64(n) * int64(m) / 2\n}",
            "js": "/**\n * @param {number} n\n * @param {number} m\n * @return {number}\n */\nvar flowerGame = function(n, m) {\n    // let x = Math.ceil(n/2)\n    // let y = m-Math.ceil(m/2)\n    // let a = n-Math.ceil(n/2)\n    // let b = Math.ceil(m/2)\n    // return x*y+a*b\n    return Math.ceil(n/2)*(m-Math.ceil(m/2)) + (n-Math.ceil(n/2))*Math.ceil(m/2)\n};\n"
        },
        "cases": [
            {
                "input": "[\"3\",\"2\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"1\",\"1\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long flowerGame(int n, int m) {",
            "cpp": "class Solution {\npublic:\n    long long flowerGame(int n, int m) {",
            "go": "func flowerGame(n int, m int) int64 {\n\n}",
            "js": "/**\n * @param {number} n\n * @param {number} m\n * @return {number}\n */\nvar flowerGame = function(n, m) {",
            "python": "class Solution:\n    def flowerGame(self, n: int, m: int) -> int:"
        },
        "time": "20240128",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "flowerGame",
            "java": "flowerGame",
            "cpp": "flowerGame",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.flowerGame(3, 2) == 3, \"Test 1 Error!\"\nassert my_solution.flowerGame(1, 1) == 0, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int n_1 = 3;\n    int m_1 = 2;\n    long ans_1 = 3;\n    assert solution.flowerGame(n_1, m_1) == ans_1;\n    int n_2 = 1;\n    int m_2 = 1;\n    long ans_2 = 0;\n    assert solution.flowerGame(n_2, m_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int n_1 = 3;\n    int m_1 = 2;\n    long long ans_1 = 3;\n    assert(my_solution_1.flowerGame(n_1, m_1) == ans_1);\n    Solution my_solution_2;\n    int n_2 = 1;\n    int m_2 = 1;\n    long long ans_2 = 0;\n    assert(my_solution_2.flowerGame(n_2, m_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "n",
                "m"
            ],
            "java": [
                "n",
                "m"
            ],
            "cpp": [
                "n",
                "m"
            ],
            "go": [],
            "js": []
        }
    },
    "3022": {
        "description": "给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。一次操作中，你可以选择 nums 中满足 0 <= i < nums.length - 1 的一个下标 i ，并将 nums[i] 和 nums[i + 1] 替换为数字 nums[i] & nums[i + 1] ，其中 & 表示按位 AND 操作。\n请你返回 至多 k 次操作以内，使 nums 中所有剩余元素按位 OR 结果的 最小值 。",
        "difficulty_level": "Hard",
        "note": "1 <= nums.length <= 10^5\n0 <= nums[i] < 2^30\n0 <= k < nums.length",
        "codes": {
            "python": "class Solution:\n    def minOrAfterOperations(self, nums: List[int], k: int) -> int:\n        ans = mask = 0\n        for b in range(max(nums).bit_length() - 1, -1, -1):\n            mask |= 1 << b\n            cnt = 0  # 操作次数\n            and_res = -1  # -1 的二进制全为 1\n            for x in nums:\n                and_res &= x & mask\n                if and_res:\n                    cnt += 1  # 合并 x，操作次数加一\n                else:\n                    and_res = -1  # 准备合并下一段\n            if cnt > k:\n                ans |= 1 << b  # 答案的这个比特位必须是 1\n                mask ^= 1 << b  # 后面不考虑这个比特位\n        return ans\n",
            "java": "class Solution {\n    public int minOrAfterOperations(int[] nums, int k) {\n        int ans = 0;\n        int mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0; // 操作次数\n            int and = -1; // -1 的二进制全为 1\n            for (int x : nums) {\n                and &= x & mask;\n                if (and != 0) {\n                    cnt++; // 合并 x，操作次数加一\n                } else {\n                    and = -1; // 准备合并下一段\n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; // 答案的这个比特位必须是 1\n                mask ^= 1 << b; // 后面不考虑这个比特位\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minOrAfterOperations(vector<int> &nums, int k) {\n        int ans = 0, mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0, and_res = -1; // -1 的二进制全为 1\n            for (int x : nums) {\n                and_res &= x & mask;\n                if (and_res) {\n                    cnt++; // 合并 x，操作次数加一\n                } else {\n                    and_res = -1; // 准备合并下一段\n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; // 答案的这个比特位必须是 1\n                mask ^= 1 << b; // 后面不考虑这个比特位\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func minOrAfterOperations(nums []int, k int) (ans int) {\nmask := 0\nfor b := 29; b >= 0; b-- {\nmask |= 1 << b\ncnt := 0  // 操作次数\nand := -1 // -1 的二进制全为 1\nfor _, x := range nums {\nand &= x & mask\nif and != 0 {\ncnt++ // 合并 x，操作次数加一\n} else {\nand = -1 // 准备合并下一段\n}\n}\nif cnt > k {\nans |= 1 << b  // 答案的这个比特位必须是 1\nmask ^= 1 << b // 后面不考虑这个比特位\n}\n}\nreturn\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[3,5,3,2,7]\",\"2\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[7,3,15,14,2,8]\",\"4\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[10,7,10,3,9,14,9,4]\",\"1\"]",
                "output": "[\"15\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minOrAfterOperations(int[] nums, int k) {",
            "cpp": "class Solution {\npublic:\n    int minOrAfterOperations(vector<int>& nums, int k) {",
            "go": "func minOrAfterOperations(nums []int, k int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOrAfterOperations = function(nums, k) {",
            "python": "class Solution:\n    def minOrAfterOperations(self, nums: List[int], k: int) -> int:"
        },
        "time": "20240128",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minOrAfterOperations",
            "java": "minOrAfterOperations",
            "cpp": "minOrAfterOperations",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minOrAfterOperations([3,5,3,2,7], 2) == 3, \"Test 1 Error!\"\nassert my_solution.minOrAfterOperations([7,3,15,14,2,8], 4) == 2, \"Test 2 Error!\"\nassert my_solution.minOrAfterOperations([10,7,10,3,9,14,9,4], 1) == 15, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {3,5,3,2,7};\n    int k_1 = 2;\n    int ans_1 = 3;\n    assert solution.minOrAfterOperations(nums_1, k_1) == ans_1;\n    int[] nums_2 = {7,3,15,14,2,8};\n    int k_2 = 4;\n    int ans_2 = 2;\n    assert solution.minOrAfterOperations(nums_2, k_2) == ans_2;\n    int[] nums_3 = {10,7,10,3,9,14,9,4};\n    int k_3 = 1;\n    int ans_3 = 15;\n    assert solution.minOrAfterOperations(nums_3, k_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {3,5,3,2,7};\n    int k_1 = 2;\n    int ans_1 = 3;\n    assert(my_solution_1.minOrAfterOperations(nums_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {7,3,15,14,2,8};\n    int k_2 = 4;\n    int ans_2 = 2;\n    assert(my_solution_2.minOrAfterOperations(nums_2, k_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {10,7,10,3,9,14,9,4};\n    int k_3 = 1;\n    int ans_3 = 15;\n    assert(my_solution_3.minOrAfterOperations(nums_3, k_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "k"
            ],
            "java": [
                "nums",
                "k"
            ],
            "cpp": [
                "nums",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3028": {
        "description": "边界上有一只蚂蚁，它有时向 左 走，有时向 右 走。\n给你一个 非零 整数数组 nums 。蚂蚁会按顺序读取 nums 中的元素，从第一个元素开始直到结束。每一步，蚂蚁会根据当前元素的值移动：\n如果 nums[i] < 0 ，向 左 移动 -nums[i]单位。\n如果 nums[i] > 0 ，向 右 移动 nums[i]单位。\n返回蚂蚁 返回 到边界上的次数。\n注意：\n边界两侧有无限的空间。\n只有在蚂蚁移动了 |nums[i]| 单位后才检查它是否位于边界上。换句话说，如果蚂蚁只是在移动过程中穿过了边界，则不会计算在内。",
        "difficulty_level": "Easy",
        "note": "1 <= nums.length <= 100\n-10 <= nums[i] <= 10\nnums[i] != 0",
        "codes": {
            "python": "class Solution:\n    def returnToBoundaryCount(self, nums: List[int]) -> int:\n        return sum(s == 0 for s in accumulate(nums))\n",
            "java": "class Solution {\n    public int returnToBoundaryCount(int[] nums) {\n        int ans = 0;\n        int sum = 0;\n        for (int x : nums) {\n            sum += x;\n            if (sum == 0) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int returnToBoundaryCount(vector<int> &nums) {\n        int ans = 0, sum = 0;\n        for (int x : nums) {\n            sum += x;\n            ans += sum == 0;\n        }\n        return ans;\n    }\n};\n",
            "go": "func returnToBoundaryCount(nums []int) (ans int) {\nsum := 0\nfor _, x := range nums {\nsum += x\nif sum == 0 {\nans++\n}\n}\nreturn\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar returnToBoundaryCount = function (nums) {\n    let sum = 0, res = 0\n    nums.forEach(item => {\n        sum += item\n        if (sum === 0) {\n            res += 1\n        }\n    })\n    return res\n};\n"
        },
        "cases": [
            {
                "input": "[\"[2,3,-5]\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"[3,2,-3,-4]\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int returnToBoundaryCount(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    int returnToBoundaryCount(vector<int>& nums) {",
            "go": "func returnToBoundaryCount(nums []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar returnToBoundaryCount = function(nums) {",
            "python": "class Solution:\n    def returnToBoundaryCount(self, nums: List[int]) -> int:"
        },
        "time": "20240204",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "returnToBoundaryCount",
            "java": "returnToBoundaryCount",
            "cpp": "returnToBoundaryCount",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.returnToBoundaryCount([2,3,-5]) == 1, \"Test 1 Error!\"\nassert my_solution.returnToBoundaryCount([3,2,-3,-4]) == 0, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {2,3,-5};\n    int ans_1 = 1;\n    assert solution.returnToBoundaryCount(nums_1) == ans_1;\n    int[] nums_2 = {3,2,-3,-4};\n    int ans_2 = 0;\n    assert solution.returnToBoundaryCount(nums_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {2,3,-5};\n    int ans_1 = 1;\n    assert(my_solution_1.returnToBoundaryCount(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {3,2,-3,-4};\n    int ans_2 = 0;\n    assert(my_solution_2.returnToBoundaryCount(nums_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3029": {
        "description": "给你一个下标从 0 开始的字符串 word 和一个整数 k 。\n在每一秒，你必须执行以下操作：\n移除 word 的前 k 个字符。\n在 word 的末尾添加 k 个任意字符。\n注意 添加的字符不必和移除的字符相同。但是，必须在每一秒钟都执行 两种 操作。\n返回将 word 恢复到其 初始 状态所需的 最短 时间（该时间必须大于零）。",
        "difficulty_level": "Middle",
        "note": "1 <= word.length <= 50\n1 <= k <= word.length\nword仅由小写英文字母组成。",
        "codes": {
            "python": "class Solution:\n    def minimumTimeToInitialState(self, s: str, k: int) -> int:\n        n = len(s)\n        z = [0] * n\n        l = r = 0\n        for i in range(1, n):\n            if i <= r:\n                z[i] = min(z[i - l], r - i + 1)\n            while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n                l, r = i, i + z[i]\n                z[i] += 1\n            if i % k == 0 and z[i] >= n - i:\n                return i // k\n        return (n - 1) // k + 1\n",
            "java": "class Solution {\n    public int minimumTimeToInitialState(String S, int k) {\n        char[] s = S.toCharArray();\n        int n = s.length;\n        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(z[i - l], r - i + 1);\n            }\n            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n                l = i;\n                r = i + z[i];\n                z[i]++;\n            }\n            if (i % k == 0 && z[i] >= n - i) {\n                return i / k;\n            }\n        }\n        return (n - 1) / k + 1;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumTimeToInitialState(string s, int k) {\n        int n = s.size();\n        vector<int> z(n);\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = min(z[i - l], r - i + 1);\n            }\n            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n                l = i;\n                r = i + z[i];\n                z[i]++;\n            }\n            if (i % k == 0 && z[i] >= n - i) {\n                return i / k;\n            }\n        }\n        return (n - 1) / k + 1;\n    }\n};\n",
            "go": "func minimumTimeToInitialState(s string, k int) int {\nn := len(s)\nz := make([]int, n)\nfor i, l, r := 1, 0, 0; i < n; i++ {\nif i <= r {\nz[i] = min(z[i-l], r-i+1)\n}\nfor i+z[i] < n && s[z[i]] == s[i+z[i]] {\nl, r = i, i+z[i]\nz[i]++\n}\nif i%k == 0 && z[i] >= n-i {\nreturn i / k\n}\n}\nreturn (n-1)/k + 1\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"\\\"abacaba\\\"\",\"3\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"\\\"abacaba\\\"\",\"4\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"\\\"abcbabcd\\\"\",\"2\"]",
                "output": "[\"4\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumTimeToInitialState(String word, int k) {",
            "cpp": "class Solution {\npublic:\n    int minimumTimeToInitialState(string word, int k) {",
            "go": "func minimumTimeToInitialState(word string, k int) int {\n\n}",
            "js": "/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar minimumTimeToInitialState = function(word, k) {",
            "python": "class Solution:\n    def minimumTimeToInitialState(self, word: str, k: int) -> int:"
        },
        "time": "20240204",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumTimeToInitialState",
            "java": "minimumTimeToInitialState",
            "cpp": "minimumTimeToInitialState",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumTimeToInitialState(\"abacaba\", 3) == 2, \"Test 1 Error!\"\nassert my_solution.minimumTimeToInitialState(\"abacaba\", 4) == 1, \"Test 2 Error!\"\nassert my_solution.minimumTimeToInitialState(\"abcbabcd\", 2) == 4, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String word_1 = \"abacaba\";\n    int k_1 = 3;\n    int ans_1 = 2;\n    assert solution.minimumTimeToInitialState(word_1, k_1) == ans_1;\n    String word_2 = \"abacaba\";\n    int k_2 = 4;\n    int ans_2 = 1;\n    assert solution.minimumTimeToInitialState(word_2, k_2) == ans_2;\n    String word_3 = \"abcbabcd\";\n    int k_3 = 2;\n    int ans_3 = 4;\n    assert solution.minimumTimeToInitialState(word_3, k_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string word_1 = \"abacaba\";\n    int k_1 = 3;\n    int ans_1 = 2;\n    assert(my_solution_1.minimumTimeToInitialState(word_1, k_1) == ans_1);\n    Solution my_solution_2;\n    string word_2 = \"abacaba\";\n    int k_2 = 4;\n    int ans_2 = 1;\n    assert(my_solution_2.minimumTimeToInitialState(word_2, k_2) == ans_2);\n    Solution my_solution_3;\n    string word_3 = \"abcbabcd\";\n    int k_3 = 2;\n    int ans_3 = 4;\n    assert(my_solution_3.minimumTimeToInitialState(word_3, k_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "word",
                "k"
            ],
            "java": [
                "word",
                "k"
            ],
            "cpp": [
                "word",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3030": {
        "description": "给你一个下标从 0 开始、大小为 m x n 的网格 image ，表示一个灰度图像，其中 image[i][j] 表示在范围 [0..255] 内的某个像素强度。另给你一个 非负 整数 threshold 。\n如果 image[a][b] 和 image[c][d] 满足 |a - c| + |b - d| == 1 ，则称这两个像素是 相邻像素 。\n区域 是一个 3 x 3 的子网格，且满足区域中任意两个 相邻 像素之间，像素强度的 绝对差 小于或等于 threshold 。\n区域 内的所有像素都认为属于该区域，而一个像素 可以 属于 多个 区域。\n你需要计算一个下标从 0 开始、大小为 m x n 的网格 result ，其中 result[i][j] 是 image[i][j] 所属区域的 平均 强度，向下取整 到最接近的整数。如果 image[i][j] 属于多个区域，result[i][j] 是这些区域的 “取整后的平均强度” 的 平均值，也 向下取整 到最接近的整数。如果 image[i][j] 不属于任何区域，则 result[i][j] 等于 image[i][j] 。\n返回网格 result 。",
        "difficulty_level": "Middle",
        "note": "3 <= n, m <= 500\n0 <= image[i][j] <= 255\n0 <= threshold <= 255",
        "codes": {
            "python": "class Solution:\n    def resultGrid(self, a: List[List[int]], threshold: int) -> List[List[int]]:\n        m, n = len(a), len(a[0])\n        result = [[0] * n for _ in range(m)]\n        cnt = [[0] * n for _ in range(m)]\n        for i in range(2, m):\n            for j in range(2, n):\n                # 检查左右相邻格子\n                ok = True\n                for row in a[i - 2: i + 1]:\n                    if abs(row[j - 2] - row[j - 1]) > threshold or abs(row[j - 1] - row[j]) > threshold:\n                        ok = False\n                        break  # 不合法，下一个\n                if not ok: continue\n\n                # 检查上下相邻格子\n                for y in range(j - 2, j + 1):\n                    if abs(a[i - 2][y] - a[i - 1][y]) > threshold or abs(a[i - 1][y] - a[i][y]) > threshold:\n                        ok = False\n                        break  # 不合法，下一个\n                if not ok: continue\n\n                # 合法，计算 3x3 子网格的平均值\n                avg = sum(a[x][y] for x in range(i - 2, i + 1) for y in range(j - 2, j + 1)) // 9\n\n                # 更新 3x3 子网格内的 result\n                for x in range(i - 2, i + 1):\n                    for y in range(j - 2, j + 1):\n                        result[x][y] += avg  # 先累加，最后再求平均值\n                        cnt[x][y] += 1\n\n        for i, row in enumerate(cnt):\n            for j, c in enumerate(row):\n                if c == 0:  # (i,j) 不属于任何子网格\n                    result[i][j] = a[i][j]\n                else:\n                    result[i][j] //= c  # 求平均值\n        return result\n",
            "java": "public class Solution {\n    public int[][] resultGrid(int[][] a, int threshold) {\n        int m = a.length;\n        int n = a[0].length;\n        int[][] result = new int[m][n];\n        int[][] cnt = new int[m][n];\n        for (int i = 2; i < m; i++) {\n            next:\n            for (int j = 2; j < n; j++) {\n                // 检查左右相邻格子\n                for (int x = i - 2; x <= i; x++) {\n                    if (Math.abs(a[x][j - 2] - a[x][j - 1]) > threshold || Math.abs(a[x][j - 1] - a[x][j]) > threshold) {\n                        continue next; // 不合法，下一个\n                    }\n                }\n\n                // 检查上下相邻格子\n                for (int y = j - 2; y <= j; ++y) {\n                    if (Math.abs(a[i - 2][y] - a[i - 1][y]) > threshold || Math.abs(a[i - 1][y] - a[i][y]) > threshold) {\n                        continue next; // 不合法，下一个\n                    }\n                }\n\n                // 合法，计算 3x3 子网格的平均值\n                int avg = 0;\n                for (int x = i - 2; x <= i; x++) {\n                    for (int y = j - 2; y <= j; y++) {\n                        avg += a[x][y];\n                    }\n                }\n                avg /= 9;\n\n                // 更新 3x3 子网格内的 result\n                for (int x = i - 2; x <= i; x++) {\n                    for (int y = j - 2; y <= j; y++) {\n                        result[x][y] += avg; // 先累加，最后再求平均值\n                        cnt[x][y]++;\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (cnt[i][j] == 0) { // (i,j) 不属于任何子网格\n                    result[i][j] = a[i][j];\n                } else {\n                    result[i][j] /= cnt[i][j]; // 求平均值\n                }\n            }\n        }\n        return result;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    vector<vector<int>> resultGrid(vector<vector<int>> &a, int threshold) {\n        int m = a.size(), n = a[0].size();\n        vector<vector<int>> result(m, vector<int>(n));\n        vector<vector<int>> cnt(m, vector<int>(n));\n        for (int i = 2; i < m; i++) {\n            for (int j = 2; j < n; j++) {\n                // 检查左右相邻格子\n                bool ok = true;\n                for (int x = i - 2; x <= i; x++) {\n                    if (abs(a[x][j - 2] - a[x][j - 1]) > threshold || abs(a[x][j - 1] - a[x][j]) > threshold) {\n                        ok = false;\n                        break; // 不合法，下一个\n                    }\n                }\n                if (!ok) continue;\n\n                // 检查上下相邻格子\n                for (int y = j - 2; y <= j; y++) {\n                    if (abs(a[i - 2][y] - a[i - 1][y]) > threshold || abs(a[i - 1][y] - a[i][y]) > threshold) {\n                        ok = false;\n                        break; // 不合法，下一个\n                    }\n                }\n                if (!ok) continue;\n\n                // 合法，计算 3x3 子网格的平均值\n                int avg = 0;\n                for (int x = i - 2; x <= i; x++) {\n                    for (int y = j - 2; y <= j; y++) {\n                        avg += a[x][y];\n                    }\n                }\n                avg /= 9;\n\n                // 更新 3x3 子网格内的 result\n                for (int x = i - 2; x <= i; x++) {\n                    for (int y = j - 2; y <= j; y++) {\n                        result[x][y] += avg; // 先累加，最后再求平均值\n                        cnt[x][y]++;\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (cnt[i][j] == 0) { // (i,j) 不属于任何子网格\n                    result[i][j] = a[i][j];\n                } else {\n                    result[i][j] /= cnt[i][j]; // 求平均值\n                }\n            }\n        }\n        return result;\n    }\n};\n",
            "go": "func resultGrid(a [][]int, threshold int) [][]int {\nm, n := len(a), len(a[0])\nresult := make([][]int, m)\ncnt := make([][]int, m)\nfor i := range result {\nresult[i] = make([]int, n)\ncnt[i] = make([]int, n)\n}\nfor i := 2; i < m; i++ {\nnext:\nfor j := 2; j < n; j++ {\n// 检查左右相邻格子\nfor _, row := range a[i-2 : i+1] {\nif abs(row[j-2]-row[j-1]) > threshold || abs(row[j-1]-row[j]) > threshold {\ncontinue next // 不合法，下一个\n}\n}\n\n// 检查上下相邻格子\nfor y := j - 2; y <= j; y++ {\nif abs(a[i-2][y]-a[i-1][y]) > threshold || abs(a[i-1][y]-a[i][y]) > threshold {\ncontinue next // 不合法，下一个\n}\n}\n\n// 合法，计算 3x3 子网格的平均值\navg := 0\nfor x := i - 2; x <= i; x++ {\nfor y := j - 2; y <= j; y++ {\navg += a[x][y]\n}\n}\navg /= 9\n\n// 更新 3x3 子网格内的 result\nfor x := i - 2; x <= i; x++ {\nfor y := j - 2; y <= j; y++ {\nresult[x][y] += avg // 先累加，最后再求平均值\ncnt[x][y]++\n}\n}\n}\n}\n\nfor i, row := range cnt {\nfor j, c := range row {\nif c == 0 { // (i,j) 不属于任何子网格\nresult[i][j] = a[i][j]\n} else {\nresult[i][j] /= c // 求平均值\n}\n}\n}\nreturn result\n}\n\nfunc abs(x int) int { if x < 0 { return -x }; return x }\n",
            "js": "/**\n * @param {number[][]} image\n * @param {number} threshold\n * @return {number[][]}\n */\nvar resultGrid = function (image, threshold) {\n  // 和image相同尺寸的二维数组并填充null\n  let res = image.map((innerArr) => innerArr.map(() => null));\n  // 寻找区域的左上角第一个元素\n  for (let i = 0; i < image.length - 2; i++) {\n    for (let j = 0; j < image[i].length - 2; j++) {\n      if (\n        !(Math.abs(image[i][j] - image[i + 1][j]) > threshold) &&\n        !(Math.abs(image[i][j] - image[i][j + 1]) > threshold) &&\n        !(Math.abs(image[i][j + 1] - image[i + 1][j + 1]) > threshold) &&\n        !(Math.abs(image[i][j + 1] - image[i][j + 2]) > threshold) &&\n        !(Math.abs(image[i][j + 2] - image[i + 1][j + 2]) > threshold) &&\n        !(Math.abs(image[i + 1][j] - image[i + 1][j + 1]) > threshold) &&\n        !(Math.abs(image[i + 1][j] - image[i + 2][j]) > threshold) &&\n        !(Math.abs(image[i + 2][j] - image[i + 2][j + 1]) > threshold) &&\n        !(Math.abs(image[i + 1][j + 1] - image[i + 2][j + 1]) > threshold) &&\n        !(Math.abs(image[i + 1][j + 1] - image[i + 1][j + 2]) > threshold) &&\n        !(Math.abs(image[i + 2][j + 1] - image[i + 2][j + 2]) > threshold) &&\n        !(Math.abs(image[i + 1][j + 2] - image[i + 2][j + 2]) > threshold)\n      ) {\n        // 这符合区域\n        // 累加并统计累加次数方便日后求均值\n        for (let a = 0; a < 3; a++) {\n          for (let b = 0; b < 3; b++) {\n            // 第一次先把null转成对象\n            if (!res[i + a][j + b])\n              res[i + a][j + b] = {\n                value: 0,\n                num: 0,\n              };\n            // 后续累加并记录累加次数\n            res[i + a][j + b].value += Math.floor(\n              (image[i][j] +\n                image[i][j + 1] +\n                image[i][j + 2] +\n                image[i + 1][j] +\n                image[i + 1][j + 1] +\n                image[i + 1][j + 2] +\n                image[i + 2][j] +\n                image[i + 2][j + 1] +\n                image[i + 2][j + 2]) /\n              9\n            );\n            res[i + a][j + b].num++;\n          }\n        }\n      }\n    }\n  }\n  res = res.map((v, i) => {\n    return v.map((item, j) => {\n      // 求均值\n      if (item) {\n        return Math.floor(item.value / item.num);\n      } else {\n        // 没有所属的区域\n        return image[i][j];\n      }\n    });\n  });\n  return res;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[[5,6,7,10],[8,9,10,10],[11,12,13,10]]\",\"3\"]",
                "output": "[\"[[9,9,9,9],[9,9,9,9],[9,9,9,9]]\"]"
            },
            {
                "input": "[\"[[10,20,30],[15,25,35],[20,30,40],[25,35,45]]\",\"12\"]",
                "output": "[\"[[25,25,25],[27,27,27],[27,27,27],[30,30,30]]\"]"
            },
            {
                "input": "[\"[[5,6,7],[8,9,10],[11,12,13]]\",\"1\"]",
                "output": "[\"[[5,6,7],[8,9,10],[11,12,13]]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int[][] resultGrid(int[][] image, int threshold) {",
            "cpp": "class Solution {\npublic:\n    vector<vector<int>> resultGrid(vector<vector<int>>& image, int threshold) {",
            "go": "func resultGrid(image [][]int, threshold int) [][]int {\n\n}",
            "js": "/**\n * @param {number[][]} image\n * @param {number} threshold\n * @return {number[][]}\n */\nvar resultGrid = function(image, threshold) {",
            "python": "class Solution:\n    def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:"
        },
        "time": "20240204",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "resultGrid",
            "java": "resultGrid",
            "cpp": "resultGrid",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.resultGrid([[5,6,7,10],[8,9,10,10],[11,12,13,10]], 3) == [[9,9,9,9],[9,9,9,9],[9,9,9,9]], \"Test 1 Error!\"\nassert my_solution.resultGrid([[10,20,30],[15,25,35],[20,30,40],[25,35,45]], 12) == [[25,25,25],[27,27,27],[27,27,27],[30,30,30]], \"Test 2 Error!\"\nassert my_solution.resultGrid([[5,6,7],[8,9,10],[11,12,13]], 1) == [[5,6,7],[8,9,10],[11,12,13]], \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] image_1 = {{5,6,7,10},{8,9,10,10},{11,12,13,10}};\n    int threshold_1 = 3;\n    int[][] ans_1 = {{9,9,9,9},{9,9,9,9},{9,9,9,9}};\n    assert Arrays.deepEquals(solution.resultGrid(image_1, threshold_1), ans_1);\n    int[][] image_2 = {{10,20,30},{15,25,35},{20,30,40},{25,35,45}};\n    int threshold_2 = 12;\n    int[][] ans_2 = {{25,25,25},{27,27,27},{27,27,27},{30,30,30}};\n    assert Arrays.deepEquals(solution.resultGrid(image_2, threshold_2), ans_2);\n    int[][] image_3 = {{5,6,7},{8,9,10},{11,12,13}};\n    int threshold_3 = 1;\n    int[][] ans_3 = {{5,6,7},{8,9,10},{11,12,13}};\n    assert Arrays.deepEquals(solution.resultGrid(image_3, threshold_3), ans_3);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> image_1 = {{5,6,7,10},{8,9,10,10},{11,12,13,10}};\n    int threshold_1 = 3;\n    vector<vector<int>> ans_1 = {{9,9,9,9},{9,9,9,9},{9,9,9,9}};\n    assert(my_solution_1.resultGrid(image_1, threshold_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> image_2 = {{10,20,30},{15,25,35},{20,30,40},{25,35,45}};\n    int threshold_2 = 12;\n    vector<vector<int>> ans_2 = {{25,25,25},{27,27,27},{27,27,27},{30,30,30}};\n    assert(my_solution_2.resultGrid(image_2, threshold_2) == ans_2);\n    Solution my_solution_3;\n    vector<vector<int>> image_3 = {{5,6,7},{8,9,10},{11,12,13}};\n    int threshold_3 = 1;\n    vector<vector<int>> ans_3 = {{5,6,7},{8,9,10},{11,12,13}};\n    assert(my_solution_3.resultGrid(image_3, threshold_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "image",
                "threshold"
            ],
            "java": [
                "image",
                "threshold"
            ],
            "cpp": [
                "image",
                "threshold"
            ],
            "go": [],
            "js": []
        }
    },
    "3031": {
        "description": "给你一个下标从 0 开始的字符串 word 和一个整数 k 。\n在每一秒，你必须执行以下操作：\n移除 word 的前 k 个字符。\n在 word 的末尾添加 k 个任意字符。\n注意 添加的字符不必和移除的字符相同。但是，必须在每一秒钟都执行 两种 操作。\n返回将 word 恢复到其 初始 状态所需的 最短 时间（该时间必须大于零）。",
        "difficulty_level": "Hard",
        "note": "1 <= word.length <= 10^6\n1 <= k <= word.length\nword仅由小写英文字母组成。",
        "codes": {
            "python": "class Solution:\n    def minimumTimeToInitialState(self, s: str, k: int) -> int:\n        n = len(s)\n        z = [0] * n\n        l = r = 0\n        for i in range(1, n):\n            if i <= r:\n                z[i] = min(z[i - l], r - i + 1)\n            while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n                l, r = i, i + z[i]\n                z[i] += 1\n            if i % k == 0 and z[i] >= n - i:\n                return i // k\n        return (n - 1) // k + 1\n",
            "java": "class Solution {\n    public int minimumTimeToInitialState(String S, int k) {\n        char[] s = S.toCharArray();\n        int n = s.length;\n        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(z[i - l], r - i + 1);\n            }\n            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n                l = i;\n                r = i + z[i];\n                z[i]++;\n            }\n            if (i % k == 0 && z[i] >= n - i) {\n                return i / k;\n            }\n        }\n        return (n - 1) / k + 1;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumTimeToInitialState(string s, int k) {\n        int n = s.size();\n        vector<int> z(n);\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = min(z[i - l], r - i + 1);\n            }\n            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n                l = i;\n                r = i + z[i];\n                z[i]++;\n            }\n            if (i % k == 0 && z[i] >= n - i) {\n                return i / k;\n            }\n        }\n        return (n - 1) / k + 1;\n    }\n};\n",
            "go": "func minimumTimeToInitialState(s string, k int) int {\nn := len(s)\nz := make([]int, n)\nfor i, l, r := 1, 0, 0; i < n; i++ {\nif i <= r {\nz[i] = min(z[i-l], r-i+1)\n}\nfor i+z[i] < n && s[z[i]] == s[i+z[i]] {\nl, r = i, i+z[i]\nz[i]++\n}\nif i%k == 0 && z[i] >= n-i {\nreturn i / k\n}\n}\nreturn (n-1)/k + 1\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"\\\"abacaba\\\"\",\"3\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"\\\"abacaba\\\"\",\"4\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"\\\"abcbabcd\\\"\",\"2\"]",
                "output": "[\"4\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumTimeToInitialState(String word, int k) {",
            "cpp": "class Solution {\npublic:\n    int minimumTimeToInitialState(string word, int k) {",
            "go": "func minimumTimeToInitialState(word string, k int) int {\n\n}",
            "js": "/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar minimumTimeToInitialState = function(word, k) {",
            "python": "class Solution:\n    def minimumTimeToInitialState(self, word: str, k: int) -> int:"
        },
        "time": "20240204",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumTimeToInitialState",
            "java": "minimumTimeToInitialState",
            "cpp": "minimumTimeToInitialState",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumTimeToInitialState(\"abacaba\", 3) == 2, \"Test 1 Error!\"\nassert my_solution.minimumTimeToInitialState(\"abacaba\", 4) == 1, \"Test 2 Error!\"\nassert my_solution.minimumTimeToInitialState(\"abcbabcd\", 2) == 4, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String word_1 = \"abacaba\";\n    int k_1 = 3;\n    int ans_1 = 2;\n    assert solution.minimumTimeToInitialState(word_1, k_1) == ans_1;\n    String word_2 = \"abacaba\";\n    int k_2 = 4;\n    int ans_2 = 1;\n    assert solution.minimumTimeToInitialState(word_2, k_2) == ans_2;\n    String word_3 = \"abcbabcd\";\n    int k_3 = 2;\n    int ans_3 = 4;\n    assert solution.minimumTimeToInitialState(word_3, k_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string word_1 = \"abacaba\";\n    int k_1 = 3;\n    int ans_1 = 2;\n    assert(my_solution_1.minimumTimeToInitialState(word_1, k_1) == ans_1);\n    Solution my_solution_2;\n    string word_2 = \"abacaba\";\n    int k_2 = 4;\n    int ans_2 = 1;\n    assert(my_solution_2.minimumTimeToInitialState(word_2, k_2) == ans_2);\n    Solution my_solution_3;\n    string word_3 = \"abcbabcd\";\n    int k_3 = 2;\n    int ans_3 = 4;\n    assert(my_solution_3.minimumTimeToInitialState(word_3, k_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "word",
                "k"
            ],
            "java": [
                "word",
                "k"
            ],
            "cpp": [
                "word",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3033": {
        "description": "给你一个下标从 0 开始、大小为 m x n 的整数矩阵 matrix ，新建一个下标从 0 开始、名为 answer 的矩阵。使 answer 与 matrix 相等，接着将其中每个值为 -1 的元素替换为所在列的 最大 元素。\n返回矩阵 answer 。",
        "difficulty_level": "Easy",
        "note": "m == matrix.length\nn == matrix[i].length\n2 <= m, n <= 50\n-1 <= matrix[i][j] <= 100\n测试用例中生成的输入满足每列至少包含一个非负整数。",
        "codes": {
            "python": "class Solution:\n    def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:\n        n, m = len(matrix), len(matrix[0])\n        for j in range(m):\n            zd = -1\n            for i in range(n):\n                zd = max(zd, matrix[i][j])\n            for i in range(n):\n                if matrix[i][j] == -1:\n                    matrix[i][j] = zd\n        return matrix\n",
            "java": "public class Solution {\n    public int[][] modifiedMatrix(int[][] matrix) {\n        int n = matrix.length; \n        int m = matrix[0].length; \n        for (int j = 0; j < m; j++) {\n            int zd = -1; \n            for (int i = 0; i < n; i++) {\n                zd = Math.max(zd, matrix[i][j]); \n            }\n            for (int i = 0; i < n; i++) {\n                if (matrix[i][j] == -1) {\n                    matrix[i][j] = zd; \n                }\n            }\n        }\n        return matrix; \n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    vector<vector<int>> modifiedMatrix(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        for (int j = 0; j < m; j++) {\n            int zd = -1;\n            for (int i = 0; i < n; i++) {\n                zd = max(zd, matrix[i][j]);\n            }\n            for (int i = 0; i < n; i++) {\n                if (matrix[i][j] == -1) {\n                    matrix[i][j] = zd;\n                }\n            }\n        }\n        return matrix;\n    }\n};\n",
            "go": "func modifiedMatrix(matrix [][]int) [][]int {\n    n := len(matrix)\n    m := len(matrix[0])\n    for j := 0; j < m; j++ {\n        zd := -1\n        for i := 0; i < n; i++ {\n            zd = max(zd, matrix[i][j])\n        }\n        for i := 0; i < n; i++ {\n            if matrix[i][j] == -1 {\n                matrix[i][j] = zd\n            }\n        }\n    }\n    return matrix\n}\n\nfunc max(a, b int) int {\n    if a > b {\n    return a\n}\nreturn b\n}\n",
            "js": "var modifiedMatrix = function(matrix) {\n    let n = matrix.length;\n    let m = matrix[0].length;\n    for (let j = 0; j < m; j++) {\n        let zd = -1;\n        for (let i = 0; i < n; i++) {\n            zd = Math.max(zd, matrix[i][j]);\n        }\n        for (let i = 0; i < n; i++) {\n            if (matrix[i][j] == -1) {\n                matrix[i][j] = zd;\n            }\n        }\n    }\n    return matrix;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[[1,2,-1],[4,-1,6],[7,8,9]]\"]",
                "output": "[\"[[1,2,9],[4,8,6],[7,8,9]]\"]"
            },
            {
                "input": "[\"[[3,-1],[5,2]]\"]",
                "output": "[\"[[3,2],[5,2]]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int[][] modifiedMatrix(int[][] matrix) {",
            "cpp": "class Solution {\npublic:\n    vector<vector<int>> modifiedMatrix(vector<vector<int>>& matrix) {",
            "go": "func modifiedMatrix(matrix [][]int) [][]int {\n\n}",
            "js": "/**\n * @param {number[][]} matrix\n * @return {number[][]}\n */\nvar modifiedMatrix = function(matrix) {",
            "python": "class Solution:\n    def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:"
        },
        "time": "20240211",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "modifiedMatrix",
            "java": "modifiedMatrix",
            "cpp": "modifiedMatrix",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.modifiedMatrix([[1,2,-1],[4,-1,6],[7,8,9]]) == [[1,2,9],[4,8,6],[7,8,9]], \"Test 1 Error!\"\nassert my_solution.modifiedMatrix([[3,-1],[5,2]]) == [[3,2],[5,2]], \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] matrix_1 = {{1,2,-1},{4,-1,6},{7,8,9}};\n    int[][] ans_1 = {{1,2,9},{4,8,6},{7,8,9}};\n    assert Arrays.deepEquals(solution.modifiedMatrix(matrix_1), ans_1);\n    int[][] matrix_2 = {{3,-1},{5,2}};\n    int[][] ans_2 = {{3,2},{5,2}};\n    assert Arrays.deepEquals(solution.modifiedMatrix(matrix_2), ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> matrix_1 = {{1,2,-1},{4,-1,6},{7,8,9}};\n    vector<vector<int>> ans_1 = {{1,2,9},{4,8,6},{7,8,9}};\n    assert(my_solution_1.modifiedMatrix(matrix_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> matrix_2 = {{3,-1},{5,2}};\n    vector<vector<int>> ans_2 = {{3,2},{5,2}};\n    assert(my_solution_2.modifiedMatrix(matrix_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "matrix"
            ],
            "java": [
                "matrix"
            ],
            "cpp": [
                "matrix"
            ],
            "go": [],
            "js": []
        }
    },
    "3034": {
        "description": "给你一个下标从 0 开始长度为 n 的整数数组 nums ，和一个下标从 0 开始长度为 m 的整数数组 pattern ，pattern 数组只包含整数 -1 ，0 和 1 。\n大小为 m + 1 的子数组 nums[i..j] 如果对于每个元素 pattern[k] 都满足以下条件，那么我们说这个子数组匹配模式数组 pattern ：\n如果 pattern[k] == 1 ，那么 nums[i + k + 1] > nums[i + k]\n如果 pattern[k] == 0 ，那么 nums[i + k + 1] == nums[i + k]\n如果 pattern[k] == -1 ，那么 nums[i + k + 1] < nums[i + k]\n请你返回匹配 pattern 的 nums 子数组的 数目 。",
        "difficulty_level": "Middle",
        "note": "2 <= n == nums.length <= 100\n1 <= nums[i] <= 10^9\n1 <= m == pattern.length < n\n-1 <= pattern[i] <= 1",
        "codes": {
            "python": "class Solution:\n    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:\n        m = len(pattern)\n        pi = [0] * m\n        cnt = 0\n        for i in range(1, m):\n            v = pattern[i]\n            while cnt and pattern[cnt] != v:\n                cnt = pi[cnt - 1]\n            if pattern[cnt] == v:\n                cnt += 1\n            pi[i] = cnt\n\n        ans = cnt = 0\n        for x, y in pairwise(nums):\n            v = (y > x) - (y < x)\n            while cnt and pattern[cnt] != v:\n                cnt = pi[cnt - 1]\n            if pattern[cnt] == v:\n                cnt += 1\n            if cnt == m:\n                ans += 1\n                cnt = pi[cnt - 1]\n        return ans\n",
            "java": "class Solution {\n    public int countMatchingSubarrays(int[] nums, int[] pattern) {\n        int m = pattern.length;\n        int[] pi = new int[m];\n        int cnt = 0;\n        for (int i = 1; i < m; i++) {\n            int v = pattern[i];\n            while (cnt > 0 && pattern[cnt] != v) {\n                cnt = pi[cnt - 1];\n            }\n            if (pattern[cnt] == v) {\n                cnt++;\n            }\n            pi[i] = cnt;\n        }\n\n        int ans = 0;\n        cnt = 0;\n        for (int i = 1; i < nums.length; i++) {\n            int v = Integer.compare(nums[i], nums[i - 1]);\n            while (cnt > 0 && pattern[cnt] != v) {\n                cnt = pi[cnt - 1];\n            }\n            if (pattern[cnt] == v) {\n                cnt++;\n            }\n            if (cnt == m) {\n                ans++;\n                cnt = pi[cnt - 1];\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int countMatchingSubarrays(vector<int> &nums, vector<int> &pattern) {\n        int m = pattern.size();\n        vector<int> pi(m);\n        int cnt = 0;\n        for (int i = 1; i < m; i++) {\n            int v = pattern[i];\n            while (cnt && pattern[cnt] != v) {\n                cnt = pi[cnt - 1];\n            }\n            if (pattern[cnt] == v) {\n                cnt++;\n            }\n            pi[i] = cnt;\n        }\n\n        int ans = 0;\n        cnt = 0;\n        for (int i = 1; i < nums.size(); i++) {\n            int x = nums[i - 1], y = nums[i];\n            int v = (y > x) - (y < x);\n            while (cnt && pattern[cnt] != v) {\n                cnt = pi[cnt - 1];\n            }\n            if (pattern[cnt] == v) {\n                cnt++;\n            }\n            if (cnt == m) {\n                ans++;\n                cnt = pi[cnt - 1];\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func countMatchingSubarrays(nums, pattern []int) (ans int) {\nm := len(pattern)\npi := make([]int, m)\ncnt := 0\nfor i := 1; i < m; i++ {\nv := pattern[i]\nfor cnt > 0 && pattern[cnt] != v {\ncnt = pi[cnt-1]\n}\nif pattern[cnt] == v {\ncnt++\n}\npi[i] = cnt\n}\n\ncnt = 0\nfor i := 1; i < len(nums); i++ {\nv := cmp.Compare(nums[i], nums[i-1])\nfor cnt > 0 && pattern[cnt] != v {\ncnt = pi[cnt-1]\n}\nif pattern[cnt] == v {\ncnt++\n}\nif cnt == m {\nans++\ncnt = pi[cnt-1]\n}\n}\nreturn\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @param {number[]} pattern\n * @return {number}\n */\nvar countMatchingSubarrays = function (nums, pattern) {\n  const obj = {\n    '-1': 'D',\n    '0': 'E',\n    '1': 'I',\n  }\n  const p = pattern.map(item => obj[item]).join('');\n\n  const n = nums.length;\n  let str = '';\n  for (let i = 0; i < n - 1; i++) {\n    if (nums[i + 1] > nums[i]) {\n      str += obj['1'];\n    } else if (nums[i + 1] === nums[i]) {\n      str += obj['0'];\n    } else {\n      str += obj['-1'];\n    }\n  }\n\n  let idx = -1;\n  let ans = 0;\n  while ((idx = str.indexOf(p, idx + 1)) !== -1) {\n    ans++;\n  }\n  return ans;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,2,3,4,5,6]\",\"[1,1]\"]",
                "output": "[\"4\"]"
            },
            {
                "input": "[\"[1,4,4,1,3,5,5,3]\",\"[1,0,-1]\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int countMatchingSubarrays(int[] nums, int[] pattern) {",
            "cpp": "class Solution {\npublic:\n    int countMatchingSubarrays(vector<int>& nums, vector<int>& pattern) {",
            "go": "func countMatchingSubarrays(nums []int, pattern []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number[]} pattern\n * @return {number}\n */\nvar countMatchingSubarrays = function(nums, pattern) {",
            "python": "class Solution:\n    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:"
        },
        "time": "20240211",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "countMatchingSubarrays",
            "java": "countMatchingSubarrays",
            "cpp": "countMatchingSubarrays",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.countMatchingSubarrays([1,2,3,4,5,6], [1,1]) == 4, \"Test 1 Error!\"\nassert my_solution.countMatchingSubarrays([1,4,4,1,3,5,5,3], [1,0,-1]) == 2, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,3,4,5,6};\n    int[] pattern_1 = {1,1};\n    int ans_1 = 4;\n    assert solution.countMatchingSubarrays(nums_1, pattern_1) == ans_1;\n    int[] nums_2 = {1,4,4,1,3,5,5,3};\n    int[] pattern_2 = {1,0,-1};\n    int ans_2 = 2;\n    assert solution.countMatchingSubarrays(nums_2, pattern_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,3,4,5,6};\n    vector<int> pattern_1 = {1,1};\n    int ans_1 = 4;\n    assert(my_solution_1.countMatchingSubarrays(nums_1, pattern_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,4,4,1,3,5,5,3};\n    vector<int> pattern_2 = {1,0,-1};\n    int ans_2 = 2;\n    assert(my_solution_2.countMatchingSubarrays(nums_2, pattern_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "pattern"
            ],
            "java": [
                "nums",
                "pattern"
            ],
            "cpp": [
                "nums",
                "pattern"
            ],
            "go": [],
            "js": []
        }
    },
    "3035": {
        "description": "给你一个下标从 0 开始的字符串数组 words ，数组的长度为 n ，且包含下标从 0 开始的若干字符串。\n你可以执行以下操作 任意 次数（包括零次）：\n选择整数i、j、x和y，满足0 <= i, j < n，0 <= x < words[i].length，0 <= y < words[j].length，交换 字符 words[i][x] 和 words[j][y] 。\n返回一个整数，表示在执行一些操作后，words 中可以包含的回文串的 最大 数量。\n注意：在操作过程中，i 和 j 可以相等。",
        "difficulty_level": "Middle",
        "note": "1 <= words.length <= 1000\n1 <= words[i].length <= 100\nwords[i] 仅由小写英文字母组成。",
        "codes": {
            "python": "class Solution:\n    def maxPalindromesAfterOperations(self, words: List[str]) -> int:\n        ans = tot = 0\n        cnt = Counter()\n        for w in words:\n            tot += len(w)\n            cnt += Counter(w)\n        tot -= sum(c % 2 for c in cnt.values())  # 减去出现次数为奇数的字母\n\n        words.sort(key=len)  # 按照长度从小到大排序\n        for w in words:\n            tot -= len(w) // 2 * 2  # 长为奇数的字符串，长度要减一\n            if tot < 0: break\n            ans += 1\n        return ans\n",
            "java": "class Solution {\n    public int maxPalindromesAfterOperations(String[] words) {\n        int tot = 0;\n        int mask = 0; // 奇数个数的字母集合\n        for (String w : words) {\n            tot += w.length();\n            for (char c : w.toCharArray()) {\n                mask ^= 1 << (c - 'a');\n            }\n        }\n        tot -= Integer.bitCount(mask); // 减去出现次数为奇数的字母\n\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\n        int ans = 0;\n        for (String w : words) {\n            tot -= w.length() / 2 * 2; // 长为奇数的字符串，长度要减一\n            if (tot < 0) break;\n            ans++;\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int maxPalindromesAfterOperations(vector<string> &words) {\n        int ans = 0, tot = 0, mask = 0;\n        for (auto &w : words) {\n            tot += w.length();\n            for (char c : w) {\n                mask ^= 1 << (c - 'a');\n            }\n        }\n        tot -= __builtin_popcount(mask); // 减去出现次数为奇数的字母\n\n        ranges::sort(words, [](const auto &a, const auto &b) {\n            return a.length() < b.length();\n        });\n        for (auto &w : words) {\n            tot -= w.length() / 2 * 2; // 长为奇数的字符串，长度要减一\n            if (tot < 0) break;\n            ans++;\n        }\n        return ans;\n    }\n};\n",
            "go": "func maxPalindromesAfterOperations(words []string) (ans int) {\ntot, mask := 0, 0\nfor _, w := range words {\ntot += len(w)\nfor _, c := range w {\nmask ^= 1 << (c - 'a')\n}\n}\ntot -= bits.OnesCount(uint(mask)) // 减去出现次数为奇数的字母\n\nslices.SortFunc(words, func(a, b string) int { return len(a) - len(b) })\nfor _, w := range words {\ntot -= len(w) / 2 * 2 // 长为奇数的字符串，长度要减一\nif tot < 0 { break }\nans++\n}\nreturn\n}\n",
            "js": "/**\n * @param {string[]} words\n * @return {number}\n */\nvar maxPalindromesAfterOperations = function(words) {\n    //统计每个字母出现的次数\n    const arr=new Array(26).fill(0)\n    for(const word of words){\n        for(const s of word){\n            const i=s.charCodeAt()-'a'.charCodeAt()\n            arr[i]+=1\n        }\n    }\n\n    //计算可以用来组成回文串的一侧的字母的个数\n    let left=arr.reduce((pre,cur)=>pre+=(cur>>1),0)\n\n    //按照字符串长度，从小到大填入字母\n    let ans=0\n    words.sort((a,b)=>(a.length-b.length))\n        for(const word of words){\n            const len=word.length>>1\n            if(left<len){\n                break\n            }\n            left-=len\n            ans+=1\n        }\n    return ans\n};\n"
        },
        "cases": [
            {
                "input": "[\"[\\\"abbb\\\",\\\"ba\\\",\\\"aa\\\"]\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[\\\"abc\\\",\\\"ab\\\"]\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[\\\"cd\\\",\\\"ef\\\",\\\"a\\\"]\"]",
                "output": "[\"1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maxPalindromesAfterOperations(String[] words) {",
            "cpp": "class Solution {\npublic:\n    int maxPalindromesAfterOperations(vector<string>& words) {",
            "go": "func maxPalindromesAfterOperations(words []string) int {\n\n}",
            "js": "/**\n * @param {string[]} words\n * @return {number}\n */\nvar maxPalindromesAfterOperations = function(words) {",
            "python": "class Solution:\n    def maxPalindromesAfterOperations(self, words: List[str]) -> int:"
        },
        "time": "20240211",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maxPalindromesAfterOperations",
            "java": "maxPalindromesAfterOperations",
            "cpp": "maxPalindromesAfterOperations",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maxPalindromesAfterOperations([\"abbb\",\"ba\",\"aa\"]) == 3, \"Test 1 Error!\"\nassert my_solution.maxPalindromesAfterOperations([\"abc\",\"ab\"]) == 2, \"Test 2 Error!\"\nassert my_solution.maxPalindromesAfterOperations([\"cd\",\"ef\",\"a\"]) == 1, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String[] words_1 = {\"abbb\",\"ba\",\"aa\"};\n    int ans_1 = 3;\n    assert solution.maxPalindromesAfterOperations(words_1) == ans_1;\n    String[] words_2 = {\"abc\",\"ab\"};\n    int ans_2 = 2;\n    assert solution.maxPalindromesAfterOperations(words_2) == ans_2;\n    String[] words_3 = {\"cd\",\"ef\",\"a\"};\n    int ans_3 = 1;\n    assert solution.maxPalindromesAfterOperations(words_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<string> words_1 = {\"abbb\",\"ba\",\"aa\"};\n    int ans_1 = 3;\n    assert(my_solution_1.maxPalindromesAfterOperations(words_1) == ans_1);\n    Solution my_solution_2;\n    vector<string> words_2 = {\"abc\",\"ab\"};\n    int ans_2 = 2;\n    assert(my_solution_2.maxPalindromesAfterOperations(words_2) == ans_2);\n    Solution my_solution_3;\n    vector<string> words_3 = {\"cd\",\"ef\",\"a\"};\n    int ans_3 = 1;\n    assert(my_solution_3.maxPalindromesAfterOperations(words_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "words"
            ],
            "java": [
                "words"
            ],
            "cpp": [
                "words"
            ],
            "go": [],
            "js": []
        }
    },
    "3036": {
        "description": "给你一个下标从 0 开始长度为 n 的整数数组 nums ，和一个下标从 0 开始长度为 m 的整数数组 pattern ，pattern 数组只包含整数 -1 ，0 和 1 。\n大小为 m + 1 的子数组 nums[i..j] 如果对于每个元素 pattern[k] 都满足以下条件，那么我们说这个子数组匹配模式数组 pattern ：\n如果 pattern[k] == 1 ，那么 nums[i + k + 1] > nums[i + k]\n如果 pattern[k] == 0 ，那么 nums[i + k + 1] == nums[i + k]\n如果 pattern[k] == -1 ，那么 nums[i + k + 1] < nums[i + k]\n请你返回匹配 pattern 的 nums 子数组的 数目 。",
        "difficulty_level": "Hard",
        "note": "2 <= n == nums.length <= 10^6\n1 <= nums[i] <= 10^9\n1 <= m == pattern.length < n\n-1 <= pattern[i] <= 1",
        "codes": {
            "python": "class Solution:\n    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:\n        m = len(pattern)\n        pattern.append(2)\n        pattern.extend((y > x) - (y < x) for x, y in pairwise(nums))\n\n        n = len(pattern)\n        z = [0] * n\n        l = r = 0\n        for i in range(1, n):\n            if i <= r:\n                z[i] = min(z[i - l], r - i + 1)\n            while i + z[i] < n and pattern[z[i]] == pattern[i + z[i]]:\n                l, r = i, i + z[i]\n                z[i] += 1\n\n        return sum(lcp == m for lcp in z[m + 1:])\n",
            "java": "class Solution {\n    public int countMatchingSubarrays(int[] nums, int[] pattern) {\n        int m = pattern.length;\n        int[] s = Arrays.copyOf(pattern, m + nums.length);\n        s[m] = 2;\n        for (int i = 1; i < nums.length; i++) {\n            s[m + i] = Integer.compare(nums[i], nums[i - 1]);\n        }\n\n        int n = s.length;\n        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(z[i - l], r - i + 1);\n            }\n            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n                l = i;\n                r = i + z[i];\n                z[i]++;\n            }\n        }\n\n        int ans = 0;\n        for (int i = m + 1; i < n; i++) {\n            if (z[i] == m) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int countMatchingSubarrays(vector<int> &nums, vector<int> &pattern) {\n        int m = pattern.size();\n        pattern.push_back(2);\n        for (int i = 1; i < nums.size(); i++) {\n            int x = nums[i - 1], y = nums[i];\n            pattern.push_back((y > x) - (y < x));\n        }\n\n        int n = pattern.size();\n        vector<int> z(n);\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = min(z[i - l], r - i + 1);\n            }\n            while (i + z[i] < n && pattern[z[i]] == pattern[i + z[i]]) {\n                l = i;\n                r = i + z[i];\n                z[i]++;\n            }\n        }\n\n        int ans = 0;\n        for (int i = m + 1; i < n; i++) {\n            ans += z[i] == m;\n        }\n        return ans;\n    }\n};\n",
            "go": "func countMatchingSubarrays(nums, pattern []int) (ans int) {\nm := len(pattern)\npattern = append(pattern, 2)\nfor i := 1; i < len(nums); i++ {\npattern = append(pattern, cmp.Compare(nums[i], nums[i-1]))\n}\n\nn := len(pattern)\nz := make([]int, n)\nl, r := 0, 0\nfor i := 1; i < n; i++ {\nif i <= r {\nz[i] = min(z[i-l], r-i+1)\n}\nfor i+z[i] < n && pattern[z[i]] == pattern[i+z[i]] {\nl, r = i, i+z[i]\nz[i]++\n}\n}\n\nfor _, lcp := range z[m+1:] {\nif lcp == m {\nans++\n}\n}\nreturn\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @param {number[]} pattern\n * @return {number}\n */\nvar countMatchingSubarrays = function(nums, pattern) {\nlet n=nums.length\nconst nstr=[]\nfor(let i=0;i<n-1;i++){\n    let diff=nums[i]-nums[i+1]\n    if(diff<0){\n        nstr.push(1)\n    }else if(diff==0){\n nstr.push(0)\n    }else{\n nstr.push(2)\n    }\n}\nconst s = nstr.join('');\nconst p = pattern.map((item)=>{\n    if(item==-1){\n        return 2\n    }else{\n        return item\n    }\n}).join('')\n\nreturn match(s,p).length\nfunction match(str, pattern) {\n  const n = str.length;\n  const m = pattern.length;\n  \n  // 生成 next 数组\n  const next = Array(m).fill(0);\n  for (let i = 1, j = 0; i < m; i++) {\n    while (j > 0 && pattern[i] !== pattern[j]) {\n      j = next[j - 1];\n    }\n    if (pattern[i] === pattern[j]) {\n      j++;\n    }\n    next[i] = j;\n  }\n  \n  // 匹配字符串\n  const res = [];\n  for (let i = 0, j = 0; i < n; i++) {\n    while (j > 0 && str[i] !== pattern[j]) {\n      j = next[j - 1];\n    }\n    if (str[i] === pattern[j]) {\n      j++;\n    }\n    if (j === m) {\n      res.push(i - m + 1);\n      j = next[j - 1];\n    }\n  }\n  \n  return res; // 返回所有匹配的起始位置\n}\n\n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,2,3,4,5,6]\",\"[1,1]\"]",
                "output": "[\"4\"]"
            },
            {
                "input": "[\"[1,4,4,1,3,5,5,3]\",\"[1,0,-1]\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int countMatchingSubarrays(int[] nums, int[] pattern) {",
            "cpp": "class Solution {\npublic:\n    int countMatchingSubarrays(vector<int>& nums, vector<int>& pattern) {",
            "go": "func countMatchingSubarrays(nums []int, pattern []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number[]} pattern\n * @return {number}\n */\nvar countMatchingSubarrays = function(nums, pattern) {",
            "python": "class Solution:\n    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:"
        },
        "time": "20240211",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "countMatchingSubarrays",
            "java": "countMatchingSubarrays",
            "cpp": "countMatchingSubarrays",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.countMatchingSubarrays([1,2,3,4,5,6], [1,1]) == 4, \"Test 1 Error!\"\nassert my_solution.countMatchingSubarrays([1,4,4,1,3,5,5,3], [1,0,-1]) == 2, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,3,4,5,6};\n    int[] pattern_1 = {1,1};\n    int ans_1 = 4;\n    assert solution.countMatchingSubarrays(nums_1, pattern_1) == ans_1;\n    int[] nums_2 = {1,4,4,1,3,5,5,3};\n    int[] pattern_2 = {1,0,-1};\n    int ans_2 = 2;\n    assert solution.countMatchingSubarrays(nums_2, pattern_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,3,4,5,6};\n    vector<int> pattern_1 = {1,1};\n    int ans_1 = 4;\n    assert(my_solution_1.countMatchingSubarrays(nums_1, pattern_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,4,4,1,3,5,5,3};\n    vector<int> pattern_2 = {1,0,-1};\n    int ans_2 = 2;\n    assert(my_solution_2.countMatchingSubarrays(nums_2, pattern_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "pattern"
            ],
            "java": [
                "nums",
                "pattern"
            ],
            "cpp": [
                "nums",
                "pattern"
            ],
            "go": [],
            "js": []
        }
    },
    "3042": {
        "description": "给你一个下标从 0 开始的字符串数组 words。\n定义一个 布尔 函数 isPrefixAndSuffix ，它接受两个字符串参数 str1 和 str2 ：\n当 str1 同时是 str2 的前缀（prefix）和后缀（suffix）时，isPrefixAndSuffix(str1, str2) 返回 true，否则返回 false。\n例如，isPrefixAndSuffix(\\\"aba\\\", \\\"ababa\\\") 返回 true，因为 \\\"aba\\\" 既是 \\\"ababa\\\" 的前缀，也是 \\\"ababa\\\" 的后缀，但是 isPrefixAndSuffix(\\\"abc\\\", \\\"abcd\\\") 返回 false。\n以整数形式，返回满足 i < j 且 isPrefixAndSuffix(words[i], words[j]) 为 true 的下标对 (i, j) 的 数量 。",
        "difficulty_level": "Easy",
        "note": "1 <= words.length <= 50\n1 <= words[i].length <= 10\nwords[i] 仅由小写英文字母组成。",
        "codes": {
            "python": "class Node:\n    __slots__ = 'son', 'cnt'\n\n    def __init__(self):\n        self.son = dict()\n        self.cnt = 0\n\nclass Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:\n        ans = 0\n        root = Node()\n        for t in words:\n            z = self.calc_z(t)\n            cur = root\n            for i, c in enumerate(t):\n                if c not in cur.son:\n                    cur.son[c] = Node()\n                cur = cur.son[c]\n                if z[-1 - i] == i + 1:  # t[-1-i:] == t[:i+1]\n                    ans += cur.cnt\n            cur.cnt += 1\n        return ans\n\n    def calc_z(self, s: str) -> List[int]:\n        n = len(s)\n        z = [0] * n\n        l, r = 0, 0\n        for i in range(1, n):\n            if i <= r:\n                z[i] = min(z[i - l], r - i + 1)\n            while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n                l, r = i, i + z[i]\n                z[i] += 1\n        z[0] = n\n        return z\n",
            "java": "class Node {\n    Node[] son = new Node[26];\n    int cnt;\n}\n\nclass Solution {\n    public long countPrefixSuffixPairs(String[] words) {\n        long ans = 0;\n        Node root = new Node();\n        for (String T : words) {\n            char[] t = T.toCharArray();\n            int n = t.length;\n            int[] z = new int[n];\n            int l = 0, r = 0;\n            for (int i = 1; i < n; i++) {\n                if (i <= r) {\n                    z[i] = Math.min(z[i - l], r - i + 1);\n                }\n                while (i + z[i] < n && t[z[i]] == t[i + z[i]]) {\n                    l = i;\n                    r = i + z[i];\n                    z[i]++;\n                }\n            }\n            z[0] = n;\n\n            Node cur = root;\n            for (int i = 0; i < n; i++) {\n                int c = t[i] - 'a';\n                if (cur.son[c] == null) {\n                    cur.son[c] = new Node();\n                }\n                cur = cur.son[c];\n                if (z[n - 1 - i] == i + 1) { // t 的长为 i+1 的前后缀相同\n                    ans += cur.cnt;\n                }\n            }\n            cur.cnt++;\n        }\n        return ans;\n    }\n}\n",
            "cpp": "struct Node {\n    Node *son[26]{};\n    int cnt = 0;\n};\n\nclass Solution {\npublic:\n    long long countPrefixSuffixPairs(vector<string> &words) {\n        long long ans = 0;\n        Node *root = new Node();\n        for (string &t: words) {\n            int n = t.length();\n            vector<int> z(n);\n            int l = 0, r = 0;\n            for (int i = 1; i < n; i++) {\n                if (i <= r) {\n                    z[i] = min(z[i - l], r - i + 1);\n                }\n                while (i + z[i] < n && t[z[i]] == t[i + z[i]]) {\n                    l = i;\n                    r = i + z[i];\n                    z[i]++;\n                }\n            }\n            z[0] = n;\n\n            auto cur = root;\n            for (int i = 0; i < n; i++) {\n                int c = t[i] - 'a';\n                if (cur->son[c] == nullptr) {\n                    cur->son[c] = new Node();\n                }\n                cur = cur->son[c];\n                if (z[n - 1 - i] == i + 1) { // t 的长为 i+1 的前后缀相同\n                    ans += cur->cnt;\n                }\n            }\n            cur->cnt++;\n        }\n        return ans;\n    }\n};\n",
            "go": "func calcZ(s string) []int {\nn := len(s)\nz := make([]int, n)\nl, r := 0, 0\nfor i := 1; i < n; i++ {\nif i <= r {\nz[i] = min(z[i-l], r-i+1)\n}\nfor i+z[i] < n && s[z[i]] == s[i+z[i]] {\nl, r = i, i+z[i]\nz[i]++\n}\n}\nz[0] = n\nreturn z\n}\n\nfunc countPrefixSuffixPairs(words []string) (ans int64) {\ntype node struct {\nson [26]*node\ncnt int\n}\nroot := &node{}\nfor _, t := range words {\nz := calcZ(t)\ncur := root\nfor i, c := range t {\nc -= 'a'\nif cur.son[c] == nil {\ncur.son[c] = &node{}\n}\ncur = cur.son[c]\nif z[len(t)-1-i] == i+1 { // t[:i+1] == t[len(t)-1-i:]\nans += int64(cur.cnt)\n}\n}\ncur.cnt++\n}\nreturn\n}\n",
            "js": "/**\n * @param {string[]} words\n * @return {number}\n */\nvar countPrefixSuffixPairs = function(words) {\n  let count = 0;\n\n    for (let i = 0; i < words.length; i++) {\n        for (let j = i + 1; j < words.length; j++) {\n            if (words[i].length <= words[j].length && \n                words[j].startsWith(words[i]) && \n                words[j].endsWith(words[i])) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[\\\"a\\\",\\\"aba\\\",\\\"ababa\\\",\\\"aa\\\"]\"]",
                "output": "[\"4\"]"
            },
            {
                "input": "[\"[\\\"pa\\\",\\\"papa\\\",\\\"ma\\\",\\\"mama\\\"]\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[\\\"abab\\\",\\\"ab\\\"]\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int countPrefixSuffixPairs(String[] words) {",
            "cpp": "class Solution {\npublic:\n    int countPrefixSuffixPairs(vector<string>& words) {",
            "go": "func countPrefixSuffixPairs(words []string) int {\n\n}",
            "js": "/**\n * @param {string[]} words\n * @return {number}\n */\nvar countPrefixSuffixPairs = function(words) {",
            "python": "class Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:"
        },
        "time": "20240218",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "countPrefixSuffixPairs",
            "java": "countPrefixSuffixPairs",
            "cpp": "countPrefixSuffixPairs",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.countPrefixSuffixPairs([\"a\",\"aba\",\"ababa\",\"aa\"]) == 4, \"Test 1 Error!\"\nassert my_solution.countPrefixSuffixPairs([\"pa\",\"papa\",\"ma\",\"mama\"]) == 2, \"Test 2 Error!\"\nassert my_solution.countPrefixSuffixPairs([\"abab\",\"ab\"]) == 0, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String[] words_1 = {\"a\",\"aba\",\"ababa\",\"aa\"};\n    int ans_1 = 4;\n    assert solution.countPrefixSuffixPairs(words_1) == ans_1;\n    String[] words_2 = {\"pa\",\"papa\",\"ma\",\"mama\"};\n    int ans_2 = 2;\n    assert solution.countPrefixSuffixPairs(words_2) == ans_2;\n    String[] words_3 = {\"abab\",\"ab\"};\n    int ans_3 = 0;\n    assert solution.countPrefixSuffixPairs(words_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<string> words_1 = {\"a\",\"aba\",\"ababa\",\"aa\"};\n    int ans_1 = 4;\n    assert(my_solution_1.countPrefixSuffixPairs(words_1) == ans_1);\n    Solution my_solution_2;\n    vector<string> words_2 = {\"pa\",\"papa\",\"ma\",\"mama\"};\n    int ans_2 = 2;\n    assert(my_solution_2.countPrefixSuffixPairs(words_2) == ans_2);\n    Solution my_solution_3;\n    vector<string> words_3 = {\"abab\",\"ab\"};\n    int ans_3 = 0;\n    assert(my_solution_3.countPrefixSuffixPairs(words_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "words"
            ],
            "java": [
                "words"
            ],
            "cpp": [
                "words"
            ],
            "go": [],
            "js": []
        }
    },
    "3043": {
        "description": "给你两个 正整数 数组 arr1 和 arr2 。正整数的 前缀 是其 最左边 的一位或多位数字组成的整数。例如，123 是整数 12345 的前缀，而 234 不是 。\n设若整数 c 是整数 a 和 b 的 公共前缀 ，那么 c 需要同时是 a 和 b 的前缀。例如，5655359 和 56554 有公共前缀 565 ，而 1223 和 43456 没有 公共前缀。\n你需要找出属于 arr1 的整数 x 和属于 arr2 的整数 y 组成的所有数对 (x, y) 之中最长的公共前缀的长度。\n返回所有数对之中最长公共前缀的长度。如果它们之间不存在公共前缀，则返回 0 。",
        "difficulty_level": "Middle",
        "note": "1 <= arr1.length, arr2.length <= 5 * 10^4\n1 <= arr1[i], arr2[i] <= 10^8",
        "codes": {
            "python": "class Solution:\n    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n        st = set()\n        for s in map(str, arr1):\n            for i in range(1, len(s) + 1):\n                st.add(s[:i])\n\n        ans = 0\n        for s in map(str, arr2):\n            for i in range(1, len(s) + 1):\n                if s[:i] not in st:\n                    break\n                ans = max(ans, i)\n        return ans\n",
            "java": "class Solution {\n    public int longestCommonPrefix(int[] arr1, int[] arr2) {\n        Set<String> st = new HashSet<>();\n        for (int x : arr1) {\n            String s = Integer.toString(x);\n            for (int i = 1; i <= s.length(); i++) {\n                st.add(s.substring(0, i));\n            }\n        }\n\n        int ans = 0;\n        for (int x : arr2) {\n            String s = Integer.toString(x);\n            for (int i = 1; i <= s.length(); i++) {\n                if (!st.contains(s.substring(0, i))) {\n                    break;\n                }\n                ans = Math.max(ans, i);\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int longestCommonPrefix(vector<int> &arr1, vector<int> &arr2) {\n        unordered_set<string> st;\n        for (int x : arr1) {\n            string s = to_string(x);\n            for (int i = 1; i <= s.length(); i++) {\n                st.insert(s.substr(0, i));\n            }\n        }\n\n        int ans = 0;\n        for (int x : arr2) {\n            string s = to_string(x);\n            for (int i = 1; i <= s.length(); i++) {\n                if (!st.contains(s.substr(0, i))) {\n                    break;\n                }\n                ans = max(ans, i);\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func longestCommonPrefix(arr1, arr2 []int) (ans int) {\nhas := map[string]bool{}\nfor _, x := range arr1 {\ns := strconv.Itoa(x)\nfor i := 1; i <= len(s); i++ {\nhas[s[:i]] = true\n}\n}\n\nfor _, x := range arr2 {\ns := strconv.Itoa(x)\nfor i := 1; i <= len(s) && has[s[:i]]; i++ {\nans = max(ans, i)\n}\n}\nreturn\n}\n",
            "js": "/**\n * @param {number[]} arr1\n * @param {number[]} arr2\n * @return {number}\n */\nvar longestCommonPrefix = function(arr1, arr2) {\n    let set = new Set(), max = 0\n    for(let x of arr2){\n        for(let y = x; y > 0; y = y/10 >> 0  ){\n            set.add(y)\n        }\n    }\n    for(let x of arr1){\n       let len = 0 \n       for(let y = x; y > 0; y = y/10 >> 0) len++\n       for(let y = x; y > 0; y = y/10 >> 0){\n         if(set.has(y)){\n             max = Math.max(max, len)\n             break\n         }\n         len--\n       }\n    }\n    return max  \n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,10,100]\",\"[1000]\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[1,2,3]\",\"[4,4,4]\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int longestCommonPrefix(int[] arr1, int[] arr2) {",
            "cpp": "class Solution {\npublic:\n    int longestCommonPrefix(vector<int>& arr1, vector<int>& arr2) {",
            "go": "func longestCommonPrefix(arr1 []int, arr2 []int) int {\n\n}",
            "js": "/**\n * @param {number[]} arr1\n * @param {number[]} arr2\n * @return {number}\n */\nvar longestCommonPrefix = function(arr1, arr2) {",
            "python": "class Solution:\n    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:"
        },
        "time": "20240218",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "longestCommonPrefix",
            "java": "longestCommonPrefix",
            "cpp": "longestCommonPrefix",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.longestCommonPrefix([1,10,100], [1000]) == 3, \"Test 1 Error!\"\nassert my_solution.longestCommonPrefix([1,2,3], [4,4,4]) == 0, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] arr1_1 = {1,10,100};\n    int[] arr2_1 = {1000};\n    int ans_1 = 3;\n    assert solution.longestCommonPrefix(arr1_1, arr2_1) == ans_1;\n    int[] arr1_2 = {1,2,3};\n    int[] arr2_2 = {4,4,4};\n    int ans_2 = 0;\n    assert solution.longestCommonPrefix(arr1_2, arr2_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> arr1_1 = {1,10,100};\n    vector<int> arr2_1 = {1000};\n    int ans_1 = 3;\n    assert(my_solution_1.longestCommonPrefix(arr1_1, arr2_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> arr1_2 = {1,2,3};\n    vector<int> arr2_2 = {4,4,4};\n    int ans_2 = 0;\n    assert(my_solution_2.longestCommonPrefix(arr1_2, arr2_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "arr1",
                "arr2"
            ],
            "java": [
                "arr1",
                "arr2"
            ],
            "cpp": [
                "arr1",
                "arr2"
            ],
            "go": [],
            "js": []
        }
    },
    "3044": {
        "description": "给你一个大小为 m x n 、下标从 0 开始的二维矩阵 mat 。在每个单元格，你可以按以下方式生成数字：\n最多有 8 条路径可以选择：东，东南，南，西南，西，西北，北，东北。\n选择其中一条路径，沿着这个方向移动，并且将路径上的数字添加到正在形成的数字后面。\n注意，每一步都会生成数字，例如，如果路径上的数字是 1, 9, 1，那么在这个方向上会生成三个数字：1, 19, 191 。\n返回在遍历矩阵所创建的所有数字中，出现频率最高的、大于 10的质数；如果不存在这样的质数，则返回 -1 。如果存在多个出现频率最高的质数，那么返回其中最大的那个。\n注意：移动过程中不允许改变方向。",
        "difficulty_level": "Middle",
        "note": "m == mat.length\nn == mat[i].length\n1 <= m, n <= 6\n1 <= mat[i][j] <= 9",
        "codes": {
            "python": "class Solution:\n    def mostFrequentPrime(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        cnt = Counter()\n        for i, row in enumerate(mat):\n            for j, v in enumerate(row):\n                for dx, dy in (1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1):\n                    x, y, val = i + dx, j + dy, v\n                    while 0 <= x < m and 0 <= y < n:\n                        val = val * 10 + mat[x][y]\n                        # 如果 val 在 cnt 中，那么 val 一定是质数\n                        if val in cnt or self.is_prime(val):\n                            cnt[val] += 1\n                        x += dx\n                        y += dy\n\n        ans, max_cnt = -1, 0\n        for v, c in cnt.items():\n            if c > max_cnt:\n                ans, max_cnt = v, c\n            elif c == max_cnt:\n                ans = max(ans, v)\n        return ans\n\n    def is_prime(self, n: int) -> bool:\n        return all(n % i for i in range(2, isqrt(n) + 1))\n",
            "java": "class Solution {\n    private static final int[][] DIRS = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\n\n    public int mostFrequentPrime(int[][] mat) {\n        int m = mat.length;\n        int n = mat[0].length;\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int[] d : DIRS) {\n                    int x = i + d[0];\n                    int y = j + d[1];\n                    int v = mat[i][j];\n                    while (x >= 0 && x < m && y >= 0 && y < n) {\n                        v = v * 10 + mat[x][y];\n                        if (isPrime(v)) {\n                            cnt.merge(v, 1, Integer::sum);\n                        }\n                        x += d[0];\n                        y += d[1];\n                    }\n                }\n            }\n        }\n\n        int ans = -1;\n        int maxCnt = 0;\n        for (Map.Entry<Integer, Integer> e : cnt.entrySet()) {\n            int v = e.getKey();\n            int c = e.getValue();\n            if (c > maxCnt) {\n                ans = v;\n                maxCnt = c;\n            } else if (c == maxCnt) {\n                ans = Math.max(ans, v);\n            }\n        }\n        return ans;\n    }\n\n    private boolean isPrime(int n) {\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n",
            "cpp": "class Solution {\n    static constexpr int dirs[8][2] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\n\n    bool is_prime(int n) {\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\npublic:\n    int mostFrequentPrime(vector<vector<int>> &mat) {\n        int m = mat.size(), n = mat[0].size();\n        unordered_map<int, int> cnt;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                for (auto &d: dirs) {\n                    int x = i + d[0], y = j + d[1], v = mat[i][j];\n                    while (x >= 0 && x < m && y >= 0 && y < n) {\n                        v = v * 10 + mat[x][y];\n                        // 如果 v 在 cnt 中，那么 v 一定是质数\n                        if (cnt.contains(v) || is_prime(v)) {\n                            cnt[v]++;\n                        }\n                        x += d[0];\n                        y += d[1];\n                    }\n                }\n            }\n        }\n\n        int ans = -1, max_cnt = 0;\n        for (auto &[v, c]: cnt) {\n            if (c > max_cnt) {\n                ans = v;\n                max_cnt = c;\n            } else if (c == max_cnt) {\n                ans = max(ans, v);\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func isPrime(n int) bool {\nfor i := 2; i*i <= n; i++ {\nif n%i == 0 {\nreturn false\n}\n}\nreturn true\n}\n\nfunc mostFrequentPrime(mat [][]int) int {\ndirs := []struct{ x, y int }{{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}}\nm, n := len(mat), len(mat[0])\ncnt := map[int]int{}\nfor i, row := range mat {\nfor j, v := range row {\nfor _, d := range dirs {\nx, y, v := i+d.x, j+d.y, v\nfor 0 <= x && x < m && 0 <= y && y < n {\nv = v*10 + mat[x][y]\n// 如果 v 在 cnt 中，那么 v 一定是质数\nif cnt[v] > 0 || isPrime(v) {\ncnt[v]++\n}\nx += d.x\ny += d.y\n}\n}\n}\n}\n\nans, maxCnt := -1, 0\nfor v, c := range cnt {\nif c > maxCnt {\nans, maxCnt = v, c\n} else if c == maxCnt {\nans = max(ans, v)\n}\n}\nreturn ans\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[[1,1],[9,9],[1,1]]\"]",
                "output": "[\"19\"]"
            },
            {
                "input": "[\"[[7]]\"]",
                "output": "[\"-1\"]"
            },
            {
                "input": "[\"[[9,7,8],[4,6,5],[2,8,6]]\"]",
                "output": "[\"97\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int mostFrequentPrime(int[][] mat) {",
            "cpp": "class Solution {\npublic:\n    int mostFrequentPrime(vector<vector<int>>& mat) {",
            "go": "func mostFrequentPrime(mat [][]int) int {\n\n}",
            "js": "/**\n * @param {number[][]} mat\n * @return {number}\n */\nvar mostFrequentPrime = function(mat) {",
            "python": "class Solution:\n    def mostFrequentPrime(self, mat: List[List[int]]) -> int:"
        },
        "time": "20240218",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "mostFrequentPrime",
            "java": "mostFrequentPrime",
            "cpp": "mostFrequentPrime",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.mostFrequentPrime([[1,1],[9,9],[1,1]]) == 19, \"Test 1 Error!\"\nassert my_solution.mostFrequentPrime([[7]]) == -1, \"Test 2 Error!\"\nassert my_solution.mostFrequentPrime([[9,7,8],[4,6,5],[2,8,6]]) == 97, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] mat_1 = {{1,1},{9,9},{1,1}};\n    int ans_1 = 19;\n    assert solution.mostFrequentPrime(mat_1) == ans_1;\n    int[][] mat_2 = {{7}};\n    int ans_2 = -1;\n    assert solution.mostFrequentPrime(mat_2) == ans_2;\n    int[][] mat_3 = {{9,7,8},{4,6,5},{2,8,6}};\n    int ans_3 = 97;\n    assert solution.mostFrequentPrime(mat_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> mat_1 = {{1,1},{9,9},{1,1}};\n    int ans_1 = 19;\n    assert(my_solution_1.mostFrequentPrime(mat_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> mat_2 = {{7}};\n    int ans_2 = -1;\n    assert(my_solution_2.mostFrequentPrime(mat_2) == ans_2);\n    Solution my_solution_3;\n    vector<vector<int>> mat_3 = {{9,7,8},{4,6,5},{2,8,6}};\n    int ans_3 = 97;\n    assert(my_solution_3.mostFrequentPrime(mat_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "mat"
            ],
            "java": [
                "mat"
            ],
            "cpp": [
                "mat"
            ],
            "go": [],
            "js": []
        }
    },
    "3045": {
        "description": "给你一个下标从 0 开始的字符串数组 words 。\n定义一个 布尔 函数 isPrefixAndSuffix ，它接受两个字符串参数 str1 和 str2 ：\n当 str1 同时是 str2 的前缀（prefix）和后缀（suffix）时，isPrefixAndSuffix(str1, str2) 返回 true，否则返回 false。\n例如，isPrefixAndSuffix(\\\"aba\\\", \\\"ababa\\\") 返回 true，因为 \\\"aba\\\" 既是 \\\"ababa\\\" 的前缀，也是 \\\"ababa\\\" 的后缀，但是 isPrefixAndSuffix(\\\"abc\\\", \\\"abcd\\\") 返回 false。\n以整数形式，返回满足 i < j 且 isPrefixAndSuffix(words[i], words[j]) 为 true 的下标对 (i, j) 的 数量 。",
        "difficulty_level": "Hard",
        "note": "1 <= words.length <= 10^5\n1 <= words[i].length <= 10^5\nwords[i] 仅由小写英文字母组成。\n所有 words[i] 的长度之和不超过 5 * 10^5 。",
        "codes": {
            "python": "class Node:\n    __slots__ = 'son', 'cnt'\n\n    def __init__(self):\n        self.son = dict()\n        self.cnt = 0\n\nclass Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:\n        ans = 0\n        root = Node()\n        for s in words:\n            cur = root\n            for p in zip(s, reversed(s)):\n                if p not in cur.son:\n                    cur.son[p] = Node()\n                cur = cur.son[p]\n                ans += cur.cnt\n            cur.cnt += 1\n        return ans\n",
            "java": "class Node {\n    Map<Integer, Node> son = new HashMap<>();\n    int cnt;\n}\n\nclass Solution {\n    public long countPrefixSuffixPairs(String[] words) {\n        long ans = 0;\n        Node root = new Node();\n        for (String S : words) {\n            char[] s = S.toCharArray();\n            int n = s.length;\n            Node cur = root;\n            for (int i = 0; i < n; i++) {\n                int p = (s[i] - 'a') << 5 | (s[n - 1 - i] - 'a');\n                cur = cur.son.computeIfAbsent(p, k -> new Node());\n                ans += cur.cnt;\n            }\n            cur.cnt++;\n        }\n        return ans;\n    }\n}\n",
            "cpp": "struct Node {\n    unordered_map<int, Node*> son;\n    int cnt = 0;\n};\n\nclass Solution {\npublic:\n    long long countPrefixSuffixPairs(vector<string> &words) {\n        long long ans = 0;\n        Node *root = new Node();\n        for (string &s: words) {\n            int n = s.length();\n            auto cur = root;\n            for (int i = 0; i < n; i++) {\n                int p = (int) (s[i] - 'a') << 5 | (s[n - 1 - i] - 'a');\n                if (cur->son[p] == nullptr) {\n                    cur->son[p] = new Node();\n                }\n                cur = cur->son[p];\n                ans += cur->cnt;\n            }\n            cur->cnt++;\n        }\n        return ans;\n    }\n};\n",
            "go": "func countPrefixSuffixPairs(words []string) (ans int64) {\ntype pair struct{ x, y byte }\ntype node struct {\nson map[pair]*node\ncnt int\n}\nroot := &node{son: map[pair]*node{}}\nfor _, s := range words {\ncur := root\nfor i := range s {\np := pair{s[i], s[len(s)-1-i]}\nif cur.son[p] == nil {\ncur.son[p] = &node{son: map[pair]*node{}}\n}\ncur = cur.son[p]\nans += int64(cur.cnt)\n}\ncur.cnt++\n}\nreturn\n}\n",
            "js": "/**\n * @param {string[]} words\n * @return {number}\n */\nvar countPrefixSuffixPairs = function(words) {\n    const map = new Map()\n    let ans = 0\n    const strHash = () => {\n        return {\n            hash: 0,\n            basePower: 1,\n            mod: 1000000000,\n            base: 666,\n            pushChar: function (x) {\n                this.hash = (x.charCodeAt() * this.basePower + this.hash) % this.mod\n                this.basePower = (this.basePower * this.base) % this.mod\n            },\n            unShiftChar: function (x) {\n                this.hash = (this.hash * this.base + x.charCodeAt()) % this.mod\n                this.basePower = (this.basePower * this.base) % this.mod\n            }\n        }\n    }\n    for (let word of words) {\n        let len = word.length\n        let l = strHash(), r = strHash()\n        for (let i = 0, j = len - 1; i < len; i++, j--) {\n            l.pushChar(word[i])\n            r.unShiftChar(word[j])\n            if (l.hash === r.hash && map.has(l.hash)) {\n                ans += map.get(l.hash)\n            }\n        }\n        map.set(l.hash, (map.get(l.hash) || 0) + 1)\n    }\n    return ans\n};\n"
        },
        "cases": [
            {
                "input": "[\"[\\\"a\\\",\\\"aba\\\",\\\"ababa\\\",\\\"aa\\\"]\"]",
                "output": "[\"4\"]"
            },
            {
                "input": "[\"[\\\"pa\\\",\\\"papa\\\",\\\"ma\\\",\\\"mama\\\"]\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[\\\"abab\\\",\\\"ab\\\"]\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long countPrefixSuffixPairs(String[] words) {",
            "cpp": "class Solution {\npublic:\n    long long countPrefixSuffixPairs(vector<string>& words) {",
            "go": "func countPrefixSuffixPairs(words []string) int64 {\n\n}",
            "js": "/**\n * @param {string[]} words\n * @return {number}\n */\nvar countPrefixSuffixPairs = function(words) {",
            "python": "class Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:"
        },
        "time": "20240218",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "countPrefixSuffixPairs",
            "java": "countPrefixSuffixPairs",
            "cpp": "countPrefixSuffixPairs",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.countPrefixSuffixPairs([\"a\",\"aba\",\"ababa\",\"aa\"]) == 4, \"Test 1 Error!\"\nassert my_solution.countPrefixSuffixPairs([\"pa\",\"papa\",\"ma\",\"mama\"]) == 2, \"Test 2 Error!\"\nassert my_solution.countPrefixSuffixPairs([\"abab\",\"ab\"]) == 0, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String[] words_1 = {\"a\",\"aba\",\"ababa\",\"aa\"};\n    long ans_1 = 4;\n    assert solution.countPrefixSuffixPairs(words_1) == ans_1;\n    String[] words_2 = {\"pa\",\"papa\",\"ma\",\"mama\"};\n    long ans_2 = 2;\n    assert solution.countPrefixSuffixPairs(words_2) == ans_2;\n    String[] words_3 = {\"abab\",\"ab\"};\n    long ans_3 = 0;\n    assert solution.countPrefixSuffixPairs(words_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<string> words_1 = {\"a\",\"aba\",\"ababa\",\"aa\"};\n    long long ans_1 = 4;\n    assert(my_solution_1.countPrefixSuffixPairs(words_1) == ans_1);\n    Solution my_solution_2;\n    vector<string> words_2 = {\"pa\",\"papa\",\"ma\",\"mama\"};\n    long long ans_2 = 2;\n    assert(my_solution_2.countPrefixSuffixPairs(words_2) == ans_2);\n    Solution my_solution_3;\n    vector<string> words_3 = {\"abab\",\"ab\"};\n    long long ans_3 = 0;\n    assert(my_solution_3.countPrefixSuffixPairs(words_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "words"
            ],
            "java": [
                "words"
            ],
            "cpp": [
                "words"
            ],
            "go": [],
            "js": []
        }
    },
    "3046": {
        "description": "给你一个长度为 偶数 的整数数组 nums 。你需要将这个数组分割成 nums1 和 nums2 两部分，要求：\nnums1.length == nums2.length == nums.length / 2 。\nnums1 应包含 互不相同 的元素。\nnums2也应包含 互不相同 的元素。\n如果能够分割数组就返回 true ，否则返回 false 。",
        "difficulty_level": "Easy",
        "note": "1 <= nums.length <= 100\nnums.length % 2 == 0\n1 <= nums[i] <= 100",
        "codes": {
            "python": "class Solution:\n    def isPossibleToSplit(self, nums: List[int]) -> bool:\n        return max(Counter(nums).values()) <= 2\n",
            "java": "class Solution {\n    public boolean isPossibleToSplit(int[] nums) {\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int x : nums) {\n            if (cnt.merge(x, 1, Integer::sum) > 2) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    bool isPossibleToSplit(vector<int> &nums) {\n        unordered_map<int, int> cnt;\n        for (int x : nums) {\n            if (++cnt[x] > 2) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n",
            "go": "func isPossibleToSplit(nums []int) bool {\ncnt := map[int]int{}\nfor _, x := range nums {\nif cnt[x] == 2 {\nreturn false\n}\ncnt[x]++\n}\nreturn true\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar isPossibleToSplit = function(nums) {\n    let map =new Map()\n    for(let i of nums){\n        if(map.has(i)){\n            let time=map.get(i)\n            map.set(i,time+1)\n            if(time+1>2){\n                return false\n            }\n        }else{\n            map.set(i,1)\n        }\n    }\n    return true\n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,1,2,2,3,4]\"]",
                "output": "[\"true\"]"
            },
            {
                "input": "[\"[1,1,1,1]\"]",
                "output": "[\"false\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public boolean isPossibleToSplit(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    bool isPossibleToSplit(vector<int>& nums) {",
            "go": "func isPossibleToSplit(nums []int) bool {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar isPossibleToSplit = function(nums) {",
            "python": "class Solution:\n    def isPossibleToSplit(self, nums: List[int]) -> bool:"
        },
        "time": "20240225",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "isPossibleToSplit",
            "java": "isPossibleToSplit",
            "cpp": "isPossibleToSplit",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.isPossibleToSplit([1,1,2,2,3,4]) == True, \"Test 1 Error!\"\nassert my_solution.isPossibleToSplit([1,1,1,1]) == False, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,1,2,2,3,4};\n    boolean ans_1 = true;\n    assert solution.isPossibleToSplit(nums_1) == ans_1;\n    int[] nums_2 = {1,1,1,1};\n    boolean ans_2 = false;\n    assert solution.isPossibleToSplit(nums_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,1,2,2,3,4};\n    bool ans_1 = true;\n    assert(my_solution_1.isPossibleToSplit(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,1,1,1};\n    bool ans_2 = false;\n    assert(my_solution_2.isPossibleToSplit(nums_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3047": {
        "description": "在二维平面上存在 n 个矩形。给你两个下标从 0 开始的二维整数数组 bottomLeft 和 topRight，两个数组的大小都是 n x 2 ，其中 bottomLeft[i] 和 topRight[i] 分别代表第 i 个矩形的 左下角 和 右上角 坐标。\n我们定义 向右 的方向为 x 轴正半轴（x 坐标增加），向左 的方向为 x 轴负半轴（x 坐标减少）。同样地，定义 向上 的方向为 y 轴正半轴（y 坐标增加），向下 的方向为 y 轴负半轴（y 坐标减少）。\n你可以选择一个区域，该区域由两个矩形的 交集 形成。你需要找出能够放入该区域 内 的 最大 正方形面积，并选择最优解。\n返回能够放入交集区域的正方形的 最大 可能面积，如果矩形之间不存在任何交集区域，则返回 0。",
        "difficulty_level": "Middle",
        "note": "n == bottomLeft.length == topRight.length\n2 <= n <= 10^3\nbottomLeft[i].length == topRight[i].length == 2\n1 <= bottomLeft[i][0], bottomLeft[i][1] <= 10^7\n1 <= topRight[i][0], topRight[i][1] <= 10^7\nbottomLeft[i][0] < topRight[i][0]\nbottomLeft[i][1] < topRight[i][1]",
        "codes": {
            "python": "class Solution:\n    def largestSquareArea(self, bottomLeft: List[List[int]], topRight: List[List[int]]) -> int:\n        ans = 0\n        for ((x1, y1), (x2, y2)), ((x3, y3), (x4, y4)) in combinations(zip(bottomLeft, topRight), 2):\n            width = min(x2, x4) - max(x1, x3)  # 注：改成用 if-else 计算 min 和 max 会更快\n            height = min(y2, y4) - max(y1, y3)\n            size = min(width, height)\n            if size > 0:\n                ans = max(ans, size * size)\n        return ans\n",
            "java": "class Solution {\n    public long largestSquareArea(int[][] bottomLeft, int[][] topRight) {\n        long ans = 0;\n        for (int i = 0; i < bottomLeft.length; i++) {\n            int[] b1 = bottomLeft[i];\n            int[] t1 = topRight[i];\n            for (int j = i + 1; j < bottomLeft.length; j++) {\n                int[] b2 = bottomLeft[j];\n                int[] t2 = topRight[j];\n                int height = Math.min(t1[1], t2[1]) - Math.max(b1[1], b2[1]);\n                int width = Math.min(t1[0], t2[0]) - Math.max(b1[0], b2[0]);\n                int size = Math.min(width, height);\n                if (size > 0) {\n                    ans = Math.max(ans, (long) size * size);\n                }\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long largestSquareArea(vector<vector<int>> &bottomLeft, vector<vector<int>> &topRight) {\n        long long ans = 0;\n        for (int i = 0; i < bottomLeft.size(); i++) {\n            auto &b1 = bottomLeft[i];\n            auto &t1 = topRight[i];\n            for (int j = i + 1; j < bottomLeft.size(); j++) {\n                auto &b2 = bottomLeft[j];\n                auto &t2 = topRight[j];\n                int height = min(t1[1], t2[1]) - max(b1[1], b2[1]);\n                int width = min(t1[0], t2[0]) - max(b1[0], b2[0]);\n                int size = min(width, height);\n                if (size > 0) {\n                    ans = max(ans, (long long) size * size);\n                }\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func largestSquareArea(bottomLeft, topRight [][]int) (ans int64) {\nfor i, b1 := range bottomLeft {\nt1 := topRight[i]\nfor j := i + 1; j < len(bottomLeft); j++ {\nb2, t2 := bottomLeft[j], topRight[j]\nheight := min(t1[1], t2[1]) - max(b1[1], b2[1])\nwidth := min(t1[0], t2[0]) - max(b1[0], b2[0])\nsize := min(width, height)\nif size > 0 {\nans = max(ans, int64(size)*int64(size))\n}\n}\n}\nreturn\n}\n",
            "js": "var largestSquareArea = function(bottomLeft, topRight) {\n    let maxSquareArea = 0;\n    let n = bottomLeft.length;\n    for (let i = 0; i < n; i++) {\n        let bottomLeft1 = bottomLeft[i];\n        let topRight1 = topRight[i];\n        for (let j = i + 1; j < n; j++) {\n            let bottomLeft2 = bottomLeft[j];\n            let topRight2 = topRight[j];\n            let squareArea = overlapSquareArea(bottomLeft1, topRight1, bottomLeft2, topRight2);\n            maxSquareArea = Math.max(maxSquareArea, squareArea);\n        }\n    }\n    return maxSquareArea;\n}\n\nvar overlapSquareArea = function(bottomLeft1, topRight1, bottomLeft2, topRight2) {\n    let overlapWidth = Math.max(Math.min(topRight1[0], topRight2[0]) - Math.max(bottomLeft1[0], bottomLeft2[0]), 0);\n    let overlapHeight = Math.max(Math.min(topRight1[1], topRight2[1]) - Math.max(bottomLeft1[1], bottomLeft2[1]), 0);\n    let side = Math.min(overlapWidth, overlapHeight);\n    return side * side;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[[1,1],[2,2],[3,1]]\",\"[[3,3],[4,4],[6,6]]\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"[[1,1],[2,2],[1,2]]\",\"[[3,3],[4,4],[3,4]]\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"[[1,1],[3,3],[3,1]]\",\"[[2,2],[4,4],[4,2]]\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long largestSquareArea(int[][] bottomLeft, int[][] topRight) {",
            "cpp": "class Solution {\npublic:\n    long long largestSquareArea(vector<vector<int>>& bottomLeft, vector<vector<int>>& topRight) {",
            "go": "func largestSquareArea(bottomLeft [][]int, topRight [][]int) int64 {\n\n}",
            "js": "/**\n * @param {number[][]} bottomLeft\n * @param {number[][]} topRight\n * @return {number}\n */\nvar largestSquareArea = function(bottomLeft, topRight) {",
            "python": "class Solution:\n    def largestSquareArea(self, bottomLeft: List[List[int]], topRight: List[List[int]]) -> int:"
        },
        "time": "20240225",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "largestSquareArea",
            "java": "largestSquareArea",
            "cpp": "largestSquareArea",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.largestSquareArea([[1,1],[2,2],[3,1]], [[3,3],[4,4],[6,6]]) == 1, \"Test 1 Error!\"\nassert my_solution.largestSquareArea([[1,1],[2,2],[1,2]], [[3,3],[4,4],[3,4]]) == 1, \"Test 2 Error!\"\nassert my_solution.largestSquareArea([[1,1],[3,3],[3,1]], [[2,2],[4,4],[4,2]]) == 0, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] bottomLeft_1 = {{1,1},{2,2},{3,1}};\n    int[][] topRight_1 = {{3,3},{4,4},{6,6}};\n    long ans_1 = 1;\n    assert solution.largestSquareArea(bottomLeft_1, topRight_1) == ans_1;\n    int[][] bottomLeft_2 = {{1,1},{2,2},{1,2}};\n    int[][] topRight_2 = {{3,3},{4,4},{3,4}};\n    long ans_2 = 1;\n    assert solution.largestSquareArea(bottomLeft_2, topRight_2) == ans_2;\n    int[][] bottomLeft_3 = {{1,1},{3,3},{3,1}};\n    int[][] topRight_3 = {{2,2},{4,4},{4,2}};\n    long ans_3 = 0;\n    assert solution.largestSquareArea(bottomLeft_3, topRight_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> bottomLeft_1 = {{1,1},{2,2},{3,1}};\n    vector<vector<int>> topRight_1 = {{3,3},{4,4},{6,6}};\n    long long ans_1 = 1;\n    assert(my_solution_1.largestSquareArea(bottomLeft_1, topRight_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> bottomLeft_2 = {{1,1},{2,2},{1,2}};\n    vector<vector<int>> topRight_2 = {{3,3},{4,4},{3,4}};\n    long long ans_2 = 1;\n    assert(my_solution_2.largestSquareArea(bottomLeft_2, topRight_2) == ans_2);\n    Solution my_solution_3;\n    vector<vector<int>> bottomLeft_3 = {{1,1},{3,3},{3,1}};\n    vector<vector<int>> topRight_3 = {{2,2},{4,4},{4,2}};\n    long long ans_3 = 0;\n    assert(my_solution_3.largestSquareArea(bottomLeft_3, topRight_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "bottomLeft",
                "topRight"
            ],
            "java": [
                "bottomLeft",
                "topRight"
            ],
            "cpp": [
                "bottomLeft",
                "topRight"
            ],
            "go": [],
            "js": []
        }
    },
    "3048": {
        "description": "给你两个下标从 1 开始的整数数组 nums 和 changeIndices ，数组的长度分别为 n 和 m。一开始，nums 中所有下标都是未标记的，你的任务是标记 nums 中 所有 下标。\n从第 1 秒到第 m 秒（包括 第 m 秒），对于每一秒 s ，你可以执行以下操作 之一 ：\n选择范围 [1, n] 中的一个下标 i ，并且将 nums[i] 减少 1 。\n如果 nums[changeIndices[s]] 等于 0 ，标记 下标 changeIndices[s] 。\n什么也不做。\n请你返回范围 [1, m] 中的一个整数，表示最优操作下，标记 nums 中 所有 下标的 最早秒数 ，如果无法标记所有下标，返回 -1 。",
        "difficulty_level": "Middle",
        "note": "1 <= n == nums.length <= 2000\n0 <= nums[i] <= 10^9\n1 <= m == changeIndices.length <= 2000\n1 <= changeIndices[i] <= n",
        "codes": {
            "python": "class Solution:\n    def earliestSecondToMarkIndices(self, nums: List[int], changeIndices: List[int]) -> int:\n        n, m = len(nums), len(changeIndices)\n        if n > m: return -1\n\n        def check(mx: int) -> bool:\n            last_t = [-1] * n\n            for t, idx in enumerate(changeIndices[:mx]):\n                last_t[idx - 1] = t\n            if -1 in last_t:  # 有课程没有考试时间\n                return False\n\n            cnt = 0\n            for i, idx in enumerate(changeIndices[:mx]):\n                idx -= 1\n                if i == last_t[idx]:  # 考试\n                    if nums[idx] > cnt:  # 没时间复习\n                        return False\n                    cnt -= nums[idx]  # 复习这门课程\n                else:\n                    cnt += 1  # 留着后面用\n            return True\n\n        left = n + sum(nums)\n        ans = left + bisect_left(range(left, m + 1), True, key=check)\n        return -1 if ans > m else ans\n",
            "java": "class Solution {\n    public int earliestSecondToMarkIndices(int[] nums, int[] changeIndices) {\n        int n = nums.length;\n        int m = changeIndices.length;\n        if (n > m) {\n            return -1;\n        }\n\n        int[] lastT = new int[n];\n        int left = n - 1, right = m + 1;\n        while (left + 1 < right) {\n            int mid = (left + right) / 2;\n            if (check(nums, changeIndices, lastT, mid)) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        return right > m ? -1 : right;\n    }\n\n    private boolean check(int[] nums, int[] changeIndices, int[] lastT, int mx) {\n        Arrays.fill(lastT, -1);\n        for (int t = 0; t < mx; t++) {\n            lastT[changeIndices[t] - 1] = t;\n        }\n        for (int t : lastT) {\n            if (t < 0) { // 有课程没有考试时间\n                return false;\n            }\n        }\n\n        int cnt = 0;\n        for (int i = 0; i < mx; i++) {\n            int idx = changeIndices[i] - 1;\n            if (i == lastT[idx]) { // 考试\n                if (nums[idx] > cnt) { // 没时间复习\n                    return false;\n                }\n                cnt -= nums[idx]; // 复习这门课程\n            } else {\n                cnt++; // 留着后面用\n            }\n        }\n        return true;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int earliestSecondToMarkIndices(vector<int> &nums, vector<int> &changeIndices) {\n        int n = nums.size(), m = changeIndices.size();\n        if (n > m) return -1;\n\n        vector<int> last_t(n);\n        auto check = [&](int mx) -> bool {\n            ranges::fill(last_t, -1);\n            for (int t = 0; t < mx; t++) {\n                last_t[changeIndices[t] - 1] = t;\n            }\n            if (ranges::find(last_t, -1) != last_t.end()) { // 有课程没有考试时间\n                return false;\n            }\n\n            int cnt = 0;\n            for (int i = 0; i < mx; i++) {\n                int idx = changeIndices[i] - 1;\n                if (i == last_t[idx]) { // 考试\n                    if (nums[idx] > cnt) { // 没时间复习\n                        return false;\n                    }\n                    cnt -= nums[idx]; // 复习这门课程\n                } else {\n                    cnt++; // 留着后面用\n                }\n            }\n            return true;\n        };\n\n        int left = n - 1, right = m + 1;\n        while (left + 1 < right) {\n            int mid = (left + right) / 2;\n            (check(mid) ? right : left) = mid;\n        }\n        return right > m ? -1 : right;\n    }\n};\n",
            "go": "func earliestSecondToMarkIndices(nums, changeIndices []int) int {\nn, m := len(nums), len(changeIndices)\nif n > m {\nreturn -1\n}\n\nlastT := make([]int, n)\nans := n + sort.Search(m+1-n, func(mx int) bool {\nmx += n\nclear(lastT)\nfor t, idx := range changeIndices[:mx] {\nlastT[idx-1] = t + 1\n}\nif slices.Contains(lastT, 0) { // 有课程没有考试时间\nreturn false\n}\n\ncnt := 0\nfor i, idx := range changeIndices[:mx] {\nidx--\nif i == lastT[idx]-1 { // 考试\nif nums[idx] > cnt { // 没时间复习\nreturn false\n}\ncnt -= nums[idx] // 复习这门课程\n} else {\ncnt++ // 留着后面用\n}\n}\nreturn true\n})\nif ans > m {\nreturn -1\n}\nreturn ans\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @param {number[]} changeIndices\n * @return {number}\n */\n\n //参考灵神直播内容 https://space.bilibili.com/206214\nvar earliestSecondToMarkIndices = function(nums, changeIndices) {\n\n  //把nums看作考试科目列表, i: 考试科目(examId) nums[i]: 参加此项考试需要的努力值\n  //把changeIndices看作考试时间表, i: 日期(day) , changeIndices[i]: 考试科目(examId)\n  const n = nums.length;\n  const m = changeIndices.length;\n\n  const check = (maxDay) => {\n    //lastExamDay: 每门考试最后一天考试的时间\n    const lastExamDay = new Array(n).fill(-1);\n    for (let day = 0; day < maxDay; day++) {\n      // -1:  从 1-based 转成 0-based\n      lastExamDay[changeIndices[day] - 1] = day;\n    }\n\n    //检查是否每一门考试都囊括在了 [0 - maxDay) 区间\n    for (let examId = 0; examId < n; examId++) {\n      const day = lastExamDay[examId];\n      //当前examId没有办法在[0 - maxDay)之间安排考试\n      if (day === -1) {\n        return false;\n      }\n    }\n\n\n    let cnt = 0; //cnt: 累计的努力值\n    for (let day = 0; day < maxDay; day++) {\n      const examId = lastExamDay.findIndex(date => date === day);\n      if (examId >= 0) {\n         //努力值不足，没法进行考试\n         if (cnt < nums[examId]) {\n           return false;\n         }\n        //努力值足够， 进行考试并消耗努力值\n        cnt -= nums[examId];\n      } else {\n        //没有考试， 累计努力值\n        cnt += 1;\n      }\n    }\n    \n    return true;\n  }\n\n  //二分查找答案\n  let left = 0, right = m + 1;\n  while (left <= right) {\n    //mid： 当前天数\n    const mid = Math.floor((right - left) / 2) + left;\n    \n    if (check(mid)) {\n      //当前天数足够应付考试, 继续压缩时间\n      right = mid - 1;\n    } else {\n      //当前天数不足够应付考试, 放宽时间\n      left = mid + 1;\n    }\n  }\n  return left > m ? -1 : left;\n\n};\n"
        },
        "cases": [
            {
                "input": "[\"[2,2,0]\",\"[2,2,2,2,3,2,2,1]\"]",
                "output": "[\"8\"]"
            },
            {
                "input": "[\"[1,3]\",\"[1,1,1,2,1,1,1]\"]",
                "output": "[\"6\"]"
            },
            {
                "input": "[\"[0,1]\",\"[2,2,2]\"]",
                "output": "[\"-1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int earliestSecondToMarkIndices(int[] nums, int[] changeIndices) {",
            "cpp": "class Solution {\npublic:\n    int earliestSecondToMarkIndices(vector<int>& nums, vector<int>& changeIndices) {",
            "go": "func earliestSecondToMarkIndices(nums []int, changeIndices []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number[]} changeIndices\n * @return {number}\n */\nvar earliestSecondToMarkIndices = function(nums, changeIndices) {",
            "python": "class Solution:\n    def earliestSecondToMarkIndices(self, nums: List[int], changeIndices: List[int]) -> int:"
        },
        "time": "20240225",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "earliestSecondToMarkIndices",
            "java": "earliestSecondToMarkIndices",
            "cpp": "earliestSecondToMarkIndices",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.earliestSecondToMarkIndices([2,2,0], [2,2,2,2,3,2,2,1]) == 8, \"Test 1 Error!\"\nassert my_solution.earliestSecondToMarkIndices([1,3], [1,1,1,2,1,1,1]) == 6, \"Test 2 Error!\"\nassert my_solution.earliestSecondToMarkIndices([0,1], [2,2,2]) == -1, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {2,2,0};\n    int[] changeIndices_1 = {2,2,2,2,3,2,2,1};\n    int ans_1 = 8;\n    assert solution.earliestSecondToMarkIndices(nums_1, changeIndices_1) == ans_1;\n    int[] nums_2 = {1,3};\n    int[] changeIndices_2 = {1,1,1,2,1,1,1};\n    int ans_2 = 6;\n    assert solution.earliestSecondToMarkIndices(nums_2, changeIndices_2) == ans_2;\n    int[] nums_3 = {0,1};\n    int[] changeIndices_3 = {2,2,2};\n    int ans_3 = -1;\n    assert solution.earliestSecondToMarkIndices(nums_3, changeIndices_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {2,2,0};\n    vector<int> changeIndices_1 = {2,2,2,2,3,2,2,1};\n    int ans_1 = 8;\n    assert(my_solution_1.earliestSecondToMarkIndices(nums_1, changeIndices_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,3};\n    vector<int> changeIndices_2 = {1,1,1,2,1,1,1};\n    int ans_2 = 6;\n    assert(my_solution_2.earliestSecondToMarkIndices(nums_2, changeIndices_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {0,1};\n    vector<int> changeIndices_3 = {2,2,2};\n    int ans_3 = -1;\n    assert(my_solution_3.earliestSecondToMarkIndices(nums_3, changeIndices_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "changeIndices"
            ],
            "java": [
                "nums",
                "changeIndices"
            ],
            "cpp": [
                "nums",
                "changeIndices"
            ],
            "go": [],
            "js": []
        }
    },
    "3049": {
        "description": "给你两个下标从 1 开始的整数数组 nums 和 changeIndices ，数组的长度分别为 n 和 m 。一开始，nums 中所有下标都是未标记的，你的任务是标记 nums 中 所有 下标。\n从第 1 秒到第 m 秒（包括 第 m 秒），对于每一秒 s ，你可以执行以下操作 之一 ：\n选择范围 [1, n] 中的一个下标 i ，并且将 nums[i] 减少 1 。\n将 nums[changeIndices[s]] 设置成任意的 非负 整数。\n选择范围 [1, n] 中的一个下标 i ， 满足 nums[i] 等于 0, 并 标记 下标 i 。\n什么也不做。\n请你返回范围 [1, m] 中的一个整数，表示最优操作下，标记 nums 中 所有 下标的 最早秒数 ，如果无法标记所有下标，返回 -1 。",
        "difficulty_level": "Hard",
        "note": "1 <= n == nums.length <= 5000\n0 <= nums[i] <= 10^9\n1 <= m == changeIndices.length <= 5000\n1 <= changeIndices[i] <= n",
        "codes": {
            "python": "class Solution:\n    def earliestSecondToMarkIndices(self, nums: List[int], changeIndices: List[int]) -> int:\n        n, m = len(nums), len(changeIndices)\n        total = n + sum(nums)\n\n        first_t = [-1] * n\n        for t in range(m - 1, -1, -1):\n            first_t[changeIndices[t] - 1] = t\n\n        def check(mx: int) -> bool:\n            cnt = 0\n            slow = total  # 慢速复习+考试所需天数\n            h = []\n            for t in range(mx - 1, -1, -1):\n                i = changeIndices[t] - 1\n                v = nums[i]\n                if v <= 1 or t != first_t[i]:\n                    cnt += 1  # 留给左边，用来快速复习/考试\n                    continue\n                if cnt == 0:\n                    if not h or v <= h[0]:\n                        cnt += 1  # 留给左边，用来快速复习/考试\n                        continue\n                    slow += heappop(h) + 1\n                    cnt += 2  # 反悔：一天快速复习，一天考试\n                slow -= v + 1\n                cnt -= 1  # 快速复习，然后消耗一天来考试\n                heappush(h, v)\n            return cnt >= slow  # 剩余天数搞定慢速复习+考试\n\n        ans = n + bisect_left(range(n, m + 1), True, key=check)\n        return -1 if ans > m else ans\n",
            "java": "class Solution {\n    public int earliestSecondToMarkIndices(int[] nums, int[] changeIndices) {\n        int n = nums.length;\n        int m = changeIndices.length;\n        if (n > m) {\n            return -1;\n        }\n\n        long slow = n; // 慢速复习+考试所需天数\n        for (int v : nums) {\n            slow += v;\n        }\n\n        int[] firstT = new int[n];\n        Arrays.fill(firstT, -1);\n        for (int t = m - 1; t >= 0; t--) {\n            firstT[changeIndices[t] - 1] = t;\n        }\n\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> a - b);\n        int left = n - 1, right = m + 1;\n        while (left + 1 < right) {\n            pq.clear();\n            int mid = (left + right) / 2;\n            if (check(nums, changeIndices, firstT, pq, slow, mid)) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        return right > m ? -1 : right;\n    }\n\n    private boolean check(int[] nums, int[] changeIndices, int[] firstT, PriorityQueue<Integer> pq, long slow, int mx) {\n        int cnt = 0;\n        for (int t = mx - 1; t >= 0; t--) {\n            int i = changeIndices[t] - 1;\n            int v = nums[i];\n            if (v <= 1 || t != firstT[i]) {\n                cnt++; // 留给左边，用来快速复习/考试\n                continue;\n            }\n            if (cnt == 0) {\n                if (pq.isEmpty() || v <= pq.peek()) {\n                    cnt++; // 留给左边，用来快速复习/考试\n                    continue;\n                }\n                slow += pq.poll() + 1;\n                cnt += 2; // 反悔：一天快速复习，一天考试\n            }\n            slow -= v + 1;\n            cnt--; // 快速复习，然后消耗一天来考试\n            pq.offer(v);\n        }\n        return cnt >= slow; // 剩余天数搞定慢速复习+考试\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int earliestSecondToMarkIndices(vector<int> &nums, vector<int> &changeIndices) {\n        int n = nums.size();\n        int m = changeIndices.size();\n        long long total = n + accumulate(nums.begin(), nums.end(), 0LL);\n\n        vector<int> first_t(n, -1);\n        for (int t = m - 1; t >= 0; t--) {\n            first_t[changeIndices[t] - 1] = t;\n        }\n\n        auto check = [&](int mx) -> bool {\n            int cnt = 0;\n            long long slow = total; // 慢速复习+考试所需天数\n            priority_queue<int, vector<int>, greater<>> pq;\n            for (int t = mx - 1; t >= 0; t--) {\n                int i = changeIndices[t] - 1;\n                int v = nums[i];\n                if (v <= 1 || t != first_t[i]) {\n                    cnt++; // 留给左边，用来快速复习/考试\n                    continue;\n                }\n                if (cnt == 0) {\n                    if (pq.empty() || v <= pq.top()) {\n                        cnt++; // 留给左边，用来快速复习/考试\n                        continue;\n                    }\n                    slow += pq.top() + 1;\n                    pq.pop();\n                    cnt += 2; // 反悔：一天快速复习，一天考试\n                }\n                slow -= v + 1;\n                cnt--; // 快速复习，然后消耗一天来考试\n                pq.push(v);\n            }\n            return cnt >= slow; // 剩余天数搞定慢速复习+考试\n        };\n\n        int left = n - 1, right = m + 1;\n        while (left + 1 < right) {\n            int mid = (left + right) / 2;\n            (check(mid) ? right : left) = mid;\n        }\n        return right > m ? -1 : right;\n    }\n};\n",
            "go": "func earliestSecondToMarkIndices(nums, changeIndices []int) int {\nn, m := len(nums), len(changeIndices)\nif n > m {\nreturn -1\n}\n\ntotal := n\nfor _, v := range nums {\ntotal += v // 慢速复习+考试所需天数\n}\n\nfirstT := make([]int, n)\nfor t := m - 1; t >= 0; t-- {\nfirstT[changeIndices[t]-1] = t + 1\n}\n\nh := hp{}\nans := n + sort.Search(m+1-n, func(mx int) bool {\nmx += n\ncnt, slow := 0, total\nh.IntSlice = h.IntSlice[:0]\nfor t := mx - 1; t >= 0; t-- {\ni := changeIndices[t] - 1\nv := nums[i]\nif v <= 1 || t != firstT[i]-1 {\ncnt++ // 留给左边，用来快速复习/考试\ncontinue\n}\nif cnt == 0 {\nif h.Len() == 0 || v <= h.IntSlice[0] {\ncnt++ // 留给左边，用来快速复习/考试\ncontinue\n}\nslow += heap.Pop(&h).(int) + 1\ncnt += 2 // 反悔：一天快速复习，一天考试\n}\nslow -= v + 1\ncnt-- // 快速复习，然后消耗一天来考试\nheap.Push(&h, v)\n}\nreturn cnt >= slow // 剩余天数搞定慢速复习+考试\n})\nif ans > m {\nreturn -1\n}\nreturn ans\n}\n\ntype hp struct{ sort.IntSlice }\nfunc (h *hp) Push(v any) { h.IntSlice = append(h.IntSlice, v.(int)) }\nfunc (h *hp) Pop() any   { a := h.IntSlice; v := a[len(a)-1]; h.IntSlice = a[:len(a)-1]; return v }\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[3,2,3]\",\"[1,3,2,2,2,2,3]\"]",
                "output": "[\"6\"]"
            },
            {
                "input": "[\"[0,0,1,2]\",\"[1,2,1,2,1,2,1,2]\"]",
                "output": "[\"7\"]"
            },
            {
                "input": "[\"[1,2,3]\",\"[1,2,3]\"]",
                "output": "[\"-1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int earliestSecondToMarkIndices(int[] nums, int[] changeIndices) {",
            "cpp": "class Solution {\npublic:\n    int earliestSecondToMarkIndices(vector<int>& nums, vector<int>& changeIndices) {",
            "go": "func earliestSecondToMarkIndices(nums []int, changeIndices []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number[]} changeIndices\n * @return {number}\n */\nvar earliestSecondToMarkIndices = function(nums, changeIndices) {",
            "python": "class Solution:\n    def earliestSecondToMarkIndices(self, nums: List[int], changeIndices: List[int]) -> int:"
        },
        "time": "20240225",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "earliestSecondToMarkIndices",
            "java": "earliestSecondToMarkIndices",
            "cpp": "earliestSecondToMarkIndices",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.earliestSecondToMarkIndices([3,2,3], [1,3,2,2,2,2,3]) == 6, \"Test 1 Error!\"\nassert my_solution.earliestSecondToMarkIndices([0,0,1,2], [1,2,1,2,1,2,1,2]) == 7, \"Test 2 Error!\"\nassert my_solution.earliestSecondToMarkIndices([1,2,3], [1,2,3]) == -1, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {3,2,3};\n    int[] changeIndices_1 = {1,3,2,2,2,2,3};\n    int ans_1 = 6;\n    assert solution.earliestSecondToMarkIndices(nums_1, changeIndices_1) == ans_1;\n    int[] nums_2 = {0,0,1,2};\n    int[] changeIndices_2 = {1,2,1,2,1,2,1,2};\n    int ans_2 = 7;\n    assert solution.earliestSecondToMarkIndices(nums_2, changeIndices_2) == ans_2;\n    int[] nums_3 = {1,2,3};\n    int[] changeIndices_3 = {1,2,3};\n    int ans_3 = -1;\n    assert solution.earliestSecondToMarkIndices(nums_3, changeIndices_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {3,2,3};\n    vector<int> changeIndices_1 = {1,3,2,2,2,2,3};\n    int ans_1 = 6;\n    assert(my_solution_1.earliestSecondToMarkIndices(nums_1, changeIndices_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {0,0,1,2};\n    vector<int> changeIndices_2 = {1,2,1,2,1,2,1,2};\n    int ans_2 = 7;\n    assert(my_solution_2.earliestSecondToMarkIndices(nums_2, changeIndices_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {1,2,3};\n    vector<int> changeIndices_3 = {1,2,3};\n    int ans_3 = -1;\n    assert(my_solution_3.earliestSecondToMarkIndices(nums_3, changeIndices_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "changeIndices"
            ],
            "java": [
                "nums",
                "changeIndices"
            ],
            "cpp": [
                "nums",
                "changeIndices"
            ],
            "go": [],
            "js": []
        }
    },
    "3069": {
        "description": "给你一个下标从 1 开始、包含 不同 整数的数组 nums ，数组长度为 n 。\n你需要通过 n 次操作，将 nums 中的所有元素分配到两个数组 arr1 和 arr2 中。在第一次操作中，将 nums[1] 追加到 arr1 。在第二次操作中，将 nums[2] 追加到 arr2 。之后，在第 i 次操作中：\n如果 arr1 的最后一个元素 大于 arr2 的最后一个元素，就将 nums[i] 追加到 arr1 。否则，将 nums[i] 追加到 arr2 。\n通过连接数组 arr1 和 arr2 形成数组 result 。例如，如果 arr1 == [1,2,3] 且 arr2 == [4,5,6] ，那么 result = [1,2,3,4,5,6] 。\n返回数组 result 。",
        "difficulty_level": "Easy",
        "note": "3 <= n <= 50\n1 <= nums[i] <= 100\nnums中的所有元素都互不相同。",
        "codes": {
            "python": "class Solution:\n    def resultArray(self, nums: List[int]) -> List[int]:\n        a = nums[:1]\n        b = nums[1:2]\n        for x in nums[2:]:\n            if a[-1] > b[-1]:\n                a.append(x)\n            else:\n                b.append(x)\n        return a + b\n",
            "java": "class Solution {\n    public int[] resultArray(int[] nums) {\n        int n = nums.length;\n        List<Integer> a = new ArrayList<>();\n        List<Integer> b = new ArrayList<>();\n        a.add(nums[0]);\n        b.add(nums[1]);\n        for (int i = 2; i < n; i++) {\n            if (a.get(a.size() - 1) > b.get(b.size() - 1)) {\n                a.add(nums[i]);\n            } else {\n                b.add(nums[i]);\n            }\n        }\n        a.addAll(b);\n        for (int i = 0; i < n; i++) {\n            nums[i] = a.get(i);\n        }\n        return nums;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    vector<int> resultArray(vector<int> &nums) {\n        vector<int> a{nums[0]}, b{nums[1]};\n        for (int i = 2; i < nums.size(); i++) {\n            (a.back() > b.back() ? a : b).push_back(nums[i]);\n        }\n        a.insert(a.end(), b.begin(), b.end());\n        return a;\n    }\n};\n",
            "go": "func resultArray(nums []int) []int {\na := nums[:1]\nb := []int{nums[1]}\nfor _, x := range nums[2:] {\nif a[len(a)-1] > b[len(b)-1] {\na = append(a, x)\n} else {\nb = append(b, x)\n}\n}\nreturn append(a, b...)\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar resultArray = function(nums) {\n    let a = [nums[0]], b = [nums[1]]\n    for(let i = 2; i < nums.length; i++){\n        if(a.at(-1) > b.at(-1)) a.push(nums[i])\n        else b.push(nums[i])\n    }\n    return a.concat(b)\n};\n"
        },
        "cases": [
            {
                "input": "[\"[2,1,3]\"]",
                "output": "[\"[2,3,1]\"]"
            },
            {
                "input": "[\"[5,4,3,8]\"]",
                "output": "[\"[5,3,4,8]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int[] resultArray(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    vector<int> resultArray(vector<int>& nums) {",
            "go": "func resultArray(nums []int) []int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar resultArray = function(nums) {",
            "python": "class Solution:\n    def resultArray(self, nums: List[int]) -> List[int]:"
        },
        "time": "20240303",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "resultArray",
            "java": "resultArray",
            "cpp": "resultArray",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.resultArray([2,1,3]) == [2,3,1], \"Test 1 Error!\"\nassert my_solution.resultArray([5,4,3,8]) == [5,3,4,8], \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {2,1,3};\n    int[] ans_1 = {2,3,1};\n    assert Arrays.equals(solution.resultArray(nums_1), ans_1);\n    int[] nums_2 = {5,4,3,8};\n    int[] ans_2 = {5,3,4,8};\n    assert Arrays.equals(solution.resultArray(nums_2), ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {2,1,3};\n    vector<int> ans_1 = {2,3,1};\n    assert(my_solution_1.resultArray(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {5,4,3,8};\n    vector<int> ans_2 = {5,3,4,8};\n    assert(my_solution_2.resultArray(nums_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3070": {
        "description": "给你一个下标从 0 开始的整数矩阵 grid 和一个整数 k。返回包含 grid 左上角元素、元素和小于或等于 k 的 \n子矩阵\n的数目。",
        "difficulty_level": "Middle",
        "note": "m == grid.length\nn == grid[i].length\n1 <= n, m <= 1000\n0 <= grid[i][j] <= 1000\n1 <= k <= 10^9",
        "codes": {
            "python": "class Solution:\n    def countSubmatrices(self, grid: List[List[int]], k: int) -> int:\n        ans = 0\n        m, n = len(grid), len(grid[0])\n        s = [[0] * (n + 1) for _ in range(m + 1)]\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                s[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + x\n                if s[i + 1][j + 1] <= k:\n                    ans += 1\n        return ans\n",
            "java": "class Solution {\n    public int countSubmatrices(int[][] grid, int k) {\n        int ans = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] sum = new int[m + 1][n + 1];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + grid[i][j];\n                if (sum[i + 1][j + 1] <= k) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int countSubmatrices(vector<vector<int>> &grid, int k) {\n        int ans = 0, m = grid.size(), n = grid[0].size();\n        vector<vector<int>> sum(m + 1, vector<int>(n + 1));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + grid[i][j];\n                ans += sum[i + 1][j + 1] <= k;\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func countSubmatrices(grid [][]int, k int) (ans int) {\nm, n := len(grid), len(grid[0])\nsum := make([][]int, m+1)\nsum[0] = make([]int, n+1)\nfor i, row := range grid {\nsum[i+1] = make([]int, n+1)\nfor j, x := range row {\nsum[i+1][j+1] = sum[i+1][j] + sum[i][j+1] - sum[i][j] + x\nif sum[i+1][j+1] <= k {\nans++\n}\n}\n}\nreturn\n}\n",
            "js": "/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number}\n */\nvar countSubmatrices = function(grid, k) {\n  let num = 0;\n  let temp = [...grid[0]];\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      if (temp.slice(0, j + 1).reduce((a, b) => a + b, 0) <= k) {\n        num++;\n      }\n      if (j === grid[0].length - 1 && i < grid.length - 1) {\n        temp = temp.map((item, index) => item + grid[i + 1][index]);\n      }\n    }\n  }\n  return num;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[[7,6,3],[6,6,1]]\",\"18\"]",
                "output": "[\"4\"]"
            },
            {
                "input": "[\"[[7,2,9],[1,5,0],[2,6,6]]\",\"20\"]",
                "output": "[\"6\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int countSubmatrices(int[][] grid, int k) {",
            "cpp": "class Solution {\npublic:\n    int countSubmatrices(vector<vector<int>>& grid, int k) {",
            "go": "func countSubmatrices(grid [][]int, k int) int {\n\n}",
            "js": "/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number}\n */\nvar countSubmatrices = function(grid, k) {",
            "python": "class Solution:\n    def countSubmatrices(self, grid: List[List[int]], k: int) -> int:"
        },
        "time": "20240303",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "countSubmatrices",
            "java": "countSubmatrices",
            "cpp": "countSubmatrices",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.countSubmatrices([[7,6,3],[6,6,1]], 18) == 4, \"Test 1 Error!\"\nassert my_solution.countSubmatrices([[7,2,9],[1,5,0],[2,6,6]], 20) == 6, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] grid_1 = {{7,6,3},{6,6,1}};\n    int k_1 = 18;\n    int ans_1 = 4;\n    assert solution.countSubmatrices(grid_1, k_1) == ans_1;\n    int[][] grid_2 = {{7,2,9},{1,5,0},{2,6,6}};\n    int k_2 = 20;\n    int ans_2 = 6;\n    assert solution.countSubmatrices(grid_2, k_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> grid_1 = {{7,6,3},{6,6,1}};\n    int k_1 = 18;\n    int ans_1 = 4;\n    assert(my_solution_1.countSubmatrices(grid_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> grid_2 = {{7,2,9},{1,5,0},{2,6,6}};\n    int k_2 = 20;\n    int ans_2 = 6;\n    assert(my_solution_2.countSubmatrices(grid_2, k_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "grid",
                "k"
            ],
            "java": [
                "grid",
                "k"
            ],
            "cpp": [
                "grid",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3071": {
        "description": "给你一个下标从 0 开始、大小为 n x n 的矩阵 grid ，其中 n 为奇数，且 grid[r][c] 的值为 0 、1 或 2 。如果一个单元格属于以下三条线中的任一一条，我们就认为它是字母 Y 的一部分：\n从左上角单元格开始到矩阵中心单元格结束的对角线。\n从右上角单元格开始到矩阵中心单元格结束的对角线。\n从中心单元格开始到矩阵底部边界结束的垂直线。\n当且仅当满足以下全部条件时，可以判定矩阵上写有字母 Y ：\n属于 Y 的所有单元格的值相等。\n不属于 Y 的所有单元格的值相等。\n属于 Y 的单元格的值与不属于Y的单元格的值不同。\n每次操作你可以将任意单元格的值改变为 0 、1 或 2 。返回在矩阵上写出字母 Y 所需的 最少 操作次数。",
        "difficulty_level": "Middle",
        "note": "3 <= n <= 49\nn == grid.length == grid[i].length\n0 <= grid[i][j] <= 2\nn 为奇数。",
        "codes": {
            "python": "class Solution:\n    def minimumOperationsToWriteY(self, grid: List[List[int]]) -> int:\n        cnt1 = [0] * 3\n        cnt2 = [0] * 3\n        n = len(grid)\n        m = n // 2\n\n        for i, row in enumerate(grid[:m]):\n            cnt1[row[i]] += 1\n            cnt1[row[-1 - i]] += 1\n            for j, x in enumerate(row):\n                if j != i and j != n - 1 - i:\n                    cnt2[x] += 1\n        for row in grid[m:]:\n            cnt1[row[m]] += 1\n            for j, x in enumerate(row):\n                if j != m:\n                    cnt2[x] += 1\n\n        max_not_change = 0\n        for i, c1 in enumerate(cnt1):\n            for j, c2 in enumerate(cnt2):\n                if i != j:\n                    max_not_change = max(max_not_change, c1 + c2)\n        return n * n - max_not_change\n",
            "java": "class Solution {\n    public int minimumOperationsToWriteY(int[][] grid) {\n        int[] cnt1 = new int[3];\n        int[] cnt2 = new int[3];\n        int n = grid.length;\n        int m = n / 2;\n        for (int i = 0; i < m; i++) {\n            cnt1[grid[i][i]]++;\n            cnt1[grid[i][n - 1 - i]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != i && j != n - 1 - i) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n        for (int i = m; i < n; i++) {\n            cnt1[grid[i][m]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != m) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n\n        int maxNotChange = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (i != j) {\n                    maxNotChange = Math.max(maxNotChange, cnt1[i] + cnt2[j]);\n                }\n            }\n        }\n        return n * n - maxNotChange;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumOperationsToWriteY(vector<vector<int>> &grid) {\n        int cnt1[3]{}, cnt2[3]{};\n        int n = grid.size();\n        int m = n / 2;\n        for (int i = 0; i < m; i++) {\n            cnt1[grid[i][i]]++;\n            cnt1[grid[i][n - 1 - i]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != i && j != n - 1 - i) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n        for (int i = m; i < n; i++) {\n            cnt1[grid[i][m]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != m) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n\n        int max_not_change = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (i != j) {\n                    max_not_change = max(max_not_change, cnt1[i] + cnt2[j]);\n                }\n            }\n        }\n        return n * n - max_not_change;\n    }\n};\n",
            "go": "func minimumOperationsToWriteY(grid [][]int) int {\nvar cnt1, cnt2 [3]int\nn := len(grid)\nm := n / 2\nfor i, row := range grid[:m] {\ncnt1[row[i]]++\ncnt1[row[n-1-i]]++\nfor j, x := range row {\nif j != i && j != n-1-i {\ncnt2[x]++\n}\n}\n}\nfor _, row := range grid[m:] {\ncnt1[row[m]]++\nfor j, x := range row {\nif j != m {\ncnt2[x]++\n}\n}\n}\n\nmaxNotChange := 0\nfor i, c1 := range cnt1 {\nfor j, c2 := range cnt2 {\nif i != j {\nmaxNotChange = max(maxNotChange, c1+c2)\n}\n}\n}\nreturn n*n - maxNotChange\n}\n",
            "js": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumOperationsToWriteY = function (grid) {\n    let n = grid.length;\n    let m = Math.floor(n / 2);\n    let temp = [];\n    let ans = [];\n    for (let i = 0; i < n; i++) {\n        if (i < m) {\n            temp.push(grid[i][i]);\n            temp.push(grid[i][n - i - 1]);\n        } else temp.push(grid[i][m]);\n        for (let j = 0; j < n; j++) {\n            if (i < m) {\n                if (j !== i && j !== n - i - 1) {\n                    ans.push(grid[i][j]);\n                }\n            } else {\n                if (j !== m) ans.push(grid[i][j]);\n            }\n        }\n    }\n    let num = findMostFrequent(temp);\n    let count = findMostFrequent(ans);\n    if (num[0].number === count[0].number) {\n        if (\n            num[0].number === num[1].number &&\n            count[0].number === count[1].number\n        ) {\n            return num[0].count;\n        }\n        if (count[0].number === count[1].number) {\n            return ans.length - count[0].count + temp.length - num[1].count;\n        }\n        if (num[0].number === num[1].number) {\n            return ans.length - count[1].count + temp.length - num[0].count;\n        }\n        if (num[0].count - num[1].count > count[0].count - count[1].count) {\n            return ans.length - count[1].count + temp.length - num[0].count;\n        } else {\n            return ans.length - count[0].count + temp.length - num[1].count;\n        }\n    } else {\n        return ans.length - count[0].count + temp.length - num[0].count;\n    }\n};\n\nfunction findMostFrequent(arr) {\n    let frequency = {};\n    // 计算每个数字的出现次数\n    arr.forEach((num) => {\n        frequency[num] = (frequency[num] || 0) + 1;\n    });\n    let a = Object.keys(frequency).sort((a, b) => frequency[b] - frequency[a]);\n    if (a.length >= 2) {\n        return [\n            { number: a[0], count: frequency[a[0]] },\n            { number: a[1], count: frequency[a[1]] },\n        ];\n    } else {\n        return [\n            { number: a[0], count: frequency[a[0]] },\n            { number: a[0], count: frequency[a[0]] },\n        ];\n    }\n}\n"
        },
        "cases": [
            {
                "input": "[\"[[1,2,2],[1,1,0],[0,1,0]]\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[[0,1,0,1,0],[2,1,0,1,2],[2,2,2,0,1],[2,2,2,2,2],[2,1,2,2,2]]\"]",
                "output": "[\"12\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumOperationsToWriteY(int[][] grid) {",
            "cpp": "class Solution {\npublic:\n    int minimumOperationsToWriteY(vector<vector<int>>& grid) {",
            "go": "func minimumOperationsToWriteY(grid [][]int) int {\n\n}",
            "js": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumOperationsToWriteY = function(grid) {",
            "python": "class Solution:\n    def minimumOperationsToWriteY(self, grid: List[List[int]]) -> int:"
        },
        "time": "20240303",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumOperationsToWriteY",
            "java": "minimumOperationsToWriteY",
            "cpp": "minimumOperationsToWriteY",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumOperationsToWriteY([[1,2,2],[1,1,0],[0,1,0]]) == 3, \"Test 1 Error!\"\nassert my_solution.minimumOperationsToWriteY([[0,1,0,1,0],[2,1,0,1,2],[2,2,2,0,1],[2,2,2,2,2],[2,1,2,2,2]]) == 12, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] grid_1 = {{1,2,2},{1,1,0},{0,1,0}};\n    int ans_1 = 3;\n    assert solution.minimumOperationsToWriteY(grid_1) == ans_1;\n    int[][] grid_2 = {{0,1,0,1,0},{2,1,0,1,2},{2,2,2,0,1},{2,2,2,2,2},{2,1,2,2,2}};\n    int ans_2 = 12;\n    assert solution.minimumOperationsToWriteY(grid_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> grid_1 = {{1,2,2},{1,1,0},{0,1,0}};\n    int ans_1 = 3;\n    assert(my_solution_1.minimumOperationsToWriteY(grid_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> grid_2 = {{0,1,0,1,0},{2,1,0,1,2},{2,2,2,0,1},{2,2,2,2,2},{2,1,2,2,2}};\n    int ans_2 = 12;\n    assert(my_solution_2.minimumOperationsToWriteY(grid_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "grid"
            ],
            "java": [
                "grid"
            ],
            "cpp": [
                "grid"
            ],
            "go": [],
            "js": []
        }
    },
    "3072": {
        "description": "给你一个下标从 1 开始、长度为 n 的整数数组 nums 。\n现定义函数 greaterCount ，使得 greaterCount(arr, val) 返回数组 arr 中 严格大于 val 的元素数量。\n你需要使用 n 次操作，将 nums 的所有元素分配到两个数组 arr1 和 arr2 中。在第一次操作中，将 nums[1] 追加到 arr1 。在第二次操作中，将 nums[2] 追加到 arr2 。之后，在第 i 次操作中：\n如果 greaterCount(arr1, nums[i]) > greaterCount(arr2, nums[i]) ，将 nums[i] 追加到 arr1 。\n如果 greaterCount(arr1, nums[i]) < greaterCount(arr2, nums[i]) ，将 nums[i] 追加到 arr2 。\n如果 greaterCount(arr1, nums[i]) == greaterCount(arr2, nums[i]) ，将 nums[i] 追加到元素数量较少的数组中。\n如果仍然相等，那么将 nums[i] 追加到 arr1 。\n连接数组 arr1 和 arr2 形成数组 result 。例如，如果 arr1 == [1,2,3] 且 arr2 == [4,5,6] ，那么 result = [1,2,3,4,5,6] 。\n返回整数数组 result 。",
        "difficulty_level": "Hard",
        "note": "3 <= n <= 10^5\n1 <= nums[i] <= 10^9",
        "codes": {
            "python": "class BinaryIndexedTree:\n    def __init__(self, n):\n        self.val = [0] * n\n\n    def add(self, i):\n        while i < len(self.val):\n            self.val[i] += 1\n            i += i & -i\n\n    def get(self, i):\n        res = 0\n        while i > 0:\n            res += self.val[i]\n            i &= i - 1\n        return res\n\nclass Solution:\n    def resultArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        sorted_nums = sorted(nums)\n        index = {}\n        for i,a in enumerate(sorted_nums):\n            index[a] = i + 1\n        arr1 = [nums[0]]\n        arr2 = [nums[1]]\n        tree1 = BinaryIndexedTree(n + 1)\n        tree2 = BinaryIndexedTree(n + 1)\n        tree1.add(index[nums[0]])\n        tree2.add(index[nums[1]])\n        for i in range(2, n):\n            count1 = len(arr1) - tree1.get(index[nums[i]])\n            count2 = len(arr2) - tree2.get(index[nums[i]])\n            if count1 > count2 or count1 == count2 and len(arr1) <= len(arr2):\n                arr1.append(nums[i])\n                tree1.add(index[nums[i]])\n            else:\n                arr2.append(nums[i])\n                tree2.add(index[nums[i]])\n        return arr1 + arr2\n",
            "java": "class BinaryIndexedTree {\n    private int[] tree;\n\n    public BinaryIndexedTree(int n) {\n        tree = new int[n + 1];\n    }\n\n    public void add(int i) {\n        while (i < tree.length) {\n            tree[i]++;\n            i += i & -i;\n        }\n    }\n\n    public int get(int i) {\n        int sum = 0;\n        while (i > 0) {\n            sum += tree[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n}\n\nclass Solution {\n    public int[] resultArray(int[] nums) {\n        int n = nums.length;\n        int[] sortedNums = Arrays.copyOf(nums, n);\n        Arrays.sort(sortedNums);\n\n        Map<Integer, Integer> index = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            index.put(sortedNums[i], i + 1);\n        }\n\n        List<Integer> arr1 = new ArrayList<>(List.of(nums[0]));\n        List<Integer> arr2 = new ArrayList<>(List.of(nums[1]));\n        BinaryIndexedTree tree1 = new BinaryIndexedTree(n);\n        BinaryIndexedTree tree2 = new BinaryIndexedTree(n);\n        tree1.add(index.get(nums[0]));\n        tree2.add(index.get(nums[1]));\n\n        for (int i = 2; i < n; i++) {\n            int count1 = arr1.size() - tree1.get(index.get(nums[i]));\n            int count2 = arr2.size() - tree2.get(index.get(nums[i]));\n            if (count1 > count2 || (count1 == count2 && arr1.size() <= arr2.size())) {\n                arr1.add(nums[i]);\n                tree1.add(index.get(nums[i]));\n            } else {\n                arr2.add(nums[i]);\n                tree2.add(index.get(nums[i]));\n            }\n        }\n\n        int i = 0;\n        for (int a: arr1) {\n            nums[i++] = a;\n        }\n        for (int a: arr2) {\n            nums[i++] = a;\n        }\n        return nums;\n    }\n}\n",
            "cpp": "class BinaryIndexedTree {\nprivate:\n    vector<int> tree;\n\npublic:\n    BinaryIndexedTree(int n) : tree(n + 1) {}\n\n    void add(int i) {\n        while (i < tree.size()) {\n            tree[i] += 1;\n            i += i & -i;\n        }\n    }\n\n    int get(int i) {\n        int res = 0;\n        while (i > 0) {\n            res += tree[i];\n            i &= i - 1;\n        }\n        return res;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> resultArray(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> sortedNums = nums;\n        sort(sortedNums.begin(), sortedNums.end());\n        unordered_map<int, int> index;\n        for (int i = 0; i < n; ++i) {\n            index[sortedNums[i]] = i + 1;\n        }\n\n        vector<int> arr1 = {nums[0]};\n        vector<int> arr2 = {nums[1]};\n        BinaryIndexedTree tree1(n), tree2(n);\n        tree1.add(index[nums[0]]);\n        tree2.add(index[nums[1]]);\n\n        for (int i = 2; i < n; ++i) {\n            int count1 = arr1.size() - tree1.get(index[nums[i]]);\n            int count2 = arr2.size() - tree2.get(index[nums[i]]);\n            if (count1 > count2 || (count1 == count2 && arr1.size() <= arr2.size())) {\n                arr1.push_back(nums[i]);\n                tree1.add(index[nums[i]]);\n            } else {\n                arr2.push_back(nums[i]);\n                tree2.add(index[nums[i]]);\n            }\n        }\n\n        arr1.insert(arr1.end(), arr2.begin(), arr2.end());\n        return arr1;\n    }\n};\n",
            "go": "type BinaryIndexedTree struct {\n    tree []int\n}\n\nfunc NewBinaryIndexedTree(n int) *BinaryIndexedTree {\n    return &BinaryIndexedTree{tree: make([]int, n+1)}\n}\n\nfunc (bit *BinaryIndexedTree) Add(i int) {\n    for i < len(bit.tree) {\n        bit.tree[i]++\n        i += i & -i\n    }\n}\n\nfunc (bit *BinaryIndexedTree) Get(i int) int {\n    sum := 0\n    for i > 0 {\n        sum += bit.tree[i]\n        i -= i & -i\n    }\n    return sum\n}\n\nfunc resultArray(nums []int) []int {\n    n := len(nums)\n    sortedNums := make([]int, n)\n    copy(sortedNums, nums)\n    sort.Ints(sortedNums)\n    index := make(map[int]int)\n    for i, num := range sortedNums {\n        index[num] = i + 1\n    }\n\n    arr1, arr2 := []int{nums[0]}, []int{nums[1]}\n    tree1, tree2 := NewBinaryIndexedTree(n), NewBinaryIndexedTree(n)\n    tree1.Add(index[nums[0]])\n    tree2.Add(index[nums[1]])\n\n    for i := 2; i < n; i++ {\n        count1 := len(arr1) - tree1.Get(index[nums[i]])\n        count2 := len(arr2) - tree2.Get(index[nums[i]])\n        if count1 > count2 || (count1 == count2 && len(arr1) <= len(arr2)) {\n            arr1 = append(arr1, nums[i])\n            tree1.Add(index[nums[i]])\n        } else {\n            arr2 = append(arr2, nums[i])\n            tree2.Add(index[nums[i]])\n        }\n    }\n\n    return append(arr1, arr2...)\n}\n",
            "js": "class BinaryIndexedTree {\n    constructor(n) {\n        this.tree = new Array(n + 1).fill(0);\n    }\n\n    add(i) {\n        while (i < this.tree.length) {\n            this.tree[i]++;\n            i += i & -i;\n        }\n    }\n\n    get(i) {\n        let sum = 0;\n        while (i > 0) {\n            sum += this.tree[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n}\n\nvar resultArray = function(nums) {\n    const n = nums.length;\n    const sortedNums = [...nums].sort((a, b) => a - b);\n    const index = {};\n    for (let i = 0; i < n; i++) {\n        index[sortedNums[i]] = i + 1;\n    }\n\n    const arr1 = [nums[0]];\n    const arr2 = [nums[1]];\n    const tree1 = new BinaryIndexedTree(n);\n    const tree2 = new BinaryIndexedTree(n);\n    tree1.add(index[nums[0]]);\n    tree2.add(index[nums[1]]);\n\n    for (let i = 2; i < n; i++) {\n        const count1 = arr1.length - tree1.get(index[nums[i]]);\n        const count2 = arr2.length - tree2.get(index[nums[i]]);\n        if (count1 > count2 || (count1 === count2 && arr1.length <= arr2.length)) {\n            arr1.push(nums[i]);\n            tree1.add(index[nums[i]]);\n        } else {\n            arr2.push(nums[i]);\n            tree2.add(index[nums[i]]);\n        }\n    }\n\n    return arr1.concat(arr2);\n};\n"
        },
        "cases": [
            {
                "input": "[\"[2,1,3,3]\"]",
                "output": "[\"[2,3,1,3]\"]"
            },
            {
                "input": "[\"[5,14,3,1,2]\"]",
                "output": "[\"[5,3,1,2,14]\"]"
            },
            {
                "input": "[\"[3,3,3,3]\"]",
                "output": "[\"[3,3,3,3]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int[] resultArray(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    vector<int> resultArray(vector<int>& nums) {",
            "go": "func resultArray(nums []int) []int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar resultArray = function(nums) {",
            "python": "class Solution:\n    def resultArray(self, nums: List[int]) -> List[int]:"
        },
        "time": "20240303",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "resultArray",
            "java": "resultArray",
            "cpp": "resultArray",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.resultArray([2,1,3,3]) == [2,3,1,3], \"Test 1 Error!\"\nassert my_solution.resultArray([5,14,3,1,2]) == [5,3,1,2,14], \"Test 2 Error!\"\nassert my_solution.resultArray([3,3,3,3]) == [3,3,3,3], \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {2,1,3,3};\n    int[] ans_1 = {2,3,1,3};\n    assert Arrays.equals(solution.resultArray(nums_1), ans_1);\n    int[] nums_2 = {5,14,3,1,2};\n    int[] ans_2 = {5,3,1,2,14};\n    assert Arrays.equals(solution.resultArray(nums_2), ans_2);\n    int[] nums_3 = {3,3,3,3};\n    int[] ans_3 = {3,3,3,3};\n    assert Arrays.equals(solution.resultArray(nums_3), ans_3);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {2,1,3,3};\n    vector<int> ans_1 = {2,3,1,3};\n    assert(my_solution_1.resultArray(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {5,14,3,1,2};\n    vector<int> ans_2 = {5,3,1,2,14};\n    assert(my_solution_2.resultArray(nums_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {3,3,3,3};\n    vector<int> ans_3 = {3,3,3,3};\n    assert(my_solution_3.resultArray(nums_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3074": {
        "description": "给你一个长度为 n 的数组 apple 和另一个长度为 m 的数组 capacity 。\n一共有 n 个包裹，其中第 i 个包裹中装着 apple[i] 个苹果。同时，还有 m 个箱子，第 i 个箱子的容量为 capacity[i] 个苹果。\n请你选择一些箱子来将这 n 个包裹中的苹果重新分装到箱子中，返回你需要选择的箱子的 最小 数量。\n注意，同一个包裹中的苹果可以分装到不同的箱子中。",
        "difficulty_level": "Easy",
        "note": "1 <= n == apple.length <= 50\n1 <= m == capacity.length <= 50\n1 <= apple[i], capacity[i] <= 50\n输入数据保证可以将包裹中的苹果重新分装到箱子中。",
        "codes": {
            "python": "class Solution:\n    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:\n        s = sum(apple)\n        capacity.sort(reverse=True)\n        for i, x in enumerate(capacity, 1):\n            s -= x\n            if s <= 0:  # 所有苹果都装入了箱子\n                return i\n",
            "java": "class Solution {\n    public int minimumBoxes(int[] apple, int[] capacity) {\n        int s = 0;\n        for (int x : apple) {\n            s += x;\n        }\n        Arrays.sort(capacity);\n        int m = capacity.length;\n        int i = m - 1;\n        for (; s > 0; i--) {\n            s -= capacity[i];\n        }\n        return m - 1 - i;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumBoxes(vector<int> &apple, vector<int> &capacity) {\n        int s = accumulate(apple.begin(), apple.end(), 0);\n        ranges::sort(capacity, greater<>());\n        int i = 0;\n        for (; s > 0; i++) {\n            s -= capacity[i];\n        }\n        return i;\n    }\n};\n",
            "go": "func minimumBoxes(apple, capacity []int) int {\ns := 0\nfor _, x := range apple {\ns += x\n}\nslices.SortFunc(capacity, func(a, b int) int { return b - a })\nfor i, c := range capacity {\ns -= c\nif s <= 0 { // 所有苹果都装入了箱子\nreturn i + 1 // 0 到 i 有 i+1 个箱子\n}\n}\nreturn -1\n}\n",
            "js": "/**\n * @param {number[]} apple\n * @param {number[]} capacity\n * @return {number}\n */\nvar minimumBoxes = function(apple, capacity) {\n    let sum = apple.reduce((a,b) => a + b, 0), c = 0, i = 0 \n    capacity.sort((a,b) => b - a)\n    while(sum > 0){\n        sum -= capacity[i++]\n        c++\n    }\n    return c \n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,3,2]\",\"[4,3,1,5,2]\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[5,5,5]\",\"[2,4,2,7]\"]",
                "output": "[\"4\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumBoxes(int[] apple, int[] capacity) {",
            "cpp": "class Solution {\npublic:\n    int minimumBoxes(vector<int>& apple, vector<int>& capacity) {",
            "go": "func minimumBoxes(apple []int, capacity []int) int {\n\n}",
            "js": "/**\n * @param {number[]} apple\n * @param {number[]} capacity\n * @return {number}\n */\nvar minimumBoxes = function(apple, capacity) {",
            "python": "class Solution:\n    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:"
        },
        "time": "20240310",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumBoxes",
            "java": "minimumBoxes",
            "cpp": "minimumBoxes",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumBoxes([1,3,2], [4,3,1,5,2]) == 2, \"Test 1 Error!\"\nassert my_solution.minimumBoxes([5,5,5], [2,4,2,7]) == 4, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] apple_1 = {1,3,2};\n    int[] capacity_1 = {4,3,1,5,2};\n    int ans_1 = 2;\n    assert solution.minimumBoxes(apple_1, capacity_1) == ans_1;\n    int[] apple_2 = {5,5,5};\n    int[] capacity_2 = {2,4,2,7};\n    int ans_2 = 4;\n    assert solution.minimumBoxes(apple_2, capacity_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> apple_1 = {1,3,2};\n    vector<int> capacity_1 = {4,3,1,5,2};\n    int ans_1 = 2;\n    assert(my_solution_1.minimumBoxes(apple_1, capacity_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> apple_2 = {5,5,5};\n    vector<int> capacity_2 = {2,4,2,7};\n    int ans_2 = 4;\n    assert(my_solution_2.minimumBoxes(apple_2, capacity_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "apple",
                "capacity"
            ],
            "java": [
                "apple",
                "capacity"
            ],
            "cpp": [
                "apple",
                "capacity"
            ],
            "go": [],
            "js": []
        }
    },
    "3075": {
        "description": "给你一个长度为 n 的数组 happiness ，以及一个 正整数 k 。\nn 个孩子站成一队，其中第 i 个孩子的 幸福值 是 happiness[i] 。你计划组织 k 轮筛选从这 n 个孩子中选出 k 个孩子。\n在每一轮选择一个孩子时，所有 尚未 被选中的孩子的 幸福值 将减少 1 。注意，幸福值 不能 变成负数，且只有在它是正数的情况下才会减少。\n选择 k 个孩子，并使你选中的孩子幸福值之和最大，返回你能够得到的 最大值 。",
        "difficulty_level": "Middle",
        "note": "1 <= n == happiness.length <= 2 * 10^5\n1 <= happiness[i] <= 10^8\n1 <= k <= n",
        "codes": {
            "python": "class Solution:\n    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:\n        happiness.sort(reverse=True)\n        ans = 0\n        for i, x in enumerate(happiness[:k]):\n            if x <= i:\n                break\n            ans += x - i\n        return ans\n",
            "java": "class Solution {\n    public long maximumHappinessSum(int[] happiness, int k) {\n        Arrays.sort(happiness);\n        int n = happiness.length;\n        long ans = 0;\n        for (int i = n - 1; i >= n - k && happiness[i] > n - 1 - i; i--) {\n            ans += happiness[i] - (n - 1 - i);\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long maximumHappinessSum(vector<int> &happiness, int k) {\n        ranges::sort(happiness, greater<>());\n        long long ans = 0;\n        for (int i = 0; i < k && happiness[i] > i; i++) {\n            ans += happiness[i] - i;\n        }\n        return ans;\n    }\n};\n",
            "go": "func maximumHappinessSum(happiness []int, k int) (ans int64) {\nslices.SortFunc(happiness, func(a, b int) int { return b - a })\nfor i, x := range happiness[:k] {\nif x <= i {\nbreak\n}\nans += int64(x - i)\n}\nreturn\n}\n",
            "js": "/**\n * @param {number[]} happiness\n * @param {number} k\n * @return {number}\n */\nvar maximumHappinessSum = function (happiness, k) {\n    happiness.sort((a, b) => b - a);\n    let num = 0;\n    for (let i = 0; i < k; i++) {\n        let t = happiness[i] - i;\n        if (t < 0) {\n            return num;\n        }\n        num += t;\n    }\n    return num;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,2,3]\",\"2\"]",
                "output": "[\"4\"]"
            },
            {
                "input": "[\"[1,1,1,1]\",\"2\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"[2,3,4,5]\",\"1\"]",
                "output": "[\"5\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long maximumHappinessSum(int[] happiness, int k) {",
            "cpp": "class Solution {\npublic:\n    long long maximumHappinessSum(vector<int>& happiness, int k) {",
            "go": "func maximumHappinessSum(happiness []int, k int) int64 {\n\n}",
            "js": "/**\n * @param {number[]} happiness\n * @param {number} k\n * @return {number}\n */\nvar maximumHappinessSum = function(happiness, k) {",
            "python": "class Solution:\n    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:"
        },
        "time": "20240310",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maximumHappinessSum",
            "java": "maximumHappinessSum",
            "cpp": "maximumHappinessSum",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maximumHappinessSum([1,2,3], 2) == 4, \"Test 1 Error!\"\nassert my_solution.maximumHappinessSum([1,1,1,1], 2) == 1, \"Test 2 Error!\"\nassert my_solution.maximumHappinessSum([2,3,4,5], 1) == 5, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] happiness_1 = {1,2,3};\n    int k_1 = 2;\n    long ans_1 = 4;\n    assert solution.maximumHappinessSum(happiness_1, k_1) == ans_1;\n    int[] happiness_2 = {1,1,1,1};\n    int k_2 = 2;\n    long ans_2 = 1;\n    assert solution.maximumHappinessSum(happiness_2, k_2) == ans_2;\n    int[] happiness_3 = {2,3,4,5};\n    int k_3 = 1;\n    long ans_3 = 5;\n    assert solution.maximumHappinessSum(happiness_3, k_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> happiness_1 = {1,2,3};\n    int k_1 = 2;\n    long long ans_1 = 4;\n    assert(my_solution_1.maximumHappinessSum(happiness_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> happiness_2 = {1,1,1,1};\n    int k_2 = 2;\n    long long ans_2 = 1;\n    assert(my_solution_2.maximumHappinessSum(happiness_2, k_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> happiness_3 = {2,3,4,5};\n    int k_3 = 1;\n    long long ans_3 = 5;\n    assert(my_solution_3.maximumHappinessSum(happiness_3, k_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "happiness",
                "k"
            ],
            "java": [
                "happiness",
                "k"
            ],
            "cpp": [
                "happiness",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3076": {
        "description": "给你一个数组 arr ，数组中有 n 个 非空 字符串。\n请你求出一个长度为 n 的字符串 answer ，满足：\nanswer[i] 是 arr[i] 最短 的子字符串，且它不是 arr 中其他任何字符串的子字符串。如果有多个这样的子字符串存在，answer[i] 应该是它们中字典序最小的一个。如果不存在这样的子字符串，answer[i] 为空字符串。\n请你返回数组 answer 。",
        "difficulty_level": "Middle",
        "note": "n == arr.length\n2 <= n <= 100\n1 <= arr[i].length <= 20\narr[i] 只包含小写英文字母。",
        "codes": {
            "python": "class Solution:\n    def shortestSubstrings(self, arr: List[str]) -> List[str]:\n        def check(i: int, sub: str) -> bool:\n            for j, s in enumerate(arr):\n                if j != i and sub in s:\n                    return False\n            return True\n\n        ans = []\n        for i, s in enumerate(arr):\n            m = len(s)\n            res = \"\"\n            for size in range(1, m + 1):\n                for j in range(size, m + 1):\n                    t = s[j - size: j]\n                    if (not res or t < res) and check(i, t):\n                        res = t\n                if res: break\n            ans.append(res)\n        return ans\n",
            "java": "class Solution {\n    public String[] shortestSubstrings(String[] arr) {\n        int n = arr.length;\n        String[] ans = new String[n];\n        for (int i = 0; i < n; i++) {\n            int m = arr[i].length();\n            String res = \"\";\n            for (int size = 1; size <= m && res.isEmpty(); size++) {\n                for (int j = size; j <= m; j++) {\n                    String t = arr[i].substring(j - size, j);\n                    if ((res.isEmpty() || t.compareTo(res) < 0) && check(arr, i, t)) {\n                        res = t;\n                    }\n                }\n            }\n            ans[i] = res;\n        }\n        return ans;\n    }\n\n    private boolean check(String[] arr, int i, String sub) {\n        for (int j = 0; j < arr.length; j++) {\n            if (j != i && arr[j].contains(sub)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    vector<string> shortestSubstrings(vector<string> &arr) {\n        int n = arr.size();\n        auto check = [&](int i, string &sub) {\n            for (int j = 0; j < n; j++) {\n                if (j != i && arr[j].find(sub) != string::npos) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        vector<string> ans(n);\n        for (int i = 0; i < n; i++) {\n            int m = arr[i].size();\n            string res;\n            for (int size = 1; size <= m && res.empty(); size++) {\n                for (int j = size; j <= m; j++) {\n                    string t = arr[i].substr(j - size, size);\n                    if ((res.empty() || t < res) && check(i, t)) {\n                        res = t;\n                    }\n                }\n            }\n            ans[i] = res;\n        }\n        return ans;\n    }\n};\n",
            "go": "func shortestSubstrings(arr []string) []string {\nans := make([]string, len(arr))\nfor i, s := range arr {\nm := len(s)\nres := \"\"\nfor size := 1; size <= m && res == \"\"; size++ {\nnext:\nfor k := size; k <= m; k++ {\nsub := s[k-size : k]\nif res != \"\" && sub >= res {\ncontinue\n}\nfor j, t := range arr {\nif j != i && strings.Contains(t, sub) {\ncontinue next\n}\n}\nres = sub\n}\n}\nans[i] = res\n}\nreturn ans\n}\n",
            "js": "/**\n * @param {string[]} arr\n * @return {string[]}\n */\nvar shortestSubstrings = function(arr) {\n  function isUniqueSubstring(index, substring, strings) {\n    for (let i = 0; i < strings.length; i++) {\n      if (i !== index && strings[i].includes(substring)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  const answer = [];\n  for (const [t, originalString] of arr.entries()) {\n    let shortest = \"\";\n    for (let i = 0; i < originalString.length; i++) {\n      for (let j = i + 1; j <= originalString.length; j++) {\n        const substring = originalString.substring(i, j);\n        if (\n          isUniqueSubstring(t, substring, arr) &&\n          (shortest === \"\" || substring.length < shortest.length)\n        ) {\n          shortest = substring;\n        } else if (\n          isUniqueSubstring(t, substring, arr) &&\n          substring.length === shortest.length &&\n          substring < shortest\n        ) {\n          shortest = substring;\n        }\n      }\n    }\n    answer.push(shortest);\n  }\n  return answer;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[\\\"cab\\\",\\\"ad\\\",\\\"bad\\\",\\\"c\\\"]\"]",
                "output": "[\"[\\\"ab\\\",\\\"\\\",\\\"ba\\\",\\\"\\\"]\"]"
            },
            {
                "input": "[\"[\\\"abc\\\",\\\"bcd\\\",\\\"abcd\\\"]\"]",
                "output": "[\"[\\\"\\\",\\\"\\\",\\\"abcd\\\"]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public String[] shortestSubstrings(String[] arr) {",
            "cpp": "class Solution {\npublic:\n    vector<string> shortestSubstrings(vector<string>& arr) {",
            "go": "func shortestSubstrings(arr []string) []string {\n\n}",
            "js": "/**\n * @param {string[]} arr\n * @return {string[]}\n */\nvar shortestSubstrings = function(arr) {",
            "python": "class Solution:\n    def shortestSubstrings(self, arr: List[str]) -> List[str]:"
        },
        "time": "20240310",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "shortestSubstrings",
            "java": "shortestSubstrings",
            "cpp": "shortestSubstrings",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.shortestSubstrings([\"cab\",\"ad\",\"bad\",\"c\"]) == [\"ab\",\"\",\"ba\",\"\"], \"Test 1 Error!\"\nassert my_solution.shortestSubstrings([\"abc\",\"bcd\",\"abcd\"]) == [\"\",\"\",\"abcd\"], \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String[] arr_1 = {\"cab\",\"ad\",\"bad\",\"c\"};\n    String[] ans_1 = {\"ab\",\"\",\"ba\",\"\"};\n    assert Arrays.equals(solution.shortestSubstrings(arr_1), ans_1);\n    String[] arr_2 = {\"abc\",\"bcd\",\"abcd\"};\n    String[] ans_2 = {\"\",\"\",\"abcd\"};\n    assert Arrays.equals(solution.shortestSubstrings(arr_2), ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<string> arr_1 = {\"cab\",\"ad\",\"bad\",\"c\"};\n    vector<string> ans_1 = {\"ab\",\"\",\"ba\",\"\"};\n    assert(my_solution_1.shortestSubstrings(arr_1) == ans_1);\n    Solution my_solution_2;\n    vector<string> arr_2 = {\"abc\",\"bcd\",\"abcd\"};\n    vector<string> ans_2 = {\"\",\"\",\"abcd\"};\n    assert(my_solution_2.shortestSubstrings(arr_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "arr"
            ],
            "java": [
                "arr"
            ],
            "cpp": [
                "arr"
            ],
            "go": [],
            "js": []
        }
    },
    "3077": {
        "description": "给你一个长度为 n 下标从 0 开始的整数数组 nums 和一个 正奇数 整数 k 。\nx 个子数组的能量值定义为 strength = sum[1] * x - sum[2] * (x - 1) + sum[3] * (x - 2) - sum[4] * (x - 3) + ... + sum[x] * 1 ，其中 sum[i] 是第 i 个子数组的和。更正式的，能量值是满足 1 <= i <= x 的所有 i 对应的 (-1)^{i+1} * sum[i] * (x - i + 1) 之和。\n你需要在 nums 中选择 k 个 不相交子数组 ，使得 能量值最大 。\n请你返回可以得到的 最大能量值 。\n注意，选出来的所有子数组 不 需要覆盖整个数组。",
        "difficulty_level": "Hard",
        "note": "1 <= n <= 10^4\n-10^9 <= nums[i] <= 10^9\n1 <= k <= n\n1 <= n * k <= 10^6\nk 是奇数。",
        "codes": {
            "python": "class Solution:\n    def maximumStrength(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        s = list(accumulate(nums, initial=0))\n        f = [[0] * (n + 1) for _ in range(k + 1)]\n        for i in range(1, k + 1):\n            f[i][i - 1] = mx = -inf\n            w = (k - i + 1) * (1 if i % 2 else -1)\n            # j 不能太小也不能太大，要给前面留 i-1 个数，后面留 k-i 个数\n            for j in range(i, n - k + i + 1):\n                mx = max(mx, f[i - 1][j - 1] - s[j - 1] * w)\n                f[i][j] = max(f[i][j - 1], s[j] * w + mx)\n        return f[k][n]\n",
            "java": "class Solution {\n    public long maximumStrength(int[] nums, int k) {\n        int n = nums.length;\n        long[] s = new long[n + 1];\n        for (int i = 0; i < n; i++) {\n            s[i + 1] = s[i] + nums[i];\n        }\n        long[][] f = new long[k + 1][n + 1];\n        for (int i = 1; i <= k; i++) {\n            f[i][i - 1] = Long.MIN_VALUE;\n            long mx = Long.MIN_VALUE;\n            int w = (k - i + 1) * (i % 2 > 0 ? 1 : -1);\n            // j 不能太小也不能太大，要给前面留 i-1 个数，后面留 k-i 个数\n            for (int j = i; j <= n - k + i; j++) {\n                mx = Math.max(mx, f[i - 1][j - 1] - s[j - 1] * w);\n                f[i][j] = Math.max(f[i][j - 1], s[j] * w + mx);\n            }\n        }\n        return f[k][n];\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long maximumStrength(vector<int> &nums, int k) {\n        int n = nums.size();\n        vector<long long> s(n + 1);\n        for (int i = 0; i < n; i++) {\n            s[i + 1] = s[i] + nums[i];\n        }\n        vector<vector<long long>> f(k + 1, vector<long long>(n + 1));\n        for (int i = 1; i <= k; i++) {\n            f[i][i - 1] = LLONG_MIN;\n            long long mx = LLONG_MIN;\n            int w = (k - i + 1) * (i % 2 ? 1 : -1);\n            // j 不能太小也不能太大，要给前面留 i-1 个数，后面留 k-i 个数\n            for (int j = i; j <= n - k + i; j++) {\n                mx = max(mx, f[i - 1][j - 1] - s[j - 1] * w);\n                f[i][j] = max(f[i][j - 1], s[j] * w + mx);\n            }\n        }\n        return f[k][n];\n    }\n};\n",
            "go": "func maximumStrength(nums []int, k int) int64 {\nn := len(nums)\ns := make([]int, n+1)\nfor i, x := range nums {\ns[i+1] = s[i] + x\n}\nf := make([][]int, k+1)\nf[0] = make([]int, n+1)\nfor i := 1; i <= k; i++ {\nf[i] = make([]int, n+1)\nf[i][i-1] = math.MinInt\nmx := math.MinInt\nw := (k - i + 1) * (i%2*2 - 1)\n// j 不能太小也不能太大，要给前面留 i-1 个数，后面留 k-i 个数\nfor j := i; j <= n-k+i; j++ {\nmx = max(mx, f[i-1][j-1]-s[j-1]*w)\nf[i][j] = max(f[i][j-1], s[j]*w+mx)\n}\n}\nreturn int64(f[k][n])\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[1,2,3,-1,2]\",\"3\"]",
                "output": "[\"22\"]"
            },
            {
                "input": "[\"[12,-2,-2,-2,-2]\",\"5\"]",
                "output": "[\"64\"]"
            },
            {
                "input": "[\"[-1,-2,-3]\",\"1\"]",
                "output": "[\"-1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long maximumStrength(int[] nums, int k) {",
            "cpp": "class Solution {\npublic:\n    long long maximumStrength(vector<int>& nums, int k) {",
            "go": "func maximumStrength(nums []int, k int) int64 {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumStrength = function(nums, k) {",
            "python": "class Solution:\n    def maximumStrength(self, nums: List[int], k: int) -> int:"
        },
        "time": "20240310",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maximumStrength",
            "java": "maximumStrength",
            "cpp": "maximumStrength",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maximumStrength([1,2,3,-1,2], 3) == 22, \"Test 1 Error!\"\nassert my_solution.maximumStrength([12,-2,-2,-2,-2], 5) == 64, \"Test 2 Error!\"\nassert my_solution.maximumStrength([-1,-2,-3], 1) == -1, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,3,-1,2};\n    int k_1 = 3;\n    long ans_1 = 22;\n    assert solution.maximumStrength(nums_1, k_1) == ans_1;\n    int[] nums_2 = {12,-2,-2,-2,-2};\n    int k_2 = 5;\n    long ans_2 = 64;\n    assert solution.maximumStrength(nums_2, k_2) == ans_2;\n    int[] nums_3 = {-1,-2,-3};\n    int k_3 = 1;\n    long ans_3 = -1;\n    assert solution.maximumStrength(nums_3, k_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,3,-1,2};\n    int k_1 = 3;\n    long long ans_1 = 22;\n    assert(my_solution_1.maximumStrength(nums_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {12,-2,-2,-2,-2};\n    int k_2 = 5;\n    long long ans_2 = 64;\n    assert(my_solution_2.maximumStrength(nums_2, k_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {-1,-2,-3};\n    int k_3 = 1;\n    long long ans_3 = -1;\n    assert(my_solution_3.maximumStrength(nums_3, k_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "k"
            ],
            "java": [
                "nums",
                "k"
            ],
            "cpp": [
                "nums",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3083": {
        "description": "给你一个字符串 s ，请你判断字符串 s 是否存在一个长度为 2 的子字符串，在其反转后的字符串中也出现。\n如果存在这样的子字符串，返回 true；如果不存在，返回 false 。",
        "difficulty_level": "Easy",
        "note": "1 <= s.length <= 100\n字符串 s 仅由小写英文字母组成。",
        "codes": {
            "python": "class Solution:\n    def isSubstringPresent(self, s: str) -> bool:\n        st = set()\n        for x, y in pairwise(s):\n            st.add((x, y))\n            if (y, x) in st:\n                return True\n        return False\n",
            "java": "class Solution {\n    public boolean isSubstringPresent(String S) {\n        char[] s = S.toCharArray();\n        boolean[][] vis = new boolean[26][26];\n        for (int i = 1; i < s.length; i++) {\n            int x = s[i - 1] - 'a';\n            int y = s[i] - 'a';\n            vis[x][y] = true;\n            if (vis[y][x]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    bool isSubstringPresent(string s) {\n        bool vis[26][26]{};\n        for (int i = 1; i < s.length(); i++) {\n            int x = s[i - 1] - 'a', y = s[i] - 'a';\n            vis[x][y] = true;\n            if (vis[y][x]) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n",
            "go": "func isSubstringPresent(s string) bool {\nvis := [26][26]bool{}\nfor i := 1; i < len(s); i++ {\nx, y := s[i-1]-'a', s[i]-'a'\nvis[x][y] = true\nif vis[y][x] {\nreturn true\n}\n}\nreturn false\n}\n",
            "js": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar isSubstringPresent = function(s) {\n    let i\n    let tmp = s.split('').reverse().join('')\n    for(i = 0;i < s.length-1;i ++){\n        let cur = s[i] + s[i+1] //假设为AB\n        // 正则匹配反转字符串有出现形如AB则返回true\n        if(tmp.match(cur)){\n            return true\n        }\n    }\n    // 没有匹配到结果返回false\n    return false\n};\n"
        },
        "cases": [
            {
                "input": "[\"\\\"leetcode\\\"\"]",
                "output": "[\"true\"]"
            },
            {
                "input": "[\"\\\"abcba\\\"\"]",
                "output": "[\"true\"]"
            },
            {
                "input": "[\"\\\"abcd\\\"\"]",
                "output": "[\"false\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public boolean isSubstringPresent(String s) {",
            "cpp": "class Solution {\npublic:\n    bool isSubstringPresent(string s) {",
            "go": "func isSubstringPresent(s string) bool {\n\n}",
            "js": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar isSubstringPresent = function(s) {",
            "python": "class Solution:\n    def isSubstringPresent(self, s: str) -> bool:"
        },
        "time": "20240317",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "isSubstringPresent",
            "java": "isSubstringPresent",
            "cpp": "isSubstringPresent",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.isSubstringPresent(\"leetcode\") == True, \"Test 1 Error!\"\nassert my_solution.isSubstringPresent(\"abcba\") == True, \"Test 2 Error!\"\nassert my_solution.isSubstringPresent(\"abcd\") == False, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String s_1 = \"leetcode\";\n    boolean ans_1 = true;\n    assert solution.isSubstringPresent(s_1) == ans_1;\n    String s_2 = \"abcba\";\n    boolean ans_2 = true;\n    assert solution.isSubstringPresent(s_2) == ans_2;\n    String s_3 = \"abcd\";\n    boolean ans_3 = false;\n    assert solution.isSubstringPresent(s_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string s_1 = \"leetcode\";\n    bool ans_1 = true;\n    assert(my_solution_1.isSubstringPresent(s_1) == ans_1);\n    Solution my_solution_2;\n    string s_2 = \"abcba\";\n    bool ans_2 = true;\n    assert(my_solution_2.isSubstringPresent(s_2) == ans_2);\n    Solution my_solution_3;\n    string s_3 = \"abcd\";\n    bool ans_3 = false;\n    assert(my_solution_3.isSubstringPresent(s_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "s"
            ],
            "java": [
                "s"
            ],
            "cpp": [
                "s"
            ],
            "go": [],
            "js": []
        }
    },
    "3084": {
        "description": "给你一个字符串 s 和一个字符 c 。返回在字符串 s 中并且以 c 字符开头和结尾的非空子字符串的总数。",
        "difficulty_level": "Middle",
        "note": "1 <= s.length <= 10^5\ns 和 c 均由小写英文字母组成。",
        "codes": {
            "python": "class Solution:\n    def countSubstrings(self, s: str, c: str) -> int:\n        return comb(s.count(c) + 1, 2)\n",
            "java": "class Solution {\n    public long countSubstrings(String s, char c) {\n        long k = s.chars().filter(ch -> ch == c).count();\n        return k * (k + 1) / 2;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long countSubstrings(string s, char c) {\n        long long k = ranges::count(s, c);\n        return k * (k + 1) / 2;\n    }\n};\n",
            "go": "func countSubstrings(s string, c byte) int64 {\nk := int64(strings.Count(s, string(c)))\nreturn k * (k + 1) / 2\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"\\\"abada\\\"\",\"\\\"a\\\"\"]",
                "output": "[\"6\"]"
            },
            {
                "input": "[\"\\\"zzz\\\"\",\"\\\"z\\\"\"]",
                "output": "[\"6\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long countSubstrings(String s, char c) {",
            "cpp": "class Solution {\npublic:\n    long long countSubstrings(string s, char c) {",
            "go": "func countSubstrings(s string, c byte) int64 {\n\n}",
            "js": "/**\n * @param {string} s\n * @param {character} c\n * @return {number}\n */\nvar countSubstrings = function(s, c) {",
            "python": "class Solution:\n    def countSubstrings(self, s: str, c: str) -> int:"
        },
        "time": "20240317",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "countSubstrings",
            "java": "countSubstrings",
            "cpp": "countSubstrings",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.countSubstrings(\"abada\", \"a\") == 6, \"Test 1 Error!\"\nassert my_solution.countSubstrings(\"zzz\", \"z\") == 6, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String s_1 = \"abada\";\n    char c_1 = \"a\";\n    long ans_1 = 6;\n    assert solution.countSubstrings(s_1, c_1) == ans_1;\n    String s_2 = \"zzz\";\n    char c_2 = \"z\";\n    long ans_2 = 6;\n    assert solution.countSubstrings(s_2, c_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string s_1 = \"abada\";\n    char c_1 = 'a';\n    long long ans_1 = 6;\n    assert(my_solution_1.countSubstrings(s_1, c_1) == ans_1);\n    Solution my_solution_2;\n    string s_2 = \"zzz\";\n    char c_2 = 'z';\n    long long ans_2 = 6;\n    assert(my_solution_2.countSubstrings(s_2, c_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "s",
                "c"
            ],
            "java": [
                "s",
                "c"
            ],
            "cpp": [
                "s",
                "c"
            ],
            "go": [],
            "js": []
        }
    },
    "3085": {
        "description": "给你一个字符串 word 和一个整数 k。\n如果 |freq(word[i]) - freq(word[j])| <= k 对于字符串中所有下标 i 和 j  都成立，则认为 word 是 k 特殊字符串。\n此处，freq(x) 表示字符 x 在 word 中的出现频率，而 |y| 表示 y 的绝对值。\n返回使 word 成为 k 特殊字符串 需要删除的字符的最小数量。",
        "difficulty_level": "Middle",
        "note": "1 <= word.length <= 10^5\n0 <= k <= 10^5\nword 仅由小写英文字母组成。",
        "codes": {
            "python": "class Solution:\n    def minimumDeletions(self, word: str, k: int) -> int:\n        cnt = sorted(Counter(word).values())\n        max_save = max(sum(min(c, base + k) for c in cnt[i:])\n                       for i, base in enumerate(cnt))\n        return len(word) - max_save\n",
            "java": "class Solution {\n    public int minimumDeletions(String word, int k) {\n        int[] cnt = new int[26];\n        for (char c : word.toCharArray()) {\n            cnt[c - 'a']++;\n        }\n        Arrays.sort(cnt);\n\n        int maxSave = 0;\n        for (int i = 0; i < 26; i++) {\n            int sum = 0;\n            for (int j = i; j < 26; j++) {\n                sum += Math.min(cnt[j], cnt[i] + k); // 至多保留 cnt[i]+k 个\n            }\n            maxSave = Math.max(maxSave, sum);\n        }\n        return word.length() - maxSave;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumDeletions(string word, int k) {\n        int cnt[26]{};\n        for (char c: word) {\n            cnt[c - 'a']++;\n        }\n        ranges::sort(cnt);\n\n        int max_save = 0;\n        for (int i = 0; i < 26; i++) {\n            int sum = 0;\n            for (int j = i; j < 26; j++) {\n                sum += min(cnt[j], cnt[i] + k); // 至多保留 cnt[i]+k 个\n            }\n            max_save = max(max_save, sum);\n        }\n        return word.length() - max_save;\n    }\n};\n",
            "go": "func minimumDeletions(word string, k int) int {\ncnt := make([]int, 26)\nfor _, b := range word {\ncnt[b-'a']++\n}\nslices.Sort(cnt)\n\nmaxSave := 0\nfor i, base := range cnt {\nsum := 0\nfor _, c := range cnt[i:] {\nsum += min(c, base+k) // 至多保留 base+k 个\n}\nmaxSave = max(maxSave, sum)\n}\nreturn len(word) - maxSave\n}\n",
            "js": "/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar minimumDeletions = function(word, k) {\n    let freq = new Map();\n    for (let char of word) {\n        freq.set(char, (freq.get(char) || 0) + 1);\n    }\n    console.log(freq);\n    let res=0;\n    for(const [key,value] of freq){\n        const maxValue = value+k,minValue = value-k;\n        let curMaxCover1 = 0,curMaxCover2 = 0;\n        for(let [key,value2] of freq){\n            if(value2>=value && value2<=maxValue){\n                curMaxCover1 += value2;\n            }else if(value2>maxValue){\n                curMaxCover1 += maxValue;\n            }\n            if(value2<=value && value2>=minValue){\n                curMaxCover2 += value2;\n            }else if(value2>value){\n                curMaxCover2 += value;\n            }\n        }\n        res = Math.max(res,curMaxCover1,curMaxCover2);\n\n    }\n    return word.length - res;\n};\n"
        },
        "cases": [
            {
                "input": "[\"\\\"aabcaba\\\"\",\"0\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"\\\"dabdcbdcdcd\\\"\",\"2\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"\\\"aaabaaa\\\"\",\"2\"]",
                "output": "[\"1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumDeletions(String word, int k) {",
            "cpp": "class Solution {\npublic:\n    int minimumDeletions(string word, int k) {",
            "go": "func minimumDeletions(word string, k int) int {\n\n}",
            "js": "/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar minimumDeletions = function(word, k) {",
            "python": "class Solution:\n    def minimumDeletions(self, word: str, k: int) -> int:"
        },
        "time": "20240317",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumDeletions",
            "java": "minimumDeletions",
            "cpp": "minimumDeletions",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumDeletions(\"aabcaba\", 0) == 3, \"Test 1 Error!\"\nassert my_solution.minimumDeletions(\"dabdcbdcdcd\", 2) == 2, \"Test 2 Error!\"\nassert my_solution.minimumDeletions(\"aaabaaa\", 2) == 1, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String word_1 = \"aabcaba\";\n    int k_1 = 0;\n    int ans_1 = 3;\n    assert solution.minimumDeletions(word_1, k_1) == ans_1;\n    String word_2 = \"dabdcbdcdcd\";\n    int k_2 = 2;\n    int ans_2 = 2;\n    assert solution.minimumDeletions(word_2, k_2) == ans_2;\n    String word_3 = \"aaabaaa\";\n    int k_3 = 2;\n    int ans_3 = 1;\n    assert solution.minimumDeletions(word_3, k_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string word_1 = \"aabcaba\";\n    int k_1 = 0;\n    int ans_1 = 3;\n    assert(my_solution_1.minimumDeletions(word_1, k_1) == ans_1);\n    Solution my_solution_2;\n    string word_2 = \"dabdcbdcdcd\";\n    int k_2 = 2;\n    int ans_2 = 2;\n    assert(my_solution_2.minimumDeletions(word_2, k_2) == ans_2);\n    Solution my_solution_3;\n    string word_3 = \"aaabaaa\";\n    int k_3 = 2;\n    int ans_3 = 1;\n    assert(my_solution_3.minimumDeletions(word_3, k_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "word",
                "k"
            ],
            "java": [
                "word",
                "k"
            ],
            "cpp": [
                "word",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3086": {
        "description": "给你一个下标从 0 开始的二进制数组 nums，其长度为 n ；另给你一个 正整数 k 以及一个 非负整数 maxChanges 。\nAlice 在玩一个游戏，游戏的目标是让 Alice 使用 最少 数量的 行动 次数从 nums 中拾起 k 个 1 。游戏开始时，Alice 可以选择数组 [0, n - 1] 范围内的任何索引 aliceIndex 站立。如果 nums[aliceIndex] == 1 ，Alice 会拾起一个 1 ，并且 nums[aliceIndex] 变成0（这 不算 作一次行动）。之后，Alice 可以执行 任意数量 的 行动（包括零次），在每次行动中 Alice 必须 恰好 执行以下动作之一：\n选择任意一个下标 j != aliceIndex 且满足 nums[j] == 0 ，然后将 nums[j] 设置为 1 。这个动作最多可以执行 maxChanges 次。\n选择任意两个相邻的下标 x 和 y（|x - y| == 1）且满足 nums[x] == 1, nums[y] == 0 ，然后交换它们的值（将 nums[y] = 1 和 nums[x] = 0）。如果 y == aliceIndex，在这次行动后 Alice 拾起一个 1 ，并且 nums[y] 变成 0 。\n返回 Alice 拾起 恰好 k 个 1 所需的 最少 行动次数。",
        "difficulty_level": "Hard",
        "note": "2 <= n <= 10^5\n0 <= nums[i] <= 1\n1 <= k <= 10^5\n0 <= maxChanges <= 10^5\nmaxChanges + sum(nums) >= k",
        "codes": {
            "python": "class Solution:\n    def minimumMoves(self, nums: List[int], k: int, maxChanges: int) -> int:\n        n = len(nums)\n        def f(i: int) -> int:\n            return sum(nums[max(i - 1, 0):min(i + 2, n)])\n\n        indexSum, count = [0] * (n + 1), [0] * (n + 1)\n        for i in range(n):\n            indexSum[i + 1], count[i + 1] = indexSum[i] + nums[i] * i, count[i] + nums[i]\n        res = inf\n        for i in range(n):\n            if f(i) + maxChanges >= k:\n                if k <= f(i):\n                    res = min(res, k - nums[i])\n                else:\n                    res = min(res, 2 * k - f(i) - nums[i])\n            left, right = 0, n\n            while left <= right:\n                mid = (left + right) // 2\n                i1, i2 = max(i - mid, 0), min(i + mid, n - 1)\n                if count[i2 + 1] - count[i1] >= k - maxChanges:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            i1, i2 = max(i - left, 0), min(i + left, n - 1)\n            if count[i2 + 1] - count[i1] > k - maxChanges:\n                i1 += 1\n            count1, count2 = count[i + 1] - count[i1], count[i2 + 1] - count[i + 1]\n            res = min(res, indexSum[i2 + 1] - indexSum[i + 1] - i * count2 + i * count1 - (indexSum[i + 1] - indexSum[i1]) + 2 * maxChanges)\n        return res\n",
            "java": "class Solution {\n    public long minimumMoves(int[] nums, int k, int maxChanges) {\n        int n = nums.length;\n\n        long[] indexSum = new long[n + 1], sum = new long[n + 1];\n        for (int i = 0; i < n; i++) {\n            indexSum[i + 1] = indexSum[i] + nums[i] * i;\n            sum[i + 1] = sum[i] + nums[i];\n        }\n        long res = Long.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            if (f(i, nums) + maxChanges >= k) {\n                if (k <= f(i, nums)) {\n                    res = Math.min(res, (long)k - nums[i]);\n                } else {\n                    res = Math.min(res, (long)2 * k - f(i, nums) - nums[i]);\n                }\n                continue;\n            }\n            int left = 0, right = n;\n            while (left <= right) {\n                int mid = (left + right) / 2;\n                int i1 = Math.max(i - mid, 0), i2 = Math.min(i + mid, n - 1);\n                if (sum[i2 + 1] - sum[i1] >= k - maxChanges) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            int i1 = Math.max(i - left, 0), i2 = Math.min(i + left, n - 1);\n            if (sum[i2 + 1] - sum[i1] > k - maxChanges) {\n                i1++;\n            }\n            long count1 = sum[i + 1] - sum[i1], count2 = sum[i2 + 1] - sum[i + 1];\n            res = Math.min(res, indexSum[i2 + 1] - indexSum[i + 1] - i * count2 + i * count1 - (indexSum[i + 1] - indexSum[i1]) + 2 * maxChanges);\n        }\n        return res;\n    }\n\n    public int f(int i, int[] nums) {\n        int x = nums[i];\n        if (i - 1 >= 0) {\n            x += nums[i - 1];\n        }\n        if (i + 1 < nums.length) {\n            x += nums[i + 1];\n        }\n        return x;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long minimumMoves(vector<int>& nums, int k, int maxChanges) {\n        int n = nums.size();\n        auto f = [&](int i) -> int {\n            int x = nums[i];\n            if (i - 1 >= 0) {\n                x += nums[i - 1];\n            }\n            if (i + 1 < n) {\n                x += nums[i + 1];\n            }\n            return x;\n        };\n\n        vector<long long> indexSum(n + 1), sum(n + 1);\n        for (int i = 0; i < n; i++) {\n            indexSum[i + 1] = indexSum[i] + nums[i] * i;\n            sum[i + 1] = sum[i] + nums[i];\n        }\n        long long res = LONG_LONG_MAX;\n        for (int i = 0; i < n; i++) {\n            if (f(i) + maxChanges >= k) {\n                if (k <= f(i)) {\n                    res = min(res, (long long)k - nums[i]);\n                } else {\n                    res = min(res, (long long)2 * k - f(i) - nums[i]);\n                }\n                continue;\n            }\n            int left = 0, right = n;\n            while (left <= right) {\n                int mid = (left + right) / 2;\n                int i1 = max(i - mid, 0), i2 = min(i + mid, n - 1);\n                if (sum[i2 + 1] - sum[i1] >= k - maxChanges) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            int i1 = max(i - left, 0), i2 = min(i + left, n - 1);\n            if (sum[i2 + 1] - sum[i1] > k - maxChanges) {\n                i1++;\n            }\n            long long count1 = sum[i + 1] - sum[i1], count2 = sum[i2 + 1] - sum[i + 1];\n            res = min(res, indexSum[i2 + 1] - indexSum[i + 1] - i * count2 + i * count1 - (indexSum[i + 1] - indexSum[i1]) + 2 * maxChanges);\n        }\n        return res;\n    }\n};\n",
            "go": "func minimumMoves(nums []int, k int, maxChanges int) int64 {\n    n := len(nums)\n    f := func(i int) int {\n        x := nums[i]\n        if i - 1 >= 0 {\n            x += nums[i - 1]\n        }\n        if i + 1 < n {\n            x += nums[i + 1]\n        }\n        return x\n    }\n\n    indexSum, sum := make([]int64, n + 1), make([]int64, n + 1)\n    for i := 0; i < n; i++ {\n        indexSum[i + 1] = indexSum[i] + int64(nums[i]) * int64(i)\n        sum[i + 1] = sum[i] + int64(nums[i])\n    }\n    var res int64 = math.MaxInt64\n    for i := 0; i < n; i++ {\n        if f(i) + maxChanges >= k {\n            if k <= f(i) {\n                res = min(res, int64(k - nums[i]))\n            } else {\n                res = min(res, int64(2 * k - f(i) - nums[i]))\n            }\n            continue\n        }\n        left, right := 0, n\n        for left <= right {\n            mid := (left + right) / 2\n            i1, i2 := max(i - mid, 0), min(i + mid, n - 1)\n            if sum[i2 + 1] - sum[i1] >= int64(k - maxChanges) {\n                right = mid - 1\n            } else {\n                left = mid + 1\n            }\n        }\n        i1, i2 := max(i - left, 0), min(i + left, n - 1)\n        if sum[i2 + 1] - sum[i1] > int64(k - maxChanges) {\n            i1++\n        }\n        count1, count2 := sum[i + 1] - sum[i1], sum[i2 + 1] - sum[i + 1]\n        res = min(res, indexSum[i2 + 1] - indexSum[i + 1] - int64(i) * count2 + int64(i) * count1 - (indexSum[i + 1] - indexSum[i1]) + 2 * int64(maxChanges))\n    }\n    return res\n}\n",
            "js": "var f = function(i, nums) {\n    let x = nums[i];\n    if (i - 1 >= 0) {\n        x += nums[i - 1];\n    }\n    if (i + 1 < nums.length) {\n        x += nums[i + 1];\n    }\n    return x;\n};\n\nvar minimumMoves = function(nums, k, maxChanges) {\n    let n = nums.length;\n\n    let indexSum = new Array(n + 1).fill(0), sum = new Array(n + 1).fill(0);\n    for (let i = 0; i < n; i++) {\n        indexSum[i + 1] = indexSum[i] + nums[i] * i;\n        sum[i + 1] = sum[i] + nums[i];\n    }\n    let res = Infinity;\n    for (let i = 0; i < n; i++) {\n        if (f(i, nums) + maxChanges >= k) {\n            if (k <= f(i, nums)) {\n                res = Math.min(res, k - nums[i]);\n            } else {\n                res = Math.min(res, 2 * k - f(i, nums) - nums[i]);\n            }\n            continue;\n        }\n        let left = 0, right = n;\n        while (left <= right) {\n            let mid = Math.floor((left + right) / 2);\n            let i1 = Math.max(i - mid, 0), i2 = Math.min(i + mid, n - 1);\n            if (sum[i2 + 1] - sum[i1] >= k - maxChanges) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        let i1 = Math.max(i - left, 0), i2 = Math.min(i + left, n - 1);\n        if (sum[i2 + 1] - sum[i1] > k - maxChanges) {\n            i1++;\n        }\n        let count1 = sum[i + 1] - sum[i1], count2 = sum[i2 + 1] - sum[i + 1];\n        res = Math.min(res, indexSum[i2 + 1] - indexSum[i + 1] - i * count2 + i * count1 - (indexSum[i + 1] - indexSum[i1]) + 2 * maxChanges);\n    }\n    return res;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,1,0,0,0,1,1,0,0,1]\",\"3\",\"1\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[0,0,0,0]\",\"2\",\"3\"]",
                "output": "[\"4\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long minimumMoves(int[] nums, int k, int maxChanges) {",
            "cpp": "class Solution {\npublic:\n    long long minimumMoves(vector<int>& nums, int k, int maxChanges) {",
            "go": "func minimumMoves(nums []int, k int, maxChanges int) int64 {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number} maxChanges\n * @return {number}\n */\nvar minimumMoves = function(nums, k, maxChanges) {",
            "python": "class Solution:\n    def minimumMoves(self, nums: List[int], k: int, maxChanges: int) -> int:"
        },
        "time": "20240317",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumMoves",
            "java": "minimumMoves",
            "cpp": "minimumMoves",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumMoves([1,1,0,0,0,1,1,0,0,1], 3, 1) == 3, \"Test 1 Error!\"\nassert my_solution.minimumMoves([0,0,0,0], 2, 3) == 4, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,1,0,0,0,1,1,0,0,1};\n    int k_1 = 3;\n    int maxChanges_1 = 1;\n    long ans_1 = 3;\n    assert solution.minimumMoves(nums_1, k_1, maxChanges_1) == ans_1;\n    int[] nums_2 = {0,0,0,0};\n    int k_2 = 2;\n    int maxChanges_2 = 3;\n    long ans_2 = 4;\n    assert solution.minimumMoves(nums_2, k_2, maxChanges_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,1,0,0,0,1,1,0,0,1};\n    int k_1 = 3;\n    int maxChanges_1 = 1;\n    long long ans_1 = 3;\n    assert(my_solution_1.minimumMoves(nums_1, k_1, maxChanges_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {0,0,0,0};\n    int k_2 = 2;\n    int maxChanges_2 = 3;\n    long long ans_2 = 4;\n    assert(my_solution_2.minimumMoves(nums_2, k_2, maxChanges_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "k",
                "maxChanges"
            ],
            "java": [
                "nums",
                "k",
                "maxChanges"
            ],
            "cpp": [
                "nums",
                "k",
                "maxChanges"
            ],
            "go": [],
            "js": []
        }
    },
    "3090": {
        "description": "给你一个字符串 s ，请找出满足每个字符最多出现两次的最长子字符串，并返回该\n子字符串\n的 最大 长度。",
        "difficulty_level": "Easy",
        "note": "2 <= s.length <= 100\ns 仅由小写英文字母组成。",
        "codes": {
            "python": "class Solution:\n    def maximumLengthSubstring(self, s: str) -> int:\n        ans = left = 0\n        cnt = Counter()\n        for i, c in enumerate(s):\n            cnt[c] += 1\n            while cnt[c] > 2:\n                cnt[s[left]] -= 1\n                left += 1\n            ans = max(ans, i - left + 1)\n        return ans\n",
            "java": "class Solution {\n    public int maximumLengthSubstring(String S) {\n        char[] s = S.toCharArray();\n        int ans = 0;\n        int left = 0;\n        int[] cnt = new int[26];\n        for (int i = 0; i < s.length; i++) {\n            int b = s[i] - 'a';\n            cnt[b]++;\n            while (cnt[b] > 2) {\n                cnt[s[left++] - 'a']--;\n            }\n            ans = Math.max(ans, i - left + 1);\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int maximumLengthSubstring(string s) {\n        int ans = 0, left = 0, cnt[26]{};\n        for (int i = 0; i < s.length(); i++) {\n            int b = s[i] - 'a';\n            cnt[b]++;\n            while (cnt[b] > 2) {\n                cnt[s[left++] - 'a']--;\n            }\n            ans = max(ans, i - left + 1);\n        }\n        return ans;\n    }\n};\n",
            "go": "func maximumLengthSubstring(s string) (ans int) {\ncnt := [26]int{}\nleft := 0\nfor i, b := range s {\nb -= 'a'\ncnt[b]++\nfor cnt[b] > 2 {\ncnt[s[left]-'a']--\nleft++\n}\nans = max(ans, i-left+1)\n}\nreturn\n}\n",
            "js": "/**\n * @param {string} s\n * @return {number}\n */\nvar maximumLengthSubstring = function(s) {\nlet len = s.length;\n  let result = [];\n  let max = 0;\n  let i = 0;\n  let j = 0;\n  while (i < len && j < len && i <= j) {\n    result.push(s[j]);\n    if (result.filter((item) => item === s[j]).length < 3) {\n      j++;\n      max = Math.max(max, result.length);\n    } else {\n      max = Math.max(max, result.length - 1);\n      i = i + 1;\n      j = i;\n      result = [];\n    }\n  }\n  console.log(max, result);\n  return max;\n};\n"
        },
        "cases": [
            {
                "input": "[\"\\\"bcbbbcba\\\"\"]",
                "output": "[\"4\"]"
            },
            {
                "input": "[\"\\\"aaaa\\\"\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maximumLengthSubstring(String s) {",
            "cpp": "class Solution {\npublic:\n    int maximumLengthSubstring(string s) {",
            "go": "func maximumLengthSubstring(s string) int {\n\n}",
            "js": "/**\n * @param {string} s\n * @return {number}\n */\nvar maximumLengthSubstring = function(s) {",
            "python": "class Solution:\n    def maximumLengthSubstring(self, s: str) -> int:"
        },
        "time": "20240324",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maximumLengthSubstring",
            "java": "maximumLengthSubstring",
            "cpp": "maximumLengthSubstring",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maximumLengthSubstring(\"bcbbbcba\") == 4, \"Test 1 Error!\"\nassert my_solution.maximumLengthSubstring(\"aaaa\") == 2, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String s_1 = \"bcbbbcba\";\n    int ans_1 = 4;\n    assert solution.maximumLengthSubstring(s_1) == ans_1;\n    String s_2 = \"aaaa\";\n    int ans_2 = 2;\n    assert solution.maximumLengthSubstring(s_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string s_1 = \"bcbbbcba\";\n    int ans_1 = 4;\n    assert(my_solution_1.maximumLengthSubstring(s_1) == ans_1);\n    Solution my_solution_2;\n    string s_2 = \"aaaa\";\n    int ans_2 = 2;\n    assert(my_solution_2.maximumLengthSubstring(s_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "s"
            ],
            "java": [
                "s"
            ],
            "cpp": [
                "s"
            ],
            "go": [],
            "js": []
        }
    },
    "3091": {
        "description": "给你一个正整数 k 。最初，你有一个数组 nums = [1] 。\n你可以对数组执行以下 任意 操作 任意 次数（可能为零）：\n选择数组中的任何一个元素，然后将它的值 增加 1 。\n复制数组中的任何一个元素，然后将它附加到数组的末尾。\n返回使得最终数组元素之 和 大于或等于 k 所需的 最少 操作次数。",
        "difficulty_level": "Middle",
        "note": "1 <= k <= 105",
        "codes": {
            "python": "class Solution:\n    def minOperations(self, k: int) -> int:\n        return min(m - 1 + (k - 1) // m for m in range(1, k + 1))\n",
            "java": "class Solution {\n    public int minOperations(int k) {\n        int ans = Integer.MAX_VALUE;\n        for (int m = 1; m <= k; m++) {\n            ans = Math.min(ans, m - 1 + (k - 1) / m);\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minOperations(int k) {\n        int ans = INT_MAX;\n        for (int m = 1; m <= k; m++) {\n            ans = min(ans, m - 1 + (k - 1) / m);\n        }\n        return ans;\n    }\n};\n",
            "go": "func minOperations(k int) int {\nans := math.MaxInt\nfor m := 1; m <= k; m++ {\nans = min(ans, m-1+(k-1)/m)\n}\nreturn ans\n}\n",
            "js": "/**\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(k) {\n  if (k === 1) return 0\n  // (1 + n ) * m > k 求 n + m 最小值\n  let num = 1\n  let res = Infinity\n\n  for (let i = 1; i < k; i++) {\n    let m = Math.ceil((k - (num + i)) / (num + i))\n    if (res >= m + i) {\n      res = m + i\n    } else {\n      return res\n    }\n  }\n\n  return res\n};\n"
        },
        "cases": [
            {
                "input": "[\"11\"]",
                "output": "[\"5\"]"
            },
            {
                "input": "[\"1\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minOperations(int k) {",
            "cpp": "class Solution {\npublic:\n    int minOperations(int k) {",
            "go": "func minOperations(k int) int {\n\n}",
            "js": "/**\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(k) {",
            "python": "class Solution:\n    def minOperations(self, k: int) -> int:"
        },
        "time": "20240324",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minOperations",
            "java": "minOperations",
            "cpp": "minOperations",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minOperations(11) == 5, \"Test 1 Error!\"\nassert my_solution.minOperations(1) == 0, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int k_1 = 11;\n    int ans_1 = 5;\n    assert solution.minOperations(k_1) == ans_1;\n    int k_2 = 1;\n    int ans_2 = 0;\n    assert solution.minOperations(k_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int k_1 = 11;\n    int ans_1 = 5;\n    assert(my_solution_1.minOperations(k_1) == ans_1);\n    Solution my_solution_2;\n    int k_2 = 1;\n    int ans_2 = 0;\n    assert(my_solution_2.minOperations(k_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "k"
            ],
            "java": [
                "k"
            ],
            "cpp": [
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3092": {
        "description": "你需要在一个集合里动态记录 ID 的出现频率。给你两个长度都为 n 的整数数组 nums 和 freq ，nums 中每一个元素表示一个 ID ，对应的 freq 中的元素表示这个 ID 在集合中此次操作后需要增加或者减少的数目。\n增加 ID 的数目：如果 freq[i] 是正数，那么 freq[i] 个 ID 为 nums[i] 的元素在第 i 步操作后会添加到集合中。\n减少 ID 的数目：如果 freq[i] 是负数，那么 -freq[i] 个 ID 为 nums[i] 的元素在第 i 步操作后会从集合中删除。\n请你返回一个长度为 n 的数组 ans ，其中 ans[i] 表示第 i 步操作后出现频率最高的 ID 数目 ，如果在某次操作后集合为空，那么 ans[i] 为 0 。",
        "difficulty_level": "Middle",
        "note": "1 <= nums.length == freq.length <= 10^5\n1 <= nums[i] <= 10^5\n-10^5 <= freq[i] <= 10^5\nfreq[i] != 0\n输入保证任何操作后，集合中的元素出现次数不会为负数。",
        "codes": {
            "python": "from sortedcontainers import SortedList\n\nclass Solution:\n    def mostFrequentIDs(self, nums: List[int], freq: List[int]) -> List[int]:\n        cnt = Counter()\n        sl = SortedList()\n        ans = []\n        for x, f in zip(nums, freq):\n            sl.discard(cnt[x])  # 多个 cnt[x] 只会移除一个\n            cnt[x] += f\n            sl.add(cnt[x])\n            ans.append(sl[-1])\n        return ans\n",
            "java": "class Solution {\n    public long[] mostFrequentIDs(int[] nums, int[] freq) {\n        Map<Integer, Long> cnt = new HashMap<>();\n        TreeMap<Long, Integer> m = new TreeMap<>();\n        int n = nums.length;\n        long[] ans = new long[n];\n        for (int i = 0; i < n; i++) {\n            int x = nums[i];\n            if (cnt.containsKey(x) && m.containsKey(cnt.get(x)) && m.merge(cnt.get(x), -1, Integer::sum) == 0) { // --m[cnt[x]] == 0\n                m.remove(cnt.get(x));\n            }\n            long c = cnt.merge(x, (long) freq[i], Long::sum); // cnt[x] += freq[i]\n            m.merge(c, 1, Integer::sum); // ++m[cnt[x]]\n            ans[i] = m.lastKey();\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    vector<long long> mostFrequentIDs(vector<int> &nums, vector<int> &freq) {\n        unordered_map<int, long long> cnt;\n        multiset<long long> m;\n        int n = nums.size();\n        vector<long long> ans(n);\n        for (int i = 0; i < n; i++) {\n            int x = nums[i];\n            auto it = m.find(cnt[x]);\n            if (it != m.end()) {\n                m.erase(it);\n            }\n            cnt[x] += freq[i];\n            m.insert(cnt[x]);\n            ans[i] = *m.rbegin();\n        }\n        return ans;\n    }\n};\n",
            "go": "func mostFrequentIDs(nums, freq []int) []int64 {\nans := make([]int64, len(nums))\ncnt := make(map[int]int)\nh := hp{}\nheap.Init(&h)\nfor i, x := range nums {\ncnt[x] += freq[i]\nheap.Push(&h, pair{cnt[x], x})\nfor h[0].c != cnt[h[0].x] { // 堆顶保存的数据已经发生变化\nheap.Pop(&h) // 删除\n}\nans[i] = int64(h[0].c)\n}\nreturn ans\n}\n\ntype pair struct{ c, x int }\ntype hp []pair\nfunc (h hp) Len() int           { return len(h) }\nfunc (h hp) Less(i, j int) bool { return h[i].c > h[j].c } // 最大堆\nfunc (h hp) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\nfunc (h *hp) Push(v any)        { *h = append(*h, v.(pair)) }\nfunc (h *hp) Pop() any          { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }\n",
            "js": "/**\n * @param {number[]} nums\n * @param {number[]} freq\n * @return {number[]}\n */\nvar mostFrequentIDs = function(nums, freq) {\n  let list = new Array(10 ** 5+1).fill(0)\n  let maxPQ = new MaxPriorityQueue({\n    priority: item => item.count,\n  })\n  return nums.map((item, idx) => {\n    list[item] += freq[idx]\n    const obj = {\n      count: list[item],\n      key: item,\n    }\n    maxPQ.enqueue(obj)\n    let o = maxPQ.front().element\n    while (o.count !== list[o.key]) {\n      maxPQ.dequeue()\n      o = maxPQ.front().element\n    }\n    return o.count\n  })\n}\n"
        },
        "cases": [
            {
                "input": "[\"[2,3,2,1]\",\"[3,2,-3,1]\"]",
                "output": "[\"[3,3,2,2]\"]"
            },
            {
                "input": "[\"[5,5,3]\",\"[2,-2,1]\"]",
                "output": "[\"[2,0,1]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long[] mostFrequentIDs(int[] nums, int[] freq) {",
            "cpp": "class Solution {\npublic:\n    vector<long long> mostFrequentIDs(vector<int>& nums, vector<int>& freq) {",
            "go": "func mostFrequentIDs(nums []int, freq []int) []int64 {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number[]} freq\n * @return {number[]}\n */\nvar mostFrequentIDs = function(nums, freq) {",
            "python": "class Solution:\n    def mostFrequentIDs(self, nums: List[int], freq: List[int]) -> List[int]:"
        },
        "time": "20240324",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "mostFrequentIDs",
            "java": "mostFrequentIDs",
            "cpp": "mostFrequentIDs",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.mostFrequentIDs([2,3,2,1], [3,2,-3,1]) == [3,3,2,2], \"Test 1 Error!\"\nassert my_solution.mostFrequentIDs([5,5,3], [2,-2,1]) == [2,0,1], \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {2,3,2,1};\n    int[] freq_1 = {3,2,-3,1};\n    long[] ans_1 = {3,3,2,2};\n    assert Arrays.equals(solution.mostFrequentIDs(nums_1, freq_1), ans_1);\n    int[] nums_2 = {5,5,3};\n    int[] freq_2 = {2,-2,1};\n    long[] ans_2 = {2,0,1};\n    assert Arrays.equals(solution.mostFrequentIDs(nums_2, freq_2), ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {2,3,2,1};\n    vector<int> freq_1 = {3,2,-3,1};\n    vector<long long> ans_1 = {3,3,2,2};\n    assert(my_solution_1.mostFrequentIDs(nums_1, freq_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {5,5,3};\n    vector<int> freq_2 = {2,-2,1};\n    vector<long long> ans_2 = {2,0,1};\n    assert(my_solution_2.mostFrequentIDs(nums_2, freq_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "freq"
            ],
            "java": [
                "nums",
                "freq"
            ],
            "cpp": [
                "nums",
                "freq"
            ],
            "go": [],
            "js": []
        }
    },
    "3093": {
        "description": "给你两个字符串数组 wordsContainer 和 wordsQuery 。\n对于每个 wordsQuery[i] ，你需要从 wordsContainer 中找到一个与 wordsQuery[i] 有 最长公共后缀 的字符串。如果 wordsContainer 中有两个或者更多字符串有最长公共后缀，那么答案为长度 最短 的。如果有超过两个字符串有 相同 最短长度，那么答案为它们在 wordsContainer 中出现 更早 的一个。\n请你返回一个整数数组 ans ，其中 ans[i]是 wordsContainer中与 wordsQuery[i] 有 最长公共后缀 字符串的下标。",
        "difficulty_level": "Hard",
        "note": "1 <= wordsContainer.length, wordsQuery.length <= 10^4\n1 <= wordsContainer[i].length <= 5 * 10^3\n1 <= wordsQuery[i].length <= 5 * 10^3\nwordsContainer[i] 只包含小写英文字母。\nwordsQuery[i] 只包含小写英文字母。\nwordsContainer[i].length 的和至多为 5 * 10^5 。\nwordsQuery[i].length 的和至多为 5 * 10^5 。",
        "codes": {
            "python": "class Node:\n    __slots__ = 'son', 'min_l', 'i'\n\n    def __init__(self):\n        self.son = [None] * 26\n        self.min_l = inf\n\nclass Solution:\n    def stringIndices(self, wordsContainer: List[str], wordsQuery: List[str]) -> List[int]:\n        ord_a = ord('a')\n        root = Node()\n        for idx, s in enumerate(wordsContainer):\n            l = len(s)\n            cur = root\n            if l < cur.min_l:\n                cur.min_l, cur.i = l, idx\n            for c in map(ord, reversed(s)):\n                c -= ord_a\n                if cur.son[c] is None:\n                    cur.son[c] = Node()\n                cur = cur.son[c]\n                if l < cur.min_l:\n                    cur.min_l, cur.i = l, idx\n\n        ans = []\n        for s in wordsQuery:\n            cur = root\n            for c in map(ord, reversed(s)):\n                c -= ord_a\n                if cur.son[c] is None:\n                    break\n                cur = cur.son[c]\n            ans.append(cur.i)\n        return ans\n",
            "java": "class Node {\n    Node[] son = new Node[26];\n    int minL = Integer.MAX_VALUE;\n    int i;\n}\n\nclass Solution {\n    public int[] stringIndices(String[] wordsContainer, String[] wordsQuery) {\n        Node root = new Node();\n        for (int idx = 0; idx < wordsContainer.length; ++idx) {\n            char[] s = wordsContainer[idx].toCharArray();\n            int l = s.length;\n            Node cur = root;\n            if (l < cur.minL) {\n                cur.minL = l;\n                cur.i = idx;\n            }\n            for (int i = s.length - 1; i >= 0; i--) {\n                int b = s[i] - 'a';\n                if (cur.son[b] == null) {\n                    cur.son[b] = new Node();\n                }\n                cur = cur.son[b];\n                if (l < cur.minL) {\n                    cur.minL = l;\n                    cur.i = idx;\n                }\n            }\n        }\n\n        int[] ans = new int[wordsQuery.length];\n        for (int idx = 0; idx < wordsQuery.length; idx++) {\n            char[] s = wordsQuery[idx].toCharArray();\n            Node cur = root;\n            for (int i = s.length - 1; i >= 0 && cur.son[s[i] - 'a'] != null; i--) {\n                cur = cur.son[s[i] - 'a'];\n            }\n            ans[idx] = cur.i;\n        }\n        return ans;\n    }\n}\n",
            "cpp": "struct Node {\n    Node *son[26]{};\n    int min_l = INT_MAX, i;\n};\n\nclass Solution {\npublic:\n    vector<int> stringIndices(vector<string> &wordsContainer, vector<string> &wordsQuery) {\n        Node *root = new Node();\n        for (int idx = 0; idx < wordsContainer.size(); ++idx) {\n            auto &s = wordsContainer[idx];\n            int l = s.length();\n            auto cur = root;\n            if (l < cur->min_l) {\n                cur->min_l = l;\n                cur->i = idx;\n            }\n            for (int i = s.length() - 1; i >= 0; i--) {\n                int b = s[i] - 'a';\n                if (cur->son[b] == nullptr) {\n                    cur->son[b] = new Node();\n                }\n                cur = cur->son[b];\n                if (l < cur->min_l) {\n                    cur->min_l = l;\n                    cur->i = idx;\n                }\n            }\n        }\n\n        vector<int> ans;\n        ans.reserve(wordsQuery.size());\n        for (auto &s: wordsQuery) {\n            auto cur = root;\n            for (int i = s.length() - 1; i >= 0 && cur->son[s[i] - 'a']; i--) {\n                cur = cur->son[s[i] - 'a'];\n            }\n            ans.push_back(cur->i);\n        }\n        return ans;\n    }\n};\n",
            "go": "func stringIndices(wordsContainer, wordsQuery []string) []int {\ntype node struct {\nson     [26]*node\nminL, i int\n}\nroot := &node{minL: math.MaxInt}\n\nfor idx, s := range wordsContainer {\nl := len(s)\ncur := root\nif l < cur.minL {\ncur.minL, cur.i = l, idx\n}\nfor i := len(s) - 1; i >= 0; i-- {\nb := s[i] - 'a'\nif cur.son[b] == nil {\ncur.son[b] = &node{minL: math.MaxInt}\n}\ncur = cur.son[b]\nif l < cur.minL {\ncur.minL, cur.i = l, idx\n}\n}\n}\n\nans := make([]int, len(wordsQuery))\nfor idx, s := range wordsQuery {\ncur := root\nfor i := len(s) - 1; i >= 0 && cur.son[s[i]-'a'] != nil; i-- {\ncur = cur.son[s[i]-'a']\n}\nans[idx] = cur.i\n}\nreturn ans\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[\\\"abcd\\\",\\\"bcd\\\",\\\"xbcd\\\"]\",\"[\\\"cd\\\",\\\"bcd\\\",\\\"xyz\\\"]\"]",
                "output": "[\"[1,1,1]\"]"
            },
            {
                "input": "[\"[\\\"abcdefgh\\\",\\\"poiuygh\\\",\\\"ghghgh\\\"]\",\"[\\\"gh\\\",\\\"acbfgh\\\",\\\"acbfegh\\\"]\"]",
                "output": "[\"[2,0,2]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int[] stringIndices(String[] wordsContainer, String[] wordsQuery) {",
            "cpp": "class Solution {\npublic:\n    vector<int> stringIndices(vector<string>& wordsContainer, vector<string>& wordsQuery) {",
            "go": "func stringIndices(wordsContainer []string, wordsQuery []string) []int {\n\n}",
            "js": "/**\n * @param {string[]} wordsContainer\n * @param {string[]} wordsQuery\n * @return {number[]}\n */\nvar stringIndices = function(wordsContainer, wordsQuery) {",
            "python": "class Solution:\n    def stringIndices(self, wordsContainer: List[str], wordsQuery: List[str]) -> List[int]:"
        },
        "time": "20240324",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "stringIndices",
            "java": "stringIndices",
            "cpp": "stringIndices",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.stringIndices([\"abcd\",\"bcd\",\"xbcd\"], [\"cd\",\"bcd\",\"xyz\"]) == [1,1,1], \"Test 1 Error!\"\nassert my_solution.stringIndices([\"abcdefgh\",\"poiuygh\",\"ghghgh\"], [\"gh\",\"acbfgh\",\"acbfegh\"]) == [2,0,2], \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String[] wordsContainer_1 = {\"abcd\",\"bcd\",\"xbcd\"};\n    String[] wordsQuery_1 = {\"cd\",\"bcd\",\"xyz\"};\n    int[] ans_1 = {1,1,1};\n    assert Arrays.equals(solution.stringIndices(wordsContainer_1, wordsQuery_1), ans_1);\n    String[] wordsContainer_2 = {\"abcdefgh\",\"poiuygh\",\"ghghgh\"};\n    String[] wordsQuery_2 = {\"gh\",\"acbfgh\",\"acbfegh\"};\n    int[] ans_2 = {2,0,2};\n    assert Arrays.equals(solution.stringIndices(wordsContainer_2, wordsQuery_2), ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<string> wordsContainer_1 = {\"abcd\",\"bcd\",\"xbcd\"};\n    vector<string> wordsQuery_1 = {\"cd\",\"bcd\",\"xyz\"};\n    vector<int> ans_1 = {1,1,1};\n    assert(my_solution_1.stringIndices(wordsContainer_1, wordsQuery_1) == ans_1);\n    Solution my_solution_2;\n    vector<string> wordsContainer_2 = {\"abcdefgh\",\"poiuygh\",\"ghghgh\"};\n    vector<string> wordsQuery_2 = {\"gh\",\"acbfgh\",\"acbfegh\"};\n    vector<int> ans_2 = {2,0,2};\n    assert(my_solution_2.stringIndices(wordsContainer_2, wordsQuery_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "wordsContainer",
                "wordsQuery"
            ],
            "java": [
                "wordsContainer",
                "wordsQuery"
            ],
            "cpp": [
                "wordsContainer",
                "wordsQuery"
            ],
            "go": [],
            "js": []
        }
    },
    "3099": {
        "description": "如果一个整数能够被其各个数位上的数字之和整除，则称之为 哈沙德数（Harshad number）。给你一个整数 x 。如果 x 是 哈沙德数 ，则返回 x 各个数位上的数字之和，否则，返回 -1 。",
        "difficulty_level": "Easy",
        "note": "1 <= x <= 100",
        "codes": {
            "python": "class Solution:\n    def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:\n        s = 0\n        y = x\n        while y:\n            y, r = divmod(y, 10)\n            s += r\n        return -1 if x % s else s\n",
            "java": "class Solution {\n    public int sumOfTheDigitsOfHarshadNumber(int x) {\n        int s = 0;\n        for (int y = x; y != 0; y /= 10) {\n            s += y % 10;\n        }\n        return x % s != 0 ? -1 : s;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int sumOfTheDigitsOfHarshadNumber(int x) {\n        int s = 0;\n        for (int y = x; y; y /= 10) {\n            s += y % 10;\n        }\n        return x % s ? -1 : s;\n    }\n};\n",
            "go": "func sumOfTheDigitsOfHarshadNumber(x int) int {\n    s := 0\n    for y := x; y != 0; y /= 10 {\n        s += y % 10\n    }\n\n    if x % s != 0 {\n        return -1\n    }\n    return s\n}\n",
            "js": "var sumOfTheDigitsOfHarshadNumber = function(x) {\n    let s = 0;\n    for (let y = x; y != 0; y = Math.floor(y / 10)) {\n        s += y % 10;\n    }\n    return x % s ? -1 : s;\n};\n"
        },
        "cases": [
            {
                "input": "[\"18\"]",
                "output": "[\"9\"]"
            },
            {
                "input": "[\"23\"]",
                "output": "[\"-1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int sumOfTheDigitsOfHarshadNumber(int x) {",
            "cpp": "class Solution {\npublic:\n    int sumOfTheDigitsOfHarshadNumber(int x) {",
            "go": "func sumOfTheDigitsOfHarshadNumber(x int) int {\n\n}",
            "js": "/**\n * @param {number} x\n * @return {number}\n */\nvar sumOfTheDigitsOfHarshadNumber = function(x) {",
            "python": "class Solution:\n    def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:"
        },
        "time": "20240331",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "sumOfTheDigitsOfHarshadNumber",
            "java": "sumOfTheDigitsOfHarshadNumber",
            "cpp": "sumOfTheDigitsOfHarshadNumber",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.sumOfTheDigitsOfHarshadNumber(18) == 9, \"Test 1 Error!\"\nassert my_solution.sumOfTheDigitsOfHarshadNumber(23) == -1, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int x_1 = 18;\n    int ans_1 = 9;\n    assert solution.sumOfTheDigitsOfHarshadNumber(x_1) == ans_1;\n    int x_2 = 23;\n    int ans_2 = -1;\n    assert solution.sumOfTheDigitsOfHarshadNumber(x_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int x_1 = 18;\n    int ans_1 = 9;\n    assert(my_solution_1.sumOfTheDigitsOfHarshadNumber(x_1) == ans_1);\n    Solution my_solution_2;\n    int x_2 = 23;\n    int ans_2 = -1;\n    assert(my_solution_2.sumOfTheDigitsOfHarshadNumber(x_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "x"
            ],
            "java": [
                "x"
            ],
            "cpp": [
                "x"
            ],
            "go": [],
            "js": []
        }
    },
    "3100": {
        "description": "给你两个整数 numBottles 和 numExchange 。numBottles 代表你最初拥有的满水瓶数量。在一次操作中，你可以执行以下操作之一：\n喝掉任意数量的满水瓶，使它们变成空水瓶。\n用 numExchange 个空水瓶交换一个满水瓶。然后，将 numExchange 的值增加 1 。\n注意，你不能使用相同的 numExchange 值交换多批空水瓶。例如，如果 numBottles == 3 并且 numExchange == 1 ，则不能用 3 个空水瓶交换成 3 个满水瓶。\n返回你 最多 可以喝到多少瓶水。",
        "difficulty_level": "Middle",
        "note": "1 <= numBottles <= 100 \n1 <= numExchange <= 100",
        "codes": {
            "python": "class Solution:\n    def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:\n        ans = numBottles  # 一开始就全部喝完\n        while numBottles >= numExchange:  # 有足够的空瓶\n            ans += 1  # 用 numExchange 个空瓶交换，然后喝掉，产生一个新的空瓶\n            numBottles += 1 - numExchange\n            numExchange += 1\n        return ans\n",
            "java": "class Solution {\n    public int maxBottlesDrunk(int numBottles, int numExchange) {\n        int ans = numBottles; // 一开始就全部喝完\n        while (numBottles >= numExchange) { // 有足够的空瓶\n            ans++; // 用 numExchange 个空瓶交换，然后喝掉，产生一个新的空瓶\n            numBottles += 1 - numExchange++;\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int maxBottlesDrunk(int numBottles, int numExchange) {\n        int ans = numBottles; // 一开始就全部喝完\n        while (numBottles >= numExchange) { // 有足够的空瓶\n            ans++; // 用 numExchange 个空瓶交换，然后喝掉，产生一个新的空瓶\n            numBottles += 1 - numExchange++;\n        }\n        return ans;\n    }\n};\n",
            "go": "func maxBottlesDrunk(numBottles, numExchange int) int {\nans := numBottles // 一开始就全部喝完\nfor numBottles >= numExchange { // 有足够的空瓶\nans++ // 用 numExchange 个空瓶交换，然后喝掉，产生一个新的空瓶\nnumBottles += 1 - numExchange\nnumExchange++\n}\nreturn ans\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"13\",\"6\"]",
                "output": "[\"15\"]"
            },
            {
                "input": "[\"10\",\"3\"]",
                "output": "[\"13\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maxBottlesDrunk(int numBottles, int numExchange) {",
            "cpp": "class Solution {\npublic:\n    int maxBottlesDrunk(int numBottles, int numExchange) {",
            "go": "func maxBottlesDrunk(numBottles int, numExchange int) int {\n\n}",
            "js": "/**\n * @param {number} numBottles\n * @param {number} numExchange\n * @return {number}\n */\nvar maxBottlesDrunk = function(numBottles, numExchange) {",
            "python": "class Solution:\n    def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:"
        },
        "time": "20240331",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maxBottlesDrunk",
            "java": "maxBottlesDrunk",
            "cpp": "maxBottlesDrunk",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maxBottlesDrunk(13, 6) == 15, \"Test 1 Error!\"\nassert my_solution.maxBottlesDrunk(10, 3) == 13, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int numBottles_1 = 13;\n    int numExchange_1 = 6;\n    int ans_1 = 15;\n    assert solution.maxBottlesDrunk(numBottles_1, numExchange_1) == ans_1;\n    int numBottles_2 = 10;\n    int numExchange_2 = 3;\n    int ans_2 = 13;\n    assert solution.maxBottlesDrunk(numBottles_2, numExchange_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int numBottles_1 = 13;\n    int numExchange_1 = 6;\n    int ans_1 = 15;\n    assert(my_solution_1.maxBottlesDrunk(numBottles_1, numExchange_1) == ans_1);\n    Solution my_solution_2;\n    int numBottles_2 = 10;\n    int numExchange_2 = 3;\n    int ans_2 = 13;\n    assert(my_solution_2.maxBottlesDrunk(numBottles_2, numExchange_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "numBottles",
                "numExchange"
            ],
            "java": [
                "numBottles",
                "numExchange"
            ],
            "cpp": [
                "numBottles",
                "numExchange"
            ],
            "go": [],
            "js": []
        }
    },
    "3101": {
        "description": "给你一个二进制数组nums。如果一个子数组中 不存在 两个 相邻 元素的值 相同 的情况，我们称这样的子数组为 交替子数组 。\n返回数组 nums 中交替子数组的数量。",
        "difficulty_level": "Middle",
        "note": "1 <= nums.length <= 10^5\nnums[i] 不是 0 就是 1 。",
        "codes": {
            "python": "class Solution:\n    def countAlternatingSubarrays(self, nums: List[int]) -> int:\n        res = cur = 0\n        pre = -1\n        for a in nums:\n            if pre != a:\n                cur += 1\n            else:\n                cur = 1\n            pre = a\n            res += cur\n        return res\n",
            "java": "class Solution {\n    public long countAlternatingSubarrays(int[] nums) {\n        long res = 0, cur = 0;\n        int pre = -1;\n        for (int a : nums) {\n            cur = (pre != a) ? cur + 1 : 1;\n            pre = a;\n            res += cur;\n        }\n        return res;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long countAlternatingSubarrays(vector<int>& nums) {\n        long long res = 0, cur = 0;\n        int pre = -1;\n        for (int a : nums) {\n            cur = (pre != a) ? cur + 1 : 1;\n            pre = a;\n            res += cur;\n        }\n        return res;\n    }\n};\n",
            "go": "func countAlternatingSubarrays(nums []int) int64 {\n    var res, cur int64\n    pre := -1\n    for _, a := range nums {\n        if pre != a {\n            cur++\n        } else {\n            cur = 1\n        }\n        pre = a\n        res += cur\n    }\n    return res\n}\n",
            "js": "var countAlternatingSubarrays = function(nums) {\n    let res = 0, cur = 0, pre = -1;\n    for (const a of nums) {\n        cur = (pre != a) ? cur + 1 : 1;\n        pre = a;\n        res += cur;\n    }\n    return res;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[0,1,1,1]\"]",
                "output": "[\"5\"]"
            },
            {
                "input": "[\"[1,0,1,0]\"]",
                "output": "[\"10\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long countAlternatingSubarrays(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    long long countAlternatingSubarrays(vector<int>& nums) {",
            "go": "func countAlternatingSubarrays(nums []int) int64 {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar countAlternatingSubarrays = function(nums) {",
            "python": "class Solution:\n    def countAlternatingSubarrays(self, nums: List[int]) -> int:"
        },
        "time": "20240331",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "countAlternatingSubarrays",
            "java": "countAlternatingSubarrays",
            "cpp": "countAlternatingSubarrays",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.countAlternatingSubarrays([0,1,1,1]) == 5, \"Test 1 Error!\"\nassert my_solution.countAlternatingSubarrays([1,0,1,0]) == 10, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {0,1,1,1};\n    long ans_1 = 5;\n    assert solution.countAlternatingSubarrays(nums_1) == ans_1;\n    int[] nums_2 = {1,0,1,0};\n    long ans_2 = 10;\n    assert solution.countAlternatingSubarrays(nums_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {0,1,1,1};\n    long long ans_1 = 5;\n    assert(my_solution_1.countAlternatingSubarrays(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,0,1,0};\n    long long ans_2 = 10;\n    assert(my_solution_2.countAlternatingSubarrays(nums_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3102": {
        "description": "给你一个下标从 0 开始的数组 points ，它表示二维平面上一些点的整数坐标，其中 points[i] = [x_i, y_i] 。\n两点之间的距离定义为它们的曼哈顿距离。\n请你恰好移除一个点，返回移除后任意两点之间的 最大 距离可能的 最小 值。",
        "difficulty_level": "Hard",
        "note": "3 <= points.length <= 10^5\npoints[i].length == 2\n1 <= points[i][0], points[i][1] <= 10^8",
        "codes": {
            "python": "from sortedcontainers import SortedList\n\nclass Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:\n        sx = SortedList(p[0] - p[1] for p in points)\n        sy = SortedList(p[0] + p[1] for p in points)\n        res = float('inf')\n        for p in points:\n            sx.remove(p[0] - p[1])\n            sy.remove(p[0] + p[1])\n            res = min(res, max(sx[-1] - sx[0], sy[-1] - sy[0]))\n            sx.add(p[0] - p[1])\n            sy.add(p[0] + p[1])\n        return res\n",
            "java": "class Solution {\n    public int minimumDistance(int[][] points) {\n        TreeMap<Integer, Integer> sx = new TreeMap<Integer, Integer>();\n        TreeMap<Integer, Integer> sy = new TreeMap<Integer, Integer>();\n        for (int[] p : points) {\n            sx.put(p[0] - p[1], sx.getOrDefault(p[0] - p[1], 0) + 1);\n            sy.put(p[0] + p[1], sy.getOrDefault(p[0] + p[1], 0) + 1);\n        }\n        int res = Integer.MAX_VALUE;\n        for (int[] p : points) {\n            sx.put(p[0] - p[1], sx.get(p[0] - p[1]) - 1);\n            if (sx.get(p[0] - p[1]) == 0) {\n                sx.remove(p[0] - p[1]);\n            }\n            sy.put(p[0] + p[1], sy.get(p[0] + p[1]) - 1);\n            if (sy.get(p[0] + p[1]) == 0) {\n                sy.remove(p[0] + p[1]);\n            }\n            res = Math.min(res, Math.max(sx.lastKey() - sx.firstKey(), sy.lastKey() - sy.firstKey()));\n            sx.put(p[0] - p[1], sx.getOrDefault(p[0] - p[1], 0) + 1);\n            sy.put(p[0] + p[1], sy.getOrDefault(p[0] + p[1], 0) + 1);\n        }\n        return res;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumDistance(vector<vector<int>>& points) {\n        multiset<int> sx, sy;\n        for (auto & p : points) {\n            sx.emplace(p[0] - p[1]);\n            sy.emplace(p[0] + p[1]);\n        }\n        int res = INT_MAX;\n        for (auto &p : points) {\n            sx.erase(sx.find(p[0] - p[1]));\n            sy.erase(sy.find(p[0] + p[1]));\n            res = min(res, max(*sx.rbegin() - *sx.begin(), *sy.rbegin() - *sy.begin()));\n            sx.emplace(p[0] - p[1]);\n            sy.emplace(p[0] + p[1]);\n        }\n        return res;\n    }\n};\n",
            "go": "func minimumDistance(points [][]int) int {\n    sx := redblacktree.New[int, int]()\nsy := redblacktree.New[int, int]()\nfor _, p := range points {\nput(sx, p[0] - p[1])\nput(sy, p[0] + p[1])\n}\nres := math.MaxInt\nfor _, p := range points {\nremove(sx, p[0] - p[1])\nremove(sy, p[0] + p[1])\nres = min(res, max(sx.Right().Key - sx.Left().Key, sy.Right().Key - sy.Left().Key))\nput(sx, p[0] - p[1])\nput(sy, p[0] + p[1])\n}\nreturn res\n}\n\n\nfunc put(t *redblacktree.Tree[int, int], v int) {\nc, _ := t.Get(v)\nt.Put(v, c+1)\n}\n\nfunc remove(t *redblacktree.Tree[int, int], v int) {\nc, _ := t.Get(v)\nif c == 1 {\nt.Remove(v)\n} else {\nt.Put(v, c-1)\n}\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[[3,10],[5,15],[10,2],[4,4]]\"]",
                "output": "[\"12\"]"
            },
            {
                "input": "[\"[[1,1],[1,1],[1,1]]\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumDistance(int[][] points) {",
            "cpp": "class Solution {\npublic:\n    int minimumDistance(vector<vector<int>>& points) {",
            "go": "func minimumDistance(points [][]int) int {\n\n}",
            "js": "/**\n * @param {number[][]} points\n * @return {number}\n */\nvar minimumDistance = function(points) {",
            "python": "class Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:"
        },
        "time": "20240331",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumDistance",
            "java": "minimumDistance",
            "cpp": "minimumDistance",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumDistance([[3,10],[5,15],[10,2],[4,4]]) == 12, \"Test 1 Error!\"\nassert my_solution.minimumDistance([[1,1],[1,1],[1,1]]) == 0, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] points_1 = {{3,10},{5,15},{10,2},{4,4}};\n    int ans_1 = 12;\n    assert solution.minimumDistance(points_1) == ans_1;\n    int[][] points_2 = {{1,1},{1,1},{1,1}};\n    int ans_2 = 0;\n    assert solution.minimumDistance(points_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> points_1 = {{3,10},{5,15},{10,2},{4,4}};\n    int ans_1 = 12;\n    assert(my_solution_1.minimumDistance(points_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> points_2 = {{1,1},{1,1},{1,1}};\n    int ans_2 = 0;\n    assert(my_solution_2.minimumDistance(points_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "points"
            ],
            "java": [
                "points"
            ],
            "cpp": [
                "points"
            ],
            "go": [],
            "js": []
        }
    },
    "3105": {
        "description": "给你一个整数数组 nums 。返回数组 nums 中 严格递增 或 严格递减 的最长非空子数组的长度。",
        "difficulty_level": "Easy",
        "note": "1 <= nums.length <= 50\n1 <= nums[i] <= 50",
        "codes": {
            "python": "class Solution:\n    def longestMonotonicSubarray(self, a: List[int]) -> int:\n        ans = 1\n        i, n = 0, len(a)\n        while i < n - 1:\n            if a[i + 1] == a[i]:\n                i += 1  # 直接跳过\n                continue\n            i0 = i  # 记录这一组的开始位置\n            inc = a[i + 1] > a[i]  # 定下基调：是严格递增还是严格递减\n            i += 2  # i 和 i+1 已经满足要求，从 i+2 开始判断\n            while i < n and a[i] != a[i - 1] and (a[i] > a[i - 1]) == inc:\n                i += 1\n            # 从 i0 到 i-1 是满足题目要求的（并且无法再延长的）子数组\n            ans = max(ans, i - i0)\n            i -= 1\n        return ans\n",
            "java": "class Solution {\n    public int longestMonotonicSubarray(int[] a) {\n        int ans = 1;\n        int i = 0, n = a.length;\n        while (i < n - 1) {\n            if (a[i + 1] == a[i]) {\n                i++; // 直接跳过\n                continue;\n            }\n            int i0 = i; // 记录这一组的开始位置\n            boolean inc = a[i + 1] > a[i]; // 定下基调：是严格递增还是严格递减\n            i += 2; // i 和 i+1 已经满足要求，从 i+2 开始判断\n            while (i < n && a[i] != a[i - 1] && (a[i] > a[i - 1]) == inc) {\n                i++;\n            }\n            // 从 i0 到 i-1 是满足题目要求的（并且无法再延长的）子数组\n            ans = Math.max(ans, i - i0);\n            i--;\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int longestMonotonicSubarray(vector<int> &a) {\n        int ans = 1;\n        int i = 0, n = a.size();\n        while (i < n - 1) {\n            if (a[i + 1] == a[i]) {\n                i++; // 直接跳过\n                continue;\n            }\n            int i0 = i; // 记录这一组的开始位置\n            bool inc = a[i + 1] > a[i]; // 定下基调：是严格递增还是严格递减\n            i += 2; // i 和 i+1 已经满足要求，从 i+2 开始判断\n            while (i < n && a[i] != a[i - 1] && (a[i] > a[i - 1]) == inc) {\n                i++;\n            }\n            // 从 i0 到 i-1 是满足题目要求的（并且无法再延长的）子数组\n            ans = max(ans, i - i0);\n            i--;\n        }\n        return ans;\n    }\n};\n",
            "go": "func longestMonotonicSubarray(a []int) int {\nans := 1\ni, n := 0, len(a)\nfor i < n-1 {\nif a[i+1] == a[i] {\ni++ // 直接跳过\ncontinue\n}\ni0 := i              // 记录这一组的开始位置\ninc := a[i+1] > a[i] // 定下基调：是严格递增还是严格递减\ni += 2               // i 和 i+1 已经满足要求，从 i+2 开始判断\nfor i < n && a[i] != a[i-1] && a[i] > a[i-1] == inc {\ni++\n}\n// 从 i0 到 i-1 是满足题目要求的（并且无法再延长的）子数组\nans = max(ans, i-i0)\ni--\n}\nreturn ans\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestMonotonicSubarray = function(nums) {\n    let ansmin = 1\n    let ansmax = 1\n    let min = 1\n    let max = 1\n    for (let i = 1; i < nums.length; i++) {\n        if(nums[i-1] > nums[i]){\n            min ++\n        }else{\n            min = 1\n        }\n        if(nums[i-1] < nums[i]){\n            max ++\n        }else{\n            max = 1\n        }\n        ansmin = Math.max(min, ansmin)\n        ansmax = Math.max(max, ansmax)\n    }\n    return  Math.max(ansmin, ansmax)\n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,4,3,3,2]\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[3,3,3,3]\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"[3,2,1]\"]",
                "output": "[\"3\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int longestMonotonicSubarray(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    int longestMonotonicSubarray(vector<int>& nums) {",
            "go": "func longestMonotonicSubarray(nums []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestMonotonicSubarray = function(nums) {",
            "python": "class Solution:\n    def longestMonotonicSubarray(self, nums: List[int]) -> int:"
        },
        "time": "20240407",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "longestMonotonicSubarray",
            "java": "longestMonotonicSubarray",
            "cpp": "longestMonotonicSubarray",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.longestMonotonicSubarray([1,4,3,3,2]) == 2, \"Test 1 Error!\"\nassert my_solution.longestMonotonicSubarray([3,3,3,3]) == 1, \"Test 2 Error!\"\nassert my_solution.longestMonotonicSubarray([3,2,1]) == 3, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,4,3,3,2};\n    int ans_1 = 2;\n    assert solution.longestMonotonicSubarray(nums_1) == ans_1;\n    int[] nums_2 = {3,3,3,3};\n    int ans_2 = 1;\n    assert solution.longestMonotonicSubarray(nums_2) == ans_2;\n    int[] nums_3 = {3,2,1};\n    int ans_3 = 3;\n    assert solution.longestMonotonicSubarray(nums_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,4,3,3,2};\n    int ans_1 = 2;\n    assert(my_solution_1.longestMonotonicSubarray(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {3,3,3,3};\n    int ans_2 = 1;\n    assert(my_solution_2.longestMonotonicSubarray(nums_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {3,2,1};\n    int ans_3 = 3;\n    assert(my_solution_3.longestMonotonicSubarray(nums_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3106": {
        "description": "给你一个字符串 s 和一个整数 k 。定义函数 distance(s_1, s_2) ，用于衡量两个长度为 n 的字符串 s_1 和 s_2 之间的距离，即：\n字符 'a' 到 'z' 按 循环 顺序排列，对于区间 [0, n - 1] 中的 i ，计算所有「 s_1[i] 和 s_2[i] 之间 最小距离」的 和 。例如，distance(\\\"ab\\\", \\\"cd\\\") == 4 ，且 distance(\\\"a\\\", \\\"z\\\") == 1 。\n你可以对字符串 s 执行 任意次 操作。在每次操作中，可以将 s 中的一个字母 改变 为 任意 其他小写英文字母。\n返回一个字符串，表示在执行一些操作后你可以得到的 字典序最小 的字符串 t ，且满足 distance(s, t) <= k 。",
        "difficulty_level": "Middle",
        "note": "1 <= s.length <= 100\n0 <= k <= 2000\ns 只包含小写英文字母。",
        "codes": {
            "python": "class Solution:\n    def getSmallestString(self, s: str, k: int) -> str:\n        s = list(s)\n        for i, c in enumerate(map(ord, s)):\n            dis = min(c - ord('a'), ord('z') - c + 1)\n            if dis > k:\n                s[i] = chr(c - k)\n                break\n            s[i] = 'a'\n            k -= dis\n        return ''.join(s)\n",
            "java": "class Solution {\n    public String getSmallestString(String s, int k) {\n        char[] t = s.toCharArray();\n        for (int i = 0; i < t.length; i++) {\n            int dis = Math.min(t[i] - 'a', 'z' - t[i] + 1);\n            if (dis > k) {\n                t[i] -= k;\n                break;\n            }\n            t[i] = 'a';\n            k -= dis;\n        }\n        return new String(t);\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    string getSmallestString(string s, int k) {\n        for (int i = 0; i < s.length(); i++) {\n            int dis = min(s[i] - 'a', 'z' - s[i] + 1);\n            if (dis > k) {\n                s[i] -= k;\n                break;\n            }\n            s[i] = 'a';\n            k -= dis;\n        }\n        return s;\n    }\n};\n",
            "go": "func getSmallestString(s string, k int) string {\nt := []byte(s)\nfor i, c := range t {\ndis := int(min(c-'a', 'z'-c+1))\nif dis > k {\nt[i] -= byte(k)\nbreak\n}\nt[i] = 'a'\nk -= dis\n}\nreturn string(t)\n}\n",
            "js": "/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nlet getSmallestString = function (s, k) {\n    let arr = []; //空数组，用于存放变换后得值\n    const numA = 97;\n    for (let i = 0; i < s.length; i++) {\n        let el = s[i];\n        const d = el.charCodeAt() - numA; //计算当前元素与'a'得距离\n        let distance = d > 13 ? 26 - d : d; //循环字符串，需要从两端判断看那边距离短，真实得距离是两端计算后的最小值\n        if (k > 0) {\n            if (distance <= k) {\n                arr.push(\"a\");\n                k = k - distance;\n            } else {\n                const ch1 = el.charCodeAt() + k;\n                const ch2 = el.charCodeAt() - k;\n                const minNum = Math.min(ch1, ch2);\n                arr.push(String.fromCharCode(minNum));\n                k = 0;\n            }\n        } else {\n            arr.push(el);\n        }\n    }\n    return arr.join(\"\");\n};\n"
        },
        "cases": [
            {
                "input": "[\"\\\"zbbz\\\"\",\"3\"]",
                "output": "[\"\\\"aaaz\\\"\"]"
            },
            {
                "input": "[\"\\\"xaxcd\\\"\",\"4\"]",
                "output": "[\"\\\"aawcd\\\"\"]"
            },
            {
                "input": "[\"\\\"lol\\\"\",\"0\"]",
                "output": "[\"\\\"lol\\\"\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public String getSmallestString(String s, int k) {",
            "cpp": "class Solution {\npublic:\n    string getSmallestString(string s, int k) {",
            "go": "func getSmallestString(s string, k int) string {\n\n}",
            "js": "/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nvar getSmallestString = function(s, k) {",
            "python": "class Solution:\n    def getSmallestString(self, s: str, k: int) -> str:"
        },
        "time": "20240407",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "getSmallestString",
            "java": "getSmallestString",
            "cpp": "getSmallestString",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.getSmallestString(\"zbbz\", 3) == \"aaaz\", \"Test 1 Error!\"\nassert my_solution.getSmallestString(\"xaxcd\", 4) == \"aawcd\", \"Test 2 Error!\"\nassert my_solution.getSmallestString(\"lol\", 0) == \"lol\", \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String s_1 = \"zbbz\";\n    int k_1 = 3;\n    String ans_1 = \"aaaz\";\n    assert solution.getSmallestString(s_1, k_1).equals(ans_1);\n    String s_2 = \"xaxcd\";\n    int k_2 = 4;\n    String ans_2 = \"aawcd\";\n    assert solution.getSmallestString(s_2, k_2).equals(ans_2);\n    String s_3 = \"lol\";\n    int k_3 = 0;\n    String ans_3 = \"lol\";\n    assert solution.getSmallestString(s_3, k_3).equals(ans_3);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string s_1 = \"zbbz\";\n    int k_1 = 3;\n    string ans_1 = \"aaaz\";\n    assert(my_solution_1.getSmallestString(s_1, k_1) == ans_1);\n    Solution my_solution_2;\n    string s_2 = \"xaxcd\";\n    int k_2 = 4;\n    string ans_2 = \"aawcd\";\n    assert(my_solution_2.getSmallestString(s_2, k_2) == ans_2);\n    Solution my_solution_3;\n    string s_3 = \"lol\";\n    int k_3 = 0;\n    string ans_3 = \"lol\";\n    assert(my_solution_3.getSmallestString(s_3, k_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "s",
                "k"
            ],
            "java": [
                "s",
                "k"
            ],
            "cpp": [
                "s",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3107": {
        "description": "给你一个整数数组 nums 和一个 非负 整数 k 。一次操作中，你可以选择任一元素 加 1 或者减 1 。\n请你返回将 nums 中位数 变为 k 所需要的 最少 操作次数。\n一个数组的中位数指的是数组按非递减顺序排序后最中间的元素。如果数组长度为偶数，我们选择中间两个数的较大值为中位数。",
        "difficulty_level": "Middle",
        "note": "1 <= nums.length <= 2 * 10^5\n1 <= nums[i] <= 10^9\n1 <= k <= 10^9",
        "codes": {
            "python": "class Solution:\n    def minOperationsToMakeMedianK(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        m = len(nums) // 2\n        ans = 0\n        if nums[m] > k:\n            for i in range(m, -1, -1):\n                if nums[i] <= k:\n                    break\n                ans += nums[i] - k\n        else:\n            for i in range(m, len(nums)):\n                if nums[i] >= k:\n                    break\n                ans += k - nums[i]\n        return ans\n",
            "java": "class Solution {\n    public long minOperationsToMakeMedianK(int[] nums, int k) {\n        Arrays.sort(nums);\n        long ans = 0;\n        int m = nums.length / 2;\n        if (nums[m] > k) {\n            for (int i = m; i >= 0 && nums[i] > k; i--) {\n                ans += nums[i] - k;\n            }\n        } else {\n            for (int i = m; i < nums.length && nums[i] < k; i++) {\n                ans += k - nums[i];\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long minOperationsToMakeMedianK(vector<int> &nums, int k) {\n        ranges::sort(nums);\n        long long ans = 0;\n        int m = nums.size() / 2;\n        if (nums[m] > k) {\n            for (int i = m; i >= 0 && nums[i] > k; i--) {\n                ans += nums[i] - k;\n            }\n        } else {\n            for (int i = m; i < nums.size() && nums[i] < k; i++) {\n                ans += k - nums[i];\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func minOperationsToMakeMedianK(nums []int, k int) (ans int64) {\nslices.Sort(nums)\nm := len(nums) / 2\nif nums[m] > k {\nfor i := m; i >= 0 && nums[i] > k; i-- {\nans += int64(nums[i] - k)\n}\n} else {\nfor i := m; i < len(nums) && nums[i] < k; i++ {\nans += int64(k - nums[i])\n}\n}\nreturn\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[2,5,6,8,5]\",\"4\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[2,5,6,8,5]\",\"7\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[1,2,3,4,5,6]\",\"4\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long minOperationsToMakeMedianK(int[] nums, int k) {",
            "cpp": "class Solution {\npublic:\n    long long minOperationsToMakeMedianK(vector<int>& nums, int k) {",
            "go": "func minOperationsToMakeMedianK(nums []int, k int) int64 {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperationsToMakeMedianK = function(nums, k) {",
            "python": "class Solution:\n    def minOperationsToMakeMedianK(self, nums: List[int], k: int) -> int:"
        },
        "time": "20240407",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minOperationsToMakeMedianK",
            "java": "minOperationsToMakeMedianK",
            "cpp": "minOperationsToMakeMedianK",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minOperationsToMakeMedianK([2,5,6,8,5], 4) == 2, \"Test 1 Error!\"\nassert my_solution.minOperationsToMakeMedianK([2,5,6,8,5], 7) == 3, \"Test 2 Error!\"\nassert my_solution.minOperationsToMakeMedianK([1,2,3,4,5,6], 4) == 0, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {2,5,6,8,5};\n    int k_1 = 4;\n    long ans_1 = 2;\n    assert solution.minOperationsToMakeMedianK(nums_1, k_1) == ans_1;\n    int[] nums_2 = {2,5,6,8,5};\n    int k_2 = 7;\n    long ans_2 = 3;\n    assert solution.minOperationsToMakeMedianK(nums_2, k_2) == ans_2;\n    int[] nums_3 = {1,2,3,4,5,6};\n    int k_3 = 4;\n    long ans_3 = 0;\n    assert solution.minOperationsToMakeMedianK(nums_3, k_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {2,5,6,8,5};\n    int k_1 = 4;\n    long long ans_1 = 2;\n    assert(my_solution_1.minOperationsToMakeMedianK(nums_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {2,5,6,8,5};\n    int k_2 = 7;\n    long long ans_2 = 3;\n    assert(my_solution_2.minOperationsToMakeMedianK(nums_2, k_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {1,2,3,4,5,6};\n    int k_3 = 4;\n    long long ans_3 = 0;\n    assert(my_solution_3.minOperationsToMakeMedianK(nums_3, k_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "k"
            ],
            "java": [
                "nums",
                "k"
            ],
            "cpp": [
                "nums",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3108": {
        "description": "给你一个 n 个节点的带权无向图，节点编号为 0 到 n - 1 。给你一个整数 n 和一个数组 edges ，其中 edges[i] = [u_i, v_i, w_i] 表示节点 u_i 和 v_i 之间有一条权值为 w_i 的无向边。\n在图中，一趟旅途包含一系列节点和边。旅途开始和结束点都是图中的节点，且图中存在连接旅途中相邻节点的边。注意，一趟旅途可能访问同一条边或者同一个节点多次。\n如果旅途开始于节点 u ，结束于节点 v ，我们定义这一趟旅途的 代价 是经过的边权按位与 AND 的结果。换句话说，如果经过的边对应的边权为 w_0, w_1, w_2, ..., w_k ，那么代价为w_0 & w_1 & w_2 & ... & w_k ，其中 & 表示按位与 AND 操作。\n给你一个二维数组 query ，其中 query[i] = [s_i, t_i] 。对于每一个查询，你需要找出从节点开始 s_i ，在节点 t_i 处结束的旅途的最小代价。如果不存在这样的旅途，答案为 -1 。\n返回数组 answer ，其中 answer[i] 表示对于查询 i 的 最小 旅途代价。",
        "difficulty_level": "Hard",
        "note": "1 <= n <= 10^5\n0 <= edges.length <= 10^5\nedges[i].length == 3\n0 <= u_i, v_i <= n - 1\nu_i != v_i\n0 <= w_i <= 10^5\n1 <= query.length <= 10^5\nquery[i].length == 2\n0 <= s_i, t_i <= n - 1",
        "codes": {
            "python": "class Solution:\n    def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:\n        g = [[] for _ in range(n)]\n        for x, y, w in edges:\n            g[x].append((y, w))\n            g[y].append((x, w))\n\n        def dfs(x: int) -> int:\n            and_ = -1\n            ids[x] = len(cc_and)  # 记录每个点所在连通块的编号\n            for y, w in g[x]:\n                and_ &= w\n                if ids[y] < 0:  # 没有访问过\n                    and_ &= dfs(y)\n            return and_\n\n        ids = [-1] * n  # 记录每个点所在连通块的编号\n        cc_and = []  # 记录每个连通块的边权的 AND\n        for i in range(n):\n            if ids[i] < 0:\n                cc_and.append(dfs(i))\n\n        return [-1 if ids[s] != ids[t] else cc_and[ids[s]]\n                for s, t in query]\n",
            "java": "class Solution {\n    public int[] minimumCost(int n, int[][] edges, int[][] query) {\n        List<int[]>[] g = new ArrayList[n];\n        Arrays.setAll(g, i -> new ArrayList<>());\n        for (int[] e : edges) {\n            int x = e[0], y = e[1], w = e[2];\n            g[x].add(new int[]{y, w});\n            g[y].add(new int[]{x, w});\n        }\n\n        int[] ids = new int[n]; // 记录每个点所在连通块的编号\n        Arrays.fill(ids, -1);\n        List<Integer> ccAnd = new ArrayList<>(); // 记录每个连通块的边权的 AND\n        for (int i = 0; i < n; i++) {\n            if (ids[i] < 0) {\n                ccAnd.add(dfs(i, ccAnd.size(), g, ids));\n            }\n        }\n\n        int[] ans = new int[query.length];\n        for (int i = 0; i < query.length; i++) {\n            int s = query[i][0], t = query[i][1];\n            ans[i] = ids[s] != ids[t] ? -1 : ccAnd.get(ids[s]);\n        }\n        return ans;\n    }\n\n    private int dfs(int x, int curId, List<int[]>[] g, int[] ids) {\n        ids[x] = curId; // 记录每个点所在连通块的编号\n        int and = -1;\n        for (int[] e : g[x]) {\n            and &= e[1];\n            if (ids[e[0]] < 0) { // 没有访问过\n                and &= dfs(e[0], curId, g, ids);\n            }\n        }\n        return and;\n    }\n}\n",
            "cpp": "class Solution {\n    vector<vector<pair<int, int>>> g;\n    vector<int> cc_and, ids;\n\n    int dfs(int x) {\n        ids[x] = cc_and.size(); // 记录每个点所在连通块的编号\n        int and_ = -1;\n        for (auto &[y, w]: g[x]) {\n            and_ &= w;\n            if (ids[y] < 0) { // 没有访问过\n                and_ &= dfs(y);\n            }\n        }\n        return and_;\n    }\n\npublic:\n    vector<int> minimumCost(int n, vector<vector<int>> &edges, vector<vector<int>> &query) {\n        g.resize(n);\n        for (auto &e: edges) {\n            int x = e[0], y = e[1], w = e[2];\n            g[x].emplace_back(y, w);\n            g[y].emplace_back(x, w);\n        }\n\n        ids.resize(n, -1); // 记录每个点所在连通块的编号\n        for (int i = 0; i < n; i++) {\n            if (ids[i] < 0) { // 没有访问过\n                cc_and.push_back(dfs(i)); // 记录每个连通块的边权的 AND\n            }\n        }\n\n        vector<int> ans;\n        ans.reserve(query.size()); // 预分配空间\n        for (auto &q: query) {\n            int s = q[0], t = q[1];\n            ans.push_back(ids[s] != ids[t] ? -1 : cc_and[ids[s]]);\n        }\n        return ans;\n    }\n};\n",
            "go": "func minimumCost(n int, edges, query [][]int) []int {\ntype edge struct{ to, w int }\ng := make([][]edge, n)\nfor _, e := range edges {\nx, y, w := e[0], e[1], e[2]\ng[x] = append(g[x], edge{y, w})\ng[y] = append(g[y], edge{x, w})\n}\n\nids := make([]int, n) // 记录每个点所在连通块的编号\nfor i := range ids {\nids[i] = -1\n}\nccAnd := []int{} // 记录每个连通块的边权的 AND\nvar dfs func(int) int\ndfs = func(x int) int {\nids[x] = len(ccAnd) // 记录每个点所在连通块的编号\nand := -1\nfor _, e := range g[x] {\nand &= e.w\nif ids[e.to] < 0 { // 没有访问过\nand &= dfs(e.to)\n}\n}\nreturn and\n}\nfor i, id := range ids {\nif id < 0 { // 没有访问过\nccAnd = append(ccAnd, dfs(i)) // 记录每个连通块的边权的 AND\n}\n}\n\nans := make([]int, len(query))\nfor i, q := range query {\ns, t := q[0], q[1]\nif ids[s] != ids[t] {\nans[i] = -1\n} else {\nans[i] = ccAnd[ids[s]]\n}\n}\nreturn ans\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"5\",\"[[0,1,7],[1,3,7],[1,2,1]]\",\"[[0,3],[3,4]]\"]",
                "output": "[\"[1,-1]\"]"
            },
            {
                "input": "[\"3\",\"[[0,2,7],[0,1,15],[1,2,6],[1,2,1]]\",\"[[1,2]]\"]",
                "output": "[\"[0]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int[] minimumCost(int n, int[][] edges, int[][] query) {",
            "cpp": "class Solution {\npublic:\n    vector<int> minimumCost(int n, vector<vector<int>>& edges, vector<vector<int>>& query) {",
            "go": "func minimumCost(n int, edges [][]int, query [][]int) []int {\n\n}",
            "js": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number[][]} query\n * @return {number[]}\n */\nvar minimumCost = function(n, edges, query) {",
            "python": "class Solution:\n    def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:"
        },
        "time": "20240407",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumCost",
            "java": "minimumCost",
            "cpp": "minimumCost",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumCost(5, [[0,1,7],[1,3,7],[1,2,1]], [[0,3],[3,4]]) == [1,-1], \"Test 1 Error!\"\nassert my_solution.minimumCost(3, [[0,2,7],[0,1,15],[1,2,6],[1,2,1]], [[1,2]]) == [0], \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int n_1 = 5;\n    int[][] edges_1 = {{0,1,7},{1,3,7},{1,2,1}};\n    int[][] query_1 = {{0,3},{3,4}};\n    int[] ans_1 = {1,-1};\n    assert Arrays.equals(solution.minimumCost(n_1, edges_1, query_1), ans_1);\n    int n_2 = 3;\n    int[][] edges_2 = {{0,2,7},{0,1,15},{1,2,6},{1,2,1}};\n    int[][] query_2 = {{1,2}};\n    int[] ans_2 = {0};\n    assert Arrays.equals(solution.minimumCost(n_2, edges_2, query_2), ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int n_1 = 5;\n    vector<vector<int>> edges_1 = {{0,1,7},{1,3,7},{1,2,1}};\n    vector<vector<int>> query_1 = {{0,3},{3,4}};\n    vector<int> ans_1 = {1,-1};\n    assert(my_solution_1.minimumCost(n_1, edges_1, query_1) == ans_1);\n    Solution my_solution_2;\n    int n_2 = 3;\n    vector<vector<int>> edges_2 = {{0,2,7},{0,1,15},{1,2,6},{1,2,1}};\n    vector<vector<int>> query_2 = {{1,2}};\n    vector<int> ans_2 = {0};\n    assert(my_solution_2.minimumCost(n_2, edges_2, query_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "n",
                "edges",
                "query"
            ],
            "java": [
                "n",
                "edges",
                "query"
            ],
            "cpp": [
                "n",
                "edges",
                "query"
            ],
            "go": [],
            "js": []
        }
    },
    "3114": {
        "description": "给你一个字符串 s，表示一个 12 小时制的时间格式，其中一些数字（可能没有）被 \"?\" 替换。\n12 小时制时间格式为 \"HH:MM\" ，其中 HH 的取值范围为 00 至 11，MM 的取值范围为 00 至 59。最早的时间为 00:00，最晚的时间为 11:59。\n你需要将 s 中的 所有 \"?\" 字符替换为数字，使得结果字符串代表的时间是一个 有效 的 12 小时制时间，并且是可能的 最晚 时间。\n返回结果字符串。",
        "difficulty_level": "Easy",
        "note": "s.length == 5\ns[2] 是字符 \":\"\n除 s[2] 外，其他字符都是数字或 \"?\"\n输入保证在替换 \"?\" 字符后至少存在一个介于 \"00:00\" 和 \"11:59\" 之间的时间。",
        "codes": {
            "python": "class Solution:\n    def findLatestTime(self, s: str) -> str:\n        for h in range(11, -1, -1):\n            for m in range(59, -1, -1):\n                t = f\"{h:02d}:{m:02d}\"  # f-string\n                if all(x == '?' or x == y for x, y in zip(s, t)):\n                    return t\n",
            "java": "class Solution {\n    public String findLatestTime(String S) {\n        char[] s = S.toCharArray();\n        for (int h = 11; ; h--) {\n            if (s[0] != '?' && s[0] - '0' != h / 10 || s[1] != '?' && s[1] - '0' != h % 10) {\n                continue;\n            }\n            for (int m = 59; m >= 0; m--) {\n                if (s[3] != '?' && s[3] - '0' != m / 10 || s[4] != '?' && s[4] - '0' != m % 10) {\n                    continue;\n                }\n                return String.format(\"%02d:%02d\", h, m);\n            }\n        }\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    string findLatestTime(string s) {\n        for (int h = 11; ; h--) {\n            if (s[0] != '?' && s[0] - '0' != h / 10 || s[1] != '?' && s[1] - '0' != h % 10) {\n                continue;\n            }\n            for (int m = 59; m >= 0; m--) {\n                if (s[3] != '?' && s[3] - '0' != m / 10 || s[4] != '?' && s[4] - '0' != m % 10) {\n                    continue;\n                }\n                char ans[6];\n                sprintf(ans, \"%02d:%02d\", h, m);\n                return string(ans);\n            }\n        }\n    }\n};\n",
            "go": "func findLatestTime(s string) string {\nfor h := 11; ; h-- {\nif s[0] != '?' && s[0]-'0' != byte(h/10) || s[1] != '?' && s[1]-'0' != byte(h%10) {\ncontinue\n}\nfor m := 59; m >= 0; m-- {\nif s[3] != '?' && s[3]-'0' != byte(m/10) || s[4] != '?' && s[4]-'0' != byte(m%10) {\ncontinue\n}\nreturn fmt.Sprintf(\"%02d:%02d\", h, m)\n}\n}\n}\n",
            "js": "/**\n * @param {string} s\n * @return {string}\n */\nvar findLatestTime = function(s) {\n    for(let h = 11; h >= 0; h--){\n        x:for(let m = 59; m >= 0; m--){\n           let t = `${String(h).padStart(2,0)}:${String(m).padStart(2,0)}`\n           for(let i = 0; i < 5; i++)  if(t[i] !== s[i] && s[i] !== '?') continue x  \n           return t \n        }\n    }\n};\n"
        },
        "cases": [
            {
                "input": "[\"\\\"1?:?4\\\"\"]",
                "output": "[\"\\\"11:54\\\"\"]"
            },
            {
                "input": "[\"\\\"0?:5?\\\"\"]",
                "output": "[\"\\\"09:59\\\"\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public String findLatestTime(String s) {",
            "cpp": "class Solution {\npublic:\n    string findLatestTime(string s) {",
            "go": "func findLatestTime(s string) string {\n\n}",
            "js": "/**\n * @param {string} s\n * @return {string}\n */\nvar findLatestTime = function(s) {",
            "python": "class Solution:\n    def findLatestTime(self, s: str) -> str:"
        },
        "time": "20240414",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "findLatestTime",
            "java": "findLatestTime",
            "cpp": "findLatestTime",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.findLatestTime(\"1?:?4\") == \"11:54\", \"Test 1 Error!\"\nassert my_solution.findLatestTime(\"0?:5?\") == \"09:59\", \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String s_1 = \"1?:?4\";\n    String ans_1 = \"11:54\";\n    assert solution.findLatestTime(s_1).equals(ans_1);\n    String s_2 = \"0?:5?\";\n    String ans_2 = \"09:59\";\n    assert solution.findLatestTime(s_2).equals(ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string s_1 = \"1?:?4\";\n    string ans_1 = \"11:54\";\n    assert(my_solution_1.findLatestTime(s_1) == ans_1);\n    Solution my_solution_2;\n    string s_2 = \"0?:5?\";\n    string ans_2 = \"09:59\";\n    assert(my_solution_2.findLatestTime(s_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "s"
            ],
            "java": [
                "s"
            ],
            "cpp": [
                "s"
            ],
            "go": [],
            "js": []
        }
    },
    "3115": {
        "description": "给你一个整数数组 nums。\n返回两个（不一定不同的）质数在 nums 中 下标 的 最大距离。",
        "difficulty_level": "Middle",
        "note": "1 <= nums.length <= 3 * 10^5\n1 <= nums[i] <= 100\n输入保证 nums 中至少有一个质数。",
        "codes": {
            "python": "class Solution:\n    def maximumPrimeDifference(self, nums: List[int]) -> int:\n        primes = {\n            2, 3, 5, 7, 11,\n            13, 17, 19, 23, 29,\n            31, 37, 41, 43, 47,\n            53, 59, 61, 67, 71,\n            73, 79, 83, 89, 97\n        }\n\n        first, ans = -1, 0\n        for i, num in enumerate(nums):\n            if num in primes:\n                if first != -1:\n                    ans = max(ans, i - first)\n                else:\n                    first = i\n        return ans\n",
            "java": "class Solution {\n    public int maximumPrimeDifference(int[] nums) {\n        Set<Integer> primes = new HashSet<>(Arrays.asList(\n            2, 3, 5, 7, 11,\n            13, 17, 19, 23, 29,\n            31, 37, 41, 43, 47,\n            53, 59, 61, 67, 71,\n            73, 79, 83, 89, 97\n        ));\n\n        int n = nums.length;\n        int first = -1, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (primes.contains(nums[i])) {\n                if (first != -1) {\n                    ans = Math.max(ans, i - first);\n                } else {\n                    first = i;\n                }\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int maximumPrimeDifference(vector<int>& nums) {\n        unordered_set<int> primes = {\n            2, 3, 5, 7, 11,\n            13, 17, 19, 23, 29,\n            31, 37, 41, 43, 47,\n            53, 59, 61, 67, 71,\n            73, 79, 83, 89, 97\n        };\n\n        int n = nums.size();\n        int first = -1, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (primes.count(nums[i])) {\n                if (first != -1) {\n                    ans = max(ans, i - first);\n                }\n                else {\n                    first = i;\n                }\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func isPrime(n int) bool {\nfor i := 2; i*i <= n; i++ {\nif n%i == 0 {\nreturn false\n}\n}\nreturn n >= 2\n}\n\nfunc maximumPrimeDifference(nums []int) int {\ni := 0\nfor !isPrime(nums[i]) {\ni++\n}\nj := len(nums)-1\nfor !isPrime(nums[j]) {\nj--\n}\nreturn j - i\n}\n",
            "js": "var maximumPrimeDifference = function(nums) {\n    const primes = new Set([\n        2, 3, 5, 7, 11,\n        13, 17, 19, 23, 29,\n        31, 37, 41, 43, 47,\n        53, 59, 61, 67, 71,\n        73, 79, 83, 89, 97\n    ]);\n\n    const n = nums.length;\n    let first = -1, ans = 0;\n    for (let i = 0; i < n; ++i) {\n        if (primes.has(nums[i])) {\n            if (first !== -1) {\n                ans = Math.max(ans, i - first);\n            } else {\n                first = i;\n            }\n        }\n    }\n    return ans;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[4,2,9,5,3]\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[4,8,2,8]\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maximumPrimeDifference(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    int maximumPrimeDifference(vector<int>& nums) {",
            "go": "func maximumPrimeDifference(nums []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumPrimeDifference = function(nums) {",
            "python": "class Solution:\n    def maximumPrimeDifference(self, nums: List[int]) -> int:"
        },
        "time": "20240414",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maximumPrimeDifference",
            "java": "maximumPrimeDifference",
            "cpp": "maximumPrimeDifference",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maximumPrimeDifference([4,2,9,5,3]) == 3, \"Test 1 Error!\"\nassert my_solution.maximumPrimeDifference([4,8,2,8]) == 0, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {4,2,9,5,3};\n    int ans_1 = 3;\n    assert solution.maximumPrimeDifference(nums_1) == ans_1;\n    int[] nums_2 = {4,8,2,8};\n    int ans_2 = 0;\n    assert solution.maximumPrimeDifference(nums_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {4,2,9,5,3};\n    int ans_1 = 3;\n    assert(my_solution_1.maximumPrimeDifference(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {4,8,2,8};\n    int ans_2 = 0;\n    assert(my_solution_2.maximumPrimeDifference(nums_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3116": {
        "description": "给你一个整数数组 coins 表示不同面额的硬币，另给你一个整数 k 。你有无限量的每种面额的硬币。但是，你 不能 组合使用不同面额的硬币。返回使用这些硬币能制造的 第 k^th 小 金额。",
        "difficulty_level": "Hard",
        "note": "1 <= coins.length <= 15\n1 <= coins[i] <= 25\n1 <= k <= 2 * 10^9\ncoins 包含两两不同的整数。",
        "codes": {
            "python": "class Solution:\n    def findKthSmallest(self, coins: List[int], k: int) -> int:\n        def check(m: int) -> bool:\n            cnt = 0\n            for i in range(1, 1 << len(coins)):  # 枚举所有非空子集\n                lcm_res = 1  # 计算子集 LCM\n                for j, x in enumerate(coins):\n                    if i >> j & 1:\n                        lcm_res = lcm(lcm_res, x)\n                        if lcm_res > m:  # 太大了\n                            break\n                else:  # 中途没有 break\n                    cnt += m // lcm_res if bit_count(i) % 2 else -(m // lcm_res)\n            return cnt >= k\n        return bisect_left(range(min(coins) * k), True, k, key=check)\n",
            "java": "class Solution {\n    public long findKthSmallest(int[] coins, int k) {\n        int mn = Integer.MAX_VALUE;\n        for (int x : coins) {\n            mn = Math.min(mn, x);\n        }\n        long left = k - 1, right = (long) mn * k;\n        while (left + 1 < right) {\n            long mid = (left + right) / 2;\n            if (check(mid, coins, k)) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        return right;\n    }\n\n    private boolean check(long m, int[] coins, int k) {\n        long cnt = 0;\n        next:\n        for (int i = 1; i < (1 << coins.length); i++) { // 枚举所有非空子集\n            long lcmRes = 1; // 计算子集 LCM\n            for (int j = 0; j < coins.length; j++) {\n                if ((i >> j & 1) == 1) {\n                    lcmRes = lcm(lcmRes, coins[j]);\n                    if (lcmRes > m) { // 太大了\n                        continue next;\n                    }\n                }\n            }\n            cnt += Integer.bitCount(i) % 2 == 1 ? m / lcmRes : -m / lcmRes;\n        }\n        return cnt >= k;\n    }\n\n    private long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n\n    private long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long findKthSmallest(vector<int>& coins, int k) {\n        auto check = [&](long long m) -> bool {\n            long long cnt = 0;\n            for (int i = 1; i < (1 << coins.size()); i++) { // 枚举所有非空子集\n                long long lcm_res = 1; // 计算子集 LCM\n                for (int j = 0; j < coins.size(); j++) {\n                    if (i >> j & 1) {\n                        lcm_res = lcm(lcm_res, coins[j]);\n                        if (lcm_res > m) { // 太大了\n                            break;\n                        }\n                    }\n                }\n                cnt += __builtin_popcount(i) % 2 ? m / lcm_res : -m / lcm_res;\n            }\n            return cnt >= k;\n        };\n\n        long long left = k - 1, right = (long long) ranges::min(coins) * k;\n        while (left + 1 < right) {\n            long long mid = (left + right) / 2;\n            (check(mid) ? right : left) = mid;\n        }\n        return right;\n    }\n};\n",
            "go": "func findKthSmallest(coins []int, k int) int64 {\nans := sort.Search(slices.Min(coins)*k, func(m int) bool {\ncnt := 0\nnext:\nfor i := uint(1); i < 1<<len(coins); i++ { // 枚举所有非空子集\nlcmRes := 1 // 计算子集 LCM\nfor j := i; j > 0; j &= j - 1 {\nlcmRes = lcm(lcmRes, coins[bits.TrailingZeros(j)])\nif lcmRes > m { // 太大了\ncontinue next\n}\n}\nc := m / lcmRes\nif bits.OnesCount(i)%2 == 0 {\nc = -c\n}\ncnt += c\n}\nreturn cnt >= k\n})\nreturn int64(ans)\n}\n\nfunc gcd(a, b int) int {\nfor a != 0 {\na, b = b%a, a\n}\nreturn b\n}\n\nfunc lcm(a, b int) int {\nreturn a / gcd(a, b) * b\n}\n",
            "js": "/**\n * @param {number[]} coins\n * @param {number} k\n * @return {number}\n */\nvar findKthSmallest = function(coins, k) {\n    // 对硬币数组进行升序排序\n    coins.sort((a, b) => a - b);\n    // 最小金额的下界\n    let left = 1;\n    // 最大金额的上界\n    let right = coins[coins.length - 1] * k;\n\n    while (left < right) {\n        // 计算中间金额\n        const mid = Math.floor((left + right) / 2);\n        // 计算小于等于中间金额的金额数量\n        const count = countCoins(coins, mid);\n\n        if (count < k) {\n            // 第 k 小的金额在右半部分\n            left = mid + 1;\n        } else {\n            // 第 k 小的金额在左半部分或者就是当前中间金额\n            right = mid;\n        }\n    }\n\n    // 返回第 k 小的金额\n    return left;\n};\n\nvar countCoins = function(coins, amount) {\n    // 金额数量计数器\n    let count = 0;\n\n    // 使用容斥原理计算小于等于 amount 的金额数量\n    for (let i = 1; i < (1 << coins.length); i++) {\n        // 最小公倍数\n        let lcm = 1;\n        // 二进制中 1 的个数\n        let bitCount = 0;\n\n        for (let j = 0; j < coins.length; j++) {\n            if ((i & (1 << j)) !== 0) {\n                // 计算所选硬币的最小公倍数\n                lcm = getLCM(lcm, coins[j]);\n                // 统计二进制位 1 的个数\n                bitCount++;\n            }\n        }\n\n        // 计算小于等于 amount 的 lcm 数量\n        const amountCount = Math.floor(amount / lcm);\n        // 根据二进制位 1 的个数确定计算的正负符号\n        count += bitCount % 2 === 1 ? amountCount : -amountCount;\n    }\n\n    // 返回小于等于 amount 的金额数量\n    return count;\n};\n\n// 计算最小公倍数\nvar getLCM = function(a, b) {\n    // 使用辗转相除法计算最大公约数，再通过公式计算最小公倍数\n    return (a * b) / getGCD(a, b);\n};\n\n// 计算最大公约数\nvar getGCD = function(a, b) {\n    // 辗转相除法的终止条件\n    if (b === 0) {\n        return a;\n    }\n    // 递归计算最大公约数\n    return getGCD(b, a % b);\n};\n"
        },
        "cases": [
            {
                "input": "[\"[3,6,9]\",\"3\"]",
                "output": "[\"9\"]"
            },
            {
                "input": "[\"[5,2]\",\"7\"]",
                "output": "[\"12\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long findKthSmallest(int[] coins, int k) {",
            "cpp": "class Solution {\npublic:\n    long long findKthSmallest(vector<int>& coins, int k) {",
            "go": "func findKthSmallest(coins []int, k int) int64 {\n\n}",
            "js": "/**\n * @param {number[]} coins\n * @param {number} k\n * @return {number}\n */\nvar findKthSmallest = function(coins, k) {",
            "python": "class Solution:\n    def findKthSmallest(self, coins: List[int], k: int) -> int:"
        },
        "time": "20240414",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "findKthSmallest",
            "java": "findKthSmallest",
            "cpp": "findKthSmallest",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.findKthSmallest([3,6,9], 3) == 9, \"Test 1 Error!\"\nassert my_solution.findKthSmallest([5,2], 7) == 12, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] coins_1 = {3,6,9};\n    int k_1 = 3;\n    long ans_1 = 9;\n    assert solution.findKthSmallest(coins_1, k_1) == ans_1;\n    int[] coins_2 = {5,2};\n    int k_2 = 7;\n    long ans_2 = 12;\n    assert solution.findKthSmallest(coins_2, k_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> coins_1 = {3,6,9};\n    int k_1 = 3;\n    long long ans_1 = 9;\n    assert(my_solution_1.findKthSmallest(coins_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> coins_2 = {5,2};\n    int k_2 = 7;\n    long long ans_2 = 12;\n    assert(my_solution_2.findKthSmallest(coins_2, k_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "coins",
                "k"
            ],
            "java": [
                "coins",
                "k"
            ],
            "cpp": [
                "coins",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3117": {
        "description": "给你两个数组 nums 和 andValues，长度分别为 n 和 m。",
        "difficulty_level": "Hard",
        "note": "1 <= n == nums.length <= 10^4\n1 <= m == andValues.length <= min(n, 10)\n1 <= nums[i] < 10^5\n0 <= andValues[j] < 10^5",
        "codes": {
            "python": "class Solution:\n    def minimumValueSum(self, nums: List[int], andValues: List[int]) -> int:\n        n, m = len(nums), len(andValues)\n        @cache\n        def dfs(i: int, j: int, and_: int) -> int:\n            if m - j > n - i:  # 剩余元素不足\n                return inf\n            if j == m:  # 分了 m 段\n                return 0 if i == n else inf\n            and_ &= nums[i]\n            if and_ < andValues[j]:  # 剪枝：无法等于 andValues[j]\n                return inf\n            res = dfs(i + 1, j, and_)  # 不划分\n            if and_ == andValues[j]:  # 划分，nums[i] 是这一段的最后一个数\n                res = min(res, dfs(i + 1, j + 1, -1) + nums[i])\n            return res\n        ans = dfs(0, 0, -1)\n        return ans if ans < inf else -1\n",
            "java": "class Solution {\n    public int minimumValueSum(int[] nums, int[] andValues) {\n        Map<Long, Integer> memo = new HashMap<>();\n        int ans = dfs(0, 0, -1, nums, andValues, memo);\n        return ans < Integer.MAX_VALUE / 2 ? ans : -1;\n    }\n\n    private int dfs(int i, int j, int and, int[] nums, int[] andValues, Map<Long, Integer> memo) {\n        int n = nums.length;\n        int m = andValues.length;\n        if (m - j > n - i) { // 剩余元素不足\n            return Integer.MAX_VALUE / 2;\n        }\n        if (j == m) { // 分了 m 段\n            return i == n ? 0 : Integer.MAX_VALUE / 2;\n        }\n        and &= nums[i];\n        if (and < andValues[j]) { // 剪枝：无法等于 andValues[j]\n            return Integer.MAX_VALUE / 2;\n        }\n        long mask = (long) i << 36 | (long) j << 32 | and; // 三个状态压缩成一个 long\n        if (memo.containsKey(mask)) {\n            return memo.get(mask);\n        }\n        int res = dfs(i + 1, j, and, nums, andValues, memo); // 不划分\n        if (and == andValues[j]) { // 划分，nums[i] 是这一段的最后一个数\n            res = Math.min(res, dfs(i + 1, j + 1, -1, nums, andValues, memo) + nums[i]);\n        }\n        memo.put(mask, res);\n        return res;\n    }\n}\n",
            "cpp": "class Solution {\n    unordered_map<long long, int> memo;\n\n    int dfs(int i, int j, int and_, vector<int>& nums, vector<int>& andValues) {\n        int n = nums.size(), m = andValues.size();\n        if (m - j > n - i) { // 剩余元素不足\n            return INT_MAX / 2;\n        }\n        if (j == m) { // 分了 m 段\n            return i == n ? 0 : INT_MAX / 2;\n        }\n        and_ &= nums[i];\n        if (and_ < andValues[j]) { // 剪枝：无法等于 andValues[j]\n            return INT_MAX / 2;\n        }\n        long long mask = (long long) i << 36 | (long long) j << 32 | and_; // 三个状态压缩成一个 long long\n        if (memo.contains(mask)) {\n            return memo[mask];\n        }\n        int res = dfs(i + 1, j, and_, nums, andValues); // 不划分\n        if (and_ == andValues[j]) { // 划分，nums[i] 是这一段的最后一个数\n            res = min(res, dfs(i + 1, j + 1, -1, nums, andValues) + nums[i]);\n        }\n        return memo[mask] = res;\n    }\n\npublic:\n    int minimumValueSum(vector<int>& nums, vector<int>& andValues) {\n        int ans = dfs(0, 0, -1, nums, andValues);\n        return ans < INT_MAX / 2 ? ans : -1;\n    }\n};\n",
            "go": "func minimumValueSum(nums, andValues []int) int {\nn, m := len(nums), len(andValues)\ntype args struct{ i, j, and int }\nmemo := map[args]int{}\nvar dfs func(int, int, int) int\ndfs = func(i, j, and int) int {\nif m-j > n-i { // 剩余元素不足\nreturn math.MaxInt / 2\n}\nif j == m { // 分了 m 段\nif i == n {\nreturn 0\n}\nreturn math.MaxInt / 2\n}\nand &= nums[i]\nif and < andValues[j] { // 剪枝：无法等于 andValues[j]\nreturn math.MaxInt / 2\n}\np := args{i, j, and}\nif res, ok := memo[p]; ok {\nreturn res\n}\nres := dfs(i+1, j, and)  // 不划分\nif and == andValues[j] { // 划分，nums[i] 是这一段的最后一个数\nres = min(res, dfs(i+1, j+1, -1)+nums[i])\n}\nmemo[p] = res\nreturn res\n}\nans := dfs(0, 0, -1)\nif ans == math.MaxInt/2 {\nreturn -1\n}\nreturn ans\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[1,4,3,3,2]\",\"[0,3,3,2]\"]",
                "output": "[\"12\"]"
            },
            {
                "input": "[\"[2,3,5,7,7,7,5]\",\"[0,7,5]\"]",
                "output": "[\"17\"]"
            },
            {
                "input": "[\"[1,2,3,4]\",\"[2]\"]",
                "output": "[\"-1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumValueSum(int[] nums, int[] andValues) {",
            "cpp": "class Solution {\npublic:\n    int minimumValueSum(vector<int>& nums, vector<int>& andValues) {",
            "go": "func minimumValueSum(nums []int, andValues []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number[]} andValues\n * @return {number}\n */\nvar minimumValueSum = function(nums, andValues) {",
            "python": "class Solution:\n    def minimumValueSum(self, nums: List[int], andValues: List[int]) -> int:"
        },
        "time": "20240414",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumValueSum",
            "java": "minimumValueSum",
            "cpp": "minimumValueSum",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumValueSum([1,4,3,3,2], [0,3,3,2]) == 12, \"Test 1 Error!\"\nassert my_solution.minimumValueSum([2,3,5,7,7,7,5], [0,7,5]) == 17, \"Test 2 Error!\"\nassert my_solution.minimumValueSum([1,2,3,4], [2]) == -1, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,4,3,3,2};\n    int[] andValues_1 = {0,3,3,2};\n    int ans_1 = 12;\n    assert solution.minimumValueSum(nums_1, andValues_1) == ans_1;\n    int[] nums_2 = {2,3,5,7,7,7,5};\n    int[] andValues_2 = {0,7,5};\n    int ans_2 = 17;\n    assert solution.minimumValueSum(nums_2, andValues_2) == ans_2;\n    int[] nums_3 = {1,2,3,4};\n    int[] andValues_3 = {2};\n    int ans_3 = -1;\n    assert solution.minimumValueSum(nums_3, andValues_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,4,3,3,2};\n    vector<int> andValues_1 = {0,3,3,2};\n    int ans_1 = 12;\n    assert(my_solution_1.minimumValueSum(nums_1, andValues_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {2,3,5,7,7,7,5};\n    vector<int> andValues_2 = {0,7,5};\n    int ans_2 = 17;\n    assert(my_solution_2.minimumValueSum(nums_2, andValues_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {1,2,3,4};\n    vector<int> andValues_3 = {2};\n    int ans_3 = -1;\n    assert(my_solution_3.minimumValueSum(nums_3, andValues_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "andValues"
            ],
            "java": [
                "nums",
                "andValues"
            ],
            "cpp": [
                "nums",
                "andValues"
            ],
            "go": [],
            "js": []
        }
    },
    "3120": {
        "description": "给你一个字符串 word。如果 word 中同时存在某个字母的小写形式和大写形式，则称这个字母为 特殊字母。\n返回 word 中 特殊字母 的数量。",
        "difficulty_level": "Easy",
        "note": "1 <= word.length <= 50\nword 仅由小写和大写英文字母组成。",
        "codes": {
            "python": "class Solution:\n    def numberOfSpecialChars(self, word: str) -> int:\n        mask = [0, 0]\n        for c in map(ord, word):\n            mask[c >> 5 & 1] |= 1 << (c & 31)\n        return bit_count(mask[0] & mask[1])\n",
            "java": "class Solution {\n    public int numberOfSpecialChars(String word) {\n        int[] mask = new int[2];\n        for (char c : word.toCharArray()) {\n            mask[c >> 5 & 1] |= 1 << (c & 31);\n        }\n        return Integer.bitCount(mask[0] & mask[1]);\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int numberOfSpecialChars(string word) {\n        int mask[2]{};\n        for (char c : word) {\n            mask[c >> 5 & 1] |= 1 << (c & 31);\n        }\n        return __builtin_popcount(mask[0] & mask[1]);\n    }\n};\n",
            "go": "func numberOfSpecialChars(word string) int {\nmask := [2]int{}\nfor _, c := range word {\nmask[c>>5&1] |= 1 << (c & 31)\n}\nreturn bits.OnesCount(uint(mask[0] & mask[1]))\n}\n",
            "js": "/**\n * @param {string} word\n * @return {number}\n */\nvar numberOfSpecialChars = function(word) {\n    const ans = new Set(), set = new Set();\n    for (const w of word) {\n        let wNum = w.charCodeAt();\n        if (set.has(wNum < 97 ? wNum + 32 : wNum - 32)) {\n            ans.add(wNum < 97 ? wNum + 32 : wNum);\n        } else {\n            set.add(wNum);\n        }\n    }\n    return ans.size;\n};\n"
        },
        "cases": [
            {
                "input": "[\"\\\"aaAbcBC\\\"\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"\\\"abc\\\"\"]",
                "output": "[\"0\"]"
            },
            {
                "input": "[\"\\\"abBCab\\\"\"]",
                "output": "[\"1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int numberOfSpecialChars(String word) {",
            "cpp": "class Solution {\npublic:\n    int numberOfSpecialChars(string word) {",
            "go": "func numberOfSpecialChars(word string) int {\n\n}",
            "js": "/**\n * @param {string} word\n * @return {number}\n */\nvar numberOfSpecialChars = function(word) {",
            "python": "class Solution:\n    def numberOfSpecialChars(self, word: str) -> int:"
        },
        "time": "20240421",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "numberOfSpecialChars",
            "java": "numberOfSpecialChars",
            "cpp": "numberOfSpecialChars",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.numberOfSpecialChars(\"aaAbcBC\") == 3, \"Test 1 Error!\"\nassert my_solution.numberOfSpecialChars(\"abc\") == 0, \"Test 2 Error!\"\nassert my_solution.numberOfSpecialChars(\"abBCab\") == 1, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String word_1 = \"aaAbcBC\";\n    int ans_1 = 3;\n    assert solution.numberOfSpecialChars(word_1) == ans_1;\n    String word_2 = \"abc\";\n    int ans_2 = 0;\n    assert solution.numberOfSpecialChars(word_2) == ans_2;\n    String word_3 = \"abBCab\";\n    int ans_3 = 1;\n    assert solution.numberOfSpecialChars(word_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string word_1 = \"aaAbcBC\";\n    int ans_1 = 3;\n    assert(my_solution_1.numberOfSpecialChars(word_1) == ans_1);\n    Solution my_solution_2;\n    string word_2 = \"abc\";\n    int ans_2 = 0;\n    assert(my_solution_2.numberOfSpecialChars(word_2) == ans_2);\n    Solution my_solution_3;\n    string word_3 = \"abBCab\";\n    int ans_3 = 1;\n    assert(my_solution_3.numberOfSpecialChars(word_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "word"
            ],
            "java": [
                "word"
            ],
            "cpp": [
                "word"
            ],
            "go": [],
            "js": []
        }
    },
    "3121": {
        "description": "给你一个字符串 word。如果 word 中同时出现某个字母 c 的小写形式和大写形式，并且 每个 小写形式的 c 都出现在第一个大写形式的 c 之前，则称字母 c 是一个 特殊字母 。\n返回 word 中 特殊字母 的数量。",
        "difficulty_level": "Middle",
        "note": "1 <= word.length <= 2 * 10^5\nword 仅由小写和大写英文字母组成。",
        "codes": {
            "python": "class Solution:\n    def numberOfSpecialChars(self, word: str) -> int:\n        ans = 0\n        state = [0] * 27\n        for c in map(ord, word):\n            x = c & 31  # 转成数字 1~26\n            if c & 32:  # 小写字母\n                if state[x] == 0:\n                    state[x] = 1\n                elif state[x] == 2:\n                    state[x] = -1\n                    ans -= 1\n            else:  # 大写字母\n                if state[x] == 0:\n                    state[x] = -1\n                elif state[x] == 1:\n                    state[x] = 2\n                    ans += 1\n        return ans\n",
            "java": "class Solution {\n    public int numberOfSpecialChars(String word) {\n        int ans = 0;\n        int[] state = new int[27];\n        for (char c : word.toCharArray()) {\n            int x = c & 31; // 转成数字 1~26\n            if ((c & 32) > 0) { // 小写字母\n                if (state[x] == 0) {\n                    state[x] = 1;\n                } else if (state[x] == 2) {\n                    state[x] = -1;\n                    ans--;\n                }\n            } else { // 大写字母\n                if (state[x] == 0) {\n                    state[x] = -1;\n                } else if (state[x] == 1) {\n                    state[x] = 2;\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int numberOfSpecialChars(string word) {\n        int ans = 0;\n        int state[27]{};\n        for (char c : word) {\n            int x = c & 31; // 转成数字 1~26\n            if (c & 32) { // 小写字母\n                if (state[x] == 0) {\n                    state[x] = 1;\n                } else if (state[x] == 2) {\n                    state[x] = -1;\n                    ans--;\n                }\n            } else { // 大写字母\n                if (state[x] == 0) {\n                    state[x] = -1;\n                } else if (state[x] == 1) {\n                    state[x] = 2;\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func numberOfSpecialChars(word string) (ans int) {\nstate := [27]int{}\nfor _, c := range word {\nx := c & 31\nif c&32 > 0 {\nif state[x] == 0 {\nstate[x] = 1\n} else if state[x] == 2 {\nstate[x] = -1\nans--\n}\n} else {\nif state[x] == 0 {\nstate[x] = -1\n} else if state[x] == 1 {\nstate[x] = 2\nans++\n}\n}\n}\nreturn\n}\n",
            "js": "/**\n * @param {string} word\n * @return {number}\n */\nvar numberOfSpecialChars = function(word) {\n    const ans = new Set(), set = new Set(), delSet = new Set(), upSet = new Set();\n    for (const w of word) {\n        let wNum = w.charCodeAt();\n        if (set.has(wNum + 32) && !upSet.has(wNum)) { // 加过b后出现了B,且且前面没有出现过B\n            ans.add(wNum);\n        } else if (wNum >= 97) { // 小写字母\n            if (ans.has(wNum - 32)) { // 小写在大写后面，一开始符合后面打破规则的需要去除\n                delSet.add(wNum);\n            } else {\n                set.add(wNum);\n            }\n        }\n        upSet.add(wNum);\n    }\n    return ans.size - delSet.size;\n};\n"
        },
        "cases": [
            {
                "input": "[\"\\\"aaAbcBC\\\"\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"\\\"abc\\\"\"]",
                "output": "[\"0\"]"
            },
            {
                "input": "[\"\\\"AbBCab\\\"\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int numberOfSpecialChars(String word) {",
            "cpp": "class Solution {\npublic:\n    int numberOfSpecialChars(string word) {",
            "go": "func numberOfSpecialChars(word string) int {\n\n}",
            "js": "/**\n * @param {string} word\n * @return {number}\n */\nvar numberOfSpecialChars = function(word) {",
            "python": "class Solution:\n    def numberOfSpecialChars(self, word: str) -> int:"
        },
        "time": "20240421",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "numberOfSpecialChars",
            "java": "numberOfSpecialChars",
            "cpp": "numberOfSpecialChars",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.numberOfSpecialChars(\"aaAbcBC\") == 3, \"Test 1 Error!\"\nassert my_solution.numberOfSpecialChars(\"abc\") == 0, \"Test 2 Error!\"\nassert my_solution.numberOfSpecialChars(\"AbBCab\") == 0, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String word_1 = \"aaAbcBC\";\n    int ans_1 = 3;\n    assert solution.numberOfSpecialChars(word_1) == ans_1;\n    String word_2 = \"abc\";\n    int ans_2 = 0;\n    assert solution.numberOfSpecialChars(word_2) == ans_2;\n    String word_3 = \"AbBCab\";\n    int ans_3 = 0;\n    assert solution.numberOfSpecialChars(word_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string word_1 = \"aaAbcBC\";\n    int ans_1 = 3;\n    assert(my_solution_1.numberOfSpecialChars(word_1) == ans_1);\n    Solution my_solution_2;\n    string word_2 = \"abc\";\n    int ans_2 = 0;\n    assert(my_solution_2.numberOfSpecialChars(word_2) == ans_2);\n    Solution my_solution_3;\n    string word_3 = \"AbBCab\";\n    int ans_3 = 0;\n    assert(my_solution_3.numberOfSpecialChars(word_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "word"
            ],
            "java": [
                "word"
            ],
            "cpp": [
                "word"
            ],
            "go": [],
            "js": []
        }
    },
    "3122": {
        "description": "给你一个大小为 m x n 的二维矩形 grid 。每次 操作 中，你可以将 任一 格子的值修改为 任意 非负整数。完成所有操作后，你需要确保每个格子 grid[i][j] 的值满足：\n如果下面相邻格子存在的话，它们的值相等，也就是 grid[i][j] == grid[i + 1][j]（如果存在）。\n如果右边相邻格子存在的话，它们的值不相等，也就是 grid[i][j] != grid[i][j + 1]（如果存在）。\n请你返回需要的 最少 操作数目。",
        "difficulty_level": "Middle",
        "note": "1 <= n, m <= 1000\n0 <= grid[i][j] <= 9",
        "codes": {
            "python": "class Solution:\n    def minimumOperations(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        cnt = [[0] * 10 for _ in range(n)]\n        for row in grid:\n            for j, x in enumerate(row):\n                cnt[j][x] += 1\n\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if i < 0:\n                return 0\n            return max(dfs(i - 1, k) + c for k, c in enumerate(cnt[i]) if k != j)\n\n        return m * n - dfs(n - 1, 10)\n",
            "java": "class Solution {\n    public int minimumOperations(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] cnt = new int[n][10];\n        for (int[] row : grid) {\n            for (int j = 0; j < n; j++) {\n                cnt[j][row[j]]++;\n            }\n        }\n        int[][] memo = new int[n][11];\n        for (int[] row : memo) {\n            Arrays.fill(row, -1); // -1 表示没有计算过\n        }\n        return m * n - dfs(n - 1, 10, cnt, memo);\n    }\n\n    private int dfs(int i, int j, int[][] cnt, int[][] memo) {\n        if (i < 0) {\n            return 0;\n        }\n        if (memo[i][j] != -1) { // 之前计算过\n            return memo[i][j];\n        }\n        int res = 0;\n        for (int k = 0; k < 10; ++k) {\n            if (k != j) {\n                res = Math.max(res, dfs(i - 1, k, cnt, memo) + cnt[i][k]);\n            }\n        }\n        return memo[i][j] = res; // 记忆化\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumOperations(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        vector<array<int, 10>> cnt(n);\n        for (auto& row : grid) {\n            for (int j = 0; j < n; j++) {\n                cnt[j][row[j]]++;\n            }\n        }\n\n        vector<vector<int>> memo(n, vector<int>(11, -1)); // -1 表示没有计算过\n        function<int(int, int)> dfs = [&](int i, int j) -> int {\n            if (i < 0) {\n                return 0;\n            }\n            auto& res = memo[i][j]; // 注意这里是引用\n            if (res != -1) { // 之前计算过\n                return res;\n            }\n            res = 0;\n            for (int k = 0; k < 10; k++) {\n                if (k != j) {\n                    res = max(res, dfs(i - 1, k) + cnt[i][k]);\n                }\n            }\n            return res;\n        };\n        return m * n - dfs(n - 1, 10);\n    }\n};\n",
            "go": "func minimumOperations(grid [][]int) (ans int) {\nm, n := len(grid), len(grid[0])\ncnt := make([][10]int, n)\nfor _, row := range grid {\nfor j, x := range row {\ncnt[j][x]++\n}\n}\n\nmemo := make([][11]int, n)\nfor i := range memo {\nfor j := range memo[i] {\nmemo[i][j] = -1\n}\n}\nvar dfs func(int, int) int\ndfs = func(i, j int) (res int) {\nif i < 0 {\nreturn\n}\np := &memo[i][j]\nif *p != -1 {\nreturn *p\n}\nfor k, c := range cnt[i] {\nif k != j {\nres = max(res, dfs(i-1, k)+c)\n}\n}\n*p = res\nreturn\n}\nreturn m*n - dfs(n-1, 10)\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[[1,0,2],[1,0,2]]\"]",
                "output": "[\"0\"]"
            },
            {
                "input": "[\"[[1,1,1],[0,0,0]]\"]",
                "output": "[\"3\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumOperations(int[][] grid) {",
            "cpp": "class Solution {\npublic:\n    int minimumOperations(vector<vector<int>>& grid) {",
            "go": "func minimumOperations(grid [][]int) int {\n\n}",
            "js": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumOperations = function(grid) {",
            "python": "class Solution:\n    def minimumOperations(self, grid: List[List[int]]) -> int:"
        },
        "time": "20240421",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumOperations",
            "java": "minimumOperations",
            "cpp": "minimumOperations",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumOperations([[1,0,2],[1,0,2]]) == 0, \"Test 1 Error!\"\nassert my_solution.minimumOperations([[1,1,1],[0,0,0]]) == 3, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] grid_1 = {{1,0,2},{1,0,2}};\n    int ans_1 = 0;\n    assert solution.minimumOperations(grid_1) == ans_1;\n    int[][] grid_2 = {{1,1,1},{0,0,0}};\n    int ans_2 = 3;\n    assert solution.minimumOperations(grid_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> grid_1 = {{1,0,2},{1,0,2}};\n    int ans_1 = 0;\n    assert(my_solution_1.minimumOperations(grid_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> grid_2 = {{1,1,1},{0,0,0}};\n    int ans_2 = 3;\n    assert(my_solution_2.minimumOperations(grid_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "grid"
            ],
            "java": [
                "grid"
            ],
            "cpp": [
                "grid"
            ],
            "go": [],
            "js": []
        }
    },
    "3123": {
        "description": "给你一个 n 个节点的无向带权图，节点编号为 0 到 n - 1 。图中总共有 m 条边，用二维数组 edges 表示，其中 edges[i] = [a_i, b_i, w_i] 表示节点 a_i 和 b_i 之间有一条边权为 w_i 的边。\n对于节点 0 为出发点，节点 n - 1 为结束点的所有最短路，你需要返回一个长度为 m 的 boolean 数组 answer ，如果 edges[i] 至少 在其中一条最短路上，那么 answer[i] 为 true ，否则 answer[i] 为 false 。\n请你返回数组 answer。\n注意，图可能不连通。",
        "difficulty_level": "Hard",
        "note": "2 <= n <= 5 * 10^4\nm == edges.length\n1 <= m <= min(5 * 10^4, n * (n - 1) / 2)\n0 <= a_i, b_i < n\na_i != b_i\n1 <= w_i <= 10^5\n图中没有重边。",
        "codes": {
            "python": "class Solution:\n    def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:\n        g = [[] for _ in range(n)]\n        for i, (x, y, w) in enumerate(edges):\n            g[x].append((y, w, i))\n            g[y].append((x, w, i))\n\n        # Dijkstra 算法模板\n        dis = [inf] * n\n        dis[0] = 0\n        h = [(0, 0)]\n        while h:\n            dx, x = heappop(h)\n            if dx > dis[x]:\n                continue\n            for y, w, _ in g[x]:\n                new_dis = dx + w\n                if new_dis < dis[y]:\n                    dis[y] = new_dis\n                    heappush(h, (new_dis, y))\n\n        ans = [False] * len(edges)\n        # 图不连通\n        if dis[-1] == inf:\n            return ans\n\n        # 从终点出发 DFS\n        vis = [False] * n\n        def dfs(y: int) -> None:\n            vis[y] = True\n            for x, w, i in g[y]:\n                if dis[x] + w != dis[y]:\n                    continue\n                ans[i] = True\n                if not vis[x]:\n                    dfs(x)\n        dfs(n - 1)\n        return ans\n",
            "java": "class Solution {\n    public boolean[] findAnswer(int n, int[][] edges) {\n        List<int[]>[] g = new ArrayList[n];\n        Arrays.setAll(g, i -> new ArrayList<>());\n        for (int i = 0; i < edges.length; i++) {\n            int[] e = edges[i];\n            int x = e[0], y = e[1], w = e[2];\n            g[x].add(new int[]{y, w, i});\n            g[y].add(new int[]{x, w, i});\n        }\n\n        long[] dis = new long[n];\n        Arrays.fill(dis, Long.MAX_VALUE);\n        dis[0] = 0;\n        PriorityQueue<long[]> pq = new PriorityQueue<>((a, b) -> Long.compare(a[0], b[0]));\n        pq.offer(new long[]{0, 0});\n        while (!pq.isEmpty()) {\n            long[] dxPair = pq.poll();\n            long dx = dxPair[0];\n            int x = (int) dxPair[1];\n            if (dx > dis[x]) {\n                continue;\n            }\n            for (int[] t : g[x]) {\n                int y = t[0];\n                int w = t[1];\n                long newDis = dx + w;\n                if (newDis < dis[y]) {\n                    dis[y] = newDis;\n                    pq.offer(new long[]{newDis, y});\n                }\n            }\n        }\n\n        boolean[] ans = new boolean[edges.length];\n        // 图不连通\n        if (dis[n - 1] == Long.MAX_VALUE) {\n            return ans;\n        }\n\n        // 从终点出发 DFS\n        boolean[] vis = new boolean[n];\n        dfs(n - 1, g, dis, ans, vis);\n        return ans;\n    }\n\n    private void dfs(int y, List<int[]>[] g, long[] dis, boolean[] ans, boolean[] vis) {\n        vis[y] = true;\n        for (int[] t : g[y]) {\n            int x = t[0];\n            int w = t[1];\n            int i = t[2];\n            if (dis[x] + w != dis[y]) {\n                continue;\n            }\n            ans[i] = true;\n            if (!vis[x]) {\n                dfs(x, g, dis, ans, vis);\n            }\n        }\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    vector<bool> findAnswer(int n, vector<vector<int>>& edges) {\n        vector<vector<tuple<int, int, int>>> g(n);\n        for (int i = 0; i < edges.size(); i++) {\n            auto& e = edges[i];\n            int x = e[0], y = e[1], w = e[2];\n            g[x].emplace_back(y, w, i);\n            g[y].emplace_back(x, w, i);\n        }\n\n        vector<long long> dis(n, LLONG_MAX);\n        dis[0] = 0;\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<>> pq;\n        pq.emplace(0, 0);\n        while (!pq.empty()) {\n            auto [dx, x] = pq.top();\n            pq.pop();\n            if (dx > dis[x]) {\n                continue;\n            }\n            for (auto [y, w, _] : g[x]) {\n                int new_dis = dx + w;\n                if (new_dis < dis[y]) {\n                    dis[y] = new_dis;\n                    pq.emplace(new_dis, y);\n                }\n            }\n        }\n\n        vector<bool> ans(edges.size());\n        // 图不连通\n        if (dis[n - 1] == LLONG_MAX) {\n            return ans;\n        }\n\n        // 从终点出发 DFS\n        vector<int> vis(n);\n        function<void(int)> dfs = [&](int y) {\n            vis[y] = true;\n            for (auto [x, w, i] : g[y]) {\n                if (dis[x] + w != dis[y]) {\n                    continue;\n                }\n                ans[i] = true;\n                if (!vis[x]) {\n                    dfs(x);\n                }\n            }\n        };\n        dfs(n - 1);\n        return ans;\n    }\n};\n",
            "go": "func findAnswer(n int, edges [][]int) []bool {\ntype edge struct{ to, w, i int }\ng := make([][]edge, n)\nfor i, e := range edges {\nx, y, w := e[0], e[1], e[2]\ng[x] = append(g[x], edge{y, w, i})\ng[y] = append(g[y], edge{x, w, i})\n}\n\n// Dijkstra 算法模板\ndis := make([]int, n)\nfor i := 1; i < n; i++ {\ndis[i] = math.MaxInt\n}\nh := hp{{}}\nfor len(h) > 0 {\np := heap.Pop(&h).(pair)\nx := p.x\nif p.dis > dis[x] {\ncontinue\n}\nfor _, e := range g[x] {\ny := e.to\nnewD := p.dis + e.w\nif newD < dis[y] {\ndis[y] = newD\nheap.Push(&h, pair{newD, y})\n}\n}\n}\n\nans := make([]bool, len(edges))\n// 图不连通\nif dis[n-1] == math.MaxInt {\nreturn ans\n}\n\n// 从终点出发 DFS\nvis := make([]bool, n)\nvar dfs func(int)\ndfs = func(y int) {\nvis[y] = true\nfor _, e := range g[y] {\nx := e.to\nif dis[x]+e.w != dis[y] {\ncontinue\n}\nans[e.i] = true\nif !vis[x] {\ndfs(x)\n}\n}\n}\ndfs(n - 1)\nreturn ans\n}\n\ntype pair struct{ dis, x int }\ntype hp []pair\nfunc (h hp) Len() int           { return len(h) }\nfunc (h hp) Less(i, j int) bool { return h[i].dis < h[j].dis }\nfunc (h hp) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\nfunc (h *hp) Push(v any)        { *h = append(*h, v.(pair)) }\nfunc (h *hp) Pop() (v any)      { a := *h; *h, v = a[:len(a)-1], a[len(a)-1]; return }\n",
            "js": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {boolean[]}\n */\n\n// 计算从start出发到各节点的最短路径\nfunction dijkstra(g, start) {\n    const dis = new Array(g.length).fill(Infinity)\n    dis[start] = 0\n    // https://github.com/datastructures-js/priority-queue/blob/v5/src/priorityQueue.js\n    const queue = new PriorityQueue({\n        compare: (a, b) => a.wight - b.wight\n    })\n    queue.enqueue({ node: start, wight: 0 })\n    while (!queue.isEmpty()) {\n        const { node, wight } = queue.dequeue()\n        if (wight > dis[node]) {\n            continue; \n        }\n        for (const [v, w] of g[node]) {\n            const nextW = wight + w;\n            if (nextW < dis[v]) {\n                dis[v] = nextW;\n                queue.enqueue({ node: v, wight: nextW })\n            } \n        }\n    }\n    return dis\n}\nvar findAnswer = function(n, edges) {\n    const g = Array.from({ length: n }, () => [])\n    for (const [a, b, w] of edges) {\n        g[a].push([b, w])\n        g[b].push([a, w])\n    }\n    const dis0 = dijkstra(g, 0)\n    // 从节点0无法到达n-1节点\n    if (dis0[n - 1] === Infinity) {\n        return new Array(edges.length).fill(false)\n    }\n    const dis1 = dijkstra(g, n - 1)\n    const ans = []\n    for (const [a, b, w] of edges) {\n        // 满足下面两个情况，代表至少一条最短路径会经过 a b。 \n        // 0 -> a -> b -> n - 1 的路径值等于 0 -> n - 1\n        // 0 -> b -> a -> n - 1 的路径值等于 0 -> n - 1\n        if (\n            (dis0[a] + dis1[b] + w === dis0[n - 1] ||\n            dis0[b] + dis1[a] + w === dis0[n - 1])\n        ) {\n            ans.push(true)\n        } else {\n            ans.push(false)\n        }\n    }\n    return ans\n};\n"
        },
        "cases": [
            {
                "input": "[\"6\",\"[[0,1,4],[0,2,1],[1,3,2],[1,4,3],[1,5,1],[2,3,1],[3,5,3],[4,5,2]]\"]",
                "output": "[\"[true,true,true,false,true,true,true,false]\"]"
            },
            {
                "input": "[\"4\",\"[[2,0,1],[0,1,1],[0,3,4],[3,2,2]]\"]",
                "output": "[\"[true,false,false,true]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public boolean[] findAnswer(int n, int[][] edges) {",
            "cpp": "class Solution {\npublic:\n    vector<bool> findAnswer(int n, vector<vector<int>>& edges) {",
            "go": "func findAnswer(n int, edges [][]int) []bool {\n\n}",
            "js": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {boolean[]}\n */\nvar findAnswer = function(n, edges) {",
            "python": "class Solution:\n    def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:"
        },
        "time": "20240421",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "findAnswer",
            "java": "findAnswer",
            "cpp": "findAnswer",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.findAnswer(6, [[0,1,4],[0,2,1],[1,3,2],[1,4,3],[1,5,1],[2,3,1],[3,5,3],[4,5,2]]) == [True,True,True,False,True,True,True,False], \"Test 1 Error!\"\nassert my_solution.findAnswer(4, [[2,0,1],[0,1,1],[0,3,4],[3,2,2]]) == [True,False,False,True], \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int n_1 = 6;\n    int[][] edges_1 = {{0,1,4},{0,2,1},{1,3,2},{1,4,3},{1,5,1},{2,3,1},{3,5,3},{4,5,2}};\n    boolean[] ans_1 = {true,true,true,false,true,true,true,false};\n    assert Arrays.equals(solution.findAnswer(n_1, edges_1), ans_1);\n    int n_2 = 4;\n    int[][] edges_2 = {{2,0,1},{0,1,1},{0,3,4},{3,2,2}};\n    boolean[] ans_2 = {true,false,false,true};\n    assert Arrays.equals(solution.findAnswer(n_2, edges_2), ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int n_1 = 6;\n    vector<vector<int>> edges_1 = {{0,1,4},{0,2,1},{1,3,2},{1,4,3},{1,5,1},{2,3,1},{3,5,3},{4,5,2}};\n    vector<bool> ans_1 = {true,true,true,false,true,true,true,false};\n    assert(my_solution_1.findAnswer(n_1, edges_1) == ans_1);\n    Solution my_solution_2;\n    int n_2 = 4;\n    vector<vector<int>> edges_2 = {{2,0,1},{0,1,1},{0,3,4},{3,2,2}};\n    vector<bool> ans_2 = {true,false,false,true};\n    assert(my_solution_2.findAnswer(n_2, edges_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "n",
                "edges"
            ],
            "java": [
                "n",
                "edges"
            ],
            "cpp": [
                "n",
                "edges"
            ],
            "go": [],
            "js": []
        }
    },
    "3131": {
        "description": "给你两个长度相等的数组 nums1 和 nums2。\n数组 nums1 中的每个元素都与变量 x 所表示的整数相加。如果 x 为负数，则表现为元素值的减少。\n在与 x 相加后，nums1 和 nums2 相等 。当两个数组中包含相同的整数，并且这些整数出现的频次相同时，两个数组 相等 。\n返回整数 x 。",
        "difficulty_level": "Easy",
        "note": "1 <= nums1.length == nums2.length <= 100\n0 <= nums1[i], nums2[i] <= 1000\n测试用例以这样的方式生成：存在一个整数 x，使得 nums1 中的每个元素都与 x 相加后，nums1 与 nums2 相等。",
        "codes": {
            "python": "class Solution:\n    def addedInteger(self, nums1: List[int], nums2: List[int]) -> int:\n        return min(nums2) - min(nums1)\n",
            "java": "class Solution {\n    public int addedInteger(int[] nums1, int[] nums2) {\n        int min1 = Integer.MAX_VALUE;\n        int min2 = Integer.MAX_VALUE;\n        for (int i = 0; i < nums1.length; i++) {\n            min1 = Math.min(min1, nums1[i]);\n            min2 = Math.min(min2, nums2[i]);\n        }\n        return min2 - min1;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int addedInteger(vector<int>& nums1, vector<int>& nums2) {\n        return ranges::min(nums2) - ranges::min(nums1);\n    }\n};\n",
            "go": "func addedInteger(nums1, nums2 []int) int {\nreturn slices.Min(nums2) - slices.Min(nums1)\n}\n",
            "js": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar addedInteger = function(nums1, nums2) {\n    return Math.min(...nums2) - Math.min(...nums1)\n};\n"
        },
        "cases": [
            {
                "input": "[\"[2,6,4]\",\"[9,7,5]\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[10]\",\"[5]\"]",
                "output": "[\"-5\"]"
            },
            {
                "input": "[\"[1,1,1,1]\",\"[1,1,1,1]\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int addedInteger(int[] nums1, int[] nums2) {",
            "cpp": "class Solution {\npublic:\n    int addedInteger(vector<int>& nums1, vector<int>& nums2) {",
            "go": "func addedInteger(nums1 []int, nums2 []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar addedInteger = function(nums1, nums2) {",
            "python": "class Solution:\n    def addedInteger(self, nums1: List[int], nums2: List[int]) -> int:"
        },
        "time": "20240428",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "addedInteger",
            "java": "addedInteger",
            "cpp": "addedInteger",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.addedInteger([2,6,4], [9,7,5]) == 3, \"Test 1 Error!\"\nassert my_solution.addedInteger([10], [5]) == -5, \"Test 2 Error!\"\nassert my_solution.addedInteger([1,1,1,1], [1,1,1,1]) == 0, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums1_1 = {2,6,4};\n    int[] nums2_1 = {9,7,5};\n    int ans_1 = 3;\n    assert solution.addedInteger(nums1_1, nums2_1) == ans_1;\n    int[] nums1_2 = {10};\n    int[] nums2_2 = {5};\n    int ans_2 = -5;\n    assert solution.addedInteger(nums1_2, nums2_2) == ans_2;\n    int[] nums1_3 = {1,1,1,1};\n    int[] nums2_3 = {1,1,1,1};\n    int ans_3 = 0;\n    assert solution.addedInteger(nums1_3, nums2_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums1_1 = {2,6,4};\n    vector<int> nums2_1 = {9,7,5};\n    int ans_1 = 3;\n    assert(my_solution_1.addedInteger(nums1_1, nums2_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums1_2 = {10};\n    vector<int> nums2_2 = {5};\n    int ans_2 = -5;\n    assert(my_solution_2.addedInteger(nums1_2, nums2_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums1_3 = {1,1,1,1};\n    vector<int> nums2_3 = {1,1,1,1};\n    int ans_3 = 0;\n    assert(my_solution_3.addedInteger(nums1_3, nums2_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums1",
                "nums2"
            ],
            "java": [
                "nums1",
                "nums2"
            ],
            "cpp": [
                "nums1",
                "nums2"
            ],
            "go": [],
            "js": []
        }
    },
    "3132": {
        "description": "给你两个整数数组 nums1 和 nums2。\n从 nums1 中移除两个元素，并且所有其他元素都与变量 x 所表示的整数相加。如果 x 为负数，则表现为元素值的减少。\n执行上述操作后，nums1 和 nums2 相等 。当两个数组中包含相同的整数，并且这些整数出现的频次相同时，两个数组 相等 。\n返回能够实现数组相等的 最小 整数 x 。",
        "difficulty_level": "Middle",
        "note": "3 <= nums1.length <= 200\nnums2.length == nums1.length - 2\n0 <= nums1[i], nums2[i] <= 1000\n测试用例以这样的方式生成：存在一个整数 x，nums1 中的每个元素都与 x 相加后，再移除两个元素，nums1 可以与 nums2 相等。",
        "codes": {
            "python": "class Solution:\n    def minimumAddedInteger(self, nums1: List[int], nums2: List[int]) -> int:\n        nums1.sort()\n        nums2.sort()\n        # 枚举保留 nums1[2] 或者 nums1[1] 或者 nums1[0]\n        # 倒着枚举是因为 nums1[i] 越大答案越小，第一个满足的就是答案\n        for i in range(2, 0, -1):\n            diff = nums2[0] - nums1[i]\n            # 在 {nums1[i] + diff} 中找子序列 nums2\n            j = 0\n            for v in nums1[i:]:\n                if nums2[j] == v + diff:\n                    j += 1\n                    # nums2 是 {nums1[i] + diff} 的子序列\n                    if j == len(nums2):\n                        return diff\n        # 题目保证答案一定存在\n        return nums2[0] - nums1[0]\n",
            "java": "class Solution {\n    public int minimumAddedInteger(int[] nums1, int[] nums2) {\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        // 枚举保留 nums1[2] 或者 nums1[1] 或者 nums1[0]\n        // 倒着枚举是因为 nums1[i] 越大答案越小，第一个满足的就是答案\n        for (int i = 2; i > 0; i--) {\n            int diff = nums2[0] - nums1[i];\n            // 在 {nums1[i] + diff} 中找子序列 nums2\n            int j = 0;\n            for (int k = i; k < nums1.length; k++) {\n                if (nums2[j] == nums1[k] + diff && ++j == nums2.length) {\n                    // nums2 是 {nums1[i] + diff} 的子序列\n                    return diff;\n                }\n            }\n        }\n        // 题目保证答案一定存在\n        return nums2[0] - nums1[0];\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumAddedInteger(vector<int>& nums1, vector<int>& nums2) {\n        ranges::sort(nums1);\n        ranges::sort(nums2);\n        // 枚举保留 nums1[2] 或者 nums1[1] 或者 nums1[0]\n        // 倒着枚举是因为 nums1[i] 越大答案越小，第一个满足的就是答案\n        for (int i = 2; i; i--) {\n            int diff = nums2[0] - nums1[i];\n            // 在 {nums1[i] + diff} 中找子序列 nums2\n            int j = 0;\n            for (int k = i; k < nums1.size(); k++) {\n                if (nums2[j] == nums1[k] + diff && ++j == nums2.size()) {\n                    // nums2 是 {nums1[i] + diff} 的子序列\n                    return diff;\n                }\n            }\n        }\n        // 题目保证答案一定存在\n        return nums2[0] - nums1[0];\n    }\n};\n",
            "go": "func minimumAddedInteger(nums1, nums2 []int) int {\nslices.Sort(nums1)\nslices.Sort(nums2)\n// 枚举保留 nums1[2] 或者 nums1[1] 或者 nums1[0]\n// 倒着枚举是因为 nums1[i] 越大答案越小，第一个满足的就是答案\nfor i := 2; i > 0; i-- {\ndiff := nums2[0] - nums1[i]\n// 在 {nums1[i] + diff} 中找子序列 nums2\nj := 0\nfor _, v := range nums1[i:] {\nif nums2[j] == v+diff {\nj++\n// nums2 是 {nums1[i] + diff} 的子序列\nif j == len(nums2) {\nreturn diff\n}\n}\n}\n}\n// 题目保证答案一定存在\nreturn nums2[0] - nums1[0]\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[4,20,16,12,8]\",\"[14,18,10]\"]",
                "output": "[\"-2\"]"
            },
            {
                "input": "[\"[3,5,5,3]\",\"[7,7]\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumAddedInteger(int[] nums1, int[] nums2) {",
            "cpp": "class Solution {\npublic:\n    int minimumAddedInteger(vector<int>& nums1, vector<int>& nums2) {",
            "go": "func minimumAddedInteger(nums1 []int, nums2 []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar minimumAddedInteger = function(nums1, nums2) {",
            "python": "class Solution:\n    def minimumAddedInteger(self, nums1: List[int], nums2: List[int]) -> int:"
        },
        "time": "20240428",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumAddedInteger",
            "java": "minimumAddedInteger",
            "cpp": "minimumAddedInteger",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumAddedInteger([4,20,16,12,8], [14,18,10]) == -2, \"Test 1 Error!\"\nassert my_solution.minimumAddedInteger([3,5,5,3], [7,7]) == 2, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums1_1 = {4,20,16,12,8};\n    int[] nums2_1 = {14,18,10};\n    int ans_1 = -2;\n    assert solution.minimumAddedInteger(nums1_1, nums2_1) == ans_1;\n    int[] nums1_2 = {3,5,5,3};\n    int[] nums2_2 = {7,7};\n    int ans_2 = 2;\n    assert solution.minimumAddedInteger(nums1_2, nums2_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums1_1 = {4,20,16,12,8};\n    vector<int> nums2_1 = {14,18,10};\n    int ans_1 = -2;\n    assert(my_solution_1.minimumAddedInteger(nums1_1, nums2_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums1_2 = {3,5,5,3};\n    vector<int> nums2_2 = {7,7};\n    int ans_2 = 2;\n    assert(my_solution_2.minimumAddedInteger(nums1_2, nums2_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums1",
                "nums2"
            ],
            "java": [
                "nums1",
                "nums2"
            ],
            "cpp": [
                "nums1",
                "nums2"
            ],
            "go": [],
            "js": []
        }
    },
    "3133": {
        "description": "给你两个整数 n 和 x 。你需要构造一个长度为 n 的 正整数 数组 nums ，对于所有 0 <= i < n - 1 ，满足 nums[i + 1] 大于 nums[i] ，并且数组 nums 中所有元素的按位 AND 运算结果为 x 。\n返回 nums[n - 1] 可能的 最小 值。",
        "difficulty_level": "Middle",
        "note": "1 <= n, x <= 10^8",
        "codes": {
            "python": "class Solution:\n    def minEnd(self, n: int, x: int) -> int:\n        n -= 1  # 先把 n 减一，这样下面讨论的 n 就是原来的 n-1\n        i = j = 0\n        while n >> j:\n            # x 的第 i 个比特值是 0，即「空位」\n            if (x >> i & 1) == 0:\n                # 空位填入 n 的第 j 个比特值\n                x |= (n >> j & 1) << i\n                j += 1\n            i += 1\n        return x\n",
            "java": "class Solution {\n    public long minEnd(int n, int x) {\n        n--; // 先把 n 减一，这样下面讨论的 n 就是原来的 n-1\n        long ans = x;\n        int i = 0, j = 0;\n        while ((n >> j) > 0) {\n            // x 的第 i 个比特值是 0，即「空位」\n            if ((ans >> i & 1) == 0) {\n                // 空位填入 n 的第 j 个比特值\n                ans |= (long) (n >> j & 1) << i;\n                j++;\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long minEnd(int n, int x) {\n        n--; // 先把 n 减一，这样下面讨论的 n 就是原来的 n-1\n        long long ans = x;\n        int i = 0, j = 0;\n        while (n >> j) {\n            // x 的第 i 个比特值是 0，即「空位」\n            if ((ans >> i & 1) == 0) {\n                // 空位填入 n 的第 j 个比特值\n                ans |= (long long) (n >> j & 1) << i;\n                j++;\n            }\n            i++;\n        }\n        return ans;\n    }\n};\n",
            "go": "func minEnd(n, x int) int64 {\nn-- // 先把 n 减一，这样下面讨论的 n 就是原来的 n-1\ni, j := 0, 0\nfor n>>j > 0 {\n// x 的第 i 个比特值是 0，即「空位」\nif x>>i&1 == 0 {\n// 空位填入 n 的第 j 个比特值\nx |= n >> j & 1 << i\nj++\n}\ni++\n}\nreturn int64(x)\n}\n",
            "js": "/**\n * @param {number} n\n * @param {number} x\n * @return {number}\n */\nvar minEnd = function(n, x) {\n  let n1 = n - 1\n  let r = x\n  let mask = 1\n  while (n1 > 0 && mask <= 1e8) {\n    while ((r & mask) > 0) {\n      mask <<= 1\n    }\n    if (n1 & 1) {\n      r |= mask\n    }\n    n1 >>= 1\n    mask <<= 1\n  }\n  if (n1 > 0) {\n    return parseInt(n1.toString(2) + mask.toString(2).slice(1), 2) + r\n  }\n  return r\n};\n"
        },
        "cases": [
            {
                "input": "[\"3\",\"4\"]",
                "output": "[\"6\"]"
            },
            {
                "input": "[\"2\",\"7\"]",
                "output": "[\"15\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long minEnd(int n, int x) {",
            "cpp": "class Solution {\npublic:\n    long long minEnd(int n, int x) {",
            "go": "func minEnd(n int, x int) int64 {\n\n}",
            "js": "/**\n * @param {number} n\n * @param {number} x\n * @return {number}\n */\nvar minEnd = function(n, x) {",
            "python": "class Solution:\n    def minEnd(self, n: int, x: int) -> int:"
        },
        "time": "20240428",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minEnd",
            "java": "minEnd",
            "cpp": "minEnd",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minEnd(3, 4) == 6, \"Test 1 Error!\"\nassert my_solution.minEnd(2, 7) == 15, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int n_1 = 3;\n    int x_1 = 4;\n    long ans_1 = 6;\n    assert solution.minEnd(n_1, x_1) == ans_1;\n    int n_2 = 2;\n    int x_2 = 7;\n    long ans_2 = 15;\n    assert solution.minEnd(n_2, x_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int n_1 = 3;\n    int x_1 = 4;\n    long long ans_1 = 6;\n    assert(my_solution_1.minEnd(n_1, x_1) == ans_1);\n    Solution my_solution_2;\n    int n_2 = 2;\n    int x_2 = 7;\n    long long ans_2 = 15;\n    assert(my_solution_2.minEnd(n_2, x_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "n",
                "x"
            ],
            "java": [
                "n",
                "x"
            ],
            "cpp": [
                "n",
                "x"
            ],
            "go": [],
            "js": []
        }
    },
    "3134": {
        "description": "给你一个整数数组 nums 。数组 nums 的 唯一性数组 是一个按元素从小到大排序的数组，包含了 nums 的所有非空子数组中不同元素的个数。\n换句话说，这是由所有 0 <= i <= j < nums.length 的 distinct(nums[i..j]) 组成的递增数组。其中，distinct(nums[i..j]) 表示从下标 i 到下标 j 的子数组中不同元素的数量。\n返回 nums 唯一性数组 的 中位数 。\n注意，数组的 中位数 定义为有序数组的中间元素。如果有两个中间元素，则取值较小的那个。",
        "difficulty_level": "Hard",
        "note": "1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5",
        "codes": {
            "python": "class Solution:\n    def medianOfUniquenessArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        k = (n * (n + 1) // 2 + 1) // 2\n\n        def check(upper: int) -> bool:\n            cnt = l = 0\n            freq = defaultdict(int)\n            for r, in_ in enumerate(nums):\n                freq[in_] += 1\n                while len(freq) > upper:\n                    out = nums[l]\n                    freq[out] -= 1\n                    if freq[out] == 0:\n                        del freq[out]\n                    l += 1\n                cnt += r - l + 1\n                if cnt >= k:\n                    return True\n            return False\n\n        return bisect_left(range(len(set(nums))), True, 1, key=check)\n",
            "java": "class Solution {\n    public int medianOfUniquenessArray(int[] nums) {\n        int n = nums.length;\n        long k = ((long) n * (n + 1) / 2 + 1) / 2;\n        int left = 0;\n        int right = n;\n        while (left + 1 < right) {\n            int mid = (left + right) / 2;\n            if (check(nums, mid, k)) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        return right;\n    }\n\n    private boolean check(int[] nums, int upper, long k) {\n        long cnt = 0;\n        int l = 0;\n        HashMap<Integer, Integer> freq = new HashMap<>();\n        for (int r = 0; r < nums.length; r++) {\n            freq.merge(nums[r], 1, Integer::sum);\n            while (freq.size() > upper) {\n                int out = nums[l++];\n                if (freq.merge(out, -1, Integer::sum) == 0) {\n                    freq.remove(out);\n                }\n            }\n            cnt += r - l + 1;\n            if (cnt >= k) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int medianOfUniquenessArray(vector<int>& nums) {\n        int n = nums.size();\n        long long k = ((long long) n * (n + 1) / 2 + 1) / 2;\n\n        auto check = [&](int upper) {\n            long long cnt = 0;\n            int l = 0;\n            unordered_map<int, int> freq;\n            for (int r = 0; r < n; r++) {\n                freq[nums[r]]++;\n                while (freq.size() > upper) {\n                    int out = nums[l++];\n                    if (--freq[out] == 0) {\n                        freq.erase(out);\n                    }\n                }\n                cnt += r - l + 1;\n                if (cnt >= k) {\n                    return true;\n                }\n            }\n            return false;\n        };\n\n        int left = 0, right = n;\n        while (left + 1 < right) {\n            int mid = (left + right) / 2;\n            (check(mid) ? right : left) = mid;\n        }\n        return right;\n    }\n};\n",
            "go": "func medianOfUniquenessArray(nums []int) int {\nn := len(nums)\nk := (n*(n+1)/2 + 1) / 2\nans := 1 + sort.Search(n-1, func(upper int) bool {\nupper++\ncnt := 0\nl := 0\nfreq := map[int]int{}\nfor r, in := range nums {\nfreq[in]++\nfor len(freq) > upper {\nout := nums[l]\nfreq[out]--\nif freq[out] == 0 {\ndelete(freq, out)\n}\nl++\n}\ncnt += r - l + 1\nif cnt >= k {\nreturn true\n}\n}\nreturn false\n})\nreturn ans\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[1,2,3]\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"[3,4,3,4,5]\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[4,3,5,4]\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int medianOfUniquenessArray(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    int medianOfUniquenessArray(vector<int>& nums) {",
            "go": "func medianOfUniquenessArray(nums []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar medianOfUniquenessArray = function(nums) {",
            "python": "class Solution:\n    def medianOfUniquenessArray(self, nums: List[int]) -> int:"
        },
        "time": "20240428",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "medianOfUniquenessArray",
            "java": "medianOfUniquenessArray",
            "cpp": "medianOfUniquenessArray",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.medianOfUniquenessArray([1,2,3]) == 1, \"Test 1 Error!\"\nassert my_solution.medianOfUniquenessArray([3,4,3,4,5]) == 2, \"Test 2 Error!\"\nassert my_solution.medianOfUniquenessArray([4,3,5,4]) == 2, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,3};\n    int ans_1 = 1;\n    assert solution.medianOfUniquenessArray(nums_1) == ans_1;\n    int[] nums_2 = {3,4,3,4,5};\n    int ans_2 = 2;\n    assert solution.medianOfUniquenessArray(nums_2) == ans_2;\n    int[] nums_3 = {4,3,5,4};\n    int ans_3 = 2;\n    assert solution.medianOfUniquenessArray(nums_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,3};\n    int ans_1 = 1;\n    assert(my_solution_1.medianOfUniquenessArray(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {3,4,3,4,5};\n    int ans_2 = 2;\n    assert(my_solution_2.medianOfUniquenessArray(nums_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {4,3,5,4};\n    int ans_3 = 2;\n    assert(my_solution_3.medianOfUniquenessArray(nums_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3136": {
        "description": "有效单词 需要满足以下几个条件：至少 包含 3 个字符。由数字 0-9 和英文大小写字母组成。（不必包含所有这类字符。）至少 包含一个 元音字母 。至少 包含一个 辅音字母 。\n给你一个字符串 word 。如果 word 是一个有效单词，则返回 true ，否则返回 false 。\n注意：\n'a'、'e'、'i'、'o'、'u' 及其大写形式都属于 元音字母 。\n英文中的 辅音字母 是指那些除元音字母之外的字母。",
        "difficulty_level": "Easy",
        "note": "1 <= word.length <= 20\nword 由英文大写和小写字母、数字、'@'、'#' 和 '$' 组成。",
        "codes": {
            "python": "class Solution:\n    def isValid(self, word: str) -> bool:\n        if len(word) < 3:\n            return False\n        f = [False] * 2\n        for c in word:\n            if c.isalpha():\n                f[c.lower() in \"aeiou\"] = True\n            elif not c.isdigit():\n                return False\n        return all(f)\n",
            "java": "class Solution {\n    public boolean isValid(String word) {\n        if (word.length() < 3) {\n            return false;\n        }\n        boolean[] f = new boolean[2];\n        Arrays.fill(f, false);\n        for (char c : word.toCharArray()) {\n            if (Character.isAlphabetic(c)) {\n                c = Character.toLowerCase(c);\n                f[c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ? 1 : 0] = true;\n            } else if (!Character.isDigit(c)) {\n                return false;\n            }\n        }\n        return f[0] && f[1];\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    bool isValid(string word) {\n        if (word.length() < 3) {\n            return false;\n        }\n        bool f[2]{};\n        for (char c : word) {\n            if (isalpha(c)) {\n                c = tolower(c);\n                f[c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'] = true;\n            } else if (!isdigit(c)) {\n                return false;\n            }\n        }\n        return f[0] && f[1];\n    }\n};\n",
            "go": "func isValid(word string) bool {\nif len(word) < 3 {\nreturn false\n}\nvar f0, f1 bool\nfor _, c := range word {\nif unicode.IsLetter(c) {\nif strings.ContainsRune(\"aeiou\", unicode.ToLower(c)) {\nf1 = true\n} else {\nf0 = true\n}\n} else if !unicode.IsDigit(c) {\nreturn false\n}\n}\nreturn f0 && f1\n}\n",
            "js": "/**\n * @param {string} word\n * @return {boolean}\n */\nvar isValid = function (word) {\n    const a = /[aeiou]/i.test(word)\n    const b = /[bcdfghjklmnpqrstvwxyz]/i.test(word)\n    const c = /^[0-9a-zA-z]{3,}$/igm.test(word)\n    return a && b && c\n};\n"
        },
        "cases": [
            {
                "input": "[\"\\\"234Adas\\\"\"]",
                "output": "[\"true\"]"
            },
            {
                "input": "[\"\\\"b3\\\"\"]",
                "output": "[\"false\"]"
            },
            {
                "input": "[\"\\\"a3$e\\\"\"]",
                "output": "[\"false\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public boolean isValid(String word) {",
            "cpp": "class Solution {\npublic:\n    bool isValid(string word) {",
            "go": "func isValid(word string) bool {\n\n}",
            "js": "/**\n * @param {string} word\n * @return {boolean}\n */\nvar isValid = function(word) {",
            "python": "class Solution:\n    def isValid(self, word: str) -> bool:"
        },
        "time": "20240505",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "isValid",
            "java": "isValid",
            "cpp": "isValid",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.isValid(\"234Adas\") == True, \"Test 1 Error!\"\nassert my_solution.isValid(\"b3\") == False, \"Test 2 Error!\"\nassert my_solution.isValid(\"a3$e\") == False, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String word_1 = \"234Adas\";\n    boolean ans_1 = true;\n    assert solution.isValid(word_1) == ans_1;\n    String word_2 = \"b3\";\n    boolean ans_2 = false;\n    assert solution.isValid(word_2) == ans_2;\n    String word_3 = \"a3$e\";\n    boolean ans_3 = false;\n    assert solution.isValid(word_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string word_1 = \"234Adas\";\n    bool ans_1 = true;\n    assert(my_solution_1.isValid(word_1) == ans_1);\n    Solution my_solution_2;\n    string word_2 = \"b3\";\n    bool ans_2 = false;\n    assert(my_solution_2.isValid(word_2) == ans_2);\n    Solution my_solution_3;\n    string word_3 = \"a3$e\";\n    bool ans_3 = false;\n    assert(my_solution_3.isValid(word_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "word"
            ],
            "java": [
                "word"
            ],
            "cpp": [
                "word"
            ],
            "go": [],
            "js": []
        }
    },
    "3137": {
        "description": "给你一个长度为 n 的字符串 word 和一个整数 k ，其中 k 是 n 的因数。\n在一次操作中，你可以选择任意两个下标 i 和 j，其中 0 <= i, j < n ，且这两个下标都可以被 k 整除，然后用从 j 开始的长度为 k 的子串替换从 i 开始的长度为 k 的子串。也就是说，将子串 word[i..i + k - 1] 替换为子串 word[j..j + k - 1] 。\n返回使 word 成为 K 周期字符串 所需的 最少 操作次数。\n如果存在某个长度为 k 的字符串 s，使得 word 可以表示为任意次数连接 s ，则称字符串 word 是 K 周期字符串 。例如，如果 word == \"ababab\"，那么 word 就是 s = \"ab\" 时的 2 周期字符串 。",
        "difficulty_level": "Middle",
        "note": "1 <= n == word.length <= 10^5\n1 <= k <= word.length\nk 能整除 word.length 。\nword 仅由小写英文字母组成。",
        "codes": {
            "python": "class Solution:\n    def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -> int:\n        n = len(word)\n        cnt = Counter(word[i - k: i] for i in range(k, n + 1, k))\n        mx = max(cnt.values())\n        return n // k - mx\n",
            "java": "class Solution {\n    public int minimumOperationsToMakeKPeriodic(String word, int k) {\n        int n = word.length();\n        int mx = 0;\n        HashMap<String, Integer> cnt = new HashMap<>();\n        for (int i = k; i <= n; i += k) {\n            String sub = word.substring(i - k, i);\n            int c = cnt.merge(sub, 1, Integer::sum); // c = ++cnt[sub]\n            mx = Math.max(mx, c);\n        }\n        return n / k - mx;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumOperationsToMakeKPeriodic(string word, int k) {\n        int n = word.size(), mx = 0;\n        unordered_map<string, int> cnt;\n        for (int i = k; i <= n; i += k) {\n            mx = max(mx, ++cnt[word.substr(i - k, k)]);\n        }\n        return n / k - mx;\n    }\n};\n",
            "go": "func minimumOperationsToMakeKPeriodic(word string, k int) int {\nn := len(word)\ncnt := map[string]int{}\nfor i := k; i <= n; i += k {\ncnt[word[i-k:i]]++\n}\nmx := 0\nfor _, c := range cnt {\nmx = max(mx, c)\n}\nreturn n/k - mx\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"\\\"leetcodeleet\\\"\",\"4\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"\\\"leetcoleet\\\"\",\"2\"]",
                "output": "[\"3\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumOperationsToMakeKPeriodic(String word, int k) {",
            "cpp": "class Solution {\npublic:\n    int minimumOperationsToMakeKPeriodic(string word, int k) {",
            "go": "func minimumOperationsToMakeKPeriodic(word string, k int) int {\n\n}",
            "js": "/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar minimumOperationsToMakeKPeriodic = function(word, k) {",
            "python": "class Solution:\n    def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -> int:"
        },
        "time": "20240505",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumOperationsToMakeKPeriodic",
            "java": "minimumOperationsToMakeKPeriodic",
            "cpp": "minimumOperationsToMakeKPeriodic",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumOperationsToMakeKPeriodic(\"leetcodeleet\", 4) == 1, \"Test 1 Error!\"\nassert my_solution.minimumOperationsToMakeKPeriodic(\"leetcoleet\", 2) == 3, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String word_1 = \"leetcodeleet\";\n    int k_1 = 4;\n    int ans_1 = 1;\n    assert solution.minimumOperationsToMakeKPeriodic(word_1, k_1) == ans_1;\n    String word_2 = \"leetcoleet\";\n    int k_2 = 2;\n    int ans_2 = 3;\n    assert solution.minimumOperationsToMakeKPeriodic(word_2, k_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string word_1 = \"leetcodeleet\";\n    int k_1 = 4;\n    int ans_1 = 1;\n    assert(my_solution_1.minimumOperationsToMakeKPeriodic(word_1, k_1) == ans_1);\n    Solution my_solution_2;\n    string word_2 = \"leetcoleet\";\n    int k_2 = 2;\n    int ans_2 = 3;\n    assert(my_solution_2.minimumOperationsToMakeKPeriodic(word_2, k_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "word",
                "k"
            ],
            "java": [
                "word",
                "k"
            ],
            "cpp": [
                "word",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3138": {
        "description": "给你一个字符串 s ，它由某个字符串 t 和若干 t  的 同位字符串 连接而成。\n请你返回字符串 t 的 最小 可能长度。\n同位字符串 指的是重新排列一个单词得到的另外一个字符串，原来字符串中的每个字符在新字符串中都恰好只使用一次。",
        "difficulty_level": "Middle",
        "note": "1 <= s.length <= 10^5\ns 只包含小写英文字母。",
        "codes": {
            "python": "class Solution:\n    def minAnagramLength(self, s: str) -> int:\n        n = len(s)\n        for k in range(1, n // 2 + 1):\n            if n % k:\n                continue\n            cnt0 = Counter(s[:k])\n            for i in range(k * 2, n + 1, k):\n                if Counter(s[i - k: i]) != cnt0:\n                    break\n            else:\n                return k\n        return n\n",
            "java": "class Solution {\n    public int minAnagramLength(String S) {\n        char[] s = S.toCharArray();\n        int n = s.length;\n        next:\n        for (int k = 1; k <= n / 2; k++) {\n            if (n % k > 0) {\n                continue;\n            }\n            int[] cnt0 = new int[26];\n            for (int j = 0; j < k; j++) {\n                cnt0[s[j] - 'a']++;\n            }\n            for (int i = k * 2; i <= n; i += k) {\n                int[] cnt = new int[26];\n                for (int j = i - k; j < i; j++) {\n                    cnt[s[j] - 'a']++;\n                }\n                if (!Arrays.equals(cnt, cnt0)) {\n                    continue next;\n                }\n            }\n            return k;\n        }\n        return n;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minAnagramLength(string s) {\n        int n = s.length();\n        for (int k = 1; k <= n / 2; k++) {\n            if (n % k) {\n                continue;\n            }\n            array<int, 26> cnt0{};\n            for (int j = 0; j < k; j++) {\n                cnt0[s[j] - 'a']++;\n            }\n            for (int i = k * 2; i <= n; i += k) {\n                array<int, 26> cnt{};\n                for (int j = i - k; j < i; j++) {\n                    cnt[s[j] - 'a']++;\n                }\n                if (cnt != cnt0) {\n                    goto next;\n                }\n            }\n            return k;\n            next:;\n        }\n        return n;\n    }\n};\n",
            "go": "func minAnagramLength(s string) int {\nn := len(s)\nnext:\nfor k := 1; k <= n/2; k++ {\nif n%k > 0 {\ncontinue\n}\ncnt0 := [26]int{}\nfor _, b := range s[:k] {\ncnt0[b-'a']++\n}\nfor i := k * 2; i <= len(s); i += k {\ncnt := [26]int{}\nfor _, b := range s[i-k : i] {\ncnt[b-'a']++\n}\nif cnt != cnt0 {\ncontinue next\n}\n}\nreturn k\n}\nreturn n\n}\n",
            "js": "/**\n * @param {string} s\n * @return {number}\n */\nvar minAnagramLength = function(s) {\n    let m = s.length\n    let n = m/2\n    let i = 1\n    while(i<=n){\n        if(m%i==0){\n            let p = new Set()\n            let j = 0\n            while(j<m/i){\n                let d = s.slice(j*i,(j+1)*i).split('').sort((a,b)=>a.charCodeAt()-b.charCodeAt()).join('')\n                p.add(d)\n                j++\n                if(p.size>1) break\n            }\n            if(p.size==1) return i\n        }\n        i++\n    }\n    return m\n};\n"
        },
        "cases": [
            {
                "input": "[\"\\\"abba\\\"\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"\\\"cdef\\\"\"]",
                "output": "[\"4\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minAnagramLength(String s) {",
            "cpp": "class Solution {\npublic:\n    int minAnagramLength(string s) {",
            "go": "func minAnagramLength(s string) int {\n\n}",
            "js": "/**\n * @param {string} s\n * @return {number}\n */\nvar minAnagramLength = function(s) {",
            "python": "class Solution:\n    def minAnagramLength(self, s: str) -> int:"
        },
        "time": "20240505",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minAnagramLength",
            "java": "minAnagramLength",
            "cpp": "minAnagramLength",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minAnagramLength(\"abba\") == 2, \"Test 1 Error!\"\nassert my_solution.minAnagramLength(\"cdef\") == 4, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String s_1 = \"abba\";\n    int ans_1 = 2;\n    assert solution.minAnagramLength(s_1) == ans_1;\n    String s_2 = \"cdef\";\n    int ans_2 = 4;\n    assert solution.minAnagramLength(s_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string s_1 = \"abba\";\n    int ans_1 = 2;\n    assert(my_solution_1.minAnagramLength(s_1) == ans_1);\n    Solution my_solution_2;\n    string s_2 = \"cdef\";\n    int ans_2 = 4;\n    assert(my_solution_2.minAnagramLength(s_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "s"
            ],
            "java": [
                "s"
            ],
            "cpp": [
                "s"
            ],
            "go": [],
            "js": []
        }
    },
    "3139": {
        "description": "给你一个整数数组 nums 和两个整数 cost1 和 cost2 。你可以执行以下 任一 操作 任意 次：从 nums 中选择下标 i 并且将 nums[i] 增加 1 ，开销为 cost1。选择 nums 中两个 不同 下标 i 和 j ，并且将 nums[i] 和 nums[j] 都 增加 1 ，开销为 cost2 。\n你的目标是使数组中所有元素都 相等 ，请你返回需要的 最小开销 之和。\n由于答案可能会很大，请你将它对 10^9 + 7 取余 后返回。",
        "difficulty_level": "Hard",
        "note": "1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^6\n1 <= cost1 <= 10^6\n1 <= cost2 <= 10^6",
        "codes": {
            "python": "class Solution:\n    def minCostToEqualizeArray(self, nums: List[int], c1: int, c2: int) -> int:\n        MOD = 1_000_000_007\n        n = len(nums)\n        m = min(nums)\n        M = max(nums)\n        base = n * M - sum(nums)\n        if n <= 2 or c1 * 2 <= c2:\n            return base * c1 % MOD\n\n        def f(x: int) -> int:\n            s = base + (x - M) * n\n            d = x - m\n            if d * 2 <= s:\n                return s // 2 * c2 + s % 2 * c1\n            return (s - d) * c2 + (d * 2 - s) * c1\n\n        i = (n * M - m * 2 - base + n - 3) // (n - 2)\n        return min(f(M), f(M + 1)) % MOD if i <= M else \\\n               min(f(M), f(i - 1), f(i), f(i + 1)) % MOD\n",
            "java": "class Solution {\n    public int minCostToEqualizeArray(int[] nums, int c1, int c2) {\n        final int MOD = 1_000_000_007;\n        long n = nums.length;\n        int m = Integer.MAX_VALUE;\n        int M = Integer.MIN_VALUE;\n        long sum = 0;\n        for (int x : nums) {\n            m = Math.min(m, x);\n            M = Math.max(M, x);\n            sum += x;\n        }\n\n        long base = n * M - sum;\n        if (n <= 2 || c1 * 2 <= c2) {\n            return (int) (base * c1 % MOD);\n        }\n\n        int i = (int) ((n * M - m * 2 - base + n - 3) / (n - 2));\n        long res1 = f(M, base, n, m, M, c1, c2);\n        long res2 = f(M + 1, base, n, m, M, c1, c2);\n        long res3 = f(i - 1, base, n, m, M, c1, c2);\n        long res4 = f(i, base, n, m, M, c1, c2);\n        long res5 = f(i + 1, base, n, m, M, c1, c2);\n        return (int) (i <= M ? Math.min(res1, res2) % MOD :\n                Math.min(Math.min(Math.min(res1, res3), res4), res5) % MOD);\n    }\n\n    private long f(int x, long base, long n, int m, int M, int c1, int c2) {\n        long s = base + (x - M) * n;\n        int d = x - m;\n        if (d * 2 <= s) {\n            return s / 2 * c2 + s % 2 * c1;\n        }\n        return (s - d) * c2 + (d * 2 - s) * c1;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minCostToEqualizeArray(vector<int>& nums, int c1, int c2) {\n        const int MOD = 1'000'000'007;\n        long long n = nums.size();\n        auto [m, M] = ranges::minmax(nums);\n        long long base = n * M - reduce(nums.begin(), nums.end(), 0LL);\n        if (n <= 2 || c1 * 2 <= c2) {\n            return base * c1 % MOD;\n        }\n\n        auto f = [&](int x) -> long long {\n            long long s = base + (x - M) * n;\n            int d = x - m;\n            if (d * 2 <= s) {\n                return s / 2 * c2 + s % 2 * c1;\n            }\n            return (s - d) * c2 + (d * 2 - s) * c1;\n        };\n\n        int i = (n * M - m * 2 - base + n - 3) / (n - 2);\n        return i <= M ? min(f(M), f(M + 1)) % MOD :\n               min({f(M), f(i - 1), f(i), f(i + 1)}) % MOD;\n    }\n};\n",
            "go": "func minCostToEqualizeArray(nums []int, c1 int, c2 int) int {\nconst mod = 1_000_000_007\nn := len(nums)\nm := slices.Min(nums)\nM := slices.Max(nums)\nbase := n * M\nfor _, x := range nums {\nbase -= x\n}\nif n <= 2 || c1*2 <= c2 {\nreturn base * c1 % mod\n}\n\nf := func(x int) int {\ns := base + (x-M)*n\nd := x - m\nif d*2 <= s {\nreturn s/2*c2 + s%2*c1\n}\nreturn (s-d)*c2 + (d*2-s)*c1\n}\n\ni := (n*M - m*2 - base + n - 3) / (n - 2)\nif i <= M {\nreturn min(f(M), f(M+1)) % mod\n}\nreturn min(f(M), f(i-1), f(i), f(i+1)) % mod\n}\n",
            "js": "var minCostToEqualizeArray = function(nums, cost1, cost2) {\n    let n = nums.length\n    if(n == 1){\n        return 0\n    }\n    if(n == 2){\n        return Math.abs((nums[0] - nums[1]) * cost1) % (10**9 + 7)\n    }\n    let sum = 0\n    let min = 10 ** 6\n    let max = 0\n    for(let i of nums){ // 找到最大值最小值计算差\n        sum += i\n        if(min > i){\n            min = i\n        }\n        if(max < i){\n            max = i\n        }\n    }\n    let count = max * n - sum //至少需要填满的空间\n    let c = max - min //最大的差值\n    if(cost1 * 2 >= cost2){ //如果单选的收益大于双选，全部选择单选，没有特殊情况\n        let f = count - 2 * c //如果最大的差值比别的所有加起来都打，可能会突破最大值\n        if(f > 0){\n            let number = Math.floor(count / 2) * cost2\n            let p = [(count % 2) * cost1]\n            if(n % 2 && count % 2){ //如果只剩最后一个未填满，对比一个的值和突破一层大小对比\n                p.push((n + 1)*cost2/2)\n            }\n            return (number + Math.min(...p)) % (10**9 + 7)\n        }else{\n            let s = count - c  //出去最大的差值得到能直接双选的数量\n            let z = c - s //最大的差值减去其他差值，得到需要单选或者突破最大的情况\n            let number = [s * cost2 + z * cost1] \n            let x = z/(n - 2)\n            if(x % 1 == 0){\n                let m = (x * (n - 1))\n                number.push((m + s) * cost2)\n            }else{\n                let x1 = Math.floor(x)\n                let x2 = Math.ceil(x)\n                let m = (x1 * (n - 1))\n                number.push((z - m + x1) * cost1 + (m + s) * cost2)\n                count = (x2 * n + z)\n                m = (x2 * (n - 1))\n                let po = Math.floor(count/2) + s\n                number.push((Math.floor(count/2) + s)* cost2 + (count % 2) * cost1)\n                if(count % 2 && n % 2){\n                    number.push((po + (n + 1)/2) * cost2)\n                }\n            }\n            return (Math.min(...number) % (10**9 + 7)) % (10**9 + 7)\n        }\n    }else{\n        return (count * cost1) % (10**9 + 7)\n    }\n\n};\n"
        },
        "cases": [
            {
                "input": "[\"[4,1]\",\"5\",\"2\"]",
                "output": "[\"15\"]"
            },
            {
                "input": "[\"[2,3,3,3,5]\",\"2\",\"1\"]",
                "output": "[\"6\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minCostToEqualizeArray(int[] nums, int cost1, int cost2) {",
            "cpp": "class Solution {\npublic:\n    int minCostToEqualizeArray(vector<int>& nums, int cost1, int cost2) {",
            "go": "func minCostToEqualizeArray(nums []int, cost1 int, cost2 int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number} cost1\n * @param {number} cost2\n * @return {number}\n */\nvar minCostToEqualizeArray = function(nums, cost1, cost2) {",
            "python": "class Solution:\n    def minCostToEqualizeArray(self, nums: List[int], cost1: int, cost2: int) -> int:"
        },
        "time": "20240505",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minCostToEqualizeArray",
            "java": "minCostToEqualizeArray",
            "cpp": "minCostToEqualizeArray",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minCostToEqualizeArray([4,1], 5, 2) == 15, \"Test 1 Error!\"\nassert my_solution.minCostToEqualizeArray([2,3,3,3,5], 2, 1) == 6, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {4,1};\n    int cost1_1 = 5;\n    int cost2_1 = 2;\n    int ans_1 = 15;\n    assert solution.minCostToEqualizeArray(nums_1, cost1_1, cost2_1) == ans_1;\n    int[] nums_2 = {2,3,3,3,5};\n    int cost1_2 = 2;\n    int cost2_2 = 1;\n    int ans_2 = 6;\n    assert solution.minCostToEqualizeArray(nums_2, cost1_2, cost2_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {4,1};\n    int cost1_1 = 5;\n    int cost2_1 = 2;\n    int ans_1 = 15;\n    assert(my_solution_1.minCostToEqualizeArray(nums_1, cost1_1, cost2_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {2,3,3,3,5};\n    int cost1_2 = 2;\n    int cost2_2 = 1;\n    int ans_2 = 6;\n    assert(my_solution_2.minCostToEqualizeArray(nums_2, cost1_2, cost2_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "cost1",
                "cost2"
            ],
            "java": [
                "nums",
                "cost1",
                "cost2"
            ],
            "cpp": [
                "nums",
                "cost1",
                "cost2"
            ],
            "go": [],
            "js": []
        }
    },
    "3146": {
        "description": "给你两个字符串 s 和 t，每个字符串中的字符都不重复，且 t 是 s 的一个排列。排列差 定义为 s 和 t 中每个字符在两个字符串中位置的绝对差值之和。返回 s 和 t 之间的 排列差 。",
        "difficulty_level": "Easy",
        "note": "1 <= s.length <= 26\n每个字符在 s 中最多出现一次。\nt 是 s 的一个排列。\ns 仅由小写英文字母组成。",
        "codes": {
            "python": "class Solution:\n    def findPermutationDifference(self, s: str, t: str) -> int:\n        pos = {c: i for i, c in enumerate(s)}\n        return sum(abs(i - pos[c]) for i, c in enumerate(t))\n",
            "java": "class Solution {\n    public int findPermutationDifference(String s, String t) {\n        int[] pos = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            pos[s.charAt(i) - 'a'] = i;\n        }\n        int ans = 0;\n        for (int i = 0; i < t.length(); i++) {\n            ans += Math.abs(i - pos[t.charAt(i) - 'a']);\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int findPermutationDifference(string s, string t) {\n        int pos[26];\n        for (int i = 0; i < s.size(); i++) {\n            pos[s[i] - 'a'] = i;\n        }\n        int ans = 0;\n        for (int i = 0; i < t.size(); i++) {\n            ans += abs(i - pos[t[i] - 'a']);\n        }\n        return ans;\n    }\n};\n",
            "go": "func findPermutationDifference(s, t string) (ans int) {\npos := [26]int{}\nfor i, c := range s {\npos[c-'a'] = i\n}\nfor i, c := range t {\nans += abs(i - pos[c-'a'])\n}\nreturn\n}\n\nfunc abs(x int) int { if x < 0 { return -x }; return x }\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"\\\"abc\\\"\",\"\\\"bac\\\"\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"\\\"abcde\\\"\",\"\\\"edbac\\\"\"]",
                "output": "[\"12\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int findPermutationDifference(String s, String t) {",
            "cpp": "class Solution {\npublic:\n    int findPermutationDifference(string s, string t) {",
            "go": "func findPermutationDifference(s string, t string) int {\n\n}",
            "js": "/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nvar findPermutationDifference = function(s, t) {",
            "python": "class Solution:\n    def findPermutationDifference(self, s: str, t: str) -> int:"
        },
        "time": "20240512",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "findPermutationDifference",
            "java": "findPermutationDifference",
            "cpp": "findPermutationDifference",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.findPermutationDifference(\"abc\", \"bac\") == 2, \"Test 1 Error!\"\nassert my_solution.findPermutationDifference(\"abcde\", \"edbac\") == 12, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String s_1 = \"abc\";\n    String t_1 = \"bac\";\n    int ans_1 = 2;\n    assert solution.findPermutationDifference(s_1, t_1) == ans_1;\n    String s_2 = \"abcde\";\n    String t_2 = \"edbac\";\n    int ans_2 = 12;\n    assert solution.findPermutationDifference(s_2, t_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string s_1 = \"abc\";\n    string t_1 = \"bac\";\n    int ans_1 = 2;\n    assert(my_solution_1.findPermutationDifference(s_1, t_1) == ans_1);\n    Solution my_solution_2;\n    string s_2 = \"abcde\";\n    string t_2 = \"edbac\";\n    int ans_2 = 12;\n    assert(my_solution_2.findPermutationDifference(s_2, t_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "s",
                "t"
            ],
            "java": [
                "s",
                "t"
            ],
            "cpp": [
                "s",
                "t"
            ],
            "go": [],
            "js": []
        }
    },
    "3147": {
        "description": "在神秘的地牢中，n 个魔法师站成一排。每个魔法师都拥有一个属性，这个属性可以给你提供能量。有些魔法师可能会给你负能量，即从你身上吸取能量。\n你被施加了一种诅咒，当你从魔法师 i 处吸收能量后，你将被立即传送到魔法师 (i + k) 处。这一过程将重复进行，直到你到达一个不存在 (i + k) 的魔法师为止。\n换句话说，你将选择一个起点，然后以 k 为间隔跳跃，直到到达魔法师序列的末端，在过程中吸收所有的能量。\n给定一个数组 energy 和一个整数k，返回你能获得的 最大 能量。",
        "difficulty_level": "Middle",
        "note": "1 <= energy.length <= 10^5\n-1000 <= energy[i] <= 1000\n1 <= k <= energy.length - 1",
        "codes": {
            "python": "class Solution:\n    def maximumEnergy(self, energy: List[int], k: int) -> int:\n        n = len(energy)\n        ans = -inf\n        for i in range(n - k, n):\n            ans = max(ans, max(accumulate(energy[j] for j in range(i, -1, -k))))\n        return ans\n",
            "java": "class Solution {\n    public int maximumEnergy(int[] energy, int k) {\n        int n = energy.length;\n        int ans = Integer.MIN_VALUE;\n        for (int i = n - k; i < n; i++) {\n            int s = 0;\n            for (int j = i; j >= 0; j -= k) {\n                s += energy[j];\n                ans = Math.max(ans, s);\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int maximumEnergy(vector<int>& energy, int k) {\n        int n = energy.size(), ans = INT_MIN;\n        for (int i = n - k; i < n; i++) {\n            int s = 0;\n            for (int j = i; j >= 0; j -= k) {\n                s += energy[j];\n                ans = max(ans, s);\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func maximumEnergy(energy []int, k int) int {\nn := len(energy)\nans := math.MinInt\nfor i := n - k; i < n; i++ {\ns := 0\nfor j := i; j >= 0; j -= k {\ns += energy[j]\nans = max(ans, s)\n}\n}\nreturn ans\n}\n",
            "js": "/**\n * @param {number[]} energy\n * @param {number} k\n * @return {number}\n */\nvar maximumEnergy = function(energy, k) {\n    const len = energy.length;\n    let ans = -Infinity;\n    for (i = len - 1; i >= len - k; i--) { // 只有最后K个必须要是最后需要到达的魔法师\n        let cur = 0;\n        for (j = i; j >= 0; j -= k) { // 从后往前加，并取最大值\n            cur += energy[j];\n            ans = Math.max(ans, cur);\n        }\n    }\n    return ans;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[5,2,-10,-5,1]\",\"3\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[-2,-3,-1]\",\"2\"]",
                "output": "[\"-1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maximumEnergy(int[] energy, int k) {",
            "cpp": "class Solution {\npublic:\n    int maximumEnergy(vector<int>& energy, int k) {",
            "go": "func maximumEnergy(energy []int, k int) int {\n\n}",
            "js": "/**\n * @param {number[]} energy\n * @param {number} k\n * @return {number}\n */\nvar maximumEnergy = function(energy, k) {",
            "python": "class Solution:\n    def maximumEnergy(self, energy: List[int], k: int) -> int:"
        },
        "time": "20240512",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maximumEnergy",
            "java": "maximumEnergy",
            "cpp": "maximumEnergy",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maximumEnergy([5,2,-10,-5,1], 3) == 3, \"Test 1 Error!\"\nassert my_solution.maximumEnergy([-2,-3,-1], 2) == -1, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] energy_1 = {5,2,-10,-5,1};\n    int k_1 = 3;\n    int ans_1 = 3;\n    assert solution.maximumEnergy(energy_1, k_1) == ans_1;\n    int[] energy_2 = {-2,-3,-1};\n    int k_2 = 2;\n    int ans_2 = -1;\n    assert solution.maximumEnergy(energy_2, k_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> energy_1 = {5,2,-10,-5,1};\n    int k_1 = 3;\n    int ans_1 = 3;\n    assert(my_solution_1.maximumEnergy(energy_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> energy_2 = {-2,-3,-1};\n    int k_2 = 2;\n    int ans_2 = -1;\n    assert(my_solution_2.maximumEnergy(energy_2, k_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "energy",
                "k"
            ],
            "java": [
                "energy",
                "k"
            ],
            "cpp": [
                "energy",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3148": {
        "description": "给你一个由 正整数 组成、大小为 m x n 的矩阵 grid。你可以从矩阵中的任一单元格移动到另一个位于正下方或正右侧的任意单元格（不必相邻）。从值为 c1 的单元格移动到值为 c2 的单元格的得分为 c2 - c1 。\n你可以从 任一 单元格开始，并且必须至少移动一次。\n返回你能得到的 最大 总得分。",
        "difficulty_level": "Middle",
        "note": "m == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 10^5\n1 <= grid[i][j] <= 10^5",
        "codes": {
            "python": "class Solution:\n    def maxScore(self, grid: List[List[int]]) -> int:\n        ans = -inf\n        m, n = len(grid), len(grid[0])\n        f = [[inf] * (n + 1) for _ in range(m + 1)]\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                mn = min(f[i + 1][j], f[i][j + 1])\n                ans = max(ans, x - mn)\n                f[i + 1][j + 1] = min(mn, x)\n        return ans\n",
            "java": "public class Solution {\n    public int maxScore(List<List<Integer>> grid) {\n        int ans = Integer.MIN_VALUE;\n        int m = grid.size(), n = grid.get(0).size();\n        int[][] f = new int[m + 1][n + 1];\n        Arrays.fill(f[0], Integer.MAX_VALUE);\n        for (int i = 0; i < m; i++) {\n            f[i + 1][0] = Integer.MAX_VALUE;\n            List<Integer> row = grid.get(i);\n            for (int j = 0; j < n; j++) {\n                int mn = Math.min(f[i + 1][j], f[i][j + 1]);\n                int x = row.get(j);\n                ans = Math.max(ans, x - mn);\n                f[i + 1][j + 1] = Math.min(mn, x);\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int maxScore(vector<vector<int>>& grid) {\n        int ans = INT_MIN;\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> f(m + 1, vector<int>(n + 1, INT_MAX));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int mn = min(f[i + 1][j], f[i][j + 1]);\n                ans = max(ans, grid[i][j] - mn);\n                f[i + 1][j + 1] = min(mn, grid[i][j]);\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func maxScore(grid [][]int) int {\nans := math.MinInt\nm, n := len(grid), len(grid[0])\nf := make([][]int, m+1)\nf[0] = make([]int, n+1)\nfor j := range f[0] {\nf[0][j] = math.MaxInt\n}\nfor i, row := range grid {\nf[i+1] = make([]int, n+1)\nf[i+1][0] = math.MaxInt\nfor j, x := range row {\nmn := min(f[i+1][j], f[i][j+1])\nans = max(ans, x-mn)\nf[i+1][j+1] = min(mn, x)\n}\n}\nreturn ans\n}\n",
            "js": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar maxScore = function (grid) {\n  let n = grid.length;\n  let m = grid[0].length;\n  let ans = -Infinity;\n  let dp = Array.from({ length: n + 1 }, () => new Array(m + 1).fill(Infinity));\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      mn = Math.min(dp[i][j + 1], dp[i + 1][j]);\n      ans = Math.max(ans, grid[i][j] - mn);\n      dp[i + 1][j + 1] = Math.min(mn, grid[i][j]);\n    }\n  }\n  return ans\n};\n"
        },
        "cases": [
            {
                "input": "[\"[[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]\"]",
                "output": "[\"9\"]"
            },
            {
                "input": "[\"[[4,3,2],[3,2,1]]\"]",
                "output": "[\"-1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maxScore(List<List<Integer>> grid) {",
            "cpp": "class Solution {\npublic:\n    int maxScore(vector<vector<int>>& grid) {",
            "go": "func maxScore(grid [][]int) int {\n\n}",
            "js": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar maxScore = function(grid) {",
            "python": "class Solution:\n    def maxScore(self, grid: List[List[int]]) -> int:"
        },
        "time": "20240512",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maxScore",
            "java": "maxScore",
            "cpp": "maxScore",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maxScore([[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]) == 9, \"Test 1 Error!\"\nassert my_solution.maxScore([[4,3,2],[3,2,1]]) == -1, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    List<List<Integer>> grid_1 = [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]];\n    int ans_1 = 9;\n    assert solution.maxScore(grid_1) == ans_1;\n    List<List<Integer>> grid_2 = [[4,3,2],[3,2,1]];\n    int ans_2 = -1;\n    assert solution.maxScore(grid_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> grid_1 = {{9,5,7,3},{8,9,6,1},{6,7,14,3},{2,5,3,1}};\n    int ans_1 = 9;\n    assert(my_solution_1.maxScore(grid_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> grid_2 = {{4,3,2},{3,2,1}};\n    int ans_2 = -1;\n    assert(my_solution_2.maxScore(grid_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "grid"
            ],
            "java": [
                "grid"
            ],
            "cpp": [
                "grid"
            ],
            "go": [],
            "js": []
        }
    },
    "3149": {
        "description": "给你一个数组 nums,它是 [0, 1, 2, ..., n - 1] 的一个 排列 。对于任意一个[0, 1, 2, ..., n - 1] 的排列 perm其 分数 定义为：score(perm) = |perm[0] - nums[perm[1]]| + |perm[1] - nums[perm[2]]| + ... + |perm[n - 1] - nums[perm[0]]|\n返回具有 最低 分数的排列 perm 。如果存在多个满足题意且分数相等的排列，则返回其中 字典序最小 的一个。",
        "difficulty_level": "Hard",
        "note": "2 <= n == nums.length <= 14\nnums 是 [0, 1, 2, ..., n - 1] 的一个排列。",
        "codes": {
            "python": "class Solution:\n    def findPermutation(self, a: List[int]) -> List[int]:\n        n = len(a)\n        @cache  # 缓存装饰器，避免重复计算 dfs 的结果（记忆化）\n        def dfs(s: int, j: int) -> int:\n            if s == (1 << n) - 1:\n                # 所有位置都填完了，最后一个位置是下标 j\n                return abs(j - a[0])\n            res = inf\n            # 枚举当前位置填下标 k\n            for k in range(1, n):\n                if s >> k & 1 == 0:  # k 之前没填过\n                    res = min(res, dfs(s | 1 << k, k) + abs(j - a[k]))\n            return res\n\n        ans = []\n        # 原理见上面贴的题解链接\n        def make_ans(s: int, j: int) -> None:\n            ans.append(j)\n            if s == (1 << n) - 1:\n                return\n            final_res = dfs(s, j)\n            for k in range(1, n):\n                if s >> k & 1 == 0 and dfs(s | 1 << k, k) + abs(j - a[k]) == final_res:\n                    make_ans(s | 1 << k, k)\n                    break\n        make_ans(1, 0)\n        return ans\n",
            "java": "class Solution {\n    public int[] findPermutation(int[] a) {\n        int n = a.length;\n        int[][] memo = new int[1 << n][n];\n        for (int[] row : memo) {\n            Arrays.fill(row, -1); // -1 表示没有计算过\n        }\n        int[] ans = new int[n];\n        makeAns(1, 0, a, memo, ans, 0);\n        return ans;\n    }\n\n    private int dfs(int s, int j, int[] a, int[][] memo) {\n        if (s == (1 << a.length) - 1) {\n            return Math.abs(j - a[0]);\n        }\n        if (memo[s][j] != -1) { // 之前计算过\n            return memo[s][j];\n        }\n        int res = Integer.MAX_VALUE;\n        for (int k = 1; k < a.length; k++) {\n            if ((s >> k & 1) == 0) { // k 之前没填过\n                res = Math.min(res, dfs(s | 1 << k, k, a, memo) + Math.abs(j - a[k]));\n            }\n        }\n        memo[s][j] = res; // 记忆化\n        return res;\n    }\n\n    private void makeAns(int s, int j, int[] a, int[][] memo, int[] ans, int i) {\n        ans[i] = j;\n        if (s == (1 << a.length) - 1) {\n            return;\n        }\n        int finalRes = dfs(s, j, a, memo);\n        for (int k = 1; k < a.length; k++) {\n            if ((s >> k & 1) == 0 && dfs(s | 1 << k, k, a, memo) + Math.abs(j - a[k]) == finalRes) {\n                makeAns(s | 1 << k, k, a, memo, ans, i + 1);\n                break;\n            }\n        }\n    }\n}   \n",
            "cpp": "class Solution {\npublic:\n    vector<int> findPermutation(vector<int>& a) {\n        int n = a.size();\n        vector<vector<int>> memo(1 << n, vector<int>(n, -1)); // -1 表示没有计算过\n        function<int(int, int)> dfs = [&](int s, int j) -> int {\n            if (s == (1 << n) - 1) {\n                return abs(j - a[0]);\n            }\n            int& res = memo[s][j]; // 注意这里是引用\n            if (res != -1) { // 之前计算过\n                return res;\n            }\n            res = INT_MAX;\n            for (int k = 1; k < n; k++) {\n                if ((s >> k & 1) == 0) { // k 之前没填过\n                    res = min(res, dfs(s | 1 << k, k) + abs(j - a[k]));\n                }\n            }\n            return res;\n        };\n\n        vector<int> ans;\n        function<void(int, int)> make_ans = [&](int s, int j) -> void {\n            ans.push_back(j);\n            if (s == (1 << n) - 1) {\n                return;\n            }\n            int final_res = dfs(s, j);\n            for (int k = 1; k < n; k++) {\n                if ((s >> k & 1) == 0 && dfs(s | 1 << k, k) + abs(j - a[k]) == final_res) {\n                    make_ans(s | 1 << k, k);\n                    break;\n                }\n            }\n        };\n        make_ans(1, 0);\n        return ans;\n    }\n};\n",
            "go": "func findPermutation(a []int) []int {\nn := len(a)\nmemo := make([][]int, 1<<n)\nfor i := range memo {\nmemo[i] = make([]int, n)\nfor j := range memo[i] {\nmemo[i][j] = -1 // -1 表示没有计算过\n}\n}\nvar dfs func(int, int) int\ndfs = func(s, j int) int {\nif s == 1<<n-1 {\nreturn abs(j - a[0])\n}\np := &memo[s][j]\nif *p != -1 { // 之前计算过\nreturn *p\n}\nres := math.MaxInt\nfor k := 1; k < n; k++ {\nif s>>k&1 == 0 { // k 之前没填过\nres = min(res, dfs(s|1<<k, k)+abs(j-a[k]))\n}\n}\n*p = res // 记忆化\nreturn res\n}\n\nans := make([]int, 0, n)\nvar makeAns func(int, int)\nmakeAns = func(s, j int) {\nans = append(ans, j)\nif s == 1<<n-1 {\nreturn\n}\nfinalRes := dfs(s, j)\nfor k := 1; k < n; k++ {\nif s>>k&1 == 0 && dfs(s|1<<k, k)+abs(j-a[k]) == finalRes {\nmakeAns(s|1<<k, k)\nbreak\n}\n}\n}\nmakeAns(1, 0)\nreturn ans\n}\n\nfunc abs(x int) int { if x < 0 { return -x }; return x }\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[1,0,2]\"]",
                "output": "[\"[0,1,2]\"]"
            },
            {
                "input": "[\"[0,2,1]\"]",
                "output": "[\"[0,2,1]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int[] findPermutation(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    vector<int> findPermutation(vector<int>& nums) {",
            "go": "func findPermutation(nums []int) []int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar findPermutation = function(nums) {",
            "python": "class Solution:\n    def findPermutation(self, nums: List[int]) -> List[int]:"
        },
        "time": "20240512",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "findPermutation",
            "java": "findPermutation",
            "cpp": "findPermutation",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.findPermutation([1,0,2]) == [0,1,2], \"Test 1 Error!\"\nassert my_solution.findPermutation([0,2,1]) == [0,2,1], \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,0,2};\n    int[] ans_1 = {0,1,2};\n    assert Arrays.equals(solution.findPermutation(nums_1), ans_1);\n    int[] nums_2 = {0,2,1};\n    int[] ans_2 = {0,2,1};\n    assert Arrays.equals(solution.findPermutation(nums_2), ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,0,2};\n    vector<int> ans_1 = {0,1,2};\n    assert(my_solution_1.findPermutation(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {0,2,1};\n    vector<int> ans_2 = {0,2,1};\n    assert(my_solution_2.findPermutation(nums_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3151": {
        "description": "如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 特殊数组 。\nAging 有一个整数数组 nums。如果 nums 是一个 特殊数组 ，返回 true，否则返回 false。",
        "difficulty_level": "Easy",
        "note": "1 <= nums.length <= 100\n1 <= nums[i] <= 100",
        "codes": {
            "python": "class Solution:\n    def isArraySpecial(self, nums: List[int]) -> bool:\n        return all(x % 2 != y % 2 for x, y in pairwise(nums))\n",
            "java": "class Solution {\n    public boolean isArraySpecial(int[] nums) {\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i - 1] % 2 == nums[i] % 2) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    bool isArraySpecial(vector<int>& nums) {\n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[i - 1] % 2 == nums[i] % 2) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n",
            "go": "func isArraySpecial(nums []int) bool {\nfor i := 1; i < len(nums); i++ {\nif nums[i-1]%2 == nums[i]%2 {\nreturn false\n}\n}\nreturn true\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar isArraySpecial = function(nums) {\n    let x = nums[0] \n    if(x % 2) return nums.every((v,i) => i % 2  !==  v % 2 ) \n    return nums.every((v,i) => i % 2  ===  v % 2) \n};\n"
        },
        "cases": [
            {
                "input": "[\"[1]\"]",
                "output": "[\"true\"]"
            },
            {
                "input": "[\"[2,1,4]\"]",
                "output": "[\"true\"]"
            },
            {
                "input": "[\"[4,3,1,6]\"]",
                "output": "[\"false\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public boolean isArraySpecial(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    bool isArraySpecial(vector<int>& nums) {",
            "go": "func isArraySpecial(nums []int) bool {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar isArraySpecial = function(nums) {",
            "python": "class Solution:\n    def isArraySpecial(self, nums: List[int]) -> bool:"
        },
        "time": "20240519",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "isArraySpecial",
            "java": "isArraySpecial",
            "cpp": "isArraySpecial",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.isArraySpecial([1]) == True, \"Test 1 Error!\"\nassert my_solution.isArraySpecial([2,1,4]) == True, \"Test 2 Error!\"\nassert my_solution.isArraySpecial([4,3,1,6]) == False, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1};\n    boolean ans_1 = true;\n    assert solution.isArraySpecial(nums_1) == ans_1;\n    int[] nums_2 = {2,1,4};\n    boolean ans_2 = true;\n    assert solution.isArraySpecial(nums_2) == ans_2;\n    int[] nums_3 = {4,3,1,6};\n    boolean ans_3 = false;\n    assert solution.isArraySpecial(nums_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1};\n    bool ans_1 = true;\n    assert(my_solution_1.isArraySpecial(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {2,1,4};\n    bool ans_2 = true;\n    assert(my_solution_2.isArraySpecial(nums_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {4,3,1,6};\n    bool ans_3 = false;\n    assert(my_solution_3.isArraySpecial(nums_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3152": {
        "description": "如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 特殊数组 。\n周洋哥有一个整数数组 nums 和一个二维整数矩阵 queries，对于 queries[i] = [fromi, toi]，请你帮助周洋哥检查子数组 nums[fromi..toi] 是不是一个 特殊数组 。\n返回布尔数组 answer，如果 nums[fromi..toi] 是特殊数组，则 answer[i] 为 true ，否则，answer[i] 为 false 。",
        "difficulty_level": "Middle",
        "note": "1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\n1 <= queries.length <= 10^5\nqueries[i].length == 2\n0 <= queries[i][0] <= queries[i][1] <= nums.length - 1",
        "codes": {
            "python": "class Solution:\n    def isArraySpecial(self, nums: List[int], queries: List[List[int]]) -> List[bool]:\n        s = list(accumulate((x % 2 == y % 2 for x, y in pairwise(nums)), initial=0))\n        return [s[from_] == s[to] for from_, to in queries]\n",
            "java": "class Solution:\n    def isArraySpecial(self, nums: List[int], queries: List[List[int]]) -> List[bool]:\n        s = list(accumulate((x % 2 == y % 2 for x, y in pairwise(nums)), initial=0))\n        return [s[from_] == s[to] for from_, to in queries]\n",
            "cpp": "class Solution {\npublic:\n    vector<bool> isArraySpecial(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> s(nums.size());\n        for (int i = 1; i < nums.size(); i++) {\n            s[i] = s[i - 1] + (nums[i - 1] % 2 == nums[i] % 2);\n        }\n        vector<bool> ans(queries.size());\n        for (int i = 0; i < queries.size(); i++) {\n            auto& q = queries[i];\n            ans[i] = s[q[0]] == s[q[1]];\n        }\n        return ans;\n    }\n};\n",
            "go": "func isArraySpecial(nums []int, queries [][]int) []bool {\ns := make([]int, len(nums))\nfor i := 1; i < len(nums); i++ {\ns[i] = s[i-1]\nif nums[i-1]%2 == nums[i]%2 {\ns[i]++\n}\n}\nans := make([]bool, len(queries))\nfor i, q := range queries {\nans[i] = s[q[0]] == s[q[1]]\n}\nreturn ans\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nfunction isOdd(num) {\n    return num % 2 === 1;\n}\n\nfunction isSpecialPair(a, b) {\n    return (isOdd(a) && !isOdd(b)) || (!isOdd(a) && isOdd(b));\n}\n\nvar isArraySpecial = function(nums, queries) {\n    let n = nums.length;\n    let specialPairs = new Array(n).fill(0);\n\n    // 预处理，计算每个相邻的元素是否构成特殊对\n    for (let i = 0; i < n - 1; i++) {\n        if (isSpecialPair(nums[i], nums[i + 1])) {\n            specialPairs[i] = 1;\n        }\n    }\n\n    // 构建前缀和数组\n    let prefixSum = new Array(n).fill(0);\n    for (let i = 1; i < n; i++) {\n        prefixSum[i] = prefixSum[i - 1] + specialPairs[i - 1];\n    }\n\n    let res = [];\n    for (let [left, right] of queries) {\n        if (right == left) {\n            res.push(true);\n        } else {\n            // 计算区间内的特殊对数量\n            let totalSpecialPairs = prefixSum[right] - prefixSum[left];\n            // 判断是否每对都是特殊对\n            res.push(totalSpecialPairs === (right - left));\n        }\n    }\n\n    return res;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[3,4,1,2,6]\",\"[[0,4]]\"]",
                "output": "[\"[false]\"]"
            },
            {
                "input": "[\"[4,3,1,6]\",\"[[0,2],[2,3]]\"]",
                "output": "[\"[false,true]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public boolean[] isArraySpecial(int[] nums, int[][] queries) {",
            "cpp": "class Solution {\npublic:\n    vector<bool> isArraySpecial(vector<int>& nums, vector<vector<int>>& queries) {",
            "go": "func isArraySpecial(nums []int, queries [][]int) []bool {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nvar isArraySpecial = function(nums, queries) {",
            "python": "class Solution:\n    def isArraySpecial(self, nums: List[int], queries: List[List[int]]) -> List[bool]:"
        },
        "time": "20240519",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "isArraySpecial",
            "java": "isArraySpecial",
            "cpp": "isArraySpecial",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.isArraySpecial([3,4,1,2,6], [[0,4]]) == [False], \"Test 1 Error!\"\nassert my_solution.isArraySpecial([4,3,1,6], [[0,2],[2,3]]) == [False,True], \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {3,4,1,2,6};\n    int[][] queries_1 = {{0,4}};\n    boolean[] ans_1 = {false};\n    assert Arrays.equals(solution.isArraySpecial(nums_1, queries_1), ans_1);\n    int[] nums_2 = {4,3,1,6};\n    int[][] queries_2 = {{0,2},{2,3}};\n    boolean[] ans_2 = {false,true};\n    assert Arrays.equals(solution.isArraySpecial(nums_2, queries_2), ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {3,4,1,2,6};\n    vector<vector<int>> queries_1 = {{0,4}};\n    vector<bool> ans_1 = {false};\n    assert(my_solution_1.isArraySpecial(nums_1, queries_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {4,3,1,6};\n    vector<vector<int>> queries_2 = {{0,2},{2,3}};\n    vector<bool> ans_2 = {false,true};\n    assert(my_solution_2.isArraySpecial(nums_2, queries_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "queries"
            ],
            "java": [
                "nums",
                "queries"
            ],
            "cpp": [
                "nums",
                "queries"
            ],
            "go": [],
            "js": []
        }
    },
    "3153": {
        "description": "车尔尼有一个数组 nums ，它只包含 正 整数，所有正整数的数位长度都 相同 。\n两个整数的 数位不同 指的是两个整数 相同 位置上不同数字的数目。\n请车尔尼返回 nums 中 所有 整数对里，数位不同之和。",
        "difficulty_level": "Middle",
        "note": "2 <= nums.length <= 10^5\n1 <= nums[i] < 10^9\nnums 中的整数都有相同的数位长度。",
        "codes": {
            "python": "class Solution:\n    def sumDigitDifferences(self, nums: List[int]) -> int:\n        ans = 0\n        cnt = [[0] * 10 for _ in str(nums[0])]\n        for k, x in enumerate(nums):\n            i = 0\n            while x:\n                x, d = divmod(x, 10)\n                ans += k - cnt[i][d]\n                cnt[i][d] += 1\n                i += 1\n        return ans\n",
            "java": "public class Solution {\n    public long sumDigitDifferences(int[] nums) {\n        long ans = 0;\n        int[][] cnt = new int[Integer.toString(nums[0]).length()][10];\n        for (int k = 0; k < nums.length; k++) {\n            int x = nums[k];\n            for (int i = 0; x > 0; x /= 10, i++) {\n                int d = x % 10;\n                ans += k - cnt[i][d]++;\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long sumDigitDifferences(vector<int>& nums) {\n        long long ans = 0;\n        vector<array<int, 10>> cnt(to_string(nums[0]).length());\n        for (int k = 0; k < nums.size(); k++) {\n            int x = nums[k];\n            for (int i = 0; x; x /= 10, i++) {\n                int d = x % 10;\n                ans += k - cnt[i][d]++;\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func sumDigitDifferences(nums []int) (ans int64) {\ncnt := make([][10]int, len(strconv.Itoa(nums[0])))\nfor k, x := range nums {\nfor i := 0; x > 0; x /= 10 {\nd := x % 10\nans += int64(k - cnt[i][d])\ncnt[i][d]++\ni++\n}\n}\nreturn\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumDigitDifferences = function(nums) {\n    let ans = 0;\n    let len = nums[0].toString().length; // 数位长度\n    let cnt = new Array(len).fill(0).map(() => Array(10).fill(0)); // 初始化计数数组\n\n    for (let i = 0; i < nums.length; i++) {\n        let num = nums[i];\n        let numArr = num.toString().split('').reverse(); // 将数字转成数组并翻转\n        for (let j = 0; j < numArr.length; j++) {\n            let temp = numArr[j];\n            // cnt[j][temp] 是一个二维数组，用于记录在当前数位 j 上，每个数字 temp 出现的次数。\n            /*如果 temp 在之前没有出现过：cnt[j][temp] 为 0，那么 i - cnt[j][temp] 等于 i，这表示\n            当前 nums[i] 的第 j 位 temp 与之前处理的所有 i 个数字在第 j 位上都不同，所有这些不同都会被计入 ans。\n              如果 temp 在之前出现过 cnt[j][temp] 次：那么 i - cnt[j][temp] 表示在处理 nums[i] 时，\n              之前 i 个数字中有 i - cnt[j][temp] 个数字在第 j 位上与 temp 不同。*/\n            ans += i - cnt[j][temp]; // 计算数位不同之和\n            cnt[j][temp]++; // 更新计数数组\n        }\n    }\n    return ans;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[13,23,12]\"]",
                "output": "[\"4\"]"
            },
            {
                "input": "[\"[10,10,10,10]\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long sumDigitDifferences(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    long long sumDigitDifferences(vector<int>& nums) {",
            "go": "func sumDigitDifferences(nums []int) int64 {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumDigitDifferences = function(nums) {",
            "python": "class Solution:\n    def sumDigitDifferences(self, nums: List[int]) -> int:"
        },
        "time": "20240519",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "sumDigitDifferences",
            "java": "sumDigitDifferences",
            "cpp": "sumDigitDifferences",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.sumDigitDifferences([13,23,12]) == 4, \"Test 1 Error!\"\nassert my_solution.sumDigitDifferences([10,10,10,10]) == 0, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {13,23,12};\n    long ans_1 = 4;\n    assert solution.sumDigitDifferences(nums_1) == ans_1;\n    int[] nums_2 = {10,10,10,10};\n    long ans_2 = 0;\n    assert solution.sumDigitDifferences(nums_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {13,23,12};\n    long long ans_1 = 4;\n    assert(my_solution_1.sumDigitDifferences(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {10,10,10,10};\n    long long ans_2 = 0;\n    assert(my_solution_2.sumDigitDifferences(nums_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3154": {
        "description": "给你有一个 非负 整数 k 。有一个无限长度的台阶，最低 一层编号为 0 。\n虎老师有一个整数 jump ，一开始值为 0 。虎老师从台阶 1 开始，虎老师可以使用 任意 次操作，目标是到达第 k 级台阶。假设虎老师位于台阶 i ，一次 操作 中，虎老师可以：向下走一级到 i - 1 ，但该操作 不能 连续使用，如果在台阶第 0 级也不能使用。向上走到台阶 i + 2^jump 处，然后 jump 变为 jump + 1 。\n请你返回虎老师到达台阶 k 处的总方案数。\n注意 ，虎老师可能到达台阶 k 处后，通过一些操作重新回到台阶 k 处，这视为不同的方案。",
        "difficulty_level": "Hard",
        "note": "0 <= k <= 10^9",
        "codes": {
            "python": "class Solution:\n    def waysToReachStair(self, k: int) -> int:\n        @cache  # 缓存装饰器，避免重复计算 dfs 的结果（记忆化）\n        def dfs(i: int, j: int, pre_down: bool) -> int:\n            if i > k + 1:\n                return 0\n            res = 1 if i == k else 0\n            res += dfs(i + (1 << j), j + 1, False)  # 操作二\n            if i and not pre_down:\n                res += dfs(i - 1, j, True)  # 操作一\n            return res\n        return dfs(1, 0, False)\n",
            "java": "class Solution {\n    public int waysToReachStair(int k) {\n        return dfs(1, 0, 0, k, new HashMap<>());\n    }\n\n    private int dfs(int i, int j, int preDown, int k, Map<Long, Integer> memo) {\n        if (i > k + 1) {\n            return 0;\n        }\n        long p = ((long) i << 32) | j << 1 | preDown; // 用一个 long 表示状态\n        if (memo.containsKey(p)) { // 之前算过了\n            return memo.get(p);\n        }\n        int res = i == k ? 1 : 0;\n        res += dfs(i + (1 << j), j + 1, 0, k, memo); // 操作二\n        if (preDown == 0 && i > 0) {\n            res += dfs(i - 1, j, 1, k, memo); // 操作一\n        }\n        memo.put(p, res); // 记忆化\n        return res;\n    }\n}\n",
            "cpp": "class Solution {\n    unordered_map<long long, int> memo;\n\n    int dfs(int i, int j, bool preDown, int k) {\n        if (i > k + 1) {\n            return 0;\n        }\n        long long p = (long long) i << 32 | j << 1 | preDown; // 用一个 long long 表示状态\n        if (memo.contains(p)) { // 之前算过了\n            return memo[p];\n        }\n        int res = i == k;\n        res += dfs(i + (1 << j), j + 1, false, k); // 操作二\n        if (i && !preDown) {\n            res += dfs(i - 1, j, true, k); // 操作一\n        }\n        return memo[p] = res; // 记忆化\n    };\n\npublic:\n    int waysToReachStair(int k) {\n        return dfs(1, 0, false, k);\n    }\n};\n",
            "go": "func waysToReachStair(k int) int {\ntype args struct {\ni, j    int\npreDown bool\n}\nmemo := map[args]int{}\nvar dfs func(int, int, bool) int\ndfs = func(i, j int, preDown bool) int {\nif i > k+1 {\nreturn 0\n}\np := args{i, j, preDown}\nif v, ok := memo[p]; ok { // 之前算过了\nreturn v\n}\nres := dfs(i+1<<j, j+1, false) // 操作二\nif !preDown && i > 0 {\nres += dfs(i-1, j, true) // 操作一\n}\nif i == k {\nres++\n}\nmemo[p] = res // 记忆化\nreturn res\n}\nreturn dfs(1, 0, false)\n}\n",
            "js": "/**\n * @param {number} k\n * @return {number}\n */\nvar waysToReachStair = function(k) {\n    return dfs(1, 0, 0 , k, new Map());\n};\n\n// i表示当前楼梯数，j表示使用第2次操作j次，preDown表示前一次操作是否是向上，1表示向上，k表示目标楼梯数，memo记忆化搜索map，\n// 避免重复计算。\nfunction dfs(i, j, preDown, k, memo) {\n    if (i > k + 1) {\n        return 0;\n    }\n    let p = ((BigInt(i) << 32n) | BigInt(j) << 1n | BigInt(preDown)); // 用一个 BigInt 表示状态\n    if (memo.has(p)) { // 之前算过了\n        return memo.get(p);\n    }\n    let res = (i === k) ? 1 : 0;\n    res += dfs(i + (1 << j), j + 1, 0, k, memo); // 操作二\n    if (preDown === 0 && i > 0) {\n        res += dfs(i - 1, j, 1, k, memo); // 操作一\n    }\n    memo.set(p, res); // 记忆化\n    return res;\n}\n"
        },
        "cases": [
            {
                "input": "[\"0\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"1\"]",
                "output": "[\"4\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int waysToReachStair(int k) {",
            "cpp": "class Solution {\npublic:\n    int waysToReachStair(int k) {",
            "go": "func waysToReachStair(k int) int {\n\n}",
            "js": "/**\n * @param {number} k\n * @return {number}\n */\nvar waysToReachStair = function(k) {",
            "python": "class Solution:\n    def waysToReachStair(self, k: int) -> int:"
        },
        "time": "20240519",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "waysToReachStair",
            "java": "waysToReachStair",
            "cpp": "waysToReachStair",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.waysToReachStair(0) == 2, \"Test 1 Error!\"\nassert my_solution.waysToReachStair(1) == 4, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int k_1 = 0;\n    int ans_1 = 2;\n    assert solution.waysToReachStair(k_1) == ans_1;\n    int k_2 = 1;\n    int ans_2 = 4;\n    assert solution.waysToReachStair(k_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int k_1 = 0;\n    int ans_1 = 2;\n    assert(my_solution_1.waysToReachStair(k_1) == ans_1);\n    Solution my_solution_2;\n    int k_2 = 1;\n    int ans_2 = 4;\n    assert(my_solution_2.waysToReachStair(k_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "k"
            ],
            "java": [
                "k"
            ],
            "cpp": [
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3162": {
        "description": "给你两个整数数组 nums1 和 nums2，长度分别为 n 和 m。同时给你一个正整数 k。\n\n如果 nums1[i] 可以被 nums2[j] * k 整除，则称数对 (i, j) 为 优质数对（0 <= i <= n - 1, 0 <= j <= m - 1）。\n\n返回 优质数对 的总数。",
        "difficulty_level": "Easy",
        "note": "1 <= n, m <= 50\n1 <= nums1[i], nums2[j] <= 50\n1 <= k <= 50",
        "codes": {
            "python": "class Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        cnt = defaultdict(int)\n        for x in nums1:\n            if x % k:\n                continue\n            x //= k\n            for d in range(1, isqrt(x) + 1):\n                if x % d:\n                    continue\n                cnt[d] += 1\n                if d * d < x:\n                    cnt[x // d] += 1\n        return sum(cnt[x] for x in nums2)\n",
            "java": "class Solution {\n    public long numberOfPairs(int[] nums1, int[] nums2, int k) {\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int x : nums1) {\n            if (x % k != 0) {\n                continue;\n            }\n            x /= k;\n            for (int d = 1; d * d <= x; d++) {\n                if (x % d > 0) {\n                    continue;\n                }\n                cnt.merge(d, 1, Integer::sum);\n                if (d * d < x) {\n                    cnt.merge(x / d, 1, Integer::sum);\n                }\n            }\n        }\n\n        long ans = 0;\n        for (int x : nums2) {\n            ans += cnt.getOrDefault(x, 0);\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n        unordered_map<int, int> cnt;\n        for (int x : nums1) {\n            if (x % k) {\n                continue;\n            }\n            x /= k;\n            for (int d = 1; d * d <= x; d++) {\n                if (x % d) {\n                    continue;\n                }\n                cnt[d]++;\n                if (d * d < x) {\n                    cnt[x / d]++;\n                }\n            }\n        }\n\n        long long ans = 0;\n        for (int x : nums2) {\n            ans += cnt.contains(x) ? cnt[x] : 0;\n        }\n        return ans;\n    }\n};\n",
            "go": "func numberOfPairs(nums1, nums2 []int, k int) (ans int64) {\ncnt := map[int]int{}\nfor _, x := range nums1 {\nif x%k > 0 {\ncontinue\n}\nx /= k\nfor d := 1; d*d <= x; d++ {\nif x%d == 0 {\ncnt[d]++\nif d*d < x {\ncnt[x/d]++\n}\n}\n}\n}\n\nfor _, x := range nums2 {\nans += int64(cnt[x])\n}\nreturn\n}\n",
            "js": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number}\n */\nvar numberOfPairs = function(nums1, nums2, k) {\n    let d1 = new Map();\n    \n    for (let x of nums1){\n        if (x%k===0){\n            let v = x/k;\n            for (let i=1;i<Math.floor(Math.sqrt(v)+1);i++){\n                if (v%i ===0) {\n                    if (!d1.has(i)) d1.set(i,1);\n                    else d1.set(i,d1.get(i)+1);\n                    let y = v/i;\n                    if (y!=i){\n                        if (!d1.has(y)) d1.set(y,1);\n                        else d1.set(y,d1.get(y)+1);\n                    }\n                }\n            }\n        }\n    }\n    let ans = 0;\n    for (let t of nums2){\n        if (d1.has(t)) ans += d1.get(t);\n    }\n    return ans;\n\n}\n"
        },
        "cases": [
            {
                "input": "[\"[1,3,4]\",\"[1,3,4]\",\"1\"]",
                "output": "[\"5\"]"
            },
            {
                "input": "[\"[1,2,4,12]\",\"[2,4]\",\"3\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int numberOfPairs(int[] nums1, int[] nums2, int k) {",
            "cpp": "class Solution {\npublic:\n    int numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {",
            "go": "func numberOfPairs(nums1 []int, nums2 []int, k int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number}\n */\nvar numberOfPairs = function(nums1, nums2, k) {",
            "python": "class Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:"
        },
        "time": "20240526",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "numberOfPairs",
            "java": "numberOfPairs",
            "cpp": "numberOfPairs",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.numberOfPairs([1,3,4], [1,3,4], 1) == 5, \"Test 1 Error!\"\nassert my_solution.numberOfPairs([1,2,4,12], [2,4], 3) == 2, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums1_1 = {1,3,4};\n    int[] nums2_1 = {1,3,4};\n    int k_1 = 1;\n    int ans_1 = 5;\n    assert solution.numberOfPairs(nums1_1, nums2_1, k_1) == ans_1;\n    int[] nums1_2 = {1,2,4,12};\n    int[] nums2_2 = {2,4};\n    int k_2 = 3;\n    int ans_2 = 2;\n    assert solution.numberOfPairs(nums1_2, nums2_2, k_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums1_1 = {1,3,4};\n    vector<int> nums2_1 = {1,3,4};\n    int k_1 = 1;\n    int ans_1 = 5;\n    assert(my_solution_1.numberOfPairs(nums1_1, nums2_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums1_2 = {1,2,4,12};\n    vector<int> nums2_2 = {2,4};\n    int k_2 = 3;\n    int ans_2 = 2;\n    assert(my_solution_2.numberOfPairs(nums1_2, nums2_2, k_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums1",
                "nums2",
                "k"
            ],
            "java": [
                "nums1",
                "nums2",
                "k"
            ],
            "cpp": [
                "nums1",
                "nums2",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3163": {
        "description": "给你一个字符串 word，请你使用以下算法进行压缩：从空字符串 comp 开始。当 word 不为空 时，执行以下操作：移除 word 的最长单字符前缀，该前缀由单一字符 c 重复多次组成，且该前缀长度 最多 为 9 。将前缀的长度和字符 c 追加到 comp 。\n返回字符串 comp 。",
        "difficulty_level": "Middle",
        "note": "1 <= word.length <= 2 * 10^5\nword 仅由小写英文字母组成。",
        "codes": {
            "python": "class Solution:\n    def compressedString(self, word: str) -> str:\n        t = []\n        i0 = -1\n        for i, c in enumerate(word):\n            if i + 1 == len(word) or c != word[i + 1]:\n                k, rem = divmod(i - i0, 9)\n                t.append((\"9\" + c) * k)\n                if rem:\n                    t.append(str(rem))\n                    t.append(c)\n                i0 = i\n        return ''.join(t)\n",
            "java": "public class Solution {\n    public String compressedString(String word) {\n        StringBuilder t = new StringBuilder();\n        char[] s = word.toCharArray();\n        int i0 = -1;\n        for (int i = 0; i < s.length; i++) {\n            char c = s[i];\n            if (i + 1 == s.length || c != s[i + 1]) {\n                int k = i - i0;\n                for (int j = 0; j < k / 9; j++) {\n                    t.append('9').append(c);\n                }\n                if (k % 9 > 0) {\n                    t.append((char) ('0' + (k % 9))).append(c);\n                }\n                i0 = i;\n            }\n        }\n        return t.toString();\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    string compressedString(string word) {\n        string t;\n        int i0 = -1;\n        for (int i = 0; i < word.length(); i++) {\n            char c = word[i];\n            if (i + 1 == word.length() || c != word[i + 1]) {\n                int k = i - i0;\n                for (int j = 0; j < k / 9; j++) {\n                    t += '9';\n                    t += c;\n                }\n                if (k % 9) {\n                    t += '0' + (k % 9);\n                    t += c;\n                }\n                i0 = i;\n            }\n        }\n        return t;\n    }\n};\n",
            "go": "func compressedString(word string) string {\nt := []byte{}\ni0 := -1\nfor i := range word {\nc := word[i]\nif i+1 == len(word) || c != word[i+1] {\nk := i - i0\nt = append(t, bytes.Repeat([]byte{'9', c}, k/9)...)\nif k%9 > 0 {\nt = append(t, '0'+byte(k%9), c)\n}\ni0 = i\n}\n}\nreturn string(t)\n}\n",
            "js": "/**\n * @param {string} word\n * @return {string}\n */\nvar compressedString = function(word) {\n\n    let char , i , j , res = '' ;\n    i = j = 0\n    char = word[i]\n    const ok = (s , e , char)=>{\n        while(e-s >=9) {\n            res+= `9${char}`;\n            e-=9\n        }\n        if(e-s) {\n            res+= `${e-s}${char}`;\n        }\n    }\n    for( ;  i<word.length ; i++) {\n        while(char === word[j]) {\n            j++\n        }\n        ok(i , j , char);\n        i = j-1;\n        char = word[j]\n    }\n    return res\n};\n"
        },
        "cases": [
            {
                "input": "[\"\\\"abcde\\\"\"]",
                "output": "[\"\\\"1a1b1c1d1e\\\"\"]"
            },
            {
                "input": "[\"\\\"aaaaaaaaaaaaaabb\\\"\"]",
                "output": "[\"\\\"9a5a2b\\\"\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public String compressedString(String word) {",
            "cpp": "class Solution {\npublic:\n    string compressedString(string word) {",
            "go": "func compressedString(word string) string {\n\n}",
            "js": "/**\n * @param {string} word\n * @return {string}\n */\nvar compressedString = function(word) {",
            "python": "class Solution:\n    def compressedString(self, word: str) -> str:"
        },
        "time": "20240526",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "compressedString",
            "java": "compressedString",
            "cpp": "compressedString",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.compressedString(\"abcde\") == \"1a1b1c1d1e\", \"Test 1 Error!\"\nassert my_solution.compressedString(\"aaaaaaaaaaaaaabb\") == \"9a5a2b\", \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String word_1 = \"abcde\";\n    String ans_1 = \"1a1b1c1d1e\";\n    assert solution.compressedString(word_1).equals(ans_1);\n    String word_2 = \"aaaaaaaaaaaaaabb\";\n    String ans_2 = \"9a5a2b\";\n    assert solution.compressedString(word_2).equals(ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string word_1 = \"abcde\";\n    string ans_1 = \"1a1b1c1d1e\";\n    assert(my_solution_1.compressedString(word_1) == ans_1);\n    Solution my_solution_2;\n    string word_2 = \"aaaaaaaaaaaaaabb\";\n    string ans_2 = \"9a5a2b\";\n    assert(my_solution_2.compressedString(word_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "word"
            ],
            "java": [
                "word"
            ],
            "cpp": [
                "word"
            ],
            "go": [],
            "js": []
        }
    },
    "3164": {
        "description": "给你两个整数数组 nums1 和 nums2，长度分别为 n 和 m。同时给你一个正整数 k。\n如果 nums1[i] 可以被 nums2[j] * k 整除，则称数对 (i, j) 为 优质数对（0 <= i <= n - 1, 0 <= j <= m - 1）。\n返回 优质数对 的总数。",
        "difficulty_level": "Middle",
        "note": "1 <= n, m <= 10^5\n1 <= nums1[i], nums2[j] <= 10^6\n1 <= k <= 10^3",
        "codes": {
            "python": "class Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        cnt1 = Counter(x // k for x in nums1 if x % k == 0)\n        if not cnt1:\n            return 0\n        ans = 0\n        u = max(cnt1)\n        for i, c in Counter(nums2).items():\n            s = sum(cnt1[j] for j in range(i, u + 1, i))\n            ans += s * c\n        return ans\n",
            "java": "public class Solution {\n    public long numberOfPairs(int[] nums1, int[] nums2, int k) {\n        Map<Integer, Integer> cnt1 = new HashMap<>();\n        for (int x : nums1) {\n            if (x % k == 0) {\n                cnt1.merge(x / k, 1, Integer::sum);\n            }\n        }\n        if (cnt1.isEmpty()) {\n            return 0;\n        }\n\n        Map<Integer, Integer> cnt2 = new HashMap<>();\n        for (int x : nums2) {\n            cnt2.merge(x, 1, Integer::sum);\n        }\n\n        long ans = 0;\n        int u = Collections.max(cnt1.keySet());\n        for (Map.Entry<Integer, Integer> e : cnt2.entrySet()) {\n            int s = 0;\n            int i = e.getKey();\n            for (int j = i; j <= u; j += i) {\n                if (cnt1.containsKey(j)) {\n                    s += cnt1.get(j);\n                }\n            }\n            ans += (long) s * e.getValue();\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n        unordered_map<int, int> cnt1;\n        for (int x : nums1) {\n            if (x % k == 0) {\n                cnt1[x / k]++;\n            }\n        }\n        if (cnt1.empty()) {\n            return 0;\n        }\n        unordered_map<int, int> cnt2;\n        for (int x : nums2) {\n            cnt2[x]++;\n        }\n\n        long long ans = 0;\n        int u = ranges::max_element(cnt1)->first;\n        for (auto& [i, c] : cnt2) {\n            int s = 0;\n            for (int j = i; j <= u; j += i) {\n                s += cnt1.contains(j) ? cnt1[j] : 0;\n            }\n            ans += (long long) s * c;\n        }\n        return ans;\n    }\n};\n",
            "go": "func numberOfPairs(nums1, nums2 []int, k int) (ans int64) {\ncnt1 := map[int]int{}\nfor _, x := range nums1 {\nif x%k == 0 {\ncnt1[x/k]++\n}\n}\ncnt2 := map[int]int{}\nfor _, x := range nums2 {\ncnt2[x]++\n}\n\nu := slices.Max(nums1) / k\nfor i, c := range cnt2 {\ns := 0\nfor j := i; j <= u; j += i {\ns += cnt1[j]\n}\nans += int64(s * c)\n}\nreturn\n}\n",
            "js": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number}\n */\n\nvar numberOfPairs = function(nums1, nums2, k) {\n    let d1 = new Map();\n    \n    for (let x of nums1){\n        if (x%k===0){\n            let v = x/k;\n            for (let i=1;i<Math.floor(Math.sqrt(v)+1);i++){\n                if (v%i ===0) {\n                    if (!d1.has(i)) d1.set(i,1);\n                    else d1.set(i,d1.get(i)+1);\n                    let y = v/i;\n                    if (y!=i){\n                        if (!d1.has(y)) d1.set(y,1);\n                        else d1.set(y,d1.get(y)+1);\n                    }\n                }\n            }\n        }\n    }\n    let ans = 0;\n    for (let t of nums2){\n        if (d1.has(t)) ans += d1.get(t);\n    }\n    return ans;\n\n}\n"
        },
        "cases": [
            {
                "input": "[\"[1,3,4]\",\"[1,3,4]\",\"1\"]",
                "output": "[\"5\"]"
            },
            {
                "input": "[\"[1,2,4,12]\",\"[2,4]\",\"3\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long numberOfPairs(int[] nums1, int[] nums2, int k) {",
            "cpp": "class Solution {\npublic:\n    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {",
            "go": "func numberOfPairs(nums1 []int, nums2 []int, k int) int64 {\n\n}",
            "js": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number}\n */\nvar numberOfPairs = function(nums1, nums2, k) {",
            "python": "class Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:"
        },
        "time": "20240526",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "numberOfPairs",
            "java": "numberOfPairs",
            "cpp": "numberOfPairs",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.numberOfPairs([1,3,4], [1,3,4], 1) == 5, \"Test 1 Error!\"\nassert my_solution.numberOfPairs([1,2,4,12], [2,4], 3) == 2, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums1_1 = {1,3,4};\n    int[] nums2_1 = {1,3,4};\n    int k_1 = 1;\n    long ans_1 = 5;\n    assert solution.numberOfPairs(nums1_1, nums2_1, k_1) == ans_1;\n    int[] nums1_2 = {1,2,4,12};\n    int[] nums2_2 = {2,4};\n    int k_2 = 3;\n    long ans_2 = 2;\n    assert solution.numberOfPairs(nums1_2, nums2_2, k_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums1_1 = {1,3,4};\n    vector<int> nums2_1 = {1,3,4};\n    int k_1 = 1;\n    long long ans_1 = 5;\n    assert(my_solution_1.numberOfPairs(nums1_1, nums2_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums1_2 = {1,2,4,12};\n    vector<int> nums2_2 = {2,4};\n    int k_2 = 3;\n    long long ans_2 = 2;\n    assert(my_solution_2.numberOfPairs(nums1_2, nums2_2, k_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums1",
                "nums2",
                "k"
            ],
            "java": [
                "nums1",
                "nums2",
                "k"
            ],
            "cpp": [
                "nums1",
                "nums2",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3165": {
        "description": "给你一个整数数组 nums 和一个二维数组 queries，其中 queries[i] = [posi, xi]。\n对于每个查询 i，首先将 nums[posi] 设置为 xi，然后计算查询 i 的答案，该答案为 nums 中 不包含相邻元素 的 子序列 的 最大 和。\n返回所有查询的答案之和。\n由于最终答案可能非常大，返回其对 10^9 + 7 取余 的结果。\n子序列 是指从另一个数组中删除一些或不删除元素而不改变剩余元素顺序得到的数组。",
        "difficulty_level": "Hard",
        "note": "1 <= nums.length <= 5 * 10^4\n-10^5 <= nums[i] <= 10^5\n1 <= queries.length <= 5 * 10^4\nqueries[i] == [posi, xi]\n0 <= posi <= nums.length - 1\n-10^5 <= xi <= 10^5",
        "codes": {
            "python": "class Solution:\n    def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        # 4 个数分别保存 f00, f01, f10, f11\n        t = [[0] * 4 for _ in range(2 << n.bit_length())]\n\n        def maintain(o: int):\n            a, b = t[o * 2], t[o * 2 + 1]\n            t[o][0] = max(a[0] + b[2], a[1] + b[0])\n            t[o][1] = max(a[0] + b[3], a[1] + b[1])\n            t[o][2] = max(a[2] + b[2], a[3] + b[0])\n            t[o][3] = max(a[2] + b[3], a[3] + b[1])\n\n        # 用 nums 初始化线段树\n        def build(o: int, l: int, r: int) -> None:\n            if l == r:\n                t[o][3] = max(nums[l], 0)\n                return\n            m = (l + r) // 2\n            build(o * 2, l, m)\n            build(o * 2 + 1, m + 1, r)\n            maintain(o)\n\n        # 把 nums[i] 改成 val\n        def update(o: int, l: int, r: int, i: int, val: int) -> None:\n            if l == r:\n                t[o][3] = max(val, 0)\n                return\n            m = (l + r) // 2\n            if i <= m:\n                update(o * 2, l, m, i, val)\n            else:\n                update(o * 2 + 1, m + 1, r, i, val)\n            maintain(o)\n\n        build(1, 0, n - 1)\n        ans = 0\n        for i, x in queries:\n            update(1, 0, n - 1, i, x)\n            ans += t[1][3]  # 注意 f11 没有任何限制，也就是整个数组的打家劫舍\n        return ans % 1_000_000_007\n",
            "java": "class Solution {\n    public int maximumSumSubsequence(int[] nums, int[][] queries) {\n        int n = nums.length;\n        // 4 个数分别保存 f00, f01, f10, f11\n        long[][] t = new long[2 << (32 - Integer.numberOfLeadingZeros(n))][4];\n        build(t, nums, 1, 0, n - 1);\n        long ans = 0;\n        for (int[] q : queries) {\n            update(t, 1, 0, n - 1, q[0], q[1]);\n            ans += t[1][3]; // 注意 f11 没有任何限制，也就是整个数组的打家劫舍\n        }\n        return (int) (ans % 1_000_000_007);\n    }\n\n    private void maintain(long[][] t, int o) {\n        long[] a = t[o * 2], b = t[o * 2 + 1];\n        t[o][0] = Math.max(a[0] + b[2], a[1] + b[0]);\n        t[o][1] = Math.max(a[0] + b[3], a[1] + b[1]);\n        t[o][2] = Math.max(a[2] + b[2], a[3] + b[0]);\n        t[o][3] = Math.max(a[2] + b[3], a[3] + b[1]);\n    }\n\n    // 用 nums 初始化线段树\n    private void build(long[][] t, int[] nums, int o, int l, int r) {\n        if (l == r) {\n            t[o][3] = Math.max(nums[l], 0);\n            return;\n        }\n        int m = (l + r) / 2;\n        build(t, nums, o * 2, l, m);\n        build(t, nums, o * 2 + 1, m + 1, r);\n        maintain(t, o);\n    }\n\n    // 把 nums[i] 改成 val\n    private void update(long[][] t, int o, int l, int r, int i, int val) {\n        if (l == r) {\n            t[o][3] = Math.max(val, 0);\n            return;\n        }\n        int m = (l + r) / 2;\n        if (i <= m) {\n            update(t, o * 2, l, m, i, val);\n        } else {\n            update(t, o * 2 + 1, m + 1, r, i, val);\n        }\n        maintain(t, o);\n    }\n}\n",
            "cpp": "class Solution {\n    // 4 个数分别保存 f00, f01, f10, f11\n    vector<array<unsigned int, 4>> t;\n\n    void maintain(int o) {\n        auto& a = t[o * 2], b = t[o * 2 + 1];\n        t[o] = {\n            max(a[0] + b[2], a[1] + b[0]),\n            max(a[0] + b[3], a[1] + b[1]),\n            max(a[2] + b[2], a[3] + b[0]),\n            max(a[2] + b[3], a[3] + b[1]),\n        };\n    }\n\n    // 用 nums 初始化线段树\n    void build(vector<int>& nums, int o, int l, int r) {\n        if (l == r) {\n            t[o][3] = max(nums[l], 0);\n            return;\n        }\n        int m = (l + r) / 2;\n        build(nums, o * 2, l, m);\n        build(nums, o * 2 + 1, m + 1, r);\n        maintain(o);\n    };\n\n    // 把 nums[i] 改成 val\n    void update(int o, int l, int r, int i, int val) {\n        if (l == r) {\n            t[o][3] = max(val, 0);\n            return;\n        }\n        int m = (l + r) / 2;\n        if (i <= m) {\n            update(o * 2, l, m, i, val);\n        } else {\n            update(o * 2 + 1, m + 1, r, i, val);\n        }\n        maintain(o);\n    };\n\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        t.resize(2 << (32 - __builtin_clz(n)));\n        build(nums, 1, 0, n - 1);\n        long long ans = 0;\n        for (auto& q : queries) {\n            update(1, 0, n - 1, q[0], q[1]);\n            ans += t[1][3]; // 注意 f11 没有任何限制，也就是整个数组的打家劫舍\n        }\n        return ans % 1'000'000'007;\n    }\n};\n",
            "go": "// f00 表示第一个数一定不选，最后一个数一定不选\n// f01 表示第一个数一定不选，最后一个数可选可不选\n// f10 表示第一个数可选可不选，最后一个数一定不选\n// f11 表示第一个数可选可不选，最后一个数可选可不选，也就是没有任何限制\ntype data struct{ f00, f01, f10, f11 int }\ntype seg []data\n\nfunc (t seg) maintain(o int) {\na, b := t[o<<1], t[o<<1|1]\nt[o] = data{\nmax(a.f00+b.f10, a.f01+b.f00),\nmax(a.f00+b.f11, a.f01+b.f01),\nmax(a.f10+b.f10, a.f11+b.f00),\nmax(a.f10+b.f11, a.f11+b.f01),\n}\n}\n\nfunc (t seg) build(a []int, o, l, r int) {\nif l == r {\nt[o].f11 = max(a[l], 0)\nreturn\n}\nm := (l + r) >> 1\nt.build(a, o<<1, l, m)\nt.build(a, o<<1|1, m+1, r)\nt.maintain(o)\n}\n\nfunc (t seg) update(o, l, r, i, val int) {\nif l == r {\nt[o].f11 = max(val, 0)\nreturn\n}\nm := (l + r) >> 1\nif i <= m {\nt.update(o<<1, l, m, i, val)\n} else {\nt.update(o<<1|1, m+1, r, i, val)\n}\nt.maintain(o)\n}\n\nfunc maximumSumSubsequence(nums []int, queries [][]int) (ans int) {\nn := len(nums)\nt := make(seg, 2<<bits.Len(uint(n-1)))\nt.build(nums, 1, 0, n-1)\nfor _, q := range queries {\nt.update(1, 0, n-1, q[0], q[1])\nans += t[1].f11 // 注意 f11 没有任何限制，也就是整个数组的打家劫舍\n}\nreturn ans % 1_000_000_007\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nvar maximumSumSubsequence = function(nums, queries) {\n    const MOD = 10**9 + 7;\n    const n = nums.length;\n    const tree = Array.from({ length: 2 << Math.ceil(Math.log2(n)) }, () => [0, 0, 0, 0]);\n\n    const dptree = (o) => {\n        tree[o][0] = Math.max(tree[2 * o][0] + tree[2 * o + 1][2], tree[2 * o][1] + tree[2 * o + 1][0]);\n        tree[o][1] = Math.max(tree[2 * o][0] + tree[2 * o + 1][3], tree[2 * o][1] + tree[2 * o + 1][1]);\n        tree[o][2] = Math.max(tree[2 * o][2] + tree[2 * o + 1][2], tree[2 * o][3] + tree[2 * o + 1][0]);\n        tree[o][3] = Math.max(tree[2 * o][2] + tree[2 * o + 1][3], tree[2 * o][3] + tree[2 * o + 1][1]);\n    };\n\n    const build = (o, l, r) => {\n        if (l === r) {\n            tree[o][3] = Math.max(nums[l], 0);\n            return;\n        }\n\n        const mid = Math.floor((l + r) / 2);\n\n        build(2 * o, l, mid);\n        build(2 * o + 1, mid + 1, r);\n\n        dptree(o);\n    };\n\n    const update = (o, l, r, i, val) => {\n        if (l === r) {\n            tree[o][3] = Math.max(val, 0);\n            return;\n        }\n\n        const mid = Math.floor((l + r) / 2);\n\n        if (i <= mid) {\n            update(2 * o, l, mid, i, val);\n        } else {\n            update(2 * o + 1, mid + 1, r, i, val);\n        }\n\n        dptree(o);\n    };\n\n    build(1, 0, n - 1);\n\n    let ans = 0;\n    for (const [j, val] of queries) {\n        update(1, 0, n - 1, j, val);\n        ans += tree[1][3];\n    }\n\n    return ans % MOD;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[3,5,9]\",\"[[1,-2],[0,-3]]\"]",
                "output": "[\"21\"]"
            },
            {
                "input": "[\"[0,-1]\",\"[[0,-5]]\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maximumSumSubsequence(int[] nums, int[][] queries) {",
            "cpp": "class Solution {\npublic:\n    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {",
            "go": "func maximumSumSubsequence(nums []int, queries [][]int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number}\n */\nvar maximumSumSubsequence = function(nums, queries) {",
            "python": "class Solution:\n    def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -> int:"
        },
        "time": "20240526",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maximumSumSubsequence",
            "java": "maximumSumSubsequence",
            "cpp": "maximumSumSubsequence",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maximumSumSubsequence([3,5,9], [[1,-2],[0,-3]]) == 21, \"Test 1 Error!\"\nassert my_solution.maximumSumSubsequence([0,-1], [[0,-5]]) == 0, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {3,5,9};\n    int[][] queries_1 = {{1,-2},{0,-3}};\n    int ans_1 = 21;\n    assert solution.maximumSumSubsequence(nums_1, queries_1) == ans_1;\n    int[] nums_2 = {0,-1};\n    int[][] queries_2 = {{0,-5}};\n    int ans_2 = 0;\n    assert solution.maximumSumSubsequence(nums_2, queries_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {3,5,9};\n    vector<vector<int>> queries_1 = {{1,-2},{0,-3}};\n    int ans_1 = 21;\n    assert(my_solution_1.maximumSumSubsequence(nums_1, queries_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {0,-1};\n    vector<vector<int>> queries_2 = {{0,-5}};\n    int ans_2 = 0;\n    assert(my_solution_2.maximumSumSubsequence(nums_2, queries_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "queries"
            ],
            "java": [
                "nums",
                "queries"
            ],
            "cpp": [
                "nums",
                "queries"
            ],
            "go": [],
            "js": []
        }
    },
    "3168": {
        "description": "给你一个字符串 s，模拟每秒钟的事件 i: 如果 s[i] == 'E'，表示有一位顾客进入候诊室并占用一把椅子。如果 s[i] == 'L'，表示有一位顾客离开候诊室，从而释放一把椅子。返回保证每位进入候诊室的顾客都能有椅子坐的 最少 椅子数，假设候诊室最初是 空的 。",
        "difficulty_level": "Easy",
        "note": "1 <= s.length <= 50\n s 仅由字母 'E' 和 'L' 组成。\ns 表示一个有效的进出序列。",
        "codes": {
            "java": "class Solution {\n    public int minimumChairs(String s) {\n        int ans = 0;\n        int cnt = 0;\n        for (char c : s.toCharArray()) {\n            if (c == 'E') {\n                ans = Math.max(ans, ++cnt);\n            } else {\n                cnt--;\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumChairs(string s) {\n        int ans = 0, cnt = 0;\n        for (char c : s) {\n            if (c == 'E') {\n                ans = max(ans, ++cnt);\n            } else {\n                cnt--;\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func minimumChairs(s string) (ans int) {\ncnt := 0\nfor _, c := range s {\nif c == 'E' {\ncnt++\nans = max(ans, cnt)\n} else {\ncnt--\n}\n}\nreturn\n}\n",
            "js": "",
            "python": "class Solution:\n    def minimumChairs(self, s: str) -> int:\n        ans = cnt = 0\n        for c in s:\n            if c == 'E':\n                cnt += 1\n                ans = max(ans, cnt)\n            else:\n                cnt -= 1\n        return ans\n"
        },
        "cases": [
            {
                "input": "[\"\\\"EEEEEEE\\\"\"]",
                "output": "[\"7\"]"
            },
            {
                "input": "[\"\\\"ELELEEL\\\"\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"\\\"ELEELEELLL\\\"\"]",
                "output": "[\"3\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumChairs(String s) {",
            "cpp": "class Solution {\npublic:\n    int minimumChairs(string s) {",
            "go": "func minimumChairs(s string) int {\n\n}",
            "js": "/**\n * @param {string} s\n * @return {number}\n */\nvar minimumChairs = function(s) {",
            "python": "class Solution:\n    def minimumChairs(self, s: str) -> int:"
        },
        "time": "20240602",
        "class_helper": {
            "java": null,
            "cpp": null,
            "go": null,
            "js": null,
            "python": null
        },
        "input_def_helper": {
            "java": null,
            "cpp": null,
            "go": null,
            "js": null,
            "python": null
        },
        "output_def_helper": {
            "java": null,
            "cpp": null,
            "go": null,
            "js": null,
            "python": null
        },
        "function_names": {
            "java": "minimumChairs",
            "cpp": "minimumChairs",
            "go": "",
            "js": "",
            "python": "minimumChairs"
        },
        "references": {
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String s_1 = \"EEEEEEE\";\n    int ans_1 = 7;\n    assert solution.minimumChairs(s_1) == ans_1;\n    String s_2 = \"ELELEEL\";\n    int ans_2 = 2;\n    assert solution.minimumChairs(s_2) == ans_2;\n    String s_3 = \"ELEELEELLL\";\n    int ans_3 = 3;\n    assert solution.minimumChairs(s_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string s_1 = \"EEEEEEE\";\n    int ans_1 = 7;\n    assert(my_solution_1.minimumChairs(s_1) == ans_1);\n    Solution my_solution_2;\n    string s_2 = \"ELELEEL\";\n    int ans_2 = 2;\n    assert(my_solution_2.minimumChairs(s_2) == ans_2);\n    Solution my_solution_3;\n    string s_3 = \"ELEELEELLL\";\n    int ans_3 = 3;\n    assert(my_solution_3.minimumChairs(s_3) == ans_3);\n}",
            "go": "",
            "js": "",
            "python": "my_solution = Solution()\nassert my_solution.minimumChairs(\"EEEEEEE\") == 7, \"Test 1 Error!\"\nassert my_solution.minimumChairs(\"ELELEEL\") == 2, \"Test 2 Error!\"\nassert my_solution.minimumChairs(\"ELEELEELLL\") == 3, \"Test 3 Error!\"\n"
        },
        "vars": {
            "java": [
                "s"
            ],
            "cpp": [
                "s"
            ],
            "go": [],
            "js": [],
            "python": [
                "s"
            ]
        }
    },
    "3169": {
        "description": "给你一个正整数 days，表示员工可工作的总天数（从第 1 天开始）。另给你一个二维数组 meetings，长度为 n，其中 meetings[i] = [start_i, end_i] 表示第 i 次会议的开始和结束天数（包含首尾）。\n\n返回员工可工作且没有安排会议的天数。\n\n注意：会议时间可能会有重叠。",
        "difficulty_level": "Middle",
        "note": "1 <= days <= 10^9 \n 1 <= meetings.length <= 10^5\nmeetings[i].length == 2\n1 <= meetings[i][0] <= meetings[i][1] <= days",
        "codes": {
            "java": "class Solution {\n    public int countDays(int days, int[][] meetings) {\n        Arrays.sort(meetings, (p, q) -> p[0] - q[0]); // 按照左端点从小到大排序\n        int start = 1, end = 0; // 当前合并区间的左右端点\n        for (int[] p : meetings) {\n            if (p[0] > end) { // 不相交\n                days -= end - start + 1; // 当前合并区间的长度\n                start = p[0]; // 下一个合并区间的左端点\n            }\n            end = Math.max(end, p[1]);\n        }\n        days -= end - start + 1; // 最后一个合并区间的长度\n        return days;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int countDays(int days, vector<vector<int>>& meetings) {\n        ranges::sort(meetings); // 按照左端点从小到大排序\n        int start = 1, end = 0; // 当前合并区间的左右端点\n        for (auto& p : meetings) {\n            if (p[0] > end) { // 不相交\n                days -= end - start + 1; // 当前合并区间的长度\n                start = p[0]; // 下一个合并区间的左端点\n            }\n            end = max(end, p[1]);\n        }\n        days -= end - start + 1; // 最后一个合并区间的长度\n        return days;\n    }\n};\n",
            "go": "func countDays(days int, meetings [][]int) int {\nslices.SortFunc(meetings, func(p, q []int) int { return p[0] - q[0] }) // 按照左端点从小到大排序\nstart, end := 1, 0 // 当前合并区间的左右端点\nfor _, p := range meetings {\nif p[0] > end { // 不相交\ndays -= end - start + 1 // 当前合并区间的长度\nstart = p[0] // 下一个合并区间的左端点\n}\nend = max(end, p[1])\n}\ndays -= end - start + 1 // 最后一个合并区间的长度\nreturn days\n}\n",
            "js": "",
            "python": "class Solution:\n    def countDays(self, days: int, meetings: List[List[int]]) -> int:\n        meetings.sort(key=lambda p: p[0])  # 按照左端点从小到大排序\n        start, end = 1, 0  # 当前合并区间的左右端点\n        for s, e in meetings:\n            if s > end:  # 不相交\n                days -= end - start + 1  # 当前合并区间的长度\n                start = s  # 下一个合并区间的左端点\n            end = max(end, e)\n        days -= end - start + 1  # 最后一个合并区间的长度\n        return days\n"
        },
        "cases": [
            {
                "input": "[\"10\",\"[[5,7],[1,3],[9,10]]\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"5\",\"[[2,4],[1,3]]\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"6\",\"[[1,6]]\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int countDays(int days, int[][] meetings) {",
            "cpp": "class Solution {\npublic:\n    int countDays(int days, vector<vector<int>>& meetings) {",
            "go": "func countDays(days int, meetings [][]int) int {\n\n}",
            "js": "/**\n * @param {number} days\n * @param {number[][]} meetings\n * @return {number}\n */\nvar countDays = function(days, meetings) {",
            "python": "class Solution:\n    def countDays(self, days: int, meetings: List[List[int]]) -> int:"
        },
        "time": "20240602",
        "class_helper": {
            "java": null,
            "cpp": null,
            "go": null,
            "js": null,
            "python": null
        },
        "input_def_helper": {
            "java": null,
            "cpp": null,
            "go": null,
            "js": null,
            "python": null
        },
        "output_def_helper": {
            "java": null,
            "cpp": null,
            "go": null,
            "js": null,
            "python": null
        },
        "function_names": {
            "java": "countDays",
            "cpp": "countDays",
            "go": "",
            "js": "",
            "python": "countDays"
        },
        "references": {
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int days_1 = 10;\n    int[][] meetings_1 = {{5,7},{1,3},{9,10}};\n    int ans_1 = 2;\n    assert solution.countDays(days_1, meetings_1) == ans_1;\n    int days_2 = 5;\n    int[][] meetings_2 = {{2,4},{1,3}};\n    int ans_2 = 1;\n    assert solution.countDays(days_2, meetings_2) == ans_2;\n    int days_3 = 6;\n    int[][] meetings_3 = {{1,6}};\n    int ans_3 = 0;\n    assert solution.countDays(days_3, meetings_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int days_1 = 10;\n    vector<vector<int>> meetings_1 = {{5,7},{1,3},{9,10}};\n    int ans_1 = 2;\n    assert(my_solution_1.countDays(days_1, meetings_1) == ans_1);\n    Solution my_solution_2;\n    int days_2 = 5;\n    vector<vector<int>> meetings_2 = {{2,4},{1,3}};\n    int ans_2 = 1;\n    assert(my_solution_2.countDays(days_2, meetings_2) == ans_2);\n    Solution my_solution_3;\n    int days_3 = 6;\n    vector<vector<int>> meetings_3 = {{1,6}};\n    int ans_3 = 0;\n    assert(my_solution_3.countDays(days_3, meetings_3) == ans_3);\n}",
            "go": "",
            "js": "",
            "python": "my_solution = Solution()\nassert my_solution.countDays(10, [[5,7],[1,3],[9,10]]) == 2, \"Test 1 Error!\"\nassert my_solution.countDays(5, [[2,4],[1,3]]) == 1, \"Test 2 Error!\"\nassert my_solution.countDays(6, [[1,6]]) == 0, \"Test 3 Error!\"\n"
        },
        "vars": {
            "java": [
                "days",
                "meetings"
            ],
            "cpp": [
                "days",
                "meetings"
            ],
            "go": [],
            "js": [],
            "python": [
                "days",
                "meetings"
            ]
        }
    },
    "3170": {
        "description": "给你一个字符串 s 。它可能包含任意数量的 '*' 字符。你的任务是删除所有的 '*' 字符。\n\n当字符串还存在至少一个 '*' 字符时，你可以执行以下操作：删除最左边的 '*' 字符，同时删除该星号字符左边一个字典序 最小 的字符。如果有多个字典序最小的字符，你可以删除它们中的任意一个。\n\n请你返回删除所有 '*' 字符以后，剩余字符连接而成的 字典序最小 的字符串。",
        "difficulty_level": "Middle",
        "note": "1 <= s.length <= 10^5 \n s 只含有小写英文字母和 '*' 字符。\n输入保证操作可以删除所有的 '*' 字符。",
        "codes": {
            "java": "class Solution {\n    public String clearStars(String S) {\n        char[] s = S.toCharArray();\n        List<Integer>[] st = new ArrayList[26];\n        Arrays.setAll(st, i -> new ArrayList<>());\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] != '*') {\n                st[s[i] - 'a'].add(i);\n                continue;\n            }\n            for (List<Integer> p : st) {\n                if (!p.isEmpty()) {\n                    p.remove(p.size() - 1);\n                    break;\n                }\n            }\n        }\n\n        List<Integer> idx = new ArrayList<>();\n        for (List<Integer> p : st) {\n            idx.addAll(p);\n        }\n        Collections.sort(idx);\n\n        StringBuilder t = new StringBuilder(idx.size());\n        for (int i : idx) {\n            t.append(s[i]);\n        }\n        return t.toString();\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    string clearStars(string s) {\n        vector<int> st[26];\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] != '*') {\n                st[s[i] - 'a'].push_back(i);\n                continue;\n            }\n            for (auto& p : st) {\n                if (!p.empty()) {\n                    p.pop_back();\n                    break;\n                }\n            }\n        }\n\n        vector<int> idx;\n        for (auto& p : st) {\n            idx.insert(idx.end(), p.begin(), p.end());\n        }\n        ranges::sort(idx);\n\n        string t(idx.size(), 0);\n        for (int i = 0; i < idx.size(); i++) {\n            t[i] = s[idx[i]];\n        }\n        return t;\n    }\n};\n",
            "go": "func clearStars(s string) string {\nst := make([][]int, 26)\nfor i, c := range s {\nif c != '*' {\nst[c-'a'] = append(st[c-'a'], i)\ncontinue\n}\nfor j, p := range st {\nif len(p) > 0 {\nst[j] = p[:len(p)-1]\nbreak\n}\n}\n}\n\nidx := []int{}\nfor _, p := range st {\nidx = append(idx, p...)\n}\nslices.Sort(idx)\n\nt := make([]byte, len(idx))\nfor i, j := range idx {\nt[i] = s[j]\n}\nreturn string(t)\n}\n",
            "js": "",
            "python": "class Solution:\n    def clearStars(self, s: str) -> str:\n        st = [[] for _ in range(26)]\n        for i, c in enumerate(s):\n            if c != '*':\n                st[ord(c) - ord('a')].append(i)\n                continue\n            for p in st:\n                if p:\n                    p.pop()\n                    break\n        return ''.join(s[i] for i in sorted(chain.from_iterable(st)))\n"
        },
        "cases": [
            {
                "input": "[\"\\\"aaba*\\\"\"]",
                "output": "[\"\\\"aab\\\"\"]"
            },
            {
                "input": "[\"\\\"abc\\\"\"]",
                "output": "[\"\\\"abc\\\"\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public String clearStars(String s) {",
            "cpp": "class Solution {\npublic:\n    string clearStars(string s) {",
            "go": "func clearStars(s string) string {\n\n}",
            "js": "/**\n * @param {string} s\n * @return {string}\n */\nvar clearStars = function(s) {",
            "python": "class Solution:\n    def clearStars(self, s: str) -> str:"
        },
        "time": "20240602",
        "class_helper": {
            "java": null,
            "cpp": null,
            "go": null,
            "js": null,
            "python": null
        },
        "input_def_helper": {
            "java": null,
            "cpp": null,
            "go": null,
            "js": null,
            "python": null
        },
        "output_def_helper": {
            "java": null,
            "cpp": null,
            "go": null,
            "js": null,
            "python": null
        },
        "function_names": {
            "java": "clearStars",
            "cpp": "clearStars",
            "go": "",
            "js": "",
            "python": "clearStars"
        },
        "references": {
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String s_1 = \"aaba*\";\n    String ans_1 = \"aab\";\n    assert solution.clearStars(s_1).equals(ans_1);\n    String s_2 = \"abc\";\n    String ans_2 = \"abc\";\n    assert solution.clearStars(s_2).equals(ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string s_1 = \"aaba*\";\n    string ans_1 = \"aab\";\n    assert(my_solution_1.clearStars(s_1) == ans_1);\n    Solution my_solution_2;\n    string s_2 = \"abc\";\n    string ans_2 = \"abc\";\n    assert(my_solution_2.clearStars(s_2) == ans_2);\n}",
            "go": "",
            "js": "",
            "python": "my_solution = Solution()\nassert my_solution.clearStars(\"aaba*\") == \"aab\", \"Test 1 Error!\"\nassert my_solution.clearStars(\"abc\") == \"abc\", \"Test 2 Error!\"\n"
        },
        "vars": {
            "java": [
                "s"
            ],
            "cpp": [
                "s"
            ],
            "go": [],
            "js": [],
            "python": [
                "s"
            ]
        }
    },
    "3171": {
        "description": "给你一个数组 nums 和一个整数 k 。你需要找到 nums 的一个 子数组 ，满足子数组中所有元素按位与运算 AND 的值与 k 的 绝对差 尽可能 小 。换言之，你需要选择一个子数组 nums[l..r] 满足 |k - (nums[l] AND nums[l + 1] ... AND nums[r])| 最小。\n\n请你返回 最小 的绝对差值。\n\n子数组是数组中连续的 非空 元素序列。",
        "difficulty_level": "Hard",
        "note": "1 <= nums.length <= 10^5 \n 1 <= nums[i] <= 10^9\n1 <= k <= 10^9",
        "codes": {
            "python": "class Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        ans = inf\n        for i, x in enumerate(nums):\n            ans = min(ans, abs(x - k))\n            j = i - 1\n            while j >= 0 and nums[j] & x != nums[j]:\n                nums[j] &= x\n                ans = min(ans, abs(nums[j] - k))\n                j -= 1\n        return ans\n",
            "java": "class Solution {\n    public int minimumDifference(int[] nums, int k) {\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i < nums.length; i++) {\n            int x = nums[i];\n            ans = Math.min(ans, Math.abs(x - k));\n            for (int j = i - 1; j >= 0 && (nums[j] & x) != nums[j]; j--) {\n                nums[j] &= x;\n                ans = Math.min(ans, Math.abs(nums[j] - k));\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumDifference(vector<int>& nums, int k) {\n        int ans = INT_MAX;\n        for (int i = 0; i < nums.size(); i++) {\n            int x = nums[i];\n            ans = min(ans, abs(x - k));\n            for (int j = i - 1; j >= 0 && (nums[j] & x) != nums[j]; j--) {\n                nums[j] &= x;\n                ans = min(ans, abs(nums[j] - k));\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func minimumDifference(nums []int, k int) int {\nans := math.MaxInt\nfor i, x := range nums {\nans = min(ans, abs(x-k))\nfor j := i - 1; j >= 0 && nums[j]&x != nums[j]; j-- {\nnums[j] &= x\nans = min(ans, abs(nums[j]-k))\n}\n}\nreturn ans\n}\n\nfunc abs(x int) int { if x < 0 { return -x }; return x }\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[1,2,4,5]\",\"3\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"[1,2,1,2]\",\"2\"]",
                "output": "[\"0\"]"
            },
            {
                "input": "[\"[1]\",\"10\"]",
                "output": "[\"9\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumDifference(int[] nums, int k) {",
            "cpp": "class Solution {\npublic:\n    int minimumDifference(vector<int>& nums, int k) {",
            "go": "func minimumDifference(nums []int, k int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minimumDifference = function(nums, k) {",
            "python": "class Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:"
        },
        "time": "20240602",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumDifference",
            "java": "minimumDifference",
            "cpp": "minimumDifference",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumDifference([1,2,4,5], 3) == 1, \"Test 1 Error!\"\nassert my_solution.minimumDifference([1,2,1,2], 2) == 0, \"Test 2 Error!\"\nassert my_solution.minimumDifference([1], 10) == 9, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,4,5};\n    int k_1 = 3;\n    int ans_1 = 1;\n    assert solution.minimumDifference(nums_1, k_1) == ans_1;\n    int[] nums_2 = {1,2,1,2};\n    int k_2 = 2;\n    int ans_2 = 0;\n    assert solution.minimumDifference(nums_2, k_2) == ans_2;\n    int[] nums_3 = {1};\n    int k_3 = 10;\n    int ans_3 = 9;\n    assert solution.minimumDifference(nums_3, k_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,4,5};\n    int k_1 = 3;\n    int ans_1 = 1;\n    assert(my_solution_1.minimumDifference(nums_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,2,1,2};\n    int k_2 = 2;\n    int ans_2 = 0;\n    assert(my_solution_2.minimumDifference(nums_2, k_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {1};\n    int k_3 = 10;\n    int ans_3 = 9;\n    assert(my_solution_3.minimumDifference(nums_3, k_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "k"
            ],
            "java": [
                "nums",
                "k"
            ],
            "cpp": [
                "nums",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3178": {
        "description": "给你两个 正整数 n 和 k。有 n 个编号从 0 到 n - 1 的孩子按顺序从左到右站成一队。\n最初，编号为 0 的孩子拿着一个球，并且向右传球。每过一秒，拿着球的孩子就会将球传给他旁边的孩子。一旦球到达队列的 任一端 ，即编号为 0 的孩子或编号为 n - 1 的孩子处，传球方向就会 反转 。\n返回 k 秒后接到球的孩子的编号。",
        "difficulty_level": "Easy",
        "note": "2 <= n <= 50\n1 <= k <= 50",
        "codes": {
            "python": "class Solution:\n    def numberOfChild(self, n: int, k: int) -> int:\n        k, t = divmod(k, n - 1)\n        return n - t - 1 if k % 2 else t\n",
            "java": "class Solution {\n    public int numberOfChild(int n, int k) {\n        int t = k % (n - 1);\n        return k / (n - 1) % 2 > 0 ? n - t - 1 : t;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int numberOfChild(int n, int k) {\n        int t = k % (n - 1);\n        return k / (n - 1) % 2 ? n - t - 1 : t;\n    }\n};\n",
            "go": "func numberOfChild(n, k int) int {\nt := k % (n - 1)\nif k/(n-1)%2 > 0 {\nreturn n - t - 1\n}\nreturn t\n}\n",
            "js": "var numberOfChild = function(n, k) {\n    let num = 0, direction = 1;\n    while (k > 0) {\n        if (num + direction < 0 || num + direction >= n) {\n            direction *= -1;\n        }\n        num += direction;\n        k--;\n    }\n    return num;\n};\n"
        },
        "cases": [
            {
                "input": "[\"3\",\"5\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"5\",\"6\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"4\",\"2\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int numberOfChild(int n, int k) {",
            "cpp": "class Solution {\npublic:\n    int numberOfChild(int n, int k) {",
            "go": "func numberOfChild(n int, k int) int {\n\n}",
            "js": "/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar numberOfChild = function(n, k) {",
            "python": "class Solution:\n    def numberOfChild(self, n: int, k: int) -> int:"
        },
        "time": "20240609",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "numberOfChild",
            "java": "numberOfChild",
            "cpp": "numberOfChild",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.numberOfChild(3, 5) == 1, \"Test 1 Error!\"\nassert my_solution.numberOfChild(5, 6) == 2, \"Test 2 Error!\"\nassert my_solution.numberOfChild(4, 2) == 2, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int n_1 = 3;\n    int k_1 = 5;\n    int ans_1 = 1;\n    assert solution.numberOfChild(n_1, k_1) == ans_1;\n    int n_2 = 5;\n    int k_2 = 6;\n    int ans_2 = 2;\n    assert solution.numberOfChild(n_2, k_2) == ans_2;\n    int n_3 = 4;\n    int k_3 = 2;\n    int ans_3 = 2;\n    assert solution.numberOfChild(n_3, k_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int n_1 = 3;\n    int k_1 = 5;\n    int ans_1 = 1;\n    assert(my_solution_1.numberOfChild(n_1, k_1) == ans_1);\n    Solution my_solution_2;\n    int n_2 = 5;\n    int k_2 = 6;\n    int ans_2 = 2;\n    assert(my_solution_2.numberOfChild(n_2, k_2) == ans_2);\n    Solution my_solution_3;\n    int n_3 = 4;\n    int k_3 = 2;\n    int ans_3 = 2;\n    assert(my_solution_3.numberOfChild(n_3, k_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "n",
                "k"
            ],
            "java": [
                "n",
                "k"
            ],
            "cpp": [
                "n",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3179": {
        "description": "给你两个整数 n 和 k。\n最初，你有一个长度为 n 的整数数组 a，对所有 0 <= i <= n - 1，都有 a[i] = 1 。每过一秒，你会同时更新每个元素为其前面所有元素的和加上该元素本身。例如，一秒后，a[0] 保持不变，a[1] 变为 a[0] + a[1]，a[2] 变为 a[0] + a[1] + a[2]，以此类推。\n返回 k 秒后 a[n - 1] 的值。\n由于答案可能非常大，返回其对 10^9 + 7 取余 后的结果。",
        "difficulty_level": "Middle",
        "note": "1 <= n, k <= 1000",
        "codes": {
            "python": "class Solution:\n    def valueAfterKSeconds(self, n: int, k: int) -> int:\n        return comb(n + k - 1, k) % 1_000_000_007\n",
            "java": "class Solution {\n    private static final int MOD = 1_000_000_007;\n    private static final int MX = 2001;\n\n    // 组合数模板\n    private static final long[] FAC = new long[MX];\n    private static final long[] INV_FAC = new long[MX];\n\n    static {\n        FAC[0] = 1;\n        for (int i = 1; i < MX; i++) {\n            FAC[i] = FAC[i - 1] * i % MOD;\n        }\n        INV_FAC[MX - 1] = pow(FAC[MX - 1], MOD - 2);\n        for (int i = MX - 1; i > 0; i--) {\n            INV_FAC[i - 1] = INV_FAC[i] * i % MOD;\n        }\n    }\n\n    private static long comb(int n, int k) {\n        return FAC[n] * INV_FAC[k] % MOD * INV_FAC[n - k] % MOD;\n    }\n\n    public int valueAfterKSeconds(int n, int k) {\n        return (int) comb(n + k - 1, k);\n    }\n\n    private static long pow(long x, int n) {\n        long res = 1;\n        for (; n > 0; n /= 2) {\n            if (n % 2 > 0) {\n                res = res * x % MOD;\n            }\n            x = x * x % MOD;\n        }\n        return res;\n    }\n}\n",
            "cpp": "const int MOD = 1'000'000'007;\nconst int MX = 2001;\n\nlong long q_pow(long long x, int n) {\n    long long res = 1;\n    for (; n > 0; n /= 2) {\n        if (n % 2) {\n            res = res * x % MOD;\n        }\n        x = x * x % MOD;\n    }\n    return res;\n}\n\n// 组合数模板\nlong long fac[MX], inv_fac[MX];\n\nauto init = [] {\n    fac[0] = 1;\n    for (int i = 1; i < MX; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n    }\n    inv_fac[MX - 1] = q_pow(fac[MX - 1], MOD - 2);\n    for (int i = MX - 1; i > 0; i--) {\n        inv_fac[i - 1] = inv_fac[i] * i % MOD;\n    }\n    return 0;\n}();\n\nlong long comb(int n, int k) {\n    return fac[n] * inv_fac[k] % MOD * inv_fac[n - k] % MOD;\n}\n\nclass Solution {\npublic:\n    int valueAfterKSeconds(int n, int k) {\n        return comb(n + k - 1, k);\n    }\n};\n",
            "go": "const mod = 1_000_000_007\nconst mx = 2000\nvar F, invF [mx + 1]int\n\nfunc init() {\nF[0] = 1\nfor i := 1; i <= mx; i++ {\nF[i] = F[i-1] * i % mod\n}\ninvF[mx] = pow(F[mx], mod-2)\nfor i := mx; i > 0; i-- {\ninvF[i-1] = invF[i] * i % mod\n}\n}\n\nfunc valueAfterKSeconds(n, k int) int {\nreturn F[n+k-1] * invF[n-1] % mod * invF[k] % mod\n}\n\nfunc pow(x, n int) int {\nres := 1\nfor ; n > 0; n /= 2 {\nif n%2 > 0 {\nres = res * x % mod\n}\nx = x * x % mod\n}\nreturn res\n}\n",
            "js": "/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar valueAfterKSeconds = function(n, k) {\n    if (k === 0) return 1;\n    const mode = 10 ** 9 + 7;\n    let cur = [];\n    for (let i = 1; i <= n; i++) {\n        cur.push(i);\n    }\n    let temp = [];\n    k--;\n    while(k--) {\n        temp[0] = 1;\n        for (let i = 1 ; i < n ;i++) {\n            temp[i] = (temp[i - 1] + cur[i]) % mode;\n        }\n        cur = temp;\n    }\n    return cur[n - 1];\n};\n"
        },
        "cases": [
            {
                "input": "[\"4\",\"5\"]",
                "output": "[\"56\"]"
            },
            {
                "input": "[\"5\",\"3\"]",
                "output": "[\"35\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int valueAfterKSeconds(int n, int k) {",
            "cpp": "class Solution {\npublic:\n    int valueAfterKSeconds(int n, int k) {",
            "go": "func valueAfterKSeconds(n int, k int) int {\n\n}",
            "js": "/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar valueAfterKSeconds = function(n, k) {",
            "python": "class Solution:\n    def valueAfterKSeconds(self, n: int, k: int) -> int:"
        },
        "time": "20240609",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "valueAfterKSeconds",
            "java": "valueAfterKSeconds",
            "cpp": "valueAfterKSeconds",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.valueAfterKSeconds(4, 5) == 56, \"Test 1 Error!\"\nassert my_solution.valueAfterKSeconds(5, 3) == 35, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int n_1 = 4;\n    int k_1 = 5;\n    int ans_1 = 56;\n    assert solution.valueAfterKSeconds(n_1, k_1) == ans_1;\n    int n_2 = 5;\n    int k_2 = 3;\n    int ans_2 = 35;\n    assert solution.valueAfterKSeconds(n_2, k_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int n_1 = 4;\n    int k_1 = 5;\n    int ans_1 = 56;\n    assert(my_solution_1.valueAfterKSeconds(n_1, k_1) == ans_1);\n    Solution my_solution_2;\n    int n_2 = 5;\n    int k_2 = 3;\n    int ans_2 = 35;\n    assert(my_solution_2.valueAfterKSeconds(n_2, k_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "n",
                "k"
            ],
            "java": [
                "n",
                "k"
            ],
            "cpp": [
                "n",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3180": {
        "description": "给你一个整数数组 rewardValues，长度为 n，代表奖励的值。\n最初，你的总奖励 x 为 0，所有下标都是 未标记 的。你可以执行以下操作 任意次 ：\n从区间 [0, n - 1] 中选择一个 未标记 的下标 i。\n如果 rewardValues[i] 大于 你当前的总奖励 x，则将 rewardValues[i] 加到 x 上（即 x = x + rewardValues[i]），并 标记 下标 i。\n以整数形式返回执行最优操作能够获得的 最大 总奖励。",
        "difficulty_level": "Middle",
        "note": "1 <= rewardValues.length <= 2000\n1 <= rewardValues[i] <= 2000",
        "codes": {
            "python": "class Solution:\n    def maxTotalReward(self, rewardValues: List[int]) -> int:\n        f = 1\n        for v in sorted(set(rewardValues)):\n            f |= (f & ((1 << v) - 1)) << v\n        return f.bit_length() - 1\n",
            "java": "import java.math.BigInteger;\n\nclass Solution {\n    public int maxTotalReward(int[] rewardValues) {\n        BigInteger f = BigInteger.ONE;\n        for (int v : Arrays.stream(rewardValues).distinct().sorted().toArray()) {\n            BigInteger mask = BigInteger.ONE.shiftLeft(v).subtract(BigInteger.ONE);\n            f = f.or(f.and(mask).shiftLeft(v));\n        }\n        return f.bitLength() - 1;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int maxTotalReward(vector<int>& rewardValues) {\n        ranges::sort(rewardValues);\n        rewardValues.erase(unique(rewardValues.begin(), rewardValues.end()), rewardValues.end());\n\n        bitset<100000> f{1};\n        for (int v : rewardValues) {\n            int shift = f.size() - v;\n            // 左移 shift 再右移 shift，把所有 >= v 的比特位置 0\n            // f |= f << shift >> shift << v;\n            f |= f << shift >> (shift - v); // 简化上式\n        }\n        for (int i = rewardValues.back() * 2 - 1; ; i--) {\n            if (f.test(i)) {\n                return i;\n            }\n        }\n    }\n};\n",
            "go": "func maxTotalReward(rewardValues []int) int {\nslices.Sort(rewardValues)\nrewardValues = slices.Compact(rewardValues) // 去重\n\none := big.NewInt(1)\nf := big.NewInt(1)\np := new(big.Int)\nfor _, v := range rewardValues {\nmask := p.Sub(p.Lsh(one, uint(v)), one)\nf.Or(f, p.Lsh(p.And(f, mask), uint(v)))\n}\nreturn f.BitLen() - 1\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[1,1,3,3]\"]",
                "output": "[\"4\"]"
            },
            {
                "input": "[\"[1,6,4,3,2]\"]",
                "output": "[\"11\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maxTotalReward(int[] rewardValues) {",
            "cpp": "class Solution {\npublic:\n    int maxTotalReward(vector<int>& rewardValues) {",
            "go": "func maxTotalReward(rewardValues []int) int {\n\n}",
            "js": "/**\n * @param {number[]} rewardValues\n * @return {number}\n */\nvar maxTotalReward = function(rewardValues) {",
            "python": "class Solution:\n    def maxTotalReward(self, rewardValues: List[int]) -> int:"
        },
        "time": "20240609",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maxTotalReward",
            "java": "maxTotalReward",
            "cpp": "maxTotalReward",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maxTotalReward([1,1,3,3]) == 4, \"Test 1 Error!\"\nassert my_solution.maxTotalReward([1,6,4,3,2]) == 11, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] rewardValues_1 = {1,1,3,3};\n    int ans_1 = 4;\n    assert solution.maxTotalReward(rewardValues_1) == ans_1;\n    int[] rewardValues_2 = {1,6,4,3,2};\n    int ans_2 = 11;\n    assert solution.maxTotalReward(rewardValues_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> rewardValues_1 = {1,1,3,3};\n    int ans_1 = 4;\n    assert(my_solution_1.maxTotalReward(rewardValues_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> rewardValues_2 = {1,6,4,3,2};\n    int ans_2 = 11;\n    assert(my_solution_2.maxTotalReward(rewardValues_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "rewardValues"
            ],
            "java": [
                "rewardValues"
            ],
            "cpp": [
                "rewardValues"
            ],
            "go": [],
            "js": []
        }
    },
    "3181": {
        "description": "给你一个整数数组 rewardValues，长度为 n，代表奖励的值。最初，你的总奖励 x 为 0，所有下标都是 未标记 的。你可以执行以下操作 任意次 ：\n从区间 [0, n - 1] 中选择一个 未标记 的下标 i。\n如果 rewardValues[i] 大于 你当前的总奖励 x，则将 rewardValues[i] 加到 x 上（即 x = x + rewardValues[i]），并 标记 下标 i。\n以整数形式返回执行最优操作能够获得的 最大 总奖励。",
        "difficulty_level": "Hard",
        "note": "1 <= rewardValues.length <= 5 * 10^4\n1 <= rewardValues[i] <= 5 * 10^4",
        "codes": {
            "python": "class Solution:\n    def maxTotalReward(self, rewardValues: List[int]) -> int:\n        m = max(rewardValues)\n        if m - 1 in rewardValues:\n            return m * 2 - 1\n\n        f = 1\n        for v in sorted(set(rewardValues)):\n            f |= (f & ((1 << v) - 1)) << v\n        return f.bit_length() - 1\n",
            "java": "import java.math.BigInteger;\n\nclass Solution {\n    public int maxTotalReward(int[] rewardValues) {\n        int m = 0;\n        for (int v : rewardValues) {\n            m = Math.max(m, v);\n        }\n        for (int v : rewardValues) {\n            if (v == m - 1) {\n                return m * 2 - 1;\n            }\n        }\n\n        BigInteger f = BigInteger.ONE;\n        for (int v : Arrays.stream(rewardValues).distinct().sorted().toArray()) {\n            BigInteger mask = BigInteger.ONE.shiftLeft(v).subtract(BigInteger.ONE);\n            f = f.or(f.and(mask).shiftLeft(v));\n        }\n        return f.bitLength() - 1;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int maxTotalReward(vector<int>& rewardValues) {\n        int m = ranges::max(rewardValues);\n        if (ranges::find(rewardValues, m - 1) != rewardValues.end()) {\n            return m * 2 - 1;\n        }\n\n        ranges::sort(rewardValues);\n        rewardValues.erase(unique(rewardValues.begin(), rewardValues.end()), rewardValues.end());\n        bitset<100000> f{1};\n        for (int v : rewardValues) {\n            int shift = f.size() - v;\n            // 左移 shift 再右移 shift，把所有 >= v 的比特位置 0\n            // f |= f << shift >> shift << v;\n            f |= f << shift >> (shift - v); // 简化上式\n        }\n        for (int i = m * 2 - 1;; i--) {\n            if (f.test(i)) {\n                return i;\n            }\n        }\n    }\n};\n",
            "go": "func maxTotalReward(rewardValues []int) int {\nm := slices.Max(rewardValues)\nif slices.Contains(rewardValues, m-1) {\nreturn m*2 - 1\n}\n\nslices.Sort(rewardValues)\nrewardValues = slices.Compact(rewardValues) // 去重\n\none := big.NewInt(1)\nf := big.NewInt(1)\np := new(big.Int)\nfor _, v := range rewardValues {\nmask := p.Sub(p.Lsh(one, uint(v)), one)\nf.Or(f, p.Lsh(p.And(f, mask), uint(v)))\n}\nreturn f.BitLen() - 1\n}\n",
            "js": "var maxTotalReward = function(rewardValues) {\n    const queue = [...new Set(rewardValues)]\n    queue.sort((a, b) => a - b)\n    let ans = BigInt(1)\n    for (const num of queue) {\n        ans |= (ans & ((BigInt(1) << BigInt(num)) - BigInt(1))) << BigInt(num)\n    }\n    return ans.toString(2).length - 1\n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,1,3,3]\"]",
                "output": "[\"4\"]"
            },
            {
                "input": "[\"[1,6,4,3,2]\"]",
                "output": "[\"11\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maxTotalReward(int[] rewardValues) {",
            "cpp": "class Solution {\npublic:\n    int maxTotalReward(vector<int>& rewardValues) {",
            "go": "func maxTotalReward(rewardValues []int) int {\n\n}",
            "js": "/**\n * @param {number[]} rewardValues\n * @return {number}\n */\nvar maxTotalReward = function(rewardValues) {",
            "python": "class Solution:\n    def maxTotalReward(self, rewardValues: List[int]) -> int:"
        },
        "time": "20240609",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maxTotalReward",
            "java": "maxTotalReward",
            "cpp": "maxTotalReward",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maxTotalReward([1,1,3,3]) == 4, \"Test 1 Error!\"\nassert my_solution.maxTotalReward([1,6,4,3,2]) == 11, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] rewardValues_1 = {1,1,3,3};\n    int ans_1 = 4;\n    assert solution.maxTotalReward(rewardValues_1) == ans_1;\n    int[] rewardValues_2 = {1,6,4,3,2};\n    int ans_2 = 11;\n    assert solution.maxTotalReward(rewardValues_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> rewardValues_1 = {1,1,3,3};\n    int ans_1 = 4;\n    assert(my_solution_1.maxTotalReward(rewardValues_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> rewardValues_2 = {1,6,4,3,2};\n    int ans_2 = 11;\n    assert(my_solution_2.maxTotalReward(rewardValues_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "rewardValues"
            ],
            "java": [
                "rewardValues"
            ],
            "cpp": [
                "rewardValues"
            ],
            "go": [],
            "js": []
        }
    },
    "3184": {
        "description": "给你一个整数数组 hours，表示以 小时 为单位的时间，返回一个整数，表示满足 i < j 且 hours[i] + hours[j] 构成 整天 的下标对 i, j 的数目。\n整天 定义为时间持续时间是 24 小时的 整数倍 。\n例如，1 天是 24 小时，2 天是 48 小时，3 天是 72 小时，以此类推。",
        "difficulty_level": "Easy",
        "note": "1 <= hours.length <= 100\n1 <= hours[i] <= 10^9",
        "codes": {
            "python": "class Solution:\n    def countCompleteDayPairs(self, hours: List[int]) -> int:\n        ans = 0\n        cnt = [0] * 24\n        for t in hours:\n            # 先查询 cnt，再更新 cnt，因为题目要求 i<j\n            # 如果先更新，再查询，就把 i=j 的情况也考虑进去了\n            ans += cnt[(24 - t % 24) % 24]\n            cnt[t % 24] += 1\n        return ans\n",
            "java": "class Solution {\n    public long countCompleteDayPairs(int[] hours) {\n        long ans = 0;\n        int[] cnt = new int[24];\n        for (int t : hours) {\n            // 先查询 cnt，再更新 cnt，因为题目要求 i<j\n            // 如果先更新，再查询，就把 i=j 的情况也考虑进去了\n            ans += cnt[(24 - t % 24) % 24];\n            cnt[t % 24]++;\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long countCompleteDayPairs(vector<int> &hours) {\n        long long ans = 0;\n        int cnt[24]{};\n        for (int t : hours) {\n            // 先查询 cnt，再更新 cnt，因为题目要求 i<j\n            // 如果先更新，再查询，就把 i=j 的情况也考虑进去了\n            ans += cnt[(24 - t % 24) % 24];\n            cnt[t % 24]++;\n        }\n        return ans;\n    }\n};\n",
            "go": "func countCompleteDayPairs(hours []int) (ans int64) {\ncnt := [24]int{}\nfor _, t := range hours {\n// 先查询 cnt，再更新 cnt，因为题目要求 i<j\n// 如果先更新，再查询，就把 i=j 的情况也考虑进去了\nans += int64(cnt[(24-t%24)%24])\ncnt[t%24]++\n}\nreturn\n}\n",
            "js": "/**\n * @param {number[]} hours\n * @return {number}\n */\nvar countCompleteDayPairs = function(hours) {\n    let len= hours.length\n let i =0\n let j= 0\n let cout =0\n for (; i < len;) {\n     j++\nif (i>=j){j++}\nif (j>=len) {\ni++\nj = i + 1\n}\nif ((hours[i] + hours[j]) % 24 == 0){\n    cout++\n}\n}\nreturn cout\n};\n"
        },
        "cases": [
            {
                "input": "[\"[12,12,30,24,24]\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[72,48,24,3]\"]",
                "output": "[\"3\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int countCompleteDayPairs(int[] hours) {",
            "cpp": "class Solution {\npublic:\n    int countCompleteDayPairs(vector<int>& hours) {",
            "go": "func countCompleteDayPairs(hours []int) int {\n\n}",
            "js": "/**\n * @param {number[]} hours\n * @return {number}\n */\nvar countCompleteDayPairs = function(hours) {",
            "python": "class Solution:\n    def countCompleteDayPairs(self, hours: List[int]) -> int:"
        },
        "time": "20240616",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "countCompleteDayPairs",
            "java": "countCompleteDayPairs",
            "cpp": "countCompleteDayPairs",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.countCompleteDayPairs([12,12,30,24,24]) == 2, \"Test 1 Error!\"\nassert my_solution.countCompleteDayPairs([72,48,24,3]) == 3, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] hours_1 = {12,12,30,24,24};\n    int ans_1 = 2;\n    assert solution.countCompleteDayPairs(hours_1) == ans_1;\n    int[] hours_2 = {72,48,24,3};\n    int ans_2 = 3;\n    assert solution.countCompleteDayPairs(hours_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> hours_1 = {12,12,30,24,24};\n    int ans_1 = 2;\n    assert(my_solution_1.countCompleteDayPairs(hours_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> hours_2 = {72,48,24,3};\n    int ans_2 = 3;\n    assert(my_solution_2.countCompleteDayPairs(hours_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "hours"
            ],
            "java": [
                "hours"
            ],
            "cpp": [
                "hours"
            ],
            "go": [],
            "js": []
        }
    },
    "3185": {
        "description": "给你一个整数数组 hours，表示以 小时 为单位的时间，返回一个整数，表示满足 i < j 且 hours[i] + hours[j] 构成 整天 的下标对 i, j 的数目。\n整天 定义为时间持续时间是 24 小时的 整数倍 。\n例如，1 天是 24 小时，2 天是 48 小时，3 天是 72 小时，以此类推。",
        "difficulty_level": "Middle",
        "note": "1 <= hours.length <= 5 * 10^5\n1 <= hours[i] <= 10^9",
        "codes": {
            "python": "class Solution:\n    def countCompleteDayPairs(self, hours: List[int]) -> int:\n        ans = 0\n        cnt = [0] * 24\n        for t in hours:\n            # 先查询 cnt，再更新 cnt，因为题目要求 i<j\n            # 如果先更新，再查询，就把 i=j 的情况也考虑进去了\n            ans += cnt[(24 - t % 24) % 24]\n            cnt[t % 24] += 1\n        return ans\n",
            "java": "class Solution {\n    public long countCompleteDayPairs(int[] hours) {\n        long ans = 0;\n        int[] cnt = new int[24];\n        for (int t : hours) {\n            // 先查询 cnt，再更新 cnt，因为题目要求 i<j\n            // 如果先更新，再查询，就把 i=j 的情况也考虑进去了\n            ans += cnt[(24 - t % 24) % 24];\n            cnt[t % 24]++;\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long countCompleteDayPairs(vector<int> &hours) {\n        long long ans = 0;\n        int cnt[24]{};\n        for (int t : hours) {\n            // 先查询 cnt，再更新 cnt，因为题目要求 i<j\n            // 如果先更新，再查询，就把 i=j 的情况也考虑进去了\n            ans += cnt[(24 - t % 24) % 24];\n            cnt[t % 24]++;\n        }\n        return ans;\n    }\n};\n",
            "go": "func countCompleteDayPairs(hours []int) (ans int64) {\ncnt := [24]int{}\nfor _, t := range hours {\n// 先查询 cnt，再更新 cnt，因为题目要求 i<j\n// 如果先更新，再查询，就把 i=j 的情况也考虑进去了\nans += int64(cnt[(24-t%24)%24])\ncnt[t%24]++\n}\nreturn\n}\n",
            "js": "function countCompleteDayPairs(hours: number[]): number {\n    let res = 0\n    const map = {}\n    for(const h of hours) {\n        if(map[(24 - h%24)%24]) {\n            res += map[(24 - h%24)%24]\n        }\n        map[h % 24] = (map[h % 24] || 0) + 1\n    }\n    return res\n};\n"
        },
        "cases": [
            {
                "input": "[\"[12,12,30,24,24]\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[72,48,24,3]\"]",
                "output": "[\"3\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long countCompleteDayPairs(int[] hours) {",
            "cpp": "class Solution {\npublic:\n    long long countCompleteDayPairs(vector<int>& hours) {",
            "go": "func countCompleteDayPairs(hours []int) int64 {\n\n}",
            "js": "/**\n * @param {number[]} hours\n * @return {number}\n */\nvar countCompleteDayPairs = function(hours) {",
            "python": "class Solution:\n    def countCompleteDayPairs(self, hours: List[int]) -> int:"
        },
        "time": "20240616",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "countCompleteDayPairs",
            "java": "countCompleteDayPairs",
            "cpp": "countCompleteDayPairs",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.countCompleteDayPairs([12,12,30,24,24]) == 2, \"Test 1 Error!\"\nassert my_solution.countCompleteDayPairs([72,48,24,3]) == 3, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] hours_1 = {12,12,30,24,24};\n    long ans_1 = 2;\n    assert solution.countCompleteDayPairs(hours_1) == ans_1;\n    int[] hours_2 = {72,48,24,3};\n    long ans_2 = 3;\n    assert solution.countCompleteDayPairs(hours_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> hours_1 = {12,12,30,24,24};\n    long long ans_1 = 2;\n    assert(my_solution_1.countCompleteDayPairs(hours_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> hours_2 = {72,48,24,3};\n    long long ans_2 = 3;\n    assert(my_solution_2.countCompleteDayPairs(hours_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "hours"
            ],
            "java": [
                "hours"
            ],
            "cpp": [
                "hours"
            ],
            "go": [],
            "js": []
        }
    },
    "3186": {
        "description": "一个魔法师有许多不同的咒语。\n给你一个数组 power ，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。\n已知魔法师使用伤害值为 power[i] 的咒语时，他们就 不能 使用伤害为 power[i] - 2 ，power[i] - 1 ，power[i] + 1 或者 power[i] + 2 的咒语。\n每个咒语最多只能被使用 一次 。\n请你返回这个魔法师可以达到的伤害值之和的 最大值 。",
        "difficulty_level": "Middle",
        "note": "1 <= power.length <= 10^5\n1 <= power[i] <= 10^9",
        "codes": {
            "python": "class Solution:\n    def maximumTotalDamage(self, power: List[int]) -> int:\n        cnt = Counter(power)\n        a = sorted(cnt.keys())\n        @cache\n        def dfs(i: int) -> int:\n            if i < 0:\n                return 0\n            x = a[i]\n            j = i\n            while j and a[j - 1] >= x - 2:\n                j -= 1\n            return max(dfs(i - 1), dfs(j - 1) + x * cnt[x])\n        return dfs(len(a) - 1)\n",
            "java": "class Solution {\n    public long maximumTotalDamage(int[] power) {\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int x : power) {\n            cnt.merge(x, 1, Integer::sum);\n        }\n\n        int n = cnt.size();\n        int[] a = new int[n];\n        int k = 0;\n        for (int x : cnt.keySet()) {\n            a[k++] = x;\n        }\n        Arrays.sort(a);\n\n        long[] memo = new long[n];\n        Arrays.fill(memo, -1);\n        return dfs(a, cnt, memo, n - 1);\n    }\n\n    private long dfs(int[] a, Map<Integer, Integer> cnt, long[] memo, int i) {\n        if (i < 0) {\n            return 0;\n        }\n        if (memo[i] != -1) {\n            return memo[i];\n        }\n        int x = a[i];\n        int j = i;\n        while (j > 0 && a[j - 1] >= x - 2) {\n            j--;\n        }\n        return memo[i] = Math.max(dfs(a, cnt, memo, i - 1), dfs(a, cnt, memo, j - 1) + (long) x * cnt.get(x));\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long maximumTotalDamage(vector<int>& power) {\n        unordered_map<int, int> cnt;\n        for (int x : power) {\n            cnt[x]++;\n        }\n\n        vector<pair<int, int>> a(cnt.begin(), cnt.end());\n        ranges::sort(a);\n\n        int n = a.size();\n        vector<long long> memo(n, -1);\n        auto dfs = [&](auto&& dfs, int i) -> long long {\n            if (i < 0) {\n                return 0;\n            }\n            long long& res = memo[i]; // 注意这里是引用\n            if (res != -1) {\n                return res;\n            }\n            auto& [x, c] = a[i];\n            int j = i;\n            while (j && a[j - 1].first >= x - 2) {\n                j--;\n            }\n            return res = max(dfs(dfs, i - 1), dfs(dfs, j - 1) + (long long) x * c);\n        };\n        return dfs(dfs, n - 1);\n    }\n};\n",
            "go": "func maximumTotalDamage(power []int) int64 {\ncnt := map[int]int{}\nfor _, x := range power {\ncnt[x]++\n}\n\nn := len(cnt)\na := make([]int, 0, n)\nfor x := range cnt {\na = append(a, x)\n}\nslices.Sort(a)\n\nmemo := make([]int, n)\nfor i := range memo {\nmemo[i] = -1\n}\nvar dfs func(int) int\ndfs = func(i int) int {\nif i < 0 {\nreturn 0\n}\np := &memo[i]\nif *p != -1 {\nreturn *p\n}\nx := a[i]\nj := i\nfor j > 0 && a[j-1] >= x-2 {\nj--\n}\n*p = max(dfs(i-1), dfs(j-1)+x*cnt[x])\nreturn *p\n}\nreturn int64(dfs(n - 1))\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[1,1,3,4]\"]",
                "output": "[\"6\"]"
            },
            {
                "input": "[\"[7,1,6,6]\"]",
                "output": "[\"13\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long maximumTotalDamage(int[] power) {",
            "cpp": "class Solution {\npublic:\n    long long maximumTotalDamage(vector<int>& power) {",
            "go": "func maximumTotalDamage(power []int) int64 {\n\n}",
            "js": "/**\n * @param {number[]} power\n * @return {number}\n */\nvar maximumTotalDamage = function(power) {",
            "python": "class Solution:\n    def maximumTotalDamage(self, power: List[int]) -> int:"
        },
        "time": "20240616",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maximumTotalDamage",
            "java": "maximumTotalDamage",
            "cpp": "maximumTotalDamage",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maximumTotalDamage([1,1,3,4]) == 6, \"Test 1 Error!\"\nassert my_solution.maximumTotalDamage([7,1,6,6]) == 13, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] power_1 = {1,1,3,4};\n    long ans_1 = 6;\n    assert solution.maximumTotalDamage(power_1) == ans_1;\n    int[] power_2 = {7,1,6,6};\n    long ans_2 = 13;\n    assert solution.maximumTotalDamage(power_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> power_1 = {1,1,3,4};\n    long long ans_1 = 6;\n    assert(my_solution_1.maximumTotalDamage(power_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> power_2 = {7,1,6,6};\n    long long ans_2 = 13;\n    assert(my_solution_2.maximumTotalDamage(power_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "power"
            ],
            "java": [
                "power"
            ],
            "cpp": [
                "power"
            ],
            "go": [],
            "js": []
        }
    },
    "3187": {
        "description": "数组 arr 中 大于 前面和后面相邻元素的元素被称为 峰值 元素。\n给你一个整数数组 nums 和一个二维整数数组 queries 。\n你需要处理以下两种类型的操作：\nqueries[i] = [1, l_i, r_i] ，求出子数组 nums[l_i..r_i] 中 峰值 元素的数目。\nqueries[i] = [2, index_i, val_i] ，将 nums[index_i] 变为 val_i 。\n请你返回一个数组 answer ，它依次包含每一个第一种操作的答案。\n注意：子数组中 第一个 和 最后一个 元素都 不是 峰值元素。",
        "difficulty_level": "Hard",
        "note": "3 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\n1 <= queries.length <= 10^5\nqueries[i][0] == 1 或者 queries[i][0] == 2\n对于所有的 i ，都有：\nqueries[i][0] == 1 ：0 <= queries[i][1] <= queries[i][2] <= nums.length - 1\nqueries[i][0] == 2 ：0 <= queries[i][1] <= nums.length - 1, 1 <= queries[i][2] <= 10^5",
        "codes": {
            "python": "class Fenwick:\n    __slots__ = 'f'\n\n    def __init__(self, n: int):\n        self.f = [0] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.f):\n            self.f[i] += val\n            i += i & -i\n\n    def pre(self, i: int) -> int:\n        res = 0\n        while i > 0:\n            res += self.f[i]\n            i &= i - 1\n        return res\n\n    def query(self, l: int, r: int) -> int:\n        if r < l:\n            return 0\n        return self.pre(r) - self.pre(l - 1)\n\nclass Solution:\n    def countOfPeaks(self, nums, queries):\n        n = len(nums)\n        f = Fenwick(n - 1)\n        def update(i: int, val: int) -> None:\n            if nums[i - 1] < nums[i] and nums[i] > nums[i + 1]:\n                f.update(i, val)\n        for i in range(1, n - 1):\n            update(i, 1)\n\n        ans = []\n        for op, i, val in queries:\n            if op == 1:\n                ans.append(f.query(i + 1, val - 1))\n                continue\n            for j in range(max(i - 1, 1), min(i + 2, n - 1)):\n                update(j, -1)\n            nums[i] = val\n            for j in range(max(i - 1, 1), min(i + 2, n - 1)):\n                update(j, 1)\n        return ans\n",
            "java": "class Fenwick {\n    private final int[] f;\n\n    Fenwick(int n) {\n        f = new int[n];\n    }\n\n    void update(int i, int val) {\n        for (; i < f.length; i += i & -i) {\n            f[i] += val;\n        }\n    }\n\n    private int pre(int i) {\n        int res = 0;\n        for (; i > 0; i &= i - 1) {\n            res += f[i];\n        }\n        return res;\n    }\n\n    int query(int l, int r) {\n        if (r < l) {\n            return 0;\n        }\n        return pre(r) - pre(l - 1);\n    }\n}\n\nclass Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        int n = nums.length;\n        Fenwick f = new Fenwick(n - 1);\n        for (int i = 1; i < n - 1; i++) {\n            update(f, nums, i, 1);\n        }\n\n        List<Integer> ans = new ArrayList<>();\n        for (int[] q : queries) {\n            if (q[0] == 1) {\n                ans.add(f.query(q[1] + 1, q[2] - 1));\n                continue;\n            }\n            int i = q[1];\n            for (int j = Math.max(i - 1, 1); j <= Math.min(i + 1, n - 2); j++) {\n                update(f, nums, j, -1);\n            }\n            nums[i] = q[2];\n            for (int j = Math.max(i - 1, 1); j <= Math.min(i + 1, n - 2); j++) {\n                update(f, nums, j, 1);\n            }\n        }\n        return ans;\n    }\n\n    private void update(Fenwick f, int[] nums, int i, int val) {\n        if (nums[i - 1] < nums[i] && nums[i] > nums[i + 1]) {\n            f.update(i, val);\n        }\n    }\n}\n",
            "cpp": "class Fenwick {\n    vector<int> f;\n\npublic:\n    Fenwick(int n) : f(n) {}\n\n    void update(int i, int val) {\n        for (; i < f.size(); i += i & -i) {\n            f[i] += val;\n        }\n    }\n\n    int pre(int i) {\n        int res = 0;\n        for (; i > 0; i &= i - 1) {\n            res += f[i];\n        }\n        return res;\n    }\n\n    int query(int l, int r) {\n        if (r < l) {\n            return 0;\n        }\n        return pre(r) - pre(l - 1);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        Fenwick f(n - 1);\n        auto update = [&](int i, int val) {\n            if (nums[i - 1] < nums[i] && nums[i] > nums[i + 1]) {\n                f.update(i, val);\n            }\n        };\n        for (int i = 1; i < n - 1; i++) {\n            update(i, 1);\n        }\n\n        vector<int> ans;\n        for (auto& q : queries) {\n            if (q[0] == 1) {\n                ans.push_back(f.query(q[1] + 1, q[2] - 1));\n                continue;\n            }\n            int i = q[1];\n            for (int j = max(i - 1, 1); j <= min(i + 1, n - 2); ++j) {\n                update(j, -1);\n            }\n            nums[i] = q[2];\n            for (int j = max(i - 1, 1); j <= min(i + 1, n - 2); ++j) {\n                update(j, 1);\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "type fenwick []int\n\nfunc (f fenwick) update(i, val int) {\nfor ; i < len(f); i += i & -i {\nf[i] += val\n}\n}\n\nfunc (f fenwick) pre(i int) (res int) {\nfor ; i > 0; i &= i - 1 {\nres += f[i]\n}\nreturn res\n}\n\nfunc (f fenwick) query(l, r int) int {\nif r < l {\nreturn 0\n}\nreturn f.pre(r) - f.pre(l-1)\n}\n\nfunc countOfPeaks(nums []int, queries [][]int) (ans []int) {\nn := len(nums)\nf := make(fenwick, n-1)\nupdate := func(i, val int) {\nif nums[i-1] < nums[i] && nums[i] > nums[i+1] {\nf.update(i, val)\n}\n}\nfor i := 1; i < n-1; i++ {\nupdate(i, 1)\n}\n\nfor _, q := range queries {\nif q[0] == 1 {\nans = append(ans, f.query(q[1]+1, q[2]-1))\ncontinue\n}\ni := q[1]\nfor j := max(i-1, 1); j <= min(i+1, n-2); j++ {\nupdate(j, -1)\n}\nnums[i] = q[2]\nfor j := max(i-1, 1); j <= min(i+1, n-2); j++ {\nupdate(j, 1)\n}\n}\nreturn\n}\n",
            "js": "const MAX = 1_000_00n\nconst queue = []\nfor (let oMask = 1n, length = 1n; length < MAX; oMask |= oMask << length, length <<= 1n) {\n    let mask = oMask\n    for (let l = length; l < MAX; l <<= 1n) mask |= mask << (l << 1n)\n    queue.push([mask, mask << length, length])\n}\n\nfunction bitCount(num) {\n    for (const [mask, xMask, length] of queue) {\n        num = ((xMask & num) >> length) + (mask & num)\n    }\n    return num\n}\n\nvar countOfPeaks = function(nums, queries) {\n    const n = nums.length\n    if (n <= 2) return queries.filter(it => it[0] == 1).fill(0)\n    \n    let tree = 0n;\n    for (let index = 1n, m = BigInt(n - 1); index < m; index++) {\n        if (nums[index - 1n] < nums[index] && nums[index] > nums[index + 1n]) tree |= 1n << index;\n    }\n\n    const ans = []\n    let index = -1, flag1 = false, flag2 = false;\n    for (const [a,b,c] of queries) {\n        if (a == 1) {\n            if (c - b > 1) ans.push(bitCount((tree & ((1n << BigInt(c)) - 1n)) >> BigInt(b + 1)));\n            else ans.push(0);\n        } else {\n            if (nums[b] == c) continue;\n            if (b != 0 && b != n - 1) {\n                index = b\n                flag1 = nums[index - 1] < nums[index] && nums[index] > nums[index + 1]\n                flag2 = nums[index - 1] < c && c > nums[index + 1]\n                if (flag1 != flag2) tree ^= 1n << BigInt(index)\n            }\n            if (b > 1) {\n                index = b - 1\n                flag1 = nums[index - 1] < nums[index] && nums[index] > nums[index + 1]\n                flag2 = nums[index - 1] < nums[index] && nums[index] > c\n                if (flag1 != flag2) tree ^= 1n << BigInt(index)\n            }\n            if (b < n - 2) {\n                index = b + 1\n                flag1 = nums[index - 1] < nums[index] && nums[index] > nums[index + 1]\n                flag2 = c < nums[index] && nums[index] > nums[index + 1]\n                if (flag1 != flag2) tree ^= 1n << BigInt(index)\n            }\n            nums[b] = c;\n        }\n    }\n    return ans;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[3,1,4,2,5]\",\"[[2,3,4],[1,0,4]]\"]",
                "output": "[\"[0]\"]"
            },
            {
                "input": "[\"[4,1,4,2,1,5]\",\"[[2,2,4],[1,0,2],[1,0,4]]\"]",
                "output": "[\"[0,1]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {",
            "cpp": "class Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {",
            "go": "func countOfPeaks(nums []int, queries [][]int) []int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar countOfPeaks = function(nums, queries) {",
            "python": "class Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:"
        },
        "time": "20240616",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "countOfPeaks",
            "java": "countOfPeaks",
            "cpp": "countOfPeaks",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.countOfPeaks([3,1,4,2,5], [[2,3,4],[1,0,4]]) == [0], \"Test 1 Error!\"\nassert my_solution.countOfPeaks([4,1,4,2,1,5], [[2,2,4],[1,0,2],[1,0,4]]) == [0,1], \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {3,1,4,2,5};\n    int[][] queries_1 = {{2,3,4},{1,0,4}};\n    List<Integer> ans_1 = [0];\n    assert solution.countOfPeaks(nums_1, queries_1).equals(ans_1);\n    int[] nums_2 = {4,1,4,2,1,5};\n    int[][] queries_2 = {{2,2,4},{1,0,2},{1,0,4}};\n    List<Integer> ans_2 = [0,1];\n    assert solution.countOfPeaks(nums_2, queries_2).equals(ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {3,1,4,2,5};\n    vector<vector<int>> queries_1 = {{2,3,4},{1,0,4}};\n    vector<int> ans_1 = {0};\n    assert(my_solution_1.countOfPeaks(nums_1, queries_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {4,1,4,2,1,5};\n    vector<vector<int>> queries_2 = {{2,2,4},{1,0,2},{1,0,4}};\n    vector<int> ans_2 = {0,1};\n    assert(my_solution_2.countOfPeaks(nums_2, queries_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "queries"
            ],
            "java": [
                "nums",
                "queries"
            ],
            "cpp": [
                "nums",
                "queries"
            ],
            "go": [],
            "js": []
        }
    },
    "3194": {
        "description": "你有一个初始为空的浮点数数组 averages。另给你一个包含 n 个整数的数组 nums，其中 n 为偶数。\n你需要重复以下步骤 n / 2 次：\n从 nums 中移除 最小 的元素 minElement 和 最大 的元素 maxElement。\n将 (minElement + maxElement) / 2 加入到 averages 中。\n返回 averages 中的 最小 元素。",
        "difficulty_level": "Easy",
        "note": "2 <= n == nums.length <= 50\nn 为偶数。\n1 <= nums[i] <= 50",
        "codes": {
            "python": "class Solution:\n    def minimumAverage(self, nums: List[int]) -> float:\n        nums.sort()\n        return min(nums[i] + nums[-1 - i] for i in range(len(nums) // 2)) / 2\n",
            "java": "public class Solution {\n    public double minimumAverage(int[] nums) {\n        Arrays.sort(nums);\n        int ans = Integer.MAX_VALUE;\n        int n = nums.length;\n        for (int i = 0; i < n / 2; i++) {\n            ans = Math.min(ans, nums[i] + nums[n - 1 - i]);\n        }\n        return ans / 2.0;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    double minimumAverage(vector<int>& nums) {\n        ranges::sort(nums);\n        int n = nums.size();\n        int ans = INT_MAX;\n        for (int i = 0; i < n / 2; ++i) {\n            ans = min(ans, nums[i] + nums[n - 1 - i]);\n        }\n        return ans / 2.0;\n    }\n};\n",
            "go": "func minimumAverage(nums []int) float64 {\nslices.Sort(nums)\nans := math.MaxInt\nfor i, n := 0, len(nums); i < n/2; i++ {\nans = min(ans, nums[i]+nums[n-1-i])\n}\nreturn float64(ans) / 2\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[7,8,3,4,15,13,4,1]\"]",
                "output": "[\"5.5\"]"
            },
            {
                "input": "[\"[1,9,8,3,10,5]\"]",
                "output": "[\"5.5\"]"
            },
            {
                "input": "[\"[1,2,3,7,8,9]\"]",
                "output": "[\"5.0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public double minimumAverage(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    double minimumAverage(vector<int>& nums) {",
            "go": "func minimumAverage(nums []int) float64 {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumAverage = function(nums) {",
            "python": "class Solution:\n    def minimumAverage(self, nums: List[int]) -> float:"
        },
        "time": "20240623",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumAverage",
            "java": "minimumAverage",
            "cpp": "minimumAverage",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumAverage([7,8,3,4,15,13,4,1]) == 5.5, \"Test 1 Error!\"\nassert my_solution.minimumAverage([1,9,8,3,10,5]) == 5.5, \"Test 2 Error!\"\nassert my_solution.minimumAverage([1,2,3,7,8,9]) == 5.0, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {7,8,3,4,15,13,4,1};\n    double ans_1 = 5.5;\n    assert solution.minimumAverage(nums_1) == ans_1;\n    int[] nums_2 = {1,9,8,3,10,5};\n    double ans_2 = 5.5;\n    assert solution.minimumAverage(nums_2) == ans_2;\n    int[] nums_3 = {1,2,3,7,8,9};\n    double ans_3 = 5.0;\n    assert solution.minimumAverage(nums_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {7,8,3,4,15,13,4,1};\n    double ans_1 = 5.5;\n    assert(my_solution_1.minimumAverage(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,9,8,3,10,5};\n    double ans_2 = 5.5;\n    assert(my_solution_2.minimumAverage(nums_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {1,2,3,7,8,9};\n    double ans_3 = 5.0;\n    assert(my_solution_3.minimumAverage(nums_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3195": {
        "description": "给你一个二维 二进制 数组 grid。请你找出一个边在水平方向和竖直方向上、面积 最小 的矩形，并且满足 grid 中所有的 1 都在矩形的内部。\n返回这个矩形可能的 最小 面积。",
        "difficulty_level": "Middle",
        "note": "1 <= grid.length, grid[i].length <= 1000\ngrid[i][j] 是 0 或 1。\n输入保证 grid 中至少有一个 1 。",
        "codes": {
            "python": "class Solution:\n    def minimumArea(self, grid: List[List[int]]) -> int:\n        left, right = len(grid[0]), 0\n        top, bottom = len(grid), 0\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                if x:\n                    left = min(left, j)\n                    right = max(right, j)\n                    top = min(top, i)\n                    bottom = i\n        return (right - left + 1) * (bottom - top + 1)\n",
            "java": "public class Solution {\n    public int minimumArea(int[][] grid) {\n        int left = grid[0].length;\n        int right = 0;\n        int top = grid.length;\n        int bottom = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[i].length; j++) {\n                if (grid[i][j] == 1) {\n                    left = Math.min(left, j);\n                    right = Math.max(right, j);\n                    top = Math.min(top, i);\n                    bottom = i;\n                }\n            }\n        }\n        return (right - left + 1) * (bottom - top + 1);\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumArea(vector<vector<int>>& grid) {\n        int left = grid[0].size(), right = 0, top = grid.size(), bottom = 0;\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[i].size(); j++) {\n                if (grid[i][j]) {\n                    left = min(left, j);\n                    right = max(right, j);\n                    top = min(top, i);\n                    bottom = i;\n                }\n            }\n        }\n        return (right - left + 1) * (bottom - top + 1);\n    }\n};\n",
            "go": "func minimumArea(grid [][]int) int {\nleft, right := len(grid[0]), 0\ntop, bottom := len(grid), 0\nfor i, row := range grid {\nfor j, x := range row {\nif x == 1 {\nleft = min(left, j)\nright = max(right, j)\ntop = min(top, i)\nbottom = i\n}\n}\n}\nreturn (right - left + 1) * (bottom - top + 1)\n}\n",
            "js": "function minimumArea(grid) {\n  let maxRow = Number.MIN_SAFE_INTEGER, maxCol = Number.MIN_SAFE_INTEGER\n  let minRow = Number.MAX_SAFE_INTEGER, minCol = Number.MAX_SAFE_INTEGER\n  let n = grid[0].length\n\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < n; col++) {\n      if (grid[row].indexOf(1) === -1) {\n        break\n      }\n      minCol = Math.min(minCol, grid[row].indexOf(1))\n      maxCol = Math.max(maxCol, grid[row].lastIndexOf(1))\n\n      minRow = Math.min(minRow, row)\n      maxRow = Math.max(maxRow, row)\n    }\n  }\n\n  return (maxRow - minRow + 1) * (maxCol - minCol + 1)\n};\n"
        },
        "cases": [
            {
                "input": "[\"[[0,1,0],[1,0,1]]\"]",
                "output": "[\"6\"]"
            },
            {
                "input": "[\"[[0,0],[1,0]]\"]",
                "output": "[\"1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumArea(int[][] grid) {",
            "cpp": "class Solution {\npublic:\n    int minimumArea(vector<vector<int>>& grid) {",
            "go": "func minimumArea(grid [][]int) int {\n\n}",
            "js": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumArea = function(grid) {",
            "python": "class Solution:\n    def minimumArea(self, grid: List[List[int]]) -> int:"
        },
        "time": "20240623",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumArea",
            "java": "minimumArea",
            "cpp": "minimumArea",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumArea([[0,1,0],[1,0,1]]) == 6, \"Test 1 Error!\"\nassert my_solution.minimumArea([[0,0],[1,0]]) == 1, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] grid_1 = {{0,1,0},{1,0,1}};\n    int ans_1 = 6;\n    assert solution.minimumArea(grid_1) == ans_1;\n    int[][] grid_2 = {{0,0},{1,0}};\n    int ans_2 = 1;\n    assert solution.minimumArea(grid_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> grid_1 = {{0,1,0},{1,0,1}};\n    int ans_1 = 6;\n    assert(my_solution_1.minimumArea(grid_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> grid_2 = {{0,0},{1,0}};\n    int ans_2 = 1;\n    assert(my_solution_2.minimumArea(grid_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "grid"
            ],
            "java": [
                "grid"
            ],
            "cpp": [
                "grid"
            ],
            "go": [],
            "js": []
        }
    },
    "3196": {
        "description": "给你一个长度为 n 的整数数组 nums。子数组 nums[l..r]（其中 0 <= l <= r < n）的 成本 定义为：cost(l, r) = nums[l] - nums[l + 1] + ... + nums[r] * (−1)^{r − l}\n你的任务是将 nums 分割成若干子数组，使得所有子数组的成本之和 最大化，并确保每个元素 正好 属于一个子数组。\n具体来说，如果 nums 被分割成 k 个子数组，且分割点为索引 i_1, i_2, ..., i_{k − 1}（其中 0 <= i_1 < i_2 < ... < i_{k - 1} < n - 1），则总成本为：\ncost(0, i_1) + cost(i_1 + 1, i_2) + ... + cost(i_{k − 1} + 1, n − 1)\n返回在最优分割方式下的子数组成本之和的最大值。\n注意：如果 nums 没有被分割，即 k = 1，则总成本即为 cost(0, n - 1)。",
        "difficulty_level": "Middle",
        "note": "1 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9",
        "codes": {
            "python": "class Solution:\n    def maximumTotalCost(self, a: List[int]) -> int:\n        @cache  # 缓存装饰器，避免重复计算 dfs 的结果（记忆化）\n        def dfs(i: int) -> int:\n            if i < 0:\n                return 0\n            if i == 0:\n                return a[0]\n            return max(dfs(i - 1) + a[i], dfs(i - 2) + a[i - 1] - a[i])\n        return dfs(len(a) - 1)\n",
            "java": "class Solution {\n    public long maximumTotalCost(int[] a) {\n        int n = a.length;\n        long[] memo = new long[n];\n        Arrays.fill(memo, Long.MIN_VALUE); // Long.MIN_VALUE 表示没有计算过\n        return dfs(n - 1, a, memo);\n    }\n\n    private long dfs(int i, int[] a, long[] memo) {\n        if (i < 0) {\n            return 0;\n        }\n        if (i == 0) {\n            return a[0];\n        }\n        if (memo[i] != Long.MIN_VALUE) { // 之前计算过\n            return memo[i];\n        }\n        return memo[i] = Math.max(dfs(i - 1, a, memo) + a[i], dfs(i - 2, a, memo) + a[i - 1] - a[i]);\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long maximumTotalCost(vector<int>& a) {\n        int n = a.size();\n        vector<long long> memo(n, LLONG_MIN); // LLONG_MIN 表示没有计算过\n        auto dfs = [&](auto&& dfs, int i) -> long long {\n            if (i < 0) {\n                return 0;\n            }\n            if (i == 0) {\n                return a[0];\n            }\n            auto& res = memo[i]; // 注意这里是引用\n            if (res != LLONG_MIN) { // 之前计算过\n                return res;\n            }\n            return res = max(dfs(dfs, i - 1) + a[i], dfs(dfs, i - 2) + a[i - 1] - a[i]);\n        };\n        return dfs(dfs, n - 1);\n    }\n};\n",
            "go": "func maximumTotalCost(a []int) int64 {\nn := len(a)\nmemo := make([]int, n)\nfor i := range memo {\nmemo[i] = math.MinInt\n}\nvar dfs func(int) int\ndfs = func(i int) int {\nif i < 0 {\nreturn 0\n}\nif i == 0 {\nreturn a[0]\n}\np := &memo[i]\nif *p != math.MinInt {\nreturn *p\n}\n*p = max(dfs(i-1)+a[i], dfs(i-2)+a[i-1]-a[i])\nreturn *p\n}\nreturn int64(dfs(n - 1))\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumTotalCost = function(nums) {\n\n    if(nums.length==0) return nums[0]\n    let n = nums.length\n    let dp = new Array(nums.length).fill().map(()=>new Array(2).fill(0))\n    dp[0][0] = nums[0]\n    dp[0][1] = nums[0]\n\n    for(let i = 1;i<nums.length;i++){\n        dp[i][0] = dp[i-1][1] - nums[i]\n        dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]) + nums[i]\n    }\n    // console.log(dp)\n\n    return Math.max(dp[n-1][0],dp[n-1][1])\n\n\n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,-2,3,4]\"]",
                "output": "[\"10\"]"
            },
            {
                "input": "[\"[1,-1,1,-1]\"]",
                "output": "[\"4\"]"
            },
            {
                "input": "[\"[0]\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long maximumTotalCost(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    long long maximumTotalCost(vector<int>& nums) {",
            "go": "func maximumTotalCost(nums []int) int64 {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumTotalCost = function(nums) {",
            "python": "class Solution:\n    def maximumTotalCost(self, nums: List[int]) -> int:"
        },
        "time": "20240623",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maximumTotalCost",
            "java": "maximumTotalCost",
            "cpp": "maximumTotalCost",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maximumTotalCost([1,-2,3,4]) == 10, \"Test 1 Error!\"\nassert my_solution.maximumTotalCost([1,-1,1,-1]) == 4, \"Test 2 Error!\"\nassert my_solution.maximumTotalCost([0]) == 0, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,-2,3,4};\n    long ans_1 = 10;\n    assert solution.maximumTotalCost(nums_1) == ans_1;\n    int[] nums_2 = {1,-1,1,-1};\n    long ans_2 = 4;\n    assert solution.maximumTotalCost(nums_2) == ans_2;\n    int[] nums_3 = {0};\n    long ans_3 = 0;\n    assert solution.maximumTotalCost(nums_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,-2,3,4};\n    long long ans_1 = 10;\n    assert(my_solution_1.maximumTotalCost(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,-1,1,-1};\n    long long ans_2 = 4;\n    assert(my_solution_2.maximumTotalCost(nums_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {0};\n    long long ans_3 = 0;\n    assert(my_solution_3.maximumTotalCost(nums_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3197": {
        "description": "给你一个二维 二进制 数组 grid。你需要找到 3 个 不重叠、面积 非零 、边在水平方向和竖直方向上的矩形，并且满足 grid 中所有的 1 都在这些矩形的内部。\n返回这些矩形面积之和的 最小 可能值。\n注意，这些矩形可以相接。",
        "difficulty_level": "Hard",
        "note": "1 <= grid.length, grid[i].length <= 30\ngrid[i][j] 是 0 或 1。\n输入保证 grid 中至少有三个 1 。",
        "codes": {
            "python": "class Solution:\n    def minimumSum(self, grid: List[List[int]]) -> int:\n        return min(self.f(grid), self.f(self.rotate(grid)))\n\n    def f(self, a: List[List[int]]) -> int:\n        def minimumArea(a: List[List[int]], l: int, r: int) -> int:\n            left, right = len(a[0]), 0\n            top, bottom = len(a), 0\n            for i, row in enumerate(a):\n                for j, x in enumerate(row[l:r]):\n                    if x == 1:\n                        left = min(left, j)\n                        right = max(right, j)\n                        top = min(top, i)\n                        bottom = i\n            return (right - left + 1) * (bottom - top + 1)\n\n        ans = inf\n        m, n = len(a), len(a[0])\n        if m >= 3:\n            for i in range(1, m):\n                for j in range(i + 1, m):\n                    # 图片上左\n                    area = minimumArea(a[:i], 0, n)\n                    area += minimumArea(a[i:j], 0, n)\n                    area += minimumArea(a[j:], 0, n)\n                    ans = min(ans, area)\n        if m >= 2 and n >= 2:\n            for i in range(1, m):\n                for j in range(1, n):\n                    # 图片上中\n                    area = minimumArea(a[:i], 0, n)\n                    area += minimumArea(a[i:], 0, j)\n                    area += minimumArea(a[i:], j, n)\n                    ans = min(ans, area)\n                    # 图片上右\n                    area = minimumArea(a[:i], 0, j)\n                    area += minimumArea(a[:i], j, n)\n                    area += minimumArea(a[i:], 0, n)\n                    ans = min(ans, area)\n        return ans\n\n    # 顺时针旋转矩阵 90°\n    def rotate(self, a: List[List[int]]) -> List[List[int]]:\n        return list(zip(*reversed(a)))\n",
            "java": "public class Solution {\n    public int minimumSum(int[][] grid) {\n        return Math.min(f(grid), f(rotate(grid)));\n    }\n\n    private int f(int[][] a) {\n        int ans = Integer.MAX_VALUE;\n        int m = a.length;\n        int n = a[0].length;\n        if (m >= 3) {\n            for (int i = 1; i < m; i++) {\n                for (int j = i + 1; j < m; j++) {\n                    // 图片上左\n                    int area = minimumArea(a, 0, i, 0, n);\n                    area += minimumArea(a, i, j, 0, n);\n                    area += minimumArea(a, j, m, 0, n);\n                    ans = Math.min(ans, area);\n                }\n            }\n        }\n        if (m >= 2 && n >= 2) {\n            for (int i = 1; i < m; i++) {\n                for (int j = 1; j < n; j++) {\n                    // 图片上中\n                    int area = minimumArea(a, 0, i, 0, n);\n                    area += minimumArea(a, i, m, 0, j);\n                    area += minimumArea(a, i, m, j, n);\n                    ans = Math.min(ans, area);\n                    // 图片上右\n                    area = minimumArea(a, 0, i, 0, j);\n                    area += minimumArea(a, 0, i, j, n);\n                    area += minimumArea(a, i, m, 0, n);\n                    ans = Math.min(ans, area);\n                }\n            }\n        }\n        return ans;\n    }\n\n    private int minimumArea(int[][] a, int u, int d, int l, int r) {\n        int left = a[0].length;\n        int right = 0;\n        int top = a.length;\n        int bottom = 0;\n        for (int i = u; i < d; i++) {\n            for (int j = l; j < r; j++) {\n                if (a[i][j] == 1) {\n                    left = Math.min(left, j);\n                    right = Math.max(right, j);\n                    top = Math.min(top, i);\n                    bottom = i;\n                }\n            }\n        }\n        return (right - left + 1) * (bottom - top + 1);\n    }\n\n    // 顺时针旋转矩阵 90°\n    private int[][] rotate(int[][] a) {\n        int m = a.length;\n        int n = a[0].length;\n        int[][] b = new int[n][m];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                b[j][m - 1 - i] = a[i][j];\n            }\n        }\n        return b;\n    }\n}\n",
            "cpp": "class Solution {\n    // 顺时针旋转矩阵 90°\n    vector<vector<int>> rotate(vector<vector<int>>& a) {\n        int m = a.size();\n        int n = a[0].size();\n        vector<vector<int>> b(n, vector<int>(m));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                b[j][m - 1 - i] = a[i][j];\n            }\n        }\n        return b;\n    }\n\n    int minimumArea(vector<vector<int>>& a, int u, int d, int l, int r) {\n        int left = a[0].size(), right = 0, top = a.size(), bottom = 0;\n        for (int i = u; i < d; i++) {\n            for (int j = l; j < r; j++) {\n                if (a[i][j] == 1) {\n                    left = min(left, j);\n                    right = max(right, j);\n                    top = min(top, i);\n                    bottom = i;\n                }\n            }\n        }\n        return (right - left + 1) * (bottom - top + 1);\n    }\n\n    int f(vector<vector<int>>& a) {\n        int ans = INT_MAX;\n        int m = a.size();\n        int n = a[0].size();\n        if (m >= 3) {\n            for (int i = 1; i < m; i++) {\n                for (int j = i + 1; j < m; j++) {\n                    // 图片上左\n                    int area = minimumArea(a, 0, i, 0, n);\n                    area += minimumArea(a, i, j, 0, n);\n                    area += minimumArea(a, j, m, 0, n);\n                    ans = min(ans, area);\n                }\n            }\n        }\n        if (m >= 2 && n >= 2) {\n            for (int i = 1; i < m; i++) {\n                for (int j = 1; j < n; j++) {\n                    // 图片上中\n                    int area = minimumArea(a, 0, i, 0, n);\n                    area += minimumArea(a, i, m, 0, j);\n                    area += minimumArea(a, i, m, j, n);\n                    ans = min(ans, area);\n                    // 图片上右\n                    area = minimumArea(a, 0, i, 0, j);\n                    area += minimumArea(a, 0, i, j, n);\n                    area += minimumArea(a, i, m, 0, n);\n                    ans = min(ans, area);\n                }\n            }\n        }\n        return ans;\n    }\n\npublic:\n    int minimumSum(vector<vector<int>>& grid) {\n        auto g = rotate(grid);\n        return min(f(grid), f(g));\n    }\n};\n",
            "go": "func minimumArea(a [][]int, l, r int) int {\nleft, right := len(a[0]), 0\ntop, bottom := len(a), 0\nfor i, row := range a {\nfor j, x := range row[l:r] {\nif x == 1 {\nleft = min(left, j)\nright = max(right, j)\ntop = min(top, i)\nbottom = i\n}\n}\n}\nreturn (right - left + 1) * (bottom - top + 1)\n}\n\nfunc minimumSum(grid [][]int) int {\nans := math.MaxInt\nf := func(a [][]int) {\nm, n := len(a), len(a[0])\nif m >= 3 {\nfor i := 1; i < m; i++ {\nfor j := i + 1; j < m; j++ {\n// 图片上左\narea := minimumArea(a[:i], 0, n)\narea += minimumArea(a[i:j], 0, n)\narea += minimumArea(a[j:], 0, n)\nans = min(ans, area)\n}\n}\n}\nif m >= 2 && n >= 2 {\nfor i := 1; i < m; i++ {\nfor j := 1; j < n; j++ {\n// 图片上中\narea := minimumArea(a[:i], 0, n)\narea += minimumArea(a[i:], 0, j)\narea += minimumArea(a[i:], j, n)\nans = min(ans, area)\n// 图片上右\narea = minimumArea(a[:i], 0, j)\narea += minimumArea(a[:i], j, n)\narea += minimumArea(a[i:], 0, n)\nans = min(ans, area)\n}\n}\n}\n}\nf(grid)\nf(rotate(grid))\nreturn ans\n}\n\n// 顺时针旋转矩阵 90°\nfunc rotate(a [][]int) [][]int {\nm, n := len(a), len(a[0])\nb := make([][]int, n)\nfor i := range b {\nb[i] = make([]int, m)\n}\nfor i, row := range a {\nfor j, x := range row {\nb[j][m-1-i] = x\n}\n}\nreturn b\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[[1,0,1],[1,1,1]]\"]",
                "output": "[\"5\"]"
            },
            {
                "input": "[\"[[1,0,1,0],[0,1,0,1]]\"]",
                "output": "[\"5\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumSum(int[][] grid) {",
            "cpp": "class Solution {\npublic:\n    int minimumSum(vector<vector<int>>& grid) {",
            "go": "func minimumSum(grid [][]int) int {\n\n}",
            "js": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumSum = function(grid) {",
            "python": "class Solution:\n    def minimumSum(self, grid: List[List[int]]) -> int:"
        },
        "time": "20240623",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumSum",
            "java": "minimumSum",
            "cpp": "minimumSum",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumSum([[1,0,1],[1,1,1]]) == 5, \"Test 1 Error!\"\nassert my_solution.minimumSum([[1,0,1,0],[0,1,0,1]]) == 5, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] grid_1 = {{1,0,1},{1,1,1}};\n    int ans_1 = 5;\n    assert solution.minimumSum(grid_1) == ans_1;\n    int[][] grid_2 = {{1,0,1,0},{0,1,0,1}};\n    int ans_2 = 5;\n    assert solution.minimumSum(grid_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> grid_1 = {{1,0,1},{1,1,1}};\n    int ans_1 = 5;\n    assert(my_solution_1.minimumSum(grid_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> grid_2 = {{1,0,1,0},{0,1,0,1}};\n    int ans_2 = 5;\n    assert(my_solution_2.minimumSum(grid_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "grid"
            ],
            "java": [
                "grid"
            ],
            "cpp": [
                "grid"
            ],
            "go": [],
            "js": []
        }
    },
    "3200": {
        "description": "给你两个整数 red 和 blue，分别表示红色球和蓝色球的数量。你需要使用这些球来组成一个三角形，满足第 1 行有 1 个球，第 2 行有 2 个球，第 3 行有 3 个球，依此类推。\n每一行的球必须是 相同 颜色，且相邻行的颜色必须 不同。\n返回可以实现的三角形的 最大 高度。",
        "difficulty_level": "Easy",
        "note": "1 <= red, blue <= 100",
        "codes": {
            "python": "class Solution:\n    def maxHeightOfTriangle(self, red: int, blue: int) -> int:\n        cnt = [0, 0]\n        for i in count(1):\n            cnt[i % 2] += i\n            if (cnt[0] > red or cnt[1] > blue) and (cnt[0] > blue or cnt[1] > red):\n                return i - 1\n",
            "java": "class Solution {\n    public int maxHeightOfTriangle(int red, int blue) {\n        int[] cnt = new int[2];\n        for (int i = 1; ; i++) {\n            cnt[i % 2] += i;\n            if ((cnt[0] > red || cnt[1] > blue) && (cnt[0] > blue || cnt[1] > red)) {\n                return i - 1;\n            }\n        }\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int maxHeightOfTriangle(int red, int blue) {\n        int cnt[2]{};\n        for (int i = 1; ; i++) {\n            cnt[i % 2] += i;\n            if ((cnt[0] > red || cnt[1] > blue) && (cnt[0] > blue || cnt[1] > red)) {\n                return i - 1;\n            }\n        }\n    }\n};\n",
            "go": "func maxHeightOfTriangle(red, blue int) int {\ncnt := [2]int{}\nfor i := 1; ; i++ {\ncnt[i%2] += i\nif (cnt[0] > red || cnt[1] > blue) && (cnt[0] > blue || cnt[1] > red) {\nreturn i - 1\n}\n}\n}\n",
            "js": "var maxHeightOfTriangle = function(red, blue) {\n    return Math.max(getMaxHeight([red, blue]), getMaxHeight([blue, red]));\n};\n\nvar getMaxHeight = function(counts) {\n    let height = 0;\n    let position = 0;\n    while (height + 1 <= counts[position]) {\n        height++;\n        counts[position] -= height;\n        position ^= 1;\n    }\n    return height;\n};\n"
        },
        "cases": [
            {
                "input": "[\"2\",\"4\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"2\",\"1\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"1\",\"1\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"10\",\"1\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maxHeightOfTriangle(int red, int blue) {",
            "cpp": "class Solution {\npublic:\n    int maxHeightOfTriangle(int red, int blue) {",
            "go": "func maxHeightOfTriangle(red int, blue int) int {\n\n}",
            "js": "/**\n * @param {number} red\n * @param {number} blue\n * @return {number}\n */\nvar maxHeightOfTriangle = function(red, blue) {",
            "python": "class Solution:\n    def maxHeightOfTriangle(self, red: int, blue: int) -> int:"
        },
        "time": "20240630",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maxHeightOfTriangle",
            "java": "maxHeightOfTriangle",
            "cpp": "maxHeightOfTriangle",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maxHeightOfTriangle(2, 4) == 3, \"Test 1 Error!\"\nassert my_solution.maxHeightOfTriangle(2, 1) == 2, \"Test 2 Error!\"\nassert my_solution.maxHeightOfTriangle(1, 1) == 1, \"Test 3 Error!\"\nassert my_solution.maxHeightOfTriangle(10, 1) == 2, \"Test 4 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int red_1 = 2;\n    int blue_1 = 4;\n    int ans_1 = 3;\n    assert solution.maxHeightOfTriangle(red_1, blue_1) == ans_1;\n    int red_2 = 2;\n    int blue_2 = 1;\n    int ans_2 = 2;\n    assert solution.maxHeightOfTriangle(red_2, blue_2) == ans_2;\n    int red_3 = 1;\n    int blue_3 = 1;\n    int ans_3 = 1;\n    assert solution.maxHeightOfTriangle(red_3, blue_3) == ans_3;\n    int red_4 = 10;\n    int blue_4 = 1;\n    int ans_4 = 2;\n    assert solution.maxHeightOfTriangle(red_4, blue_4) == ans_4;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int red_1 = 2;\n    int blue_1 = 4;\n    int ans_1 = 3;\n    assert(my_solution_1.maxHeightOfTriangle(red_1, blue_1) == ans_1);\n    Solution my_solution_2;\n    int red_2 = 2;\n    int blue_2 = 1;\n    int ans_2 = 2;\n    assert(my_solution_2.maxHeightOfTriangle(red_2, blue_2) == ans_2);\n    Solution my_solution_3;\n    int red_3 = 1;\n    int blue_3 = 1;\n    int ans_3 = 1;\n    assert(my_solution_3.maxHeightOfTriangle(red_3, blue_3) == ans_3);\n    Solution my_solution_4;\n    int red_4 = 10;\n    int blue_4 = 1;\n    int ans_4 = 2;\n    assert(my_solution_4.maxHeightOfTriangle(red_4, blue_4) == ans_4);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "red",
                "blue"
            ],
            "java": [
                "red",
                "blue"
            ],
            "cpp": [
                "red",
                "blue"
            ],
            "go": [],
            "js": []
        }
    },
    "3201": {
        "description": "给你一个整数数组 nums。nums 的子序列 sub 的长度为 x ，如果其满足以下条件，则称其为 有效子序列：\n(sub[0] + sub[1]) % 2 == (sub[1] + sub[2]) % 2 == ... == (sub[x - 2] + sub[x - 1]) % 2\n返回 nums 的 最长的有效子序列 的长度。\n一个 子序列 指的是从原数组中删除一些元素（也可以不删除任何元素），剩余元素保持原来顺序组成的新数组。",
        "difficulty_level": "Middle",
        "note": "2 <= nums.length <= 2 * 10^5\n1 <= nums[i] <= 10^7",
        "codes": {
            "python": "class Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        k = 2\n        f = [[0] * k for _ in range(k)]\n        for x in nums:\n            x %= k\n            for y, fxy in enumerate(f[x]):\n                f[y][x] = fxy + 1\n        return max(map(max, f))\n",
            "java": "class Solution {\n    public int maximumLength(int[] nums) {\n        int k = 2;\n        int ans = 0;\n        int[][] f = new int[k][k];\n        for (int x : nums) {\n            x %= k;\n            for (int y = 0; y < k; y++) {\n                f[y][x] = f[x][y] + 1;\n                ans = Math.max(ans, f[y][x]);\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int maximumLength(vector<int>& nums) {\n        int k = 2;\n        int ans = 0;\n        vector<vector<int>> f(k, vector<int>(k));\n        for (int x : nums) {\n            x %= k;\n            for (int y = 0; y < k; y++) {\n                f[y][x] = f[x][y] + 1;\n                ans = max(ans, f[y][x]);\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func maximumLength(nums []int) (ans int) {\nk := 2\nf := make([][]int, k)\nfor i := range f {\nf[i] = make([]int, k)\n}\nfor _, x := range nums {\nx %= k\nfor y, fxy := range f[x] {\nf[y][x] = fxy + 1\nans = max(ans, f[y][x])\n}\n}\nreturn\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[1,2,3,4]\"]",
                "output": "[\"4\"]"
            },
            {
                "input": "[\"[1,2,1,1,2,1,2]\"]",
                "output": "[\"6\"]"
            },
            {
                "input": "[\"[1,3]\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maximumLength(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    int maximumLength(vector<int>& nums) {",
            "go": "func maximumLength(nums []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumLength = function(nums) {",
            "python": "class Solution:\n    def maximumLength(self, nums: List[int]) -> int:"
        },
        "time": "20240630",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maximumLength",
            "java": "maximumLength",
            "cpp": "maximumLength",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maximumLength([1,2,3,4]) == 4, \"Test 1 Error!\"\nassert my_solution.maximumLength([1,2,1,1,2,1,2]) == 6, \"Test 2 Error!\"\nassert my_solution.maximumLength([1,3]) == 2, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,3,4};\n    int ans_1 = 4;\n    assert solution.maximumLength(nums_1) == ans_1;\n    int[] nums_2 = {1,2,1,1,2,1,2};\n    int ans_2 = 6;\n    assert solution.maximumLength(nums_2) == ans_2;\n    int[] nums_3 = {1,3};\n    int ans_3 = 2;\n    assert solution.maximumLength(nums_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,3,4};\n    int ans_1 = 4;\n    assert(my_solution_1.maximumLength(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,2,1,1,2,1,2};\n    int ans_2 = 6;\n    assert(my_solution_2.maximumLength(nums_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {1,3};\n    int ans_3 = 2;\n    assert(my_solution_3.maximumLength(nums_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3202": {
        "description": "给你一个整数数组 nums 和一个 正 整数 k 。nums 的一个 子序列 sub 的长度为 x ，如果其满足以下条件，则称其为 有效子序列 ：\n(sub[0] + sub[1]) % k == (sub[1] + sub[2]) % k == ... == (sub[x - 2] + sub[x - 1]) % k\n返回 nums 的 最长有效子序列 的长度。",
        "difficulty_level": "Middle",
        "note": "2 <= nums.length <= 10^3\n1 <= nums[i] <= 10^7\n1 <= k <= 10^3",
        "codes": {
            "python": "class Solution:\n    def maximumLength(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for m in range(k):\n            f = [0] * k\n            for x in nums:\n                x %= k\n                f[x] = f[m - x] + 1\n            ans = max(ans, max(f))\n        return ans\n",
            "java": "public class Solution {\n    public int maximumLength(int[] nums, int k) {\n        int ans = 0;\n        for (int m = 0; m < k; m++) {\n            int[] f = new int[k];\n            for (int x : nums) {\n                x %= k;\n                f[x] = f[(m - x + k) % k] + 1;\n                ans = Math.max(ans, f[x]);\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int maximumLength(vector<int>& nums, int k) {\n        int ans = 0;\n        for (int m = 0; m < k; m++) {\n            vector<int> f(k);\n            for (int x : nums) {\n                x %= k;\n                f[x] = f[(m - x + k) % k] + 1;\n                ans = max(ans, f[x]);\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func maximumLength(nums []int, k int) (ans int) {\nf := make([]int, k)\nfor m := 0; m < k; m++ {\nclear(f)\nfor _, x := range nums {\nx %= k\nf[x] = f[(m-x+k)%k] + 1\nans = max(ans, f[x])\n}\n}\nreturn\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[1,2,3,4,5]\",\"2\"]",
                "output": "[\"5\"]"
            },
            {
                "input": "[\"[1,4,2,3,1,4]\",\"3\"]",
                "output": "[\"4\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maximumLength(int[] nums, int k) {",
            "cpp": "class Solution {\npublic:\n    int maximumLength(vector<int>& nums, int k) {",
            "go": "func maximumLength(nums []int, k int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumLength = function(nums, k) {",
            "python": "class Solution:\n    def maximumLength(self, nums: List[int], k: int) -> int:"
        },
        "time": "20240630",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maximumLength",
            "java": "maximumLength",
            "cpp": "maximumLength",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maximumLength([1,2,3,4,5], 2) == 5, \"Test 1 Error!\"\nassert my_solution.maximumLength([1,4,2,3,1,4], 3) == 4, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,3,4,5};\n    int k_1 = 2;\n    int ans_1 = 5;\n    assert solution.maximumLength(nums_1, k_1) == ans_1;\n    int[] nums_2 = {1,4,2,3,1,4};\n    int k_2 = 3;\n    int ans_2 = 4;\n    assert solution.maximumLength(nums_2, k_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,3,4,5};\n    int k_1 = 2;\n    int ans_1 = 5;\n    assert(my_solution_1.maximumLength(nums_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,4,2,3,1,4};\n    int k_2 = 3;\n    int ans_2 = 4;\n    assert(my_solution_2.maximumLength(nums_2, k_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "k"
            ],
            "java": [
                "nums",
                "k"
            ],
            "cpp": [
                "nums",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3203": {
        "description": "给你两棵 无向 树，分别有 n 和 m 个节点，节点编号分别为 0 到 n - 1 和 0 到 m - 1 。给你两个二维整数数组 edges1 和 edges2 ，长度分别为 n - 1 和 m - 1 ，其中 edges1[i] = [a_i, b_i] 表示在第一棵树中节点 a_i 和 b_i 之间有一条边，edges2[i] = [u_i, v_i] 表示在第二棵树中节点 u_i 和 v_i 之间有一条边。\n你必须在第一棵树和第二棵树中分别选一个节点，并用一条边连接它们。\n请你返回添加边后得到的树中，最小直径 为多少。\n一棵树的 直径 指的是树中任意两个节点之间的最长路径长度。",
        "difficulty_level": "Hard",
        "note": "1 <= n, m <= 10^5\nedges1.length == n - 1\nedges2.length == m - 1\nedges1[i].length == edges2[i].length == 2\nedges1[i] = [a_i, b_i]\n0 <= a_i, b_i < n\nedges2[i] = [u_i, v_i]\n0 <= u_i, v_i < m\n输入保证 edges1 和 edges2 分别表示一棵合法的树。",
        "codes": {
            "python": "class Solution:\n    def diameter(self, edges: List[List[int]], ) -> int:\n        g = [[] for _ in range(len(edges) + 1)]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        res = 0\n        def dfs(x: int, fa: int) -> int:\n            nonlocal res\n            max_len = 0\n            for y in g[x]:\n                if y != fa:\n                    sub_len = dfs(y, x) + 1\n                    res = max(res, max_len + sub_len)\n                    max_len = max(max_len, sub_len)\n            return max_len\n        dfs(0, -1)\n        return res\n\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        d1 = self.diameter(edges1)\n        d2 = self.diameter(edges2)\n        return max(d1, d2, (d1 + 1) // 2 + (d2 + 1) // 2 + 1)\n",
            "java": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int d1 = diameter(edges1);\n        int d2 = diameter(edges2);\n        return Math.max(Math.max(d1, d2), (d1 + 1) / 2 + (d2 + 1) / 2 + 1);\n    }\n\n    private int res;\n\n    private int diameter(int[][] edges) {\n        List<Integer>[] g = new ArrayList[edges.length + 1];\n        Arrays.setAll(g, i -> new ArrayList<>());\n        for (int[] e : edges) {\n            int x = e[0];\n            int y = e[1];\n            g[x].add(y);\n            g[y].add(x);\n        }\n\n        res = 0;\n        dfs(0, -1, g);\n        return res;\n    }\n\n    private int dfs(int x, int fa, List<Integer>[] g) {\n        int maxLen = 0;\n        for (int y : g[x]) {\n            if (y != fa) {\n                int subLen = dfs(y, x, g) + 1;\n                res = Math.max(res, maxLen + subLen);\n                maxLen = Math.max(maxLen, subLen);\n            }\n        }\n        return maxLen;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int diameter(vector<vector<int>>& edges) {\n        vector<vector<int>> g(edges.size() + 1);\n        for (auto& e : edges) {\n            int x = e[0], y = e[1];\n            g[x].push_back(y);\n            g[y].push_back(x);\n        }\n\n        int res = 0;\n        auto dfs = [&](auto&& dfs, int x, int fa) -> int {\n            int max_len = 0;\n            for (auto y : g[x]) {\n                if (y != fa) {\n                    int sub_len = dfs(dfs, y, x) + 1;\n                    res = max(res, max_len + sub_len);\n                    max_len = max(max_len, sub_len);\n                }\n            }\n            return max_len;\n        };\n        dfs(dfs, 0, -1);\n        return res;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        int d1 = diameter(edges1);\n        int d2 = diameter(edges2);\n        return max({d1, d2, (d1 + 1) / 2 + (d2 + 1) / 2 + 1});\n    }\n};\n",
            "go": "func diameter(edges [][]int) (res int) {\ng := make([][]int, len(edges)+1)\nfor _, e := range edges {\nx, y := e[0], e[1]\ng[x] = append(g[x], y)\ng[y] = append(g[y], x)\n}\nvar dfs func(int, int) int\ndfs = func(x, fa int) (maxLen int) {\nfor _, y := range g[x] {\nif y != fa {\nsubLen := dfs(y, x) + 1\nres = max(res, maxLen+subLen)\nmaxLen = max(maxLen, subLen)\n}\n}\nreturn\n}\ndfs(0, -1)\nreturn\n}\n\nfunc minimumDiameterAfterMerge(edges1, edges2 [][]int) int {\nd1 := diameter(edges1)\nd2 := diameter(edges2)\nreturn max(d1, d2, (d1+1)/2+(d2+1)/2+1)\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[[0,1],[0,2],[0,3]]\",\"[[0,1]]\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]\",\"[[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]\"]",
                "output": "[\"5\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {",
            "cpp": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {",
            "go": "func minimumDiameterAfterMerge(edges1 [][]int, edges2 [][]int) int {\n\n}",
            "js": "/**\n * @param {number[][]} edges1\n * @param {number[][]} edges2\n * @return {number}\n */\nvar minimumDiameterAfterMerge = function(edges1, edges2) {",
            "python": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:"
        },
        "time": "20240630",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumDiameterAfterMerge",
            "java": "minimumDiameterAfterMerge",
            "cpp": "minimumDiameterAfterMerge",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumDiameterAfterMerge([[0,1],[0,2],[0,3]], [[0,1]]) == 3, \"Test 1 Error!\"\nassert my_solution.minimumDiameterAfterMerge([[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]) == 5, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] edges1_1 = {{0,1},{0,2},{0,3}};\n    int[][] edges2_1 = {{0,1}};\n    int ans_1 = 3;\n    assert solution.minimumDiameterAfterMerge(edges1_1, edges2_1) == ans_1;\n    int[][] edges1_2 = {{0,1},{0,2},{0,3},{2,4},{2,5},{3,6},{2,7}};\n    int[][] edges2_2 = {{0,1},{0,2},{0,3},{2,4},{2,5},{3,6},{2,7}};\n    int ans_2 = 5;\n    assert solution.minimumDiameterAfterMerge(edges1_2, edges2_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> edges1_1 = {{0,1},{0,2},{0,3}};\n    vector<vector<int>> edges2_1 = {{0,1}};\n    int ans_1 = 3;\n    assert(my_solution_1.minimumDiameterAfterMerge(edges1_1, edges2_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> edges1_2 = {{0,1},{0,2},{0,3},{2,4},{2,5},{3,6},{2,7}};\n    vector<vector<int>> edges2_2 = {{0,1},{0,2},{0,3},{2,4},{2,5},{3,6},{2,7}};\n    int ans_2 = 5;\n    assert(my_solution_2.minimumDiameterAfterMerge(edges1_2, edges2_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "edges1",
                "edges2"
            ],
            "java": [
                "edges1",
                "edges2"
            ],
            "cpp": [
                "edges1",
                "edges2"
            ],
            "go": [],
            "js": []
        }
    },
    "3210": {
        "description": "给你一个字符串 s 和一个整数 k。请你使用以下算法加密字符串：\n对于字符串 s 中的每个字符 c，用字符串中 c 后面的第 k 个字符替换 c（以循环方式）。\n返回加密后的字符串。",
        "difficulty_level": "Easy",
        "note": "1 <= s.length <= 100\n1 <= k <= 10^4\ns 仅由小写英文字母组成。",
        "codes": {
            "python": "class Solution:\n    def getEncryptedString(self, s: str, k: int) -> str:\n        k %= len(s)\n        return s[k:] + s[:k]\n",
            "java": "class Solution {\n    public String getEncryptedString(String s, int k) {\n        k %= s.length();\n        return s.substring(k) + s.substring(0, k);\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    string getEncryptedString(string s, int k) {\n        k %= s.length();\n        return s.substr(k) + s.substr(0, k);\n    }\n};\n",
            "go": "func getEncryptedString(s string, k int) string {\nk %= len(s)\nreturn s[k:] + s[:k]\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"\\\"dart\\\"\",\"3\"]",
                "output": "[\"\\\"tdar\\\"\"]"
            },
            {
                "input": "[\"\\\"aaa\\\"\",\"1\"]",
                "output": "[\"\\\"aaa\\\"\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public String getEncryptedString(String s, int k) {",
            "cpp": "class Solution {\npublic:\n    string getEncryptedString(string s, int k) {",
            "go": "func getEncryptedString(s string, k int) string {\n\n}",
            "js": "/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nvar getEncryptedString = function(s, k) {",
            "python": "class Solution:\n    def getEncryptedString(self, s: str, k: int) -> str:"
        },
        "time": "20240707",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "getEncryptedString",
            "java": "getEncryptedString",
            "cpp": "getEncryptedString",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.getEncryptedString(\"dart\", 3) == \"tdar\", \"Test 1 Error!\"\nassert my_solution.getEncryptedString(\"aaa\", 1) == \"aaa\", \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String s_1 = \"dart\";\n    int k_1 = 3;\n    String ans_1 = \"tdar\";\n    assert solution.getEncryptedString(s_1, k_1).equals(ans_1);\n    String s_2 = \"aaa\";\n    int k_2 = 1;\n    String ans_2 = \"aaa\";\n    assert solution.getEncryptedString(s_2, k_2).equals(ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string s_1 = \"dart\";\n    int k_1 = 3;\n    string ans_1 = \"tdar\";\n    assert(my_solution_1.getEncryptedString(s_1, k_1) == ans_1);\n    Solution my_solution_2;\n    string s_2 = \"aaa\";\n    int k_2 = 1;\n    string ans_2 = \"aaa\";\n    assert(my_solution_2.getEncryptedString(s_2, k_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "s",
                "k"
            ],
            "java": [
                "s",
                "k"
            ],
            "cpp": [
                "s",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3211": {
        "description": "给你一个正整数 n。如果一个二进制字符串 x 的所有长度为 2 的子字符串中包含 至少 一个 \\\"1\\\"，则称 x 是一个 有效 字符串。\n返回所有长度为 n 的 有效 字符串，可以以任意顺序排列。",
        "difficulty_level": "Middle",
        "note": "1 <= n <= 18",
        "codes": {
            "python": "class Solution:\n    def validStrings(self, n: int) -> List[str]:\n        ans = []\n        mask = (1 << n) - 1\n        for i in range(1 << n):\n            x = mask ^ i\n            if (x >> 1) & x == 0:\n                ans.append(f\"{i:0{n}b}\")\n        return ans\n",
            "java": "class Solution {\n    public List<String> validStrings(int n) {\n        List<String> ans = new ArrayList<>();\n        int mask = (1 << n) - 1;\n        for (int i = 0; i < (1 << n); i++) {\n            int x = mask ^ i;\n            if (((x >> 1) & x) == 0) {\n                ans.add(Integer.toBinaryString((1 << n) | i).substring(1));\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    vector<string> validStrings(int n) {\n        vector<string> ans;\n        int mask = (1 << n) - 1;\n        for (int i = 0; i < (1 << n); i++) {\n            int x = mask ^ i;\n            if (((x >> 1) & x) == 0) {\n                ans.push_back(bitset<18>(i).to_string().substr(18 - n));\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func validStrings(n int) (ans []string) {\nfor i := 0; i < 1<<n; i++ {\nx := 1<<n - 1 ^ i\nif x>>1&x == 0 {\nans = append(ans, fmt.Sprintf(\"%0*b\", n, i))\n}\n}\nreturn\n}\n",
            "js": "/**\n * @param {number} n\n * @return {string[]}\n */\nvar validStrings = function(n) {\n    let ans = []\n    var backTracking = (index,s)=>{\n        // 1.满足回溯结束条件，结束回溯\n        if(index == n){\n            ans.push(s)\n            return\n        }\n        // 2.遍历选择\n        for(let i = 0;i <= 1;i++){\n            // 剪枝\n            if(s[s.length - 1] === '0' && i == 0){\n                continue\n            }\n            // 做出选择\n            s += i + ''\n            // 基于选择时做出的下一步\n            backTracking(index + 1,s)\n            // 撤销选择\n            s = s.slice(0,-1)\n        }\n    }\n    backTracking(0,'')\n    return ans\n};\n"
        },
        "cases": [
            {
                "input": "[\"3\"]",
                "output": "[\"[\\\"010\\\",\\\"011\\\",\\\"101\\\",\\\"110\\\",\\\"111\\\"]\"]"
            },
            {
                "input": "[\"1\"]",
                "output": "[\"[\\\"0\\\",\\\"1\\\"]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public List<String> validStrings(int n) {",
            "cpp": "class Solution {\npublic:\n    vector<string> validStrings(int n) {",
            "go": "func validStrings(n int) []string {\n\n}",
            "js": "/**\n * @param {number} n\n * @return {string[]}\n */\nvar validStrings = function(n) {",
            "python": "class Solution:\n    def validStrings(self, n: int) -> List[str]:"
        },
        "time": "20240707",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "validStrings",
            "java": "validStrings",
            "cpp": "validStrings",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.validStrings(3) == [\"010\",\"011\",\"101\",\"110\",\"111\"], \"Test 1 Error!\"\nassert my_solution.validStrings(1) == [\"0\",\"1\"], \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int n_1 = 3;\n    List<String> ans_1 = [\"010\",\"011\",\"101\",\"110\",\"111\"];\n    assert solution.validStrings(n_1).equals(ans_1);\n    int n_2 = 1;\n    List<String> ans_2 = [\"0\",\"1\"];\n    assert solution.validStrings(n_2).equals(ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int n_1 = 3;\n    vector<string> ans_1 = {\"010\",\"011\",\"101\",\"110\",\"111\"};\n    assert(my_solution_1.validStrings(n_1) == ans_1);\n    Solution my_solution_2;\n    int n_2 = 1;\n    vector<string> ans_2 = {\"0\",\"1\"};\n    assert(my_solution_2.validStrings(n_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "n"
            ],
            "java": [
                "n"
            ],
            "cpp": [
                "n"
            ],
            "go": [],
            "js": []
        }
    },
    "3212": {
        "description": "给你一个二维字符矩阵 grid，其中 grid[i][j] 可能是 'X'、'Y' 或 '.'，返回满足以下条件的\n子矩阵\n数量：\n包含 grid[0][0]\n'X' 和 'Y' 的频数相等。\n至少包含一个 'X'。",
        "difficulty_level": "Middle",
        "note": "1 <= grid.length, grid[i].length <= 1000\ngrid[i][j] 可能是 'X'、'Y' 或 '.'.",
        "codes": {
            "python": "class Solution:\n    def numberOfSubmatrices(self, grid: List[List[str]]) -> int:\n        ans = 0\n        m, n = len(grid), len(grid[0])\n        s = [[[0, 0] for _ in range(n + 1)] for _ in range(m + 1)]\n        for i, row in enumerate(grid):\n            for j, c in enumerate(row):\n                s[i + 1][j + 1][0] = s[i + 1][j][0] + s[i][j + 1][0] - s[i][j][0]\n                s[i + 1][j + 1][1] = s[i + 1][j][1] + s[i][j + 1][1] - s[i][j][1]\n                if c != '.':\n                    s[i + 1][j + 1][ord(c) & 1] += 1\n                if s[i + 1][j + 1][0] and s[i + 1][j + 1][0] == s[i + 1][j + 1][1]:\n                    ans += 1\n        return ans\n",
            "java": "class Solution {\n    public int numberOfSubmatrices(char[][] grid) {\n        int ans = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][][] sum = new int[m + 1][n + 1][2];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1][0] = sum[i + 1][j][0] + sum[i][j + 1][0] - sum[i][j][0];\n                sum[i + 1][j + 1][1] = sum[i + 1][j][1] + sum[i][j + 1][1] - sum[i][j][1];\n                if (grid[i][j] != '.') {\n                    sum[i + 1][j + 1][grid[i][j] & 1]++;\n                }\n                if (sum[i + 1][j + 1][0] > 0 && sum[i + 1][j + 1][0] == sum[i + 1][j + 1][1]) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int numberOfSubmatrices(vector<vector<char>>& grid) {\n        int ans = 0, m = grid.size(), n = grid[0].size();\n        vector<vector<array<int, 2>>> sum(m + 1, vector<array<int, 2>>(n + 1));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1][0] = sum[i + 1][j][0] + sum[i][j + 1][0] - sum[i][j][0];\n                sum[i + 1][j + 1][1] = sum[i + 1][j][1] + sum[i][j + 1][1] - sum[i][j][1];\n                if (grid[i][j] != '.') {\n                    sum[i + 1][j + 1][grid[i][j] & 1]++;\n                }\n                if (sum[i + 1][j + 1][0] && sum[i + 1][j + 1][0] == sum[i + 1][j + 1][1]) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func numberOfSubmatrices(grid [][]byte) (ans int) {\nm, n := len(grid), len(grid[0])\nsum := make([][][2]int, m+1)\nfor i := range sum {\nsum[i] = make([][2]int, n+1)\n}\nfor i, row := range grid {\nfor j, c := range row {\nsum[i+1][j+1][0] = sum[i+1][j][0] + sum[i][j+1][0] - sum[i][j][0]\nsum[i+1][j+1][1] = sum[i+1][j][1] + sum[i][j+1][1] - sum[i][j][1]\nif c != '.' {\nsum[i+1][j+1][c&1]++\n}\nif sum[i+1][j+1][0] > 0 && sum[i+1][j+1][0] == sum[i+1][j+1][1] {\nans++\n}\n}\n}\nreturn\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[[\\\"X\\\",\\\"Y\\\",\\\".\\\"],[\\\"Y\\\",\\\".\\\",\\\".\\\"]]\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[[\\\"X\\\",\\\"X\\\"],[\\\"X\\\",\\\"Y\\\"]]\"]",
                "output": "[\"0\"]"
            },
            {
                "input": "[\"[[\\\".\\\",\\\".\\\"],[\\\".\\\",\\\".\\\"]]\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int numberOfSubmatrices(char[][] grid) {",
            "cpp": "class Solution {\npublic:\n    int numberOfSubmatrices(vector<vector<char>>& grid) {",
            "go": "func numberOfSubmatrices(grid [][]byte) int {\n\n}",
            "js": "/**\n * @param {character[][]} grid\n * @return {number}\n */\nvar numberOfSubmatrices = function(grid) {",
            "python": "class Solution:\n    def numberOfSubmatrices(self, grid: List[List[str]]) -> int:"
        },
        "time": "20240707",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "numberOfSubmatrices",
            "java": "numberOfSubmatrices",
            "cpp": "numberOfSubmatrices",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.numberOfSubmatrices([[\"X\",\"Y\",\".\"],[\"Y\",\".\",\".\"]]) == 3, \"Test 1 Error!\"\nassert my_solution.numberOfSubmatrices([[\"X\",\"X\"],[\"X\",\"Y\"]]) == 0, \"Test 2 Error!\"\nassert my_solution.numberOfSubmatrices([[\".\",\".\"],[\".\",\".\"]]) == 0, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    char[][] grid_1 = {{'X','Y','.'},{'Y','.','.'}};\n    int ans_1 = 3;\n    assert solution.numberOfSubmatrices(grid_1) == ans_1;\n    char[][] grid_2 = {{'X','X'},{'X','Y'}};\n    int ans_2 = 0;\n    assert solution.numberOfSubmatrices(grid_2) == ans_2;\n    char[][] grid_3 = {{'.','.'},{'.','.'}};\n    int ans_3 = 0;\n    assert solution.numberOfSubmatrices(grid_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<char>> grid_1 = {{'X','Y','.'},{'Y','.','.'}};\n    int ans_1 = 3;\n    assert(my_solution_1.numberOfSubmatrices(grid_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<char>> grid_2 = {{'X','X'},{'X','Y'}};\n    int ans_2 = 0;\n    assert(my_solution_2.numberOfSubmatrices(grid_2) == ans_2);\n    Solution my_solution_3;\n    vector<vector<char>> grid_3 = {{'.','.'},{'.','.'}};\n    int ans_3 = 0;\n    assert(my_solution_3.numberOfSubmatrices(grid_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "grid"
            ],
            "java": [
                "grid"
            ],
            "cpp": [
                "grid"
            ],
            "go": [],
            "js": []
        }
    },
    "3213": {
        "description": "给你一个字符串 target、一个字符串数组 words 以及一个整数数组 costs，这两个数组长度相同。设想一个空字符串 s。你可以执行以下操作任意次数（包括零次）：\n选择一个在范围  [0, words.length - 1] 的索引 i。\n将 words[i] 追加到 s。\n该操作的成本是 costs[i]。\n返回使 s 等于 target 的 最小 成本。如果不可能，返回 -1。",
        "difficulty_level": "Hard",
        "note": "1 <= target.length <= 5 * 10^4\n1 <= words.length == costs.length <= 5 * 10^4\n1 <= words[i].length <= target.length\n所有 words[i].length 的总和小于或等于 5 * 10^4\ntarget 和 words[i] 仅由小写英文字母组成。\n1 <= costs[i] <= 10^4",
        "codes": {
            "python": "from collections import defaultdict\nclass Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        wordcost = {}\n        \n        for i in range(len(words)):\n            if words[i] not in wordcost:\n                wordcost[words[i]] = costs[i]\n            else:\n                wordcost[words[i]] = min(wordcost[words[i]], costs[i])\n        \n        n = len(target)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0 \n        \n        for i in range(n):\n            if dp[i] == float('inf'):\n                continue\n            \n            for word in wordcost:\n                if i + len(word) <= n and target[i:i+len(word)] == word:\n                    dp[i + len(word)] = min(dp[i + len(word)], dp[i] + wordcost[word])\n        \n        if target in wordcost:\n            return min(wordcost[target], dp[n])\n        return dp[n] if dp[n] != float('inf') else -1\n",
            "java": "class Solution {\n    private static final int INF = (int) 1e9;\n\n    public int minimumCost(String target, String[] words, int[] costs) {\n        int n = target.length();\n        int m = words.length;\n\n        Node root = new Node(0);\n        for (int i = 0; i < m; i++) {\n            Node cur = root;\n            for (char c : words[i].toCharArray()) {\n                if (cur.next[c - 'a'] == null) {\n                    cur.next[c - 'a'] = new Node(cur.len + 1);\n                }\n                cur = cur.next[c - 'a'];\n            }\n            cur.len = words[i].length();\n            cur.cost = Math.min(cur.cost, costs[i]);\n        }\n        Queue<Node> q = new ArrayDeque<>();\n        for (int i = 0; i < 26; i++) {\n            if (root.next[i] == null) {\n                root.next[i] = root;\n            } else {\n                root.next[i].fail = root;\n                root.next[i].sup_fail = root;\n                q.add(root.next[i]);\n            }\n        }\n        for (; !q.isEmpty(); q.remove()) {\n            Node u = q.peek();\n            for (int i = 0; i < 26; i++) {\n                if (u.next[i] == null) {\n                    u.next[i] = u.fail.next[i];\n                } else {\n                    u.next[i].fail = u.fail.next[i];\n                    if (u.next[i].fail.cost == INF) {\n                        u.next[i].sup_fail = u.next[i].fail.sup_fail;\n                    } else {\n                        u.next[i].sup_fail = u.next[i].fail;\n                    }\n                    q.add(u.next[i]);\n                }\n            }\n        }\n\n        int[] dp = new int[n + 1];\n        Node cur = root;\n        for (int i = 0; i < n; i++) {\n            cur = cur.next[target.charAt(i) - 'a'];\n            int min_cost = INF;\n            for (Node j = cur; j != null; j = j.sup_fail) {\n                min_cost = Math.min(min_cost, dp[i + 1 - j.len] + j.cost);\n            }\n            dp[i + 1] = min_cost;\n        }\n        return dp[n] < INF ? dp[n] : -1;\n    }\n\n    static class Node {\n        int len, cost;\n        Node fail, sup_fail;\n        Node[] next;\n\n        public Node(int len) {\n            this.len = len;\n            cost = INF;\n            next = new Node[26];\n        }\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    static constexpr unsigned INF = UINT_MAX / 2, NIL = UINT_MAX;\n\n    int minimumCost(string target, const vector<string>& words, const vector<int>& costs) {\n        struct Node {\n            unsigned len;\n            unsigned cost;\n            unsigned fail;\n            unsigned sup_fail;\n            unsigned next[26];\n            Node(unsigned len, unsigned cost = INF) : len(len), cost(cost), fail(NIL), sup_fail(NIL) {\n                fill_n(next, 26, NIL);\n            }\n        };\n        vector<Node> pool;\n        const auto newnode = [&] (auto... args) {\n            const unsigned ans = pool.size();\n            pool.emplace_back(args...);\n            return ans;\n        };\n        const unsigned n = target.size(), m = words.size();\n        pool.reserve(max(n, 2 * m) + 1);\n        const unsigned root = newnode(0);\n        for (unsigned i = 0;i < m;++i) {\n            unsigned cur = root;\n            for (char c : words[i]) {\n                if (pool[cur].next[c - 'a'] == NIL)\n                    pool[cur].next[c - 'a'] = newnode(pool[cur].len + 1);\n                cur = pool[cur].next[c - 'a'];\n            }\n            pool[cur].len = words[i].size();\n            pool[cur].cost = min<unsigned>(pool[cur].cost, costs[i]);\n        }\n        queue<unsigned> q;\n        for (unsigned i = 0;i < 26;++i) {\n            if (pool[root].next[i] == NIL)\n                pool[root].next[i] = root;\n            else {\n                pool[pool[root].next[i]].fail = root;\n                pool[pool[root].next[i]].sup_fail = root;\n                q.push(pool[root].next[i]);\n            }\n        }\n        for (;!q.empty();q.pop()) {\n            const auto u = q.front();\n            for (unsigned i = 0;i < 26;++i) {\n                if (pool[u].next[i] == NIL)\n                    pool[u].next[i] = pool[pool[u].fail].next[i];\n                else {\n                    pool[pool[u].next[i]].fail = pool[pool[u].fail].next[i];\n                    pool[pool[u].next[i]].sup_fail = pool[pool[pool[u].next[i]].fail].cost == INF ? pool[pool[pool[u].next[i]].fail].sup_fail :pool[pool[u].next[i]].fail;\n                    q.push(pool[u].next[i]);\n                }\n            }\n        }\n        vector<unsigned> dp(n + 1, 0);\n        for (unsigned cur = root, i = 0;i < n;++i) {\n            cur = pool[cur].next[target[i] - 'a'];\n            unsigned min_cost = INF;\n            for (unsigned j = cur;j != NIL;j = pool[j].sup_fail)\n                min_cost = min(min_cost, dp[i + 1 - pool[j].len] + pool[j].cost);\n            dp[i + 1] = min_cost;\n        }\n        return dp[n] < INF ? dp[n] : -1;\n    }\n};\n",
            "go": "func minimumCost(target string, words []string, costs []int) int {\nminCost := map[string]uint16{}\nfor i, w := range words {\nc := uint16(costs[i])\nif minCost[w] == 0 {\nminCost[w] = c\n} else {\nminCost[w] = min(minCost[w], c)\n}\n}\n\nn := len(target)\ntype pair struct{ l, cost uint16 }\nfrom := make([][]pair, n+1)\nsa := suffixarray.New([]byte(target))\nfor w, c := range minCost {\nfor _, l := range sa.Lookup([]byte(w), -1) {\nr := l + len(w)\nfrom[r] = append(from[r], pair{uint16(l), c})\n}\n}\n\nf := make([]int, n+1)\nfor i := 1; i <= n; i++ {\nf[i] = math.MaxInt / 2\nfor _, p := range from[i] {\nf[i] = min(f[i], f[p.l]+int(p.cost))\n}\n}\nif f[n] == math.MaxInt/2 {\nreturn -1\n}\nreturn f[n]\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"\\\"abcdef\\\"\",\"[\\\"abdef\\\",\\\"abc\\\",\\\"d\\\",\\\"def\\\",\\\"ef\\\"]\",\"[100,1,1,10,5]\"]",
                "output": "[\"7\"]"
            },
            {
                "input": "[\"\\\"aaaa\\\"\",\"[\\\"z\\\",\\\"zz\\\",\\\"zzz\\\"]\",\"[1,10,100]\"]",
                "output": "[\"-1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumCost(String target, String[] words, int[] costs) {",
            "cpp": "class Solution {\npublic:\n    int minimumCost(string target, vector<string>& words, vector<int>& costs) {",
            "go": "func minimumCost(target string, words []string, costs []int) int {\n\n}",
            "js": "/**\n * @param {string} target\n * @param {string[]} words\n * @param {number[]} costs\n * @return {number}\n */\nvar minimumCost = function(target, words, costs) {",
            "python": "class Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:"
        },
        "time": "20240707",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumCost",
            "java": "minimumCost",
            "cpp": "minimumCost",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumCost(\"abcdef\", [\"abdef\",\"abc\",\"d\",\"def\",\"ef\"], [100,1,1,10,5]) == 7, \"Test 1 Error!\"\nassert my_solution.minimumCost(\"aaaa\", [\"z\",\"zz\",\"zzz\"], [1,10,100]) == -1, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String target_1 = \"abcdef\";\n    String[] words_1 = {\"abdef\",\"abc\",\"d\",\"def\",\"ef\"};\n    int[] costs_1 = {100,1,1,10,5};\n    int ans_1 = 7;\n    assert solution.minimumCost(target_1, words_1, costs_1) == ans_1;\n    String target_2 = \"aaaa\";\n    String[] words_2 = {\"z\",\"zz\",\"zzz\"};\n    int[] costs_2 = {1,10,100};\n    int ans_2 = -1;\n    assert solution.minimumCost(target_2, words_2, costs_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string target_1 = \"abcdef\";\n    vector<string> words_1 = {\"abdef\",\"abc\",\"d\",\"def\",\"ef\"};\n    vector<int> costs_1 = {100,1,1,10,5};\n    int ans_1 = 7;\n    assert(my_solution_1.minimumCost(target_1, words_1, costs_1) == ans_1);\n    Solution my_solution_2;\n    string target_2 = \"aaaa\";\n    vector<string> words_2 = {\"z\",\"zz\",\"zzz\"};\n    vector<int> costs_2 = {1,10,100};\n    int ans_2 = -1;\n    assert(my_solution_2.minimumCost(target_2, words_2, costs_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "target",
                "words",
                "costs"
            ],
            "java": [
                "target",
                "words",
                "costs"
            ],
            "cpp": [
                "target",
                "words",
                "costs"
            ],
            "go": [],
            "js": []
        }
    },
    "3216": {
        "description": "给你一个仅由数字组成的字符串 s，在最多交换一次 相邻 且具有相同 奇偶性 的数字后，返回可以得到的字典序最小的字符串。\n如果两个数字都是奇数或都是偶数，则它们具有相同的奇偶性。例如，5 和 9、2 和 4 奇偶性相同，而 6 和 9 奇偶性不同。",
        "difficulty_level": "Easy",
        "note": "2 <= s.length <= 100\ns 仅由数字组成。",
        "codes": {
            "python": "class Solution:\n    def getSmallestString(self, s: str) -> str:\n        t = list(s)\n        for i in range(1, len(t)):\n            x, y = t[i - 1], t[i]\n            if x > y and ord(x) % 2 == ord(y) % 2:\n                t[i - 1], t[i] = y, x\n                break\n        return ''.join(t)\n",
            "java": "class Solution {\n    public String getSmallestString(String s) {\n        char[] t = s.toCharArray();\n        for (int i = 1; i < t.length; i++) {\n            char x = t[i - 1];\n            char y = t[i];\n            if (x > y && x % 2 == y % 2) {\n                t[i - 1] = y;\n                t[i] = x;\n                break;\n            }\n        }\n        return new String(t);\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    string getSmallestString(string s) {\n        for (int i = 1; i < s.length(); i++) {\n            char x = s[i - 1], y = s[i];\n            if (x > y && x % 2 == y % 2) {\n                swap(s[i - 1], s[i]);\n                break;\n            }\n        }\n        return s;\n    }\n};\n",
            "go": "func getSmallestString(s string) string {\nt := []byte(s)\nfor i := 1; i < len(t); i++ {\nx, y := t[i-1], t[i]\nif x > y && x%2 == y%2 {\nt[i-1], t[i] = y, x\nbreak\n}\n}\nreturn string(t)\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"\\\"45320\\\"\"]",
                "output": "[\"\\\"43520\\\"\"]"
            },
            {
                "input": "[\"\\\"001\\\"\"]",
                "output": "[\"\\\"001\\\"\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public String getSmallestString(String s) {",
            "cpp": "class Solution {\npublic:\n    string getSmallestString(string s) {",
            "go": "func getSmallestString(s string) string {\n\n}",
            "js": "/**\n * @param {string} s\n * @return {string}\n */\nvar getSmallestString = function(s) {",
            "python": "class Solution:\n    def getSmallestString(self, s: str) -> str:"
        },
        "time": "20240714",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "getSmallestString",
            "java": "getSmallestString",
            "cpp": "getSmallestString",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.getSmallestString(\"45320\") == \"43520\", \"Test 1 Error!\"\nassert my_solution.getSmallestString(\"001\") == \"001\", \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String s_1 = \"45320\";\n    String ans_1 = \"43520\";\n    assert solution.getSmallestString(s_1).equals(ans_1);\n    String s_2 = \"001\";\n    String ans_2 = \"001\";\n    assert solution.getSmallestString(s_2).equals(ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string s_1 = \"45320\";\n    string ans_1 = \"43520\";\n    assert(my_solution_1.getSmallestString(s_1) == ans_1);\n    Solution my_solution_2;\n    string s_2 = \"001\";\n    string ans_2 = \"001\";\n    assert(my_solution_2.getSmallestString(s_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "s"
            ],
            "java": [
                "s"
            ],
            "cpp": [
                "s"
            ],
            "go": [],
            "js": []
        }
    },
    "3217": {
        "description": "给你一个整数数组 nums 和一个链表的头节点 head。从链表中移除所有存在于 nums 中的节点后，返回修改后的链表的头节点。",
        "difficulty_level": "Middle",
        "note": "1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\nnums 中的所有元素都是唯一的。\n链表中的节点数在 [1, 10^5] 的范围内。\n1 <= Node.val <= 10^5\n输入保证链表中至少有一个值没有在 nums 中出现过。",
        "codes": {
            "python": "class Solution:\n    def modifiedList(self, nums: List[int], head: Optional[ListNode]) -> Optional[ListNode]:\n        st = set(nums)\n        cur = dummy = ListNode(next=head)\n        while cur.next:\n            if cur.next.val in st:\n                cur.next = cur.next.next  # 删除\n            else:\n                cur = cur.next  # 向后移动\n        return dummy.next\n",
            "java": "class Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n        Set<Integer> set = new HashSet<>(nums.length); // 预分配空间\n        for (int x : nums) {\n            set.add(x);\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy;\n        while (cur.next != null) {\n            if (set.contains(cur.next.val)) {\n                cur.next = cur.next.next; // 删除\n            } else {\n                cur = cur.next; // 向后移动\n            }\n        }\n        return dummy.next;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    ListNode* modifiedList(vector<int>& nums, ListNode* head) {\n        unordered_set<int> st(nums.begin(), nums.end());\n        ListNode dummy(0, head);\n        ListNode* cur = &dummy;\n        while (cur->next) {\n            if (st.contains(cur->next->val)) {\n                cur->next = cur->next->next; // 删除\n            } else {\n                cur = cur->next; // 向后移动\n            }\n        }\n        return dummy.next;\n    }\n};\n",
            "go": "func modifiedList(nums []int, head *ListNode) *ListNode {\nhas := make(map[int]bool, len(nums)) // 预分配空间\nfor _, x := range nums {\nhas[x] = true\n}\ndummy := &ListNode{Next: head}\ncur := dummy\nfor cur.Next != nil {\nif has[cur.Next.Val] {\ncur.Next = cur.Next.Next // 删除\n} else {\ncur = cur.Next // 向后移动\n}\n}\nreturn dummy.Next\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[1,2,3]\",\"[1,2,3,4,5]\"]",
                "output": "[\"[4,5]\"]"
            },
            {
                "input": "[\"[1]\",\"[1,2,1,2,1,2]\"]",
                "output": "[\"[2,2,2]\"]"
            },
            {
                "input": "[\"[5]\",\"[1,2,3,4]\"]",
                "output": "[\"[1,2,3,4]\"]"
            }
        ],
        "contexts": {
            "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {",
            "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* modifiedList(vector<int>& nums, ListNode* head) {",
            "go": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc modifiedList(nums []int, head *ListNode) *ListNode {\n\n}",
            "js": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n *",
            "python": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def modifiedList(self, nums: List[int], head: Optional[ListNode]) -> Optional[ListNode]:"
        },
        "time": "20240714",
        "class_helper": {
            "python": "ListNode",
            "java": "ListNode",
            "cpp": "ListNode",
            "go": null,
            "js": "ListNode"
        },
        "input_def_helper": {
            "python": {
                "1": "list_to_linkedlist"
            },
            "java": null,
            "cpp": {
                "1": "list_to_linkedlist"
            },
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": "linkedlist_to_list",
            "java": null,
            "cpp": "linkedlist_to_list",
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "modifiedList",
            "java": "modifiedList",
            "cpp": "modifiedList",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "def list_to_linkedlist(nums):\n    dummy = ListNode(0)\n    current = dummy\n    for num in nums:\n        current.next = ListNode(num)\n        current = current.next\n    return dummy.next\n\ndef linkedlist_to_list(head):\n    result = []\n    current = head\n    while current is not None:\n        result.append(current.val)\n        current = current.next\n    return result\n\nmy_solution = Solution()\nassert linkedlist_to_list(my_solution.modifiedList([1,2,3], list_to_linkedlist([1,2,3,4,5]))) == [4,5], \"Test 1 Error!\"\nassert linkedlist_to_list(my_solution.modifiedList([1], list_to_linkedlist([1,2,1,2,1,2]))) == [2,2,2], \"Test 2 Error!\"\nassert linkedlist_to_list(my_solution.modifiedList([5], list_to_linkedlist([1,2,3,4]))) == [1,2,3,4], \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,3};\n    ListNode head_1 = [1,2,3,4,5];\n    ListNode ans_1 = [4,5];\n    assert solution.modifiedList(nums_1, head_1).equals(ans_1);\n    int[] nums_2 = {1};\n    ListNode head_2 = [1,2,1,2,1,2];\n    ListNode ans_2 = [2,2,2];\n    assert solution.modifiedList(nums_2, head_2).equals(ans_2);\n    int[] nums_3 = {5};\n    ListNode head_3 = [1,2,3,4];\n    ListNode ans_3 = [1,2,3,4];\n    assert solution.modifiedList(nums_3, head_3).equals(ans_3);\n    }\n}",
            "cpp": "ListNode* list_to_linkedlist(const vector<int>& nums) {\n    ListNode* dummy = new ListNode();\n    ListNode* current = dummy;\n    for (int num : nums) {\n        current->next = new ListNode(num);\n        current = current->next;\n    }\n    ListNode* head = dummy->next;\n    delete dummy;\n    return head;\n};\n\nvector<int> linkedlist_to_list(ListNode* head) {\n    vector<int> result;\n    ListNode* current = head;\n    while (current != nullptr) {\n        result.push_back(current->val);\n        current = current->next;\n    }\n    return result;\n};\n\n#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,3};\n    ListNode* head_1 = list_to_linkedlist({1,2,3,4,5});\n    ListNode* ans_1 = list_to_linkedlist({4,5});\n    assert(linkedlist_to_list(my_solution_1.modifiedList(nums_1, head_1)) == linkedlist_to_list(ans_1));\n    Solution my_solution_2;\n    vector<int> nums_2 = {1};\n    ListNode* head_2 = list_to_linkedlist({1,2,1,2,1,2});\n    ListNode* ans_2 = list_to_linkedlist({2,2,2});\n    assert(linkedlist_to_list(my_solution_2.modifiedList(nums_2, head_2)) == linkedlist_to_list(ans_2));\n    Solution my_solution_3;\n    vector<int> nums_3 = {5};\n    ListNode* head_3 = list_to_linkedlist({1,2,3,4});\n    ListNode* ans_3 = list_to_linkedlist({1,2,3,4});\n    assert(linkedlist_to_list(my_solution_3.modifiedList(nums_3, head_3)) == linkedlist_to_list(ans_3));\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "head"
            ],
            "java": [
                "nums",
                "head"
            ],
            "cpp": [
                "nums",
                "head"
            ],
            "go": [],
            "js": []
        }
    },
    "3218": {
        "description": "有一个 m x n 大小的矩形蛋糕，需要切成 1 x 1 的小块。\n给你整数 m ，n 和两个数组：\nhorizontalCut 的大小为 m - 1 ，其中 horizontalCut[i] 表示沿着水平线 i 切蛋糕的开销。\nverticalCut 的大小为 n - 1 ，其中 verticalCut[j] 表示沿着垂直线 j 切蛋糕的开销。\n一次操作中，你可以选择任意不是 1 x 1 大小的矩形蛋糕并执行以下操作之一：\n沿着水平线 i 切开蛋糕，开销为 horizontalCut[i] 。\n沿着垂直线 j 切开蛋糕，开销为 verticalCut[j] 。\n每次操作后，这块蛋糕都被切成两个独立的小蛋糕。\n每次操作的开销都为最开始对应切割线的开销，并且不会改变。\n请你返回将蛋糕全部切成 1 x 1 的蛋糕块的 最小 总开销。",
        "difficulty_level": "Middle",
        "note": "1 <= m, n <= 20\nhorizontalCut.length == m - 1\nverticalCut.length == n - 1\n1 <= horizontalCut[i], verticalCut[i] <= 10^3",
        "codes": {
            "python": "class Solution:\n    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:\n        horizontalCut.sort(reverse=True)\n        verticalCut.sort(reverse=True)\n        ans = i = j = 0\n        cnt_h = cnt_v = 1\n        while i < m - 1 or j < n - 1:\n            if j == n - 1 or i < m - 1 and horizontalCut[i] > verticalCut[j]:\n                ans += horizontalCut[i] * cnt_h  # 横切\n                i += 1\n                cnt_v += 1  # 需要竖切的蛋糕块增加\n            else:\n                ans += verticalCut[j] * cnt_v  # 竖切\n                j += 1\n                cnt_h += 1  # 需要横切的蛋糕块增加\n        return ans\n",
            "java": "class Solution {\n    public long minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n        Arrays.sort(horizontalCut); // 下面倒序遍历\n        Arrays.sort(verticalCut);\n        long ans = 0;\n        int i = m - 2;\n        int j = n - 2;\n        int cntH = 1;\n        int cntV = 1;\n        while (i >= 0 || j >= 0) {\n            if (j < 0 || i >= 0 && horizontalCut[i] > verticalCut[j]) {\n                ans += horizontalCut[i--] * cntH; // 横切\n                cntV++; // 需要竖切的蛋糕块增加\n            } else {\n                ans += verticalCut[j--] * cntV; // 竖切\n                cntH++; // 需要横切的蛋糕块增加\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long minimumCost(int m, int n, vector<int>& horizontalCut, vector<int>& verticalCut) {\n        ranges::sort(horizontalCut, greater<>());\n        ranges::sort(verticalCut, greater<>());\n        long long ans = 0;\n        int cnt_h = 1, cnt_v = 1;\n        int i = 0, j = 0;\n        while (i < m - 1 || j < n - 1) {\n            if (j == n - 1 || i < m - 1 && horizontalCut[i] > verticalCut[j]) {\n                ans += horizontalCut[i++] * cnt_h; // 横切\n                cnt_v++; // 需要竖切的蛋糕块增加\n            } else {\n                ans += verticalCut[j++] * cnt_v; // 竖切\n                cnt_h++; // 需要横切的蛋糕块增加\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func minimumCost(m, n int, horizontalCut, verticalCut []int) int64 {\nslices.SortFunc(horizontalCut, func(a, b int) int { return b - a })\nslices.SortFunc(verticalCut, func(a, b int) int { return b - a })\nans := 0\ncntH, cntV := 1, 1\ni, j := 0, 0\nfor i < m-1 || j < n-1 {\nif j == n-1 || i < m-1 && horizontalCut[i] > verticalCut[j] {\nans += horizontalCut[i] * cntH // 横切\ni++\ncntV++ // 需要竖切的蛋糕块增加\n} else {\nans += verticalCut[j] * cntV // 竖切\nj++\ncntH++ // 需要横切的蛋糕块增加\n}\n}\nreturn int64(ans)\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"3\",\"2\",\"[1,3]\",\"[5]\"]",
                "output": "[\"13\"]"
            },
            {
                "input": "[\"2\",\"2\",\"[7]\",\"[4]\"]",
                "output": "[\"15\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {",
            "cpp": "class Solution {\npublic:\n    int minimumCost(int m, int n, vector<int>& horizontalCut, vector<int>& verticalCut) {",
            "go": "func minimumCost(m int, n int, horizontalCut []int, verticalCut []int) int {\n\n}",
            "js": "/**\n * @param {number} m\n * @param {number} n\n * @param {number[]} horizontalCut\n * @param {number[]} verticalCut\n * @return {number}\n */\nvar minimumCost = function(m, n, horizontalCut, verticalCut) {",
            "python": "class Solution:\n    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:"
        },
        "time": "20240714",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumCost",
            "java": "minimumCost",
            "cpp": "minimumCost",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumCost(3, 2, [1,3], [5]) == 13, \"Test 1 Error!\"\nassert my_solution.minimumCost(2, 2, [7], [4]) == 15, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int m_1 = 3;\n    int n_1 = 2;\n    int[] horizontalCut_1 = {1,3};\n    int[] verticalCut_1 = {5};\n    int ans_1 = 13;\n    assert solution.minimumCost(m_1, n_1, horizontalCut_1, verticalCut_1) == ans_1;\n    int m_2 = 2;\n    int n_2 = 2;\n    int[] horizontalCut_2 = {7};\n    int[] verticalCut_2 = {4};\n    int ans_2 = 15;\n    assert solution.minimumCost(m_2, n_2, horizontalCut_2, verticalCut_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int m_1 = 3;\n    int n_1 = 2;\n    vector<int> horizontalCut_1 = {1,3};\n    vector<int> verticalCut_1 = {5};\n    int ans_1 = 13;\n    assert(my_solution_1.minimumCost(m_1, n_1, horizontalCut_1, verticalCut_1) == ans_1);\n    Solution my_solution_2;\n    int m_2 = 2;\n    int n_2 = 2;\n    vector<int> horizontalCut_2 = {7};\n    vector<int> verticalCut_2 = {4};\n    int ans_2 = 15;\n    assert(my_solution_2.minimumCost(m_2, n_2, horizontalCut_2, verticalCut_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "m",
                "n",
                "horizontalCut",
                "verticalCut"
            ],
            "java": [
                "m",
                "n",
                "horizontalCut",
                "verticalCut"
            ],
            "cpp": [
                "m",
                "n",
                "horizontalCut",
                "verticalCut"
            ],
            "go": [],
            "js": []
        }
    },
    "3219": {
        "description": "有一个 m x n 大小的矩形蛋糕，需要切成 1 x 1 的小块。\n给你整数 m ，n 和两个数组：\nhorizontalCut 的大小为 m - 1 ，其中 horizontalCut[i] 表示沿着水平线 i 切蛋糕的开销。\nverticalCut 的大小为 n - 1 ，其中 verticalCut[j] 表示沿着垂直线 j 切蛋糕的开销。\n一次操作中，你可以选择任意不是 1 x 1 大小的矩形蛋糕并执行以下操作之一：\n沿着水平线 i 切开蛋糕，开销为 horizontalCut[i] 。\n沿着垂直线 j 切开蛋糕，开销为 verticalCut[j] 。\n每次操作后，这块蛋糕都被切成两个独立的小蛋糕。\n每次操作的开销都为最开始对应切割线的开销，并且不会改变。\n请你返回将蛋糕全部切成 1 x 1 的蛋糕块的 最小 总开销。",
        "difficulty_level": "Hard",
        "note": "1 <= m, n <= 10^5\nhorizontalCut.length == m - 1\nverticalCut.length == n - 1\n1 <= horizontalCut[i], verticalCut[i] <= 10^3",
        "codes": {
            "python": "class Solution:\n    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:\n        horizontalCut.sort(reverse=True)\n        verticalCut.sort(reverse=True)\n        ans = i = j = 0\n        while i < m - 1 or j < n - 1:\n            if j == n - 1 or i < m - 1 and horizontalCut[i] > verticalCut[j]:\n                ans += horizontalCut[i] * (j + 1)  # 横切\n                i += 1\n            else:\n                ans += verticalCut[j] * (i + 1)  # 竖切\n                j += 1\n        return ans\n",
            "java": "class Solution {\n    public long minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n        Arrays.sort(horizontalCut); // 下面倒序遍历\n        Arrays.sort(verticalCut);\n        long ans = 0;\n        int i = m - 2;\n        int j = n - 2;\n        while (i >= 0 || j >= 0) {\n            if (j < 0 || i >= 0 && horizontalCut[i] > verticalCut[j]) {\n                ans += horizontalCut[i--] * (n - 1 - j); // 横切\n            } else {\n                ans += verticalCut[j--] * (m - 1 - i); // 竖切\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long minimumCost(int m, int n, vector<int>& horizontalCut, vector<int>& verticalCut) {\n        ranges::sort(horizontalCut, greater<>());\n        ranges::sort(verticalCut, greater<>());\n        long long ans = 0;\n        int i = 0, j = 0;\n        while (i < m - 1 || j < n - 1) {\n            if (j == n - 1 || i < m - 1 && horizontalCut[i] > verticalCut[j]) {\n                ans += horizontalCut[i++] * (j + 1); // 横切\n            } else {\n                ans += verticalCut[j++] * (i + 1); // 竖切\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func minimumCost(m, n int, horizontalCut, verticalCut []int) int64 {\nslices.SortFunc(horizontalCut, func(a, b int) int { return b - a })\nslices.SortFunc(verticalCut, func(a, b int) int { return b - a })\nans := 0\ni, j := 0, 0\nfor i < m-1 || j < n-1 {\nif j == n-1 || i < m-1 && horizontalCut[i] > verticalCut[j] {\nans += horizontalCut[i] * (j + 1) // 横切\ni++\n} else {\nans += verticalCut[j] * (i + 1) // 竖切\nj++\n}\n}\nreturn int64(ans)\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"3\",\"2\",\"[1,3]\",\"[5]\"]",
                "output": "[\"13\"]"
            },
            {
                "input": "[\"2\",\"2\",\"[7]\",\"[4]\"]",
                "output": "[\"15\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {",
            "cpp": "class Solution {\npublic:\n    long long minimumCost(int m, int n, vector<int>& horizontalCut, vector<int>& verticalCut) {",
            "go": "func minimumCost(m int, n int, horizontalCut []int, verticalCut []int) int64 {\n\n}",
            "js": "/**\n * @param {number} m\n * @param {number} n\n * @param {number[]} horizontalCut\n * @param {number[]} verticalCut\n * @return {number}\n */\nvar minimumCost = function(m, n, horizontalCut, verticalCut) {",
            "python": "class Solution:\n    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:"
        },
        "time": "20240714",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumCost",
            "java": "minimumCost",
            "cpp": "minimumCost",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumCost(3, 2, [1,3], [5]) == 13, \"Test 1 Error!\"\nassert my_solution.minimumCost(2, 2, [7], [4]) == 15, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int m_1 = 3;\n    int n_1 = 2;\n    int[] horizontalCut_1 = {1,3};\n    int[] verticalCut_1 = {5};\n    long ans_1 = 13;\n    assert solution.minimumCost(m_1, n_1, horizontalCut_1, verticalCut_1) == ans_1;\n    int m_2 = 2;\n    int n_2 = 2;\n    int[] horizontalCut_2 = {7};\n    int[] verticalCut_2 = {4};\n    long ans_2 = 15;\n    assert solution.minimumCost(m_2, n_2, horizontalCut_2, verticalCut_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int m_1 = 3;\n    int n_1 = 2;\n    vector<int> horizontalCut_1 = {1,3};\n    vector<int> verticalCut_1 = {5};\n    long long ans_1 = 13;\n    assert(my_solution_1.minimumCost(m_1, n_1, horizontalCut_1, verticalCut_1) == ans_1);\n    Solution my_solution_2;\n    int m_2 = 2;\n    int n_2 = 2;\n    vector<int> horizontalCut_2 = {7};\n    vector<int> verticalCut_2 = {4};\n    long long ans_2 = 15;\n    assert(my_solution_2.minimumCost(m_2, n_2, horizontalCut_2, verticalCut_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "m",
                "n",
                "horizontalCut",
                "verticalCut"
            ],
            "java": [
                "m",
                "n",
                "horizontalCut",
                "verticalCut"
            ],
            "cpp": [
                "m",
                "n",
                "horizontalCut",
                "verticalCut"
            ],
            "go": [],
            "js": []
        }
    },
    "3024": {
        "description": "给你一个下标从 0 开始长度为 3 的整数数组 nums ，需要用它们来构造三角形。\n如果一个三角形的所有边长度相等，那么这个三角形称为 equilateral 。\n如果一个三角形恰好有两条边长度相等，那么这个三角形称为 isosceles 。\n如果一个三角形三条边的长度互不相同，那么这个三角形称为 scalene 。\n如果这个数组无法构成一个三角形，请你返回字符串 \\\"none\\\" ，否则返回一个字符串表示这个三角形的类型。",
        "difficulty_level": "Easy",
        "note": "nums.length == 3\n1 <= nums[i] <= 100",
        "codes": {
            "python": "class Solution:\n    def triangleType(self, nums: List[int]) -> str:\n        nums.sort()\n        x, y, z = nums\n        if x + y <= z:  # 排序后，只需比较 x+y 和 z\n            return \"none\"\n        if x == z:  # 排序了，说明 y 也和 x z 相等\n            return \"equilateral\"\n        if x == y or y == z:\n            return \"isosceles\"\n        return \"scalene\"\n",
            "java": "class Solution {\n    public String triangleType(int[] nums) {\n        Arrays.sort(nums);\n        int x = nums[0];\n        int y = nums[1];\n        int z = nums[2];\n        if (x + y <= z) { // 排序后，只需比较 x+y 和 z\n            return \"none\";\n        }\n        if (x == z) { // 排序了，说明 y 也和 x z 相等\n            return \"equilateral\";\n        }\n        if (x == y || y == z) {\n            return \"isosceles\";\n        }\n        return \"scalene\";\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    string triangleType(vector<int> &nums) {\n        sort(nums.begin(), nums.end());\n        int x = nums[0], y = nums[1], z = nums[2];\n        if (x + y <= z) { // 排序后，只需比较 x+y 和 z\n            return \"none\";\n        }\n        if (x == z) { // 排序了，说明 y 也和 x z 相等\n            return \"equilateral\";\n        }\n        if (x == y || y == z) {\n            return \"isosceles\";\n        }\n        return \"scalene\";\n    }\n};\n",
            "go": "func triangleType(nums []int) string {\nslices.Sort(nums)\nx, y, z := nums[0], nums[1], nums[2]\nif x+y <= z { // 排序后，只需比较 x+y 和 z\nreturn \"none\"\n}\nif x == z { // 排序了，说明 y 也和 x z 相等\nreturn \"equilateral\"\n}\nif x == y || y == z {\nreturn \"isosceles\"\n}\nreturn \"scalene\"\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @return {string}\n */\nvar triangleType = function(nums) {\n    if (nums[0] + nums[1] <= nums[2] || nums[1] + nums[2] <= nums[0] || nums[0] + nums[2] <= nums[1]) return 'none'\n    if (nums[0] === nums[1] && nums[1] === nums[2]) return 'equilateral'\n    if (nums[0] === nums[1] || nums[1] === nums[2] || nums[0] === nums[2]) return 'isosceles'\n    return 'scalene'\n};\n"
        },
        "cases": [
            {
                "input": "[\"[3,3,3]\"]",
                "output": "[\"\\\"equilateral\\\"\"]"
            },
            {
                "input": "[\"[3,4,5]\"]",
                "output": "[\"\\\"scalene\\\"\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public String triangleType(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    string triangleType(vector<int>& nums) {",
            "go": "func triangleType(nums []int) string {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {string}\n */\nvar triangleType = function(nums) {",
            "python": "class Solution:\n    def triangleType(self, nums: List[int]) -> str:"
        },
        "time": "20240203",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "triangleType",
            "java": "triangleType",
            "cpp": "triangleType",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.triangleType([3,3,3]) == \"equilateral\", \"Test 1 Error!\"\nassert my_solution.triangleType([3,4,5]) == \"scalene\", \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {3,3,3};\n    String ans_1 = \"equilateral\";\n    assert solution.triangleType(nums_1).equals(ans_1);\n    int[] nums_2 = {3,4,5};\n    String ans_2 = \"scalene\";\n    assert solution.triangleType(nums_2).equals(ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {3,3,3};\n    string ans_1 = \"equilateral\";\n    assert(my_solution_1.triangleType(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {3,4,5};\n    string ans_2 = \"scalene\";\n    assert(my_solution_2.triangleType(nums_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3025": {
        "description": "给你一个  n x 2 的二维数组 points ，它表示二维平面上的一些点坐标，其中 points[i] = [x_i, y_i] 。\n计算点对 (A, B) 的数量，其中\nA 在 B 的左上角，并且\n它们形成的长方形中（或直线上）没有其它点（包括边界）。\n返回数量。",
        "difficulty_level": "Middle",
        "note": "2 <= n <= 50\npoints[i].length == 2\n0 <= points[i][0], points[i][1] <= 50\npoints[i] 点对两两不同。",
        "codes": {
            "python": "class Solution:\n    def numberOfPairs(self, points: List[List[int]]) -> int:\n        points.sort(key=lambda p: (p[0], -p[1]))\n        ans = 0\n        for i, (_, y0) in enumerate(points):\n            max_y = -inf\n            for (_, y) in points[i + 1:]:\n                if max_y < y <= y0:\n                    max_y = y\n                    ans += 1\n        return ans\n",
            "java": "class Solution {\n    public int numberOfPairs(int[][] points) {\n        Arrays.sort(points, (p, q) -> p[0] != q[0] ? p[0] - q[0] : q[1] - p[1]);\n        int ans = 0;\n        for (int i = 0; i < points.length; i++) {\n            int y0 = points[i][1];\n            int maxY = Integer.MIN_VALUE;\n            for (int j = i + 1; j < points.length; j++) {\n                int y = points[j][1];\n                if (y <= y0 && y > maxY) {\n                    maxY = y;\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int numberOfPairs(vector<vector<int>> &points) {\n        ranges::sort(points, [](const auto &p, const auto &q) {\n            return p[0] != q[0] ? p[0] < q[0] : p[1] > q[1];\n        });\n        int ans = 0, n = points.size();\n        for (int i = 0; i < n; i++) {\n            int y0 = points[i][1];\n            int max_y = INT_MIN;\n            for (int j = i + 1; j < n; j++) {\n                int y = points[j][1];\n                if (y <= y0 && y > max_y) {\n                    max_y = y;\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func numberOfPairs(points [][]int) (ans int) {\nslices.SortFunc(points, func(p, q []int) int {\nif p[0] != q[0] {\nreturn p[0] - q[0]\n}\nreturn q[1] - p[1]\n})\nfor i, p := range points {\ny0 := p[1]\nmaxY := math.MinInt\nfor _, q := range points[i+1:] {\ny := q[1]\nif y <= y0 && y > maxY {\nmaxY = y\nans++\n}\n}\n}\nreturn\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[[1,1],[2,2],[3,3]]\"]",
                "output": "[\"0\"]"
            },
            {
                "input": "[\"[[6,2],[4,4],[2,6]]\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[[3,1],[1,3],[1,1]]\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int numberOfPairs(int[][] points) {",
            "cpp": "class Solution {\npublic:\n    int numberOfPairs(vector<vector<int>>& points) {",
            "go": "func numberOfPairs(points [][]int) int {\n\n}",
            "js": "/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfPairs = function(points) {",
            "python": "class Solution:\n    def numberOfPairs(self, points: List[List[int]]) -> int:"
        },
        "time": "20240203",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "numberOfPairs",
            "java": "numberOfPairs",
            "cpp": "numberOfPairs",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.numberOfPairs([[1,1],[2,2],[3,3]]) == 0, \"Test 1 Error!\"\nassert my_solution.numberOfPairs([[6,2],[4,4],[2,6]]) == 2, \"Test 2 Error!\"\nassert my_solution.numberOfPairs([[3,1],[1,3],[1,1]]) == 2, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] points_1 = {{1,1},{2,2},{3,3}};\n    int ans_1 = 0;\n    assert solution.numberOfPairs(points_1) == ans_1;\n    int[][] points_2 = {{6,2},{4,4},{2,6}};\n    int ans_2 = 2;\n    assert solution.numberOfPairs(points_2) == ans_2;\n    int[][] points_3 = {{3,1},{1,3},{1,1}};\n    int ans_3 = 2;\n    assert solution.numberOfPairs(points_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> points_1 = {{1,1},{2,2},{3,3}};\n    int ans_1 = 0;\n    assert(my_solution_1.numberOfPairs(points_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> points_2 = {{6,2},{4,4},{2,6}};\n    int ans_2 = 2;\n    assert(my_solution_2.numberOfPairs(points_2) == ans_2);\n    Solution my_solution_3;\n    vector<vector<int>> points_3 = {{3,1},{1,3},{1,1}};\n    int ans_3 = 2;\n    assert(my_solution_3.numberOfPairs(points_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "points"
            ],
            "java": [
                "points"
            ],
            "cpp": [
                "points"
            ],
            "go": [],
            "js": []
        }
    },
    "3026": {
        "description": "给你一个长度为 n 的数组 nums 和一个 正 整数 k 。\n如果 nums 的一个子数组中，第一个元素和最后一个元素 差的绝对值恰好 为 k ，我们称这个子数组为 好 的。换句话说，如果子数组 nums[i..j] 满足 |nums[i] - nums[j]| == k ，那么它是一个好子数组。\n请你返回 nums 中 好 子数组的 最大 和，如果没有好子数组，返回 0 。",
        "difficulty_level": "Middle",
        "note": "2 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9\n1 <= k <= 10^9",
        "codes": {
            "python": "class Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        ans = -inf\n        min_s = defaultdict(lambda: inf)\n        s = 0\n        for x in nums:\n            ans = max(ans, s + x - min(min_s[x - k], min_s[x + k]))\n            min_s[x] = min(min_s[x], s)\n            s += x\n        return ans if ans > -inf else 0\n",
            "java": "class Solution {\n    public long maximumSubarraySum(int[] nums, int k) {\n        long ans = Long.MIN_VALUE;\n        long sum = 0;\n        Map<Integer, Long> minS = new HashMap<>();\n        for (int x : nums) {\n            long s1 = minS.getOrDefault(x - k, Long.MAX_VALUE / 2);\n            long s2 = minS.getOrDefault(x + k, Long.MAX_VALUE / 2);\n            ans = Math.max(ans, sum + x - Math.min(s1, s2));\n            minS.merge(x, sum, Math::min);\n            sum += x;\n        }\n        return ans > Long.MIN_VALUE / 4 ? ans : 0;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long maximumSubarraySum(vector<int> &nums, int k) {\n        long long ans = LLONG_MIN, sum = 0;\n        unordered_map<int, long long> min_s;\n        for (int x: nums) {\n            auto it = min_s.find(x + k);\n            if (it != min_s.end()) {\n                ans = max(ans, sum + x - it->second);\n            }\n\n            it = min_s.find(x - k);\n            if (it != min_s.end()) {\n                ans = max(ans, sum + x - it->second);\n            }\n\n            it = min_s.find(x);\n            if (it == min_s.end() || sum < it->second) {\n                min_s[x] = sum;\n            }\n\n            sum += x;\n        }\n        return ans == LLONG_MIN ? 0 : ans;\n    }\n};\n",
            "go": "func maximumSubarraySum(nums []int, k int) int64 {\nans := math.MinInt\nminS := map[int]int{}\nsum := 0\nfor _, x := range nums {\ns, ok := minS[x+k]\nif ok {\nans = max(ans, sum+x-s)\n}\n\ns, ok = minS[x-k]\nif ok {\nans = max(ans, sum+x-s)\n}\n\ns, ok = minS[x]\nif !ok || sum < s {\nminS[x] = sum\n}\n\nsum += x\n}\nif ans == math.MinInt {\nreturn 0\n}\nreturn int64(ans)\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumSubarraySum = function(nums, k) {\n    // 暴力算法超时\n    // let max = - Number.MAX_VALUE\n    // let sum = 0\n    // let count = 0\n    // for (let left = 0; left < nums.length; left++) {\n    //     sum = nums[left]\n    //     for (let right = left + 1; right < nums.length; right++) {\n    //         sum += nums[right]\n    //         if (Math.abs(nums[left] - nums[right]) === k) {\n    //             count += 1\n    //             max = Math.max(sum, max)\n    //         }\n    //     }\n    // }\n    // return count > 0 ? max : 0\n    \n    // 前缀和\n    const map = new Map()\n    let sum = 0\n    let max = - Number.MAX_VALUE\n    for (let num of nums) {\n        sum += num\n        if (!map.has(num)) {\n            map.set(num, sum - num)\n        }\n        if (map.has(num)) {\n            map.set(num, Math.min(sum - num, map.get(num)))\n        }\n        if (map.has(num - k)) {\n            max = Math.max(max, sum - map.get(num - k))\n        }\n        if (map.has(num + k)) {\n            max = Math.max(max, sum - map.get(num + k))\n        }\n    }\n    return max === - Number.MAX_VALUE ? 0 : max\n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,2,3,4,5,6]\",\"1\"]",
                "output": "[\"11\"]"
            },
            {
                "input": "[\"[-1,3,2,4,5]\",\"3\"]",
                "output": "[\"11\"]"
            },
            {
                "input": "[\"[-1,-2,-3,-4]\",\"2\"]",
                "output": "[\"-6\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long maximumSubarraySum(int[] nums, int k) {",
            "cpp": "class Solution {\npublic:\n    long long maximumSubarraySum(vector<int>& nums, int k) {",
            "go": "func maximumSubarraySum(nums []int, k int) int64 {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumSubarraySum = function(nums, k) {",
            "python": "class Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:"
        },
        "time": "20240203",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maximumSubarraySum",
            "java": "maximumSubarraySum",
            "cpp": "maximumSubarraySum",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maximumSubarraySum([1,2,3,4,5,6], 1) == 11, \"Test 1 Error!\"\nassert my_solution.maximumSubarraySum([-1,3,2,4,5], 3) == 11, \"Test 2 Error!\"\nassert my_solution.maximumSubarraySum([-1,-2,-3,-4], 2) == -6, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,3,4,5,6};\n    int k_1 = 1;\n    long ans_1 = 11;\n    assert solution.maximumSubarraySum(nums_1, k_1) == ans_1;\n    int[] nums_2 = {-1,3,2,4,5};\n    int k_2 = 3;\n    long ans_2 = 11;\n    assert solution.maximumSubarraySum(nums_2, k_2) == ans_2;\n    int[] nums_3 = {-1,-2,-3,-4};\n    int k_3 = 2;\n    long ans_3 = -6;\n    assert solution.maximumSubarraySum(nums_3, k_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,3,4,5,6};\n    int k_1 = 1;\n    long long ans_1 = 11;\n    assert(my_solution_1.maximumSubarraySum(nums_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {-1,3,2,4,5};\n    int k_2 = 3;\n    long long ans_2 = 11;\n    assert(my_solution_2.maximumSubarraySum(nums_2, k_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {-1,-2,-3,-4};\n    int k_3 = 2;\n    long long ans_3 = -6;\n    assert(my_solution_3.maximumSubarraySum(nums_3, k_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "k"
            ],
            "java": [
                "nums",
                "k"
            ],
            "cpp": [
                "nums",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3027": {
        "description": "给你一个  n x 2 的二维数组 points ，它表示二维平面上的一些点坐标，其中 points[i] = [x_i, y_i] 。\n我们定义 x 轴的正方向为 右 （x 轴递增的方向），x 轴的负方向为 左 （x 轴递减的方向）。类似的，我们定义 y 轴的正方向为 上 （y 轴递增的方向），y 轴的负方向为 下 （y 轴递减的方向）。\n你需要安排这 n 个人的站位，这 n 个人中包括 Alice 和 Bob 。你需要确保每个点处 恰好 有 一个 人。同时，Alice 想跟 Bob 单独玩耍，所以 Alice 会以 Alice 的坐标为 左上角 ，Bob 的坐标为 右下角 建立一个矩形的围栏（注意，围栏可能 不 包含任何区域，也就是说围栏可能是一条线段）。如果围栏的 内部 或者 边缘 上有任何其他人，Alice 都会难过。\n请你在确保 Alice 不会 难过的前提下，返回 Alice 和 Bob 可以选择的 点对 数目。\n注意，Alice 建立的围栏必须确保 Alice 的位置是矩形的左上角，Bob 的位置是矩形的右下角。比方说，以 (1, 1) ，(1, 3) ，(3, 1) 和 (3, 3) 为矩形的四个角，给定下图的两个输入，Alice 都不能建立围栏，原因如下：\n图一中，Alice 在 (3, 3) 且 Bob 在 (1, 1) ，Alice 的位置不是左上角且 Bob 的位置不是右下角。\n图二中，Alice 在 (1, 3) 且 Bob 在 (1, 1) ，Bob 的位置不是在围栏的右下角。",
        "difficulty_level": "Hard",
        "note": "2 <= n <= 1000\npoints[i].length == 2\n-10^9 <= points[i][0], points[i][1] <= 10^9\npoints[i] 点对两两不同。",
        "codes": {
            "python": "class Solution:\n    def numberOfPairs(self, points: List[List[int]]) -> int:\n        points.sort(key=lambda p: (p[0], -p[1]))\n        ans = 0\n        for i, (_, y0) in enumerate(points):\n            max_y = -inf\n            for (_, y) in points[i + 1:]:\n                if max_y < y <= y0:\n                    max_y = y\n                    ans += 1\n        return ans\n",
            "java": "class Solution {\n    public int numberOfPairs(int[][] points) {\n        Arrays.sort(points, (p, q) -> p[0] != q[0] ? p[0] - q[0] : q[1] - p[1]);\n        int ans = 0;\n        for (int i = 0; i < points.length; i++) {\n            int y0 = points[i][1];\n            int maxY = Integer.MIN_VALUE;\n            for (int j = i + 1; j < points.length; j++) {\n                int y = points[j][1];\n                if (y <= y0 && y > maxY) {\n                    maxY = y;\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int numberOfPairs(vector<vector<int>> &points) {\n        ranges::sort(points, [](const auto &p, const auto &q) {\n            return p[0] != q[0] ? p[0] < q[0] : p[1] > q[1];\n        });\n        int ans = 0, n = points.size();\n        for (int i = 0; i < n; i++) {\n            int y0 = points[i][1];\n            int max_y = INT_MIN;\n            for (int j = i + 1; j < n; j++) {\n                int y = points[j][1];\n                if (y <= y0 && y > max_y) {\n                    max_y = y;\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func numberOfPairs(points [][]int) (ans int) {\nslices.SortFunc(points, func(p, q []int) int {\nif p[0] != q[0] {\nreturn p[0] - q[0]\n}\nreturn q[1] - p[1]\n})\nfor i, p := range points {\ny0 := p[1]\nmaxY := math.MinInt\nfor _, q := range points[i+1:] {\ny := q[1]\nif y <= y0 && y > maxY {\nmaxY = y\nans++\n}\n}\n}\nreturn\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[[1,1],[2,2],[3,3]]\"]",
                "output": "[\"0\"]"
            },
            {
                "input": "[\"[[6,2],[4,4],[2,6]]\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[[3,1],[1,3],[1,1]]\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int numberOfPairs(int[][] points) {",
            "cpp": "class Solution {\npublic:\n    int numberOfPairs(vector<vector<int>>& points) {",
            "go": "func numberOfPairs(points [][]int) int {\n\n}",
            "js": "/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfPairs = function(points) {",
            "python": "class Solution:\n    def numberOfPairs(self, points: List[List[int]]) -> int:"
        },
        "time": "20240203",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "numberOfPairs",
            "java": "numberOfPairs",
            "cpp": "numberOfPairs",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.numberOfPairs([[1,1],[2,2],[3,3]]) == 0, \"Test 1 Error!\"\nassert my_solution.numberOfPairs([[6,2],[4,4],[2,6]]) == 2, \"Test 2 Error!\"\nassert my_solution.numberOfPairs([[3,1],[1,3],[1,1]]) == 2, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] points_1 = {{1,1},{2,2},{3,3}};\n    int ans_1 = 0;\n    assert solution.numberOfPairs(points_1) == ans_1;\n    int[][] points_2 = {{6,2},{4,4},{2,6}};\n    int ans_2 = 2;\n    assert solution.numberOfPairs(points_2) == ans_2;\n    int[][] points_3 = {{3,1},{1,3},{1,1}};\n    int ans_3 = 2;\n    assert solution.numberOfPairs(points_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> points_1 = {{1,1},{2,2},{3,3}};\n    int ans_1 = 0;\n    assert(my_solution_1.numberOfPairs(points_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> points_2 = {{6,2},{4,4},{2,6}};\n    int ans_2 = 2;\n    assert(my_solution_2.numberOfPairs(points_2) == ans_2);\n    Solution my_solution_3;\n    vector<vector<int>> points_3 = {{3,1},{1,3},{1,1}};\n    int ans_3 = 2;\n    assert(my_solution_3.numberOfPairs(points_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "points"
            ],
            "java": [
                "points"
            ],
            "cpp": [
                "points"
            ],
            "go": [],
            "js": []
        }
    },
    "3038": {
        "description": "给你一个整数数组 nums ，如果 nums 至少 包含 2 个元素，你可以执行以下操作：\n选择 nums 中的前两个元素并将它们删除。\n一次操作的 分数 是被删除元素的和。\n在确保 所有操作分数相同 的前提下，请你求出 最多 能进行多少次操作。\n请你返回按照上述要求 最多 可以进行的操作次数。",
        "difficulty_level": "Easy",
        "note": "2 <= nums.length <= 100\n1 <= nums[i] <= 1000",
        "codes": {
            "python": "class Solution:\n    def maxOperations(self, nums: List[int]) -> int:\n        n, t = len(nums), 0\n        for i in range(1, n, 2):\n            if nums[i] + nums[i - 1] != nums[1] + nums[0]:\n                break\n            t += 1\n        return t\n",
            "java": "class Solution {\n    public int maxOperations(int[] nums) {\n        int n = nums.length, t = 0;\n        for (int i = 1; i < n; i += 2) {\n            if (nums[i] + nums[i - 1] != nums[1] + nums[0]) {\n                break;\n            }\n            t++;\n        }\n        return t;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int maxOperations(vector<int>& nums) {\n        int n = nums.size(), t = 0;\n        for (int i = 1; i < n; i += 2) {\n            if (nums[i] + nums[i - 1] != nums[1] + nums[0]) {\n                break;\n            }\n            t++;\n        }\n        return t;\n    }\n};\n",
            "go": "func maxOperations(nums []int) int {\n    n, t := len(nums), 0\n    for i := 1; i < n; i += 2 {\n        if nums[i] + nums[i - 1] != nums[1] + nums[0] {\n            break\n        }\n        t++\n    }\n    return t\n}\n",
            "js": "var maxOperations = function(nums) {\n    let n = nums.length, t = 0;\n    for (let i = 1; i < n; i += 2) {\n        if (nums[i] + nums[i - 1] != nums[1] + nums[0]) {\n            break;\n        }\n        t++;\n    }\n    return t;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[3,2,1,4,5]\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[3,2,6,1,4]\"]",
                "output": "[\"1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maxOperations(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    int maxOperations(vector<int>& nums) {",
            "go": "func maxOperations(nums []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxOperations = function(nums) {",
            "python": "class Solution:\n    def maxOperations(self, nums: List[int]) -> int:"
        },
        "time": "20240217",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maxOperations",
            "java": "maxOperations",
            "cpp": "maxOperations",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maxOperations([3,2,1,4,5]) == 2, \"Test 1 Error!\"\nassert my_solution.maxOperations([3,2,6,1,4]) == 1, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {3,2,1,4,5};\n    int ans_1 = 2;\n    assert solution.maxOperations(nums_1) == ans_1;\n    int[] nums_2 = {3,2,6,1,4};\n    int ans_2 = 1;\n    assert solution.maxOperations(nums_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {3,2,1,4,5};\n    int ans_1 = 2;\n    assert(my_solution_1.maxOperations(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {3,2,6,1,4};\n    int ans_2 = 1;\n    assert(my_solution_2.maxOperations(nums_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3039": {
        "description": "给你一个字符串 s 。请你进行以下操作直到 s 为 空 ：\n每次操作 依次 遍历 'a' 到 'z'，如果当前字符出现在 s 中，那么删除出现位置 最早 的该字符（如果存在的话）。\n例如，最初 s = \\\"aabcbbca\\\"。我们执行下述操作：\n移除下划线的字符  s = \\\"\\undeline{a}a\\underline{bc}bbca\\\"。结果字符串为 s = \\\"abbca\\\"。\n移除下划线的字符  s = \\\"\\underline{ab}b\\underline{c}a\\\"。结果字符串为 s = \\\"ba\\\"。\n移除下划线的字符  s = \\\"\\underline{ba}\\\"。结果字符串为 s = \\\"\\\"。\n请你返回进行 最后 一次操作 之前 的字符串 s 。在上面的例子中，答案是 \\\"ba\\\"。",
        "difficulty_level": "Middle",
        "note": "1 <= s.length <= 5 * 10^5\ns 只包含小写英文字母。",
        "codes": {
            "python": "class Solution:\n    def lastNonEmptyString(self, s: str) -> str:\n        last = {c: i for i, c in enumerate(s)}\n        cnt = Counter(s)\n        mx = max(cnt.values())\n        ids = sorted(last[ch] for ch, c in cnt.items() if c == mx)\n        return ''.join(s[i] for i in ids)\n",
            "java": "class Solution {\n    public String lastNonEmptyString(String S) {\n        int[] cnt = new int[26];\n        int[] last = new int[26];\n        char[] s = S.toCharArray();\n        for (int i = 0; i < s.length; i++) {\n            int b = s[i] - 'a';\n            cnt[b]++;\n            last[b] = i;\n        }\n\n        // 注：也可以再遍历一次 s 直接得到答案，但效率不如下面，毕竟至多 26 个数\n        List<Integer> ids = new ArrayList<>();\n        int mx = Arrays.stream(cnt).max().orElseThrow();\n        for (int i = 0; i < 26; i++) {\n            if (cnt[i] == mx) {\n                ids.add(last[i]);\n            }\n        }\n        Collections.sort(ids);\n\n        StringBuilder t = new StringBuilder(ids.size());\n        for (int i : ids) {\n            t.append(s[i]);\n        }\n        return t.toString();\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    string lastNonEmptyString(string s) {\n        int cnt[26]{}, last[26]{};\n        for (int i = 0; i < s.size(); i++) {\n            int b = s[i] - 'a';\n            cnt[b]++;\n            last[b] = i;\n        }\n\n        // 注：也可以再遍历一次 s 直接得到答案，但效率不如下面，毕竟至多 26 个数\n        vector<int> ids;\n        int mx = ranges::max(cnt);\n        for (int i = 0; i < 26; i++) {\n            if (cnt[i] == mx) {\n                ids.push_back(last[i]);\n            }\n        }\n        ranges::sort(ids);\n\n        string t(ids.size(), 0);\n        for (int i = 0; i < ids.size(); i++) {\n            t[i] = s[ids[i]];\n        }\n        return t;\n    }\n};\n",
            "go": "func lastNonEmptyString(s string) string {\nvar cnt, last [26]int\nfor i, b := range s {\nb -= 'a'\ncnt[b]++\nlast[b] = i\n}\n\n// 注：也可以再遍历一次 s 直接得到答案，但效率不如下面，毕竟至多 26 个数\nids := []int{}\nmx := slices.Max(cnt[:])\nfor i, c := range cnt {\nif c == mx {\nids = append(ids, last[i])\n}\n}\nslices.Sort(ids)\n\nt := make([]byte, len(ids))\nfor i, id := range ids {\nt[i] = s[id]\n}\nreturn string(t)\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"\\\"aabcbbca\\\"\"]",
                "output": "[\"\\\"ba\\\"\"]"
            },
            {
                "input": "[\"\\\"abcd\\\"\"]",
                "output": "[\"\\\"abcd\\\"\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public String lastNonEmptyString(String s) {",
            "cpp": "class Solution {\npublic:\n    string lastNonEmptyString(string s) {",
            "go": "func lastNonEmptyString(s string) string {\n\n}",
            "js": "/**\n * @param {string} s\n * @return {string}\n */\nvar lastNonEmptyString = function(s) {",
            "python": "class Solution:\n    def lastNonEmptyString(self, s: str) -> str:"
        },
        "time": "20240217",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "lastNonEmptyString",
            "java": "lastNonEmptyString",
            "cpp": "lastNonEmptyString",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.lastNonEmptyString(\"aabcbbca\") == \"ba\", \"Test 1 Error!\"\nassert my_solution.lastNonEmptyString(\"abcd\") == \"abcd\", \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String s_1 = \"aabcbbca\";\n    String ans_1 = \"ba\";\n    assert solution.lastNonEmptyString(s_1).equals(ans_1);\n    String s_2 = \"abcd\";\n    String ans_2 = \"abcd\";\n    assert solution.lastNonEmptyString(s_2).equals(ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string s_1 = \"aabcbbca\";\n    string ans_1 = \"ba\";\n    assert(my_solution_1.lastNonEmptyString(s_1) == ans_1);\n    Solution my_solution_2;\n    string s_2 = \"abcd\";\n    string ans_2 = \"abcd\";\n    assert(my_solution_2.lastNonEmptyString(s_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "s"
            ],
            "java": [
                "s"
            ],
            "cpp": [
                "s"
            ],
            "go": [],
            "js": []
        }
    },
    "3040": {
        "description": "给你一个整数数组 nums ，如果 nums 至少 包含 2 个元素，你可以执行以下操作中的 任意 一个：\n选择 nums 中最前面两个元素并且删除它们。\n选择 nums 中最后两个元素并且删除它们。\n选择 nums 中第一个和最后一个元素并且删除它们。\n一次操作的 分数 是被删除元素的和。\n在确保 所有操作分数相同 的前提下，请你求出 最多 能进行多少次操作。\n请你返回按照上述要求 最多 可以进行的操作次数。",
        "difficulty_level": "Middle",
        "note": "2 <= nums.length <= 2000\n1 <= nums[i] <= 1000",
        "codes": {
            "python": "class Solution:\n    def maxOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n\n        @cache\n        def dfs(i, j, target):\n            if i >= j:\n                return 0\n            ans = 0\n            if nums[i] + nums[i + 1] == target:\n                ans = max(ans, 1 + dfs(i + 2, j, target))\n            if nums[i] + nums[j] == target:\n                ans = max(ans, 1 + dfs(i + 1, j - 1, target))\n            if nums[j - 1] + nums[j] == target:\n                ans = max(ans, 1 + dfs(i , j - 2, target))\n            return ans\n\n        res = 0\n        res = max(res, dfs(0, n - 1, nums[0] + nums[1]))\n        res = max(res, dfs(0, n - 1, nums[0] + nums[n - 1]))\n        res = max(res, dfs(0, n - 1, nums[n - 2] + nums[n - 1]))\n        return res\n",
            "java": "class Solution {\n    int[] nums;\n    int[][] memo;\n\n    public int maxOperations(int[] nums) {\n        int n = nums.length;\n        this.nums = nums;\n        this.memo = new int[n][n];\n        int res = 0;\n        res = Math.max(res, helper(0, n - 1, nums[0] + nums[n - 1]));\n        res = Math.max(res, helper(0, n - 1, nums[0] + nums[1]));\n        res = Math.max(res, helper(0, n - 1, nums[n - 2] + nums[n - 1]));\n        return res;\n    }\n\n    public int helper(int i, int j, int target) {\n        for (int k = 0; k < nums.length; k++) {\n            Arrays.fill(memo[k], -1);\n        }\n        return dfs(i, j, target);\n    }\n\n    public int dfs(int i, int j, int target) {\n        if (i >= j) {\n            return 0;\n        }\n        if (memo[i][j] != -1) {\n            return memo[i][j];\n        }\n        int ans = 0;\n        if (nums[i] + nums[i + 1] == target) {\n            ans = Math.max(ans, dfs(i + 2, j, target) + 1);\n        }\n        if (nums[j - 1] + nums[j] == target) {\n            ans = Math.max(ans, dfs(i, j - 2, target) + 1);\n        }\n        if (nums[i] + nums[j] == target) {\n            ans = Math.max(ans, dfs(i + 1, j - 1, target) + 1);\n        }\n        memo[i][j] = ans;\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int maxOperations(vector<int>& nums) {\n        int n = nums.size();\n        int memo[n][n];\n\n        auto helper = [&](int i, int j, int target) -> int {\n            memset(memo, -1, sizeof(memo));\n            function<int(int, int)> dfs = [&](int i, int j) -> int {\n                if (i >= j) {\n                    return 0;\n                }\n                if (memo[i][j] != -1) {\n                    return memo[i][j];\n                }\n                int ans = 0;\n                if (nums[i] + nums[i + 1] == target) {\n                    ans = max(ans, 1 + dfs(i + 2, j));\n                }\n                if (nums[j - 1] + nums[j] == target) {\n                    ans = max(ans, 1 + dfs(i, j - 2));\n                }\n                if (nums[i] + nums[j] == target) {\n                    ans = max(ans, 1 + dfs(i + 1, j - 1));\n                }\n                memo[i][j] = ans;\n                return ans;\n            };\n            return dfs(i, j);\n        };\n\n        int res = 0;\n        res = max(res, helper(0, n - 1, nums[0] + nums[n - 1]));\n        res = max(res, helper(0, n - 1, nums[0] + nums[1]));\n        res = max(res, helper(0, n - 1, nums[n - 2] + nums[n - 1]));\n        return res;\n    }\n};\n",
            "go": "func maxOperations(nums []int) int {\n    n := len(nums)\nmemo := make([][]int, n)\n\n    helper := func(i, j, target int) int {\n        for i := range memo {\n            memo[i] = make([]int, n)\n            for j := range memo[i] {\n                memo[i][j] = -1\n            }\n        }\n\n        var dfs func(int, int) int\n        dfs = func(i, j int) int {\n            if i >= j {\n                return 0\n            }\n            if memo[i][j] != -1 {\n                return memo[i][j]\n            }\n\n            ans := 0\n            if nums[i] + nums[i + 1] == target {\n                ans = max(ans, 1 + dfs(i + 2, j))\n            }\n            if nums[j - 1] + nums[j] == target {\n                ans = max(ans, 1 + dfs(i, j - 2))\n            }\n            if nums[i] + nums[j] == target {\n                ans = max(ans, 1 + dfs(i + 1, j - 1))\n            }\n            memo[i][j] = ans\n            return ans\n        }\n        return dfs(i, j)\n    }\n\nres := 0\nres = max(res, helper(0, n - 1, nums[0] + nums[n - 1]))\nres = max(res, helper(0, n - 1, nums[0] + nums[1]))\nres = max(res, helper(0, n - 1, nums[n - 2] + nums[n - 1]))\nreturn res\n}\n",
            "js": "var maxOperations = function(nums) {\n    const n = nums.length;\n    const helper = (i, j, target) => {\n        const memo = Array.from({ length: n }, () => Array(n).fill(-1));\n        const dfs = (i, j) => {\n            if (i >= j) {\n                return 0;\n            }\n            if (memo[i][j] != -1) {\n                return memo[i][j];\n            }\n            let ans = 0;\n            if (nums[i] + nums[i + 1] == target) {\n                ans = Math.max(ans, 1 + dfs(i + 2, j));\n            }\n            if (nums[j - 1] + nums[j] == target) {\n                ans = Math.max(ans, 1 + dfs(i, j - 2));\n            }\n            if (nums[i] + nums[j] == target) {\n                ans = Math.max(ans, 1 + dfs(i + 1, j - 1));\n            }\n            memo[i][j] = ans;\n            return ans;\n        }\n        return dfs(i, j);\n    }\n\n    let res = 0;\n    res = Math.max(res, helper(0, n - 1, nums[0] + nums[n - 1]));\n    res = Math.max(res, helper(0, n - 1, nums[0] + nums[1]));\n    res = Math.max(res, helper(0, n - 1, nums[n - 2] + nums[n - 1]));\n    return res;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[3,2,1,2,3,4]\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[3,2,6,1,4]\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maxOperations(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    int maxOperations(vector<int>& nums) {",
            "go": "func maxOperations(nums []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxOperations = function(nums) {",
            "python": "class Solution:\n    def maxOperations(self, nums: List[int]) -> int:"
        },
        "time": "20240217",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maxOperations",
            "java": "maxOperations",
            "cpp": "maxOperations",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maxOperations([3,2,1,2,3,4]) == 3, \"Test 1 Error!\"\nassert my_solution.maxOperations([3,2,6,1,4]) == 2, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {3,2,1,2,3,4};\n    int ans_1 = 3;\n    assert solution.maxOperations(nums_1) == ans_1;\n    int[] nums_2 = {3,2,6,1,4};\n    int ans_2 = 2;\n    assert solution.maxOperations(nums_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {3,2,1,2,3,4};\n    int ans_1 = 3;\n    assert(my_solution_1.maxOperations(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {3,2,6,1,4};\n    int ans_2 = 2;\n    assert(my_solution_2.maxOperations(nums_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3041": {
        "description": "给你一个下标从 0 开始只包含 正 整数的数组 nums 。一开始，你可以将数组中 任意数量 元素增加 至多 1 。\n修改后，你可以从最终数组中选择 一个或者更多 元素，并确保这些元素升序排序后是 连续 的。比方说，[3, 4, 5] 是连续的，但是 [3, 4, 6] 和 [1, 1, 2, 3] 不是连续的。\n请你返回 最多 可以选出的元素数目。",
        "difficulty_level": "Hard",
        "note": "1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^6",
        "codes": {
            "python": "class Solution:\n    def maxSelectedElements(self, nums: List[int]) -> int:\n        nums.sort()\n        f = defaultdict(int)\n        for x in nums:\n            f[x + 1] = f[x] + 1\n            f[x] = f[x - 1] + 1\n        return max(f.values())\n",
            "java": "class Solution {\n    public int maxSelectedElements(int[] nums) {\n        Arrays.sort(nums);\n        Map<Integer, Integer> f = new HashMap<>();\n        for (int x : nums) {\n            f.put(x + 1, f.getOrDefault(x, 0) + 1);\n            f.put(x, f.getOrDefault(x - 1, 0) + 1);\n        }\n        int ans = 0;\n        for (int res : f.values()) {\n            ans = Math.max(ans, res);\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int maxSelectedElements(vector<int> &nums) {\n        ranges::sort(nums);\n        unordered_map<int, int> f;\n        for (int x : nums) {\n            f[x + 1] = f[x] + 1;\n            f[x] = f[x - 1] + 1;\n        }\n        int ans = 0;\n        for (auto &[_, res] : f) {\n            ans = max(ans, res);\n        }\n        return ans;\n    }\n};\n",
            "go": "func maxSelectedElements(nums []int) (ans int) {\nslices.Sort(nums)\nf := map[int]int{}\nfor _, x := range nums {\nf[x+1] = f[x] + 1\nf[x] = f[x-1] + 1\n}\nfor _, res := range f {\nans = max(ans, res)\n}\nreturn\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSelectedElements = function(nums) {\n    const sortSums = nums.sort((a,b) => a-b)\n    const len = nums.length;\n    let count = 0\n    for(let i = 0; i < len - count; i++) {\n        let cur = sortSums[i]\n        let cLen = 1;\n        for(let j = i + 1; j < len; j++) {\n            const item = sortSums[j]\n            if(item < cur) {\n                continue;\n            }\n            if(item === cur) {\n                cur++;\n                cLen++\n                continue;\n            }\n            if(item === cur + 1) {\n\n                cur++;\n                cLen++\n                continue;\n            }\n            if(item > cur + 1) {\n                if(item > cur + 2) {\n                    // 相差大于2 开头直接跳到 j 因为后面 i ++ 所以这里 j 需要 - 1\n                    i = j - 1;\n                }\n                break;\n            }\n        }\n        count = Math.max(count, cLen)\n        cur = sortSums[i] + 1\n        cLen = 1;\n        for(let j = i + 1; j < len; j++) {\n            const item = sortSums[j]\n            if(item < cur) {\n                continue;\n            }\n            if(item === cur) {\n                cur++;\n                cLen++\n                continue;\n            }\n            if(item === cur + 1) {\n                cur++;\n                cLen++\n                continue;\n            }\n            if(item > cur + 1) {\n                if(item > cur + 2) {\n                    i = j - 1;\n                }\n                break;\n            }\n        }\n        count = Math.max(count, cLen)\n    }\n    return count\n};\n"
        },
        "cases": [
            {
                "input": "[\"[2,1,5,1,1]\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[1,4,7,10]\"]",
                "output": "[\"1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maxSelectedElements(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    int maxSelectedElements(vector<int>& nums) {",
            "go": "func maxSelectedElements(nums []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSelectedElements = function(nums) {",
            "python": "class Solution:\n    def maxSelectedElements(self, nums: List[int]) -> int:"
        },
        "time": "20240217",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maxSelectedElements",
            "java": "maxSelectedElements",
            "cpp": "maxSelectedElements",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maxSelectedElements([2,1,5,1,1]) == 3, \"Test 1 Error!\"\nassert my_solution.maxSelectedElements([1,4,7,10]) == 1, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {2,1,5,1,1};\n    int ans_1 = 3;\n    assert solution.maxSelectedElements(nums_1) == ans_1;\n    int[] nums_2 = {1,4,7,10};\n    int ans_2 = 1;\n    assert solution.maxSelectedElements(nums_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {2,1,5,1,1};\n    int ans_1 = 3;\n    assert(my_solution_1.maxSelectedElements(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,4,7,10};\n    int ans_2 = 1;\n    assert(my_solution_2.maxSelectedElements(nums_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3065": {
        "description": "给你一个下标从 0 开始的整数数组 nums 和一个整数 k。\n一次操作中，你可以删除 nums 中的最小元素。\n你需要使数组中的所有元素都大于或等于 k ，请你返回需要的 最少 操作次数。",
        "difficulty_level": "Easy",
        "note": "1 <= nums.length <= 50\n1 <= nums[i] <= 10^9\n1 <= k <= 10^9\n输入保证至少有一个满足 nums[i] >= k 的下标 i 存在。",
        "codes": {
            "python": "class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        return sum(x < k for x in nums)\n",
            "java": "class Solution {\n    public int minOperations(int[] nums, int k) {\n        int ans = 0;\n        for (int x : nums) {\n            if (x < k) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minOperations(vector<int> &nums, int k) {\n        int ans = 0;\n        for (int x : nums) {\n            ans += x < k;\n        }\n        return ans;\n    }\n};\n",
            "go": "func minOperations(nums []int, k int) (ans int) {\nfor _, x := range nums {\nif x < k {\nans++\n}\n}\nreturn\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(nums, k) {\n    return nums.filter(v => v < k).length\n};\n"
        },
        "cases": [
            {
                "input": "[\"[2,11,10,1,3]\",\"10\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[1,1,2,4,9]\",\"1\"]",
                "output": "[\"0\"]"
            },
            {
                "input": "[\"[1,1,2,4,9]\",\"9\"]",
                "output": "[\"4\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minOperations(int[] nums, int k) {",
            "cpp": "class Solution {\npublic:\n    int minOperations(vector<int>& nums, int k) {",
            "go": "func minOperations(nums []int, k int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(nums, k) {",
            "python": "class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:"
        },
        "time": "20240302",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minOperations",
            "java": "minOperations",
            "cpp": "minOperations",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minOperations([2,11,10,1,3], 10) == 3, \"Test 1 Error!\"\nassert my_solution.minOperations([1,1,2,4,9], 1) == 0, \"Test 2 Error!\"\nassert my_solution.minOperations([1,1,2,4,9], 9) == 4, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {2,11,10,1,3};\n    int k_1 = 10;\n    int ans_1 = 3;\n    assert solution.minOperations(nums_1, k_1) == ans_1;\n    int[] nums_2 = {1,1,2,4,9};\n    int k_2 = 1;\n    int ans_2 = 0;\n    assert solution.minOperations(nums_2, k_2) == ans_2;\n    int[] nums_3 = {1,1,2,4,9};\n    int k_3 = 9;\n    int ans_3 = 4;\n    assert solution.minOperations(nums_3, k_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {2,11,10,1,3};\n    int k_1 = 10;\n    int ans_1 = 3;\n    assert(my_solution_1.minOperations(nums_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,1,2,4,9};\n    int k_2 = 1;\n    int ans_2 = 0;\n    assert(my_solution_2.minOperations(nums_2, k_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {1,1,2,4,9};\n    int k_3 = 9;\n    int ans_3 = 4;\n    assert(my_solution_3.minOperations(nums_3, k_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "k"
            ],
            "java": [
                "nums",
                "k"
            ],
            "cpp": [
                "nums",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3066": {
        "description": "给你一个下标从 0 开始的整数数组 nums 和一个整数 k。\n一次操作中，你将执行：\n选择 nums 中最小的两个整数 x 和 y。\n将 x 和 y 从 nums 中删除。\n将 min(x, y) * 2 + max(x, y) 添加到数组中的任意位置。\n注意，只有当 nums 至少包含两个元素时，你才可以执行以上操作。\n你需要使数组中的所有元素都大于或等于 k ，请你返回需要的 最少 操作次数。",
        "difficulty_level": "Middle",
        "note": "2 <= nums.length <= 2 * 10^5\n1 <= nums[i] <= 10^9\n1 <= k <= 10^9\n输入保证答案一定存在，也就是说一定存在一个操作序列使数组中所有元素都大于等于 k 。",
        "codes": {
            "python": "class Solution:\n    def minOperations(self, h: List[int], k: int) -> int:\n        ans = 0\n        heapify(h)\n        while h[0] < k:\n            x = heappop(h)\n            heapreplace(h, x * 2 + h[0])\n            ans += 1\n        return ans\n",
            "java": "class Solution {\n    public int minOperations(int[] nums, int k) {\n        int ans = 0;\n        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (int x : nums) {\n            pq.offer((long) x);\n        }\n        while (pq.peek() < k) {\n            long x = pq.poll();\n            long y = pq.poll();\n            pq.offer(x * 2 + y);\n            ans++;\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minOperations(vector<int> &nums, int k) {\n        int ans = 0;\n        priority_queue<long long, vector<long long>, greater<>> pq;\n        for (int x : nums) {\n            pq.push((long long) x);\n        }\n        while (pq.top() < k) {\n            long long x = pq.top(); pq.pop();\n            long long y = pq.top(); pq.pop();\n            pq.push(x * 2 + y);\n            ans++;\n        }\n        return ans;\n    }\n};\n",
            "go": "func minOperations(nums []int, k int) (ans int) {\nh := &hp{nums}\nheap.Init(h)\nfor h.IntSlice[0] < k {\nx := heap.Pop(h).(int)\nh.IntSlice[0] += x * 2\nheap.Fix(h, 0)\nans++\n}\nreturn\n}\n\ntype hp struct{ sort.IntSlice }\nfunc (hp) Push(any)    {}\nfunc (h *hp) Pop() any { a := h.IntSlice; v := a[len(a)-1]; h.IntSlice = a[:len(a)-1]; return v }\n",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(nums, k) {\n    let q = new MinPriorityQueue()\n    for(let x of nums){\n        q.enqueue(x)\n    }\n    let ans = 0\n    while(q.front().element < k){\n       let {element:x} = q.dequeue(), {element:y} = q.dequeue()\n       ans++\n       q.enqueue(Math.min(x,y)*2 + Math.max(x,y))\n    }\n    return ans \n};\n"
        },
        "cases": [
            {
                "input": "[\"[2,11,10,1,3]\",\"10\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[1,1,2,4,9]\",\"20\"]",
                "output": "[\"4\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minOperations(int[] nums, int k) {",
            "cpp": "class Solution {\npublic:\n    int minOperations(vector<int>& nums, int k) {",
            "go": "func minOperations(nums []int, k int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minOperations = function(nums, k) {",
            "python": "class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:"
        },
        "time": "20240302",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minOperations",
            "java": "minOperations",
            "cpp": "minOperations",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minOperations([2,11,10,1,3], 10) == 2, \"Test 1 Error!\"\nassert my_solution.minOperations([1,1,2,4,9], 20) == 4, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {2,11,10,1,3};\n    int k_1 = 10;\n    int ans_1 = 2;\n    assert solution.minOperations(nums_1, k_1) == ans_1;\n    int[] nums_2 = {1,1,2,4,9};\n    int k_2 = 20;\n    int ans_2 = 4;\n    assert solution.minOperations(nums_2, k_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {2,11,10,1,3};\n    int k_1 = 10;\n    int ans_1 = 2;\n    assert(my_solution_1.minOperations(nums_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,1,2,4,9};\n    int k_2 = 20;\n    int ans_2 = 4;\n    assert(my_solution_2.minOperations(nums_2, k_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "k"
            ],
            "java": [
                "nums",
                "k"
            ],
            "cpp": [
                "nums",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3067": {
        "description": "给你一棵无根带权树，树中总共有 n 个节点，分别表示 n 个服务器，服务器从 0 到 n - 1 编号。同时给你一个数组 edges ，其中 edges[i] = [a_i, b_i, weight_i] 表示节点 a_i 和 b_i 之间有一条双向边，边的权值为 weight_i 。再给你一个整数 signalSpeed。\n如果两台服务器 a 和 b 是通过服务器 c 可连接的，则：\na < b ，a != c 且 b != c 。\n从 c 到 a 的距离是可以被 signalSpeed 整除的。\n从 c 到 b 的距离是可以被 signalSpeed 整除的。\n从 c 到 b 的路径与从 c 到 a 的路径没有任何公共边。\n请你返回一个长度为 n 的整数数组 count ，其中 count[i] 表示通过服务器 i 可连接 的服务器对的 数目 。",
        "difficulty_level": "Middle",
        "note": "2 <= n <= 1000\nedges.length == n - 1\nedges[i].length == 3\n0 <= a_i, b_i < n\nedges[i] = [a_i, b_i, weight_i]\n1 <= weight_i <= 10^6\n1 <= signalSpeed <= 10^6\n输入保证 edges 构成一棵合法的树。",
        "codes": {
            "python": "class Solution:\n    def countPairsOfConnectableServers(self, edges: List[List[int]], signalSpeed: int) -> List[int]:\n        n = len(edges) + 1\n        graph = [[] for _ in range(n)]\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n\n        def dfs(p: int, root: int, curr: int) -> int:\n            res = 0\n            if curr == 0:\n                res += 1\n            for v, cost in graph[p]:\n                if v != root:\n                    res += dfs(v, p, (curr + cost) % signalSpeed)\n            return res\n\n        res = [0] * n\n        for i in range(n):\n            pre = 0\n            for v, cost in graph[i]:\n                cnt = dfs(v, i, cost % signalSpeed)\n                res[i] += pre * cnt\n                pre += cnt\n        return res\n",
            "java": "class Solution {\n    public int[] countPairsOfConnectableServers(int[][] edges, int signalSpeed) {\n        int n = edges.length + 1;\n        List<int[]>[] graph = new ArrayList[n];\n        Arrays.setAll(graph, i -> new ArrayList<>());\n\n        for (int[] e : edges) {\n            int u = e[0];\n            int v = e[1];\n            int w = e[2];\n            graph[u].add(new int[]{v, w});\n            graph[v].add(new int[]{u, w});\n        }\n\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            int pre = 0;\n            for (int[] e : graph[i]) {\n                int cnt = dfs(e[0], i, e[1] % signalSpeed, signalSpeed, graph);\n                res[i] += pre * cnt;\n                pre += cnt;\n            }\n        }\n        return res;\n    }\n\n    private int dfs(int p, int root, int curr, int signalSpeed, List<int[]>[] graph) {\n        int res = 0;\n        if (curr == 0) {\n            res++;\n        }\n        for (int[] e : graph[p]) {\n            int v = e[0];\n            int cost = e[1];\n            if (v != root) {\n                res += dfs(v, p, (curr + cost) % signalSpeed, signalSpeed, graph);\n            }\n        }\n        return res;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    vector<int> countPairsOfConnectableServers(vector<vector<int>>& edges, int signalSpeed) {\n        int n = edges.size() + 1;\n        vector<vector<pair<int, int>>> graph(n);\n        \n        for (auto e : edges) {\n            graph[e[0]].emplace_back(e[1], e[2]);\n            graph[e[1]].emplace_back(e[0], e[2]);\n        }\n        function<int(int, int, int)> dfs = [&](int p, int root, int curr) -> int {\n            int res = 0;\n            if (curr == 0) {\n                res++;\n            }\n            for (auto &[v, cost] : graph[p]) {\n                if (v != root) {\n                    res += dfs(v, p, (curr + cost) % signalSpeed);\n                }\n            }\n            return res;\n        };\n        \n        vector<int> res(n);\n        for (int i = 0; i < n; i++) {\n            int pre = 0;\n            for (auto &[v, cost] : graph[i]) {\n                int cnt = dfs(v, i, cost % signalSpeed);\n                res[i] += pre * cnt;\n                pre += cnt;\n            }\n        }\n        return res;\n    }\n};\n",
            "go": "func countPairsOfConnectableServers(edges [][]int, signalSpeed int) []int {\n    n := len(edges) + 1\n    graph := make([][][]int, n)\n    for _, e := range edges {\n        u, v, w := e[0], e[1], e[2]\n        graph[u] = append(graph[u], []int{v, w})\n        graph[v] = append(graph[v], []int{u, w})\n    }\n\n    var dfs func(int, int, int) int\n    dfs = func(p, root, curr int) int {\n        res := 0\n        if curr == 0 {\n            res++\n        }\n        for _, e := range graph[p] {\n            v, cost := e[0], e[1]\n            if v != root {\n                res += dfs(v, p, (curr + cost) % signalSpeed)\n            }\n        }\n        return res\n    }\n\n    res := make([]int, n)\n    for i := 0; i < n; i++ {\n        pre := 0\n        for _, e := range graph[i] {\n            v, cost := e[0], e[1]\n            cnt := dfs(v, i, cost % signalSpeed)\n            res[i] += pre * cnt\n            pre += cnt\n        }\n    }\n    return res\n}\n",
            "js": "var countPairsOfConnectableServers = function(edges, signalSpeed) {\n    const n = edges.length + 1;\n    const graph = Array.from({ length: n }, () => []);\n    for (const [u, v, w] of edges) {\n        graph[u].push([v, w]);\n        graph[v].push([u, w]);\n    }\n\n    const dfs = (p, root, curr) => {\n        let res = 0;\n        if (curr === 0) {\n            res++;\n        }\n        for (const [v, cost] of graph[p]) {\n            if (v !== root) {\n                res += dfs(v, p, (curr + cost) % signalSpeed);\n            }\n        }\n        return res;\n    };\n\n    const res = Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        let pre = 0;\n        for (const [v, cost] of graph[i]) {\n            const cnt = dfs(v, i, cost % signalSpeed);\n            res[i] += pre * cnt;\n            pre += cnt;\n        }\n    }\n    return res;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]]\",\"1\"]",
                "output": "[\"[0,4,6,6,4,0]\"]"
            },
            {
                "input": "[\"[[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]]\",\"3\"]",
                "output": "[\"[2,0,0,0,0,0,2]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int[] countPairsOfConnectableServers(int[][] edges, int signalSpeed) {",
            "cpp": "class Solution {\npublic:\n    vector<int> countPairsOfConnectableServers(vector<vector<int>>& edges, int signalSpeed) {",
            "go": "func countPairsOfConnectableServers(edges [][]int, signalSpeed int) []int {\n\n}",
            "js": "/**\n * @param {number[][]} edges\n * @param {number} signalSpeed\n * @return {number[]}\n */\nvar countPairsOfConnectableServers = function(edges, signalSpeed) {",
            "python": "class Solution:\n    def countPairsOfConnectableServers(self, edges: List[List[int]], signalSpeed: int) -> List[int]:"
        },
        "time": "20240302",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "countPairsOfConnectableServers",
            "java": "countPairsOfConnectableServers",
            "cpp": "countPairsOfConnectableServers",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.countPairsOfConnectableServers([[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], 1) == [0,4,6,6,4,0], \"Test 1 Error!\"\nassert my_solution.countPairsOfConnectableServers([[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], 3) == [2,0,0,0,0,0,2], \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] edges_1 = {{0,1,1},{1,2,5},{2,3,13},{3,4,9},{4,5,2}};\n    int signalSpeed_1 = 1;\n    int[] ans_1 = {0,4,6,6,4,0};\n    assert Arrays.equals(solution.countPairsOfConnectableServers(edges_1, signalSpeed_1), ans_1);\n    int[][] edges_2 = {{0,6,3},{6,5,3},{0,3,1},{3,2,7},{3,1,6},{3,4,2}};\n    int signalSpeed_2 = 3;\n    int[] ans_2 = {2,0,0,0,0,0,2};\n    assert Arrays.equals(solution.countPairsOfConnectableServers(edges_2, signalSpeed_2), ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> edges_1 = {{0,1,1},{1,2,5},{2,3,13},{3,4,9},{4,5,2}};\n    int signalSpeed_1 = 1;\n    vector<int> ans_1 = {0,4,6,6,4,0};\n    assert(my_solution_1.countPairsOfConnectableServers(edges_1, signalSpeed_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> edges_2 = {{0,6,3},{6,5,3},{0,3,1},{3,2,7},{3,1,6},{3,4,2}};\n    int signalSpeed_2 = 3;\n    vector<int> ans_2 = {2,0,0,0,0,0,2};\n    assert(my_solution_2.countPairsOfConnectableServers(edges_2, signalSpeed_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "edges",
                "signalSpeed"
            ],
            "java": [
                "edges",
                "signalSpeed"
            ],
            "cpp": [
                "edges",
                "signalSpeed"
            ],
            "go": [],
            "js": []
        }
    },
    "3068": {
        "description": "给你一棵 n 个节点的 无向 树，节点从 0 到 n - 1 编号。树以长度为 n - 1 下标从 0 开始的二维整数数组 edges 的形式给你，其中 edges[i] = [u_i, v_i] 表示树中节点 u_i 和 v_i 之间有一条边。同时给你一个 正 整数 k 和一个长度为 n 下标从 0 开始的 非负 整数数组 nums ，其中 nums[i] 表示节点 i 的 价值 。\nAlice 想 最大化 树中所有节点价值之和。为了实现这一目标，Alice 可以执行以下操作 任意 次（包括 0 次）：\n选择连接节点 u 和 v 的边 [u, v] ，并将它们的值更新为：\nnums[u] = nums[u] XOR k\nnums[v] = nums[v] XOR k\n请你返回 Alice 通过执行以上操作 任意次 后，可以得到所有节点 价值之和 的 最大值 。",
        "difficulty_level": "Hard",
        "note": "2 <= n == nums.length <= 2 * 10^4\n1 <= k <= 10^9\n0 <= nums[i] <= 10^9\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\n输入保证 edges 构成一棵合法的树。",
        "codes": {
            "python": "class Solution:\n    def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -> int:\n        g = [[] for _ in nums]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        def dfs(x: int, fa: int) -> (int, int):\n            f0, f1 = 0, -inf  # f[x][0] 和 f[x][1]\n            for y in g[x]:\n                if y != fa:\n                    r0, r1 = dfs(y, x)\n                    f0, f1 = max(f0 + r0, f1 + r1), max(f1 + r0, f0 + r1)\n            return max(f0 + nums[x], f1 + (nums[x] ^ k)), max(f1 + nums[x], f0 + (nums[x] ^ k))\n        return dfs(0, -1)[0]\n",
            "java": "class Solution {\n    public long maximumValueSum(int[] nums, int k, int[][] edges) {\n        int n = nums.length;\n        List<Integer>[] g = new ArrayList[n];\n        Arrays.setAll(g, i -> new ArrayList<>());\n        for (int[] e : edges) {\n            int x = e[0];\n            int y = e[1];\n            g[x].add(y);\n            g[y].add(x);\n        }\n        return dfs(0, -1, g, nums, k)[0];\n    }\n\n    private long[] dfs(int x, int fa, List<Integer>[] g, int[] nums, int k) {\n        long f0 = 0, f1 = Long.MIN_VALUE; // f[x][0] 和 f[x][1]\n        for (int y : g[x]) {\n            if (y != fa) {\n                long[] r = dfs(y, x, g, nums, k);\n                long t = Math.max(f1 + r[0], f0 + r[1]);\n                f0 = Math.max(f0 + r[0], f1 + r[1]);\n                f1 = t;\n            }\n        }\n        return new long[]{Math.max(f0 + nums[x], f1 + (nums[x] ^ k)),\n                          Math.max(f1 + nums[x], f0 + (nums[x] ^ k))};\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long maximumValueSum(vector<int> &nums, int k, vector<vector<int>> &edges) {\n        int n = nums.size();\n        vector<vector<int>> g(n);\n        for (auto &e : edges) {\n            int x = e[0], y = e[1];\n            g[x].push_back(y);\n            g[y].push_back(x);\n        }\n\n        function<pair<long long, long long>(int, int)> dfs = [&](int x, int fa) -> pair<long long, long long> {\n            long long f0 = 0, f1 = LLONG_MIN; // f[x][0] 和 f[x][1]\n            for (auto &y : g[x]) {\n                if (y != fa) {\n                    auto [r0, r1] = dfs(y, x);\n                    long long t = max(f1 + r0, f0 + r1);\n                    f0 = max(f0 + r0, f1 + r1);\n                    f1 = t;\n                }\n            }\n            return {max(f0 + nums[x], f1 + (nums[x] ^ k)), max(f1 + nums[x], f0 + (nums[x] ^ k))};\n        };\n        return dfs(0, -1).first;\n    }\n};\n",
            "go": "func maximumValueSum(nums []int, k int, edges [][]int) int64 {\nn := len(nums)\ng := make([][]int, n)\nfor _, e := range edges {\nx, y := e[0], e[1]\ng[x] = append(g[x], y)\ng[y] = append(g[y], x)\n}\n\nvar dfs func(int, int) (int, int)\ndfs = func(x, fa int) (int, int) {\nf0, f1 := 0, math.MinInt // f[x][0] 和 f[x][1]\nfor _, y := range g[x] {\nif y != fa {\nr0, r1 := dfs(y, x)\nf0, f1 = max(f0+r0, f1+r1), max(f1+r0, f0+r1)\n}\n}\nreturn max(f0+nums[x], f1+(nums[x]^k)), max(f1+nums[x], f0+(nums[x]^k))\n}\nans, _ := dfs(0, -1)\nreturn int64(ans)\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[1,2,1]\",\"3\",\"[[0,1],[0,2]]\"]",
                "output": "[\"6\"]"
            },
            {
                "input": "[\"[2,3]\",\"7\",\"[[0,1]]\"]",
                "output": "[\"9\"]"
            },
            {
                "input": "[\"[7,7,7,7,7,7]\",\"3\",\"[[0,1],[0,2],[0,3],[0,4],[0,5]]\"]",
                "output": "[\"42\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long maximumValueSum(int[] nums, int k, int[][] edges) {",
            "cpp": "class Solution {\npublic:\n    long long maximumValueSum(vector<int>& nums, int k, vector<vector<int>>& edges) {",
            "go": "func maximumValueSum(nums []int, k int, edges [][]int) int64 {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number[][]} edges\n * @return {number}\n */\nvar maximumValueSum = function(nums, k, edges) {",
            "python": "class Solution:\n    def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -> int:"
        },
        "time": "20240302",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maximumValueSum",
            "java": "maximumValueSum",
            "cpp": "maximumValueSum",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maximumValueSum([1,2,1], 3, [[0,1],[0,2]]) == 6, \"Test 1 Error!\"\nassert my_solution.maximumValueSum([2,3], 7, [[0,1]]) == 9, \"Test 2 Error!\"\nassert my_solution.maximumValueSum([7,7,7,7,7,7], 3, [[0,1],[0,2],[0,3],[0,4],[0,5]]) == 42, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,1};\n    int k_1 = 3;\n    int[][] edges_1 = {{0,1},{0,2}};\n    long ans_1 = 6;\n    assert solution.maximumValueSum(nums_1, k_1, edges_1) == ans_1;\n    int[] nums_2 = {2,3};\n    int k_2 = 7;\n    int[][] edges_2 = {{0,1}};\n    long ans_2 = 9;\n    assert solution.maximumValueSum(nums_2, k_2, edges_2) == ans_2;\n    int[] nums_3 = {7,7,7,7,7,7};\n    int k_3 = 3;\n    int[][] edges_3 = {{0,1},{0,2},{0,3},{0,4},{0,5}};\n    long ans_3 = 42;\n    assert solution.maximumValueSum(nums_3, k_3, edges_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,1};\n    int k_1 = 3;\n    vector<vector<int>> edges_1 = {{0,1},{0,2}};\n    long long ans_1 = 6;\n    assert(my_solution_1.maximumValueSum(nums_1, k_1, edges_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {2,3};\n    int k_2 = 7;\n    vector<vector<int>> edges_2 = {{0,1}};\n    long long ans_2 = 9;\n    assert(my_solution_2.maximumValueSum(nums_2, k_2, edges_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {7,7,7,7,7,7};\n    int k_3 = 3;\n    vector<vector<int>> edges_3 = {{0,1},{0,2},{0,3},{0,4},{0,5}};\n    long long ans_3 = 42;\n    assert(my_solution_3.maximumValueSum(nums_3, k_3, edges_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "k",
                "edges"
            ],
            "java": [
                "nums",
                "k",
                "edges"
            ],
            "cpp": [
                "nums",
                "k",
                "edges"
            ],
            "go": [],
            "js": []
        }
    },
    "3079": {
        "description": "给你一个整数数组 nums ，数组中的元素都是 正 整数。定义一个加密函数 encrypt ，encrypt(x) 将一个整数 x 中 每一个 数位都用 x 中的 最大 数位替换。比方说 encrypt(523) = 555 且 encrypt(213) = 333 。\n请你返回数组中所有元素加密后的 和 。",
        "difficulty_level": "Easy",
        "note": "1 <= nums.length <= 50\n1 <= nums[i] <= 1000",
        "codes": {
            "python": "class Solution:\n    def sumOfEncryptedInt(self, nums: List[int]) -> int:\n        ans = 0\n        for x in nums:\n            mx = base = 0\n            while x:\n                x, d = divmod(x, 10)\n                mx = max(mx, d)\n                base = base * 10 + 1\n            ans += mx * base\n        return ans\n",
            "java": "class Solution {\n    public int sumOfEncryptedInt(int[] nums) {\n        int ans = 0;\n        for (int x : nums) {\n            int mx = 0;\n            int base = 0;\n            for (; x > 0; x /= 10) {\n                mx = Math.max(mx, x % 10);\n                base = base * 10 + 1;\n            }\n            ans += mx * base;\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int sumOfEncryptedInt(vector<int> &nums) {\n        int ans = 0;\n        for (int x: nums) {\n            int mx = 0, base = 0;\n            for (; x; x /= 10) {\n                mx = max(mx, x % 10);\n                base = base * 10 + 1;\n            }\n            ans += mx * base;\n        }\n        return ans;\n    }\n};\n",
            "go": "func sumOfEncryptedInt(nums []int) (ans int) {\nfor _, x := range nums {\nmx, base := 0, 0\nfor ; x > 0; x /= 10 {\nmx = max(mx, x%10)\nbase = base*10 + 1\n}\nans += mx * base\n}\nreturn\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumOfEncryptedInt = function(nums) {\n    let ans = 0 \n    for(let x of nums){\n       let b = 0, max = 0 \n       while(x){\n         max = Math.max(max, x % 10)\n         x = x/10 >> 0 \n         b = b*10 + 1\n       } \n       ans += max*b \n    }\n    return ans \n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,2,3]\"]",
                "output": "[\"6\"]"
            },
            {
                "input": "[\"[10,21,31]\"]",
                "output": "[\"66\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int sumOfEncryptedInt(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    int sumOfEncryptedInt(vector<int>& nums) {",
            "go": "func sumOfEncryptedInt(nums []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumOfEncryptedInt = function(nums) {",
            "python": "class Solution:\n    def sumOfEncryptedInt(self, nums: List[int]) -> int:"
        },
        "time": "20240316",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "sumOfEncryptedInt",
            "java": "sumOfEncryptedInt",
            "cpp": "sumOfEncryptedInt",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.sumOfEncryptedInt([1,2,3]) == 6, \"Test 1 Error!\"\nassert my_solution.sumOfEncryptedInt([10,21,31]) == 66, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,3};\n    int ans_1 = 6;\n    assert solution.sumOfEncryptedInt(nums_1) == ans_1;\n    int[] nums_2 = {10,21,31};\n    int ans_2 = 66;\n    assert solution.sumOfEncryptedInt(nums_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,3};\n    int ans_1 = 6;\n    assert(my_solution_1.sumOfEncryptedInt(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {10,21,31};\n    int ans_2 = 66;\n    assert(my_solution_2.sumOfEncryptedInt(nums_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3080": {
        "description": "给你一个长度为 n 下标从 0 开始的正整数数组 nums 。同时给你一个长度为 m 的二维操作数组 queries ，其中 queries[i] = [index_i, k_i] 。\n一开始，数组中的所有元素都 未标记 。你需要依次对数组执行 m 次操作，第 i 次操作中，你需要执行：\n如果下标 index_i 对应的元素还没标记，那么标记这个元素。\n然后标记 k_i 个数组中还没有标记的 最小 元素。如果有元素的值相等，那么优先标记它们中下标较小的。如果少于 k_i 个未标记元素存在，那么将它们全部标记。\n请你返回一个长度为 m 的数组 answer ，其中 answer[i]是第 i 次操作后数组中还没标记元素的 和 。",
        "difficulty_level": "Middle",
        "note": "n == nums.length\nm == queries.length\n1 <= m <= n <= 10^5\n1 <= nums[i] <= 10^5\nqueries[i].length == 2\n0 <= index_i, k_i <= n - 1",
        "codes": {
            "python": "class Solution:\n    def unmarkedSumArray(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        s = sum(nums)\n        ids = sorted(range(n), key=lambda i: nums[i])  # 稳定排序\n        ans = []\n        j = 0\n        for i, k in queries:\n            s -= nums[i]\n            nums[i] = 0  # 标记\n            while j < n and k:\n                i = ids[j]\n                if nums[i]:  # 没有被标记\n                    s -= nums[i]\n                    nums[i] = 0\n                    k -= 1\n                j += 1\n            ans.append(s)\n        return ans\n",
            "java": "class Solution {\n    public long[] unmarkedSumArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        long s = 0;\n        Integer[] ids = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            s += nums[i];\n            ids[i] = i;\n        }\n        Arrays.sort(ids, (i, j) -> nums[i] - nums[j]); // 稳定排序\n\n        long[] ans = new long[queries.length];\n        int j = 0;\n        for (int qi = 0; qi < queries.length; qi++) {\n            int[] q = queries[qi];\n            int i = q[0];\n            int k = q[1];\n            s -= nums[i];\n            nums[i] = 0; // 标记\n            for (; j < n && k > 0; j++) {\n                i = ids[j];\n                if (nums[i] > 0) { // 没有被标记\n                    s -= nums[i];\n                    nums[i] = 0;\n                    k--;\n                }\n            }\n            ans[qi] = s;\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    vector<long long> unmarkedSumArray(vector<int> &nums, vector<vector<int>> &queries) {\n        int n = nums.size();\n        long long s = accumulate(nums.begin(), nums.end(), 0LL);\n        vector<int> ids(n);\n        iota(ids.begin(), ids.end(), 0);\n        ranges::stable_sort(ids, [&](int i, int j) { return nums[i] < nums[j]; });\n\n        vector<long long> ans;\n        int j = 0;\n        for (auto &q : queries) {\n            int i = q[0], k = q[1];\n            s -= nums[i];\n            nums[i] = 0; // 标记\n            for (; j < n && k; j++) {\n                i = ids[j];\n                if (nums[i] > 0) { // 没有被标记\n                    s -= nums[i];\n                    nums[i] = 0;\n                    k--;\n                }\n            }\n            ans.push_back(s);\n        }\n        return ans;\n    }\n};\n",
            "go": "func unmarkedSumArray(nums []int, queries [][]int) []int64 {\ns, n := 0, len(nums)\nids := make([]int, n)\nfor i, x := range nums {\ns += x\nids[i] = i\n}\nslices.SortStableFunc(ids, func(i, j int) int { return nums[i] - nums[j] })\n\nans := make([]int64, len(queries))\nj := 0\nfor qi, p := range queries {\ni, k := p[0], p[1]\ns -= nums[i]\nnums[i] = 0 // 标记\nfor ; j < n && k > 0; j++ {\ni := ids[j]\nif nums[i] > 0 { // 没有被标记\ns -= nums[i]\nnums[i] = 0\nk--\n}\n}\nans[qi] = int64(s)\n}\nreturn ans\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar unmarkedSumArray = function(nums, queries) {\n\n  const n = nums.length;\n  const m = queries.length;\n\n  //1. 建立 v-index 映射\n  const vi = new Array(n).fill().map(() => new Array(2));\n  for (let i = 0; i < n; i++) {\n    vi[i] = [nums[i], i];\n  }\n  //2. 根据排序 （sort稳定排序):\n  //稳定排序： The comparator returns the same result with the same pair of input.\n  vi.sort((a, b) => {\n    // if (a[0] !== b[0]) {\n    //   return a[0] - b[0];\n    // }\n    // return a[1] - b[1];\n      return a[0] - b[0];\n  });\n\n  const ans = new Array(m).fill(0);\n  //先算出总和\n  let sum = nums.reduce((acc, cur) => acc + cur);\n  //Mark 下标的set\n  const mark = new Set();\n  //已经按照优先级排好了序 ,可以按照从左到右的顺序来遍历 vi\n  let viIndex = 0;\n\n  //遍历queries\n  for (let i = 0; i < m; i++) {\n    let [index, k] = queries[i];\n    if (!mark.has(index)) {\n      sum -= nums[index];\n      mark.add(index);\n    }\n    //连续mark k 个值，每次mark 都更新sum, k 和 mark set\n    for (; viIndex < n && k > 0; viIndex++) {\n      const idx = vi[viIndex][1];\n      const val = vi[viIndex][0]; \n      if (!mark.has(idx)) {\n        sum -= val;\n        k--;\n        mark.add(idx);\n      }\n    }\n\n    //mark完， sum更新完之后, 此时sum就是当前queries 的答案.\n    ans[i] = sum;\n  }\n  return ans;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,2,2,1,2,3,1]\",\"[[1,2],[3,3],[4,2]]\"]",
                "output": "[\"[8,3,0]\"]"
            },
            {
                "input": "[\"[1,4,2,3]\",\"[[0,1]]\"]",
                "output": "[\"[7]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long[] unmarkedSumArray(int[] nums, int[][] queries) {",
            "cpp": "class Solution {\npublic:\n    vector<long long> unmarkedSumArray(vector<int>& nums, vector<vector<int>>& queries) {",
            "go": "func unmarkedSumArray(nums []int, queries [][]int) []int64 {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar unmarkedSumArray = function(nums, queries) {",
            "python": "class Solution:\n    def unmarkedSumArray(self, nums: List[int], queries: List[List[int]]) -> List[int]:"
        },
        "time": "20240316",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "unmarkedSumArray",
            "java": "unmarkedSumArray",
            "cpp": "unmarkedSumArray",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.unmarkedSumArray([1,2,2,1,2,3,1], [[1,2],[3,3],[4,2]]) == [8,3,0], \"Test 1 Error!\"\nassert my_solution.unmarkedSumArray([1,4,2,3], [[0,1]]) == [7], \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,2,1,2,3,1};\n    int[][] queries_1 = {{1,2},{3,3},{4,2}};\n    long[] ans_1 = {8,3,0};\n    assert Arrays.equals(solution.unmarkedSumArray(nums_1, queries_1), ans_1);\n    int[] nums_2 = {1,4,2,3};\n    int[][] queries_2 = {{0,1}};\n    long[] ans_2 = {7};\n    assert Arrays.equals(solution.unmarkedSumArray(nums_2, queries_2), ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,2,1,2,3,1};\n    vector<vector<int>> queries_1 = {{1,2},{3,3},{4,2}};\n    vector<long long> ans_1 = {8,3,0};\n    assert(my_solution_1.unmarkedSumArray(nums_1, queries_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,4,2,3};\n    vector<vector<int>> queries_2 = {{0,1}};\n    vector<long long> ans_2 = {7};\n    assert(my_solution_2.unmarkedSumArray(nums_2, queries_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "queries"
            ],
            "java": [
                "nums",
                "queries"
            ],
            "cpp": [
                "nums",
                "queries"
            ],
            "go": [],
            "js": []
        }
    },
    "3081": {
        "description": "给你一个字符串 s 。s[i] 要么是小写英文字母，要么是问号 '?' 。\n对于长度为 m 且 只 含有小写英文字母的字符串 t ，我们定义函数 cost(i) 为下标 i 之前（也就是范围 [0, i - 1] 中）出现过与 t[i] 相同 字符出现的次数。\n字符串 t 的 分数 为所有下标 i 的 cost(i) 之 和 。比方说，字符串 t = \\\"aab\\\" ：\ncost(0) = 0\ncost(1) = 1\ncost(2) = 0\n所以，字符串 \\\"aab\\\" 的分数为 0 + 1 + 0 = 1 。\n你的任务是用小写英文字母 替换 s 中 所有 问号，使 s 的 分数最小 。\n请你返回替换所有问号 '?' 之后且分数最小的字符串。如果有多个字符串的 分数最小 ，那么返回字典序最小的一个。",
        "difficulty_level": "Middle",
        "note": "1 <= s.length <= 10^5\ns[i] 要么是小写英文字母，要么是 '?' 。",
        "codes": {
            "python": "class Solution:\n    def minimizeStringValue(self, s: str) -> str:\n        freq = Counter(s)\n        h = [(freq[c], c) for c in ascii_lowercase]\n        heapify(h)\n\n        t = []\n        for _ in range(s.count('?')):\n            f, c = h[0]\n            t.append(c)\n            heapreplace(h, (f + 1, c))  # 出现次数加一\n        t.sort()  # 排序，因为要求字典序最小\n\n        s = list(s)\n        j = 0\n        for i in range(len(s)):\n            if s[i] == '?':\n                s[i] = t[j]  # 填入字母\n                j += 1\n        return ''.join(s)\n",
            "java": "class Solution {\n    public String minimizeStringValue(String S) {\n        char[] s = S.toCharArray();\n        int[] freq = new int[26];\n        int q = 0;\n        for (char c : s) {\n            if (c != '?') {\n                freq[c - 'a']++;\n            } else {\n                q++;\n            }\n        }\n        PriorityQueue<Pair<Integer, Character>> pq = new PriorityQueue<>(26, (a, b) -> {\n            int c = a.getKey().compareTo(b.getKey());\n            return c != 0 ? c : a.getValue().compareTo(b.getValue());\n        });\n        for (char c = 'a'; c <= 'z'; c++) {\n            pq.add(new Pair<>(freq[c - 'a'], c));\n        }\n\n        char[] t = new char[q];\n        for (int i = 0; i < q; i++) {\n            Pair<Integer, Character> p = pq.poll();\n            char c = p.getValue();\n            t[i] = c;\n            pq.add(new Pair<>(p.getKey() + 1, c)); // 出现次数加一\n        }\n        Arrays.sort(t); // 排序，因为要求字典序最小\n\n        for (int i = 0, j = 0; i < s.length; i++) {\n            if (s[i] == '?') {\n                s[i] = t[j++]; // 填入字母\n            }\n        }\n        return new String(s);\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    string minimizeStringValue(string s) {\n        int freq[26]{};\n        for (char c : s) {\n            if (c != '?') {\n                freq[c - 'a']++;\n            }\n        }\n        priority_queue<pair<int, char>, vector<pair<int, char>>, greater<>> pq;\n        for (int i = 0; i < 26; i++) {\n            pq.emplace(freq[i], 'a' + i);\n        }\n\n        int q = ranges::count(s, '?');\n        string t(q, 0);\n        for (int i = 0; i < q; i++) {\n            auto [f, c] = pq.top();\n            pq.pop();\n            t[i] = c;\n            pq.emplace(f + 1, c); // 出现次数加一\n        }\n        ranges::sort(t); // 排序，因为要求字典序最小\n\n        for (int i = 0, j = 0; i < s.size(); i++) {\n            if (s[i] == '?') {\n                s[i] = t[j++]; // 填入字母\n            }\n        }\n        return s;\n    }\n};\n",
            "go": "func minimizeStringValue(s string) string {\nh := make(hp, 26)\nfor i := byte(0); i < 26; i++ {\nh[i].c = 'a' + i\n}\nfor _, b := range s {\nif b != '?' {\nh[b-'a'].f++\n}\n}\nheap.Init(&h)\n\nt := make([]byte, strings.Count(s, \"?\"))\nfor i := range t {\nt[i] = h[0].c\nh[0].f++ // 出现次数加一\nheap.Fix(&h, 0)\n}\nslices.Sort(t) // 排序，因为要求字典序最小\n\nans := []byte(s)\nj := 0\nfor i, b := range ans {\nif b == '?' {\nans[i] = t[j] // 填入字母\nj++\n}\n}\nreturn string(ans)\n}\n\ntype pair struct {\nf int\nc byte\n}\ntype hp []pair\nfunc (h hp) Len() int           { return len(h) }\nfunc (h hp) Less(i, j int) bool { a, b := h[i], h[j]; return a.f < b.f || a.f == b.f && a.c < b.c }\nfunc (h hp) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\nfunc (hp) Push(any)             {}\nfunc (hp) Pop() (_ any)         { return }\n",
            "js": "/**\n * @param {string} s\n * @return {string}\n */\nvar minimizeStringValue = function(s) {\n\n  //1. 利用最小堆优先级队列 整理好替换'?'的逻辑顺序\n  const minHeap = new MinPriorityQueue({\n    compare: (a, b) => {\n      if (a[0] !== b[0]) {\n        return a[0] - b[0];\n      }\n      return a[1] - b[1];\n    }\n  });\n\n  //2. 设定计数器 \n  // - 记录每个小写字母出现的次数\n  // - 记录 ? 符号在原 s中的下标, 等会儿用作替换 \n  const cnt = new Array(26).fill(0);\n  const questionIdx = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === '?') {\n      questionIdx.push(i);\n    } else {\n      const index = s[i].charCodeAt(0) - 'a'.charCodeAt(0);\n      cnt[index]++;\n    }\n  }\n\n  //3. 把s中小写字母的计数放入优先级队列中 初始化优先级队列\n  for (let i = 0; i < cnt.length; i++) {\n      minHeap.enqueue([cnt[i], i]);\n  }\n\n  //因为Javascript的字符串是immutable的, 所以转成mutable的数组，等会儿按照questionIdx替换？符号\n  const ans = s.split('');\n\n  //先把需要替换的字符准备好, 细节: 等会儿需要先排序后替换\n  const tmp = new Array(questionIdx.length).fill(0);\n\n  //4.1 先准备\n  for (let i = 0; i < tmp.length; i++) {\n    //利用优先级队列的性质来准备需要替换的字符\n    const [dequeueCnt, dequeueIndex] = minHeap.dequeue();\n    tmp[i] = dequeueIndex;\n    minHeap.enqueue([dequeueCnt + 1, dequeueIndex]);\n  }\n  //4.2 再排序\n  tmp.sort((a, b) => a - b);\n  //4.3 后替换\n  for (let i = 0; i < tmp.length; i++) {\n    const idx = questionIdx[i];\n    ans[idx] = String.fromCharCode(tmp[i] + 'a'.charCodeAt(0));\n  }\n  return ans.join('');\n};\n"
        },
        "cases": [
            {
                "input": "[\"\\\"???\\\"\"]",
                "output": "[\"\\\"abc\\\"\"]"
            },
            {
                "input": "[\"\\\"a?a?\\\"\"]",
                "output": "[\"\\\"abac\\\"\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public String minimizeStringValue(String s) {",
            "cpp": "class Solution {\npublic:\n    string minimizeStringValue(string s) {",
            "go": "func minimizeStringValue(s string) string {\n\n}",
            "js": "/**\n * @param {string} s\n * @return {string}\n */\nvar minimizeStringValue = function(s) {",
            "python": "class Solution:\n    def minimizeStringValue(self, s: str) -> str:"
        },
        "time": "20240316",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimizeStringValue",
            "java": "minimizeStringValue",
            "cpp": "minimizeStringValue",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimizeStringValue(\"???\") == \"abc\", \"Test 1 Error!\"\nassert my_solution.minimizeStringValue(\"a?a?\") == \"abac\", \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String s_1 = \"???\";\n    String ans_1 = \"abc\";\n    assert solution.minimizeStringValue(s_1).equals(ans_1);\n    String s_2 = \"a?a?\";\n    String ans_2 = \"abac\";\n    assert solution.minimizeStringValue(s_2).equals(ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string s_1 = \"???\";\n    string ans_1 = \"abc\";\n    assert(my_solution_1.minimizeStringValue(s_1) == ans_1);\n    Solution my_solution_2;\n    string s_2 = \"a?a?\";\n    string ans_2 = \"abac\";\n    assert(my_solution_2.minimizeStringValue(s_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "s"
            ],
            "java": [
                "s"
            ],
            "cpp": [
                "s"
            ],
            "go": [],
            "js": []
        }
    },
    "3082": {
        "description": "给你一个长度为 n 的整数数组 nums 和一个 正 整数 k 。\n一个整数数组的 能量 定义为和 等于 k 的子序列的数目。\n请你返回 nums 中所有子序列的 能量和 。\n由于答案可能很大，请你将它对 10^9 + 7 取余 后返回。",
        "difficulty_level": "Hard",
        "note": "1 <= n <= 100\n1 <= nums[i] <= 10^4\n1 <= k <= 100",
        "codes": {
            "python": "class Solution:\n    def sumOfPower(self, nums: List[int], k: int) -> int:\n        MOD = 1_000_000_007\n        n = len(nums)\n        f = [[0] * (n + 1) for _ in range(k + 1)]\n        f[0][0] = 1\n        for i, x in enumerate(nums):\n            for j in range(k, x - 1, -1):\n                for c in range(i + 1, 0, -1):\n                    f[j][c] = (f[j][c] + f[j - x][c - 1]) % MOD\n\n        ans = 0\n        pow2 = 1\n        for i in range(n, 0, -1):\n            ans = (ans + f[k][i] * pow2) % MOD\n            pow2 = pow2 * 2 % MOD\n        return ans\n",
            "java": "class Solution {\n    public int sumOfPower(int[] nums, int k) {\n        final int MOD = 1_000_000_007;\n        int n = nums.length;\n        int[][] f = new int[k + 1][n + 1];\n        f[0][0] = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = k; j >= nums[i]; j--) {\n                for (int c = i + 1; c > 0; c--) {\n                    f[j][c] = (f[j][c] + f[j - nums[i]][c - 1]) % MOD;\n                }\n            }\n        }\n\n        long ans = 0;\n        int pow2 = 1;\n        for (int i = n; i > 0; i--) {\n            ans = (ans + (long) f[k][i] * pow2) % MOD;\n            pow2 = pow2 * 2 % MOD;\n        }\n        return (int) ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int sumOfPower(vector<int> &nums, int k) {\n        const int MOD = 1'000'000'007;\n        int n = nums.size();\n        vector<vector<int>> f(k + 1, vector<int>(n + 1));\n        f[0][0] = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = k; j >= nums[i]; j--) {\n                for (int c = i + 1; c > 0; c--) {\n                    f[j][c] = (f[j][c] + f[j - nums[i]][c - 1]) % MOD;\n                }\n            }\n        }\n\n        int ans = 0;\n        int pow2 = 1;\n        for (int i = n; i > 0; i--) {\n            ans = (ans + (long long) f[k][i] * pow2) % MOD;\n            pow2 = pow2 * 2 % MOD;\n        }\n        return ans;\n    }\n};\n",
            "go": "func sumOfPower(nums []int, k int) (ans int) {\nconst mod = 1_000_000_007\nn := len(nums)\nf := make([][]int, k+1)\nfor i := range f {\nf[i] = make([]int, n+1)\n}\nf[0][0] = 1\nfor i, x := range nums {\nfor j := k; j >= x; j-- {\nfor c := i + 1; c > 0; c-- {\nf[j][c] = (f[j][c] + f[j-x][c-1]) % mod\n}\n}\n}\npow2 := 1\nfor i := n; i > 0; i-- {\nans = (ans + f[k][i]*pow2) % mod\npow2 = pow2 * 2 % mod\n}\nreturn\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[1,2,3]\",\"3\"]",
                "output": "[\"6\"]"
            },
            {
                "input": "[\"[2,3,3]\",\"5\"]",
                "output": "[\"4\"]"
            },
            {
                "input": "[\"[1,2,3]\",\"7\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int sumOfPower(int[] nums, int k) {",
            "cpp": "class Solution {\npublic:\n    int sumOfPower(vector<int>& nums, int k) {",
            "go": "func sumOfPower(nums []int, k int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar sumOfPower = function(nums, k) {",
            "python": "class Solution:\n    def sumOfPower(self, nums: List[int], k: int) -> int:"
        },
        "time": "20240316",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "sumOfPower",
            "java": "sumOfPower",
            "cpp": "sumOfPower",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.sumOfPower([1,2,3], 3) == 6, \"Test 1 Error!\"\nassert my_solution.sumOfPower([2,3,3], 5) == 4, \"Test 2 Error!\"\nassert my_solution.sumOfPower([1,2,3], 7) == 0, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,3};\n    int k_1 = 3;\n    int ans_1 = 6;\n    assert solution.sumOfPower(nums_1, k_1) == ans_1;\n    int[] nums_2 = {2,3,3};\n    int k_2 = 5;\n    int ans_2 = 4;\n    assert solution.sumOfPower(nums_2, k_2) == ans_2;\n    int[] nums_3 = {1,2,3};\n    int k_3 = 7;\n    int ans_3 = 0;\n    assert solution.sumOfPower(nums_3, k_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,3};\n    int k_1 = 3;\n    int ans_1 = 6;\n    assert(my_solution_1.sumOfPower(nums_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {2,3,3};\n    int k_2 = 5;\n    int ans_2 = 4;\n    assert(my_solution_2.sumOfPower(nums_2, k_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {1,2,3};\n    int k_3 = 7;\n    int ans_3 = 0;\n    assert(my_solution_3.sumOfPower(nums_3, k_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "k"
            ],
            "java": [
                "nums",
                "k"
            ],
            "cpp": [
                "nums",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3095": {
        "description": "给你一个 非负 整数数组 nums 和一个整数 k 。\n如果一个数组中所有元素的按位或运算 OR 的值 至少 为 k ，那么我们称这个数组是 特别的 。\n请你返回 nums 中 最短特别非空 子数组的长度，如果特别子数组不存在，那么返回 -1 。",
        "difficulty_level": "Easy",
        "note": "1 <= nums.length <= 50\n0 <= nums[i] <= 50\n0 <= k < 64",
        "codes": {
            "python": "class Solution:\n    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n        ans = inf\n        d = dict()  # key 是右端点为 i 的子数组 OR, value 是该子数组左端点的最大值\n        for i, x in enumerate(nums):\n            # 注意 key 是按照插入顺序排的，所以在相同 OR 时，会自动取到更大的 left 作为 value\n            d = {or_ | x: left for or_, left in d.items()}\n            d[x] = i  # 只包含 x 的子数组\n            for or_, left in d.items():\n                if or_ >= k:\n                    ans = min(ans, i - left + 1)\n        return ans if ans < inf else -1\n",
            "java": "class Solution {\n    public int minimumSubarrayLength(int[] nums, int k) {\n        int ans = Integer.MAX_VALUE;\n        List<int[]> ors = new ArrayList<>(); // 保存 (右端点为 i 的子数组 OR, 该子数组左端点的最大值)\n        for (int i = 0; i < nums.length; i++) {\n            ors.add(new int[]{0, i});\n            int j = 0;\n            for (int[] or : ors) {\n                or[0] |= nums[i];\n                if (or[0] >= k) {\n                    ans = Math.min(ans, i - or[1] + 1);\n                }\n                if (ors.get(j)[0] == or[0]) {\n                    ors.get(j)[1] = or[1]; // 原地去重：合并相同值，左端点取靠右的\n                } else {\n                    ors.set(++j, or);\n                }\n            }\n            ors.subList(j + 1, ors.size()).clear(); // 去重：移除多余元素\n        }\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumSubarrayLength(vector<int> &nums, int k) {\n        int ans = INT_MAX;\n        vector<pair<int, int>> ors; // 保存 (右端点为 i 的子数组 OR, 该子数组左端点的最大值)\n        for (int i = 0; i < nums.size(); i++) {\n            ors.emplace_back(0, i);\n            int j = 0;\n            for (auto &p : ors) {\n                auto &[or_, left] = p;\n                or_ |= nums[i];\n                if (or_ >= k) {\n                    ans = min(ans, i - left + 1);\n                }\n                if (ors[j].first == or_) {\n                    ors[j].second = left; // 原地去重：合并相同值，左端点取靠右的\n                } else {\n                    ors[++j] = p;\n                }\n            }\n            ors.resize(j + 1); // 去重：移除多余元素\n        }\n        return ans == INT_MAX ? -1 : ans;\n    }\n};\n",
            "go": "func minimumSubarrayLength(nums []int, k int) int {\nans := math.MaxInt\ntype pair struct{ or, left int }\nors := []pair{} // 保存 (右端点为 i 的子数组 OR, 该子数组左端点的最大值)\nfor i, x := range nums {\nors = append(ors, pair{0, i})\nj := 0\nfor idx := range ors {\np := &ors[idx]\np.or |= x\nif p.or >= k {\nans = min(ans, i-p.left+1)\n}\nif ors[j].or == p.or {\nors[j].left = p.left // 原地去重：合并相同值，左端点取靠右的\n} else {\nj++\nors[j] = *p\n}\n}\nors = ors[:j+1] // 去重：移除多余元素\n}\nif ans == math.MaxInt {\nreturn -1\n}\nreturn ans\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minimumSubarrayLength = function(nums, k) {\n    let ans = 100;\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j <= nums.length; j++) {\n            let temp = nums.slice(i, j);\n            let res = temp.reduce((a, b) => a | b);\n            if (res >= k) ans = Math.min(ans, j - i);\n        }\n    }\n    return ans === 100 ? -1 : ans;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,2,3]\",\"2\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"[2,1,8]\",\"10\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[1,2]\",\"0\"]",
                "output": "[\"1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumSubarrayLength(int[] nums, int k) {",
            "cpp": "class Solution {\npublic:\n    int minimumSubarrayLength(vector<int>& nums, int k) {",
            "go": "func minimumSubarrayLength(nums []int, k int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minimumSubarrayLength = function(nums, k) {",
            "python": "class Solution:\n    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:"
        },
        "time": "20240330",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumSubarrayLength",
            "java": "minimumSubarrayLength",
            "cpp": "minimumSubarrayLength",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumSubarrayLength([1,2,3], 2) == 1, \"Test 1 Error!\"\nassert my_solution.minimumSubarrayLength([2,1,8], 10) == 3, \"Test 2 Error!\"\nassert my_solution.minimumSubarrayLength([1,2], 0) == 1, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,3};\n    int k_1 = 2;\n    int ans_1 = 1;\n    assert solution.minimumSubarrayLength(nums_1, k_1) == ans_1;\n    int[] nums_2 = {2,1,8};\n    int k_2 = 10;\n    int ans_2 = 3;\n    assert solution.minimumSubarrayLength(nums_2, k_2) == ans_2;\n    int[] nums_3 = {1,2};\n    int k_3 = 0;\n    int ans_3 = 1;\n    assert solution.minimumSubarrayLength(nums_3, k_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,3};\n    int k_1 = 2;\n    int ans_1 = 1;\n    assert(my_solution_1.minimumSubarrayLength(nums_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {2,1,8};\n    int k_2 = 10;\n    int ans_2 = 3;\n    assert(my_solution_2.minimumSubarrayLength(nums_2, k_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {1,2};\n    int k_3 = 0;\n    int ans_3 = 1;\n    assert(my_solution_3.minimumSubarrayLength(nums_3, k_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "k"
            ],
            "java": [
                "nums",
                "k"
            ],
            "cpp": [
                "nums",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3096": {
        "description": "给你一个长度为 n 的二进制数组 possible 。\nAlice 和 Bob 正在玩一个有 n 个关卡的游戏，游戏中有一些关卡是 困难 模式，其他的关卡是 简单 模式。如果 possible[i] == 0 ，那么第 i 个关卡是 困难 模式。一个玩家通过一个简单模式的关卡可以获得 1 分，通过困难模式的关卡将失去 1 分。\n游戏的一开始，Alice 将从第 0 级开始 按顺序 完成一些关卡，然后 Bob 会完成剩下的所有关卡。\n假设两名玩家都采取最优策略，目的是 最大化 自己的得分，Alice 想知道自己 最少 需要完成多少个关卡，才能获得比 Bob 更多的分数。\n请你返回 Alice 获得比 Bob 更多的分数所需要完成的 最少 关卡数目，如果 无法 达成，那么返回 -1 。\n注意，每个玩家都至少需要完成 1 个关卡。",
        "difficulty_level": "Middle",
        "note": "2 <= n == possible.length <= 10^5\npossible[i] 要么是 0 要么是 1 。",
        "codes": {
            "python": "class Solution:\n    def minimumLevels(self, possible: List[int]) -> int:\n        # cnt1 - cnt0 = cnt1 - (n - cnt1) = cnt1 * 2 - n\n        s = sum(possible) * 2 - len(possible)\n        pre = 0\n        for i, x in enumerate(possible[:-1]):\n            pre += 2 if x else -2\n            if pre > s:\n                return i + 1\n        return -1\n",
            "java": "class Solution {\n    public int minimumLevels(int[] possible) {\n        // cnt1 - cnt0 = cnt1 - (n - cnt1) = cnt1 * 2 - n\n        int n = possible.length;\n        int s = 0;\n        for (int x : possible) {\n            s += x;\n        }\n        s = s * 2 - n;\n        int pre = 0;\n        for (int i = 0; i < n - 1; i++) {\n            pre += possible[i] == 1 ? 2 : -2;\n            if (pre > s) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumLevels(vector<int> &possible) {\n        // cnt1 - cnt0 = cnt1 - (n - cnt1) = cnt1 * 2 - n\n        int n = possible.size();\n        int s = accumulate(possible.begin(), possible.end(), 0) * 2 - n;\n        int pre = 0;\n        for (int i = 0; i < n - 1; i++) {\n            pre += possible[i] ? 2 : -2;\n            if (pre > s) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n};\n",
            "go": "func minimumLevels(possible []int) int {\n// cnt1 - cnt0 = cnt1 - (n - cnt1) = cnt1 * 2 - n\nn := len(possible)\ns := 0\nfor _, x := range possible {\ns += x\n}\ns = s*2 - n\npre := 0\nfor i, x := range possible[:n-1] {\npre += x*4 - 2\nif pre > s {\nreturn i + 1\n}\n}\nreturn -1\n}\n",
            "js": "var minimumLevels = function(possible) {\n    let sum = 0;\n    let n = possible.length;\n    for (let i = 0; i < n; i++) {\n        if (possible[i] === 1) {\n            sum++;\n        } else {\n            sum--;\n        }\n    }\n    let left = 0;\n    for (let i = 0; i < n - 1; i++) {\n        if (possible[i] === 1) {\n            left++;\n        } else {\n            left--;\n        }\n        if (left * 2 > sum) {\n            return i + 1;\n        }\n    }\n    return -1;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,0,1,0]\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"[1,1,1,1,1]\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[0,0]\"]",
                "output": "[\"-1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumLevels(int[] possible) {",
            "cpp": "class Solution {\npublic:\n    int minimumLevels(vector<int>& possible) {",
            "go": "func minimumLevels(possible []int) int {\n\n}",
            "js": "/**\n * @param {number[]} possible\n * @return {number}\n */\nvar minimumLevels = function(possible) {",
            "python": "class Solution:\n    def minimumLevels(self, possible: List[int]) -> int:"
        },
        "time": "20240330",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumLevels",
            "java": "minimumLevels",
            "cpp": "minimumLevels",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumLevels([1,0,1,0]) == 1, \"Test 1 Error!\"\nassert my_solution.minimumLevels([1,1,1,1,1]) == 3, \"Test 2 Error!\"\nassert my_solution.minimumLevels([0,0]) == -1, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] possible_1 = {1,0,1,0};\n    int ans_1 = 1;\n    assert solution.minimumLevels(possible_1) == ans_1;\n    int[] possible_2 = {1,1,1,1,1};\n    int ans_2 = 3;\n    assert solution.minimumLevels(possible_2) == ans_2;\n    int[] possible_3 = {0,0};\n    int ans_3 = -1;\n    assert solution.minimumLevels(possible_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> possible_1 = {1,0,1,0};\n    int ans_1 = 1;\n    assert(my_solution_1.minimumLevels(possible_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> possible_2 = {1,1,1,1,1};\n    int ans_2 = 3;\n    assert(my_solution_2.minimumLevels(possible_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> possible_3 = {0,0};\n    int ans_3 = -1;\n    assert(my_solution_3.minimumLevels(possible_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "possible"
            ],
            "java": [
                "possible"
            ],
            "cpp": [
                "possible"
            ],
            "go": [],
            "js": []
        }
    },
    "3097": {
        "description": "给你一个 非负 整数数组 nums 和一个整数 k 。\n如果一个数组中所有元素的按位或运算 OR 的值 至少 为 k ，那么我们称这个数组是 特别的 。\n请你返回 nums 中 最短特别非空 子数组的长度，如果特别子数组不存在，那么返回 -1 。",
        "difficulty_level": "Middle",
        "note": "1 <= nums.length <= 2 * 10^5\n0 <= nums[i] <= 10^9\n0 <= k <= 10^9",
        "codes": {
            "python": "class Solution:\n    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n        ans = inf\n        ors = []  # 保存 (右端点为 i 的子数组 OR, 该子数组左端点的最大值)\n        for i, x in enumerate(nums):\n            ors.append([0, i])\n            j = 0\n            for p in ors:\n                p[0] |= x\n                if p[0] >= k:\n                    ans = min(ans, i - p[1] + 1)\n                if ors[j][0] == p[0]:\n                    ors[j][1] = p[1]  # 原地去重：合并相同值，左端点取靠右的\n                else:\n                    j += 1\n                    ors[j] = p\n            del ors[j + 1:]  # 去重：移除多余元素\n        return ans if ans < inf else -1\n",
            "java": "class Solution {\n    public int minimumSubarrayLength(int[] nums, int k) {\n        int ans = Integer.MAX_VALUE;\n        int[][] ors = new int[32][2]; // 保存 (右端点为 i 的子数组 OR, 该子数组左端点的最大值)\n        int m = 0;\n        for (int i = 0; i < nums.length; i++) {\n            ors[m][0] = 0;\n            ors[m++][1] = i;\n            int j = 0;\n            for (int idx = 0; idx < m; idx++) {\n                ors[idx][0] |= nums[i];\n                if (ors[idx][0] >= k) {\n                    ans = Math.min(ans, i - ors[idx][1] + 1);\n                }\n                if (ors[j][0] != ors[idx][0]) {\n                    ors[++j][0] = ors[idx][0];\n                }\n                ors[j][1] = ors[idx][1];\n            }\n            m = j + 1; // 去重：移除多余元素\n        }\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumSubarrayLength(vector<int> &nums, int k) {\n        int ans = INT_MAX;\n        vector<pair<int, int>> ors; // 保存 (右端点为 i 的子数组 OR, 该子数组左端点的最大值)\n        for (int i = 0; i < nums.size(); i++) {\n            ors.emplace_back(0, i);\n            int j = 0;\n            for (auto &p : ors) {\n                auto &[or_, left] = p;\n                or_ |= nums[i];\n                if (or_ >= k) {\n                    ans = min(ans, i - left + 1);\n                }\n                if (ors[j].first == or_) {\n                    ors[j].second = left; // 原地去重：合并相同值，左端点取靠右的\n                } else {\n                    ors[++j] = p;\n                }\n            }\n            ors.resize(j + 1); // 去重：移除多余元素\n        }\n        return ans == INT_MAX ? -1 : ans;\n    }\n};\n",
            "go": "func minimumSubarrayLength(nums []int, k int) int {\nans := math.MaxInt\ntype pair struct{ or, left int }\nors := []pair{} // 保存 (右端点为 i 的子数组 OR, 该子数组左端点的最大值)\nfor i, x := range nums {\nors = append(ors, pair{0, i})\nors[0].or |= x\nj := 0\nfor _, p := range ors[1:] {\np.or |= x\nif ors[j].or == p.or {\nors[j].left = p.left // 原地去重：合并相同值，左端点取靠右的\n} else {\nj++\nors[j] = p\n}\n}\nors = ors[:j+1] // 去重：移除多余元素\nfor len(ors) > 0 && ors[0].or >= k {\nans = min(ans, i-ors[0].left+1)\nors = ors[1:]\n}\n}\nif ans == math.MaxInt {\nreturn -1\n}\nreturn ans\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[1,2,3]\",\"2\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"[2,1,8]\",\"10\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[1,2]\",\"0\"]",
                "output": "[\"1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumSubarrayLength(int[] nums, int k) {",
            "cpp": "class Solution {\npublic:\n    int minimumSubarrayLength(vector<int>& nums, int k) {",
            "go": "func minimumSubarrayLength(nums []int, k int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minimumSubarrayLength = function(nums, k) {",
            "python": "class Solution:\n    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:"
        },
        "time": "20240330",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumSubarrayLength",
            "java": "minimumSubarrayLength",
            "cpp": "minimumSubarrayLength",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumSubarrayLength([1,2,3], 2) == 1, \"Test 1 Error!\"\nassert my_solution.minimumSubarrayLength([2,1,8], 10) == 3, \"Test 2 Error!\"\nassert my_solution.minimumSubarrayLength([1,2], 0) == 1, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,3};\n    int k_1 = 2;\n    int ans_1 = 1;\n    assert solution.minimumSubarrayLength(nums_1, k_1) == ans_1;\n    int[] nums_2 = {2,1,8};\n    int k_2 = 10;\n    int ans_2 = 3;\n    assert solution.minimumSubarrayLength(nums_2, k_2) == ans_2;\n    int[] nums_3 = {1,2};\n    int k_3 = 0;\n    int ans_3 = 1;\n    assert solution.minimumSubarrayLength(nums_3, k_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,3};\n    int k_1 = 2;\n    int ans_1 = 1;\n    assert(my_solution_1.minimumSubarrayLength(nums_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {2,1,8};\n    int k_2 = 10;\n    int ans_2 = 3;\n    assert(my_solution_2.minimumSubarrayLength(nums_2, k_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {1,2};\n    int k_3 = 0;\n    int ans_3 = 1;\n    assert(my_solution_3.minimumSubarrayLength(nums_3, k_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "k"
            ],
            "java": [
                "nums",
                "k"
            ],
            "cpp": [
                "nums",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3098": {
        "description": "给你一个长度为 n 的整数数组 nums 和一个 正 整数 k 。\n一个子序列的 能量 定义为子序列中 任意 两个元素的差值绝对值的 最小值 。\n请你返回 nums 中长度 等于 k 的 所有 子序列的 能量和 。\n由于答案可能会很大，将答案对 10^9 + 7 取余 后返回。",
        "difficulty_level": "Hard",
        "note": "2 <= n == nums.length <= 50\n-10^8 <= nums[i] <= 10^8\n2 <= k <= n",
        "codes": {
            "python": "class Solution:\n    def sumOfPowers(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n        mod = 10 ** 9 + 7\n        \n        def f(nums, lower_diff):\n            n = len(nums)\n            dp = [[0] * k for _ in range(n)]\n            dp_acc = [[0] * k for _ in range(n + 1)]\n            pt = 0\n            dp[0][1] = 1\n            dp_acc[1][1] = 1\n            for i in range(1, n):\n                while pt < i and nums[i] - nums[pt] >= lower_diff:\n                    pt += 1\n                \n                for v in range(k - 1):\n                    dp[i][v+1] += dp_acc[pt][v]\n                    dp[i][v+1] %= mod\n                \n                for v in range(k):\n                    dp_acc[i+1][v] = dp_acc[i][v] + dp[i][v]\n                    dp_acc[i+1][v] %= mod\n\n            return dp_acc[-1]\n        \n        ans = 0\n        for i in range(n):\n            for j in range(i):\n                v = nums[i] - nums[j]\n                vs = [nums[j] - nums[idx] for idx in range(j, -1, -1)]\n                dp1 = f(vs, v + 1)\n                vs = [nums[idx] - nums[i] for idx in range(i, n)]\n                dp2 = f(vs, v)\n                for x in range(1, k):\n                    ans += dp1[x] * dp2[k - x] * v\n                    ans %= mod\n        return ans\n",
            "java": "class Solution {\n    int MOD = (int) 1e9 + 7;\n    Map<String , Long> memo;\n    public int sumOfPowers(int[] nums, int k) {\n        memo = new HashMap<>();\n        Arrays.sort(nums);\n        //递归入口 ， pre 和 min 取Integer.MAX_VALUE / 2 ，防止计算负数时溢出\n        return (int) dfs(nums.length - 1 , k , Integer.MAX_VALUE / 2 , Integer.MAX_VALUE / 2 , nums);\n    }\n    long dfs(int i , int rest , int pre , int min , int[] nums){\n        //当前剩余i + 1 个数字， 剩余数字小于还要选择的数字， 怎么选都不能够选出k个数 ， 返回0\n        if (i + 1 < rest){\n            return 0;\n        }\n        //选够了\n        if (rest == 0){\n            return min;\n        }\n        //把当前状态 映射为字符串\n        String key = i + \"#\" + rest + \"#\" + pre + \"#\" + min;\n        //如果之前计算过\n        if (memo.containsKey(key)){\n            return memo.get(key);\n        }\n        //不选 当前元素\n        long res1 = dfs(i - 1, rest , pre , min , nums);\n        //选 当前元素\n        long res2 = dfs(i - 1 , rest - 1 , nums[i] , Math.min(min , pre - nums[i]) , nums);\n        memo.put(key , (res1 + res2) % MOD);\n        return (res1 + res2) % MOD;\n    }\n}\n",
            "cpp": "using ll = long long;\nconstexpr int N = 51;\nconstexpr ll mod = int(1e9) + 7;\n\nclass Solution {\npublic:\n    int sumOfPowers(vector<int>& nums, int k) {\n        // dp[i][j][d] := The counter for the first `i` elements\n        // with diff `d` when the length of subsequence is `j`.\n        std::unordered_map<int, ll> dp[N][N];\n\n        int n = nums.size();\n        // Sort for minimum diff calculation.\n        std::sort(nums.begin(), nums.end());\n\n        for (int i = 0; i < n; ++ i) {\n            // Initialization (here, `mod` is equal to inf)\n            dp[i][1][mod] = 1;\n            for (int j = 2; j <= k; ++ j) {\n                for (int lst_i = 0; lst_i < i; ++ lst_i) {\n                    for (auto& [diff, cnt]: dp[lst_i][j - 1]) {\n                        auto nxt_diff = std::min(diff, nums[i] - nums[lst_i]);\n                        dp[i][j][nxt_diff] += cnt;\n                        dp[i][j][nxt_diff] %= mod;\n                    }\n                }\n            }\n        }\n\n        ll ans = 0;\n        for (int i = 0; i < n; ++ i) {\n            for (auto& [diff, cnt]: dp[i][k]) {\n                ans = (ans + diff * cnt) % mod;\n            }\n        }\n\n        return ans;\n    }\n};\n",
            "go": "",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar sumOfPowers = function(nums, k) {\n    nums.sort((a,b) => a - b);\n    let mod = 10 ** 9 + 7;\n    let dp = new Array(nums.length).fill([]).map(_ => new Array(k + 1).fill(0).map(_ => new Map()));\n    for(let a = 0;a < nums.length;a++){\n        for(let b = a - 1;b >= 0;b--){\n            for(let c = 1;c < k;c++){\n                for(let [min,count] of dp[b][c]){\n                    let m = Math.min(min,nums[a] - nums[b]);\n                    dp[a][c + 1].set(m,((dp[a][c + 1].get(m) | 0) + count) % mod);\n                }\n            }\n        }\n        dp[a][1].set(Infinity,1);\n    }\n    let ans = 0;\n    for(let a = 0;a < nums.length;a++){\n        for(let [min,count] of dp[a][k]){\n            ans = (ans + min * count) % mod;\n        }\n    }\n    return ans;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,2,3,4]\",\"3\"]",
                "output": "[\"4\"]"
            },
            {
                "input": "[\"[2,2]\",\"2\"]",
                "output": "[\"0\"]"
            },
            {
                "input": "[\"[4,3,-1]\",\"2\"]",
                "output": "[\"10\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int sumOfPowers(int[] nums, int k) {",
            "cpp": "class Solution {\npublic:\n    int sumOfPowers(vector<int>& nums, int k) {",
            "go": "func sumOfPowers(nums []int, k int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar sumOfPowers = function(nums, k) {",
            "python": "class Solution:\n    def sumOfPowers(self, nums: List[int], k: int) -> int:"
        },
        "time": "20240330",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "sumOfPowers",
            "java": "sumOfPowers",
            "cpp": "sumOfPowers",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.sumOfPowers([1,2,3,4], 3) == 4, \"Test 1 Error!\"\nassert my_solution.sumOfPowers([2,2], 2) == 0, \"Test 2 Error!\"\nassert my_solution.sumOfPowers([4,3,-1], 2) == 10, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,3,4};\n    int k_1 = 3;\n    int ans_1 = 4;\n    assert solution.sumOfPowers(nums_1, k_1) == ans_1;\n    int[] nums_2 = {2,2};\n    int k_2 = 2;\n    int ans_2 = 0;\n    assert solution.sumOfPowers(nums_2, k_2) == ans_2;\n    int[] nums_3 = {4,3,-1};\n    int k_3 = 2;\n    int ans_3 = 10;\n    assert solution.sumOfPowers(nums_3, k_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,3,4};\n    int k_1 = 3;\n    int ans_1 = 4;\n    assert(my_solution_1.sumOfPowers(nums_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {2,2};\n    int k_2 = 2;\n    int ans_2 = 0;\n    assert(my_solution_2.sumOfPowers(nums_2, k_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {4,3,-1};\n    int k_3 = 2;\n    int ans_3 = 10;\n    assert(my_solution_3.sumOfPowers(nums_3, k_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "k"
            ],
            "java": [
                "nums",
                "k"
            ],
            "cpp": [
                "nums",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3110": {
        "description": "给你一个字符串 s 。一个字符串的 分数 定义为相邻字符 ASCII 码差值绝对值的和。请你返回 s 的 分数 。",
        "difficulty_level": "Easy",
        "note": "2 <= s.length <= 100\ns 只包含小写英文字母。",
        "codes": {
            "python": "class Solution:\n    def scoreOfString(self, s: str) -> int:\n        return sum(abs(x - y) for x, y in pairwise(map(ord, s)))\n",
            "java": "class Solution {\n    public int scoreOfString(String S) {\n        char[] s = S.toCharArray();\n        int ans = 0;\n        for (int i = 1; i < s.length; i++) {\n            ans += Math.abs(s[i] - s[i - 1]);\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int scoreOfString(string s) {\n        int ans = 0;\n        for (int i = 1; i < s.length(); i++) {\n            ans += abs(s[i] - s[i - 1]);\n        }\n        return ans;\n    }\n};\n",
            "go": "func scoreOfString(s string) (ans int) {\nfor i := 1; i < len(s); i++ {\nans += abs(int(s[i-1]) - int(s[i]))\n}\nreturn\n}\n\nfunc abs(x int) int { if x < 0 { return -x }; return x }\n",
            "js": "/**\n * @param {string} s\n * @return {number}\n */\nvar scoreOfString = function(s) {\n    let pre = s.charCodeAt(0), ans = 0 \n    for(let i = 1; i < s.length; i++){\n       ans += Math.abs(s.charCodeAt(i) - pre)\n       pre = s.charCodeAt(i)\n    } \n    return ans \n};\n"
        },
        "cases": [
            {
                "input": "[\"\\\"hello\\\"\"]",
                "output": "[\"13\"]"
            },
            {
                "input": "[\"\\\"zaz\\\"\"]",
                "output": "[\"50\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int scoreOfString(String s) {",
            "cpp": "class Solution {\npublic:\n    int scoreOfString(string s) {",
            "go": "func scoreOfString(s string) int {\n\n}",
            "js": "/**\n * @param {string} s\n * @return {number}\n */\nvar scoreOfString = function(s) {",
            "python": "class Solution:\n    def scoreOfString(self, s: str) -> int:"
        },
        "time": "20240413",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "scoreOfString",
            "java": "scoreOfString",
            "cpp": "scoreOfString",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.scoreOfString(\"hello\") == 13, \"Test 1 Error!\"\nassert my_solution.scoreOfString(\"zaz\") == 50, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String s_1 = \"hello\";\n    int ans_1 = 13;\n    assert solution.scoreOfString(s_1) == ans_1;\n    String s_2 = \"zaz\";\n    int ans_2 = 50;\n    assert solution.scoreOfString(s_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string s_1 = \"hello\";\n    int ans_1 = 13;\n    assert(my_solution_1.scoreOfString(s_1) == ans_1);\n    Solution my_solution_2;\n    string s_2 = \"zaz\";\n    int ans_2 = 50;\n    assert(my_solution_2.scoreOfString(s_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "s"
            ],
            "java": [
                "s"
            ],
            "cpp": [
                "s"
            ],
            "go": [],
            "js": []
        }
    },
    "3111": {
        "description": "给你一个二维整数数组 point ，其中 points[i] = [x_i, y_i] 表示二维平面内的一个点。同时给你一个整数 w 。你需要用矩形 覆盖所有 点。\n每个矩形的左下角在某个点 (x_1, 0) 处，且右上角在某个点 (x_2, y_2) 处，其中 x_1 <= x_2 且 y_2 >= 0 ，同时对于每个矩形都 必须 满足 x_2 - x_1 <= w 。\n如果一个点在矩形内或者在边上，我们说这个点被矩形覆盖了。\n请你在确保每个点都 至少 被一个矩形覆盖的前提下，最少 需要多少个矩形。\n注意：一个点可以被多个矩形覆盖。",
        "difficulty_level": "Middle",
        "note": "1 <= points.length <= 10^5\npoints[i].length == 2\n0 <= x_i == points[i][0] <= 10^9\n0 <= y_i == points[i][1] <= 10^9\n0 <= w <= 10^9\n所有点坐标 (x_i, y_i) 互不相同。",
        "codes": {
            "python": "class Solution:\n    def minRectanglesToCoverPoints(self, points: List[List[int]], w: int) -> int:\n        points.sort(key=lambda p: p[0])\n        ans = 0\n        x2 = -1\n        for x, _ in points:\n            if x > x2:\n                ans += 1\n                x2 = x + w\n        return ans\n",
            "java": "class Solution {\n    public int minRectanglesToCoverPoints(int[][] points, int w) {\n        Arrays.sort(points, (p, q) -> p[0] - q[0]);\n        int ans = 0;\n        int x2 = -1;\n        for (int[] p : points) {\n            if (p[0] > x2) {\n                ans++;\n                x2 = p[0] + w;\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minRectanglesToCoverPoints(vector<vector<int>>& points, int w) {\n        ranges::sort(points, [](const auto& p, const auto& q) {\n            return p[0] < q[0];\n        });\n        int ans = 0;\n        int x2 = -1;\n        for (auto& p : points) {\n            if (p[0] > x2) {\n                ans++;\n                x2 = p[0] + w;\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func minRectanglesToCoverPoints(points [][]int, w int) (ans int) {\nslices.SortFunc(points, func(p, q []int) int { return p[0] - q[0] })\nx2 := -1\nfor _, p := range points {\nif p[0] > x2 {\nans++\nx2 = p[0] + w\n}\n}\nreturn\n}\n",
            "js": "/**\n * @param {number[][]} points\n * @param {number} w\n * @return {number}\n */\nvar minRectanglesToCoverPoints = function(points, w) {\n    points.sort((a,b) => a[0] - b[0])\n    let ans = 1, start = points[0][0]\n    for(let [a] of points){\n        if(a - start <= w) continue\n        else {\n            start = a \n            ans++\n        }\n    }\n    return ans \n};\n"
        },
        "cases": [
            {
                "input": "[\"[[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]]\",\"1\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]]\",\"2\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[[2,3],[1,2]]\",\"0\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minRectanglesToCoverPoints(int[][] points, int w) {",
            "cpp": "class Solution {\npublic:\n    int minRectanglesToCoverPoints(vector<vector<int>>& points, int w) {",
            "go": "",
            "js": "func minRectanglesToCoverPoints(points [][]int, w int) int {\n\n",
            "python": "class Solution:\n    def minRectanglesToCoverPoints(self, points: List[List[int]], w: int) -> int:"
        },
        "time": "20240413",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minRectanglesToCoverPoints",
            "java": "minRectanglesToCoverPoints",
            "cpp": "minRectanglesToCoverPoints",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minRectanglesToCoverPoints([[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]], 1) == 2, \"Test 1 Error!\"\nassert my_solution.minRectanglesToCoverPoints([[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], 2) == 3, \"Test 2 Error!\"\nassert my_solution.minRectanglesToCoverPoints([[2,3],[1,2]], 0) == 2, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] points_1 = {{2,1},{1,0},{1,4},{1,8},{3,5},{4,6}};\n    int w_1 = 1;\n    int ans_1 = 2;\n    assert solution.minRectanglesToCoverPoints(points_1, w_1) == ans_1;\n    int[][] points_2 = {{0,0},{1,1},{2,2},{3,3},{4,4},{5,5},{6,6}};\n    int w_2 = 2;\n    int ans_2 = 3;\n    assert solution.minRectanglesToCoverPoints(points_2, w_2) == ans_2;\n    int[][] points_3 = {{2,3},{1,2}};\n    int w_3 = 0;\n    int ans_3 = 2;\n    assert solution.minRectanglesToCoverPoints(points_3, w_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> points_1 = {{2,1},{1,0},{1,4},{1,8},{3,5},{4,6}};\n    int w_1 = 1;\n    int ans_1 = 2;\n    assert(my_solution_1.minRectanglesToCoverPoints(points_1, w_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> points_2 = {{0,0},{1,1},{2,2},{3,3},{4,4},{5,5},{6,6}};\n    int w_2 = 2;\n    int ans_2 = 3;\n    assert(my_solution_2.minRectanglesToCoverPoints(points_2, w_2) == ans_2);\n    Solution my_solution_3;\n    vector<vector<int>> points_3 = {{2,3},{1,2}};\n    int w_3 = 0;\n    int ans_3 = 2;\n    assert(my_solution_3.minRectanglesToCoverPoints(points_3, w_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "points",
                "w"
            ],
            "java": [
                "points",
                "w"
            ],
            "cpp": [
                "points",
                "w"
            ],
            "go": [],
            "js": []
        }
    },
    "3112": {
        "description": "给你一个二维数组 edges 表示一个 n 个点的无向图，其中 edges[i] = [u_i, v_i, length_i] 表示节点 u_i 和节点 v_i 之间有一条需要 length_i 单位时间通过的无向边。\n同时给你一个数组 disappear ，其中 disappear[i] 表示节点 i 从图中消失的时间点，在那一刻及以后，你无法再访问这个节点。\n注意，图有可能一开始是不连通的，两个节点之间也可能有多条边。\n请你返回数组 answer ，answer[i] 表示从节点 0 到节点 i 需要的 最少 单位时间。如果从节点 0 出发 无法 到达节点 i ，那么 answer[i] 为 -1 。",
        "difficulty_level": "Middle",
        "note": "1 <= n <= 5 * 10^4\n0 <= edges.length <= 10^5\nedges[i] == [u_i, v_i, length_i]\n0 <= u_i, v_i <= n - 1\n1 <= length_i <= 10^5\ndisappear.length == n\n1 <= disappear[i] <= 10^5",
        "codes": {
            "python": "class Solution:\n    def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n        g = [[] for _ in range(n)]  # 稀疏图用邻接表\n        for x, y, wt in edges:\n            g[x].append((y, wt))\n            g[y].append((x, wt))\n\n        dis = [-1] * n\n        dis[0] = 0\n        h = [(0, 0)]\n        while h:\n            dx, x = heappop(h)\n            if dx > dis[x]:  # x 之前出堆过\n                continue\n            for y, wt in g[x]:\n                new_dis = dx + wt\n                if new_dis < disappear[y] and (dis[y] < 0 or new_dis < dis[y]):\n                    dis[y] = new_dis  # 更新 x 的邻居的最短路\n                    heappush(h, (new_dis, y))\n        return dis\n",
            "java": "class Solution {\n    public int[] minimumTime(int n, int[][] edges, int[] disappear) {\n        List<int[]>[] g = new ArrayList[n]; // 稀疏图用邻接表\n        Arrays.setAll(g, i -> new ArrayList<>());\n        for (int[] e : edges) {\n            int x = e[0];\n            int y = e[1];\n            int wt = e[2];\n            g[x].add(new int[]{y, wt});\n            g[y].add(new int[]{x, wt});\n        }\n\n        int[] dis = new int[n];\n        Arrays.fill(dis, -1);\n        dis[0] = 0;\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[0] - b[0]));\n        pq.offer(new int[]{0, 0});\n        while (!pq.isEmpty()) {\n            int[] p = pq.poll();\n            int dx = p[0];\n            int x = p[1];\n            if (dx > dis[x]) { // x 之前出堆过\n                continue;\n            }\n            for (int[] e : g[x]) {\n                int y = e[0];\n                int newDis = dx + e[1];\n                if (newDis < disappear[y] && (dis[y] < 0 || newDis < dis[y])) {\n                    dis[y] = newDis; // 更新 x 的邻居的最短路\n                    pq.offer(new int[]{newDis, y});\n                }\n            }\n        }\n        return dis;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    vector<int> minimumTime(int n, vector<vector<int>>& edges, vector<int>& disappear) {\n        vector<vector<pair<int, int>>> g(n); // 稀疏图用邻接表\n        for (auto& e : edges) {\n            int x = e[0], y = e[1], wt = e[2];\n            g[x].emplace_back(y, wt);\n            g[y].emplace_back(x, wt);\n        }\n\n        vector<int> dis(n, -1);\n        dis[0] = 0;\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\n        pq.emplace(0, 0);\n        while (!pq.empty()) {\n            auto [dx, x] = pq.top();\n            pq.pop();\n            if (dx > dis[x]) { // x 之前出堆过\n                continue;\n            }\n            for (auto& [y, d] : g[x]) {\n                int new_dis = dx + d;\n                if (new_dis < disappear[y] && (dis[y] < 0 || new_dis < dis[y])) {\n                    dis[y] = new_dis; // 更新 x 的邻居的最短路\n                    pq.emplace(new_dis, y);\n                }\n            }\n        }\n        return dis;\n    }\n};\n",
            "go": "func minimumTime(n int, edges [][]int, disappear []int) []int {\ntype edge struct{ to, wt int }\ng := make([][]edge, n) // 稀疏图用邻接表\nfor _, e := range edges {\nx, y, wt := e[0], e[1], e[2]\ng[x] = append(g[x], edge{y, wt})\ng[y] = append(g[y], edge{x, wt})\n}\n\ndis := make([]int, n)\nfor i := range dis {\ndis[i] = -1\n}\ndis[0] = 0\nh := hp{{}}\nfor len(h) > 0 {\np := heap.Pop(&h).(pair)\ndx := p.dis\nx := p.x\nif dx > dis[x] { // x 之前出堆过\ncontinue\n}\nfor _, e := range g[x] {\ny := e.to\nnewDis := dx + e.wt\nif newDis < disappear[y] && (dis[y] < 0 || newDis < dis[y]) {\ndis[y] = newDis // 更新 x 的邻居的最短路\nheap.Push(&h, pair{newDis, y})\n}\n}\n}\nreturn dis\n}\n\ntype pair struct{ dis, x int }\ntype hp []pair\nfunc (h hp) Len() int           { return len(h) }\nfunc (h hp) Less(i, j int) bool { return h[i].dis < h[j].dis }\nfunc (h hp) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\nfunc (h *hp) Push(v any)        { *h = append(*h, v.(pair)) }\nfunc (h *hp) Pop() (v any)      { a := *h; *h, v = a[:len(a)-1], a[len(a)-1]; return }\n",
            "js": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number[]} disappear\n * @return {number[]}\n */\nvar minimumTime = function (n, edges, disappear) {\n  let map = Array.from({length: n}, () => []);\n  let ans = new Array(n).fill(-1);\n  ans[0] = 0;\n  for (const [a, b, c] of edges) {\n    map[a].push([b, c]);\n    map[b].push([a, c]);\n  }\n  const compare = (a, b) => a[0] - b[0];\n  const pq = new PriorityQueue({compare});\n  pq.enqueue([0, 0]);\n  while (!pq.isEmpty()) {\n    const [len, to] = pq.dequeue();\n    if (len > ans[to]) continue;\n    for (const [a, b] of map[to]) {\n      const t = len + b;\n      if (t < disappear[a] && (ans[a] < 0 || t < ans[a])) {\n        ans[a] = t;\n        pq.enqueue([t, a]);\n      }\n    }\n  }\n  return ans;\n};\n"
        },
        "cases": [
            {
                "input": "[\"3\",\"[[0,1,2],[1,2,1],[0,2,4]]\",\"[1,1,5]\"]",
                "output": "[\"[0,-1,4]\"]"
            },
            {
                "input": "[\"3\",\"[[0,1,2],[1,2,1],[0,2,4]]\",\"[1,3,5]\"]",
                "output": "[\"[0,2,3]\"]"
            },
            {
                "input": "[\"2\",\"[[0,1,1]]\",\"[1,1]\"]",
                "output": "[\"[0,-1]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int[] minimumTime(int n, int[][] edges, int[] disappear) {",
            "cpp": "class Solution {\npublic:\n    vector<int> minimumTime(int n, vector<vector<int>>& edges, vector<int>& disappear) {",
            "go": "func minimumTime(n int, edges [][]int, disappear []int) []int {\n\n}",
            "js": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number[]} disappear\n * @return {number[]}\n */\nvar minimumTime = function(n, edges, disappear) {",
            "python": "class Solution:\n    def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:"
        },
        "time": "20240413",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumTime",
            "java": "minimumTime",
            "cpp": "minimumTime",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumTime(3, [[0,1,2],[1,2,1],[0,2,4]], [1,1,5]) == [0,-1,4], \"Test 1 Error!\"\nassert my_solution.minimumTime(3, [[0,1,2],[1,2,1],[0,2,4]], [1,3,5]) == [0,2,3], \"Test 2 Error!\"\nassert my_solution.minimumTime(2, [[0,1,1]], [1,1]) == [0,-1], \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int n_1 = 3;\n    int[][] edges_1 = {{0,1,2},{1,2,1},{0,2,4}};\n    int[] disappear_1 = {1,1,5};\n    int[] ans_1 = {0,-1,4};\n    assert Arrays.equals(solution.minimumTime(n_1, edges_1, disappear_1), ans_1);\n    int n_2 = 3;\n    int[][] edges_2 = {{0,1,2},{1,2,1},{0,2,4}};\n    int[] disappear_2 = {1,3,5};\n    int[] ans_2 = {0,2,3};\n    assert Arrays.equals(solution.minimumTime(n_2, edges_2, disappear_2), ans_2);\n    int n_3 = 2;\n    int[][] edges_3 = {{0,1,1}};\n    int[] disappear_3 = {1,1};\n    int[] ans_3 = {0,-1};\n    assert Arrays.equals(solution.minimumTime(n_3, edges_3, disappear_3), ans_3);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int n_1 = 3;\n    vector<vector<int>> edges_1 = {{0,1,2},{1,2,1},{0,2,4}};\n    vector<int> disappear_1 = {1,1,5};\n    vector<int> ans_1 = {0,-1,4};\n    assert(my_solution_1.minimumTime(n_1, edges_1, disappear_1) == ans_1);\n    Solution my_solution_2;\n    int n_2 = 3;\n    vector<vector<int>> edges_2 = {{0,1,2},{1,2,1},{0,2,4}};\n    vector<int> disappear_2 = {1,3,5};\n    vector<int> ans_2 = {0,2,3};\n    assert(my_solution_2.minimumTime(n_2, edges_2, disappear_2) == ans_2);\n    Solution my_solution_3;\n    int n_3 = 2;\n    vector<vector<int>> edges_3 = {{0,1,1}};\n    vector<int> disappear_3 = {1,1};\n    vector<int> ans_3 = {0,-1};\n    assert(my_solution_3.minimumTime(n_3, edges_3, disappear_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "n",
                "edges",
                "disappear"
            ],
            "java": [
                "n",
                "edges",
                "disappear"
            ],
            "cpp": [
                "n",
                "edges",
                "disappear"
            ],
            "go": [],
            "js": []
        }
    },
    "3113": {
        "description": "给你一个 正 整数数组 nums 。\n请你求出 nums 中有多少个子数组，满足子数组中 第一个 和 最后一个 元素都是这个子数组中的 最大 值。",
        "difficulty_level": "Hard",
        "note": "1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9",
        "codes": {
            "python": "class Solution:\n    def numberOfSubarrays(self, nums: List[int]) -> int:\n        ans = len(nums)\n        st = [[inf, 0]]  # 无穷大哨兵\n        for x in nums:\n            while x > st[-1][0]:\n                st.pop()\n            if x == st[-1][0]:\n                ans += st[-1][1]\n                st[-1][1] += 1\n            else:\n                st.append([x, 1])\n        return ans\n",
            "java": "class Solution {\n    public long numberOfSubarrays(int[] nums) {\n        long ans = nums.length;\n        Deque<int[]> st = new ArrayDeque<>();\n        st.push(new int[]{Integer.MAX_VALUE, 0}); // 无穷大哨兵\n        for (int x : nums) {\n            while (x > st.peek()[0]) {\n                st.pop();\n            }\n            if (x == st.peek()[0]) {\n                ans += st.peek()[1]++;\n            } else {\n                st.push(new int[]{x, 1});\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long numberOfSubarrays(vector<int>& nums) {\n        long long ans = nums.size();\n        stack<pair<int, int>> st;\n        st.emplace(INT_MAX, 0); // 无穷大哨兵\n        for (int x : nums) {\n            while (x > st.top().first) {\n                st.pop();\n            }\n            if (x == st.top().first) {\n                ans += st.top().second++;\n            } else {\n                st.emplace(x, 1);\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func numberOfSubarrays(nums []int) int64 {\nans := len(nums)\ntype pair struct{ x, cnt int }\nst := []pair{{math.MaxInt, 0}} // 无穷大哨兵\nfor _, x := range nums {\nfor x > st[len(st)-1].x {\nst = st[:len(st)-1]\n}\nif x == st[len(st)-1].x {\nans += st[len(st)-1].cnt\nst[len(st)-1].cnt++\n} else {\nst = append(st, pair{x, 1})\n}\n}\nreturn int64(ans)\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numberOfSubarrays = function(nums) {\n  let stack = [[Infinity, 1]]\n  let ans = 0\n  for (let item of nums) {\n    let t = stack.at(-1)\n    while (t[0] < item) {\n      stack.pop()\n      t = stack.at(-1)\n    }\n    if (item < t[0]) stack.push([item, 1])\n    else t[1]++\n    ans += stack.at(-1)[1]\n  }\n  return ans\n}\n"
        },
        "cases": [
            {
                "input": "[\"[1,4,3,3,2]\"]",
                "output": "[\"6\"]"
            },
            {
                "input": "[\"[3,3,3]\"]",
                "output": "[\"6\"]"
            },
            {
                "input": "[\"[1]\"]",
                "output": "[\"1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long numberOfSubarrays(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    long long numberOfSubarrays(vector<int>& nums) {",
            "go": "func numberOfSubarrays(nums []int) int64 {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numberOfSubarrays = function(nums) {",
            "python": "class Solution:\n    def numberOfSubarrays(self, nums: List[int]) -> int:"
        },
        "time": "20240413",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "numberOfSubarrays",
            "java": "numberOfSubarrays",
            "cpp": "numberOfSubarrays",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.numberOfSubarrays([1,4,3,3,2]) == 6, \"Test 1 Error!\"\nassert my_solution.numberOfSubarrays([3,3,3]) == 6, \"Test 2 Error!\"\nassert my_solution.numberOfSubarrays([1]) == 1, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,4,3,3,2};\n    long ans_1 = 6;\n    assert solution.numberOfSubarrays(nums_1) == ans_1;\n    int[] nums_2 = {3,3,3};\n    long ans_2 = 6;\n    assert solution.numberOfSubarrays(nums_2) == ans_2;\n    int[] nums_3 = {1};\n    long ans_3 = 1;\n    assert solution.numberOfSubarrays(nums_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,4,3,3,2};\n    long long ans_1 = 6;\n    assert(my_solution_1.numberOfSubarrays(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {3,3,3};\n    long long ans_2 = 6;\n    assert(my_solution_2.numberOfSubarrays(nums_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {1};\n    long long ans_3 = 1;\n    assert(my_solution_3.numberOfSubarrays(nums_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3127": {
        "description": "给你一个二维 3 x 3 的矩阵 grid ，每个格子都是一个字符，要么是 'B' ，要么是 'W' 。字符 'W' 表示白色，字符 'B' 表示黑色。\n你的任务是改变 至多一个 格子的颜色，使得矩阵中存在一个 2 x 2 颜色完全相同的正方形。\n如果可以得到一个相同颜色的 2 x 2 正方形，那么返回 true ，否则返回 false 。",
        "difficulty_level": "Easy",
        "note": "grid.length == 3\ngrid[i].length == 3\ngrid[i][j] 要么是 'W' ，要么是 'B' 。",
        "codes": {
            "python": "class Solution:\n    def canMakeSquare(self, grid: List[List[str]]) -> bool:\n        def check(i: int, j: int) -> bool:\n            cnt = Counter()\n            cnt[grid[i][j]] += 1\n            cnt[grid[i][j + 1]] += 1\n            cnt[grid[i + 1][j]] += 1\n            cnt[grid[i + 1][j + 1]] += 1\n            return cnt['B'] >= 3 or cnt['W'] >= 3\n        return check(0, 0) or check(0, 1) or check(1, 0) or check(1, 1)\n",
            "java": "class Solution {\n    public boolean canMakeSquare(char[][] grid) {\n        return check(grid, 0, 0) || check(grid, 0, 1) || check(grid, 1, 0) || check(grid, 1, 1);\n    }\n\n    private boolean check(char[][] grid, int i, int j) {\n        int[] cnt = new int[2];\n        cnt[grid[i][j] & 1]++;\n        cnt[grid[i][j + 1] & 1]++;\n        cnt[grid[i + 1][j] & 1]++;\n        cnt[grid[i + 1][j + 1] & 1]++;\n        return cnt[0] >= 3 || cnt[1] >= 3;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    bool canMakeSquare(vector<vector<char>>& grid) {\n        auto check = [&](int i, int j) {\n            int cnt[2]{};\n            cnt[grid[i][j] & 1]++;\n            cnt[grid[i][j + 1] & 1]++;\n            cnt[grid[i + 1][j] & 1]++;\n            cnt[grid[i + 1][j + 1] & 1]++;\n            return cnt[0] >= 3 || cnt[1] >= 3;\n        };\n        return check(0, 0) || check(0, 1) || check(1, 0) || check(1, 1);\n    }\n};\n",
            "go": "func canMakeSquare(grid [][]byte) bool {\ncheck := func(i, j int) bool {\ncnt := [2]int{}\ncnt[grid[i][j]&1]++\ncnt[grid[i][j+1]&1]++\ncnt[grid[i+1][j]&1]++\ncnt[grid[i+1][j+1]&1]++\nreturn cnt[0] >= 3 || cnt[1] >= 3\n}\nreturn check(0, 0) || check(0, 1) || check(1, 0) || check(1, 1)\n}\n",
            "js": "/**\n * @param {character[][]} grid\n * @return {boolean}\n */\nvar canMakeSquare = function(grid) {\n    // 只要看中间的格子周围的颜色\n    let w;\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            if (i < 2 && j < 2) { // 只看左上角四个点\n                w = 0; // 统计白色\n                w += grid[i][j] === 'W' ? 1 : 0;\n                w += grid[i+1][j] === 'W' ? 1 : 0;\n                w += grid[i][j+1] === 'W' ? 1 : 0;\n                w += grid[i+1][j+1] === 'W' ? 1 : 0;\n                if (w !== 2) { // 符合\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[[\\\"B\\\",\\\"W\\\",\\\"B\\\"],[\\\"B\\\",\\\"W\\\",\\\"W\\\"],[\\\"B\\\",\\\"W\\\",\\\"B\\\"]]\"]",
                "output": "[\"true\"]"
            },
            {
                "input": "[\"[[\\\"B\\\",\\\"W\\\",\\\"B\\\"],[\\\"W\\\",\\\"B\\\",\\\"W\\\"],[\\\"B\\\",\\\"W\\\",\\\"B\\\"]]\"]",
                "output": "[\"false\"]"
            },
            {
                "input": "[\"[[\\\"B\\\",\\\"W\\\",\\\"B\\\"],[\\\"B\\\",\\\"W\\\",\\\"W\\\"],[\\\"B\\\",\\\"W\\\",\\\"W\\\"]]\"]",
                "output": "[\"true\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public boolean canMakeSquare(char[][] grid) {",
            "cpp": "class Solution {\npublic:\n    bool canMakeSquare(vector<vector<char>>& grid) {",
            "go": "func canMakeSquare(grid [][]byte) bool {\n\n}",
            "js": "/**\n * @param {character[][]} grid\n * @return {boolean}\n */\nvar canMakeSquare = function(grid) {",
            "python": "class Solution:\n    def canMakeSquare(self, grid: List[List[str]]) -> bool:"
        },
        "time": "20240427",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "canMakeSquare",
            "java": "canMakeSquare",
            "cpp": "canMakeSquare",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.canMakeSquare([[\"B\",\"W\",\"B\"],[\"B\",\"W\",\"W\"],[\"B\",\"W\",\"B\"]]) == True, \"Test 1 Error!\"\nassert my_solution.canMakeSquare([[\"B\",\"W\",\"B\"],[\"W\",\"B\",\"W\"],[\"B\",\"W\",\"B\"]]) == False, \"Test 2 Error!\"\nassert my_solution.canMakeSquare([[\"B\",\"W\",\"B\"],[\"B\",\"W\",\"W\"],[\"B\",\"W\",\"W\"]]) == True, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    char[][] grid_1 = {{'B','W','B'},{'B','W','W'},{'B','W','B'}};\n    boolean ans_1 = true;\n    assert solution.canMakeSquare(grid_1) == ans_1;\n    char[][] grid_2 = {{'B','W','B'},{'W','B','W'},{'B','W','B'}};\n    boolean ans_2 = false;\n    assert solution.canMakeSquare(grid_2) == ans_2;\n    char[][] grid_3 = {{'B','W','B'},{'B','W','W'},{'B','W','W'}};\n    boolean ans_3 = true;\n    assert solution.canMakeSquare(grid_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<char>> grid_1 = {{'B','W','B'},{'B','W','W'},{'B','W','B'}};\n    bool ans_1 = true;\n    assert(my_solution_1.canMakeSquare(grid_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<char>> grid_2 = {{'B','W','B'},{'W','B','W'},{'B','W','B'}};\n    bool ans_2 = false;\n    assert(my_solution_2.canMakeSquare(grid_2) == ans_2);\n    Solution my_solution_3;\n    vector<vector<char>> grid_3 = {{'B','W','B'},{'B','W','W'},{'B','W','W'}};\n    bool ans_3 = true;\n    assert(my_solution_3.canMakeSquare(grid_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "grid"
            ],
            "java": [
                "grid"
            ],
            "cpp": [
                "grid"
            ],
            "go": [],
            "js": []
        }
    },
    "3128": {
        "description": "给你一个二维 boolean 矩阵 grid 。请你返回使用 grid 中的 3 个元素可以构建的 直角三角形 数目，且满足 3 个元素值 都 为 1 。\n注意：\n如果 grid 中 3 个元素满足：一个元素与另一个元素在 同一行，同时与第三个元素在 同一列 ，那么这 3 个元素称为一个 直角三角形 。这 3 个元素互相之间不需要相邻。",
        "difficulty_level": "Middle",
        "note": "1 <= grid.length <= 1000\n1 <= grid[i].length <= 1000\n0 <= grid[i][j] <= 1",
        "codes": {
            "python": "class Solution:\n    def numberOfRightTriangles(self, grid: List[List[int]]) -> int:\n        col_sum = [sum(col) - 1 for col in zip(*grid)]  # 提前减一\n        ans = 0\n        for row in grid:\n            row_sum = sum(row) - 1\n            ans += row_sum * sum(c for x, c in zip(row, col_sum) if x)\n        return ans\n",
            "java": "class Solution {\n    public long numberOfRightTriangles(int[][] grid) {\n        int n = grid[0].length;\n        int[] colSum = new int[n];\n        Arrays.fill(colSum, -1); // 提前减一\n        for (int j = 0; j < n; j++) {\n            for (int[] row : grid) {\n                colSum[j] += row[j];\n            }\n        }\n\n        long ans = 0;\n        for (int[] row : grid) {\n            int rowSum = -1; // 提前减一\n            for (int x : row) {\n                rowSum += x;\n            }\n            for (int j = 0; j < row.length; j++) {\n                if (row[j] == 1) {\n                    ans += rowSum * colSum[j];\n                }\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long numberOfRightTriangles(vector<vector<int>>& grid) {\n        int n = grid[0].size();\n        vector<int> col_sum(n, -1); // 提前减一\n        for (int j = 0; j < n; j++) {\n            for (auto& row : grid) {\n                col_sum[j] += row[j];\n            }\n        }\n\n        long long ans = 0;\n        for (auto& row : grid) {\n            int row_sum = accumulate(row.begin(), row.end(), 0) - 1; // 提前减一\n            for (int j = 0; j < row.size(); j++) {\n                if (row[j] == 1) {\n                    ans += row_sum * col_sum[j];\n                }\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func numberOfRightTriangles(grid [][]int) (ans int64) {\nn := len(grid[0])\ncolSum := make([]int, n)\nfor j := 0; j < n; j++ {\nfor _, row := range grid {\ncolSum[j] += row[j]\n}\n}\n\nfor _, row := range grid {\nrowSum := -1 // 提前减一\nfor _, x := range row {\nrowSum += x\n}\nfor j, x := range row {\nif x == 1 {\nans += int64(rowSum * (colSum[j] - 1))\n}\n}\n}\nreturn\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[[0,1,0],[0,1,1],[0,1,0]]\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[[1,0,0,0],[0,1,0,1],[1,0,0,0]]\"]",
                "output": "[\"0\"]"
            },
            {
                "input": "[\"[[1,0,1],[1,0,0],[1,0,0]]\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long numberOfRightTriangles(int[][] grid) {",
            "cpp": "class Solution {\npublic:\n    long long numberOfRightTriangles(vector<vector<int>>& grid) {",
            "go": "func numberOfRightTriangles(grid [][]int) int64 {\n\n}",
            "js": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar numberOfRightTriangles = function(grid) {",
            "python": "class Solution:\n    def numberOfRightTriangles(self, grid: List[List[int]]) -> int:"
        },
        "time": "20240427",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "numberOfRightTriangles",
            "java": "numberOfRightTriangles",
            "cpp": "numberOfRightTriangles",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.numberOfRightTriangles([[0,1,0],[0,1,1],[0,1,0]]) == 2, \"Test 1 Error!\"\nassert my_solution.numberOfRightTriangles([[1,0,0,0],[0,1,0,1],[1,0,0,0]]) == 0, \"Test 2 Error!\"\nassert my_solution.numberOfRightTriangles([[1,0,1],[1,0,0],[1,0,0]]) == 2, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] grid_1 = {{0,1,0},{0,1,1},{0,1,0}};\n    long ans_1 = 2;\n    assert solution.numberOfRightTriangles(grid_1) == ans_1;\n    int[][] grid_2 = {{1,0,0,0},{0,1,0,1},{1,0,0,0}};\n    long ans_2 = 0;\n    assert solution.numberOfRightTriangles(grid_2) == ans_2;\n    int[][] grid_3 = {{1,0,1},{1,0,0},{1,0,0}};\n    long ans_3 = 2;\n    assert solution.numberOfRightTriangles(grid_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> grid_1 = {{0,1,0},{0,1,1},{0,1,0}};\n    long long ans_1 = 2;\n    assert(my_solution_1.numberOfRightTriangles(grid_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> grid_2 = {{1,0,0,0},{0,1,0,1},{1,0,0,0}};\n    long long ans_2 = 0;\n    assert(my_solution_2.numberOfRightTriangles(grid_2) == ans_2);\n    Solution my_solution_3;\n    vector<vector<int>> grid_3 = {{1,0,1},{1,0,0},{1,0,0}};\n    long long ans_3 = 2;\n    assert(my_solution_3.numberOfRightTriangles(grid_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "grid"
            ],
            "java": [
                "grid"
            ],
            "cpp": [
                "grid"
            ],
            "go": [],
            "js": []
        }
    },
    "3129": {
        "description": "给你 3 个正整数 zero ，one 和 limit 。\n一个 二进制数组 arr 如果满足以下条件，那么我们称它是 稳定的 ：\n0 在 arr 中出现次数 恰好 为 zero 。\n1 在 arr 中出现次数 恰好 为 one 。\narr 中每个长度超过 limit 的 子数组 都 同时 包含 0 和 1 。\n请你返回 稳定 二进制数组的 总 数目。\n由于答案可能很大，将它对 10^9 + 7 取余 后返回。",
        "difficulty_level": "Middle",
        "note": "1 <= zero, one, limit <= 200",
        "codes": {
            "python": "class Solution:\n    def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n        MOD = 1_000_000_007\n        @cache  # 缓存装饰器，避免重复计算 dfs 的结果（记忆化）\n        def dfs(i: int, j: int, k: int) -> int:\n            if i == 0:\n                return 1 if k == 1 and j <= limit else 0\n            if j == 0:\n                return 1 if k == 0 and i <= limit else 0\n            if k == 0:\n                return (dfs(i - 1, j, 0) + dfs(i - 1, j, 1) - (dfs(i - limit - 1, j, 1) if i > limit else 0)) % MOD\n            else:  # else 可以去掉，这里仅仅是为了代码对齐\n                return (dfs(i, j - 1, 0) + dfs(i, j - 1, 1) - (dfs(i, j - limit - 1, 0) if j > limit else 0)) % MOD\n        ans = (dfs(zero, one, 0) + dfs(zero, one, 1)) % MOD\n        dfs.cache_clear()  # 防止爆内存\n        return ans\n",
            "java": "class Solution {\n    private static final int MOD = 1_000_000_007;\n\n    public int numberOfStableArrays(int zero, int one, int limit) {\n        int[][][] memo = new int[zero + 1][one + 1][2];\n        for (int[][] m : memo) {\n            for (int[] m2 : m) {\n                Arrays.fill(m2, -1); // -1 表示没有计算过\n            }\n        }\n        return (dfs(zero, one, 0, limit, memo) + dfs(zero, one, 1, limit, memo)) % MOD;\n    }\n\n    private int dfs(int i, int j, int k, int limit, int[][][] memo) {\n        if (i == 0) { // 递归边界\n            return k == 1 && j <= limit ? 1 : 0;\n        }\n        if (j == 0) { // 递归边界\n            return k == 0 && i <= limit ? 1 : 0;\n        }\n        if (memo[i][j][k] != -1) { // 之前计算过\n            return memo[i][j][k];\n        }\n        if (k == 0) {\n            // + MOD 保证答案非负\n            memo[i][j][k] = (int) (((long) dfs(i - 1, j, 0, limit, memo) + dfs(i - 1, j, 1, limit, memo) +\n                    (i > limit ? MOD - dfs(i - limit - 1, j, 1, limit, memo) : 0)) % MOD);\n        } else {\n            memo[i][j][k] = (int) (((long) dfs(i, j - 1, 0, limit, memo) + dfs(i, j - 1, 1, limit, memo) +\n                    (j > limit ? MOD - dfs(i, j - limit - 1, 0, limit, memo) : 0)) % MOD);\n        }\n        return memo[i][j][k];\n    }\n}\n",
            "cpp": "class Solution {\n    int MOD = 1'000'000'007;\n    vector<vector<array<int, 2>>> memo;\n\n    int dfs(int i, int j, int k, int limit) {\n        if (i == 0) { // 递归边界\n            return k == 1 && j <= limit;\n        }\n        if (j == 0) { // 递归边界\n            return k == 0 && i <= limit;\n        }\n        int& res = memo[i][j][k]; // 注意这里是引用\n        if (res != -1) { // 之前计算过\n            return res;\n        }\n        if (k == 0) {\n            // + MOD 保证答案非负\n            res = ((long long) dfs(i - 1, j, 0, limit) + dfs(i - 1, j, 1, limit) +\n                   (i > limit ? MOD - dfs(i - limit - 1, j, 1, limit) : 0)) % MOD;\n        } else {\n            res = ((long long) dfs(i, j - 1, 0, limit) + dfs(i, j - 1, 1, limit) +\n                   (j > limit ? MOD - dfs(i, j - limit - 1, 0, limit) : 0)) % MOD;\n        }\n        return res;\n    }\n\npublic:\n    int numberOfStableArrays(int zero, int one, int limit) {\n        // -1 表示没有计算过\n        memo.resize(zero + 1, vector<array<int, 2>>(one + 1, {-1, -1}));\n        return (dfs(zero, one, 0, limit) + dfs(zero, one, 1, limit)) % MOD;\n    }\n};\n",
            "go": "func numberOfStableArrays(zero, one, limit int) int {\nconst mod = 1_000_000_007\nmemo := make([][][2]int, zero+1)\nfor i := range memo {\nmemo[i] = make([][2]int, one+1)\nfor j := range memo[i] {\nmemo[i][j] = [2]int{-1, -1}\n}\n}\nvar dfs func(int, int, int) int\ndfs = func(i, j, k int) (res int) {\nif i == 0 { // 递归边界\nif k == 1 && j <= limit {\nreturn 1\n}\nreturn\n}\nif j == 0 { // 递归边界\nif k == 0 && i <= limit {\nreturn 1\n}\nreturn\n}\np := &memo[i][j][k]\nif *p != -1 { // 之前计算过\nreturn *p\n}\nif k == 0 {\n// +mod 保证答案非负\nres = (dfs(i-1, j, 0) + dfs(i-1, j, 1)) % mod\nif i > limit {\nres = (res - dfs(i-limit-1, j, 1) + mod) % mod\n}\n} else {\nres = (dfs(i, j-1, 0) + dfs(i, j-1, 1)) % mod\nif j > limit {\nres = (res - dfs(i, j-limit-1, 0) + mod) % mod\n}\n}\n*p = res // 记忆化\nreturn\n}\nreturn (dfs(zero, one, 0) + dfs(zero, one, 1)) % mod\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"1\",\"1\",\"2\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"1\",\"2\",\"1\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"3\",\"3\",\"2\"]",
                "output": "[\"14\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int numberOfStableArrays(int zero, int one, int limit) {",
            "cpp": "class Solution {\npublic:\n    int numberOfStableArrays(int zero, int one, int limit) {",
            "go": "func numberOfStableArrays(zero int, one int, limit int) int {\n\n}",
            "js": "/**\n * @param {number} zero\n * @param {number} one\n * @param {number} limit\n * @return {number}\n */\nvar numberOfStableArrays = function(zero, one, limit) {",
            "python": "class Solution:\n    def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:"
        },
        "time": "20240427",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "numberOfStableArrays",
            "java": "numberOfStableArrays",
            "cpp": "numberOfStableArrays",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.numberOfStableArrays(1, 1, 2) == 2, \"Test 1 Error!\"\nassert my_solution.numberOfStableArrays(1, 2, 1) == 1, \"Test 2 Error!\"\nassert my_solution.numberOfStableArrays(3, 3, 2) == 14, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int zero_1 = 1;\n    int one_1 = 1;\n    int limit_1 = 2;\n    int ans_1 = 2;\n    assert solution.numberOfStableArrays(zero_1, one_1, limit_1) == ans_1;\n    int zero_2 = 1;\n    int one_2 = 2;\n    int limit_2 = 1;\n    int ans_2 = 1;\n    assert solution.numberOfStableArrays(zero_2, one_2, limit_2) == ans_2;\n    int zero_3 = 3;\n    int one_3 = 3;\n    int limit_3 = 2;\n    int ans_3 = 14;\n    assert solution.numberOfStableArrays(zero_3, one_3, limit_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int zero_1 = 1;\n    int one_1 = 1;\n    int limit_1 = 2;\n    int ans_1 = 2;\n    assert(my_solution_1.numberOfStableArrays(zero_1, one_1, limit_1) == ans_1);\n    Solution my_solution_2;\n    int zero_2 = 1;\n    int one_2 = 2;\n    int limit_2 = 1;\n    int ans_2 = 1;\n    assert(my_solution_2.numberOfStableArrays(zero_2, one_2, limit_2) == ans_2);\n    Solution my_solution_3;\n    int zero_3 = 3;\n    int one_3 = 3;\n    int limit_3 = 2;\n    int ans_3 = 14;\n    assert(my_solution_3.numberOfStableArrays(zero_3, one_3, limit_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "zero",
                "one",
                "limit"
            ],
            "java": [
                "zero",
                "one",
                "limit"
            ],
            "cpp": [
                "zero",
                "one",
                "limit"
            ],
            "go": [],
            "js": []
        }
    },
    "3130": {
        "description": "给你 3 个正整数 zero ，one 和 limit 。一个 二进制数组 arr 如果满足以下条件，那么我们称它是 稳定的 ：\n0 在 arr 中出现次数 恰好 为 zero 。\n1 在 arr 中出现次数 恰好 为 one 。\narr 中每个长度超过 limit 的 子数组 都 同时 包含 0 和 1 。\n请你返回 稳定 二进制数组的 总 数目。\n由于答案可能很大，将它对 10^9 + 7 取余 后返回。",
        "difficulty_level": "Hard",
        "note": "1 <= zero, one, limit <= 1000",
        "codes": {
            "python": "class Solution:\n    def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n        MOD = 1_000_000_007\n        f = [[[0, 0] for _ in range(one + 1)] for _ in range(zero + 1)]\n        for i in range(1, min(limit, zero) + 1):\n            f[i][0][0] = 1\n        for j in range(1, min(limit, one) + 1):\n            f[0][j][1] = 1\n        for i in range(1, zero + 1):\n            for j in range(1, one + 1):\n                f[i][j][0] = (f[i - 1][j][0] + f[i - 1][j][1] - (f[i - limit - 1][j][1] if i > limit else 0)) % MOD\n                f[i][j][1] = (f[i][j - 1][0] + f[i][j - 1][1] - (f[i][j - limit - 1][0] if j > limit else 0)) % MOD\n        return sum(f[-1][-1]) % MOD\n",
            "java": "class Solution {\n    public int numberOfStableArrays(int zero, int one, int limit) {\n        final int MOD = 1_000_000_007;\n        int[][][] f = new int[zero + 1][one + 1][2];\n        for (int i = 1; i <= Math.min(limit, zero); i++) {\n            f[i][0][0] = 1;\n        }\n        for (int j = 1; j <= Math.min(limit, one); j++) {\n            f[0][j][1] = 1;\n        }\n        for (int i = 1; i <= zero; i++) {\n            for (int j = 1; j <= one; j++) {\n                // + MOD 保证答案非负\n                f[i][j][0] = (int) (((long) f[i - 1][j][0] + f[i - 1][j][1] + (i > limit ? MOD - f[i - limit - 1][j][1] : 0)) % MOD);\n                f[i][j][1] = (int) (((long) f[i][j - 1][0] + f[i][j - 1][1] + (j > limit ? MOD - f[i][j - limit - 1][0] : 0)) % MOD);\n            }\n        }\n        return (f[zero][one][0] + f[zero][one][1]) % MOD;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int numberOfStableArrays(int zero, int one, int limit) {\n        const int MOD = 1'000'000'007;\n        vector<vector<array<int, 2>>> f(zero + 1, vector<array<int, 2>>(one + 1));\n        for (int i = 1; i <= min(limit, zero); i++) {\n            f[i][0][0] = 1;\n        }\n        for (int j = 1; j <= min(limit, one); j++) {\n            f[0][j][1] = 1;\n        }\n        for (int i = 1; i <= zero; i++) {\n            for (int j = 1; j <= one; j++) {\n                // + MOD 保证答案非负\n                f[i][j][0] = ((long long) f[i - 1][j][0] + f[i - 1][j][1] + (i > limit ? MOD - f[i - limit - 1][j][1] : 0)) % MOD;\n                f[i][j][1] = ((long long) f[i][j - 1][0] + f[i][j - 1][1] + (j > limit ? MOD - f[i][j - limit - 1][0] : 0)) % MOD;\n            }\n        }\n        return (f[zero][one][0] + f[zero][one][1]) % MOD;\n    }\n};\n",
            "go": "func numberOfStableArrays(zero, one, limit int) (ans int) {\nconst mod = 1_000_000_007\nf := make([][][2]int, zero+1)\nfor i := range f {\nf[i] = make([][2]int, one+1)\n}\nfor i := 1; i <= min(limit, zero); i++ {\nf[i][0][0] = 1\n}\nfor j := 1; j <= min(limit, one); j++ {\nf[0][j][1] = 1\n}\nfor i := 1; i <= zero; i++ {\nfor j := 1; j <= one; j++ {\nf[i][j][0] = (f[i-1][j][0] + f[i-1][j][1]) % mod\nif i > limit {\n// + mod 保证答案非负\nf[i][j][0] = (f[i][j][0] - f[i-limit-1][j][1] + mod) % mod\n}\nf[i][j][1] = (f[i][j-1][0] + f[i][j-1][1]) % mod\nif j > limit {\nf[i][j][1] = (f[i][j][1] - f[i][j-limit-1][0] + mod) % mod\n}\n}\n}\nreturn (f[zero][one][0] + f[zero][one][1]) % mod\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"1\",\"1\",\"2\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"1\",\"2\",\"1\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"3\",\"3\",\"2\"]",
                "output": "[\"14\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int numberOfStableArrays(int zero, int one, int limit) {",
            "cpp": "class Solution {\npublic:\n    int numberOfStableArrays(int zero, int one, int limit) {",
            "go": "func numberOfStableArrays(zero int, one int, limit int) int {\n\n}",
            "js": "/**\n * @param {number} zero\n * @param {number} one\n * @param {number} limit\n * @return {number}\n */\nvar numberOfStableArrays = function(zero, one, limit) {",
            "python": "class Solution:\n    def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:"
        },
        "time": "20240427",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "numberOfStableArrays",
            "java": "numberOfStableArrays",
            "cpp": "numberOfStableArrays",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.numberOfStableArrays(1, 1, 2) == 2, \"Test 1 Error!\"\nassert my_solution.numberOfStableArrays(1, 2, 1) == 1, \"Test 2 Error!\"\nassert my_solution.numberOfStableArrays(3, 3, 2) == 14, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int zero_1 = 1;\n    int one_1 = 1;\n    int limit_1 = 2;\n    int ans_1 = 2;\n    assert solution.numberOfStableArrays(zero_1, one_1, limit_1) == ans_1;\n    int zero_2 = 1;\n    int one_2 = 2;\n    int limit_2 = 1;\n    int ans_2 = 1;\n    assert solution.numberOfStableArrays(zero_2, one_2, limit_2) == ans_2;\n    int zero_3 = 3;\n    int one_3 = 3;\n    int limit_3 = 2;\n    int ans_3 = 14;\n    assert solution.numberOfStableArrays(zero_3, one_3, limit_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int zero_1 = 1;\n    int one_1 = 1;\n    int limit_1 = 2;\n    int ans_1 = 2;\n    assert(my_solution_1.numberOfStableArrays(zero_1, one_1, limit_1) == ans_1);\n    Solution my_solution_2;\n    int zero_2 = 1;\n    int one_2 = 2;\n    int limit_2 = 1;\n    int ans_2 = 1;\n    assert(my_solution_2.numberOfStableArrays(zero_2, one_2, limit_2) == ans_2);\n    Solution my_solution_3;\n    int zero_3 = 3;\n    int one_3 = 3;\n    int limit_3 = 2;\n    int ans_3 = 14;\n    assert(my_solution_3.numberOfStableArrays(zero_3, one_3, limit_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "zero",
                "one",
                "limit"
            ],
            "java": [
                "zero",
                "one",
                "limit"
            ],
            "cpp": [
                "zero",
                "one",
                "limit"
            ],
            "go": [],
            "js": []
        }
    },
    "3142": {
        "description": "给你一个大小为 m x n 的二维矩阵 grid 。你需要判断每一个格子 grid[i][j] 是否满足：\n如果它下面的格子存在，那么它需要等于它下面的格子，也就是 grid[i][j] == grid[i + 1][j] 。\n如果它右边的格子存在，那么它需要不等于它右边的格子，也就是 grid[i][j] != grid[i][j + 1] 。\n如果 所有 格子都满足以上条件，那么返回 true ，否则返回 false 。",
        "difficulty_level": "Easy",
        "note": "1 <= n, m <= 10\n0 <= grid[i][j] <= 9",
        "codes": {
            "python": "class Solution:\n    def satisfiesConditions(self, grid: List[List[int]]) -> bool:\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                if j and x == row[j - 1] or i and x != grid[i - 1][j]:\n                    return False\n        return True\n",
            "java": "class Solution {\n    public boolean satisfiesConditions(int[][] grid) {\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[i].length; j++) {\n                if (j > 0 && grid[i][j] == grid[i][j - 1] || i > 0 && grid[i][j] != grid[i - 1][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    bool satisfiesConditions(vector<vector<int>>& grid) {\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[i].size(); j++) {\n                if (j && grid[i][j] == grid[i][j - 1] || i && grid[i][j] != grid[i - 1][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n",
            "go": "func satisfiesConditions(grid [][]int) bool {\nfor i, row := range grid {\nfor j, x := range row {\nif j > 0 && x == row[j-1] || i > 0 && x != grid[i-1][j] {\nreturn false\n}\n}\n}\nreturn true\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[[1,0,2],[1,0,2]]\"]",
                "output": "[\"true\"]"
            },
            {
                "input": "[\" [[1,1,1],[0,0,0]]\"]",
                "output": "[\"false\"]"
            },
            {
                "input": "[\"[[1],[2],[3]]\"]",
                "output": "[\"false\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public boolean satisfiesConditions(int[][] grid) {",
            "cpp": "class Solution {\npublic:\n    bool satisfiesConditions(vector<vector<int>>& grid) {",
            "go": "func satisfiesConditions(grid [][]int) bool {\n\n}",
            "js": "/**\n * @param {number[][]} grid\n * @return {boolean}\n */\nvar satisfiesConditions = function(grid) {",
            "python": "class Solution:\n    def satisfiesConditions(self, grid: List[List[int]]) -> bool:"
        },
        "time": "20240511",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "satisfiesConditions",
            "java": "satisfiesConditions",
            "cpp": "satisfiesConditions",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.satisfiesConditions([[1,0,2],[1,0,2]]) == True, \"Test 1 Error!\"\nassert my_solution.satisfiesConditions( [[1,1,1],[0,0,0]]) == False, \"Test 2 Error!\"\nassert my_solution.satisfiesConditions([[1],[2],[3]]) == False, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] grid_1 = {{1,0,2},{1,0,2}};\n    boolean ans_1 = true;\n    assert solution.satisfiesConditions(grid_1) == ans_1;\n    int[][] grid_2 =  {{1,1,1},{0,0,0}};\n    boolean ans_2 = false;\n    assert solution.satisfiesConditions(grid_2) == ans_2;\n    int[][] grid_3 = {{1},{2},{3}};\n    boolean ans_3 = false;\n    assert solution.satisfiesConditions(grid_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> grid_1 = {{1,0,2},{1,0,2}};\n    bool ans_1 = true;\n    assert(my_solution_1.satisfiesConditions(grid_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> grid_2 =  {{1,1,1},{0,0,0}};\n    bool ans_2 = false;\n    assert(my_solution_2.satisfiesConditions(grid_2) == ans_2);\n    Solution my_solution_3;\n    vector<vector<int>> grid_3 = {{1},{2},{3}};\n    bool ans_3 = false;\n    assert(my_solution_3.satisfiesConditions(grid_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "grid"
            ],
            "java": [
                "grid"
            ],
            "cpp": [
                "grid"
            ],
            "go": [],
            "js": []
        }
    },
    "3143": {
        "description": "给你一个二维数组 points 和一个字符串 s ，其中 points[i] 表示第 i 个点的坐标，s[i] 表示第 i 个点的 标签 。\n如果一个正方形的中心在 (0, 0) ，所有边都平行于坐标轴，且正方形内 不 存在标签相同的两个点，那么我们称这个正方形是 合法 的。\n请你返回 合法 正方形中可以包含的 最多 点数。\n注意：\n如果一个点位于正方形的边上或者在边以内，则认为该点位于正方形内。\n正方形的边长可以为零。",
        "difficulty_level": "Middle",
        "note": "1 <= s.length, points.length <= 10^5\npoints[i].length == 2\n-10^9 <= points[i][0], points[i][1] <= 10^9\ns.length == points.length\npoints 中的点坐标互不相同。\ns 只包含小写英文字母。",
        "codes": {
            "python": "class Solution:\n    def maxPointsInsideSquare(self, points: List[List[int]], s: str) -> int:\n        ans = 0\n        def check(size: int) -> bool:\n            vis = set()\n            for (x, y), c in zip(points, s):\n                if abs(x) <= size and abs(y) <= size:\n                    if c in vis:\n                        return True\n                    vis.add(c)\n            nonlocal ans\n            ans = len(vis)\n            return False\n        bisect_left(range(1_000_000_001), True, key=check)\n        return ans\n",
            "java": "class Solution {\n    private int ans;\n\n    public int maxPointsInsideSquare(int[][] points, String S) {\n        char[] s = S.toCharArray();\n        int left = -1, right = 1_000_000_001;\n        while (left + 1 < right) {\n            int mid = (left + right) >>> 1;\n            if (check(mid, points, s)) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        return ans;\n    }\n\n    boolean check(int size, int[][] points, char[] s) {\n        int vis = 0;\n        for (int i = 0; i < points.length; i++) {\n            int x = points[i][0];\n            int y = points[i][1];\n            int c = s[i] - 'a';\n            if (Math.abs(x) <= size && Math.abs(y) <= size) {\n                if ((vis >> c & 1) > 0) {\n                    return false;\n                }\n                vis |= 1 << c;\n            }\n        }\n        ans = Integer.bitCount(vis);\n        return true;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int maxPointsInsideSquare(vector<vector<int>>& points, string s) {\n        int ans = 0;\n        auto check = [&](int size) -> bool {\n            int vis = 0;\n            for (int i = 0; i < points.size(); i++) {\n                int x = points[i][0];\n                int y = points[i][1];\n                char c = s[i] - 'a';\n                if (abs(x) <= size && abs(y) <= size) {\n                    if (vis >> c & 1) {\n                        return false;\n                    }\n                    vis |= 1 << c;\n                }\n            }\n            ans = __builtin_popcount(vis);\n            return true;\n        };\n        int left = -1, right = 1'000'000'001;\n        while (left + 1 < right) {\n            int mid = (left + right) / 2;\n            (check(mid) ? left : right) = mid;\n        }\n        return ans;\n    }\n};\n",
            "go": "func maxPointsInsideSquare(points [][]int, s string) (ans int) {\nsort.Search(1_000_000_001, func(size int) bool {\nvis := 0\nfor i, p := range points {\nif abs(p[0]) <= size && abs(p[1]) <= size {\nc := s[i] - 'a'\nif vis>>c&1 > 0 {\nreturn true\n}\nvis |= 1 << c\n}\n}\nans = bits.OnesCount(uint(vis))\nreturn false\n})\nreturn\n}\n\nfunc abs(x int) int { if x < 0 { return -x }; return x }\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[[2,2],[-1,-2],[-4,4],[-3,1],[3,-3]]\",\"\\\"abdca\\\"\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[[1,1],[-2,-2],[-2,2]]\",\"\\\"abb\\\"\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"[[1,1],[-1,-1],[2,-2]]\",\"\\\"ccd\\\"\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maxPointsInsideSquare(int[][] points, String s) {",
            "cpp": "class Solution {\npublic:\n    int maxPointsInsideSquare(vector<vector<int>>& points, string s) {",
            "go": "func maxPointsInsideSquare(points [][]int, s string) int {\n\n}",
            "js": "/**\n * @param {number[][]} points\n * @param {string} s\n * @return {number}\n */\nvar maxPointsInsideSquare = function(points, s) {",
            "python": "class Solution:\n    def maxPointsInsideSquare(self, points: List[List[int]], s: str) -> int:"
        },
        "time": "20240511",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maxPointsInsideSquare",
            "java": "maxPointsInsideSquare",
            "cpp": "maxPointsInsideSquare",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maxPointsInsideSquare([[2,2],[-1,-2],[-4,4],[-3,1],[3,-3]], \"abdca\") == 2, \"Test 1 Error!\"\nassert my_solution.maxPointsInsideSquare([[1,1],[-2,-2],[-2,2]], \"abb\") == 1, \"Test 2 Error!\"\nassert my_solution.maxPointsInsideSquare([[1,1],[-1,-1],[2,-2]], \"ccd\") == 0, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] points_1 = {{2,2},{-1,-2},{-4,4},{-3,1},{3,-3}};\n    String s_1 = \"abdca\";\n    int ans_1 = 2;\n    assert solution.maxPointsInsideSquare(points_1, s_1) == ans_1;\n    int[][] points_2 = {{1,1},{-2,-2},{-2,2}};\n    String s_2 = \"abb\";\n    int ans_2 = 1;\n    assert solution.maxPointsInsideSquare(points_2, s_2) == ans_2;\n    int[][] points_3 = {{1,1},{-1,-1},{2,-2}};\n    String s_3 = \"ccd\";\n    int ans_3 = 0;\n    assert solution.maxPointsInsideSquare(points_3, s_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> points_1 = {{2,2},{-1,-2},{-4,4},{-3,1},{3,-3}};\n    string s_1 = \"abdca\";\n    int ans_1 = 2;\n    assert(my_solution_1.maxPointsInsideSquare(points_1, s_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> points_2 = {{1,1},{-2,-2},{-2,2}};\n    string s_2 = \"abb\";\n    int ans_2 = 1;\n    assert(my_solution_2.maxPointsInsideSquare(points_2, s_2) == ans_2);\n    Solution my_solution_3;\n    vector<vector<int>> points_3 = {{1,1},{-1,-1},{2,-2}};\n    string s_3 = \"ccd\";\n    int ans_3 = 0;\n    assert(my_solution_3.maxPointsInsideSquare(points_3, s_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "points",
                "s"
            ],
            "java": [
                "points",
                "s"
            ],
            "cpp": [
                "points",
                "s"
            ],
            "go": [],
            "js": []
        }
    },
    "3144": {
        "description": "给你一个字符串 s ，你需要将它分割成一个或者更多的 平衡 子字符串。比方说，s == \"ababcc\" 那么 (\"abab\", \"c\", \"c\") ，(\"ab\", \"abc\", \"c\") 和 (\"ababcc\") 都是合法分割，但是 (\"a\", \"bab\", \"cc\") ，(\"aba\", \"bc\", \"c\") 和 (\"ab\", \"abcc\") 不是，不平衡的子字符串用粗体表示。\n请你返回 s 最少 能分割成多少个平衡子字符串。\n注意：一个 平衡 字符串指的是字符串中所有字符出现的次数都相同。",
        "difficulty_level": "Middle",
        "note": "1 <= s.length <= 1000\ns 只包含小写英文字母。",
        "codes": {
            "python": "class Solution:\n    def minimumSubstringsInPartition(self, s: str) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i < 0:\n                return 0\n            res = inf\n            cnt = defaultdict(int)\n            max_cnt = 0\n            for j in range(i, -1, -1):\n                cnt[s[j]] += 1\n                max_cnt = max(max_cnt, cnt[s[j]])\n                if i - j + 1 == len(cnt) * max_cnt:\n                    res = min(res, dfs(j - 1) + 1)\n            return res\n        return dfs(len(s) - 1)\n",
            "java": "public class Solution {\n    public int minimumSubstringsInPartition(String S) {\n        char[] s = S.toCharArray();\n        int n = s.length;\n        int[] memo = new int[n];\n        Arrays.fill(memo, -1); // -1 表示没有计算过\n        return dfs(n - 1, s, memo);\n    }\n\n    private int dfs(int i, char[] s, int[] memo) {\n        if (i < 0) {\n            return 0;\n        }\n        if (memo[i] != -1) { // 之前计算过\n            return memo[i];\n        }\n        int res = Integer.MAX_VALUE;\n        int[] cnt = new int[26];\n        int k = 0, maxCnt = 0;\n        for (int j = i; j >= 0; j--) {\n            k += cnt[s[j] - 'a']++ == 0 ? 1 : 0;\n            maxCnt = Math.max(maxCnt, cnt[s[j] - 'a']);\n            if (i - j + 1 == k * maxCnt) {\n                res = Math.min(res, dfs(j - 1, s, memo) + 1);\n            }\n        }\n        memo[i] = res; // 记忆化\n        return res;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumSubstringsInPartition(string s) {\n        int n = s.length();\n        vector<int> memo(n, -1); // -1 表示没有计算过\n        function<int(int)> dfs = [&](int i) -> int {\n            if (i < 0) {\n                return 0;\n            }\n            int& res = memo[i]; // 注意这里是引用\n            if (res != -1) { // 之前计算过\n                return res;\n            }\n            res = INT_MAX;\n            int cnt[26]{}, k = 0, max_cnt = 0;\n            for (int j = i; j >= 0; j--) {\n                k += cnt[s[j] - 'a']++ == 0;\n                max_cnt = max(max_cnt, cnt[s[j] - 'a']);\n                if (i - j + 1 == k * max_cnt) {\n                    res = min(res, dfs(j - 1) + 1);\n                }\n            }\n            return res;\n        };\n        return dfs(n - 1);\n    }\n};\n",
            "go": "func minimumSubstringsInPartition(s string) int {\nn := len(s)\nmemo := make([]int, n)\nfor i := range memo {\nmemo[i] = -1 // -1 表示没有计算过\n}\nvar dfs func(int) int\ndfs = func(i int) int {\nif i < 0 {\nreturn 0\n}\np := &memo[i]\nif *p != -1 { // 之前计算过\nreturn *p\n}\nres := math.MaxInt\ncnt := [26]int{}\nk, maxCnt := 0, 0\nfor j := i; j >= 0; j-- {\nb := s[j] - 'a'\nif cnt[b] == 0 {\nk++\n}\ncnt[b]++\nmaxCnt = max(maxCnt, cnt[b])\nif i-j+1 == k*maxCnt {\nres = min(res, dfs(j-1)+1)\n}\n}\n*p = res // 记忆化\nreturn res\n}\nreturn dfs(n - 1)\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"\\\"fabccddg\\\"\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"\\\"abababaccddb\\\"\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumSubstringsInPartition(String s) {",
            "cpp": "class Solution {\npublic:\n    int minimumSubstringsInPartition(string s) {",
            "go": "func minimumSubstringsInPartition(s string) int {\n\n}",
            "js": "/**\n * @param {string} s\n * @return {number}\n */\nvar minimumSubstringsInPartition = function(s) {",
            "python": "class Solution:\n    def minimumSubstringsInPartition(self, s: str) -> int:"
        },
        "time": "20240511",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumSubstringsInPartition",
            "java": "minimumSubstringsInPartition",
            "cpp": "minimumSubstringsInPartition",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumSubstringsInPartition(\"fabccddg\") == 3, \"Test 1 Error!\"\nassert my_solution.minimumSubstringsInPartition(\"abababaccddb\") == 2, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String s_1 = \"fabccddg\";\n    int ans_1 = 3;\n    assert solution.minimumSubstringsInPartition(s_1) == ans_1;\n    String s_2 = \"abababaccddb\";\n    int ans_2 = 2;\n    assert solution.minimumSubstringsInPartition(s_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string s_1 = \"fabccddg\";\n    int ans_1 = 3;\n    assert(my_solution_1.minimumSubstringsInPartition(s_1) == ans_1);\n    Solution my_solution_2;\n    string s_2 = \"abababaccddb\";\n    int ans_2 = 2;\n    assert(my_solution_2.minimumSubstringsInPartition(s_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "s"
            ],
            "java": [
                "s"
            ],
            "cpp": [
                "s"
            ],
            "go": [],
            "js": []
        }
    },
    "3145": {
        "description": "一个整数 x 的 强数组 指的是满足和为 x 的二的幂的最短有序数组。比方说，11 的强数组为 [1, 2, 8] 。\n我们将每一个正整数 i （即1，2，3等等）的 强数组 连接得到数组 big_nums ，big_nums 开始部分为 [\\underline{1}, \\underline{2}, \\underline{1, 2}, \\underline{4}, \\underline{1, 4}, \\underline{2, 4}, \\underline{1, 2, 4}, 8, ...] 。\n给你一个二维整数数组 queries ，其中 queries[i] = [from_i, to_i, mod_i] ，你需要计算 (big_nums[from_i] * big_nums[from_i + 1] * ... * big_nums[to_i]) % mod_i 。\n请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。",
        "difficulty_level": "Hard",
        "note": "1 <= queries.length <= 500\nqueries[i].length == 3\n0 <= queries[i][0] <= queries[i][1] <= 10^15\n1 <= queries[i][2] <= 10^5",
        "codes": {
            "python": "class Solution:\n    def findProductsOfElements(self, queries: List[List[int]]) -> List[int]:\n        def sum_e(k: int) -> int:\n            res = n = cnt1 = sum_i = 0\n            for i in range((k + 1).bit_length() - 1, 0, -1):\n                c = (cnt1 << i) + (i << (i - 1))  # 新增的幂次个数\n                if c <= k:\n                    k -= c\n                    res += (sum_i << i) + ((i * (i - 1) // 2) << (i - 1))\n                    sum_i += i  # 之前填的 1 的幂次之和\n                    cnt1 += 1  # 之前填的 1 的个数\n                    n |= 1 << i  # 填 1\n            # 最低位单独计算\n            if cnt1 <= k:\n                k -= cnt1\n                res += sum_i\n                n += 1  # 填 1\n            # 剩余的 k 个幂次，由 n 的低 k 个 1 补充\n            for _ in range(k):\n                lb = n & -n\n                res += lb.bit_length() - 1\n                n ^= lb\n            return res\n        return [pow(2, sum_e(r + 1) - sum_e(l), mod) for l, r, mod in queries]\n",
            "java": "class Solution {\n    public int[] findProductsOfElements(long[][] queries) {\n        int[] ans = new int[queries.length];\n        for (int i = 0; i < queries.length; i++) {\n            long[] q = queries[i];\n            long er = sumE(q[1] + 1);\n            long el = sumE(q[0]);\n            ans[i] = pow(2, er - el, q[2]);\n        }\n        return ans;\n    }\n\n    private long sumE(long k) {\n        long res = 0, n = 0, cnt1 = 0, sumI = 0;\n        for (long i = 63 - Long.numberOfLeadingZeros(k + 1); i > 0; i--) {\n            long c = (cnt1 << i) + (i << (i - 1)); // 新增的幂次个数\n            if (c <= k) {\n                k -= c;\n                res += (sumI << i) + ((i * (i - 1) / 2) << (i - 1));\n                sumI += i; // 之前填的 1 的幂次之和\n                cnt1++; // 之前填的 1 的个数\n                n |= 1L << i; // 填 1\n            }\n        }\n        // 最低位单独计算\n        if (cnt1 <= k) {\n            k -= cnt1;\n            res += sumI;\n            n++; // 填 1\n        }\n        // 剩余的 k 个幂次，由 n 的低 k 个 1 补充\n        while (k-- > 0) {\n            res += Long.numberOfTrailingZeros(n);\n            n &= n - 1;\n        }\n        return res;\n    }\n\n    private int pow(long x, long n, long mod) {\n        long res = 1 % mod;\n        for (; n > 0; n /= 2) {\n            if (n % 2 == 1) {\n                res = res * x % mod;\n            }\n            x = x * x % mod;\n        }\n        return (int) res;\n    }\n}\n",
            "cpp": "class Solution {\n    int pow(long long x, long long n, long long mod) {\n        long long res = 1 % mod;\n        for (; n; n /= 2) {\n            if (n % 2) {\n                res = res * x % mod;\n            }\n            x = x * x % mod;\n        }\n        return res;\n    }\n\n    long long sum_e(long long k) {\n        long long res = 0, n = 0, cnt1 = 0, sumI = 0;\n        for (long long i = 63 - __builtin_clzll(k + 1); i; i--) {\n            long long c = (cnt1 << i) + (i << (i - 1)); // 新增的幂次个数\n            if (c <= k) {\n                k -= c;\n                res += (sumI << i) + ((i * (i - 1) / 2) << (i - 1));\n                sumI += i; // 之前填的 1 的幂次之和\n                cnt1++; // 之前填的 1 的个数\n                n |= 1LL << i; // 填 1\n            }\n        }\n        // 最低位单独计算\n        if (cnt1 <= k) {\n            k -= cnt1;\n            res += sumI;\n            n++; // 填 1\n        }\n        // 剩余的 k 个幂次，由 n 的低 k 个 1 补充\n        while (k--) {\n            res += __builtin_ctzll(n);\n            n &= n - 1;\n        }\n        return res;\n    }\n\npublic:\n    vector<int> findProductsOfElements(vector<vector<long long>>& queries) {\n        vector<int> ans;\n        for (auto& q : queries) {\n            auto er = sum_e(q[1] + 1);\n            auto el = sum_e(q[0]);\n            ans.push_back(pow(2, er - el, q[2]));\n        }\n        return ans;\n    }\n};\n",
            "go": "func sumE(k int) (res int) {\nvar n, cnt1, sumI int\nfor i := bits.Len(uint(k+1)) - 1; i > 0; i-- {\nc := cnt1<<i + i<<(i-1) // 新增的幂次个数\nif c <= k {\nk -= c\nres += sumI<<i + i*(i-1)/2<<(i-1)\nsumI += i   // 之前填的 1 的幂次之和\ncnt1++      // 之前填的 1 的个数\nn |= 1 << i // 填 1\n}\n}\n// 最低位单独计算\nif cnt1 <= k {\nk -= cnt1\nres += sumI\nn++ // 填 1\n}\n// 剩余的 k 个幂次，由 n 的低 k 个 1 补充\nfor ; k > 0; k-- {\nres += bits.TrailingZeros(uint(n))\nn &= n - 1\n}\nreturn\n}\n\nfunc findProductsOfElements(queries [][]int64) []int {\nans := make([]int, len(queries))\nfor i, q := range queries {\ner := sumE(int(q[1]) + 1)\nel := sumE(int(q[0]))\nans[i] = pow(2, er-el, int(q[2]))\n}\nreturn ans\n}\n\nfunc pow(x, n, mod int) int {\nres := 1 % mod\nfor ; n > 0; n /= 2 {\nif n%2 > 0 {\nres = res * x % mod\n}\nx = x * x % mod\n}\nreturn res\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[[1,3,7]]\"]",
                "output": "[\"[4]\"]"
            },
            {
                "input": "[\"[[2,5,3],[7,7,4]]\"]",
                "output": "[\"[2,2]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int[] findProductsOfElements(long[][] queries) {",
            "cpp": "class Solution {\npublic:\n    vector<int> findProductsOfElements(vector<vector<long long>>& queries) {",
            "go": "func findProductsOfElements(queries [][]int64) []int {\n\n}",
            "js": "/**\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar findProductsOfElements = function(queries) {",
            "python": "class Solution:\n    def findProductsOfElements(self, queries: List[List[int]]) -> List[int]:"
        },
        "time": "20240511",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "findProductsOfElements",
            "java": "findProductsOfElements",
            "cpp": "findProductsOfElements",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.findProductsOfElements([[1,3,7]]) == [4], \"Test 1 Error!\"\nassert my_solution.findProductsOfElements([[2,5,3],[7,7,4]]) == [2,2], \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    long[][] queries_1 = {{1,3,7}};\n    int[] ans_1 = {4};\n    assert Arrays.equals(solution.findProductsOfElements(queries_1), ans_1);\n    long[][] queries_2 = {{2,5,3},{7,7,4}};\n    int[] ans_2 = {2,2};\n    assert Arrays.equals(solution.findProductsOfElements(queries_2), ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<long long>> queries_1 = {{1,3,7}};\n    vector<int> ans_1 = {4};\n    assert(my_solution_1.findProductsOfElements(queries_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<long long>> queries_2 = {{2,5,3},{7,7,4}};\n    vector<int> ans_2 = {2,2};\n    assert(my_solution_2.findProductsOfElements(queries_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "queries"
            ],
            "java": [
                "queries"
            ],
            "cpp": [
                "queries"
            ],
            "go": [],
            "js": []
        }
    },
    "3158": {
        "description": "给你一个数组 nums ，数组中的数字 要么 出现一次，要么 出现两次。\n请你返回数组中所有出现两次数字的按位 XOR 值，如果没有数字出现过两次，返回 0 。",
        "difficulty_level": "Easy",
        "note": "1 <= nums.length <= 50\n1 <= nums[i] <= 50\nnums 中每个数字要么出现过一次，要么出现过两次。",
        "codes": {
            "python": "class Solution:\n    def duplicateNumbersXOR(self, nums: List[int]) -> int:\n        ans = vis = 0\n        for x in nums:\n            if vis >> x & 1:\n                ans ^= x\n            else:\n                vis |= 1 << x\n        return ans\n",
            "java": "class Solution {\n    public int duplicateNumbersXOR(int[] nums) {\n        int ans = 0;\n        long vis = 0;\n        for (int x : nums) {\n            if ((vis >> x & 1) > 0) {\n                ans ^= x;\n            } else {\n                vis |= 1L << x;\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int duplicateNumbersXOR(vector<int>& nums) {\n        int ans = 0;\n        long long vis = 0;\n        for (int x : nums) {\n            if (vis >> x & 1) {\n                ans ^= x;\n            } else {\n                vis |= 1LL << x;\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "func duplicateNumbersXOR(nums []int) (ans int) {\nvis := 0\nfor _, x := range nums {\nif vis>>x&1 > 0 {\nans ^= x\n} else {\nvis |= 1 << x\n}\n}\nreturn\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar duplicateNumbersXOR = function (nums) {\n    let map = new Map(), res = 0;\n    nums.forEach(item => map.has(item) ? res ^= item : map.set(item, 1))\n    return res\n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,2,1,3]\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"[1,2,3]\"]",
                "output": "[\"0\"]"
            },
            {
                "input": "[\"[1,2,2,1]\"]",
                "output": "[\"3\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int duplicateNumbersXOR(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    int duplicateNumbersXOR(vector<int>& nums) {",
            "go": "func duplicateNumbersXOR(nums []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar duplicateNumbersXOR = function(nums) {",
            "python": "class Solution:\n    def duplicateNumbersXOR(self, nums: List[int]) -> int:"
        },
        "time": "20240525",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "duplicateNumbersXOR",
            "java": "duplicateNumbersXOR",
            "cpp": "duplicateNumbersXOR",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.duplicateNumbersXOR([1,2,1,3]) == 1, \"Test 1 Error!\"\nassert my_solution.duplicateNumbersXOR([1,2,3]) == 0, \"Test 2 Error!\"\nassert my_solution.duplicateNumbersXOR([1,2,2,1]) == 3, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,1,3};\n    int ans_1 = 1;\n    assert solution.duplicateNumbersXOR(nums_1) == ans_1;\n    int[] nums_2 = {1,2,3};\n    int ans_2 = 0;\n    assert solution.duplicateNumbersXOR(nums_2) == ans_2;\n    int[] nums_3 = {1,2,2,1};\n    int ans_3 = 3;\n    assert solution.duplicateNumbersXOR(nums_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,1,3};\n    int ans_1 = 1;\n    assert(my_solution_1.duplicateNumbersXOR(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,2,3};\n    int ans_2 = 0;\n    assert(my_solution_2.duplicateNumbersXOR(nums_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {1,2,2,1};\n    int ans_3 = 3;\n    assert(my_solution_3.duplicateNumbersXOR(nums_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3159": {
        "description": "给你一个整数数组 nums ，一个整数数组 queries 和一个整数 x 。\n对于每个查询 queries[i] ，你需要找到 nums 中第 queries[i] 个 x 的位置，并返回它的下标。如果数组中 x 的出现次数少于 queries[i] ，该查询的答案为 -1 。\n请你返回一个整数数组 answer ，包含所有查询的答案。",
        "difficulty_level": "Middle",
        "note": "1 <= nums.length, queries.length <= 10^5\n1 <= queries[i] <= 10^5\n1 <= nums[i], x <= 10^4",
        "codes": {
            "python": "class Solution:\n    def occurrencesOfElement(self, nums: List[int], queries: List[int], x: int) -> List[int]:\n        pos = [i for i, v in enumerate(nums) if v == x]\n        return [-1 if q > len(pos) else pos[q - 1] for q in queries]\n",
            "java": "public class Solution {\n    public int[] occurrencesOfElement(int[] nums, int[] queries, int x) {\n        List<Integer> pos = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == x) {\n                pos.add(i);\n            }\n        }\n        for (int i = 0; i < queries.length; i++) {\n            if (queries[i] > pos.size()) {\n                queries[i] = -1;\n            } else {\n                queries[i] = pos.get(queries[i] - 1);\n            }\n        }\n        return queries;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    vector<int> occurrencesOfElement(vector<int>& nums, vector<int>& queries, int x) {\n        vector<int> pos;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == x) {\n                pos.push_back(i);\n            }\n        }\n        for (int& q : queries) {\n            if (q > pos.size()) {\n                q = -1;\n            } else {\n                q = pos[q - 1];\n            }\n        }\n        return queries;\n    }\n};\n",
            "go": "func occurrencesOfElement(nums, queries []int, x int) []int {\npos := []int{}\nfor i, v := range nums {\nif v == x {\npos = append(pos, i)\n}\n}\nfor i, q := range queries {\nif q > len(pos) {\nqueries[i] = -1\n} else {\nqueries[i] = pos[q-1]\n}\n}\nreturn queries\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @param {number} x\n * @return {number[]}\n */\nvar occurrencesOfElement = function (nums, queries, x) {\n    const l = nums.length\n    let res = [];\n    let positions = [];\n    let currentCount = 0;\n\n    for (let j = 0; j < queries.length; j++) {\n        let query = queries[j];\n        if (query <= positions.length) {\n            res.push(positions[query - 1]);\n            continue;\n        }\n        while (currentCount < l && l - currentCount + positions.length >= query) {\n            if (nums[currentCount] === x) {\n                positions.push(currentCount);\n            }\n            currentCount++;\n            if (positions.length === query) {\n                res.push(positions[query - 1]);\n                break;\n            }\n        }\n        if (positions.length < query) {\n            res.push(-1);\n        }\n    }\n\n    return res;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,3,1,7]\",\"[1,3,2,4]\",\"1\"]",
                "output": "[\"[0,-1,2,-1]\"]"
            },
            {
                "input": "[\"[1,2,3]\",\"[10]\",\"5\"]",
                "output": "[\"[-1]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int[] occurrencesOfElement(int[] nums, int[] queries, int x) {",
            "cpp": "class Solution {\npublic:\n    vector<int> occurrencesOfElement(vector<int>& nums, vector<int>& queries, int x) {",
            "go": "func occurrencesOfElement(nums []int, queries []int, x int) []int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number[]} queries\n * @param {number} x\n * @return {number[]}\n */\nvar occurrencesOfElement = function(nums, queries, x) {",
            "python": "class Solution:\n    def occurrencesOfElement(self, nums: List[int], queries: List[int], x: int) -> List[int]:"
        },
        "time": "20240525",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "occurrencesOfElement",
            "java": "occurrencesOfElement",
            "cpp": "occurrencesOfElement",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.occurrencesOfElement([1,3,1,7], [1,3,2,4], 1) == [0,-1,2,-1], \"Test 1 Error!\"\nassert my_solution.occurrencesOfElement([1,2,3], [10], 5) == [-1], \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,3,1,7};\n    int[] queries_1 = {1,3,2,4};\n    int x_1 = 1;\n    int[] ans_1 = {0,-1,2,-1};\n    assert Arrays.equals(solution.occurrencesOfElement(nums_1, queries_1, x_1), ans_1);\n    int[] nums_2 = {1,2,3};\n    int[] queries_2 = {10};\n    int x_2 = 5;\n    int[] ans_2 = {-1};\n    assert Arrays.equals(solution.occurrencesOfElement(nums_2, queries_2, x_2), ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,3,1,7};\n    vector<int> queries_1 = {1,3,2,4};\n    int x_1 = 1;\n    vector<int> ans_1 = {0,-1,2,-1};\n    assert(my_solution_1.occurrencesOfElement(nums_1, queries_1, x_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,2,3};\n    vector<int> queries_2 = {10};\n    int x_2 = 5;\n    vector<int> ans_2 = {-1};\n    assert(my_solution_2.occurrencesOfElement(nums_2, queries_2, x_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "queries",
                "x"
            ],
            "java": [
                "nums",
                "queries",
                "x"
            ],
            "cpp": [
                "nums",
                "queries",
                "x"
            ],
            "go": [],
            "js": []
        }
    },
    "3160": {
        "description": "给你一个整数 limit 和一个大小为 n x 2 的二维数组 queries 。\n总共有 limit + 1 个球，每个球的编号为 [0, limit] 中一个 互不相同 的数字。一开始，所有球都没有颜色。queries 中每次操作的格式为 [x, y] ，你需要将球 x 染上颜色 y 。每次操作之后，你需要求出所有球中 不同 颜色的数目。\n请你返回一个长度为 n 的数组 result ，其中 result[i] 是第 i 次操作以后不同颜色的数目。\n注意 ，没有染色的球不算作一种颜色。",
        "difficulty_level": "Middle",
        "note": "1 <= limit <= 10^9\n1 <= n == queries.length <= 10^5\nqueries[i].length == 2\n0 <= queries[i][0] <= limit\n1 <= queries[i][1] <= 10^9",
        "codes": {
            "python": "class Solution:\n    def queryResults(self, _: int, queries: List[List[int]]) -> List[int]:\n        ans = []\n        color = {}\n        cnt = defaultdict(int)\n        for x, y in queries:\n            if x in color:\n                c = color[x]\n                cnt[c] -= 1\n                if cnt[c] == 0:\n                    del cnt[c]\n            color[x] = y\n            cnt[y] += 1\n            ans.append(len(cnt))\n        return ans\n",
            "java": "public class Solution {\n    public int[] queryResults(int limit, int[][] queries) {\n        int[] ans = new int[queries.length];\n        Map<Integer, Integer> color = new HashMap<>();\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int i = 0; i < queries.length; i++) {\n            int[] q = queries[i];\n            int x = q[0];\n            int y = q[1];\n            if (color.containsKey(x)) {\n                int c = color.get(x);\n                if (cnt.merge(c, -1, Integer::sum) == 0) {\n                    cnt.remove(c);\n                }\n            }\n            color.put(x, y);\n            cnt.merge(y, 1, Integer::sum);\n            ans[i] = cnt.size();\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    vector<int> queryResults(int, vector<vector<int>>& queries) {\n        vector<int> ans;\n        unordered_map<int, int> color, cnt;\n        for (auto& q : queries) {\n            int x = q[0], y = q[1];\n            if (auto it = color.find(x); it != color.end()) {\n                int c = it->second;\n                if (--cnt[c] == 0) {\n                    cnt.erase(c);\n                }\n            }\n            color[x] = y;\n            cnt[y]++;\n            ans.push_back(cnt.size());\n        }\n        return ans;\n    }\n};\n",
            "go": "func queryResults(_ int, queries [][]int) []int {\nans := make([]int, len(queries))\ncolor := map[int]int{}\ncnt := map[int]int{}\nfor i, q := range queries {\nx, y := q[0], q[1]\nif c := color[x]; c > 0 {\ncnt[c]--\nif cnt[c] == 0 {\ndelete(cnt, c)\n}\n}\ncolor[x] = y\ncnt[y]++\nans[i] = len(cnt)\n}\nreturn ans\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"4\",\"[[1,4],[2,5],[1,3],[3,4]]\"]",
                "output": "[\"[1,2,2,3]\"]"
            },
            {
                "input": "[\"4\",\"[[0,1],[1,2],[2,2],[3,4],[4,5]]\"]",
                "output": "[\"[1,2,2,3,4]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int[] queryResults(int limit, int[][] queries) {",
            "cpp": "class Solution {\npublic:\n    vector<int> queryResults(int limit, vector<vector<int>>& queries) {",
            "go": "func queryResults(limit int, queries [][]int) []int {\n\n}",
            "js": "/**\n * @param {number} limit\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar queryResults = function(limit, queries) {",
            "python": "class Solution:\n    def queryResults(self, limit: int, queries: List[List[int]]) -> List[int]:"
        },
        "time": "20240525",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "queryResults",
            "java": "queryResults",
            "cpp": "queryResults",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.queryResults(4, [[1,4],[2,5],[1,3],[3,4]]) == [1,2,2,3], \"Test 1 Error!\"\nassert my_solution.queryResults(4, [[0,1],[1,2],[2,2],[3,4],[4,5]]) == [1,2,2,3,4], \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int limit_1 = 4;\n    int[][] queries_1 = {{1,4},{2,5},{1,3},{3,4}};\n    int[] ans_1 = {1,2,2,3};\n    assert Arrays.equals(solution.queryResults(limit_1, queries_1), ans_1);\n    int limit_2 = 4;\n    int[][] queries_2 = {{0,1},{1,2},{2,2},{3,4},{4,5}};\n    int[] ans_2 = {1,2,2,3,4};\n    assert Arrays.equals(solution.queryResults(limit_2, queries_2), ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int limit_1 = 4;\n    vector<vector<int>> queries_1 = {{1,4},{2,5},{1,3},{3,4}};\n    vector<int> ans_1 = {1,2,2,3};\n    assert(my_solution_1.queryResults(limit_1, queries_1) == ans_1);\n    Solution my_solution_2;\n    int limit_2 = 4;\n    vector<vector<int>> queries_2 = {{0,1},{1,2},{2,2},{3,4},{4,5}};\n    vector<int> ans_2 = {1,2,2,3,4};\n    assert(my_solution_2.queryResults(limit_2, queries_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "limit",
                "queries"
            ],
            "java": [
                "limit",
                "queries"
            ],
            "cpp": [
                "limit",
                "queries"
            ],
            "go": [],
            "js": []
        }
    },
    "3161": {
        "description": "有一条无限长的数轴，原点在 0 处，沿着 x 轴 正 方向无限延伸。\n给你一个二维数组 queries ，它包含两种操作：\n操作类型 1 ：queries[i] = [1, x] 。在距离原点 x 处建一个障碍物。数据保证当操作执行的时候，位置 x 处 没有 任何障碍物。\n操作类型 2 ：queries[i] = [2, x, sz] 。判断在数轴范围 [0, x] 内是否可以放置一个长度为 sz 的物块，这个物块需要 完全 放置在范围 [0, x] 内。如果物块与任何障碍物有重合，那么这个物块 不能 被放置，但物块可以与障碍物刚好接触。注意，你只是进行查询，并 不是 真的放置这个物块。每个查询都是相互独立的。\n请你返回一个 boolean 数组results ，如果第 i 个操作类型 2 的操作你可以放置物块，那么 results[i] 为 true ，否则为 false 。",
        "difficulty_level": "Hard",
        "note": "1 <= queries.length <= 15 * 10^4\n2 <= queries[i].length <= 3\n1 <= queries[i][0] <= 2\n1 <= x, sz <= min(5 * 10^4, 3 * queries.length)\n输入保证操作 1 中，x 处不会有障碍物。\n输入保证至少有一个操作类型 2 。",
        "codes": {
            "python": "from sortedcontainers import SortedList\n\nclass Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:\n        m = max(q[1] for q in queries) + 1\n        t = [0] * (2 << m.bit_length())\n\n        # 把 i 处的值改成 val\n        def update(o: int, l: int, r: int, i: int, val: int) -> None:\n            if l == r:\n                t[o] = val\n                return\n            m = (l + r) // 2\n            if i <= m:\n                update(o * 2, l, m, i, val)\n            else:\n                update(o * 2 + 1, m + 1, r, i, val)\n            t[o] = max(t[o * 2], t[o * 2 + 1])\n\n        # 查询 [0,R] 中的最大值\n        def query(o: int, l: int, r: int, R: int) -> int:\n            if r <= R:\n                return t[o]\n            m = (l + r) // 2\n            if R <= m:\n                return query(o * 2, l, m, R)\n            return max(t[o * 2], query(o * 2 + 1, m + 1, r, R))\n\n        sl = SortedList([0, m])  # 哨兵\n        ans = []\n        for q in queries:\n            x = q[1]\n            i = sl.bisect_left(x)\n            pre = sl[i - 1]  # x 左侧最近障碍物的位置\n            if q[0] == 1:\n                nxt = sl[i]  # x 右侧最近障碍物的位置\n                sl.add(x)\n                update(1, 0, m, x, x - pre)    # 更新 d[x] = x - pre\n                update(1, 0, m, nxt, nxt - x)  # 更新 d[nxt] = nxt - x\n            else:\n                # 最大长度要么是 [0,pre] 中的最大 d，要么是 [pre,x] 这一段的长度\n                max_gap = max(query(1, 0, m, pre), x - pre)\n                ans.append(max_gap >= q[2])\n        return ans\n",
            "java": "class Solution {\n    public List<Boolean> getResults(int[][] queries) {\n        int m = 0;\n        for (int[] q : queries) {\n            m = Math.max(m, q[1]);\n        }\n        m++;\n\n        TreeSet<Integer> set = new TreeSet<>(List.of(0, m)); // 哨兵\n        int[] t = new int[2 << (32 - Integer.numberOfLeadingZeros(m))];\n\n        List<Boolean> ans = new ArrayList<>();\n        for (int[] q : queries) {\n            int x = q[1];\n            int pre = set.floor(x - 1); // x 左侧最近障碍物的位置\n            if (q[0] == 1) {\n                int nxt = set.ceiling(x); // x 右侧最近障碍物的位置\n                set.add(x);\n                update(t, 1, 0, m, x, x - pre);   // 更新 d[x] = x - pre\n                update(t, 1, 0, m, nxt, nxt - x); // 更新 d[nxt] = nxt - x\n            } else {\n                // 最大长度要么是 [0,pre] 中的最大 d，要么是 [pre,x] 这一段的长度\n                int maxGap = Math.max(query(t, 1, 0, m, pre), x - pre);\n                ans.add(maxGap >= q[2]);\n            }\n        }\n        return ans;\n    }\n\n    // 把 i 处的值改成 val\n    private void update(int[] t, int o, int l, int r, int i, int val) {\n        if (l == r) {\n            t[o] = val;\n            return;\n        }\n        int m = (l + r) / 2;\n        if (i <= m) {\n            update(t, o * 2, l, m, i, val);\n        } else {\n            update(t, o * 2 + 1, m + 1, r, i, val);\n        }\n        t[o] = Math.max(t[o * 2], t[o * 2 + 1]);\n    }\n\n    // 查询 [0,R] 中的最大值\n    private int query(int[] t, int o, int l, int r, int R) {\n        if (r <= R) {\n            return t[o];\n        }\n        int m = (l + r) / 2;\n        if (R <= m) {\n            return query(t, o * 2, l, m, R);\n        }\n        return Math.max(t[o * 2], query(t, o * 2 + 1, m + 1, r, R));\n    }\n}\n",
            "cpp": "class Solution {\n    vector<int> t;\n\n    // 把 i 处的值改成 val\n    void update(int o, int l, int r, int i, int val) {\n        if (l == r) {\n            t[o] = val;\n            return;\n        }\n        int m = (l + r) / 2;\n        if (i <= m) {\n            update(o * 2, l, m, i, val);\n        } else {\n            update(o * 2 + 1, m + 1, r, i, val);\n        }\n        t[o] = max(t[o * 2], t[o * 2 + 1]);\n    }\n\n    // 查询 [0,R] 中的最大值\n    int query(int o, int l, int r, int R) {\n        if (r <= R) {\n            return t[o];\n        }\n        int m = (l + r) / 2;\n        if (R <= m) {\n            return query(o * 2, l, m, R);\n        }\n        return max(t[o * 2], query(o * 2 + 1, m + 1, r, R));\n    }\n\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {\n        int m = 0;\n        for (auto& q : queries) {\n            m = max(m, q[1]);\n        }\n        m++;\n\n        set<int> st{0, m}; // 哨兵\n        t.resize(2 << (32 - __builtin_clz(m)));\n\n        vector<bool> ans;\n        for (auto& q : queries) {\n            int x = q[1];\n            auto it = st.lower_bound(x);\n            int pre = *prev(it); // x 左侧最近障碍物的位置\n            if (q[0] == 1) {\n                int nxt = *it; // x 右侧最近障碍物的位置\n                st.insert(x);\n                update(1, 0, m, x, x - pre);   // 更新 d[x] = x - pre\n                update(1, 0, m, nxt, nxt - x); // 更新 d[nxt] = nxt - x\n            } else {\n                // 最大长度要么是 [0,pre] 中的最大 d，要么是 [pre,x] 这一段的长度\n                int max_gap = max(query(1, 0, m, pre), x - pre);\n                ans.push_back(max_gap >= q[2]);\n            }\n        }\n        return ans;\n    }\n};\n",
            "go": "type seg []int\n\n// 把 i 处的值改成 val\nfunc (t seg) update(o, l, r, i, val int) {\nif l == r {\nt[o] = val\nreturn\n}\nm := (l + r) >> 1\nif i <= m {\nt.update(o<<1, l, m, i, val)\n} else {\nt.update(o<<1|1, m+1, r, i, val)\n}\nt[o] = max(t[o<<1], t[o<<1|1])\n}\n\n// 查询 [0,R] 中的最大值\nfunc (t seg) query(o, l, r, R int) int {\nif r <= R {\nreturn t[o]\n}\nm := (l + r) >> 1\nif R <= m {\nreturn t.query(o<<1, l, m, R)\n}\nreturn max(t[o<<1], t.query(o<<1|1, m+1, r, R))\n}\n\nfunc getResults(queries [][]int) (ans []bool) {\nm := 0\nfor _, q := range queries {\nm = max(m, q[1])\n}\nm++\n\nset := redblacktree.New[int, struct{}]()\nset.Put(0, struct{}{}) // 哨兵\nset.Put(m, struct{}{})\nt := make(seg, 2<<bits.Len(uint(m)))\n\nfor _, q := range queries {\nx := q[1]\n        pre, _ := set.Floor(x - 1) // x 左侧最近障碍物的位置\nif q[0] == 1 {\nnxt, _ := set.Ceiling(x) // x 右侧最近障碍物的位置\nset.Put(x, struct{}{})\nt.update(1, 0, m, x, x-pre.Key)       // 更新 d[x] = x - pre\nt.update(1, 0, m, nxt.Key, nxt.Key-x) // 更新 d[nxt] = nxt - x\n} else {\n// 最大长度要么是 [0,pre] 中的最大 d，要么是 [pre,x] 这一段的长度\nmaxGap := max(t.query(1, 0, m, pre.Key), x-pre.Key)\nans = append(ans, maxGap >= q[2])\n}\n}\nreturn\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[[1,2],[2,3,3],[2,3,1],[2,2,2]]\"]",
                "output": "[\"[false,true,true]\"]"
            },
            {
                "input": "[\"[[1,7],[2,7,6],[1,2],[2,7,5],[2,7,6]]\"]",
                "output": "[\"[true,true,false]\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public List<Boolean> getResults(int[][] queries) {",
            "cpp": "class Solution {\npublic:\n    vector<bool> getResults(vector<vector<int>>& queries) {",
            "go": "func getResults(queries [][]int) []bool {\n\n}",
            "js": "/**\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nvar getResults = function(queries) {",
            "python": "class Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:"
        },
        "time": "20240525",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "getResults",
            "java": "getResults",
            "cpp": "getResults",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.getResults([[1,2],[2,3,3],[2,3,1],[2,2,2]]) == [False,True,True], \"Test 1 Error!\"\nassert my_solution.getResults([[1,7],[2,7,6],[1,2],[2,7,5],[2,7,6]]) == [True,True,False], \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[][] queries_1 = {{1,2},{2,3,3},{2,3,1},{2,2,2}};\n    List<Boolean> ans_1 = [false,true,true];\n    assert solution.getResults(queries_1).equals(ans_1);\n    int[][] queries_2 = {{1,7},{2,7,6},{1,2},{2,7,5},{2,7,6}};\n    List<Boolean> ans_2 = [true,true,false];\n    assert solution.getResults(queries_2).equals(ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<vector<int>> queries_1 = {{1,2},{2,3,3},{2,3,1},{2,2,2}};\n    vector<bool> ans_1 = {false,true,true};\n    assert(my_solution_1.getResults(queries_1) == ans_1);\n    Solution my_solution_2;\n    vector<vector<int>> queries_2 = {{1,7},{2,7,6},{1,2},{2,7,5},{2,7,6}};\n    vector<bool> ans_2 = {true,true,false};\n    assert(my_solution_2.getResults(queries_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "queries"
            ],
            "java": [
                "queries"
            ],
            "cpp": [
                "queries"
            ],
            "go": [],
            "js": []
        }
    },
    "3174": {
        "description": "给你一个字符串 s 。\n你的任务是重复以下操作删除 所有 数字字符：删除 第一个数字字符 以及它左边 最近 的 非数字 字符。\n请你返回删除所有数字字符以后剩下的字符串。",
        "difficulty_level": "Easy",
        "note": "1 <= s.length <= 100\ns 只包含小写英文字母和数字字符。\n输入保证所有数字都可以按以上操作被删除。",
        "codes": {
            "python": "class Solution:\n    def clearDigits(self, s: str) -> str:\n        st = []\n        for c in s:\n            if c.isdigit():\n                st.pop()\n            else:\n                st.append(c)\n        return ''.join(st)\n",
            "java": "class Solution {\n    public String clearDigits(String s) {\n        StringBuilder st = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                st.deleteCharAt(st.length() - 1);\n            } else {\n                st.append(c);\n            }\n        }\n        return st.toString();\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    string clearDigits(string s) {\n        string st;\n        for (char c : s) {\n            if (isdigit(c)) {\n                st.pop_back();\n            } else {\n                st += c;\n            }\n        }\n        return st;\n    }\n};\n",
            "go": "func clearDigits(s string) string {\nst := []rune{}\nfor _, c := range s {\nif unicode.IsDigit(c) {\nst = st[:len(st)-1]\n} else {\nst = append(st, c)\n}\n}\nreturn string(st)\n}\n",
            "js": "/**\n * @param {string} s\n * @return {string}\n */\nvar clearDigits = function(s) {\n    let stack = []\n    for(let item of s){\n        if(item < '0' || item > '9')\n        stack.push(item)\n        else if(stack[stack.length-1] < '0' || stack[stack.length-1] > '9')\n        stack.pop()\n    }\n    return stack.join('')\n};\n"
        },
        "cases": [
            {
                "input": "[\"\\\"abc\\\"\"]",
                "output": "[\"\\\"abc\\\"\"]"
            },
            {
                "input": "[\"\\\"cb34\\\"\"]",
                "output": "[\"\\\"\\\"\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public String clearDigits(String s) {",
            "cpp": "class Solution {\npublic:\n    string clearDigits(string s) {",
            "go": "func clearDigits(s string) string {\n\n}",
            "js": "/**\n * @param {string} s\n * @return {string}\n */\nvar clearDigits = function(s) {",
            "python": "class Solution:\n    def clearDigits(self, s: str) -> str:"
        },
        "time": "20240608",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "clearDigits",
            "java": "clearDigits",
            "cpp": "clearDigits",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.clearDigits(\"abc\") == \"abc\", \"Test 1 Error!\"\nassert my_solution.clearDigits(\"cb34\") == \"\", \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    String s_1 = \"abc\";\n    String ans_1 = \"abc\";\n    assert solution.clearDigits(s_1).equals(ans_1);\n    String s_2 = \"cb34\";\n    String ans_2 = \"\";\n    assert solution.clearDigits(s_2).equals(ans_2);\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    string s_1 = \"abc\";\n    string ans_1 = \"abc\";\n    assert(my_solution_1.clearDigits(s_1) == ans_1);\n    Solution my_solution_2;\n    string s_2 = \"cb34\";\n    string ans_2 = \"\";\n    assert(my_solution_2.clearDigits(s_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "s"
            ],
            "java": [
                "s"
            ],
            "cpp": [
                "s"
            ],
            "go": [],
            "js": []
        }
    },
    "3175": {
        "description": "有 n 位玩家在进行比赛，玩家编号依次为 0 到 n - 1 。\n给你一个长度为 n 的整数数组 skills 和一个 正 整数 k ，其中 skills[i] 是第 i 位玩家的技能等级。skills 中所有整数 互不相同 。所有玩家从编号 0 到 n - 1 排成一列。\n比赛进行方式如下：\n队列中最前面两名玩家进行一场比赛，技能等级 更高 的玩家胜出。\n比赛后，获胜者保持在队列的开头，而失败者排到队列的末尾。\n这个比赛的赢家是 第一位连续 赢下 k 场比赛的玩家。\n请你返回这个比赛的赢家编号。",
        "difficulty_level": "Middle",
        "note": "n == skills.length\n2 <= n <= 10^5\n1 <= k <= 10^9\n1 <= skills[i] <= 10^6\nskills 中的整数互不相同。",
        "codes": {
            "python": "class Solution:\n    def findWinningPlayer(self, skills: List[int], k: int) -> int:\n        mx_i = 0\n        win = -1  # 对于 skills[0] 来说，需要连续 k+1 个回合都是最大值\n        for i, x in enumerate(skills):\n            if x > skills[mx_i]:  # 新的最大值\n                mx_i = i\n                win = 0\n            win += 1  # 获胜回合 +1\n            if win == k:\n                break\n        return mx_i\n",
            "java": "class Solution {\n    public int findWinningPlayer(int[] skills, int k) {\n        int mxI = 0;\n        int win = 0;\n        for (int i = 1; i < skills.length && win < k; i++) {\n            if (skills[i] > skills[mxI]) { // 新的最大值\n                mxI = i;\n                win = 0;\n            }\n            win++; // 获胜回合 +1\n        }\n        return mxI;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int findWinningPlayer(vector<int>& skills, int k) {\n        int mx_i = 0, win = 0;\n        for (int i = 1; i < skills.size() && win < k; i++) {\n            if (skills[i] > skills[mx_i]) { // 新的最大值\n                mx_i = i;\n                win = 0;\n            }\n            win++; // 获胜回合 +1\n        }\n        return mx_i;\n    }\n};\n",
            "go": "func findWinningPlayer(skills []int, k int) (mxI int) {\nwin := 0\nfor i := 1; i < len(skills) && win < k; i++ {\nif skills[i] > skills[mxI] { // 新的最大值\nmxI = i\nwin = 0\n}\nwin++ // 获胜回合 +1\n}\nreturn\n}\n",
            "js": "var findWinningPlayer = function(skills, k) {\n    let maxSkillIndex = skills[0] > skills[1] ? 0 : 1;\n    if (k === 1) {\n        return maxSkillIndex;\n    }\n    let consecutive = 1;\n    let n = skills.length;\n    for (let i = 2; i < n; i++) {\n        if (skills[maxSkillIndex] > skills[i]) {\n            consecutive++;\n            if (consecutive === k) {\n                return maxSkillIndex;\n            }\n        } else {\n            maxSkillIndex = i;\n            consecutive = 1;\n        }\n    }\n    return maxSkillIndex;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[4,2,6,3,9]\",\"2\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[2,5,4]\",\"3\"]",
                "output": "[\"1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int findWinningPlayer(int[] skills, int k) {",
            "cpp": "class Solution {\npublic:\n    int findWinningPlayer(vector<int>& skills, int k) {",
            "go": "func findWinningPlayer(skills []int, k int) int {\n\n}",
            "js": "/**\n * @param {number[]} skills\n * @param {number} k\n * @return {number}\n */\nvar findWinningPlayer = function(skills, k) {",
            "python": "class Solution:\n    def findWinningPlayer(self, skills: List[int], k: int) -> int:"
        },
        "time": "20240608",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "findWinningPlayer",
            "java": "findWinningPlayer",
            "cpp": "findWinningPlayer",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.findWinningPlayer([4,2,6,3,9], 2) == 2, \"Test 1 Error!\"\nassert my_solution.findWinningPlayer([2,5,4], 3) == 1, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] skills_1 = {4,2,6,3,9};\n    int k_1 = 2;\n    int ans_1 = 2;\n    assert solution.findWinningPlayer(skills_1, k_1) == ans_1;\n    int[] skills_2 = {2,5,4};\n    int k_2 = 3;\n    int ans_2 = 1;\n    assert solution.findWinningPlayer(skills_2, k_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> skills_1 = {4,2,6,3,9};\n    int k_1 = 2;\n    int ans_1 = 2;\n    assert(my_solution_1.findWinningPlayer(skills_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> skills_2 = {2,5,4};\n    int k_2 = 3;\n    int ans_2 = 1;\n    assert(my_solution_2.findWinningPlayer(skills_2, k_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "skills",
                "k"
            ],
            "java": [
                "skills",
                "k"
            ],
            "cpp": [
                "skills",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3176": {
        "description": "给你一个整数数组 nums 和一个 非负 整数 k 。如果一个整数序列 seq 满足在范围下标范围 [0, seq.length - 2] 中存在 不超过 k 个下标 i 满足 seq[i] != seq[i + 1] ，那么我们称这个整数序列为 好 序列。\n请你返回 nums 中 好 n子序列 的最长长度",
        "difficulty_level": "Middle",
        "note": "1 <= nums.length <= 500\n1 <= nums[i] <= 10^9\n0 <= k <= min(nums.length, 25)",
        "codes": {
            "python": "class Solution:\n    def maximumLength(self, nums: List[int], k: int) -> int:\n        fs = {}\n        records = [[0] * 3 for _ in range(k + 1)]\n        for x in nums:\n            if x not in fs:\n                fs[x] = [0] * (k + 1)\n            f = fs[x]\n            for j in range(k, -1, -1):\n                f[j] += 1\n                if j > 0:\n                    mx, mx2, num = records[j - 1]\n                    f[j] = max(f[j], (mx if x != num else mx2) + 1)\n\n                # records[j] 维护 fs[.][j] 的 mx, mx2, num\n                v = f[j]\n                p = records[j]\n                if v > p[0]:\n                    if x != p[2]:\n                        p[2] = x\n                        p[1] = p[0]\n                    p[0] = v\n                elif x != p[2] and v > p[1]:\n                    p[1] = v\n        return records[k][0]\n",
            "java": "public class Solution {\n    public int maximumLength(int[] nums, int k) {\n        Map<Integer, int[]> fs = new HashMap<>();\n        int[][] records = new int[k + 1][3];\n        for (int x : nums) {\n            int[] f = fs.computeIfAbsent(x, i -> new int[k + 1]);\n            for (int j = k; j >= 0; j--) {\n                f[j]++;\n                if (j > 0) {\n                    int mx = records[j - 1][0], mx2 = records[j - 1][1], num = records[j - 1][2];\n                    f[j] = Math.max(f[j], (x != num ? mx : mx2) + 1);\n                }\n\n                // records[j] 维护 fs[.][j] 的 mx, mx2, num\n                int v = f[j];\n                int[] p = records[j];\n                if (v > p[0]) {\n                    if (x != p[2]) {\n                        p[2] = x;\n                        p[1] = p[0];\n                    }\n                    p[0] = v;\n                } else if (x != p[2] && v > p[1]) {\n                    p[1] = v;\n                }\n            }\n        }\n        return records[k][0];\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int maximumLength(vector<int>& nums, int k) {\n        unordered_map<int, vector<int>> fs;\n        vector<array<int, 3>> records(k + 1);\n        for (int x : nums) {\n            if (!fs.contains(x)) {\n                fs[x] = vector<int>(k + 1);\n            }\n            auto& f = fs[x];\n            for (int j = k; j >= 0; j--) {\n                f[j]++;\n                if (j) {\n                    auto& r = records[j - 1];\n                    int mx = r[0], mx2 = r[1], num = r[2];\n                    f[j] = max(f[j], (x != num ? mx : mx2) + 1);\n                }\n\n                // records[j] 维护 fs[.][j] 的 mx, mx2, num\n                int v = f[j];\n                auto& p = records[j];\n                if (v > p[0]) {\n                    if (x != p[2]) {\n                        p[2] = x;\n                        p[1] = p[0];\n                    }\n                    p[0] = v;\n                } else if (x != p[2] && v > p[1]) {\n                    p[1] = v;\n                }\n            }\n        }\n        return records[k][0];\n    }\n};\n",
            "go": "func maximumLength(nums []int, k int) int {\nfs := map[int][]int{}\nrecords := make([]struct{ mx, mx2, num int }, k+1)\nfor _, x := range nums {\nif fs[x] == nil {\nfs[x] = make([]int, k+1)\n}\nf := fs[x]\nfor j := k; j >= 0; j-- {\nf[j]++\nif j > 0 {\np := records[j-1]\nm := p.mx\nif x == p.num {\nm = p.mx2\n}\nf[j] = max(f[j], m+1)\n}\n\n// records[j] 维护 fs[.][j] 的 mx,mx2,num\nv := f[j]\np := &records[j]\nif v > p.mx {\nif x != p.num {\np.num = x\np.mx2 = p.mx\n}\np.mx = v\n} else if x != p.num && v > p.mx2 {\np.mx2 = v\n}\n}\n}\nreturn records[k].mx\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumLength = function(nums, k) {\n    let n = nums.length \n    // dp[i][m]含义为以nums[i]为结尾的子序列，有至多k对相邻元素不同的最大子序列长度\n    let dp = new Array(n).fill(0).map(() => new Array(k+1).fill(0))\n    //初始化\n    for(let i = 0;i < n;i ++)\n    dp[i][0] = 1\n    for(let i = 0;i < n;i ++){\n        // 枚举j < i\n        for(let j = i - 1;j >= 0;j --){\n            if(nums[i] == nums[j]){ //nums[j] == nums[i]说明nums[j]已经有m对相邻元素不同\n                for(let m = 0;m <= k;m ++)\n                dp[i][m] = Math.max(dp[i][m],dp[j][m]+1)\n            }else{ //nums[j] !== nums[i]说明nums[j]只有m-1对相邻元素不同\n                for(let m = 1;m <=k;m ++)\n                dp[i][m] = Math.max(dp[i][m],dp[j][m-1]+1)\n            }\n        }\n    }\n    let maxLen = 1\n    for(let i = 0;i < n;i ++){\n        for(let m = 0;m <= k;m ++){\n            maxLen = Math.max(maxLen,dp[i][m])\n        }\n    }\n    return maxLen\n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,2,1,1,3]\",\"2\"]",
                "output": "[\"4\"]"
            },
            {
                "input": "[\"[1,2,3,4,5,1]\",\"0\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maximumLength(int[] nums, int k) {",
            "cpp": "class Solution {\npublic:\n    int maximumLength(vector<int>& nums, int k) {",
            "go": "func maximumLength(nums []int, k int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumLength = function(nums, k) {",
            "python": "class Solution:\n    def maximumLength(self, nums: List[int], k: int) -> int:"
        },
        "time": "20240608",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maximumLength",
            "java": "maximumLength",
            "cpp": "maximumLength",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maximumLength([1,2,1,1,3], 2) == 4, \"Test 1 Error!\"\nassert my_solution.maximumLength([1,2,3,4,5,1], 0) == 2, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,1,1,3};\n    int k_1 = 2;\n    int ans_1 = 4;\n    assert solution.maximumLength(nums_1, k_1) == ans_1;\n    int[] nums_2 = {1,2,3,4,5,1};\n    int k_2 = 0;\n    int ans_2 = 2;\n    assert solution.maximumLength(nums_2, k_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,1,1,3};\n    int k_1 = 2;\n    int ans_1 = 4;\n    assert(my_solution_1.maximumLength(nums_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,2,3,4,5,1};\n    int k_2 = 0;\n    int ans_2 = 2;\n    assert(my_solution_2.maximumLength(nums_2, k_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "k"
            ],
            "java": [
                "nums",
                "k"
            ],
            "cpp": [
                "nums",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3177": {
        "description": "给你一个整数数组 nums 和一个 非负 整数 k 。如果一个整数序列 seq 满足在范围下标范围 [0, seq.length - 2] 中存在 不超过 k 个下标 i 满足 seq[i] != seq[i + 1] ，那么我们称这个整数序列为 好 序列。\n请你返回 nums 中 好 子序列 的最长长度",
        "difficulty_level": "Hard",
        "note": "1 <= nums.length <= 5 * 10^3\n1 <= nums[i] <= 10^9\n0 <= k <= min(50, nums.length)",
        "codes": {
            "python": "class Solution:\n    def maximumLength(self, nums: List[int], k: int) -> int:\n        fs = {}\n        mx = [0] * (k + 2)\n        for x in nums:\n            if x not in fs:\n                fs[x] = [0] * (k + 1)\n            f = fs[x]\n            for j in range(k, -1, -1):\n                f[j] = max(f[j], mx[j]) + 1\n                mx[j + 1] = max(mx[j + 1], f[j])\n        return mx[-1]\n",
            "java": "public class Solution {\n    public int maximumLength(int[] nums, int k) {\n        Map<Integer, int[]> fs = new HashMap<>();\n        int[] mx = new int[k + 2];\n        for (int x : nums) {\n            int[] f = fs.computeIfAbsent(x, i -> new int[k + 1]);\n            for (int j = k; j >= 0; j--) {\n                f[j] = Math.max(f[j], mx[j]) + 1;\n                mx[j + 1] = Math.max(mx[j + 1], f[j]);\n            }\n        }\n        return mx[k + 1];\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int maximumLength(vector<int>& nums, int k) {\n        unordered_map<int, vector<int>> fs;\n        vector<int> mx(k + 2);\n        for (int x : nums) {\n            if (!fs.contains(x)) {\n                fs[x] = vector<int>(k + 1);\n            }\n            auto& f = fs[x];\n            for (int j = k; j >= 0; j--) {\n                f[j] = max(f[j], mx[j]) + 1;\n                mx[j + 1] = max(mx[j + 1], f[j]);\n            }\n        }\n        return mx[k + 1];\n    }\n};\n",
            "go": "func maximumLength(nums []int, k int) int {\nfs := map[int][]int{}\nmx := make([]int, k+2)\nfor _, x := range nums {\nif fs[x] == nil {\nfs[x] = make([]int, k+1)\n}\nf := fs[x]\nfor j := k; j >= 0; j-- {\nf[j] = max(f[j], mx[j]) + 1\nmx[j+1] = max(mx[j+1], f[j])\n}\n}\nreturn mx[k+1]\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumLength = function(nums, k) {\n    const numToDp = new Map();\n    const maxLength = new Array(k + 1).fill(0);\n    for (const num of nums) {\n        if (!numToDp.has(num)) {\n            numToDp.set(num, new Array(k + 1).fill(0));\n        }\n        const dp = numToDp.get(num);\n        for (let i = k; i >= 0; i--) {\n            dp[i]++;\n            if (i > 0) {\n                dp[i] = Math.max(dp[i], maxLength[i - 1] + 1);\n            }\n            maxLength[i] = Math.max(maxLength[i], dp[i]);\n        }\n    }\n    return maxLength[k];\n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,2,1,1,3]\",\"2\"]",
                "output": "[\"4\"]"
            },
            {
                "input": "[\"[1,2,3,4,5,1]\",\"0\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int maximumLength(int[] nums, int k) {",
            "cpp": "class Solution {\npublic:\n    int maximumLength(vector<int>& nums, int k) {",
            "go": "func maximumLength(nums []int, k int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar maximumLength = function(nums, k) {",
            "python": "class Solution:\n    def maximumLength(self, nums: List[int], k: int) -> int:"
        },
        "time": "20240608",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maximumLength",
            "java": "maximumLength",
            "cpp": "maximumLength",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maximumLength([1,2,1,1,3], 2) == 4, \"Test 1 Error!\"\nassert my_solution.maximumLength([1,2,3,4,5,1], 0) == 2, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,1,1,3};\n    int k_1 = 2;\n    int ans_1 = 4;\n    assert solution.maximumLength(nums_1, k_1) == ans_1;\n    int[] nums_2 = {1,2,3,4,5,1};\n    int k_2 = 0;\n    int ans_2 = 2;\n    assert solution.maximumLength(nums_2, k_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,1,1,3};\n    int k_1 = 2;\n    int ans_1 = 4;\n    assert(my_solution_1.maximumLength(nums_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,2,3,4,5,1};\n    int k_2 = 0;\n    int ans_2 = 2;\n    assert(my_solution_2.maximumLength(nums_2, k_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "k"
            ],
            "java": [
                "nums",
                "k"
            ],
            "cpp": [
                "nums",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3190": {
        "description": "给你一个整数数组 nums 。一次操作中，你可以将 nums 中的 任意 一个元素增加或者减少 1 。\n请你返回将 nums 中所有元素都可以被 3 整除的 最少 操作次数。",
        "difficulty_level": "Easy",
        "note": "1 <= nums.length <= 50\n1 <= nums[i] <= 50",
        "codes": {
            "python": "class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        return sum(x % 3 != 0 for x in nums)\n",
            "java": "class Solution {\n    public int minimumOperations(int[] nums) {\n        int ans = 0;\n        for (int x : nums) {\n            ans += x % 3 != 0 ? 1 : 0;\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minimumOperations(vector<int>& nums) {\n        int ans = 0;\n        for (int x : nums) {\n            ans += x % 3 != 0;\n        }\n        return ans;\n    }\n};\n",
            "go": "func minimumOperations(nums []int) (ans int) {\nfor _, x := range nums {\nif x%3 != 0 {\nans++\n}\n}\nreturn\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[1,2,3,4]\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[3,6,9]\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minimumOperations(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    int minimumOperations(vector<int>& nums) {",
            "go": "func minimumOperations(nums []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumOperations = function(nums) {",
            "python": "class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:"
        },
        "time": "20240622",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minimumOperations",
            "java": "minimumOperations",
            "cpp": "minimumOperations",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minimumOperations([1,2,3,4]) == 3, \"Test 1 Error!\"\nassert my_solution.minimumOperations([3,6,9]) == 0, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,2,3,4};\n    int ans_1 = 3;\n    assert solution.minimumOperations(nums_1) == ans_1;\n    int[] nums_2 = {3,6,9};\n    int ans_2 = 0;\n    assert solution.minimumOperations(nums_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,2,3,4};\n    int ans_1 = 3;\n    assert(my_solution_1.minimumOperations(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {3,6,9};\n    int ans_2 = 0;\n    assert(my_solution_2.minimumOperations(nums_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3191": {
        "description": "给你一个二进制数组 nums 。你可以对数组执行以下操作 任意 次（也可以 0 次）：\n选择数组中 任意连续 3 个元素，并将它们 全部反转 。\n反转 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。\n请你返回将 nums 中所有元素变为 1 的 最少 操作次数。如果无法全部变成 1 ，返回 -1 。",
        "difficulty_level": "Middle",
        "note": "3 <= nums.length <= 10^5\n0 <= nums[i] <= 1",
        "codes": {
            "python": "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        for i in range(len(nums) - 2):\n            if nums[i] == 0:\n                nums[i + 1] ^= 1\n                nums[i + 2] ^= 1\n                ans += 1\n        return ans if nums[-2] and nums[-1] else -1\n",
            "java": "public class Solution {\n    public int minOperations(int[] nums) {\n        int n = nums.length;\n        int ans = 0;\n        for (int i = 0; i < n - 2; i++) {\n            if (nums[i] == 0) {\n                nums[i + 1] ^= 1;\n                nums[i + 2] ^= 1;\n                ans++;\n            }\n        }\n        return nums[n - 2] != 0 && nums[n - 1] != 0 ? ans : -1;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n        int n = nums.size();\n        int ans = 0;\n        for (int i = 0; i < n - 2; i++) {\n            if (nums[i] == 0) {\n                nums[i + 1] ^= 1;\n                nums[i + 2] ^= 1;\n                ans++;\n            }\n        }\n        return nums[n - 2] && nums[n - 1] ? ans : -1;\n    }\n};\n",
            "go": "func minOperations(nums []int) (ans int) {\nn := len(nums)\nfor i, x := range nums[:n-2] {\nif x == 0 {\nnums[i+1] ^= 1\nnums[i+2] ^= 1\nans++\n}\n}\nif nums[n-2] == 0 || nums[n-1] == 0 {\nreturn -1\n}\nreturn\n}\n",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minOperations = function(nums) {\n    let ans = 0, len = nums.length;\n    for (let i = 0; i < len - 2; i++) {\n        if (nums[i] === 0) {\n            nums[i + 1] ^= 1;\n            nums[i + 2] ^= 1;\n            ans++;\n        }\n    }\n    if (nums[len - 1] === 0 || nums[len - 2] === 0) {\n        return -1;\n    }\n    return ans;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[0,1,1,1,0,0]\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[0,1,1,1]\"]",
                "output": "[\"-1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minOperations(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    int minOperations(vector<int>& nums) {",
            "go": "func minOperations(nums []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minOperations = function(nums) {",
            "python": "class Solution:\n    def minOperations(self, nums: List[int]) -> int:"
        },
        "time": "20240622",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minOperations",
            "java": "minOperations",
            "cpp": "minOperations",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minOperations([0,1,1,1,0,0]) == 3, \"Test 1 Error!\"\nassert my_solution.minOperations([0,1,1,1]) == -1, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {0,1,1,1,0,0};\n    int ans_1 = 3;\n    assert solution.minOperations(nums_1) == ans_1;\n    int[] nums_2 = {0,1,1,1};\n    int ans_2 = -1;\n    assert solution.minOperations(nums_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {0,1,1,1,0,0};\n    int ans_1 = 3;\n    assert(my_solution_1.minOperations(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {0,1,1,1};\n    int ans_2 = -1;\n    assert(my_solution_2.minOperations(nums_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3192": {
        "description": "给你一个二进制数组 nums 。你可以对数组执行以下操作 任意 次（也可以 0 次）：\n选择数组中 任意 一个下标 i ，并将从下标 i 开始一直到数组末尾 所有 元素 反转 。\n反转 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。\n请你返回将 nums 中所有元素变为 1 的 最少 操作次数。",
        "difficulty_level": "Middle",
        "note": "1 <= nums.length <= 10^5\n0 <= nums[i] <= 1",
        "codes": {
            "python": "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        for x in nums:\n            if x == ans % 2:\n                ans += 1\n        return ans\n",
            "java": "class Solution {\n    public int minOperations(int[] nums) {\n        int ans = 0;\n        for (int x : nums) {\n            if (x == ans % 2) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n        int ans = 0;\n        for (int x : nums) {\n            ans += x == ans % 2;\n        }\n        return ans;\n    }\n};\n",
            "go": "func minOperations(nums []int) (ans int) {\nfor _, x := range nums {\nif x == ans%2 {\nans++\n}\n}\nreturn\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[0,1,1,0,1]\"]",
                "output": "[\"4\"]"
            },
            {
                "input": "[\"[1,0,0,0]\"]",
                "output": "[\"1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int minOperations(int[] nums) {",
            "cpp": "class Solution {\npublic:\n    int minOperations(vector<int>& nums) {",
            "go": "func minOperations(nums []int) int {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minOperations = function(nums) {",
            "python": "class Solution:\n    def minOperations(self, nums: List[int]) -> int:"
        },
        "time": "20240622",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "minOperations",
            "java": "minOperations",
            "cpp": "minOperations",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.minOperations([0,1,1,0,1]) == 4, \"Test 1 Error!\"\nassert my_solution.minOperations([1,0,0,0]) == 1, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {0,1,1,0,1};\n    int ans_1 = 4;\n    assert solution.minOperations(nums_1) == ans_1;\n    int[] nums_2 = {1,0,0,0};\n    int ans_2 = 1;\n    assert solution.minOperations(nums_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {0,1,1,0,1};\n    int ans_1 = 4;\n    assert(my_solution_1.minOperations(nums_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,0,0,0};\n    int ans_2 = 1;\n    assert(my_solution_2.minOperations(nums_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums"
            ],
            "java": [
                "nums"
            ],
            "cpp": [
                "nums"
            ],
            "go": [],
            "js": []
        }
    },
    "3193": {
        "description": "给你一个整数 n 和一个二维数组 requirements ，其中 requirements[i] = [end_i, cnt_i] 表示这个要求中的末尾下标和 逆序对 的数目。\n整数数组 nums 中一个下标对 (i, j) 如果满足以下条件，那么它们被称为一个 逆序对 ：\ni < j 且 nums[i] > nums[j]\n请你返回 [0, 1, 2, ..., n - 1] 的 排列 perm 的数目，满足对 所有 的 requirements[i] 都有 perm[0..end_i] 恰好有 cnt_i 个逆序对。\n由于答案可能会很大，将它对 10^9 + 7 取余 后返回。",
        "difficulty_level": "Hard",
        "note": "2 <= n <= 300\n1 <= requirements.length <= n\nrequirements[i] = [end_i, cnt_i]\n0 <= end_i <= n - 1\n0 <= cnt_i <= 400\n输入保证至少有一个 i 满足 end_i == n - 1 。\n输入保证所有的 end_i 互不相同。",
        "codes": {
            "python": "class Solution:\n    def numberOfPermutations(self, n: int, requirements: List[List[int]]) -> int:\n        MOD = 1_000_000_007\n        req = [-1] * n\n        req[0] = 0\n        for end, cnt in requirements:\n            req[end] = cnt\n        if req[0]:\n            return 0\n\n        @cache  # 缓存装饰器，避免重复计算 dfs 的结果（记忆化）\n        def dfs(i: int, j: int) -> int:\n            if i == 0:\n                return 1\n            r = req[i - 1]\n            if r >= 0:\n                return dfs(i - 1, r) if r <= j <= i + r else 0\n            return sum(dfs(i - 1, j - k) for k in range(min(i, j) + 1)) % MOD\n        return dfs(n - 1, req[-1])\n",
            "java": "public class Solution {\n    public int numberOfPermutations(int n, int[][] requirements) {\n        int[] req = new int[n];\n        Arrays.fill(req, -1);\n        req[0] = 0;\n        int m = 0;\n        for (int[] p : requirements) {\n            req[p[0]] = p[1];\n            m = Math.max(m, p[1]);\n        }\n        if (req[0] > 0) {\n            return 0;\n        }\n\n        int[][] memo = new int[n][m + 1];\n        for (int[] row : memo) {\n            Arrays.fill(row, -1); // -1 表示没有计算过\n        }\n        return dfs(n - 1, req[n - 1], req, memo);\n    }\n\n    private int dfs(int i, int j, int[] req, int[][] memo) {\n        if (i == 0) {\n            return 1;\n        }\n        if (memo[i][j] != -1) { // 之前计算过\n            return memo[i][j];\n        }\n        int res = 0;\n        int r = req[i - 1];\n        if (r >= 0) {\n            if (j >= r && j - i <= r) {\n                res = dfs(i - 1, r, req, memo);\n            }\n        } else {\n            for (int k = 0; k <= Math.min(i, j); k++) {\n                res = (res + dfs(i - 1, j - k, req, memo)) % 1_000_000_007;\n            }\n        }\n        return memo[i][j] = res; // 记忆化\n    }\n}\n",
            "cpp": "class Solution {\n    const int MOD = 1'000'000'007;\npublic:\n    int numberOfPermutations(int n, vector<vector<int>>& requirements) {\n        vector<int> req(n, -1);\n        req[0] = 0;\n        for (auto& p : requirements) {\n            req[p[0]] = p[1];\n        }\n        if (req[0]) {\n            return 0;\n        }\n\n        int m = ranges::max(req);\n        vector<vector<int>> memo(n, vector<int>(m + 1, -1)); // -1 表示没有计算过\n        auto dfs = [&](auto&& dfs, int i, int j) -> int {\n            if (i == 0) {\n                return 1;\n            }\n            int& res = memo[i][j]; // 注意这里是引用\n            if (res != -1) { // 之前计算过\n                return res;\n            }\n            res = 0;\n            if (int r = req[i - 1]; r >= 0) {\n                if (j >= r && j - i <= r) {\n                    res = dfs(dfs, i - 1, r);\n                }\n            } else {\n                for (int k = 0; k <= min(i, j); k++) {\n                    res = (res + dfs(dfs, i - 1, j - k)) % MOD;\n                }\n            }\n            return res;\n        };\n        return dfs(dfs, n - 1, req[n - 1]);\n    }\n};\n",
            "go": "func numberOfPermutations(n int, requirements [][]int) int {\nconst mod = 1_000_000_007\nreq := make([]int, n)\nfor i := 1; i < n; i++ {\nreq[i] = -1\n}\nfor _, p := range requirements {\nreq[p[0]] = p[1]\n}\nif req[0] > 0 {\nreturn 0\n}\n\nm := slices.Max(req)\nmemo := make([][]int, n)\nfor i := range memo {\nmemo[i] = make([]int, m+1)\nfor j := range memo[i] {\nmemo[i][j] = -1\n}\n}\nvar dfs func(int, int) int\ndfs = func(i, j int) (res int) {\nif i == 0 {\nreturn 1\n}\np := &memo[i][j]\nif *p != -1 {\nreturn *p\n}\ndefer func() { *p = res }()\nif r := req[i-1]; r >= 0 {\nif j < r || j-i > r {\nreturn 0\n}\nreturn dfs(i-1, r)\n}\nfor k := 0; k <= min(i, j); k++ {\nres += dfs(i-1, j-k)\n}\nreturn res % mod\n}\nreturn dfs(n-1, req[n-1])\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"3\",\"[[2,2],[0,0]]\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"3\",\"[[2,2],[1,1],[0,0]]\"]",
                "output": "[\"1\"]"
            },
            {
                "input": "[\"2\",\"[[0,0],[1,0]]\"]",
                "output": "[\"1\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int numberOfPermutations(int n, int[][] requirements) {",
            "cpp": "class Solution {\npublic:\n    int numberOfPermutations(int n, vector<vector<int>>& requirements) {",
            "go": "func numberOfPermutations(n int, requirements [][]int) int {\n\n}",
            "js": "/**\n * @param {number} n\n * @param {number[][]} requirements\n * @return {number}\n */\nvar numberOfPermutations = function(n, requirements) {",
            "python": "class Solution:\n    def numberOfPermutations(self, n: int, requirements: List[List[int]]) -> int:"
        },
        "time": "20240622",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "numberOfPermutations",
            "java": "numberOfPermutations",
            "cpp": "numberOfPermutations",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.numberOfPermutations(3, [[2,2],[0,0]]) == 2, \"Test 1 Error!\"\nassert my_solution.numberOfPermutations(3, [[2,2],[1,1],[0,0]]) == 1, \"Test 2 Error!\"\nassert my_solution.numberOfPermutations(2, [[0,0],[1,0]]) == 1, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int n_1 = 3;\n    int[][] requirements_1 = {{2,2},{0,0}};\n    int ans_1 = 2;\n    assert solution.numberOfPermutations(n_1, requirements_1) == ans_1;\n    int n_2 = 3;\n    int[][] requirements_2 = {{2,2},{1,1},{0,0}};\n    int ans_2 = 1;\n    assert solution.numberOfPermutations(n_2, requirements_2) == ans_2;\n    int n_3 = 2;\n    int[][] requirements_3 = {{0,0},{1,0}};\n    int ans_3 = 1;\n    assert solution.numberOfPermutations(n_3, requirements_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    int n_1 = 3;\n    vector<vector<int>> requirements_1 = {{2,2},{0,0}};\n    int ans_1 = 2;\n    assert(my_solution_1.numberOfPermutations(n_1, requirements_1) == ans_1);\n    Solution my_solution_2;\n    int n_2 = 3;\n    vector<vector<int>> requirements_2 = {{2,2},{1,1},{0,0}};\n    int ans_2 = 1;\n    assert(my_solution_2.numberOfPermutations(n_2, requirements_2) == ans_2);\n    Solution my_solution_3;\n    int n_3 = 2;\n    vector<vector<int>> requirements_3 = {{0,0},{1,0}};\n    int ans_3 = 1;\n    assert(my_solution_3.numberOfPermutations(n_3, requirements_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "n",
                "requirements"
            ],
            "java": [
                "n",
                "requirements"
            ],
            "cpp": [
                "n",
                "requirements"
            ],
            "go": [],
            "js": []
        }
    },
    "3206": {
        "description": "给你一个整数数组 colors ，它表示一个由红色和蓝色瓷砖组成的环，第 i 块瓷砖的颜色为 colors[i] ：\ncolors[i] == 0 表示第 i 块瓷砖的颜色是 红色 。\ncolors[i] == 1 表示第 i 块瓷砖的颜色是 蓝色 。\n环中连续 3 块瓷砖的颜色如果是 交替 颜色（也就是说中间瓷砖的颜色与它 左边 和 右边 的颜色都不同），那么它被称为一个 交替 组。请你返回 交替 组的数目。\n注意 ，由于 colors 表示一个 环 ，第一块 瓷砖和 最后一块 瓷砖是相邻的。",
        "difficulty_level": "Easy",
        "note": "3 <= colors.length <= 100\n0 <= colors[i] <= 1",
        "codes": {
            "python": "class Solution:\n    def numberOfAlternatingGroups(self, colors: List[int]) -> int:\n        k = 3\n        n = len(colors)\n        ans = cnt = 0\n        for i in range(n * 2):\n            if i > 0 and colors[i % n] == colors[(i - 1) % n]:\n                cnt = 0\n            cnt += 1\n            if i >= n and cnt >= k:\n                ans += 1\n        return ans\n",
            "java": "public class Solution {\n    public int numberOfAlternatingGroups(int[] colors) {\n        int k = 3;\n        int n = colors.length;\n        int ans = 0;\n        int cnt = 0;\n        for (int i = 0; i < n * 2; i++) {\n            if (i > 0 && colors[i % n] == colors[(i - 1) % n]) {\n                cnt = 0;\n            }\n            cnt++;\n            if (i >= n && cnt >= k) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int numberOfAlternatingGroups(vector<int>& colors) {\n        int k = 3;\n        int n = colors.size();\n        int ans = 0, cnt = 0;\n        for (int i = 0; i < n * 2; i++) {\n            if (i > 0 && colors[i % n] == colors[(i - 1) % n]) {\n                cnt = 0;\n            }\n            cnt++;\n            ans += i >= n && cnt >= k;\n        }\n        return ans;\n    }\n};\n",
            "go": "func numberOfAlternatingGroups(colors []int) (ans int) {\nk := 3\nn := len(colors)\ncnt := 0\nfor i := 0; i < n*2; i++ {\nif i > 0 && colors[i%n] == colors[(i-1)%n] {\ncnt = 0\n}\ncnt++\nif i >= n && cnt >= k {\nans++\n}\n}\nreturn\n}\n",
            "js": "var numberOfAlternatingGroups = function(colors) {\n    let k = 3;\n    let alternating = 0;\n    let n = colors.length;\n    for (let i = 0; i < n; i++) {\n        if (colors[i] !== colors[(i + 1) % n] && colors[(i + 1) % n] !== colors[(i + 2) % n]) {\n            alternating++;\n        }\n    }\n    return alternating;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[1,1,1]\"]",
                "output": "[\"0\"]"
            },
            {
                "input": "[\"[0,1,0,0,1]\"]",
                "output": "[\"3\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int numberOfAlternatingGroups(int[] colors) {",
            "cpp": "class Solution {\npublic:\n    int numberOfAlternatingGroups(vector<int>& colors) {",
            "go": "func numberOfAlternatingGroups(colors []int) int {\n\n}",
            "js": "/**\n * @param {number[]} colors\n * @return {number}\n */\nvar numberOfAlternatingGroups = function(colors) {",
            "python": "class Solution:\n    def numberOfAlternatingGroups(self, colors: List[int]) -> int:"
        },
        "time": "20240706",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "numberOfAlternatingGroups",
            "java": "numberOfAlternatingGroups",
            "cpp": "numberOfAlternatingGroups",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.numberOfAlternatingGroups([1,1,1]) == 0, \"Test 1 Error!\"\nassert my_solution.numberOfAlternatingGroups([0,1,0,0,1]) == 3, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] colors_1 = {1,1,1};\n    int ans_1 = 0;\n    assert solution.numberOfAlternatingGroups(colors_1) == ans_1;\n    int[] colors_2 = {0,1,0,0,1};\n    int ans_2 = 3;\n    assert solution.numberOfAlternatingGroups(colors_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> colors_1 = {1,1,1};\n    int ans_1 = 0;\n    assert(my_solution_1.numberOfAlternatingGroups(colors_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> colors_2 = {0,1,0,0,1};\n    int ans_2 = 3;\n    assert(my_solution_2.numberOfAlternatingGroups(colors_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "colors"
            ],
            "java": [
                "colors"
            ],
            "cpp": [
                "colors"
            ],
            "go": [],
            "js": []
        }
    },
    "3207": {
        "description": "给你一个下标从 0 开始的整数数组 enemyEnergies ，它表示一个下标从 0 开始的敌人能量数组。\n同时给你一个整数 currentEnergy ，它表示你一开始拥有的能量值总量。\n你一开始的分数为 0 ，且一开始所有的敌人都未标记。\n你可以通过以下操作 之一 任意次（也可以 0 次）来得分：\n选择一个 未标记 且满足 currentEnergy >= enemyEnergies[i] 的敌人 i 。在这个操作中：你会获得 1 分。你的能量值减少 enemyEnergies[i] ，也就是说 currentEnergy = currentEnergy - enemyEnergies[i] 。\n如果你目前 至少 有 1 分，你可以选择一个 未标记 的敌人 i 。在这个操作中：你的能量值增加 enemyEnergies[i] ，也就是说 currentEnergy = currentEnergy + enemyEnergies[i] 。敌人 i 被标记 。\n请你返回通过以上操作，最多 可以获得多少分。",
        "difficulty_level": "Middle",
        "note": "1 <= enemyEnergies.length <= 10^5\n1 <= enemyEnergies[i] <= 10^9\n0 <= currentEnergy <= 10^9",
        "codes": {
            "python": "class Solution:\n    def maximumPoints(self, enemyEnergies: List[int], currentEnergy: int) -> int:\n        mn = min(enemyEnergies)\n        if currentEnergy < mn:\n            return 0\n        return (currentEnergy + sum(enemyEnergies) - mn) // mn\n",
            "java": "public class Solution {\n    public long maximumPoints(int[] enemyEnergies, int currentEnergy) {\n        int mn = Integer.MAX_VALUE;\n        long s = 0;\n        for (int e : enemyEnergies) {\n            mn = Math.min(mn, e);\n            s += e;\n        }\n        if (currentEnergy < mn) {\n            return 0;\n        }\n        return (currentEnergy + s - mn) / mn;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long maximumPoints(vector<int>& enemyEnergies, int currentEnergy) {\n        int mn = ranges::min(enemyEnergies);\n        if (currentEnergy < mn) {\n            return 0;\n        }\n        long long s = reduce(enemyEnergies.begin(), enemyEnergies.end(), 0LL);\n        return (currentEnergy + s - mn) / mn;\n    }\n};\n",
            "go": "func maximumPoints(enemyEnergies []int, currentEnergy int) int64 {\nmn, s := math.MaxInt, 0\nfor _, e := range enemyEnergies {\nmn = min(mn, e)\ns += e\n}\nif currentEnergy < mn {\nreturn 0\n}\nreturn int64((currentEnergy + s - mn) / mn)\n}\n",
            "js": "var maximumPoints = function(enemyEnergies, currentEnergy) {\n    let sum = 0;\n    let minEnemyEnergy = Infinity;\n    for (let enemyEnergy of enemyEnergies) {\n        sum += enemyEnergy;\n        minEnemyEnergy = Math.min(minEnemyEnergy, enemyEnergy);\n    }\n    if (currentEnergy < minEnemyEnergy) {\n        return 0;\n    }\n    let totalEnergy = currentEnergy + (sum - minEnemyEnergy);\n    return Math.floor(totalEnergy / minEnemyEnergy);\n};\n"
        },
        "cases": [
            {
                "input": "[\"[3,2,2]\",\"2\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[2]\",\"10\"]",
                "output": "[\"5\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long maximumPoints(int[] enemyEnergies, int currentEnergy) {",
            "cpp": "class Solution {\npublic:\n    long long maximumPoints(vector<int>& enemyEnergies, int currentEnergy) {",
            "go": "func maximumPoints(enemyEnergies []int, currentEnergy int) int64 {\n\n}",
            "js": "/**\n * @param {number[]} enemyEnergies\n * @param {number} currentEnergy\n * @return {number}\n */\nvar maximumPoints = function(enemyEnergies, currentEnergy) {",
            "python": "class Solution:\n    def maximumPoints(self, enemyEnergies: List[int], currentEnergy: int) -> int:"
        },
        "time": "20240706",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "maximumPoints",
            "java": "maximumPoints",
            "cpp": "maximumPoints",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.maximumPoints([3,2,2], 2) == 3, \"Test 1 Error!\"\nassert my_solution.maximumPoints([2], 10) == 5, \"Test 2 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] enemyEnergies_1 = {3,2,2};\n    int currentEnergy_1 = 2;\n    long ans_1 = 3;\n    assert solution.maximumPoints(enemyEnergies_1, currentEnergy_1) == ans_1;\n    int[] enemyEnergies_2 = {2};\n    int currentEnergy_2 = 10;\n    long ans_2 = 5;\n    assert solution.maximumPoints(enemyEnergies_2, currentEnergy_2) == ans_2;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> enemyEnergies_1 = {3,2,2};\n    int currentEnergy_1 = 2;\n    long long ans_1 = 3;\n    assert(my_solution_1.maximumPoints(enemyEnergies_1, currentEnergy_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> enemyEnergies_2 = {2};\n    int currentEnergy_2 = 10;\n    long long ans_2 = 5;\n    assert(my_solution_2.maximumPoints(enemyEnergies_2, currentEnergy_2) == ans_2);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "enemyEnergies",
                "currentEnergy"
            ],
            "java": [
                "enemyEnergies",
                "currentEnergy"
            ],
            "cpp": [
                "enemyEnergies",
                "currentEnergy"
            ],
            "go": [],
            "js": []
        }
    },
    "3208": {
        "description": "给你一个整数数组 colors 和一个整数 k ，colors表示一个由红色和蓝色瓷砖组成的环，第 i 块瓷砖的颜色为 colors[i] ：\ncolors[i] == 0 表示第 i 块瓷砖的颜色是 红色 。\ncolors[i] == 1 表示第 i 块瓷砖的颜色是 蓝色 。\n环中连续 k 块瓷砖的颜色如果是 交替 颜色（也就是说除了第一块和最后一块瓷砖以外，中间瓷砖的颜色与它 左边 和 右边 的颜色都不同），那么它被称为一个 交替 组。\n请你返回 交替 组的数目。\n注意 ，由于 colors 表示一个 环 ，第一块 瓷砖和 最后一块 瓷砖是相邻的。",
        "difficulty_level": "Middle",
        "note": "3 <= colors.length <= 10^5\n0 <= colors[i] <= 1\n3 <= k <= colors.length",
        "codes": {
            "python": "class Solution:\n    def numberOfAlternatingGroups(self, colors: List[int], k: int) -> int:\n        n = len(colors)\n        ans = cnt = 0\n        for i in range(n * 2):\n            if i > 0 and colors[i % n] == colors[(i - 1) % n]:\n                cnt = 0\n            cnt += 1\n            if i >= n and cnt >= k:\n                ans += 1\n        return ans\n",
            "java": "public class Solution {\n    public int numberOfAlternatingGroups(int[] colors, int k) {\n        int n = colors.length;\n        int ans = 0;\n        int cnt = 0;\n        for (int i = 0; i < n * 2; i++) {\n            if (i > 0 && colors[i % n] == colors[(i - 1) % n]) {\n                cnt = 0;\n            }\n            cnt++;\n            if (i >= n && cnt >= k) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    int numberOfAlternatingGroups(vector<int>& colors, int k) {\n        int n = colors.size();\n        int ans = 0, cnt = 0;\n        for (int i = 0; i < n * 2; i++) {\n            if (i > 0 && colors[i % n] == colors[(i - 1) % n]) {\n                cnt = 0;\n            }\n            cnt++;\n            ans += i >= n && cnt >= k;\n        }\n        return ans;\n    }\n};\n",
            "go": "func numberOfAlternatingGroups(colors []int, k int) (ans int) {\nn := len(colors)\ncnt := 0\nfor i := 0; i < n*2; i++ {\nif i > 0 && colors[i%n] == colors[(i-1)%n] {\ncnt = 0\n}\ncnt++\nif i >= n && cnt >= k {\nans++\n}\n}\nreturn\n}\n",
            "js": "var numberOfAlternatingGroups = function(colors, k) {\n    let alternating = 0;\n    let consecutive = 0;\n    let n = colors.length;\n    let maxEnd = n + k - 2;\n    for (let i = 1; i <= maxEnd; i++) {\n        if (colors[i % n] !== colors[(i - 1) % n]) {\n            consecutive++;\n            if (consecutive >= k - 1) {\n                alternating++;\n            }\n        } else {\n            consecutive = 0;\n        }\n    }\n    return alternating;\n};\n"
        },
        "cases": [
            {
                "input": "[\"[0,1,0,1,0]\",\"3\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[0,1,0,0,1,0,1]\",\"6\"]",
                "output": "[\"2\"]"
            },
            {
                "input": "[\"[1,1,0,1]\",\"4\"]",
                "output": "[\"0\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public int numberOfAlternatingGroups(int[] colors, int k) {",
            "cpp": "class Solution {\npublic:\n    int numberOfAlternatingGroups(vector<int>& colors, int k) {",
            "go": "func numberOfAlternatingGroups(colors []int, k int) int {\n\n}",
            "js": "/**\n * @param {number[]} colors\n * @param {number} k\n * @return {number}\n */\nvar numberOfAlternatingGroups = function(colors, k) {",
            "python": "class Solution:\n    def numberOfAlternatingGroups(self, colors: List[int], k: int) -> int:"
        },
        "time": "20240706",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "numberOfAlternatingGroups",
            "java": "numberOfAlternatingGroups",
            "cpp": "numberOfAlternatingGroups",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.numberOfAlternatingGroups([0,1,0,1,0], 3) == 3, \"Test 1 Error!\"\nassert my_solution.numberOfAlternatingGroups([0,1,0,0,1,0,1], 6) == 2, \"Test 2 Error!\"\nassert my_solution.numberOfAlternatingGroups([1,1,0,1], 4) == 0, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] colors_1 = {0,1,0,1,0};\n    int k_1 = 3;\n    int ans_1 = 3;\n    assert solution.numberOfAlternatingGroups(colors_1, k_1) == ans_1;\n    int[] colors_2 = {0,1,0,0,1,0,1};\n    int k_2 = 6;\n    int ans_2 = 2;\n    assert solution.numberOfAlternatingGroups(colors_2, k_2) == ans_2;\n    int[] colors_3 = {1,1,0,1};\n    int k_3 = 4;\n    int ans_3 = 0;\n    assert solution.numberOfAlternatingGroups(colors_3, k_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> colors_1 = {0,1,0,1,0};\n    int k_1 = 3;\n    int ans_1 = 3;\n    assert(my_solution_1.numberOfAlternatingGroups(colors_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> colors_2 = {0,1,0,0,1,0,1};\n    int k_2 = 6;\n    int ans_2 = 2;\n    assert(my_solution_2.numberOfAlternatingGroups(colors_2, k_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> colors_3 = {1,1,0,1};\n    int k_3 = 4;\n    int ans_3 = 0;\n    assert(my_solution_3.numberOfAlternatingGroups(colors_3, k_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "colors",
                "k"
            ],
            "java": [
                "colors",
                "k"
            ],
            "cpp": [
                "colors",
                "k"
            ],
            "go": [],
            "js": []
        }
    },
    "3209": {
        "description": "给你一个整数数组 nums 和一个整数 k ，请你返回 nums 中有多少个子数组满足：子数组中所有元素按位 AND 的结果为 k 。",
        "difficulty_level": "Hard",
        "note": "1 <= nums.length <= 10^5\n0 <= nums[i], k <= 10^9",
        "codes": {
            "python": "class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i, x in enumerate(nums):\n            for j in range(i - 1, -1, -1):\n                if nums[j] & x == nums[j]:\n                    break\n                nums[j] &= x\n            ans += bisect_right(nums, k, 0, i + 1) - bisect_left(nums, k, 0, i + 1)\n        return ans\n",
            "java": "public class Solution {\n    public long countSubarrays(int[] nums, int k) {\n        long ans = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int x = nums[i];\n            for (int j = i - 1; j >= 0 && (nums[j] & x) != nums[j]; j--) {\n                nums[j] &= x;\n            }\n            ans += lowerBound(nums, i + 1, k + 1) - lowerBound(nums, i + 1, k);\n        }\n        return ans;\n    }\n\n    // https://www.bilibili.com/video/BV1AP41137w7/\n    private int lowerBound(int[] nums, int right, int target) {\n        int left = -1; // 开区间 (left, right)\n        while (left + 1 < right) { // 区间不为空\n            // 循环不变量：\n            // nums[left] < target\n            // nums[right] >= target\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target) {\n                left = mid; // 范围缩小到 (mid, right)\n            } else {\n                right = mid; // 范围缩小到 (left, mid)\n            }\n        }\n        return right;\n    }\n}\n",
            "cpp": "class Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        long long ans = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            int x = nums[i];\n            for (int j = i - 1; j >= 0 && (nums[j] & x) != nums[j]; j--) {\n                nums[j] &= x;\n            }\n            ans += upper_bound(nums.begin(), nums.begin() + i + 1, k) -\n                   lower_bound(nums.begin(), nums.begin() + i + 1, k);\n        }\n        return ans;\n    }\n};\n",
            "go": "func countSubarrays(nums []int, k int) (ans int64) {\nfor i, x := range nums {\nfor j := i - 1; j >= 0 && nums[j]&x != nums[j]; j-- {\nnums[j] &= x\n}\na := nums[:i+1]\nans += int64(sort.SearchInts(a, k+1) - sort.SearchInts(a, k))\n}\nreturn\n}\n",
            "js": ""
        },
        "cases": [
            {
                "input": "[\"[1,1,1]\",\"1\"]",
                "output": "[\"6\"]"
            },
            {
                "input": "[\"[1,1,2]\",\"1\"]",
                "output": "[\"3\"]"
            },
            {
                "input": "[\"[1,2,3]\",\"2\"]",
                "output": "[\"2\"]"
            }
        ],
        "contexts": {
            "java": "class Solution {\n    public long countSubarrays(int[] nums, int k) {",
            "cpp": "class Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {",
            "go": "func countSubarrays(nums []int, k int) int64 {\n\n}",
            "js": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar countSubarrays = function(nums, k) {",
            "python": "class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:"
        },
        "time": "20240706",
        "class_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "input_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "output_def_helper": {
            "python": null,
            "java": null,
            "cpp": null,
            "go": null,
            "js": null
        },
        "function_names": {
            "python": "countSubarrays",
            "java": "countSubarrays",
            "cpp": "countSubarrays",
            "go": "",
            "js": ""
        },
        "references": {
            "python": "my_solution = Solution()\nassert my_solution.countSubarrays([1,1,1], 1) == 6, \"Test 1 Error!\"\nassert my_solution.countSubarrays([1,1,2], 1) == 3, \"Test 2 Error!\"\nassert my_solution.countSubarrays([1,2,3], 2) == 2, \"Test 3 Error!\"\n",
            "java": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    int[] nums_1 = {1,1,1};\n    int k_1 = 1;\n    long ans_1 = 6;\n    assert solution.countSubarrays(nums_1, k_1) == ans_1;\n    int[] nums_2 = {1,1,2};\n    int k_2 = 1;\n    long ans_2 = 3;\n    assert solution.countSubarrays(nums_2, k_2) == ans_2;\n    int[] nums_3 = {1,2,3};\n    int k_3 = 2;\n    long ans_3 = 2;\n    assert solution.countSubarrays(nums_3, k_3) == ans_3;\n    }\n}",
            "cpp": "#undef NDEBUG\n#include<assert.h>\nint main() {\n    Solution my_solution_1;\n    vector<int> nums_1 = {1,1,1};\n    int k_1 = 1;\n    long long ans_1 = 6;\n    assert(my_solution_1.countSubarrays(nums_1, k_1) == ans_1);\n    Solution my_solution_2;\n    vector<int> nums_2 = {1,1,2};\n    int k_2 = 1;\n    long long ans_2 = 3;\n    assert(my_solution_2.countSubarrays(nums_2, k_2) == ans_2);\n    Solution my_solution_3;\n    vector<int> nums_3 = {1,2,3};\n    int k_3 = 2;\n    long long ans_3 = 2;\n    assert(my_solution_3.countSubarrays(nums_3, k_3) == ans_3);\n}",
            "go": "",
            "js": ""
        },
        "vars": {
            "python": [
                "nums",
                "k"
            ],
            "java": [
                "nums",
                "k"
            ],
            "cpp": [
                "nums",
                "k"
            ],
            "go": [],
            "js": []
        }
    }
}