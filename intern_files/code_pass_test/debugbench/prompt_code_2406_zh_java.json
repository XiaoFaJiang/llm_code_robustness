[
    {
        "id": "3014",
        "prompt_base": "\"\"\"\n给你一个字符串 word，由 不同 小写英文字母组成。\n电话键盘上的按键与 不同 小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 2 对应 [\\\"a\\\",\\\"b\\\",\\\"c\\\"]，我们需要按一次键来输入 \\\"a\\\"，按两次键来输入 \\\"b\\\"，按三次键来输入 \\\"c\\\"。\n现在允许你将编号为 2 到 9 的按键重新映射到 不同 字母集合。每个按键可以映射到 任意数量 的字母，但每个字母 必须 恰好 映射到 一个 按键上。你需要找到输入字符串 word 所需的 最少 按键次数。\n返回重新映射按键后输入 word 所需的 最少 按键次数。\n下面给出了一种电话键盘上字母到按键的映射作为示例。注意 1，*，# 和 0 不 对应任何字母。\n示例 1：\n输入word = \"abcde\"\n输出：5示例 2：\n输入word = \"xycdefghij\"\n输出：12\n\n提示：\n1 <= word.length <= 26\nword 仅由小写英文字母组成。\nword 中的所有字母互不相同。\n\"\"\"\n\nclass Solution {\n    public int minimumPushes(String word) {",
        "prompt_chat": "给你一个字符串 word，由 不同 小写英文字母组成。\n电话键盘上的按键与 不同 小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 2 对应 [\\\"a\\\",\\\"b\\\",\\\"c\\\"]，我们需要按一次键来输入 \\\"a\\\"，按两次键来输入 \\\"b\\\"，按三次键来输入 \\\"c\\\"。\n现在允许你将编号为 2 到 9 的按键重新映射到 不同 字母集合。每个按键可以映射到 任意数量 的字母，但每个字母 必须 恰好 映射到 一个 按键上。你需要找到输入字符串 word 所需的 最少 按键次数。\n返回重新映射按键后输入 word 所需的 最少 按键次数。\n下面给出了一种电话键盘上字母到按键的映射作为示例。注意 1，*，# 和 0 不 对应任何字母。\n示例 1：\n输入word = \"abcde\"\n输出：5示例 2：\n输入word = \"xycdefghij\"\n输出：12\n\n提示：\n1 <= word.length <= 26\nword 仅由小写英文字母组成。\nword 中的所有字母互不相同。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumPushes(String word) {\n```",
        "solution": "class Solution {\n    public int minimumPushes(String word) {\n        int n = word.length();\n        int k = n / 8;\n        return (k * 4 + n % 8) * (k + 1);\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String word_1 = \"abcde\";\n        int ans_1 = 5;\n        assert solution.minimumPushes(word_1) == ans_1;\n        String word_2 = \"xycdefghij\";\n        int ans_2 = 12;\n        assert solution.minimumPushes(word_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumPushes(String word) {",
        "function_name": "minimumPushes",
        "difficulty_level": "Easy",
        "time": "20240121"
    },
    {
        "id": "3015",
        "prompt_base": "\"\"\"\n给你三个 正整数 n 、x 和 y 。在城市中，存在编号从 1 到 n 的房屋，由 n 条街道相连。对所有 1 <= i < n ，都存在一条街道连接编号为 i 的房屋与编号为 i + 1 的房屋。另存在一条街道连接编号为 x 的房屋与编号为 y 的房屋。\n对于每个 k（1 <= k <= n），你需要找出所有满足要求的 房屋对 [house_1, house_2] ，即从 house_1 到 house_2 需要经过的 最少 街道数为 k 。\n返回一个下标从 1 开始且长度为 n 的数组 result ，其中 result[k] 表示所有满足要求的房屋对的数量，即从一个房屋到另一个房屋需要经过的 最少 街道数为 k 。\n注意，x 与 y 可以 相等 。\n示例 1：\n输入n = 3, x = 1, y = 3\n输出：[6,0,0]示例 2：\n输入n = 5, x = 2, y = 4\n输出：[10,8,2,0,0]\n\n提示：\n2 <= n <= 100\n1 <= x, y <= n\n\"\"\"\n\nclass Solution {\n    public long[] countOfPairs(int n, int x, int y) {",
        "prompt_chat": "给你三个 正整数 n 、x 和 y 。在城市中，存在编号从 1 到 n 的房屋，由 n 条街道相连。对所有 1 <= i < n ，都存在一条街道连接编号为 i 的房屋与编号为 i + 1 的房屋。另存在一条街道连接编号为 x 的房屋与编号为 y 的房屋。\n对于每个 k（1 <= k <= n），你需要找出所有满足要求的 房屋对 [house_1, house_2] ，即从 house_1 到 house_2 需要经过的 最少 街道数为 k 。\n返回一个下标从 1 开始且长度为 n 的数组 result ，其中 result[k] 表示所有满足要求的房屋对的数量，即从一个房屋到另一个房屋需要经过的 最少 街道数为 k 。\n注意，x 与 y 可以 相等 。\n示例 1：\n输入n = 3, x = 1, y = 3\n输出：[6,0,0]示例 2：\n输入n = 5, x = 2, y = 4\n输出：[10,8,2,0,0]\n\n提示：\n2 <= n <= 100\n1 <= x, y <= n\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long[] countOfPairs(int n, int x, int y) {\n```",
        "solution": "class Solution {\n    public long[] countOfPairs(int n, int x, int y) {\n        if (x > y) {\n            int temp = x;\n            x = y;\n            y = temp;\n        }\n\n        diff = new int[n + 1];\n\n        for (int i = 1; i <= n; i++) {\n            add(1, i - 1, 1);\n            add(1, n - i, 1);\n            if (x + 1 >= y) {\n                continue;\n            }\n            if (i <= x) {\n                update(i, x, y, n);\n            } else if (i >= y) {\n                update(n + 1 - i, n + 1 - y, n + 1 - x, n);\n            } else if (i < (x + y) / 2) {\n                update2(i, x, y, n);\n            } else if (i > (x + y + 1) / 2) {\n                update2(n + 1 - i, n + 1 - y, n + 1 - x, n);\n            }\n        }\n\n        long[] ans = new long[n];\n        long sumD = 0;\n        for (int i = 0; i < n; i++) {\n            sumD += diff[i + 1];\n            ans[i] = sumD;\n        }\n        return ans;\n    }\n\n    private int[] diff;\n\n    private void add(int l, int r, int v) {\n        if (l > r) return;\n        diff[l] += v;\n        diff[r + 1] -= v;\n    }\n\n    private void update(int i, int x, int y, int n) {\n        add(y - i, n - i, -1); // 撤销 [y,n]\n        int dec = y - x - 1; // 缩短的距离\n        add(y - i - dec, n - i - dec, 1);\n\n        int j = (x + y + 1) / 2 + 1;\n        add(j - i, y - 1 - i, -1); // 撤销 [j, y-1]\n        add(x - i + 2, x - i + y - j + 1, 1);\n    }\n\n    private void update2(int i, int x, int y, int n) {\n        add(y - i, n - i, -1); // 撤销 [y,n]\n        int dec = (y - i) - (i - x + 1); // 缩短的距离\n        add(y - i - dec, n - i - dec, 1);\n\n        int j = i + (y - x + 1) / 2 + 1;\n        add(j - i, y - 1 - i, -1); // 撤销 [j, y-1]\n        add(i - x + 2, i - x + y - j + 1, 1);\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n_1 = 3;\n        int x_1 = 1;\n        int y_1 = 3;\n        long[] ans_1 = {6,0,0};\n        assert Arrays.equals(solution.countOfPairs(n_1, x_1, y_1), ans_1);\n        int n_2 = 5;\n        int x_2 = 2;\n        int y_2 = 4;\n        long[] ans_2 = {10,8,2,0,0};\n        assert Arrays.equals(solution.countOfPairs(n_2, x_2, y_2), ans_2);\n        int n_3 = 4;\n        int x_3 = 1;\n        int y_3 = 1;\n        long[] ans_3 = {6,4,2,0};\n        assert Arrays.equals(solution.countOfPairs(n_3, x_3, y_3), ans_3);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long[] countOfPairs(int n, int x, int y) {",
        "function_name": "countOfPairs",
        "difficulty_level": "Middle",
        "time": "20240121"
    },
    {
        "id": "3016",
        "prompt_base": "\"\"\"\n给你一个字符串 word，由小写英文字母组成。电话键盘上的按键与 不同 小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 2 对应 [\\\"a\\\",\\\"b\\\",\\\"c\\\"]，我们需要按一次键来输入 \\\"a\\\"，按两次键来输入 \\\"b\\\"，按三次键来输入 \\\"c\\\"。\n现在允许你将编号为 2 到 9 的按键重新映射到 不同 字母集合。每个按键可以映射到 任意数量 的字母，但每个字母 必须 恰好 映射到 一个 按键上。你需要找到输入字符串 word 所需的 最少 按键次数。\n返回重新映射按键后输入 word 所需的 最少 按键次数。\n下面给出了一种电话键盘上字母到按键的映射作为示例。注意 1，*，# 和 0 不 对应任何字母。\n示例 1：\n输入word = \"abcde\"\n输出：5示例 2：\n输入word = \"xyzxyzxyzxyz\"\n输出：12\n\n提示：\n1 <= word.length <= 10^5\nword 仅由小写英文字母组成。\n\"\"\"\n\nclass Solution {\n    public int minimumPushes(String word) {",
        "prompt_chat": "给你一个字符串 word，由小写英文字母组成。电话键盘上的按键与 不同 小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 2 对应 [\\\"a\\\",\\\"b\\\",\\\"c\\\"]，我们需要按一次键来输入 \\\"a\\\"，按两次键来输入 \\\"b\\\"，按三次键来输入 \\\"c\\\"。\n现在允许你将编号为 2 到 9 的按键重新映射到 不同 字母集合。每个按键可以映射到 任意数量 的字母，但每个字母 必须 恰好 映射到 一个 按键上。你需要找到输入字符串 word 所需的 最少 按键次数。\n返回重新映射按键后输入 word 所需的 最少 按键次数。\n下面给出了一种电话键盘上字母到按键的映射作为示例。注意 1，*，# 和 0 不 对应任何字母。\n示例 1：\n输入word = \"abcde\"\n输出：5示例 2：\n输入word = \"xyzxyzxyzxyz\"\n输出：12\n\n提示：\n1 <= word.length <= 10^5\nword 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumPushes(String word) {\n```",
        "solution": "class Solution {\n    public int minimumPushes(String word) {\n        int[] cnt = new int[26];\n        for (char b : word.toCharArray()) {\n            cnt[b - 'a']++;\n        }\n        Arrays.sort(cnt);\n\n        int ans = 0;\n        for (int i = 0; i < 26; i++) {\n            ans += cnt[25 - i] * (i / 8 + 1);\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String word_1 = \"abcde\";\n        int ans_1 = 5;\n        assert solution.minimumPushes(word_1) == ans_1;\n        String word_2 = \"xyzxyzxyzxyz\";\n        int ans_2 = 12;\n        assert solution.minimumPushes(word_2) == ans_2;\n        String word_3 = \"aabbccddeeffgghhiiiiii\";\n        int ans_3 = 24;\n        assert solution.minimumPushes(word_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumPushes(String word) {",
        "function_name": "minimumPushes",
        "difficulty_level": "Middle",
        "time": "20240121"
    },
    {
        "id": "3017",
        "prompt_base": "\"\"\"\n给你三个 正整数 n 、x 和 y 。在城市中，存在编号从 1 到 n 的房屋，由 n 条街道相连。对所有 1 <= i < n ，都存在一条街道连接编号为 i 的房屋与编号为 i + 1 的房屋。另存在一条街道连接编号为 x 的房屋与编号为 y 的房屋。\n对于每个 k（1 <= k <= n），你需要找出所有满足要求的 房屋对 [house_1, house_2] ，即从 house_1 到 house_2 需要经过的 最少 街道数为 k 。\n返回一个下标从 1 开始且长度为 n 的数组 result ，其中 result[k] 表示所有满足要求的房屋对的数量，即从一个房屋到另一个房屋需要经过的 最少 街道数为 k 。\n注意，x 与 y 可以 相等 。\n示例 1：\n输入n = 3, x = 1, y = 3\n输出：[6,0,0]示例 2：\n输入n = 5, x = 2, y = 4\n输出：[10,8,2,0,0]\n\n提示：\n2 <= n <= 10^5\n1 <= x, y <= n\n\"\"\"\n\nclass Solution {\n    public long[] countOfPairs(int n, int x, int y) {",
        "prompt_chat": "给你三个 正整数 n 、x 和 y 。在城市中，存在编号从 1 到 n 的房屋，由 n 条街道相连。对所有 1 <= i < n ，都存在一条街道连接编号为 i 的房屋与编号为 i + 1 的房屋。另存在一条街道连接编号为 x 的房屋与编号为 y 的房屋。\n对于每个 k（1 <= k <= n），你需要找出所有满足要求的 房屋对 [house_1, house_2] ，即从 house_1 到 house_2 需要经过的 最少 街道数为 k 。\n返回一个下标从 1 开始且长度为 n 的数组 result ，其中 result[k] 表示所有满足要求的房屋对的数量，即从一个房屋到另一个房屋需要经过的 最少 街道数为 k 。\n注意，x 与 y 可以 相等 。\n示例 1：\n输入n = 3, x = 1, y = 3\n输出：[6,0,0]示例 2：\n输入n = 5, x = 2, y = 4\n输出：[10,8,2,0,0]\n\n提示：\n2 <= n <= 10^5\n1 <= x, y <= n\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long[] countOfPairs(int n, int x, int y) {\n```",
        "solution": "class Solution {\n    public long[] countOfPairs(int n, int x, int y) {\n        if (x > y) {\n            int temp = x;\n            x = y;\n            y = temp;\n        }\n\n        long[] ans = new long[n];\n        if (x + 1 >= y) {\n            for (int i = 1; i < n; i++) {\n                ans[i - 1] = (n - i) * 2;\n            }\n            return ans;\n        }\n\n        diff = new int[n + 1];\n        for (int i = 1; i < n; i++) {\n            if (i <= x) {\n                int k = (x + y + 1) / 2;\n                add(1, k - i);\n                add(x - i + 2, x - i + y - k);\n                add(x - i + 1, x - i + 1 + n - y);\n            } else if (i < (x + y) / 2) {\n                int k = i + (y - x + 1) / 2;\n                add(1, k - i);\n                add(i - x + 2, i - x + y - k);\n                add(i - x + 1, i - x + 1 + n - y);\n            } else {\n                add(1, n - i);\n            }\n        }\n\n        long sumD = 0;\n        for (int i = 0; i < n; i++) {\n            sumD += diff[i + 1];\n            ans[i] = sumD * 2;\n        }\n        return ans;\n    }\n\n    private int[] diff;\n\n    private void add(int l, int r) {\n        diff[l]++;\n        diff[r + 1]--;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n_1 = 3;\n        int x_1 = 1;\n        int y_1 = 3;\n        long[] ans_1 = {6,0,0};\n        assert Arrays.equals(solution.countOfPairs(n_1, x_1, y_1), ans_1);\n        int n_2 = 5;\n        int x_2 = 2;\n        int y_2 = 4;\n        long[] ans_2 = {10,8,2,0,0};\n        assert Arrays.equals(solution.countOfPairs(n_2, x_2, y_2), ans_2);\n        int n_3 = 4;\n        int x_3 = 1;\n        int y_3 = 1;\n        long[] ans_3 = {6,4,2,0};\n        assert Arrays.equals(solution.countOfPairs(n_3, x_3, y_3), ans_3);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long[] countOfPairs(int n, int x, int y) {",
        "function_name": "countOfPairs",
        "difficulty_level": "Hard",
        "time": "20240121"
    },
    {
        "id": "3019",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的字符串 s ，该字符串由用户输入。按键变更的定义是：使用与上次使用的按键不同的键。例如 s = \\\"ab\\\" 表示按键变更一次，而 s = \\\"bBBb\\\" 不存在按键变更。\n返回用户输入过程中按键变更的次数。\n注意：shift 或 caps lock 等修饰键不计入按键变更，也就是说，如果用户先输入字母 'a' 然后输入字母 'A' ，不算作按键变更。\n示例 1：\n输入s = \"aAbBcC\"\n输出：2示例 2：\n输入s = \"AaAaAaaA\"\n输出：0\n\n提示：\n1 <= s.length <= 100\ns 仅由英文大写字母和小写字母组成。\n\"\"\"\n\nclass Solution {\n    public int countKeyChanges(String s) {",
        "prompt_chat": "给你一个下标从 0 开始的字符串 s ，该字符串由用户输入。按键变更的定义是：使用与上次使用的按键不同的键。例如 s = \\\"ab\\\" 表示按键变更一次，而 s = \\\"bBBb\\\" 不存在按键变更。\n返回用户输入过程中按键变更的次数。\n注意：shift 或 caps lock 等修饰键不计入按键变更，也就是说，如果用户先输入字母 'a' 然后输入字母 'A' ，不算作按键变更。\n示例 1：\n输入s = \"aAbBcC\"\n输出：2示例 2：\n输入s = \"AaAaAaaA\"\n输出：0\n\n提示：\n1 <= s.length <= 100\ns 仅由英文大写字母和小写字母组成。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int countKeyChanges(String s) {\n```",
        "solution": "class Solution {\n    public int countKeyChanges(String s) {\n        int ans = 0;\n        for (int i = 1; i < s.length(); i++) {\n            if ((s.charAt(i - 1) & 31) != (s.charAt(i) & 31)) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s_1 = \"aAbBcC\";\n        int ans_1 = 2;\n        assert solution.countKeyChanges(s_1) == ans_1;\n        String s_2 = \"AaAaAaaA\";\n        int ans_2 = 0;\n        assert solution.countKeyChanges(s_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int countKeyChanges(String s) {",
        "function_name": "countKeyChanges",
        "difficulty_level": "Easy",
        "time": "20240128"
    },
    {
        "id": "3020",
        "prompt_base": "\"\"\"\n给你一个 正整数 数组 nums 。\n你需要从数组中选出一个满足下述条件的子集：\n你可以将选中的元素放置在一个下标从 0 开始的数组中，并使其遵循以下模式：[x, x^2, x^4, ..., x^{k/2}, x^k, x^{k/2}, ..., x^4, x^2, x]（注意，k 可以是任何 非负 的 2 的幂）。例如，[2, 4, 16, 4, 2] 和 [3, 9, 3] 都符合这一模式，而 [2, 4, 8, 4, 2] 则不符合。\n返回满足这些条件的子集中，元素数量的 最大值 。\n示例 1：\n输入nums = [5,4,1,2,2]\n输出：3示例 2：\n输入nums = [1,3,2,4]\n输出：1\n\n提示：\n2 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\n\"\"\"\n\nclass Solution {\n    public int maximumLength(int[] nums) {",
        "prompt_chat": "给你一个 正整数 数组 nums 。\n你需要从数组中选出一个满足下述条件的子集：\n你可以将选中的元素放置在一个下标从 0 开始的数组中，并使其遵循以下模式：[x, x^2, x^4, ..., x^{k/2}, x^k, x^{k/2}, ..., x^4, x^2, x]（注意，k 可以是任何 非负 的 2 的幂）。例如，[2, 4, 16, 4, 2] 和 [3, 9, 3] 都符合这一模式，而 [2, 4, 8, 4, 2] 则不符合。\n返回满足这些条件的子集中，元素数量的 最大值 。\n示例 1：\n输入nums = [5,4,1,2,2]\n输出：3示例 2：\n输入nums = [1,3,2,4]\n输出：1\n\n提示：\n2 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maximumLength(int[] nums) {\n```",
        "solution": "class Solution {\n    public int maximumLength(int[] nums) {\n        HashMap<Long, Integer> cnt = new HashMap<>();\n        for (int x : nums) {\n            cnt.merge((long) x, 1, Integer::sum);\n        }\n        Integer c1 = cnt.remove(1L);\n        int ans = c1 != null ? c1 - 1 | 1 : 0;\n        for (long x : cnt.keySet()) {\n            int res = 0;\n            for (; cnt.getOrDefault(x, 0) > 1; x *= x) {\n                res += 2;\n            }\n            ans = Math.max(ans, res + (cnt.containsKey(x) ? 1 : -1)); // 保证 res 是奇数\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {5,4,1,2,2};\n        int ans_1 = 3;\n        assert solution.maximumLength(nums_1) == ans_1;\n        int[] nums_2 = {1,3,2,4};\n        int ans_2 = 1;\n        assert solution.maximumLength(nums_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maximumLength(int[] nums) {",
        "function_name": "maximumLength",
        "difficulty_level": "Middle",
        "time": "20240128"
    },
    {
        "id": "3021",
        "prompt_base": "\"\"\"\nAlice 和 Bob 在一个长满鲜花的环形草地玩一个回合制游戏。环形的草地上有一些鲜花，Alice 到 Bob 之间顺时针有 x 朵鲜花，逆时针有 y 朵鲜花。游戏过程如下：\nAlice 先行动。\n每一次行动中，当前玩家必须选择顺时针或者逆时针，然后在这个方向上摘一朵鲜花。\n一次行动结束后，如果所有鲜花都被摘完了，那么 当前 玩家抓住对手并赢得游戏的胜利。\n给你两个整数 n 和 m ，你的任务是求出满足以下条件的所有 (x, y) 对：\n按照上述规则，Alice 必须赢得游戏。\nAlice 顺时针方向上的鲜花数目 x 必须在区间 [1,n] 之间。\nAlice 逆时针方向上的鲜花数目 y 必须在区间 [1,m] 之间。\n请你返回满足题目描述的数对 (x, y) 的数目。\n示例 1：\n输入n = 3, m = 2\n输出：3示例 2：\n输入n = 1, m = 1\n输出：0\n\n提示：\n1 <= n, m <= 10^5\n\"\"\"\n\nclass Solution {\n    public long flowerGame(int n, int m) {",
        "prompt_chat": "Alice 和 Bob 在一个长满鲜花的环形草地玩一个回合制游戏。环形的草地上有一些鲜花，Alice 到 Bob 之间顺时针有 x 朵鲜花，逆时针有 y 朵鲜花。游戏过程如下：\nAlice 先行动。\n每一次行动中，当前玩家必须选择顺时针或者逆时针，然后在这个方向上摘一朵鲜花。\n一次行动结束后，如果所有鲜花都被摘完了，那么 当前 玩家抓住对手并赢得游戏的胜利。\n给你两个整数 n 和 m ，你的任务是求出满足以下条件的所有 (x, y) 对：\n按照上述规则，Alice 必须赢得游戏。\nAlice 顺时针方向上的鲜花数目 x 必须在区间 [1,n] 之间。\nAlice 逆时针方向上的鲜花数目 y 必须在区间 [1,m] 之间。\n请你返回满足题目描述的数对 (x, y) 的数目。\n示例 1：\n输入n = 3, m = 2\n输出：3示例 2：\n输入n = 1, m = 1\n输出：0\n\n提示：\n1 <= n, m <= 10^5\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long flowerGame(int n, int m) {\n```",
        "solution": "class Solution {\n    public long flowerGame(int n, int m) {\n        return (long) n * m / 2;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n_1 = 3;\n        int m_1 = 2;\n        long ans_1 = 3;\n        assert solution.flowerGame(n_1, m_1) == ans_1;\n        int n_2 = 1;\n        int m_2 = 1;\n        long ans_2 = 0;\n        assert solution.flowerGame(n_2, m_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long flowerGame(int n, int m) {",
        "function_name": "flowerGame",
        "difficulty_level": "Middle",
        "time": "20240128"
    },
    {
        "id": "3022",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。一次操作中，你可以选择 nums 中满足 0 <= i < nums.length - 1 的一个下标 i ，并将 nums[i] 和 nums[i + 1] 替换为数字 nums[i] & nums[i + 1] ，其中 & 表示按位 AND 操作。\n请你返回 至多 k 次操作以内，使 nums 中所有剩余元素按位 OR 结果的 最小值 。\n示例 1：\n输入nums = [3,5,3,2,7], k = 2\n输出：3示例 2：\n输入nums = [7,3,15,14,2,8], k = 4\n输出：2\n\n提示：\n1 <= nums.length <= 10^5\n0 <= nums[i] < 2^30\n0 <= k < nums.length\n\"\"\"\n\nclass Solution {\n    public int minOrAfterOperations(int[] nums, int k) {",
        "prompt_chat": "给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。一次操作中，你可以选择 nums 中满足 0 <= i < nums.length - 1 的一个下标 i ，并将 nums[i] 和 nums[i + 1] 替换为数字 nums[i] & nums[i + 1] ，其中 & 表示按位 AND 操作。\n请你返回 至多 k 次操作以内，使 nums 中所有剩余元素按位 OR 结果的 最小值 。\n示例 1：\n输入nums = [3,5,3,2,7], k = 2\n输出：3示例 2：\n输入nums = [7,3,15,14,2,8], k = 4\n输出：2\n\n提示：\n1 <= nums.length <= 10^5\n0 <= nums[i] < 2^30\n0 <= k < nums.length\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minOrAfterOperations(int[] nums, int k) {\n```",
        "solution": "class Solution {\n    public int minOrAfterOperations(int[] nums, int k) {\n        int ans = 0;\n        int mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0; // 操作次数\n            int and = -1; // -1 的二进制全为 1\n            for (int x : nums) {\n                and &= x & mask;\n                if (and != 0) {\n                    cnt++; // 合并 x，操作次数加一\n                } else {\n                    and = -1; // 准备合并下一段\n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; // 答案的这个比特位必须是 1\n                mask ^= 1 << b; // 后面不考虑这个比特位\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {3,5,3,2,7};\n        int k_1 = 2;\n        int ans_1 = 3;\n        assert solution.minOrAfterOperations(nums_1, k_1) == ans_1;\n        int[] nums_2 = {7,3,15,14,2,8};\n        int k_2 = 4;\n        int ans_2 = 2;\n        assert solution.minOrAfterOperations(nums_2, k_2) == ans_2;\n        int[] nums_3 = {10,7,10,3,9,14,9,4};\n        int k_3 = 1;\n        int ans_3 = 15;\n        assert solution.minOrAfterOperations(nums_3, k_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minOrAfterOperations(int[] nums, int k) {",
        "function_name": "minOrAfterOperations",
        "difficulty_level": "Hard",
        "time": "20240128"
    },
    {
        "id": "3028",
        "prompt_base": "\"\"\"\n边界上有一只蚂蚁，它有时向 左 走，有时向 右 走。\n给你一个 非零 整数数组 nums 。蚂蚁会按顺序读取 nums 中的元素，从第一个元素开始直到结束。每一步，蚂蚁会根据当前元素的值移动：\n如果 nums[i] < 0 ，向 左 移动 -nums[i]单位。\n如果 nums[i] > 0 ，向 右 移动 nums[i]单位。\n返回蚂蚁 返回 到边界上的次数。\n注意：\n边界两侧有无限的空间。\n只有在蚂蚁移动了 |nums[i]| 单位后才检查它是否位于边界上。换句话说，如果蚂蚁只是在移动过程中穿过了边界，则不会计算在内。\n示例 1：\n输入nums = [2,3,-5]\n输出：1示例 2：\n输入nums = [3,2,-3,-4]\n输出：0\n\n提示：\n1 <= nums.length <= 100\n-10 <= nums[i] <= 10\nnums[i] != 0\n\"\"\"\n\nclass Solution {\n    public int returnToBoundaryCount(int[] nums) {",
        "prompt_chat": "边界上有一只蚂蚁，它有时向 左 走，有时向 右 走。\n给你一个 非零 整数数组 nums 。蚂蚁会按顺序读取 nums 中的元素，从第一个元素开始直到结束。每一步，蚂蚁会根据当前元素的值移动：\n如果 nums[i] < 0 ，向 左 移动 -nums[i]单位。\n如果 nums[i] > 0 ，向 右 移动 nums[i]单位。\n返回蚂蚁 返回 到边界上的次数。\n注意：\n边界两侧有无限的空间。\n只有在蚂蚁移动了 |nums[i]| 单位后才检查它是否位于边界上。换句话说，如果蚂蚁只是在移动过程中穿过了边界，则不会计算在内。\n示例 1：\n输入nums = [2,3,-5]\n输出：1示例 2：\n输入nums = [3,2,-3,-4]\n输出：0\n\n提示：\n1 <= nums.length <= 100\n-10 <= nums[i] <= 10\nnums[i] != 0\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int returnToBoundaryCount(int[] nums) {\n```",
        "solution": "class Solution {\n    public int returnToBoundaryCount(int[] nums) {\n        int ans = 0;\n        int sum = 0;\n        for (int x : nums) {\n            sum += x;\n            if (sum == 0) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {2,3,-5};\n        int ans_1 = 1;\n        assert solution.returnToBoundaryCount(nums_1) == ans_1;\n        int[] nums_2 = {3,2,-3,-4};\n        int ans_2 = 0;\n        assert solution.returnToBoundaryCount(nums_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int returnToBoundaryCount(int[] nums) {",
        "function_name": "returnToBoundaryCount",
        "difficulty_level": "Easy",
        "time": "20240204"
    },
    {
        "id": "3029",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的字符串 word 和一个整数 k 。\n在每一秒，你必须执行以下操作：\n移除 word 的前 k 个字符。\n在 word 的末尾添加 k 个任意字符。\n注意 添加的字符不必和移除的字符相同。但是，必须在每一秒钟都执行 两种 操作。\n返回将 word 恢复到其 初始 状态所需的 最短 时间（该时间必须大于零）。\n示例 1：\n输入word = \"abacaba\", k = 3\n输出：2示例 2：\n输入word = \"abacaba\", k = 4\n输出：1\n\n提示：\n1 <= word.length <= 50\n1 <= k <= word.length\nword仅由小写英文字母组成。\n\"\"\"\n\nclass Solution {\n    public int minimumTimeToInitialState(String word, int k) {",
        "prompt_chat": "给你一个下标从 0 开始的字符串 word 和一个整数 k 。\n在每一秒，你必须执行以下操作：\n移除 word 的前 k 个字符。\n在 word 的末尾添加 k 个任意字符。\n注意 添加的字符不必和移除的字符相同。但是，必须在每一秒钟都执行 两种 操作。\n返回将 word 恢复到其 初始 状态所需的 最短 时间（该时间必须大于零）。\n示例 1：\n输入word = \"abacaba\", k = 3\n输出：2示例 2：\n输入word = \"abacaba\", k = 4\n输出：1\n\n提示：\n1 <= word.length <= 50\n1 <= k <= word.length\nword仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumTimeToInitialState(String word, int k) {\n```",
        "solution": "class Solution {\n    public int minimumTimeToInitialState(String S, int k) {\n        char[] s = S.toCharArray();\n        int n = s.length;\n        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(z[i - l], r - i + 1);\n            }\n            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n                l = i;\n                r = i + z[i];\n                z[i]++;\n            }\n            if (i % k == 0 && z[i] >= n - i) {\n                return i / k;\n            }\n        }\n        return (n - 1) / k + 1;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String word_1 = \"abacaba\";\n        int k_1 = 3;\n        int ans_1 = 2;\n        assert solution.minimumTimeToInitialState(word_1, k_1) == ans_1;\n        String word_2 = \"abacaba\";\n        int k_2 = 4;\n        int ans_2 = 1;\n        assert solution.minimumTimeToInitialState(word_2, k_2) == ans_2;\n        String word_3 = \"abcbabcd\";\n        int k_3 = 2;\n        int ans_3 = 4;\n        assert solution.minimumTimeToInitialState(word_3, k_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumTimeToInitialState(String word, int k) {",
        "function_name": "minimumTimeToInitialState",
        "difficulty_level": "Middle",
        "time": "20240204"
    },
    {
        "id": "3030",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始、大小为 m x n 的网格 image ，表示一个灰度图像，其中 image[i][j] 表示在范围 [0..255] 内的某个像素强度。另给你一个 非负 整数 threshold 。\n如果 image[a][b] 和 image[c][d] 满足 |a - c| + |b - d| == 1 ，则称这两个像素是 相邻像素 。\n区域 是一个 3 x 3 的子网格，且满足区域中任意两个 相邻 像素之间，像素强度的 绝对差 小于或等于 threshold 。\n区域 内的所有像素都认为属于该区域，而一个像素 可以 属于 多个 区域。\n你需要计算一个下标从 0 开始、大小为 m x n 的网格 result ，其中 result[i][j] 是 image[i][j] 所属区域的 平均 强度，向下取整 到最接近的整数。如果 image[i][j] 属于多个区域，result[i][j] 是这些区域的 “取整后的平均强度” 的 平均值，也 向下取整 到最接近的整数。如果 image[i][j] 不属于任何区域，则 result[i][j] 等于 image[i][j] 。\n返回网格 result 。\n示例 1：\n输入image = [[5,6,7,10],[8,9,10,10],[11,12,13,10]], threshold = 3\n输出：[[9,9,9,9],[9,9,9,9],[9,9,9,9]]示例 2：\n输入image = [[10,20,30],[15,25,35],[20,30,40],[25,35,45]], threshold = 12\n输出：[[25,25,25],[27,27,27],[27,27,27],[30,30,30]]\n\n提示：\n3 <= n, m <= 500\n0 <= image[i][j] <= 255\n0 <= threshold <= 255\n\"\"\"\n\nclass Solution {\n    public int[][] resultGrid(int[][] image, int threshold) {",
        "prompt_chat": "给你一个下标从 0 开始、大小为 m x n 的网格 image ，表示一个灰度图像，其中 image[i][j] 表示在范围 [0..255] 内的某个像素强度。另给你一个 非负 整数 threshold 。\n如果 image[a][b] 和 image[c][d] 满足 |a - c| + |b - d| == 1 ，则称这两个像素是 相邻像素 。\n区域 是一个 3 x 3 的子网格，且满足区域中任意两个 相邻 像素之间，像素强度的 绝对差 小于或等于 threshold 。\n区域 内的所有像素都认为属于该区域，而一个像素 可以 属于 多个 区域。\n你需要计算一个下标从 0 开始、大小为 m x n 的网格 result ，其中 result[i][j] 是 image[i][j] 所属区域的 平均 强度，向下取整 到最接近的整数。如果 image[i][j] 属于多个区域，result[i][j] 是这些区域的 “取整后的平均强度” 的 平均值，也 向下取整 到最接近的整数。如果 image[i][j] 不属于任何区域，则 result[i][j] 等于 image[i][j] 。\n返回网格 result 。\n示例 1：\n输入image = [[5,6,7,10],[8,9,10,10],[11,12,13,10]], threshold = 3\n输出：[[9,9,9,9],[9,9,9,9],[9,9,9,9]]示例 2：\n输入image = [[10,20,30],[15,25,35],[20,30,40],[25,35,45]], threshold = 12\n输出：[[25,25,25],[27,27,27],[27,27,27],[30,30,30]]\n\n提示：\n3 <= n, m <= 500\n0 <= image[i][j] <= 255\n0 <= threshold <= 255\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int[][] resultGrid(int[][] image, int threshold) {\n```",
        "solution": "class Solution {\n    public int[][] resultGrid(int[][] a, int threshold) {\n        int m = a.length;\n        int n = a[0].length;\n        int[][] result = new int[m][n];\n        int[][] cnt = new int[m][n];\n        for (int i = 2; i < m; i++) {\n            next:\n            for (int j = 2; j < n; j++) {\n                // 检查左右相邻格子\n                for (int x = i - 2; x <= i; x++) {\n                    if (Math.abs(a[x][j - 2] - a[x][j - 1]) > threshold || Math.abs(a[x][j - 1] - a[x][j]) > threshold) {\n                        continue next; // 不合法，下一个\n                    }\n                }\n\n                // 检查上下相邻格子\n                for (int y = j - 2; y <= j; ++y) {\n                    if (Math.abs(a[i - 2][y] - a[i - 1][y]) > threshold || Math.abs(a[i - 1][y] - a[i][y]) > threshold) {\n                        continue next; // 不合法，下一个\n                    }\n                }\n\n                // 合法，计算 3x3 子网格的平均值\n                int avg = 0;\n                for (int x = i - 2; x <= i; x++) {\n                    for (int y = j - 2; y <= j; y++) {\n                        avg += a[x][y];\n                    }\n                }\n                avg /= 9;\n\n                // 更新 3x3 子网格内的 result\n                for (int x = i - 2; x <= i; x++) {\n                    for (int y = j - 2; y <= j; y++) {\n                        result[x][y] += avg; // 先累加，最后再求平均值\n                        cnt[x][y]++;\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (cnt[i][j] == 0) { // (i,j) 不属于任何子网格\n                    result[i][j] = a[i][j];\n                } else {\n                    result[i][j] /= cnt[i][j]; // 求平均值\n                }\n            }\n        }\n        return result;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] image_1 = {{5,6,7,10},{8,9,10,10},{11,12,13,10}};\n        int threshold_1 = 3;\n        int[][] ans_1 = {{9,9,9,9},{9,9,9,9},{9,9,9,9}};\n        assert Arrays.deepEquals(solution.resultGrid(image_1, threshold_1), ans_1);\n        int[][] image_2 = {{10,20,30},{15,25,35},{20,30,40},{25,35,45}};\n        int threshold_2 = 12;\n        int[][] ans_2 = {{25,25,25},{27,27,27},{27,27,27},{30,30,30}};\n        assert Arrays.deepEquals(solution.resultGrid(image_2, threshold_2), ans_2);\n        int[][] image_3 = {{5,6,7},{8,9,10},{11,12,13}};\n        int threshold_3 = 1;\n        int[][] ans_3 = {{5,6,7},{8,9,10},{11,12,13}};\n        assert Arrays.deepEquals(solution.resultGrid(image_3, threshold_3), ans_3);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int[][] resultGrid(int[][] image, int threshold) {",
        "function_name": "resultGrid",
        "difficulty_level": "Middle",
        "time": "20240204"
    },
    {
        "id": "3031",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的字符串 word 和一个整数 k 。\n在每一秒，你必须执行以下操作：\n移除 word 的前 k 个字符。\n在 word 的末尾添加 k 个任意字符。\n注意 添加的字符不必和移除的字符相同。但是，必须在每一秒钟都执行 两种 操作。\n返回将 word 恢复到其 初始 状态所需的 最短 时间（该时间必须大于零）。\n示例 1：\n输入word = \"abacaba\", k = 3\n输出：2示例 2：\n输入word = \"abacaba\", k = 4\n输出：1\n\n提示：\n1 <= word.length <= 10^6\n1 <= k <= word.length\nword仅由小写英文字母组成。\n\"\"\"\n\nclass Solution {\n    public int minimumTimeToInitialState(String word, int k) {",
        "prompt_chat": "给你一个下标从 0 开始的字符串 word 和一个整数 k 。\n在每一秒，你必须执行以下操作：\n移除 word 的前 k 个字符。\n在 word 的末尾添加 k 个任意字符。\n注意 添加的字符不必和移除的字符相同。但是，必须在每一秒钟都执行 两种 操作。\n返回将 word 恢复到其 初始 状态所需的 最短 时间（该时间必须大于零）。\n示例 1：\n输入word = \"abacaba\", k = 3\n输出：2示例 2：\n输入word = \"abacaba\", k = 4\n输出：1\n\n提示：\n1 <= word.length <= 10^6\n1 <= k <= word.length\nword仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumTimeToInitialState(String word, int k) {\n```",
        "solution": "class Solution {\n    public int minimumTimeToInitialState(String S, int k) {\n        char[] s = S.toCharArray();\n        int n = s.length;\n        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(z[i - l], r - i + 1);\n            }\n            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n                l = i;\n                r = i + z[i];\n                z[i]++;\n            }\n            if (i % k == 0 && z[i] >= n - i) {\n                return i / k;\n            }\n        }\n        return (n - 1) / k + 1;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String word_1 = \"abacaba\";\n        int k_1 = 3;\n        int ans_1 = 2;\n        assert solution.minimumTimeToInitialState(word_1, k_1) == ans_1;\n        String word_2 = \"abacaba\";\n        int k_2 = 4;\n        int ans_2 = 1;\n        assert solution.minimumTimeToInitialState(word_2, k_2) == ans_2;\n        String word_3 = \"abcbabcd\";\n        int k_3 = 2;\n        int ans_3 = 4;\n        assert solution.minimumTimeToInitialState(word_3, k_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumTimeToInitialState(String word, int k) {",
        "function_name": "minimumTimeToInitialState",
        "difficulty_level": "Hard",
        "time": "20240204"
    },
    {
        "id": "3033",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始、大小为 m x n 的整数矩阵 matrix ，新建一个下标从 0 开始、名为 answer 的矩阵。使 answer 与 matrix 相等，接着将其中每个值为 -1 的元素替换为所在列的 最大 元素。\n返回矩阵 answer 。\n示例 1：\n输入matrix = [[1,2,-1],[4,-1,6],[7,8,9]]\n输出：[[1,2,9],[4,8,6],[7,8,9]]示例 2：\n输入matrix = [[3,-1],[5,2]]\n输出：[[3,2],[5,2]]\n\n提示：\nm == matrix.length\nn == matrix[i].length\n2 <= m, n <= 50\n-1 <= matrix[i][j] <= 100\n测试用例中生成的输入满足每列至少包含一个非负整数。\n\"\"\"\n\nclass Solution {\n    public int[][] modifiedMatrix(int[][] matrix) {",
        "prompt_chat": "给你一个下标从 0 开始、大小为 m x n 的整数矩阵 matrix ，新建一个下标从 0 开始、名为 answer 的矩阵。使 answer 与 matrix 相等，接着将其中每个值为 -1 的元素替换为所在列的 最大 元素。\n返回矩阵 answer 。\n示例 1：\n输入matrix = [[1,2,-1],[4,-1,6],[7,8,9]]\n输出：[[1,2,9],[4,8,6],[7,8,9]]示例 2：\n输入matrix = [[3,-1],[5,2]]\n输出：[[3,2],[5,2]]\n\n提示：\nm == matrix.length\nn == matrix[i].length\n2 <= m, n <= 50\n-1 <= matrix[i][j] <= 100\n测试用例中生成的输入满足每列至少包含一个非负整数。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int[][] modifiedMatrix(int[][] matrix) {\n```",
        "solution": "class Solution {\n    public int[][] modifiedMatrix(int[][] matrix) {\n        int n = matrix.length; \n        int m = matrix[0].length; \n        for (int j = 0; j < m; j++) {\n            int zd = -1; \n            for (int i = 0; i < n; i++) {\n                zd = Math.max(zd, matrix[i][j]); \n            }\n            for (int i = 0; i < n; i++) {\n                if (matrix[i][j] == -1) {\n                    matrix[i][j] = zd; \n                }\n            }\n        }\n        return matrix; \n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] matrix_1 = {{1,2,-1},{4,-1,6},{7,8,9}};\n        int[][] ans_1 = {{1,2,9},{4,8,6},{7,8,9}};\n        assert Arrays.deepEquals(solution.modifiedMatrix(matrix_1), ans_1);\n        int[][] matrix_2 = {{3,-1},{5,2}};\n        int[][] ans_2 = {{3,2},{5,2}};\n        assert Arrays.deepEquals(solution.modifiedMatrix(matrix_2), ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int[][] modifiedMatrix(int[][] matrix) {",
        "function_name": "modifiedMatrix",
        "difficulty_level": "Easy",
        "time": "20240211"
    },
    {
        "id": "3034",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始长度为 n 的整数数组 nums ，和一个下标从 0 开始长度为 m 的整数数组 pattern ，pattern 数组只包含整数 -1 ，0 和 1 。\n大小为 m + 1 的子数组 nums[i..j] 如果对于每个元素 pattern[k] 都满足以下条件，那么我们说这个子数组匹配模式数组 pattern ：\n如果 pattern[k] == 1 ，那么 nums[i + k + 1] > nums[i + k]\n如果 pattern[k] == 0 ，那么 nums[i + k + 1] == nums[i + k]\n如果 pattern[k] == -1 ，那么 nums[i + k + 1] < nums[i + k]\n请你返回匹配 pattern 的 nums 子数组的 数目 。\n示例 1：\n输入nums = [1,2,3,4,5,6], pattern = [1,1]\n输出：4示例 2：\n输入nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]\n输出：2\n\n提示：\n2 <= n == nums.length <= 100\n1 <= nums[i] <= 10^9\n1 <= m == pattern.length < n\n-1 <= pattern[i] <= 1\n\"\"\"\n\nclass Solution {\n    public int countMatchingSubarrays(int[] nums, int[] pattern) {",
        "prompt_chat": "给你一个下标从 0 开始长度为 n 的整数数组 nums ，和一个下标从 0 开始长度为 m 的整数数组 pattern ，pattern 数组只包含整数 -1 ，0 和 1 。\n大小为 m + 1 的子数组 nums[i..j] 如果对于每个元素 pattern[k] 都满足以下条件，那么我们说这个子数组匹配模式数组 pattern ：\n如果 pattern[k] == 1 ，那么 nums[i + k + 1] > nums[i + k]\n如果 pattern[k] == 0 ，那么 nums[i + k + 1] == nums[i + k]\n如果 pattern[k] == -1 ，那么 nums[i + k + 1] < nums[i + k]\n请你返回匹配 pattern 的 nums 子数组的 数目 。\n示例 1：\n输入nums = [1,2,3,4,5,6], pattern = [1,1]\n输出：4示例 2：\n输入nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]\n输出：2\n\n提示：\n2 <= n == nums.length <= 100\n1 <= nums[i] <= 10^9\n1 <= m == pattern.length < n\n-1 <= pattern[i] <= 1\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int countMatchingSubarrays(int[] nums, int[] pattern) {\n```",
        "solution": "class Solution {\n    public int countMatchingSubarrays(int[] nums, int[] pattern) {\n        int m = pattern.length;\n        int[] pi = new int[m];\n        int cnt = 0;\n        for (int i = 1; i < m; i++) {\n            int v = pattern[i];\n            while (cnt > 0 && pattern[cnt] != v) {\n                cnt = pi[cnt - 1];\n            }\n            if (pattern[cnt] == v) {\n                cnt++;\n            }\n            pi[i] = cnt;\n        }\n\n        int ans = 0;\n        cnt = 0;\n        for (int i = 1; i < nums.length; i++) {\n            int v = Integer.compare(nums[i], nums[i - 1]);\n            while (cnt > 0 && pattern[cnt] != v) {\n                cnt = pi[cnt - 1];\n            }\n            if (pattern[cnt] == v) {\n                cnt++;\n            }\n            if (cnt == m) {\n                ans++;\n                cnt = pi[cnt - 1];\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,3,4,5,6};\n        int[] pattern_1 = {1,1};\n        int ans_1 = 4;\n        assert solution.countMatchingSubarrays(nums_1, pattern_1) == ans_1;\n        int[] nums_2 = {1,4,4,1,3,5,5,3};\n        int[] pattern_2 = {1,0,-1};\n        int ans_2 = 2;\n        assert solution.countMatchingSubarrays(nums_2, pattern_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int countMatchingSubarrays(int[] nums, int[] pattern) {",
        "function_name": "countMatchingSubarrays",
        "difficulty_level": "Middle",
        "time": "20240211"
    },
    {
        "id": "3035",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的字符串数组 words ，数组的长度为 n ，且包含下标从 0 开始的若干字符串。\n你可以执行以下操作 任意 次数（包括零次）：\n选择整数i、j、x和y，满足0 <= i, j < n，0 <= x < words[i].length，0 <= y < words[j].length，交换 字符 words[i][x] 和 words[j][y] 。\n返回一个整数，表示在执行一些操作后，words 中可以包含的回文串的 最大 数量。\n注意：在操作过程中，i 和 j 可以相等。\n示例 1：\n输入words = [\"abbb\",\"ba\",\"aa\"]\n输出：3示例 2：\n输入words = [\"abc\",\"ab\"]\n输出：2\n\n提示：\n1 <= words.length <= 1000\n1 <= words[i].length <= 100\nwords[i] 仅由小写英文字母组成。\n\"\"\"\n\nclass Solution {\n    public int maxPalindromesAfterOperations(String[] words) {",
        "prompt_chat": "给你一个下标从 0 开始的字符串数组 words ，数组的长度为 n ，且包含下标从 0 开始的若干字符串。\n你可以执行以下操作 任意 次数（包括零次）：\n选择整数i、j、x和y，满足0 <= i, j < n，0 <= x < words[i].length，0 <= y < words[j].length，交换 字符 words[i][x] 和 words[j][y] 。\n返回一个整数，表示在执行一些操作后，words 中可以包含的回文串的 最大 数量。\n注意：在操作过程中，i 和 j 可以相等。\n示例 1：\n输入words = [\"abbb\",\"ba\",\"aa\"]\n输出：3示例 2：\n输入words = [\"abc\",\"ab\"]\n输出：2\n\n提示：\n1 <= words.length <= 1000\n1 <= words[i].length <= 100\nwords[i] 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maxPalindromesAfterOperations(String[] words) {\n```",
        "solution": "class Solution {\n    public int maxPalindromesAfterOperations(String[] words) {\n        int tot = 0;\n        int mask = 0; // 奇数个数的字母集合\n        for (String w : words) {\n            tot += w.length();\n            for (char c : w.toCharArray()) {\n                mask ^= 1 << (c - 'a');\n            }\n        }\n        tot -= Integer.bitCount(mask); // 减去出现次数为奇数的字母\n\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\n        int ans = 0;\n        for (String w : words) {\n            tot -= w.length() / 2 * 2; // 长为奇数的字符串，长度要减一\n            if (tot < 0) break;\n            ans++;\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] words_1 = {\"abbb\",\"ba\",\"aa\"};\n        int ans_1 = 3;\n        assert solution.maxPalindromesAfterOperations(words_1) == ans_1;\n        String[] words_2 = {\"abc\",\"ab\"};\n        int ans_2 = 2;\n        assert solution.maxPalindromesAfterOperations(words_2) == ans_2;\n        String[] words_3 = {\"cd\",\"ef\",\"a\"};\n        int ans_3 = 1;\n        assert solution.maxPalindromesAfterOperations(words_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maxPalindromesAfterOperations(String[] words) {",
        "function_name": "maxPalindromesAfterOperations",
        "difficulty_level": "Middle",
        "time": "20240211"
    },
    {
        "id": "3036",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始长度为 n 的整数数组 nums ，和一个下标从 0 开始长度为 m 的整数数组 pattern ，pattern 数组只包含整数 -1 ，0 和 1 。\n大小为 m + 1 的子数组 nums[i..j] 如果对于每个元素 pattern[k] 都满足以下条件，那么我们说这个子数组匹配模式数组 pattern ：\n如果 pattern[k] == 1 ，那么 nums[i + k + 1] > nums[i + k]\n如果 pattern[k] == 0 ，那么 nums[i + k + 1] == nums[i + k]\n如果 pattern[k] == -1 ，那么 nums[i + k + 1] < nums[i + k]\n请你返回匹配 pattern 的 nums 子数组的 数目 。\n示例 1：\n输入nums = [1,2,3,4,5,6], pattern = [1,1]\n输出：4示例 2：\n输入nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]\n输出：2\n\n提示：\n2 <= n == nums.length <= 10^6\n1 <= nums[i] <= 10^9\n1 <= m == pattern.length < n\n-1 <= pattern[i] <= 1\n\"\"\"\n\nclass Solution {\n    public int countMatchingSubarrays(int[] nums, int[] pattern) {",
        "prompt_chat": "给你一个下标从 0 开始长度为 n 的整数数组 nums ，和一个下标从 0 开始长度为 m 的整数数组 pattern ，pattern 数组只包含整数 -1 ，0 和 1 。\n大小为 m + 1 的子数组 nums[i..j] 如果对于每个元素 pattern[k] 都满足以下条件，那么我们说这个子数组匹配模式数组 pattern ：\n如果 pattern[k] == 1 ，那么 nums[i + k + 1] > nums[i + k]\n如果 pattern[k] == 0 ，那么 nums[i + k + 1] == nums[i + k]\n如果 pattern[k] == -1 ，那么 nums[i + k + 1] < nums[i + k]\n请你返回匹配 pattern 的 nums 子数组的 数目 。\n示例 1：\n输入nums = [1,2,3,4,5,6], pattern = [1,1]\n输出：4示例 2：\n输入nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]\n输出：2\n\n提示：\n2 <= n == nums.length <= 10^6\n1 <= nums[i] <= 10^9\n1 <= m == pattern.length < n\n-1 <= pattern[i] <= 1\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int countMatchingSubarrays(int[] nums, int[] pattern) {\n```",
        "solution": "class Solution {\n    public int countMatchingSubarrays(int[] nums, int[] pattern) {\n        int m = pattern.length;\n        int[] s = Arrays.copyOf(pattern, m + nums.length);\n        s[m] = 2;\n        for (int i = 1; i < nums.length; i++) {\n            s[m + i] = Integer.compare(nums[i], nums[i - 1]);\n        }\n\n        int n = s.length;\n        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.min(z[i - l], r - i + 1);\n            }\n            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n                l = i;\n                r = i + z[i];\n                z[i]++;\n            }\n        }\n\n        int ans = 0;\n        for (int i = m + 1; i < n; i++) {\n            if (z[i] == m) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,3,4,5,6};\n        int[] pattern_1 = {1,1};\n        int ans_1 = 4;\n        assert solution.countMatchingSubarrays(nums_1, pattern_1) == ans_1;\n        int[] nums_2 = {1,4,4,1,3,5,5,3};\n        int[] pattern_2 = {1,0,-1};\n        int ans_2 = 2;\n        assert solution.countMatchingSubarrays(nums_2, pattern_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int countMatchingSubarrays(int[] nums, int[] pattern) {",
        "function_name": "countMatchingSubarrays",
        "difficulty_level": "Hard",
        "time": "20240211"
    },
    {
        "id": "3042",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的字符串数组 words。\n定义一个 布尔 函数 isPrefixAndSuffix ，它接受两个字符串参数 str1 和 str2 ：\n当 str1 同时是 str2 的前缀（prefix）和后缀（suffix）时，isPrefixAndSuffix(str1, str2) 返回 true，否则返回 false。\n例如，isPrefixAndSuffix(\\\"aba\\\", \\\"ababa\\\") 返回 true，因为 \\\"aba\\\" 既是 \\\"ababa\\\" 的前缀，也是 \\\"ababa\\\" 的后缀，但是 isPrefixAndSuffix(\\\"abc\\\", \\\"abcd\\\") 返回 false。\n以整数形式，返回满足 i < j 且 isPrefixAndSuffix(words[i], words[j]) 为 true 的下标对 (i, j) 的 数量 。\n示例 1：\n输入words = [\"a\",\"aba\",\"ababa\",\"aa\"]\n输出：4示例 2：\n输入words = [\"pa\",\"papa\",\"ma\",\"mama\"]\n输出：2\n\n提示：\n1 <= words.length <= 50\n1 <= words[i].length <= 10\nwords[i] 仅由小写英文字母组成。\n\"\"\"\n\nclass Solution {\n    public int countPrefixSuffixPairs(String[] words) {",
        "prompt_chat": "给你一个下标从 0 开始的字符串数组 words。\n定义一个 布尔 函数 isPrefixAndSuffix ，它接受两个字符串参数 str1 和 str2 ：\n当 str1 同时是 str2 的前缀（prefix）和后缀（suffix）时，isPrefixAndSuffix(str1, str2) 返回 true，否则返回 false。\n例如，isPrefixAndSuffix(\\\"aba\\\", \\\"ababa\\\") 返回 true，因为 \\\"aba\\\" 既是 \\\"ababa\\\" 的前缀，也是 \\\"ababa\\\" 的后缀，但是 isPrefixAndSuffix(\\\"abc\\\", \\\"abcd\\\") 返回 false。\n以整数形式，返回满足 i < j 且 isPrefixAndSuffix(words[i], words[j]) 为 true 的下标对 (i, j) 的 数量 。\n示例 1：\n输入words = [\"a\",\"aba\",\"ababa\",\"aa\"]\n输出：4示例 2：\n输入words = [\"pa\",\"papa\",\"ma\",\"mama\"]\n输出：2\n\n提示：\n1 <= words.length <= 50\n1 <= words[i].length <= 10\nwords[i] 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int countPrefixSuffixPairs(String[] words) {\n```",
        "solution": "class Node {\n    Node[] son = new Node[26];\n    int cnt;\n}\n\nclass Solution {\n    public long countPrefixSuffixPairs(String[] words) {\n        long ans = 0;\n        Node root = new Node();\n        for (String T : words) {\n            char[] t = T.toCharArray();\n            int n = t.length;\n            int[] z = new int[n];\n            int l = 0, r = 0;\n            for (int i = 1; i < n; i++) {\n                if (i <= r) {\n                    z[i] = Math.min(z[i - l], r - i + 1);\n                }\n                while (i + z[i] < n && t[z[i]] == t[i + z[i]]) {\n                    l = i;\n                    r = i + z[i];\n                    z[i]++;\n                }\n            }\n            z[0] = n;\n\n            Node cur = root;\n            for (int i = 0; i < n; i++) {\n                int c = t[i] - 'a';\n                if (cur.son[c] == null) {\n                    cur.son[c] = new Node();\n                }\n                cur = cur.son[c];\n                if (z[n - 1 - i] == i + 1) { // t 的长为 i+1 的前后缀相同\n                    ans += cur.cnt;\n                }\n            }\n            cur.cnt++;\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] words_1 = {\"a\",\"aba\",\"ababa\",\"aa\"};\n        int ans_1 = 4;\n        assert solution.countPrefixSuffixPairs(words_1) == ans_1;\n        String[] words_2 = {\"pa\",\"papa\",\"ma\",\"mama\"};\n        int ans_2 = 2;\n        assert solution.countPrefixSuffixPairs(words_2) == ans_2;\n        String[] words_3 = {\"abab\",\"ab\"};\n        int ans_3 = 0;\n        assert solution.countPrefixSuffixPairs(words_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int countPrefixSuffixPairs(String[] words) {",
        "function_name": "countPrefixSuffixPairs",
        "difficulty_level": "Easy",
        "time": "20240218"
    },
    {
        "id": "3043",
        "prompt_base": "\"\"\"\n给你两个 正整数 数组 arr1 和 arr2 。正整数的 前缀 是其 最左边 的一位或多位数字组成的整数。例如，123 是整数 12345 的前缀，而 234 不是 。\n设若整数 c 是整数 a 和 b 的 公共前缀 ，那么 c 需要同时是 a 和 b 的前缀。例如，5655359 和 56554 有公共前缀 565 ，而 1223 和 43456 没有 公共前缀。\n你需要找出属于 arr1 的整数 x 和属于 arr2 的整数 y 组成的所有数对 (x, y) 之中最长的公共前缀的长度。\n返回所有数对之中最长公共前缀的长度。如果它们之间不存在公共前缀，则返回 0 。\n示例 1：\n输入arr1 = [1,10,100], arr2 = [1000]\n输出：3示例 2：\n输入arr1 = [1,2,3], arr2 = [4,4,4]\n输出：0\n\n提示：\n1 <= arr1.length, arr2.length <= 5 * 10^4\n1 <= arr1[i], arr2[i] <= 10^8\n\"\"\"\n\nclass Solution {\n    public int longestCommonPrefix(int[] arr1, int[] arr2) {",
        "prompt_chat": "给你两个 正整数 数组 arr1 和 arr2 。正整数的 前缀 是其 最左边 的一位或多位数字组成的整数。例如，123 是整数 12345 的前缀，而 234 不是 。\n设若整数 c 是整数 a 和 b 的 公共前缀 ，那么 c 需要同时是 a 和 b 的前缀。例如，5655359 和 56554 有公共前缀 565 ，而 1223 和 43456 没有 公共前缀。\n你需要找出属于 arr1 的整数 x 和属于 arr2 的整数 y 组成的所有数对 (x, y) 之中最长的公共前缀的长度。\n返回所有数对之中最长公共前缀的长度。如果它们之间不存在公共前缀，则返回 0 。\n示例 1：\n输入arr1 = [1,10,100], arr2 = [1000]\n输出：3示例 2：\n输入arr1 = [1,2,3], arr2 = [4,4,4]\n输出：0\n\n提示：\n1 <= arr1.length, arr2.length <= 5 * 10^4\n1 <= arr1[i], arr2[i] <= 10^8\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int longestCommonPrefix(int[] arr1, int[] arr2) {\n```",
        "solution": "class Solution {\n    public int longestCommonPrefix(int[] arr1, int[] arr2) {\n        Set<String> st = new HashSet<>();\n        for (int x : arr1) {\n            String s = Integer.toString(x);\n            for (int i = 1; i <= s.length(); i++) {\n                st.add(s.substring(0, i));\n            }\n        }\n\n        int ans = 0;\n        for (int x : arr2) {\n            String s = Integer.toString(x);\n            for (int i = 1; i <= s.length(); i++) {\n                if (!st.contains(s.substring(0, i))) {\n                    break;\n                }\n                ans = Math.max(ans, i);\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] arr1_1 = {1,10,100};\n        int[] arr2_1 = {1000};\n        int ans_1 = 3;\n        assert solution.longestCommonPrefix(arr1_1, arr2_1) == ans_1;\n        int[] arr1_2 = {1,2,3};\n        int[] arr2_2 = {4,4,4};\n        int ans_2 = 0;\n        assert solution.longestCommonPrefix(arr1_2, arr2_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int longestCommonPrefix(int[] arr1, int[] arr2) {",
        "function_name": "longestCommonPrefix",
        "difficulty_level": "Middle",
        "time": "20240218"
    },
    {
        "id": "3044",
        "prompt_base": "\"\"\"\n给你一个大小为 m x n 、下标从 0 开始的二维矩阵 mat 。在每个单元格，你可以按以下方式生成数字：\n最多有 8 条路径可以选择：东，东南，南，西南，西，西北，北，东北。\n选择其中一条路径，沿着这个方向移动，并且将路径上的数字添加到正在形成的数字后面。\n注意，每一步都会生成数字，例如，如果路径上的数字是 1, 9, 1，那么在这个方向上会生成三个数字：1, 19, 191 。\n返回在遍历矩阵所创建的所有数字中，出现频率最高的、大于 10的质数；如果不存在这样的质数，则返回 -1 。如果存在多个出现频率最高的质数，那么返回其中最大的那个。\n注意：移动过程中不允许改变方向。\n示例 1：\n输入mat = [[1,1],[9,9],[1,1]]\n输出：19示例 2：\n输入mat = [[7]]\n输出：-1\n\n提示：\nm == mat.length\nn == mat[i].length\n1 <= m, n <= 6\n1 <= mat[i][j] <= 9\n\"\"\"\n\nclass Solution {\n    public int mostFrequentPrime(int[][] mat) {",
        "prompt_chat": "给你一个大小为 m x n 、下标从 0 开始的二维矩阵 mat 。在每个单元格，你可以按以下方式生成数字：\n最多有 8 条路径可以选择：东，东南，南，西南，西，西北，北，东北。\n选择其中一条路径，沿着这个方向移动，并且将路径上的数字添加到正在形成的数字后面。\n注意，每一步都会生成数字，例如，如果路径上的数字是 1, 9, 1，那么在这个方向上会生成三个数字：1, 19, 191 。\n返回在遍历矩阵所创建的所有数字中，出现频率最高的、大于 10的质数；如果不存在这样的质数，则返回 -1 。如果存在多个出现频率最高的质数，那么返回其中最大的那个。\n注意：移动过程中不允许改变方向。\n示例 1：\n输入mat = [[1,1],[9,9],[1,1]]\n输出：19示例 2：\n输入mat = [[7]]\n输出：-1\n\n提示：\nm == mat.length\nn == mat[i].length\n1 <= m, n <= 6\n1 <= mat[i][j] <= 9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int mostFrequentPrime(int[][] mat) {\n```",
        "solution": "class Solution {\n    private static final int[][] DIRS = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\n\n    public int mostFrequentPrime(int[][] mat) {\n        int m = mat.length;\n        int n = mat[0].length;\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int[] d : DIRS) {\n                    int x = i + d[0];\n                    int y = j + d[1];\n                    int v = mat[i][j];\n                    while (x >= 0 && x < m && y >= 0 && y < n) {\n                        v = v * 10 + mat[x][y];\n                        if (isPrime(v)) {\n                            cnt.merge(v, 1, Integer::sum);\n                        }\n                        x += d[0];\n                        y += d[1];\n                    }\n                }\n            }\n        }\n\n        int ans = -1;\n        int maxCnt = 0;\n        for (Map.Entry<Integer, Integer> e : cnt.entrySet()) {\n            int v = e.getKey();\n            int c = e.getValue();\n            if (c > maxCnt) {\n                ans = v;\n                maxCnt = c;\n            } else if (c == maxCnt) {\n                ans = Math.max(ans, v);\n            }\n        }\n        return ans;\n    }\n\n    private boolean isPrime(int n) {\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] mat_1 = {{1,1},{9,9},{1,1}};\n        int ans_1 = 19;\n        assert solution.mostFrequentPrime(mat_1) == ans_1;\n        int[][] mat_2 = {{7}};\n        int ans_2 = -1;\n        assert solution.mostFrequentPrime(mat_2) == ans_2;\n        int[][] mat_3 = {{9,7,8},{4,6,5},{2,8,6}};\n        int ans_3 = 97;\n        assert solution.mostFrequentPrime(mat_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int mostFrequentPrime(int[][] mat) {",
        "function_name": "mostFrequentPrime",
        "difficulty_level": "Middle",
        "time": "20240218"
    },
    {
        "id": "3045",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的字符串数组 words 。\n定义一个 布尔 函数 isPrefixAndSuffix ，它接受两个字符串参数 str1 和 str2 ：\n当 str1 同时是 str2 的前缀（prefix）和后缀（suffix）时，isPrefixAndSuffix(str1, str2) 返回 true，否则返回 false。\n例如，isPrefixAndSuffix(\\\"aba\\\", \\\"ababa\\\") 返回 true，因为 \\\"aba\\\" 既是 \\\"ababa\\\" 的前缀，也是 \\\"ababa\\\" 的后缀，但是 isPrefixAndSuffix(\\\"abc\\\", \\\"abcd\\\") 返回 false。\n以整数形式，返回满足 i < j 且 isPrefixAndSuffix(words[i], words[j]) 为 true 的下标对 (i, j) 的 数量 。\n示例 1：\n输入words = [\"a\",\"aba\",\"ababa\",\"aa\"]\n输出：4示例 2：\n输入words = [\"pa\",\"papa\",\"ma\",\"mama\"]\n输出：2\n\n提示：\n1 <= words.length <= 10^5\n1 <= words[i].length <= 10^5\nwords[i] 仅由小写英文字母组成。\n所有 words[i] 的长度之和不超过 5 * 10^5 。\n\"\"\"\n\nclass Solution {\n    public long countPrefixSuffixPairs(String[] words) {",
        "prompt_chat": "给你一个下标从 0 开始的字符串数组 words 。\n定义一个 布尔 函数 isPrefixAndSuffix ，它接受两个字符串参数 str1 和 str2 ：\n当 str1 同时是 str2 的前缀（prefix）和后缀（suffix）时，isPrefixAndSuffix(str1, str2) 返回 true，否则返回 false。\n例如，isPrefixAndSuffix(\\\"aba\\\", \\\"ababa\\\") 返回 true，因为 \\\"aba\\\" 既是 \\\"ababa\\\" 的前缀，也是 \\\"ababa\\\" 的后缀，但是 isPrefixAndSuffix(\\\"abc\\\", \\\"abcd\\\") 返回 false。\n以整数形式，返回满足 i < j 且 isPrefixAndSuffix(words[i], words[j]) 为 true 的下标对 (i, j) 的 数量 。\n示例 1：\n输入words = [\"a\",\"aba\",\"ababa\",\"aa\"]\n输出：4示例 2：\n输入words = [\"pa\",\"papa\",\"ma\",\"mama\"]\n输出：2\n\n提示：\n1 <= words.length <= 10^5\n1 <= words[i].length <= 10^5\nwords[i] 仅由小写英文字母组成。\n所有 words[i] 的长度之和不超过 5 * 10^5 。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long countPrefixSuffixPairs(String[] words) {\n```",
        "solution": "class Node {\n    Map<Integer, Node> son = new HashMap<>();\n    int cnt;\n}\n\nclass Solution {\n    public long countPrefixSuffixPairs(String[] words) {\n        long ans = 0;\n        Node root = new Node();\n        for (String S : words) {\n            char[] s = S.toCharArray();\n            int n = s.length;\n            Node cur = root;\n            for (int i = 0; i < n; i++) {\n                int p = (s[i] - 'a') << 5 | (s[n - 1 - i] - 'a');\n                cur = cur.son.computeIfAbsent(p, k -> new Node());\n                ans += cur.cnt;\n            }\n            cur.cnt++;\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] words_1 = {\"a\",\"aba\",\"ababa\",\"aa\"};\n        long ans_1 = 4;\n        assert solution.countPrefixSuffixPairs(words_1) == ans_1;\n        String[] words_2 = {\"pa\",\"papa\",\"ma\",\"mama\"};\n        long ans_2 = 2;\n        assert solution.countPrefixSuffixPairs(words_2) == ans_2;\n        String[] words_3 = {\"abab\",\"ab\"};\n        long ans_3 = 0;\n        assert solution.countPrefixSuffixPairs(words_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long countPrefixSuffixPairs(String[] words) {",
        "function_name": "countPrefixSuffixPairs",
        "difficulty_level": "Hard",
        "time": "20240218"
    },
    {
        "id": "3046",
        "prompt_base": "\"\"\"\n给你一个长度为 偶数 的整数数组 nums 。你需要将这个数组分割成 nums1 和 nums2 两部分，要求：\nnums1.length == nums2.length == nums.length / 2 。\nnums1 应包含 互不相同 的元素。\nnums2也应包含 互不相同 的元素。\n如果能够分割数组就返回 true ，否则返回 false 。\n示例 1：\n输入nums = [1,1,2,2,3,4]\n输出：true示例 2：\n输入nums = [1,1,1,1]\n输出：false\n\n提示：\n1 <= nums.length <= 100\nnums.length % 2 == 0\n1 <= nums[i] <= 100\n\"\"\"\n\nclass Solution {\n    public boolean isPossibleToSplit(int[] nums) {",
        "prompt_chat": "给你一个长度为 偶数 的整数数组 nums 。你需要将这个数组分割成 nums1 和 nums2 两部分，要求：\nnums1.length == nums2.length == nums.length / 2 。\nnums1 应包含 互不相同 的元素。\nnums2也应包含 互不相同 的元素。\n如果能够分割数组就返回 true ，否则返回 false 。\n示例 1：\n输入nums = [1,1,2,2,3,4]\n输出：true示例 2：\n输入nums = [1,1,1,1]\n输出：false\n\n提示：\n1 <= nums.length <= 100\nnums.length % 2 == 0\n1 <= nums[i] <= 100\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public boolean isPossibleToSplit(int[] nums) {\n```",
        "solution": "class Solution {\n    public boolean isPossibleToSplit(int[] nums) {\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int x : nums) {\n            if (cnt.merge(x, 1, Integer::sum) > 2) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,1,2,2,3,4};\n        boolean ans_1 = true;\n        assert solution.isPossibleToSplit(nums_1) == ans_1;\n        int[] nums_2 = {1,1,1,1};\n        boolean ans_2 = false;\n        assert solution.isPossibleToSplit(nums_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public boolean isPossibleToSplit(int[] nums) {",
        "function_name": "isPossibleToSplit",
        "difficulty_level": "Easy",
        "time": "20240225"
    },
    {
        "id": "3047",
        "prompt_base": "\"\"\"\n在二维平面上存在 n 个矩形。给你两个下标从 0 开始的二维整数数组 bottomLeft 和 topRight，两个数组的大小都是 n x 2 ，其中 bottomLeft[i] 和 topRight[i] 分别代表第 i 个矩形的 左下角 和 右上角 坐标。\n我们定义 向右 的方向为 x 轴正半轴（x 坐标增加），向左 的方向为 x 轴负半轴（x 坐标减少）。同样地，定义 向上 的方向为 y 轴正半轴（y 坐标增加），向下 的方向为 y 轴负半轴（y 坐标减少）。\n你可以选择一个区域，该区域由两个矩形的 交集 形成。你需要找出能够放入该区域 内 的 最大 正方形面积，并选择最优解。\n返回能够放入交集区域的正方形的 最大 可能面积，如果矩形之间不存在任何交集区域，则返回 0。\n示例 1：\n输入bottomLeft = [[1,1],[2,2],[3,1]], topRight = [[3,3],[4,4],[6,6]]\n输出：1示例 2：\n输入bottomLeft = [[1,1],[2,2],[1,2]], topRight = [[3,3],[4,4],[3,4]]\n输出：1\n\n提示：\nn == bottomLeft.length == topRight.length\n2 <= n <= 10^3\nbottomLeft[i].length == topRight[i].length == 2\n1 <= bottomLeft[i][0], bottomLeft[i][1] <= 10^7\n1 <= topRight[i][0], topRight[i][1] <= 10^7\nbottomLeft[i][0] < topRight[i][0]\nbottomLeft[i][1] < topRight[i][1]\n\"\"\"\n\nclass Solution {\n    public long largestSquareArea(int[][] bottomLeft, int[][] topRight) {",
        "prompt_chat": "在二维平面上存在 n 个矩形。给你两个下标从 0 开始的二维整数数组 bottomLeft 和 topRight，两个数组的大小都是 n x 2 ，其中 bottomLeft[i] 和 topRight[i] 分别代表第 i 个矩形的 左下角 和 右上角 坐标。\n我们定义 向右 的方向为 x 轴正半轴（x 坐标增加），向左 的方向为 x 轴负半轴（x 坐标减少）。同样地，定义 向上 的方向为 y 轴正半轴（y 坐标增加），向下 的方向为 y 轴负半轴（y 坐标减少）。\n你可以选择一个区域，该区域由两个矩形的 交集 形成。你需要找出能够放入该区域 内 的 最大 正方形面积，并选择最优解。\n返回能够放入交集区域的正方形的 最大 可能面积，如果矩形之间不存在任何交集区域，则返回 0。\n示例 1：\n输入bottomLeft = [[1,1],[2,2],[3,1]], topRight = [[3,3],[4,4],[6,6]]\n输出：1示例 2：\n输入bottomLeft = [[1,1],[2,2],[1,2]], topRight = [[3,3],[4,4],[3,4]]\n输出：1\n\n提示：\nn == bottomLeft.length == topRight.length\n2 <= n <= 10^3\nbottomLeft[i].length == topRight[i].length == 2\n1 <= bottomLeft[i][0], bottomLeft[i][1] <= 10^7\n1 <= topRight[i][0], topRight[i][1] <= 10^7\nbottomLeft[i][0] < topRight[i][0]\nbottomLeft[i][1] < topRight[i][1]\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long largestSquareArea(int[][] bottomLeft, int[][] topRight) {\n```",
        "solution": "class Solution {\n    public long largestSquareArea(int[][] bottomLeft, int[][] topRight) {\n        long ans = 0;\n        for (int i = 0; i < bottomLeft.length; i++) {\n            int[] b1 = bottomLeft[i];\n            int[] t1 = topRight[i];\n            for (int j = i + 1; j < bottomLeft.length; j++) {\n                int[] b2 = bottomLeft[j];\n                int[] t2 = topRight[j];\n                int height = Math.min(t1[1], t2[1]) - Math.max(b1[1], b2[1]);\n                int width = Math.min(t1[0], t2[0]) - Math.max(b1[0], b2[0]);\n                int size = Math.min(width, height);\n                if (size > 0) {\n                    ans = Math.max(ans, (long) size * size);\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] bottomLeft_1 = {{1,1},{2,2},{3,1}};\n        int[][] topRight_1 = {{3,3},{4,4},{6,6}};\n        long ans_1 = 1;\n        assert solution.largestSquareArea(bottomLeft_1, topRight_1) == ans_1;\n        int[][] bottomLeft_2 = {{1,1},{2,2},{1,2}};\n        int[][] topRight_2 = {{3,3},{4,4},{3,4}};\n        long ans_2 = 1;\n        assert solution.largestSquareArea(bottomLeft_2, topRight_2) == ans_2;\n        int[][] bottomLeft_3 = {{1,1},{3,3},{3,1}};\n        int[][] topRight_3 = {{2,2},{4,4},{4,2}};\n        long ans_3 = 0;\n        assert solution.largestSquareArea(bottomLeft_3, topRight_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long largestSquareArea(int[][] bottomLeft, int[][] topRight) {",
        "function_name": "largestSquareArea",
        "difficulty_level": "Middle",
        "time": "20240225"
    },
    {
        "id": "3048",
        "prompt_base": "\"\"\"\n给你两个下标从 1 开始的整数数组 nums 和 changeIndices ，数组的长度分别为 n 和 m。一开始，nums 中所有下标都是未标记的，你的任务是标记 nums 中 所有 下标。\n从第 1 秒到第 m 秒（包括 第 m 秒），对于每一秒 s ，你可以执行以下操作 之一 ：\n选择范围 [1, n] 中的一个下标 i ，并且将 nums[i] 减少 1 。\n如果 nums[changeIndices[s]] 等于 0 ，标记 下标 changeIndices[s] 。\n什么也不做。\n请你返回范围 [1, m] 中的一个整数，表示最优操作下，标记 nums 中 所有 下标的 最早秒数 ，如果无法标记所有下标，返回 -1 。\n示例 1：\n输入nums = [2,2,0], changeIndices = [2,2,2,2,3,2,2,1]\n输出：8示例 2：\n输入nums = [1,3], changeIndices = [1,1,1,2,1,1,1]\n输出：6\n\n提示：\n1 <= n == nums.length <= 2000\n0 <= nums[i] <= 10^9\n1 <= m == changeIndices.length <= 2000\n1 <= changeIndices[i] <= n\n\"\"\"\n\nclass Solution {\n    public int earliestSecondToMarkIndices(int[] nums, int[] changeIndices) {",
        "prompt_chat": "给你两个下标从 1 开始的整数数组 nums 和 changeIndices ，数组的长度分别为 n 和 m。一开始，nums 中所有下标都是未标记的，你的任务是标记 nums 中 所有 下标。\n从第 1 秒到第 m 秒（包括 第 m 秒），对于每一秒 s ，你可以执行以下操作 之一 ：\n选择范围 [1, n] 中的一个下标 i ，并且将 nums[i] 减少 1 。\n如果 nums[changeIndices[s]] 等于 0 ，标记 下标 changeIndices[s] 。\n什么也不做。\n请你返回范围 [1, m] 中的一个整数，表示最优操作下，标记 nums 中 所有 下标的 最早秒数 ，如果无法标记所有下标，返回 -1 。\n示例 1：\n输入nums = [2,2,0], changeIndices = [2,2,2,2,3,2,2,1]\n输出：8示例 2：\n输入nums = [1,3], changeIndices = [1,1,1,2,1,1,1]\n输出：6\n\n提示：\n1 <= n == nums.length <= 2000\n0 <= nums[i] <= 10^9\n1 <= m == changeIndices.length <= 2000\n1 <= changeIndices[i] <= n\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int earliestSecondToMarkIndices(int[] nums, int[] changeIndices) {\n```",
        "solution": "class Solution {\n    public int earliestSecondToMarkIndices(int[] nums, int[] changeIndices) {\n        int n = nums.length;\n        int m = changeIndices.length;\n        if (n > m) {\n            return -1;\n        }\n\n        int[] lastT = new int[n];\n        int left = n - 1, right = m + 1;\n        while (left + 1 < right) {\n            int mid = (left + right) / 2;\n            if (check(nums, changeIndices, lastT, mid)) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        return right > m ? -1 : right;\n    }\n\n    private boolean check(int[] nums, int[] changeIndices, int[] lastT, int mx) {\n        Arrays.fill(lastT, -1);\n        for (int t = 0; t < mx; t++) {\n            lastT[changeIndices[t] - 1] = t;\n        }\n        for (int t : lastT) {\n            if (t < 0) { // 有课程没有考试时间\n                return false;\n            }\n        }\n\n        int cnt = 0;\n        for (int i = 0; i < mx; i++) {\n            int idx = changeIndices[i] - 1;\n            if (i == lastT[idx]) { // 考试\n                if (nums[idx] > cnt) { // 没时间复习\n                    return false;\n                }\n                cnt -= nums[idx]; // 复习这门课程\n            } else {\n                cnt++; // 留着后面用\n            }\n        }\n        return true;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {2,2,0};\n        int[] changeIndices_1 = {2,2,2,2,3,2,2,1};\n        int ans_1 = 8;\n        assert solution.earliestSecondToMarkIndices(nums_1, changeIndices_1) == ans_1;\n        int[] nums_2 = {1,3};\n        int[] changeIndices_2 = {1,1,1,2,1,1,1};\n        int ans_2 = 6;\n        assert solution.earliestSecondToMarkIndices(nums_2, changeIndices_2) == ans_2;\n        int[] nums_3 = {0,1};\n        int[] changeIndices_3 = {2,2,2};\n        int ans_3 = -1;\n        assert solution.earliestSecondToMarkIndices(nums_3, changeIndices_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int earliestSecondToMarkIndices(int[] nums, int[] changeIndices) {",
        "function_name": "earliestSecondToMarkIndices",
        "difficulty_level": "Middle",
        "time": "20240225"
    },
    {
        "id": "3049",
        "prompt_base": "\"\"\"\n给你两个下标从 1 开始的整数数组 nums 和 changeIndices ，数组的长度分别为 n 和 m 。一开始，nums 中所有下标都是未标记的，你的任务是标记 nums 中 所有 下标。\n从第 1 秒到第 m 秒（包括 第 m 秒），对于每一秒 s ，你可以执行以下操作 之一 ：\n选择范围 [1, n] 中的一个下标 i ，并且将 nums[i] 减少 1 。\n将 nums[changeIndices[s]] 设置成任意的 非负 整数。\n选择范围 [1, n] 中的一个下标 i ， 满足 nums[i] 等于 0, 并 标记 下标 i 。\n什么也不做。\n请你返回范围 [1, m] 中的一个整数，表示最优操作下，标记 nums 中 所有 下标的 最早秒数 ，如果无法标记所有下标，返回 -1 。\n示例 1：\n输入nums = [3,2,3], changeIndices = [1,3,2,2,2,2,3]\n输出：6示例 2：\n输入nums = [0,0,1,2], changeIndices = [1,2,1,2,1,2,1,2]\n输出：7\n\n提示：\n1 <= n == nums.length <= 5000\n0 <= nums[i] <= 10^9\n1 <= m == changeIndices.length <= 5000\n1 <= changeIndices[i] <= n\n\"\"\"\n\nclass Solution {\n    public int earliestSecondToMarkIndices(int[] nums, int[] changeIndices) {",
        "prompt_chat": "给你两个下标从 1 开始的整数数组 nums 和 changeIndices ，数组的长度分别为 n 和 m 。一开始，nums 中所有下标都是未标记的，你的任务是标记 nums 中 所有 下标。\n从第 1 秒到第 m 秒（包括 第 m 秒），对于每一秒 s ，你可以执行以下操作 之一 ：\n选择范围 [1, n] 中的一个下标 i ，并且将 nums[i] 减少 1 。\n将 nums[changeIndices[s]] 设置成任意的 非负 整数。\n选择范围 [1, n] 中的一个下标 i ， 满足 nums[i] 等于 0, 并 标记 下标 i 。\n什么也不做。\n请你返回范围 [1, m] 中的一个整数，表示最优操作下，标记 nums 中 所有 下标的 最早秒数 ，如果无法标记所有下标，返回 -1 。\n示例 1：\n输入nums = [3,2,3], changeIndices = [1,3,2,2,2,2,3]\n输出：6示例 2：\n输入nums = [0,0,1,2], changeIndices = [1,2,1,2,1,2,1,2]\n输出：7\n\n提示：\n1 <= n == nums.length <= 5000\n0 <= nums[i] <= 10^9\n1 <= m == changeIndices.length <= 5000\n1 <= changeIndices[i] <= n\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int earliestSecondToMarkIndices(int[] nums, int[] changeIndices) {\n```",
        "solution": "class Solution {\n    public int earliestSecondToMarkIndices(int[] nums, int[] changeIndices) {\n        int n = nums.length;\n        int m = changeIndices.length;\n        if (n > m) {\n            return -1;\n        }\n\n        long slow = n; // 慢速复习+考试所需天数\n        for (int v : nums) {\n            slow += v;\n        }\n\n        int[] firstT = new int[n];\n        Arrays.fill(firstT, -1);\n        for (int t = m - 1; t >= 0; t--) {\n            firstT[changeIndices[t] - 1] = t;\n        }\n\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> a - b);\n        int left = n - 1, right = m + 1;\n        while (left + 1 < right) {\n            pq.clear();\n            int mid = (left + right) / 2;\n            if (check(nums, changeIndices, firstT, pq, slow, mid)) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        return right > m ? -1 : right;\n    }\n\n    private boolean check(int[] nums, int[] changeIndices, int[] firstT, PriorityQueue<Integer> pq, long slow, int mx) {\n        int cnt = 0;\n        for (int t = mx - 1; t >= 0; t--) {\n            int i = changeIndices[t] - 1;\n            int v = nums[i];\n            if (v <= 1 || t != firstT[i]) {\n                cnt++; // 留给左边，用来快速复习/考试\n                continue;\n            }\n            if (cnt == 0) {\n                if (pq.isEmpty() || v <= pq.peek()) {\n                    cnt++; // 留给左边，用来快速复习/考试\n                    continue;\n                }\n                slow += pq.poll() + 1;\n                cnt += 2; // 反悔：一天快速复习，一天考试\n            }\n            slow -= v + 1;\n            cnt--; // 快速复习，然后消耗一天来考试\n            pq.offer(v);\n        }\n        return cnt >= slow; // 剩余天数搞定慢速复习+考试\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {3,2,3};\n        int[] changeIndices_1 = {1,3,2,2,2,2,3};\n        int ans_1 = 6;\n        assert solution.earliestSecondToMarkIndices(nums_1, changeIndices_1) == ans_1;\n        int[] nums_2 = {0,0,1,2};\n        int[] changeIndices_2 = {1,2,1,2,1,2,1,2};\n        int ans_2 = 7;\n        assert solution.earliestSecondToMarkIndices(nums_2, changeIndices_2) == ans_2;\n        int[] nums_3 = {1,2,3};\n        int[] changeIndices_3 = {1,2,3};\n        int ans_3 = -1;\n        assert solution.earliestSecondToMarkIndices(nums_3, changeIndices_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int earliestSecondToMarkIndices(int[] nums, int[] changeIndices) {",
        "function_name": "earliestSecondToMarkIndices",
        "difficulty_level": "Hard",
        "time": "20240225"
    },
    {
        "id": "3069",
        "prompt_base": "\"\"\"\n给你一个下标从 1 开始、包含 不同 整数的数组 nums ，数组长度为 n 。\n你需要通过 n 次操作，将 nums 中的所有元素分配到两个数组 arr1 和 arr2 中。在第一次操作中，将 nums[1] 追加到 arr1 。在第二次操作中，将 nums[2] 追加到 arr2 。之后，在第 i 次操作中：\n如果 arr1 的最后一个元素 大于 arr2 的最后一个元素，就将 nums[i] 追加到 arr1 。否则，将 nums[i] 追加到 arr2 。\n通过连接数组 arr1 和 arr2 形成数组 result 。例如，如果 arr1 == [1,2,3] 且 arr2 == [4,5,6] ，那么 result = [1,2,3,4,5,6] 。\n返回数组 result 。\n示例 1：\n输入nums = [2,1,3]\n输出：[2,3,1]示例 2：\n输入nums = [5,4,3,8]\n输出：[5,3,4,8]\n\n提示：\n3 <= n <= 50\n1 <= nums[i] <= 100\nnums中的所有元素都互不相同。\n\"\"\"\n\nclass Solution {\n    public int[] resultArray(int[] nums) {",
        "prompt_chat": "给你一个下标从 1 开始、包含 不同 整数的数组 nums ，数组长度为 n 。\n你需要通过 n 次操作，将 nums 中的所有元素分配到两个数组 arr1 和 arr2 中。在第一次操作中，将 nums[1] 追加到 arr1 。在第二次操作中，将 nums[2] 追加到 arr2 。之后，在第 i 次操作中：\n如果 arr1 的最后一个元素 大于 arr2 的最后一个元素，就将 nums[i] 追加到 arr1 。否则，将 nums[i] 追加到 arr2 。\n通过连接数组 arr1 和 arr2 形成数组 result 。例如，如果 arr1 == [1,2,3] 且 arr2 == [4,5,6] ，那么 result = [1,2,3,4,5,6] 。\n返回数组 result 。\n示例 1：\n输入nums = [2,1,3]\n输出：[2,3,1]示例 2：\n输入nums = [5,4,3,8]\n输出：[5,3,4,8]\n\n提示：\n3 <= n <= 50\n1 <= nums[i] <= 100\nnums中的所有元素都互不相同。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int[] resultArray(int[] nums) {\n```",
        "solution": "class Solution {\n    public int[] resultArray(int[] nums) {\n        int n = nums.length;\n        List<Integer> a = new ArrayList<>();\n        List<Integer> b = new ArrayList<>();\n        a.add(nums[0]);\n        b.add(nums[1]);\n        for (int i = 2; i < n; i++) {\n            if (a.get(a.size() - 1) > b.get(b.size() - 1)) {\n                a.add(nums[i]);\n            } else {\n                b.add(nums[i]);\n            }\n        }\n        a.addAll(b);\n        for (int i = 0; i < n; i++) {\n            nums[i] = a.get(i);\n        }\n        return nums;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {2,1,3};\n        int[] ans_1 = {2,3,1};\n        assert Arrays.equals(solution.resultArray(nums_1), ans_1);\n        int[] nums_2 = {5,4,3,8};\n        int[] ans_2 = {5,3,4,8};\n        assert Arrays.equals(solution.resultArray(nums_2), ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int[] resultArray(int[] nums) {",
        "function_name": "resultArray",
        "difficulty_level": "Easy",
        "time": "20240303"
    },
    {
        "id": "3070",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的整数矩阵 grid 和一个整数 k。返回包含 grid 左上角元素、元素和小于或等于 k 的 \n子矩阵\n的数目。\n示例 1：\n输入grid = [[7,6,3],[6,6,1]], k = 18\n输出：4示例 2：\n输入grid = [[7,2,9],[1,5,0],[2,6,6]], k = 20\n输出：6\n\n提示：\nm == grid.length\nn == grid[i].length\n1 <= n, m <= 1000\n0 <= grid[i][j] <= 1000\n1 <= k <= 10^9\n\"\"\"\n\nclass Solution {\n    public int countSubmatrices(int[][] grid, int k) {",
        "prompt_chat": "给你一个下标从 0 开始的整数矩阵 grid 和一个整数 k。返回包含 grid 左上角元素、元素和小于或等于 k 的 \n子矩阵\n的数目。\n示例 1：\n输入grid = [[7,6,3],[6,6,1]], k = 18\n输出：4示例 2：\n输入grid = [[7,2,9],[1,5,0],[2,6,6]], k = 20\n输出：6\n\n提示：\nm == grid.length\nn == grid[i].length\n1 <= n, m <= 1000\n0 <= grid[i][j] <= 1000\n1 <= k <= 10^9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int countSubmatrices(int[][] grid, int k) {\n```",
        "solution": "class Solution {\n    public int countSubmatrices(int[][] grid, int k) {\n        int ans = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] sum = new int[m + 1][n + 1];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + grid[i][j];\n                if (sum[i + 1][j + 1] <= k) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] grid_1 = {{7,6,3},{6,6,1}};\n        int k_1 = 18;\n        int ans_1 = 4;\n        assert solution.countSubmatrices(grid_1, k_1) == ans_1;\n        int[][] grid_2 = {{7,2,9},{1,5,0},{2,6,6}};\n        int k_2 = 20;\n        int ans_2 = 6;\n        assert solution.countSubmatrices(grid_2, k_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int countSubmatrices(int[][] grid, int k) {",
        "function_name": "countSubmatrices",
        "difficulty_level": "Middle",
        "time": "20240303"
    },
    {
        "id": "3071",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始、大小为 n x n 的矩阵 grid ，其中 n 为奇数，且 grid[r][c] 的值为 0 、1 或 2 。如果一个单元格属于以下三条线中的任一一条，我们就认为它是字母 Y 的一部分：\n从左上角单元格开始到矩阵中心单元格结束的对角线。\n从右上角单元格开始到矩阵中心单元格结束的对角线。\n从中心单元格开始到矩阵底部边界结束的垂直线。\n当且仅当满足以下全部条件时，可以判定矩阵上写有字母 Y ：\n属于 Y 的所有单元格的值相等。\n不属于 Y 的所有单元格的值相等。\n属于 Y 的单元格的值与不属于Y的单元格的值不同。\n每次操作你可以将任意单元格的值改变为 0 、1 或 2 。返回在矩阵上写出字母 Y 所需的 最少 操作次数。\n示例 1：\n输入grid = [[1,2,2],[1,1,0],[0,1,0]]\n输出：3示例 2：\n输入grid = [[0,1,0,1,0],[2,1,0,1,2],[2,2,2,0,1],[2,2,2,2,2],[2,1,2,2,2]]\n输出：12\n\n提示：\n3 <= n <= 49\nn == grid.length == grid[i].length\n0 <= grid[i][j] <= 2\nn 为奇数。\n\"\"\"\n\nclass Solution {\n    public int minimumOperationsToWriteY(int[][] grid) {",
        "prompt_chat": "给你一个下标从 0 开始、大小为 n x n 的矩阵 grid ，其中 n 为奇数，且 grid[r][c] 的值为 0 、1 或 2 。如果一个单元格属于以下三条线中的任一一条，我们就认为它是字母 Y 的一部分：\n从左上角单元格开始到矩阵中心单元格结束的对角线。\n从右上角单元格开始到矩阵中心单元格结束的对角线。\n从中心单元格开始到矩阵底部边界结束的垂直线。\n当且仅当满足以下全部条件时，可以判定矩阵上写有字母 Y ：\n属于 Y 的所有单元格的值相等。\n不属于 Y 的所有单元格的值相等。\n属于 Y 的单元格的值与不属于Y的单元格的值不同。\n每次操作你可以将任意单元格的值改变为 0 、1 或 2 。返回在矩阵上写出字母 Y 所需的 最少 操作次数。\n示例 1：\n输入grid = [[1,2,2],[1,1,0],[0,1,0]]\n输出：3示例 2：\n输入grid = [[0,1,0,1,0],[2,1,0,1,2],[2,2,2,0,1],[2,2,2,2,2],[2,1,2,2,2]]\n输出：12\n\n提示：\n3 <= n <= 49\nn == grid.length == grid[i].length\n0 <= grid[i][j] <= 2\nn 为奇数。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumOperationsToWriteY(int[][] grid) {\n```",
        "solution": "class Solution {\n    public int minimumOperationsToWriteY(int[][] grid) {\n        int[] cnt1 = new int[3];\n        int[] cnt2 = new int[3];\n        int n = grid.length;\n        int m = n / 2;\n        for (int i = 0; i < m; i++) {\n            cnt1[grid[i][i]]++;\n            cnt1[grid[i][n - 1 - i]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != i && j != n - 1 - i) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n        for (int i = m; i < n; i++) {\n            cnt1[grid[i][m]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != m) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n\n        int maxNotChange = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (i != j) {\n                    maxNotChange = Math.max(maxNotChange, cnt1[i] + cnt2[j]);\n                }\n            }\n        }\n        return n * n - maxNotChange;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] grid_1 = {{1,2,2},{1,1,0},{0,1,0}};\n        int ans_1 = 3;\n        assert solution.minimumOperationsToWriteY(grid_1) == ans_1;\n        int[][] grid_2 = {{0,1,0,1,0},{2,1,0,1,2},{2,2,2,0,1},{2,2,2,2,2},{2,1,2,2,2}};\n        int ans_2 = 12;\n        assert solution.minimumOperationsToWriteY(grid_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumOperationsToWriteY(int[][] grid) {",
        "function_name": "minimumOperationsToWriteY",
        "difficulty_level": "Middle",
        "time": "20240303"
    },
    {
        "id": "3072",
        "prompt_base": "\"\"\"\n给你一个下标从 1 开始、长度为 n 的整数数组 nums 。\n现定义函数 greaterCount ，使得 greaterCount(arr, val) 返回数组 arr 中 严格大于 val 的元素数量。\n你需要使用 n 次操作，将 nums 的所有元素分配到两个数组 arr1 和 arr2 中。在第一次操作中，将 nums[1] 追加到 arr1 。在第二次操作中，将 nums[2] 追加到 arr2 。之后，在第 i 次操作中：\n如果 greaterCount(arr1, nums[i]) > greaterCount(arr2, nums[i]) ，将 nums[i] 追加到 arr1 。\n如果 greaterCount(arr1, nums[i]) < greaterCount(arr2, nums[i]) ，将 nums[i] 追加到 arr2 。\n如果 greaterCount(arr1, nums[i]) == greaterCount(arr2, nums[i]) ，将 nums[i] 追加到元素数量较少的数组中。\n如果仍然相等，那么将 nums[i] 追加到 arr1 。\n连接数组 arr1 和 arr2 形成数组 result 。例如，如果 arr1 == [1,2,3] 且 arr2 == [4,5,6] ，那么 result = [1,2,3,4,5,6] 。\n返回整数数组 result 。\n示例 1：\n输入nums = [2,1,3,3]\n输出：[2,3,1,3]示例 2：\n输入nums = [5,14,3,1,2]\n输出：[5,3,1,2,14]\n\n提示：\n3 <= n <= 10^5\n1 <= nums[i] <= 10^9\n\"\"\"\n\nclass Solution {\n    public int[] resultArray(int[] nums) {",
        "prompt_chat": "给你一个下标从 1 开始、长度为 n 的整数数组 nums 。\n现定义函数 greaterCount ，使得 greaterCount(arr, val) 返回数组 arr 中 严格大于 val 的元素数量。\n你需要使用 n 次操作，将 nums 的所有元素分配到两个数组 arr1 和 arr2 中。在第一次操作中，将 nums[1] 追加到 arr1 。在第二次操作中，将 nums[2] 追加到 arr2 。之后，在第 i 次操作中：\n如果 greaterCount(arr1, nums[i]) > greaterCount(arr2, nums[i]) ，将 nums[i] 追加到 arr1 。\n如果 greaterCount(arr1, nums[i]) < greaterCount(arr2, nums[i]) ，将 nums[i] 追加到 arr2 。\n如果 greaterCount(arr1, nums[i]) == greaterCount(arr2, nums[i]) ，将 nums[i] 追加到元素数量较少的数组中。\n如果仍然相等，那么将 nums[i] 追加到 arr1 。\n连接数组 arr1 和 arr2 形成数组 result 。例如，如果 arr1 == [1,2,3] 且 arr2 == [4,5,6] ，那么 result = [1,2,3,4,5,6] 。\n返回整数数组 result 。\n示例 1：\n输入nums = [2,1,3,3]\n输出：[2,3,1,3]示例 2：\n输入nums = [5,14,3,1,2]\n输出：[5,3,1,2,14]\n\n提示：\n3 <= n <= 10^5\n1 <= nums[i] <= 10^9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int[] resultArray(int[] nums) {\n```",
        "solution": "class BinaryIndexedTree {\n    private int[] tree;\n\n    public BinaryIndexedTree(int n) {\n        tree = new int[n + 1];\n    }\n\n    public void add(int i) {\n        while (i < tree.length) {\n            tree[i]++;\n            i += i & -i;\n        }\n    }\n\n    public int get(int i) {\n        int sum = 0;\n        while (i > 0) {\n            sum += tree[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n}\n\nclass Solution {\n    public int[] resultArray(int[] nums) {\n        int n = nums.length;\n        int[] sortedNums = Arrays.copyOf(nums, n);\n        Arrays.sort(sortedNums);\n\n        Map<Integer, Integer> index = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            index.put(sortedNums[i], i + 1);\n        }\n\n        List<Integer> arr1 = new ArrayList<>(List.of(nums[0]));\n        List<Integer> arr2 = new ArrayList<>(List.of(nums[1]));\n        BinaryIndexedTree tree1 = new BinaryIndexedTree(n);\n        BinaryIndexedTree tree2 = new BinaryIndexedTree(n);\n        tree1.add(index.get(nums[0]));\n        tree2.add(index.get(nums[1]));\n\n        for (int i = 2; i < n; i++) {\n            int count1 = arr1.size() - tree1.get(index.get(nums[i]));\n            int count2 = arr2.size() - tree2.get(index.get(nums[i]));\n            if (count1 > count2 || (count1 == count2 && arr1.size() <= arr2.size())) {\n                arr1.add(nums[i]);\n                tree1.add(index.get(nums[i]));\n            } else {\n                arr2.add(nums[i]);\n                tree2.add(index.get(nums[i]));\n            }\n        }\n\n        int i = 0;\n        for (int a: arr1) {\n            nums[i++] = a;\n        }\n        for (int a: arr2) {\n            nums[i++] = a;\n        }\n        return nums;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {2,1,3,3};\n        int[] ans_1 = {2,3,1,3};\n        assert Arrays.equals(solution.resultArray(nums_1), ans_1);\n        int[] nums_2 = {5,14,3,1,2};\n        int[] ans_2 = {5,3,1,2,14};\n        assert Arrays.equals(solution.resultArray(nums_2), ans_2);\n        int[] nums_3 = {3,3,3,3};\n        int[] ans_3 = {3,3,3,3};\n        assert Arrays.equals(solution.resultArray(nums_3), ans_3);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int[] resultArray(int[] nums) {",
        "function_name": "resultArray",
        "difficulty_level": "Hard",
        "time": "20240303"
    },
    {
        "id": "3074",
        "prompt_base": "\"\"\"\n给你一个长度为 n 的数组 apple 和另一个长度为 m 的数组 capacity 。\n一共有 n 个包裹，其中第 i 个包裹中装着 apple[i] 个苹果。同时，还有 m 个箱子，第 i 个箱子的容量为 capacity[i] 个苹果。\n请你选择一些箱子来将这 n 个包裹中的苹果重新分装到箱子中，返回你需要选择的箱子的 最小 数量。\n注意，同一个包裹中的苹果可以分装到不同的箱子中。\n示例 1：\n输入apple = [1,3,2], capacity = [4,3,1,5,2]\n输出：2示例 2：\n输入apple = [5,5,5], capacity = [2,4,2,7]\n输出：4\n\n提示：\n1 <= n == apple.length <= 50\n1 <= m == capacity.length <= 50\n1 <= apple[i], capacity[i] <= 50\n输入数据保证可以将包裹中的苹果重新分装到箱子中。\n\"\"\"\n\nclass Solution {\n    public int minimumBoxes(int[] apple, int[] capacity) {",
        "prompt_chat": "给你一个长度为 n 的数组 apple 和另一个长度为 m 的数组 capacity 。\n一共有 n 个包裹，其中第 i 个包裹中装着 apple[i] 个苹果。同时，还有 m 个箱子，第 i 个箱子的容量为 capacity[i] 个苹果。\n请你选择一些箱子来将这 n 个包裹中的苹果重新分装到箱子中，返回你需要选择的箱子的 最小 数量。\n注意，同一个包裹中的苹果可以分装到不同的箱子中。\n示例 1：\n输入apple = [1,3,2], capacity = [4,3,1,5,2]\n输出：2示例 2：\n输入apple = [5,5,5], capacity = [2,4,2,7]\n输出：4\n\n提示：\n1 <= n == apple.length <= 50\n1 <= m == capacity.length <= 50\n1 <= apple[i], capacity[i] <= 50\n输入数据保证可以将包裹中的苹果重新分装到箱子中。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumBoxes(int[] apple, int[] capacity) {\n```",
        "solution": "class Solution {\n    public int minimumBoxes(int[] apple, int[] capacity) {\n        int s = 0;\n        for (int x : apple) {\n            s += x;\n        }\n        Arrays.sort(capacity);\n        int m = capacity.length;\n        int i = m - 1;\n        for (; s > 0; i--) {\n            s -= capacity[i];\n        }\n        return m - 1 - i;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] apple_1 = {1,3,2};\n        int[] capacity_1 = {4,3,1,5,2};\n        int ans_1 = 2;\n        assert solution.minimumBoxes(apple_1, capacity_1) == ans_1;\n        int[] apple_2 = {5,5,5};\n        int[] capacity_2 = {2,4,2,7};\n        int ans_2 = 4;\n        assert solution.minimumBoxes(apple_2, capacity_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumBoxes(int[] apple, int[] capacity) {",
        "function_name": "minimumBoxes",
        "difficulty_level": "Easy",
        "time": "20240310"
    },
    {
        "id": "3075",
        "prompt_base": "\"\"\"\n给你一个长度为 n 的数组 happiness ，以及一个 正整数 k 。\nn 个孩子站成一队，其中第 i 个孩子的 幸福值 是 happiness[i] 。你计划组织 k 轮筛选从这 n 个孩子中选出 k 个孩子。\n在每一轮选择一个孩子时，所有 尚未 被选中的孩子的 幸福值 将减少 1 。注意，幸福值 不能 变成负数，且只有在它是正数的情况下才会减少。\n选择 k 个孩子，并使你选中的孩子幸福值之和最大，返回你能够得到的 最大值 。\n示例 1：\n输入happiness = [1,2,3], k = 2\n输出：4示例 2：\n输入happiness = [1,1,1,1], k = 2\n输出：1\n\n提示：\n1 <= n == happiness.length <= 2 * 10^5\n1 <= happiness[i] <= 10^8\n1 <= k <= n\n\"\"\"\n\nclass Solution {\n    public long maximumHappinessSum(int[] happiness, int k) {",
        "prompt_chat": "给你一个长度为 n 的数组 happiness ，以及一个 正整数 k 。\nn 个孩子站成一队，其中第 i 个孩子的 幸福值 是 happiness[i] 。你计划组织 k 轮筛选从这 n 个孩子中选出 k 个孩子。\n在每一轮选择一个孩子时，所有 尚未 被选中的孩子的 幸福值 将减少 1 。注意，幸福值 不能 变成负数，且只有在它是正数的情况下才会减少。\n选择 k 个孩子，并使你选中的孩子幸福值之和最大，返回你能够得到的 最大值 。\n示例 1：\n输入happiness = [1,2,3], k = 2\n输出：4示例 2：\n输入happiness = [1,1,1,1], k = 2\n输出：1\n\n提示：\n1 <= n == happiness.length <= 2 * 10^5\n1 <= happiness[i] <= 10^8\n1 <= k <= n\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long maximumHappinessSum(int[] happiness, int k) {\n```",
        "solution": "class Solution {\n    public long maximumHappinessSum(int[] happiness, int k) {\n        Arrays.sort(happiness);\n        int n = happiness.length;\n        long ans = 0;\n        for (int i = n - 1; i >= n - k && happiness[i] > n - 1 - i; i--) {\n            ans += happiness[i] - (n - 1 - i);\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] happiness_1 = {1,2,3};\n        int k_1 = 2;\n        long ans_1 = 4;\n        assert solution.maximumHappinessSum(happiness_1, k_1) == ans_1;\n        int[] happiness_2 = {1,1,1,1};\n        int k_2 = 2;\n        long ans_2 = 1;\n        assert solution.maximumHappinessSum(happiness_2, k_2) == ans_2;\n        int[] happiness_3 = {2,3,4,5};\n        int k_3 = 1;\n        long ans_3 = 5;\n        assert solution.maximumHappinessSum(happiness_3, k_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long maximumHappinessSum(int[] happiness, int k) {",
        "function_name": "maximumHappinessSum",
        "difficulty_level": "Middle",
        "time": "20240310"
    },
    {
        "id": "3076",
        "prompt_base": "\"\"\"\n给你一个数组 arr ，数组中有 n 个 非空 字符串。\n请你求出一个长度为 n 的字符串 answer ，满足：\nanswer[i] 是 arr[i] 最短 的子字符串，且它不是 arr 中其他任何字符串的子字符串。如果有多个这样的子字符串存在，answer[i] 应该是它们中字典序最小的一个。如果不存在这样的子字符串，answer[i] 为空字符串。\n请你返回数组 answer 。\n示例 1：\n输入arr = [\"cab\",\"ad\",\"bad\",\"c\"]\n输出：[\"ab\",\"\",\"ba\",\"\"]示例 2：\n输入arr = [\"abc\",\"bcd\",\"abcd\"]\n输出：[\"\",\"\",\"abcd\"]\n\n提示：\nn == arr.length\n2 <= n <= 100\n1 <= arr[i].length <= 20\narr[i] 只包含小写英文字母。\n\"\"\"\n\nclass Solution {\n    public String[] shortestSubstrings(String[] arr) {",
        "prompt_chat": "给你一个数组 arr ，数组中有 n 个 非空 字符串。\n请你求出一个长度为 n 的字符串 answer ，满足：\nanswer[i] 是 arr[i] 最短 的子字符串，且它不是 arr 中其他任何字符串的子字符串。如果有多个这样的子字符串存在，answer[i] 应该是它们中字典序最小的一个。如果不存在这样的子字符串，answer[i] 为空字符串。\n请你返回数组 answer 。\n示例 1：\n输入arr = [\"cab\",\"ad\",\"bad\",\"c\"]\n输出：[\"ab\",\"\",\"ba\",\"\"]示例 2：\n输入arr = [\"abc\",\"bcd\",\"abcd\"]\n输出：[\"\",\"\",\"abcd\"]\n\n提示：\nn == arr.length\n2 <= n <= 100\n1 <= arr[i].length <= 20\narr[i] 只包含小写英文字母。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public String[] shortestSubstrings(String[] arr) {\n```",
        "solution": "class Solution {\n    public String[] shortestSubstrings(String[] arr) {\n        int n = arr.length;\n        String[] ans = new String[n];\n        for (int i = 0; i < n; i++) {\n            int m = arr[i].length();\n            String res = \"\";\n            for (int size = 1; size <= m && res.isEmpty(); size++) {\n                for (int j = size; j <= m; j++) {\n                    String t = arr[i].substring(j - size, j);\n                    if ((res.isEmpty() || t.compareTo(res) < 0) && check(arr, i, t)) {\n                        res = t;\n                    }\n                }\n            }\n            ans[i] = res;\n        }\n        return ans;\n    }\n\n    private boolean check(String[] arr, int i, String sub) {\n        for (int j = 0; j < arr.length; j++) {\n            if (j != i && arr[j].contains(sub)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] arr_1 = {\"cab\",\"ad\",\"bad\",\"c\"};\n        String[] ans_1 = {\"ab\",\"\",\"ba\",\"\"};\n        assert Arrays.equals(solution.shortestSubstrings(arr_1), ans_1);\n        String[] arr_2 = {\"abc\",\"bcd\",\"abcd\"};\n        String[] ans_2 = {\"\",\"\",\"abcd\"};\n        assert Arrays.equals(solution.shortestSubstrings(arr_2), ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public String[] shortestSubstrings(String[] arr) {",
        "function_name": "shortestSubstrings",
        "difficulty_level": "Middle",
        "time": "20240310"
    },
    {
        "id": "3077",
        "prompt_base": "\"\"\"\n给你一个长度为 n 下标从 0 开始的整数数组 nums 和一个 正奇数 整数 k 。\nx 个子数组的能量值定义为 strength = sum[1] * x - sum[2] * (x - 1) + sum[3] * (x - 2) - sum[4] * (x - 3) + ... + sum[x] * 1 ，其中 sum[i] 是第 i 个子数组的和。更正式的，能量值是满足 1 <= i <= x 的所有 i 对应的 (-1)^{i+1} * sum[i] * (x - i + 1) 之和。\n你需要在 nums 中选择 k 个 不相交子数组 ，使得 能量值最大 。\n请你返回可以得到的 最大能量值 。\n注意，选出来的所有子数组 不 需要覆盖整个数组。\n示例 1：\n输入nums = [1,2,3,-1,2], k = 3\n输出：22示例 2：\n输入nums = [12,-2,-2,-2,-2], k = 5\n输出：64\n\n提示：\n1 <= n <= 10^4\n-10^9 <= nums[i] <= 10^9\n1 <= k <= n\n1 <= n * k <= 10^6\nk 是奇数。\n\"\"\"\n\nclass Solution {\n    public long maximumStrength(int[] nums, int k) {",
        "prompt_chat": "给你一个长度为 n 下标从 0 开始的整数数组 nums 和一个 正奇数 整数 k 。\nx 个子数组的能量值定义为 strength = sum[1] * x - sum[2] * (x - 1) + sum[3] * (x - 2) - sum[4] * (x - 3) + ... + sum[x] * 1 ，其中 sum[i] 是第 i 个子数组的和。更正式的，能量值是满足 1 <= i <= x 的所有 i 对应的 (-1)^{i+1} * sum[i] * (x - i + 1) 之和。\n你需要在 nums 中选择 k 个 不相交子数组 ，使得 能量值最大 。\n请你返回可以得到的 最大能量值 。\n注意，选出来的所有子数组 不 需要覆盖整个数组。\n示例 1：\n输入nums = [1,2,3,-1,2], k = 3\n输出：22示例 2：\n输入nums = [12,-2,-2,-2,-2], k = 5\n输出：64\n\n提示：\n1 <= n <= 10^4\n-10^9 <= nums[i] <= 10^9\n1 <= k <= n\n1 <= n * k <= 10^6\nk 是奇数。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long maximumStrength(int[] nums, int k) {\n```",
        "solution": "class Solution {\n    public long maximumStrength(int[] nums, int k) {\n        int n = nums.length;\n        long[] s = new long[n + 1];\n        for (int i = 0; i < n; i++) {\n            s[i + 1] = s[i] + nums[i];\n        }\n        long[][] f = new long[k + 1][n + 1];\n        for (int i = 1; i <= k; i++) {\n            f[i][i - 1] = Long.MIN_VALUE;\n            long mx = Long.MIN_VALUE;\n            int w = (k - i + 1) * (i % 2 > 0 ? 1 : -1);\n            // j 不能太小也不能太大，要给前面留 i-1 个数，后面留 k-i 个数\n            for (int j = i; j <= n - k + i; j++) {\n                mx = Math.max(mx, f[i - 1][j - 1] - s[j - 1] * w);\n                f[i][j] = Math.max(f[i][j - 1], s[j] * w + mx);\n            }\n        }\n        return f[k][n];\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,3,-1,2};\n        int k_1 = 3;\n        long ans_1 = 22;\n        assert solution.maximumStrength(nums_1, k_1) == ans_1;\n        int[] nums_2 = {12,-2,-2,-2,-2};\n        int k_2 = 5;\n        long ans_2 = 64;\n        assert solution.maximumStrength(nums_2, k_2) == ans_2;\n        int[] nums_3 = {-1,-2,-3};\n        int k_3 = 1;\n        long ans_3 = -1;\n        assert solution.maximumStrength(nums_3, k_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long maximumStrength(int[] nums, int k) {",
        "function_name": "maximumStrength",
        "difficulty_level": "Hard",
        "time": "20240310"
    },
    {
        "id": "3083",
        "prompt_base": "\"\"\"\n给你一个字符串 s ，请你判断字符串 s 是否存在一个长度为 2 的子字符串，在其反转后的字符串中也出现。\n如果存在这样的子字符串，返回 true；如果不存在，返回 false 。\n示例 1：\n输入s = \"leetcode\"\n输出：true示例 2：\n输入s = \"abcba\"\n输出：true\n\n提示：\n1 <= s.length <= 100\n字符串 s 仅由小写英文字母组成。\n\"\"\"\n\nclass Solution {\n    public boolean isSubstringPresent(String s) {",
        "prompt_chat": "给你一个字符串 s ，请你判断字符串 s 是否存在一个长度为 2 的子字符串，在其反转后的字符串中也出现。\n如果存在这样的子字符串，返回 true；如果不存在，返回 false 。\n示例 1：\n输入s = \"leetcode\"\n输出：true示例 2：\n输入s = \"abcba\"\n输出：true\n\n提示：\n1 <= s.length <= 100\n字符串 s 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public boolean isSubstringPresent(String s) {\n```",
        "solution": "class Solution {\n    public boolean isSubstringPresent(String S) {\n        char[] s = S.toCharArray();\n        boolean[][] vis = new boolean[26][26];\n        for (int i = 1; i < s.length; i++) {\n            int x = s[i - 1] - 'a';\n            int y = s[i] - 'a';\n            vis[x][y] = true;\n            if (vis[y][x]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s_1 = \"leetcode\";\n        boolean ans_1 = true;\n        assert solution.isSubstringPresent(s_1) == ans_1;\n        String s_2 = \"abcba\";\n        boolean ans_2 = true;\n        assert solution.isSubstringPresent(s_2) == ans_2;\n        String s_3 = \"abcd\";\n        boolean ans_3 = false;\n        assert solution.isSubstringPresent(s_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public boolean isSubstringPresent(String s) {",
        "function_name": "isSubstringPresent",
        "difficulty_level": "Easy",
        "time": "20240317"
    },
    {
        "id": "3084",
        "prompt_base": "\"\"\"\n给你一个字符串 s 和一个字符 c 。返回在字符串 s 中并且以 c 字符开头和结尾的非空子字符串的总数。\n示例 1：\n输入s = \"abada\", c = \"a\"\n输出：6示例 2：\n输入s = \"zzz\", c = \"z\"\n输出：6\n\n提示：\n1 <= s.length <= 10^5\ns 和 c 均由小写英文字母组成。\n\"\"\"\n\nclass Solution {\n    public long countSubstrings(String s, char c) {",
        "prompt_chat": "给你一个字符串 s 和一个字符 c 。返回在字符串 s 中并且以 c 字符开头和结尾的非空子字符串的总数。\n示例 1：\n输入s = \"abada\", c = \"a\"\n输出：6示例 2：\n输入s = \"zzz\", c = \"z\"\n输出：6\n\n提示：\n1 <= s.length <= 10^5\ns 和 c 均由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long countSubstrings(String s, char c) {\n```",
        "solution": "class Solution {\n    public long countSubstrings(String s, char c) {\n        long k = s.chars().filter(ch -> ch == c).count();\n        return k * (k + 1) / 2;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s_1 = \"abada\";\n        char c_1 = 'a';\n        long ans_1 = 6;\n        assert solution.countSubstrings(s_1, c_1) == ans_1;\n        String s_2 = \"zzz\";\n        char c_2 = 'z';\n        long ans_2 = 6;\n        assert solution.countSubstrings(s_2, c_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long countSubstrings(String s, char c) {",
        "function_name": "countSubstrings",
        "difficulty_level": "Middle",
        "time": "20240317"
    },
    {
        "id": "3085",
        "prompt_base": "\"\"\"\n给你一个字符串 word 和一个整数 k。\n如果 |freq(word[i]) - freq(word[j])| <= k 对于字符串中所有下标 i 和 j  都成立，则认为 word 是 k 特殊字符串。\n此处，freq(x) 表示字符 x 在 word 中的出现频率，而 |y| 表示 y 的绝对值。\n返回使 word 成为 k 特殊字符串 需要删除的字符的最小数量。\n示例 1：\n输入word = \"aabcaba\", k = 0\n输出：3示例 2：\n输入word = \"dabdcbdcdcd\", k = 2\n输出：2\n\n提示：\n1 <= word.length <= 10^5\n0 <= k <= 10^5\nword 仅由小写英文字母组成。\n\"\"\"\n\nclass Solution {\n    public int minimumDeletions(String word, int k) {",
        "prompt_chat": "给你一个字符串 word 和一个整数 k。\n如果 |freq(word[i]) - freq(word[j])| <= k 对于字符串中所有下标 i 和 j  都成立，则认为 word 是 k 特殊字符串。\n此处，freq(x) 表示字符 x 在 word 中的出现频率，而 |y| 表示 y 的绝对值。\n返回使 word 成为 k 特殊字符串 需要删除的字符的最小数量。\n示例 1：\n输入word = \"aabcaba\", k = 0\n输出：3示例 2：\n输入word = \"dabdcbdcdcd\", k = 2\n输出：2\n\n提示：\n1 <= word.length <= 10^5\n0 <= k <= 10^5\nword 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumDeletions(String word, int k) {\n```",
        "solution": "class Solution {\n    public int minimumDeletions(String word, int k) {\n        int[] cnt = new int[26];\n        for (char c : word.toCharArray()) {\n            cnt[c - 'a']++;\n        }\n        Arrays.sort(cnt);\n\n        int maxSave = 0;\n        for (int i = 0; i < 26; i++) {\n            int sum = 0;\n            for (int j = i; j < 26; j++) {\n                sum += Math.min(cnt[j], cnt[i] + k); // 至多保留 cnt[i]+k 个\n            }\n            maxSave = Math.max(maxSave, sum);\n        }\n        return word.length() - maxSave;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String word_1 = \"aabcaba\";\n        int k_1 = 0;\n        int ans_1 = 3;\n        assert solution.minimumDeletions(word_1, k_1) == ans_1;\n        String word_2 = \"dabdcbdcdcd\";\n        int k_2 = 2;\n        int ans_2 = 2;\n        assert solution.minimumDeletions(word_2, k_2) == ans_2;\n        String word_3 = \"aaabaaa\";\n        int k_3 = 2;\n        int ans_3 = 1;\n        assert solution.minimumDeletions(word_3, k_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumDeletions(String word, int k) {",
        "function_name": "minimumDeletions",
        "difficulty_level": "Middle",
        "time": "20240317"
    },
    {
        "id": "3086",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的二进制数组 nums，其长度为 n ；另给你一个 正整数 k 以及一个 非负整数 maxChanges 。\nAlice 在玩一个游戏，游戏的目标是让 Alice 使用 最少 数量的 行动 次数从 nums 中拾起 k 个 1 。游戏开始时，Alice 可以选择数组 [0, n - 1] 范围内的任何索引 aliceIndex 站立。如果 nums[aliceIndex] == 1 ，Alice 会拾起一个 1 ，并且 nums[aliceIndex] 变成0（这 不算 作一次行动）。之后，Alice 可以执行 任意数量 的 行动（包括零次），在每次行动中 Alice 必须 恰好 执行以下动作之一：\n选择任意一个下标 j != aliceIndex 且满足 nums[j] == 0 ，然后将 nums[j] 设置为 1 。这个动作最多可以执行 maxChanges 次。\n选择任意两个相邻的下标 x 和 y（|x - y| == 1）且满足 nums[x] == 1, nums[y] == 0 ，然后交换它们的值（将 nums[y] = 1 和 nums[x] = 0）。如果 y == aliceIndex，在这次行动后 Alice 拾起一个 1 ，并且 nums[y] 变成 0 。\n返回 Alice 拾起 恰好 k 个 1 所需的 最少 行动次数。\n示例 1：\n输入nums = [1,1,0,0,0,1,1,0,0,1], k = 3, maxChanges = 1\n输出：3示例 2：\n输入nums = [0,0,0,0], k = 2, maxChanges = 3\n输出：4\n\n提示：\n2 <= n <= 10^5\n0 <= nums[i] <= 1\n1 <= k <= 10^5\n0 <= maxChanges <= 10^5\nmaxChanges + sum(nums) >= k\n\"\"\"\n\nclass Solution {\n    public long minimumMoves(int[] nums, int k, int maxChanges) {",
        "prompt_chat": "给你一个下标从 0 开始的二进制数组 nums，其长度为 n ；另给你一个 正整数 k 以及一个 非负整数 maxChanges 。\nAlice 在玩一个游戏，游戏的目标是让 Alice 使用 最少 数量的 行动 次数从 nums 中拾起 k 个 1 。游戏开始时，Alice 可以选择数组 [0, n - 1] 范围内的任何索引 aliceIndex 站立。如果 nums[aliceIndex] == 1 ，Alice 会拾起一个 1 ，并且 nums[aliceIndex] 变成0（这 不算 作一次行动）。之后，Alice 可以执行 任意数量 的 行动（包括零次），在每次行动中 Alice 必须 恰好 执行以下动作之一：\n选择任意一个下标 j != aliceIndex 且满足 nums[j] == 0 ，然后将 nums[j] 设置为 1 。这个动作最多可以执行 maxChanges 次。\n选择任意两个相邻的下标 x 和 y（|x - y| == 1）且满足 nums[x] == 1, nums[y] == 0 ，然后交换它们的值（将 nums[y] = 1 和 nums[x] = 0）。如果 y == aliceIndex，在这次行动后 Alice 拾起一个 1 ，并且 nums[y] 变成 0 。\n返回 Alice 拾起 恰好 k 个 1 所需的 最少 行动次数。\n示例 1：\n输入nums = [1,1,0,0,0,1,1,0,0,1], k = 3, maxChanges = 1\n输出：3示例 2：\n输入nums = [0,0,0,0], k = 2, maxChanges = 3\n输出：4\n\n提示：\n2 <= n <= 10^5\n0 <= nums[i] <= 1\n1 <= k <= 10^5\n0 <= maxChanges <= 10^5\nmaxChanges + sum(nums) >= k\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long minimumMoves(int[] nums, int k, int maxChanges) {\n```",
        "solution": "class Solution {\n    public long minimumMoves(int[] nums, int k, int maxChanges) {\n        int n = nums.length;\n\n        long[] indexSum = new long[n + 1], sum = new long[n + 1];\n        for (int i = 0; i < n; i++) {\n            indexSum[i + 1] = indexSum[i] + nums[i] * i;\n            sum[i + 1] = sum[i] + nums[i];\n        }\n        long res = Long.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            if (f(i, nums) + maxChanges >= k) {\n                if (k <= f(i, nums)) {\n                    res = Math.min(res, (long)k - nums[i]);\n                } else {\n                    res = Math.min(res, (long)2 * k - f(i, nums) - nums[i]);\n                }\n                continue;\n            }\n            int left = 0, right = n;\n            while (left <= right) {\n                int mid = (left + right) / 2;\n                int i1 = Math.max(i - mid, 0), i2 = Math.min(i + mid, n - 1);\n                if (sum[i2 + 1] - sum[i1] >= k - maxChanges) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            int i1 = Math.max(i - left, 0), i2 = Math.min(i + left, n - 1);\n            if (sum[i2 + 1] - sum[i1] > k - maxChanges) {\n                i1++;\n            }\n            long count1 = sum[i + 1] - sum[i1], count2 = sum[i2 + 1] - sum[i + 1];\n            res = Math.min(res, indexSum[i2 + 1] - indexSum[i + 1] - i * count2 + i * count1 - (indexSum[i + 1] - indexSum[i1]) + 2 * maxChanges);\n        }\n        return res;\n    }\n\n    public int f(int i, int[] nums) {\n        int x = nums[i];\n        if (i - 1 >= 0) {\n            x += nums[i - 1];\n        }\n        if (i + 1 < nums.length) {\n            x += nums[i + 1];\n        }\n        return x;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,1,0,0,0,1,1,0,0,1};\n        int k_1 = 3;\n        int maxChanges_1 = 1;\n        long ans_1 = 3;\n        assert solution.minimumMoves(nums_1, k_1, maxChanges_1) == ans_1;\n        int[] nums_2 = {0,0,0,0};\n        int k_2 = 2;\n        int maxChanges_2 = 3;\n        long ans_2 = 4;\n        assert solution.minimumMoves(nums_2, k_2, maxChanges_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long minimumMoves(int[] nums, int k, int maxChanges) {",
        "function_name": "minimumMoves",
        "difficulty_level": "Hard",
        "time": "20240317"
    },
    {
        "id": "3090",
        "prompt_base": "\"\"\"\n给你一个字符串 s ，请找出满足每个字符最多出现两次的最长子字符串，并返回该\n子字符串\n的 最大 长度。\n示例 1：\n输入s = \"bcbbbcba\"\n输出：4示例 2：\n输入s = \"aaaa\"\n输出：2\n\n提示：\n2 <= s.length <= 100\ns 仅由小写英文字母组成。\n\"\"\"\n\nclass Solution {\n    public int maximumLengthSubstring(String s) {",
        "prompt_chat": "给你一个字符串 s ，请找出满足每个字符最多出现两次的最长子字符串，并返回该\n子字符串\n的 最大 长度。\n示例 1：\n输入s = \"bcbbbcba\"\n输出：4示例 2：\n输入s = \"aaaa\"\n输出：2\n\n提示：\n2 <= s.length <= 100\ns 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maximumLengthSubstring(String s) {\n```",
        "solution": "class Solution {\n    public int maximumLengthSubstring(String S) {\n        char[] s = S.toCharArray();\n        int ans = 0;\n        int left = 0;\n        int[] cnt = new int[26];\n        for (int i = 0; i < s.length; i++) {\n            int b = s[i] - 'a';\n            cnt[b]++;\n            while (cnt[b] > 2) {\n                cnt[s[left++] - 'a']--;\n            }\n            ans = Math.max(ans, i - left + 1);\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s_1 = \"bcbbbcba\";\n        int ans_1 = 4;\n        assert solution.maximumLengthSubstring(s_1) == ans_1;\n        String s_2 = \"aaaa\";\n        int ans_2 = 2;\n        assert solution.maximumLengthSubstring(s_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maximumLengthSubstring(String s) {",
        "function_name": "maximumLengthSubstring",
        "difficulty_level": "Easy",
        "time": "20240324"
    },
    {
        "id": "3091",
        "prompt_base": "\"\"\"\n给你一个正整数 k 。最初，你有一个数组 nums = [1] 。\n你可以对数组执行以下 任意 操作 任意 次数（可能为零）：\n选择数组中的任何一个元素，然后将它的值 增加 1 。\n复制数组中的任何一个元素，然后将它附加到数组的末尾。\n返回使得最终数组元素之 和 大于或等于 k 所需的 最少 操作次数。\n示例 1：\n输入k = 11\n输出：5示例 2：\n输入k = 1\n输出：0\n\n提示：\n1 <= k <= 105\n\"\"\"\n\nclass Solution {\n    public int minOperations(int k) {",
        "prompt_chat": "给你一个正整数 k 。最初，你有一个数组 nums = [1] 。\n你可以对数组执行以下 任意 操作 任意 次数（可能为零）：\n选择数组中的任何一个元素，然后将它的值 增加 1 。\n复制数组中的任何一个元素，然后将它附加到数组的末尾。\n返回使得最终数组元素之 和 大于或等于 k 所需的 最少 操作次数。\n示例 1：\n输入k = 11\n输出：5示例 2：\n输入k = 1\n输出：0\n\n提示：\n1 <= k <= 105\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minOperations(int k) {\n```",
        "solution": "class Solution {\n    public int minOperations(int k) {\n        int ans = Integer.MAX_VALUE;\n        for (int m = 1; m <= k; m++) {\n            ans = Math.min(ans, m - 1 + (k - 1) / m);\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int k_1 = 11;\n        int ans_1 = 5;\n        assert solution.minOperations(k_1) == ans_1;\n        int k_2 = 1;\n        int ans_2 = 0;\n        assert solution.minOperations(k_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minOperations(int k) {",
        "function_name": "minOperations",
        "difficulty_level": "Middle",
        "time": "20240324"
    },
    {
        "id": "3092",
        "prompt_base": "\"\"\"\n你需要在一个集合里动态记录 ID 的出现频率。给你两个长度都为 n 的整数数组 nums 和 freq ，nums 中每一个元素表示一个 ID ，对应的 freq 中的元素表示这个 ID 在集合中此次操作后需要增加或者减少的数目。\n增加 ID 的数目：如果 freq[i] 是正数，那么 freq[i] 个 ID 为 nums[i] 的元素在第 i 步操作后会添加到集合中。\n减少 ID 的数目：如果 freq[i] 是负数，那么 -freq[i] 个 ID 为 nums[i] 的元素在第 i 步操作后会从集合中删除。\n请你返回一个长度为 n 的数组 ans ，其中 ans[i] 表示第 i 步操作后出现频率最高的 ID 数目 ，如果在某次操作后集合为空，那么 ans[i] 为 0 。\n示例 1：\n输入nums = [2,3,2,1], freq = [3,2,-3,1]\n输出：[3,3,2,2]示例 2：\n输入nums = [5,5,3], freq = [2,-2,1]\n输出：[2,0,1]\n\n提示：\n1 <= nums.length == freq.length <= 10^5\n1 <= nums[i] <= 10^5\n-10^5 <= freq[i] <= 10^5\nfreq[i] != 0\n输入保证任何操作后，集合中的元素出现次数不会为负数。\n\"\"\"\n\nclass Solution {\n    public long[] mostFrequentIDs(int[] nums, int[] freq) {",
        "prompt_chat": "你需要在一个集合里动态记录 ID 的出现频率。给你两个长度都为 n 的整数数组 nums 和 freq ，nums 中每一个元素表示一个 ID ，对应的 freq 中的元素表示这个 ID 在集合中此次操作后需要增加或者减少的数目。\n增加 ID 的数目：如果 freq[i] 是正数，那么 freq[i] 个 ID 为 nums[i] 的元素在第 i 步操作后会添加到集合中。\n减少 ID 的数目：如果 freq[i] 是负数，那么 -freq[i] 个 ID 为 nums[i] 的元素在第 i 步操作后会从集合中删除。\n请你返回一个长度为 n 的数组 ans ，其中 ans[i] 表示第 i 步操作后出现频率最高的 ID 数目 ，如果在某次操作后集合为空，那么 ans[i] 为 0 。\n示例 1：\n输入nums = [2,3,2,1], freq = [3,2,-3,1]\n输出：[3,3,2,2]示例 2：\n输入nums = [5,5,3], freq = [2,-2,1]\n输出：[2,0,1]\n\n提示：\n1 <= nums.length == freq.length <= 10^5\n1 <= nums[i] <= 10^5\n-10^5 <= freq[i] <= 10^5\nfreq[i] != 0\n输入保证任何操作后，集合中的元素出现次数不会为负数。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long[] mostFrequentIDs(int[] nums, int[] freq) {\n```",
        "solution": "class Solution {\n    public long[] mostFrequentIDs(int[] nums, int[] freq) {\n        Map<Integer, Long> cnt = new HashMap<>();\n        TreeMap<Long, Integer> m = new TreeMap<>();\n        int n = nums.length;\n        long[] ans = new long[n];\n        for (int i = 0; i < n; i++) {\n            int x = nums[i];\n            if (cnt.containsKey(x) && m.containsKey(cnt.get(x)) && m.merge(cnt.get(x), -1, Integer::sum) == 0) { // --m[cnt[x]] == 0\n                m.remove(cnt.get(x));\n            }\n            long c = cnt.merge(x, (long) freq[i], Long::sum); // cnt[x] += freq[i]\n            m.merge(c, 1, Integer::sum); // ++m[cnt[x]]\n            ans[i] = m.lastKey();\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {2,3,2,1};\n        int[] freq_1 = {3,2,-3,1};\n        long[] ans_1 = {3,3,2,2};\n        assert Arrays.equals(solution.mostFrequentIDs(nums_1, freq_1), ans_1);\n        int[] nums_2 = {5,5,3};\n        int[] freq_2 = {2,-2,1};\n        long[] ans_2 = {2,0,1};\n        assert Arrays.equals(solution.mostFrequentIDs(nums_2, freq_2), ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long[] mostFrequentIDs(int[] nums, int[] freq) {",
        "function_name": "mostFrequentIDs",
        "difficulty_level": "Middle",
        "time": "20240324"
    },
    {
        "id": "3093",
        "prompt_base": "\"\"\"\n给你两个字符串数组 wordsContainer 和 wordsQuery 。\n对于每个 wordsQuery[i] ，你需要从 wordsContainer 中找到一个与 wordsQuery[i] 有 最长公共后缀 的字符串。如果 wordsContainer 中有两个或者更多字符串有最长公共后缀，那么答案为长度 最短 的。如果有超过两个字符串有 相同 最短长度，那么答案为它们在 wordsContainer 中出现 更早 的一个。\n请你返回一个整数数组 ans ，其中 ans[i]是 wordsContainer中与 wordsQuery[i] 有 最长公共后缀 字符串的下标。\n示例 1：\n输入wordsContainer = [\"abcd\",\"bcd\",\"xbcd\"], wordsQuery = [\"cd\",\"bcd\",\"xyz\"]\n输出：[1,1,1]示例 2：\n输入wordsContainer = [\"abcdefgh\",\"poiuygh\",\"ghghgh\"], wordsQuery = [\"gh\",\"acbfgh\",\"acbfegh\"]\n输出：[2,0,2]\n\n提示：\n1 <= wordsContainer.length, wordsQuery.length <= 10^4\n1 <= wordsContainer[i].length <= 5 * 10^3\n1 <= wordsQuery[i].length <= 5 * 10^3\nwordsContainer[i] 只包含小写英文字母。\nwordsQuery[i] 只包含小写英文字母。\nwordsContainer[i].length 的和至多为 5 * 10^5 。\nwordsQuery[i].length 的和至多为 5 * 10^5 。\n\"\"\"\n\nclass Solution {\n    public int[] stringIndices(String[] wordsContainer, String[] wordsQuery) {",
        "prompt_chat": "给你两个字符串数组 wordsContainer 和 wordsQuery 。\n对于每个 wordsQuery[i] ，你需要从 wordsContainer 中找到一个与 wordsQuery[i] 有 最长公共后缀 的字符串。如果 wordsContainer 中有两个或者更多字符串有最长公共后缀，那么答案为长度 最短 的。如果有超过两个字符串有 相同 最短长度，那么答案为它们在 wordsContainer 中出现 更早 的一个。\n请你返回一个整数数组 ans ，其中 ans[i]是 wordsContainer中与 wordsQuery[i] 有 最长公共后缀 字符串的下标。\n示例 1：\n输入wordsContainer = [\"abcd\",\"bcd\",\"xbcd\"], wordsQuery = [\"cd\",\"bcd\",\"xyz\"]\n输出：[1,1,1]示例 2：\n输入wordsContainer = [\"abcdefgh\",\"poiuygh\",\"ghghgh\"], wordsQuery = [\"gh\",\"acbfgh\",\"acbfegh\"]\n输出：[2,0,2]\n\n提示：\n1 <= wordsContainer.length, wordsQuery.length <= 10^4\n1 <= wordsContainer[i].length <= 5 * 10^3\n1 <= wordsQuery[i].length <= 5 * 10^3\nwordsContainer[i] 只包含小写英文字母。\nwordsQuery[i] 只包含小写英文字母。\nwordsContainer[i].length 的和至多为 5 * 10^5 。\nwordsQuery[i].length 的和至多为 5 * 10^5 。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int[] stringIndices(String[] wordsContainer, String[] wordsQuery) {\n```",
        "solution": "class Node {\n    Node[] son = new Node[26];\n    int minL = Integer.MAX_VALUE;\n    int i;\n}\n\nclass Solution {\n    public int[] stringIndices(String[] wordsContainer, String[] wordsQuery) {\n        Node root = new Node();\n        for (int idx = 0; idx < wordsContainer.length; ++idx) {\n            char[] s = wordsContainer[idx].toCharArray();\n            int l = s.length;\n            Node cur = root;\n            if (l < cur.minL) {\n                cur.minL = l;\n                cur.i = idx;\n            }\n            for (int i = s.length - 1; i >= 0; i--) {\n                int b = s[i] - 'a';\n                if (cur.son[b] == null) {\n                    cur.son[b] = new Node();\n                }\n                cur = cur.son[b];\n                if (l < cur.minL) {\n                    cur.minL = l;\n                    cur.i = idx;\n                }\n            }\n        }\n\n        int[] ans = new int[wordsQuery.length];\n        for (int idx = 0; idx < wordsQuery.length; idx++) {\n            char[] s = wordsQuery[idx].toCharArray();\n            Node cur = root;\n            for (int i = s.length - 1; i >= 0 && cur.son[s[i] - 'a'] != null; i--) {\n                cur = cur.son[s[i] - 'a'];\n            }\n            ans[idx] = cur.i;\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] wordsContainer_1 = {\"abcd\",\"bcd\",\"xbcd\"};\n        String[] wordsQuery_1 = {\"cd\",\"bcd\",\"xyz\"};\n        int[] ans_1 = {1,1,1};\n        assert Arrays.equals(solution.stringIndices(wordsContainer_1, wordsQuery_1), ans_1);\n        String[] wordsContainer_2 = {\"abcdefgh\",\"poiuygh\",\"ghghgh\"};\n        String[] wordsQuery_2 = {\"gh\",\"acbfgh\",\"acbfegh\"};\n        int[] ans_2 = {2,0,2};\n        assert Arrays.equals(solution.stringIndices(wordsContainer_2, wordsQuery_2), ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int[] stringIndices(String[] wordsContainer, String[] wordsQuery) {",
        "function_name": "stringIndices",
        "difficulty_level": "Hard",
        "time": "20240324"
    },
    {
        "id": "3099",
        "prompt_base": "\"\"\"\n如果一个整数能够被其各个数位上的数字之和整除，则称之为 哈沙德数（Harshad number）。给你一个整数 x 。如果 x 是 哈沙德数 ，则返回 x 各个数位上的数字之和，否则，返回 -1 。\n示例 1：\n输入x = 18\n输出：9示例 2：\n输入x = 23\n输出：-1\n\n提示：\n1 <= x <= 100\n\"\"\"\n\nclass Solution {\n    public int sumOfTheDigitsOfHarshadNumber(int x) {",
        "prompt_chat": "如果一个整数能够被其各个数位上的数字之和整除，则称之为 哈沙德数（Harshad number）。给你一个整数 x 。如果 x 是 哈沙德数 ，则返回 x 各个数位上的数字之和，否则，返回 -1 。\n示例 1：\n输入x = 18\n输出：9示例 2：\n输入x = 23\n输出：-1\n\n提示：\n1 <= x <= 100\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int sumOfTheDigitsOfHarshadNumber(int x) {\n```",
        "solution": "class Solution {\n    public int sumOfTheDigitsOfHarshadNumber(int x) {\n        int s = 0;\n        for (int y = x; y != 0; y /= 10) {\n            s += y % 10;\n        }\n        return x % s != 0 ? -1 : s;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int x_1 = 18;\n        int ans_1 = 9;\n        assert solution.sumOfTheDigitsOfHarshadNumber(x_1) == ans_1;\n        int x_2 = 23;\n        int ans_2 = -1;\n        assert solution.sumOfTheDigitsOfHarshadNumber(x_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int sumOfTheDigitsOfHarshadNumber(int x) {",
        "function_name": "sumOfTheDigitsOfHarshadNumber",
        "difficulty_level": "Easy",
        "time": "20240331"
    },
    {
        "id": "3100",
        "prompt_base": "\"\"\"\n给你两个整数 numBottles 和 numExchange 。numBottles 代表你最初拥有的满水瓶数量。在一次操作中，你可以执行以下操作之一：\n喝掉任意数量的满水瓶，使它们变成空水瓶。\n用 numExchange 个空水瓶交换一个满水瓶。然后，将 numExchange 的值增加 1 。\n注意，你不能使用相同的 numExchange 值交换多批空水瓶。例如，如果 numBottles == 3 并且 numExchange == 1 ，则不能用 3 个空水瓶交换成 3 个满水瓶。\n返回你 最多 可以喝到多少瓶水。\n示例 1：\n输入numBottles = 13, numExchange = 6\n输出：15示例 2：\n输入numBottles = 10, numExchange = 3\n输出：13\n\n提示：\n1 <= numBottles <= 100 \n1 <= numExchange <= 100\n\"\"\"\n\nclass Solution {\n    public int maxBottlesDrunk(int numBottles, int numExchange) {",
        "prompt_chat": "给你两个整数 numBottles 和 numExchange 。numBottles 代表你最初拥有的满水瓶数量。在一次操作中，你可以执行以下操作之一：\n喝掉任意数量的满水瓶，使它们变成空水瓶。\n用 numExchange 个空水瓶交换一个满水瓶。然后，将 numExchange 的值增加 1 。\n注意，你不能使用相同的 numExchange 值交换多批空水瓶。例如，如果 numBottles == 3 并且 numExchange == 1 ，则不能用 3 个空水瓶交换成 3 个满水瓶。\n返回你 最多 可以喝到多少瓶水。\n示例 1：\n输入numBottles = 13, numExchange = 6\n输出：15示例 2：\n输入numBottles = 10, numExchange = 3\n输出：13\n\n提示：\n1 <= numBottles <= 100 \n1 <= numExchange <= 100\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maxBottlesDrunk(int numBottles, int numExchange) {\n```",
        "solution": "class Solution {\n    public int maxBottlesDrunk(int numBottles, int numExchange) {\n        int ans = numBottles; // 一开始就全部喝完\n        while (numBottles >= numExchange) { // 有足够的空瓶\n            ans++; // 用 numExchange 个空瓶交换，然后喝掉，产生一个新的空瓶\n            numBottles += 1 - numExchange++;\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int numBottles_1 = 13;\n        int numExchange_1 = 6;\n        int ans_1 = 15;\n        assert solution.maxBottlesDrunk(numBottles_1, numExchange_1) == ans_1;\n        int numBottles_2 = 10;\n        int numExchange_2 = 3;\n        int ans_2 = 13;\n        assert solution.maxBottlesDrunk(numBottles_2, numExchange_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maxBottlesDrunk(int numBottles, int numExchange) {",
        "function_name": "maxBottlesDrunk",
        "difficulty_level": "Middle",
        "time": "20240331"
    },
    {
        "id": "3101",
        "prompt_base": "\"\"\"\n给你一个二进制数组nums。如果一个子数组中 不存在 两个 相邻 元素的值 相同 的情况，我们称这样的子数组为 交替子数组 。\n返回数组 nums 中交替子数组的数量。\n示例 1：\n输入nums = [0,1,1,1]\n输出：5示例 2：\n输入nums = [1,0,1,0]\n输出：10\n\n提示：\n1 <= nums.length <= 10^5\nnums[i] 不是 0 就是 1 。\n\"\"\"\n\nclass Solution {\n    public long countAlternatingSubarrays(int[] nums) {",
        "prompt_chat": "给你一个二进制数组nums。如果一个子数组中 不存在 两个 相邻 元素的值 相同 的情况，我们称这样的子数组为 交替子数组 。\n返回数组 nums 中交替子数组的数量。\n示例 1：\n输入nums = [0,1,1,1]\n输出：5示例 2：\n输入nums = [1,0,1,0]\n输出：10\n\n提示：\n1 <= nums.length <= 10^5\nnums[i] 不是 0 就是 1 。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long countAlternatingSubarrays(int[] nums) {\n```",
        "solution": "class Solution {\n    public long countAlternatingSubarrays(int[] nums) {\n        long res = 0, cur = 0;\n        int pre = -1;\n        for (int a : nums) {\n            cur = (pre != a) ? cur + 1 : 1;\n            pre = a;\n            res += cur;\n        }\n        return res;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {0,1,1,1};\n        long ans_1 = 5;\n        assert solution.countAlternatingSubarrays(nums_1) == ans_1;\n        int[] nums_2 = {1,0,1,0};\n        long ans_2 = 10;\n        assert solution.countAlternatingSubarrays(nums_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long countAlternatingSubarrays(int[] nums) {",
        "function_name": "countAlternatingSubarrays",
        "difficulty_level": "Middle",
        "time": "20240331"
    },
    {
        "id": "3102",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的数组 points ，它表示二维平面上一些点的整数坐标，其中 points[i] = [x_i, y_i] 。\n两点之间的距离定义为它们的曼哈顿距离。\n请你恰好移除一个点，返回移除后任意两点之间的 最大 距离可能的 最小 值。\n示例 1：\n输入points = [[3,10],[5,15],[10,2],[4,4]]\n输出：12示例 2：\n输入points = [[1,1],[1,1],[1,1]]\n输出：0\n\n提示：\n3 <= points.length <= 10^5\npoints[i].length == 2\n1 <= points[i][0], points[i][1] <= 10^8\n\"\"\"\n\nclass Solution {\n    public int minimumDistance(int[][] points) {",
        "prompt_chat": "给你一个下标从 0 开始的数组 points ，它表示二维平面上一些点的整数坐标，其中 points[i] = [x_i, y_i] 。\n两点之间的距离定义为它们的曼哈顿距离。\n请你恰好移除一个点，返回移除后任意两点之间的 最大 距离可能的 最小 值。\n示例 1：\n输入points = [[3,10],[5,15],[10,2],[4,4]]\n输出：12示例 2：\n输入points = [[1,1],[1,1],[1,1]]\n输出：0\n\n提示：\n3 <= points.length <= 10^5\npoints[i].length == 2\n1 <= points[i][0], points[i][1] <= 10^8\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumDistance(int[][] points) {\n```",
        "solution": "class Solution {\n    public int minimumDistance(int[][] points) {\n        TreeMap<Integer, Integer> sx = new TreeMap<Integer, Integer>();\n        TreeMap<Integer, Integer> sy = new TreeMap<Integer, Integer>();\n        for (int[] p : points) {\n            sx.put(p[0] - p[1], sx.getOrDefault(p[0] - p[1], 0) + 1);\n            sy.put(p[0] + p[1], sy.getOrDefault(p[0] + p[1], 0) + 1);\n        }\n        int res = Integer.MAX_VALUE;\n        for (int[] p : points) {\n            sx.put(p[0] - p[1], sx.get(p[0] - p[1]) - 1);\n            if (sx.get(p[0] - p[1]) == 0) {\n                sx.remove(p[0] - p[1]);\n            }\n            sy.put(p[0] + p[1], sy.get(p[0] + p[1]) - 1);\n            if (sy.get(p[0] + p[1]) == 0) {\n                sy.remove(p[0] + p[1]);\n            }\n            res = Math.min(res, Math.max(sx.lastKey() - sx.firstKey(), sy.lastKey() - sy.firstKey()));\n            sx.put(p[0] - p[1], sx.getOrDefault(p[0] - p[1], 0) + 1);\n            sy.put(p[0] + p[1], sy.getOrDefault(p[0] + p[1], 0) + 1);\n        }\n        return res;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] points_1 = {{3,10},{5,15},{10,2},{4,4}};\n        int ans_1 = 12;\n        assert solution.minimumDistance(points_1) == ans_1;\n        int[][] points_2 = {{1,1},{1,1},{1,1}};\n        int ans_2 = 0;\n        assert solution.minimumDistance(points_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumDistance(int[][] points) {",
        "function_name": "minimumDistance",
        "difficulty_level": "Hard",
        "time": "20240331"
    },
    {
        "id": "3105",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 。返回数组 nums 中 严格递增 或 严格递减 的最长非空子数组的长度。\n示例 1：\n输入nums = [1,4,3,3,2]\n输出：2示例 2：\n输入nums = [3,3,3,3]\n输出：1\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 50\n\"\"\"\n\nclass Solution {\n    public int longestMonotonicSubarray(int[] nums) {",
        "prompt_chat": "给你一个整数数组 nums 。返回数组 nums 中 严格递增 或 严格递减 的最长非空子数组的长度。\n示例 1：\n输入nums = [1,4,3,3,2]\n输出：2示例 2：\n输入nums = [3,3,3,3]\n输出：1\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 50\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int longestMonotonicSubarray(int[] nums) {\n```",
        "solution": "class Solution {\n    public int longestMonotonicSubarray(int[] a) {\n        int ans = 1;\n        int i = 0, n = a.length;\n        while (i < n - 1) {\n            if (a[i + 1] == a[i]) {\n                i++; // 直接跳过\n                continue;\n            }\n            int i0 = i; // 记录这一组的开始位置\n            boolean inc = a[i + 1] > a[i]; // 定下基调：是严格递增还是严格递减\n            i += 2; // i 和 i+1 已经满足要求，从 i+2 开始判断\n            while (i < n && a[i] != a[i - 1] && (a[i] > a[i - 1]) == inc) {\n                i++;\n            }\n            // 从 i0 到 i-1 是满足题目要求的（并且无法再延长的）子数组\n            ans = Math.max(ans, i - i0);\n            i--;\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,4,3,3,2};\n        int ans_1 = 2;\n        assert solution.longestMonotonicSubarray(nums_1) == ans_1;\n        int[] nums_2 = {3,3,3,3};\n        int ans_2 = 1;\n        assert solution.longestMonotonicSubarray(nums_2) == ans_2;\n        int[] nums_3 = {3,2,1};\n        int ans_3 = 3;\n        assert solution.longestMonotonicSubarray(nums_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int longestMonotonicSubarray(int[] nums) {",
        "function_name": "longestMonotonicSubarray",
        "difficulty_level": "Easy",
        "time": "20240407"
    },
    {
        "id": "3106",
        "prompt_base": "\"\"\"\n给你一个字符串 s 和一个整数 k 。定义函数 distance(s_1, s_2) ，用于衡量两个长度为 n 的字符串 s_1 和 s_2 之间的距离，即：\n字符 'a' 到 'z' 按 循环 顺序排列，对于区间 [0, n - 1] 中的 i ，计算所有「 s_1[i] 和 s_2[i] 之间 最小距离」的 和 。例如，distance(\\\"ab\\\", \\\"cd\\\") == 4 ，且 distance(\\\"a\\\", \\\"z\\\") == 1 。\n你可以对字符串 s 执行 任意次 操作。在每次操作中，可以将 s 中的一个字母 改变 为 任意 其他小写英文字母。\n返回一个字符串，表示在执行一些操作后你可以得到的 字典序最小 的字符串 t ，且满足 distance(s, t) <= k 。\n示例 1：\n输入s = \"zbbz\", k = 3\n输出：\"aaaz\"示例 2：\n输入s = \"xaxcd\", k = 4\n输出：\"aawcd\"\n\n提示：\n1 <= s.length <= 100\n0 <= k <= 2000\ns 只包含小写英文字母。\n\"\"\"\n\nclass Solution {\n    public String getSmallestString(String s, int k) {",
        "prompt_chat": "给你一个字符串 s 和一个整数 k 。定义函数 distance(s_1, s_2) ，用于衡量两个长度为 n 的字符串 s_1 和 s_2 之间的距离，即：\n字符 'a' 到 'z' 按 循环 顺序排列，对于区间 [0, n - 1] 中的 i ，计算所有「 s_1[i] 和 s_2[i] 之间 最小距离」的 和 。例如，distance(\\\"ab\\\", \\\"cd\\\") == 4 ，且 distance(\\\"a\\\", \\\"z\\\") == 1 。\n你可以对字符串 s 执行 任意次 操作。在每次操作中，可以将 s 中的一个字母 改变 为 任意 其他小写英文字母。\n返回一个字符串，表示在执行一些操作后你可以得到的 字典序最小 的字符串 t ，且满足 distance(s, t) <= k 。\n示例 1：\n输入s = \"zbbz\", k = 3\n输出：\"aaaz\"示例 2：\n输入s = \"xaxcd\", k = 4\n输出：\"aawcd\"\n\n提示：\n1 <= s.length <= 100\n0 <= k <= 2000\ns 只包含小写英文字母。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public String getSmallestString(String s, int k) {\n```",
        "solution": "class Solution {\n    public String getSmallestString(String s, int k) {\n        char[] t = s.toCharArray();\n        for (int i = 0; i < t.length; i++) {\n            int dis = Math.min(t[i] - 'a', 'z' - t[i] + 1);\n            if (dis > k) {\n                t[i] -= k;\n                break;\n            }\n            t[i] = 'a';\n            k -= dis;\n        }\n        return new String(t);\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s_1 = \"zbbz\";\n        int k_1 = 3;\n        String ans_1 = \"aaaz\";\n    assert solution.getSmallestString(s_1, k_1).equals(ans_1);\n        String s_2 = \"xaxcd\";\n        int k_2 = 4;\n        String ans_2 = \"aawcd\";\n    assert solution.getSmallestString(s_2, k_2).equals(ans_2);\n        String s_3 = \"lol\";\n        int k_3 = 0;\n        String ans_3 = \"lol\";\n    assert solution.getSmallestString(s_3, k_3).equals(ans_3);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public String getSmallestString(String s, int k) {",
        "function_name": "getSmallestString",
        "difficulty_level": "Middle",
        "time": "20240407"
    },
    {
        "id": "3107",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 和一个 非负 整数 k 。一次操作中，你可以选择任一元素 加 1 或者减 1 。\n请你返回将 nums 中位数 变为 k 所需要的 最少 操作次数。\n一个数组的中位数指的是数组按非递减顺序排序后最中间的元素。如果数组长度为偶数，我们选择中间两个数的较大值为中位数。\n示例 1：\n输入nums = [2,5,6,8,5], k = 4\n输出：2示例 2：\n输入nums = [2,5,6,8,5], k = 7\n输出：3\n\n提示：\n1 <= nums.length <= 2 * 10^5\n1 <= nums[i] <= 10^9\n1 <= k <= 10^9\n\"\"\"\n\nclass Solution {\n    public long minOperationsToMakeMedianK(int[] nums, int k) {",
        "prompt_chat": "给你一个整数数组 nums 和一个 非负 整数 k 。一次操作中，你可以选择任一元素 加 1 或者减 1 。\n请你返回将 nums 中位数 变为 k 所需要的 最少 操作次数。\n一个数组的中位数指的是数组按非递减顺序排序后最中间的元素。如果数组长度为偶数，我们选择中间两个数的较大值为中位数。\n示例 1：\n输入nums = [2,5,6,8,5], k = 4\n输出：2示例 2：\n输入nums = [2,5,6,8,5], k = 7\n输出：3\n\n提示：\n1 <= nums.length <= 2 * 10^5\n1 <= nums[i] <= 10^9\n1 <= k <= 10^9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long minOperationsToMakeMedianK(int[] nums, int k) {\n```",
        "solution": "class Solution {\n    public long minOperationsToMakeMedianK(int[] nums, int k) {\n        Arrays.sort(nums);\n        long ans = 0;\n        int m = nums.length / 2;\n        if (nums[m] > k) {\n            for (int i = m; i >= 0 && nums[i] > k; i--) {\n                ans += nums[i] - k;\n            }\n        } else {\n            for (int i = m; i < nums.length && nums[i] < k; i++) {\n                ans += k - nums[i];\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {2,5,6,8,5};\n        int k_1 = 4;\n        long ans_1 = 2;\n        assert solution.minOperationsToMakeMedianK(nums_1, k_1) == ans_1;\n        int[] nums_2 = {2,5,6,8,5};\n        int k_2 = 7;\n        long ans_2 = 3;\n        assert solution.minOperationsToMakeMedianK(nums_2, k_2) == ans_2;\n        int[] nums_3 = {1,2,3,4,5,6};\n        int k_3 = 4;\n        long ans_3 = 0;\n        assert solution.minOperationsToMakeMedianK(nums_3, k_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long minOperationsToMakeMedianK(int[] nums, int k) {",
        "function_name": "minOperationsToMakeMedianK",
        "difficulty_level": "Middle",
        "time": "20240407"
    },
    {
        "id": "3108",
        "prompt_base": "\"\"\"\n给你一个 n 个节点的带权无向图，节点编号为 0 到 n - 1 。给你一个整数 n 和一个数组 edges ，其中 edges[i] = [u_i, v_i, w_i] 表示节点 u_i 和 v_i 之间有一条权值为 w_i 的无向边。\n在图中，一趟旅途包含一系列节点和边。旅途开始和结束点都是图中的节点，且图中存在连接旅途中相邻节点的边。注意，一趟旅途可能访问同一条边或者同一个节点多次。\n如果旅途开始于节点 u ，结束于节点 v ，我们定义这一趟旅途的 代价 是经过的边权按位与 AND 的结果。换句话说，如果经过的边对应的边权为 w_0, w_1, w_2, ..., w_k ，那么代价为w_0 & w_1 & w_2 & ... & w_k ，其中 & 表示按位与 AND 操作。\n给你一个二维数组 query ，其中 query[i] = [s_i, t_i] 。对于每一个查询，你需要找出从节点开始 s_i ，在节点 t_i 处结束的旅途的最小代价。如果不存在这样的旅途，答案为 -1 。\n返回数组 answer ，其中 answer[i] 表示对于查询 i 的 最小 旅途代价。\n示例 1：\n输入n = 5, edges = [[0,1,7],[1,3,7],[1,2,1]], query = [[0,3],[3,4]]\n输出：[1,-1]示例 2：\n输入n = 3, edges = [[0,2,7],[0,1,15],[1,2,6],[1,2,1]], query = [[1,2]]\n输出：[0]\n\n提示：\n1 <= n <= 10^5\n0 <= edges.length <= 10^5\nedges[i].length == 3\n0 <= u_i, v_i <= n - 1\nu_i != v_i\n0 <= w_i <= 10^5\n1 <= query.length <= 10^5\nquery[i].length == 2\n0 <= s_i, t_i <= n - 1\n\"\"\"\n\nclass Solution {\n    public int[] minimumCost(int n, int[][] edges, int[][] query) {",
        "prompt_chat": "给你一个 n 个节点的带权无向图，节点编号为 0 到 n - 1 。给你一个整数 n 和一个数组 edges ，其中 edges[i] = [u_i, v_i, w_i] 表示节点 u_i 和 v_i 之间有一条权值为 w_i 的无向边。\n在图中，一趟旅途包含一系列节点和边。旅途开始和结束点都是图中的节点，且图中存在连接旅途中相邻节点的边。注意，一趟旅途可能访问同一条边或者同一个节点多次。\n如果旅途开始于节点 u ，结束于节点 v ，我们定义这一趟旅途的 代价 是经过的边权按位与 AND 的结果。换句话说，如果经过的边对应的边权为 w_0, w_1, w_2, ..., w_k ，那么代价为w_0 & w_1 & w_2 & ... & w_k ，其中 & 表示按位与 AND 操作。\n给你一个二维数组 query ，其中 query[i] = [s_i, t_i] 。对于每一个查询，你需要找出从节点开始 s_i ，在节点 t_i 处结束的旅途的最小代价。如果不存在这样的旅途，答案为 -1 。\n返回数组 answer ，其中 answer[i] 表示对于查询 i 的 最小 旅途代价。\n示例 1：\n输入n = 5, edges = [[0,1,7],[1,3,7],[1,2,1]], query = [[0,3],[3,4]]\n输出：[1,-1]示例 2：\n输入n = 3, edges = [[0,2,7],[0,1,15],[1,2,6],[1,2,1]], query = [[1,2]]\n输出：[0]\n\n提示：\n1 <= n <= 10^5\n0 <= edges.length <= 10^5\nedges[i].length == 3\n0 <= u_i, v_i <= n - 1\nu_i != v_i\n0 <= w_i <= 10^5\n1 <= query.length <= 10^5\nquery[i].length == 2\n0 <= s_i, t_i <= n - 1\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int[] minimumCost(int n, int[][] edges, int[][] query) {\n```",
        "solution": "class Solution {\n    public int[] minimumCost(int n, int[][] edges, int[][] query) {\n        List<int[]>[] g = new ArrayList[n];\n        Arrays.setAll(g, i -> new ArrayList<>());\n        for (int[] e : edges) {\n            int x = e[0], y = e[1], w = e[2];\n            g[x].add(new int[]{y, w});\n            g[y].add(new int[]{x, w});\n        }\n\n        int[] ids = new int[n]; // 记录每个点所在连通块的编号\n        Arrays.fill(ids, -1);\n        List<Integer> ccAnd = new ArrayList<>(); // 记录每个连通块的边权的 AND\n        for (int i = 0; i < n; i++) {\n            if (ids[i] < 0) {\n                ccAnd.add(dfs(i, ccAnd.size(), g, ids));\n            }\n        }\n\n        int[] ans = new int[query.length];\n        for (int i = 0; i < query.length; i++) {\n            int s = query[i][0], t = query[i][1];\n            ans[i] = ids[s] != ids[t] ? -1 : ccAnd.get(ids[s]);\n        }\n        return ans;\n    }\n\n    private int dfs(int x, int curId, List<int[]>[] g, int[] ids) {\n        ids[x] = curId; // 记录每个点所在连通块的编号\n        int and = -1;\n        for (int[] e : g[x]) {\n            and &= e[1];\n            if (ids[e[0]] < 0) { // 没有访问过\n                and &= dfs(e[0], curId, g, ids);\n            }\n        }\n        return and;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n_1 = 5;\n        int[][] edges_1 = {{0,1,7},{1,3,7},{1,2,1}};\n        int[][] query_1 = {{0,3},{3,4}};\n        int[] ans_1 = {1,-1};\n        assert Arrays.equals(solution.minimumCost(n_1, edges_1, query_1), ans_1);\n        int n_2 = 3;\n        int[][] edges_2 = {{0,2,7},{0,1,15},{1,2,6},{1,2,1}};\n        int[][] query_2 = {{1,2}};\n        int[] ans_2 = {0};\n        assert Arrays.equals(solution.minimumCost(n_2, edges_2, query_2), ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int[] minimumCost(int n, int[][] edges, int[][] query) {",
        "function_name": "minimumCost",
        "difficulty_level": "Hard",
        "time": "20240407"
    },
    {
        "id": "3114",
        "prompt_base": "\"\"\"\n给你一个字符串 s，表示一个 12 小时制的时间格式，其中一些数字（可能没有）被 \"?\" 替换。\n12 小时制时间格式为 \"HH:MM\" ，其中 HH 的取值范围为 00 至 11，MM 的取值范围为 00 至 59。最早的时间为 00:00，最晚的时间为 11:59。\n你需要将 s 中的 所有 \"?\" 字符替换为数字，使得结果字符串代表的时间是一个 有效 的 12 小时制时间，并且是可能的 最晚 时间。\n返回结果字符串。\n示例 1：\n输入s = \"1?:?4\"\n输出：\"11:54\"示例 2：\n输入s = \"0?:5?\"\n输出：\"09:59\"\n\n提示：\ns.length == 5\ns[2] 是字符 \":\"\n除 s[2] 外，其他字符都是数字或 \"?\"\n输入保证在替换 \"?\" 字符后至少存在一个介于 \"00:00\" 和 \"11:59\" 之间的时间。\n\"\"\"\n\nclass Solution {\n    public String findLatestTime(String s) {",
        "prompt_chat": "给你一个字符串 s，表示一个 12 小时制的时间格式，其中一些数字（可能没有）被 \"?\" 替换。\n12 小时制时间格式为 \"HH:MM\" ，其中 HH 的取值范围为 00 至 11，MM 的取值范围为 00 至 59。最早的时间为 00:00，最晚的时间为 11:59。\n你需要将 s 中的 所有 \"?\" 字符替换为数字，使得结果字符串代表的时间是一个 有效 的 12 小时制时间，并且是可能的 最晚 时间。\n返回结果字符串。\n示例 1：\n输入s = \"1?:?4\"\n输出：\"11:54\"示例 2：\n输入s = \"0?:5?\"\n输出：\"09:59\"\n\n提示：\ns.length == 5\ns[2] 是字符 \":\"\n除 s[2] 外，其他字符都是数字或 \"?\"\n输入保证在替换 \"?\" 字符后至少存在一个介于 \"00:00\" 和 \"11:59\" 之间的时间。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public String findLatestTime(String s) {\n```",
        "solution": "class Solution {\n    public String findLatestTime(String S) {\n        char[] s = S.toCharArray();\n        for (int h = 11; ; h--) {\n            if (s[0] != '?' && s[0] - '0' != h / 10 || s[1] != '?' && s[1] - '0' != h % 10) {\n                continue;\n            }\n            for (int m = 59; m >= 0; m--) {\n                if (s[3] != '?' && s[3] - '0' != m / 10 || s[4] != '?' && s[4] - '0' != m % 10) {\n                    continue;\n                }\n                return String.format(\"%02d:%02d\", h, m);\n            }\n        }\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s_1 = \"1?:?4\";\n        String ans_1 = \"11:54\";\n    assert solution.findLatestTime(s_1).equals(ans_1);\n        String s_2 = \"0?:5?\";\n        String ans_2 = \"09:59\";\n    assert solution.findLatestTime(s_2).equals(ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public String findLatestTime(String s) {",
        "function_name": "findLatestTime",
        "difficulty_level": "Easy",
        "time": "20240414"
    },
    {
        "id": "3115",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums。\n返回两个（不一定不同的）质数在 nums 中 下标 的 最大距离。\n示例 1：\n输入nums = [4,2,9,5,3]\n输出：3示例 2：\n输入nums = [4,8,2,8]\n输出：0\n\n提示：\n1 <= nums.length <= 3 * 10^5\n1 <= nums[i] <= 100\n输入保证 nums 中至少有一个质数。\n\"\"\"\n\nclass Solution {\n    public int maximumPrimeDifference(int[] nums) {",
        "prompt_chat": "给你一个整数数组 nums。\n返回两个（不一定不同的）质数在 nums 中 下标 的 最大距离。\n示例 1：\n输入nums = [4,2,9,5,3]\n输出：3示例 2：\n输入nums = [4,8,2,8]\n输出：0\n\n提示：\n1 <= nums.length <= 3 * 10^5\n1 <= nums[i] <= 100\n输入保证 nums 中至少有一个质数。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maximumPrimeDifference(int[] nums) {\n```",
        "solution": "class Solution {\n    public int maximumPrimeDifference(int[] nums) {\n        Set<Integer> primes = new HashSet<>(Arrays.asList(\n            2, 3, 5, 7, 11,\n            13, 17, 19, 23, 29,\n            31, 37, 41, 43, 47,\n            53, 59, 61, 67, 71,\n            73, 79, 83, 89, 97\n        ));\n\n        int n = nums.length;\n        int first = -1, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (primes.contains(nums[i])) {\n                if (first != -1) {\n                    ans = Math.max(ans, i - first);\n                } else {\n                    first = i;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {4,2,9,5,3};\n        int ans_1 = 3;\n        assert solution.maximumPrimeDifference(nums_1) == ans_1;\n        int[] nums_2 = {4,8,2,8};\n        int ans_2 = 0;\n        assert solution.maximumPrimeDifference(nums_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maximumPrimeDifference(int[] nums) {",
        "function_name": "maximumPrimeDifference",
        "difficulty_level": "Middle",
        "time": "20240414"
    },
    {
        "id": "3116",
        "prompt_base": "\"\"\"\n给你一个整数数组 coins 表示不同面额的硬币，另给你一个整数 k 。你有无限量的每种面额的硬币。但是，你 不能 组合使用不同面额的硬币。返回使用这些硬币能制造的 第 k^th 小 金额。\n示例 1：\n输入coins = [3,6,9], k = 3\n输出：9示例 2：\n输入coins = [5,2], k = 7\n输出：12\n\n提示：\n1 <= coins.length <= 15\n1 <= coins[i] <= 25\n1 <= k <= 2 * 10^9\ncoins 包含两两不同的整数。\n\"\"\"\n\nclass Solution {\n    public long findKthSmallest(int[] coins, int k) {",
        "prompt_chat": "给你一个整数数组 coins 表示不同面额的硬币，另给你一个整数 k 。你有无限量的每种面额的硬币。但是，你 不能 组合使用不同面额的硬币。返回使用这些硬币能制造的 第 k^th 小 金额。\n示例 1：\n输入coins = [3,6,9], k = 3\n输出：9示例 2：\n输入coins = [5,2], k = 7\n输出：12\n\n提示：\n1 <= coins.length <= 15\n1 <= coins[i] <= 25\n1 <= k <= 2 * 10^9\ncoins 包含两两不同的整数。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long findKthSmallest(int[] coins, int k) {\n```",
        "solution": "class Solution {\n    public long findKthSmallest(int[] coins, int k) {\n        int mn = Integer.MAX_VALUE;\n        for (int x : coins) {\n            mn = Math.min(mn, x);\n        }\n        long left = k - 1, right = (long) mn * k;\n        while (left + 1 < right) {\n            long mid = (left + right) / 2;\n            if (check(mid, coins, k)) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        return right;\n    }\n\n    private boolean check(long m, int[] coins, int k) {\n        long cnt = 0;\n        next:\n        for (int i = 1; i < (1 << coins.length); i++) { // 枚举所有非空子集\n            long lcmRes = 1; // 计算子集 LCM\n            for (int j = 0; j < coins.length; j++) {\n                if ((i >> j & 1) == 1) {\n                    lcmRes = lcm(lcmRes, coins[j]);\n                    if (lcmRes > m) { // 太大了\n                        continue next;\n                    }\n                }\n            }\n            cnt += Integer.bitCount(i) % 2 == 1 ? m / lcmRes : -m / lcmRes;\n        }\n        return cnt >= k;\n    }\n\n    private long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n\n    private long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] coins_1 = {3,6,9};\n        int k_1 = 3;\n        long ans_1 = 9;\n        assert solution.findKthSmallest(coins_1, k_1) == ans_1;\n        int[] coins_2 = {5,2};\n        int k_2 = 7;\n        long ans_2 = 12;\n        assert solution.findKthSmallest(coins_2, k_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long findKthSmallest(int[] coins, int k) {",
        "function_name": "findKthSmallest",
        "difficulty_level": "Hard",
        "time": "20240414"
    },
    {
        "id": "3117",
        "prompt_base": "\"\"\"\n给你两个数组 nums 和 andValues，长度分别为 n 和 m。\n示例 1：\n输入nums = [1,4,3,3,2], andValues = [0,3,3,2]\n输出：12示例 2：\n输入nums = [2,3,5,7,7,7,5], andValues = [0,7,5]\n输出：17\n\n提示：\n1 <= n == nums.length <= 10^4\n1 <= m == andValues.length <= min(n, 10)\n1 <= nums[i] < 10^5\n0 <= andValues[j] < 10^5\n\"\"\"\n\nclass Solution {\n    public int minimumValueSum(int[] nums, int[] andValues) {",
        "prompt_chat": "给你两个数组 nums 和 andValues，长度分别为 n 和 m。\n示例 1：\n输入nums = [1,4,3,3,2], andValues = [0,3,3,2]\n输出：12示例 2：\n输入nums = [2,3,5,7,7,7,5], andValues = [0,7,5]\n输出：17\n\n提示：\n1 <= n == nums.length <= 10^4\n1 <= m == andValues.length <= min(n, 10)\n1 <= nums[i] < 10^5\n0 <= andValues[j] < 10^5\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumValueSum(int[] nums, int[] andValues) {\n```",
        "solution": "class Solution {\n    public int minimumValueSum(int[] nums, int[] andValues) {\n        Map<Long, Integer> memo = new HashMap<>();\n        int ans = dfs(0, 0, -1, nums, andValues, memo);\n        return ans < Integer.MAX_VALUE / 2 ? ans : -1;\n    }\n\n    private int dfs(int i, int j, int and, int[] nums, int[] andValues, Map<Long, Integer> memo) {\n        int n = nums.length;\n        int m = andValues.length;\n        if (m - j > n - i) { // 剩余元素不足\n            return Integer.MAX_VALUE / 2;\n        }\n        if (j == m) { // 分了 m 段\n            return i == n ? 0 : Integer.MAX_VALUE / 2;\n        }\n        and &= nums[i];\n        if (and < andValues[j]) { // 剪枝：无法等于 andValues[j]\n            return Integer.MAX_VALUE / 2;\n        }\n        long mask = (long) i << 36 | (long) j << 32 | and; // 三个状态压缩成一个 long\n        if (memo.containsKey(mask)) {\n            return memo.get(mask);\n        }\n        int res = dfs(i + 1, j, and, nums, andValues, memo); // 不划分\n        if (and == andValues[j]) { // 划分，nums[i] 是这一段的最后一个数\n            res = Math.min(res, dfs(i + 1, j + 1, -1, nums, andValues, memo) + nums[i]);\n        }\n        memo.put(mask, res);\n        return res;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,4,3,3,2};\n        int[] andValues_1 = {0,3,3,2};\n        int ans_1 = 12;\n        assert solution.minimumValueSum(nums_1, andValues_1) == ans_1;\n        int[] nums_2 = {2,3,5,7,7,7,5};\n        int[] andValues_2 = {0,7,5};\n        int ans_2 = 17;\n        assert solution.minimumValueSum(nums_2, andValues_2) == ans_2;\n        int[] nums_3 = {1,2,3,4};\n        int[] andValues_3 = {2};\n        int ans_3 = -1;\n        assert solution.minimumValueSum(nums_3, andValues_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumValueSum(int[] nums, int[] andValues) {",
        "function_name": "minimumValueSum",
        "difficulty_level": "Hard",
        "time": "20240414"
    },
    {
        "id": "3120",
        "prompt_base": "\"\"\"\n给你一个字符串 word。如果 word 中同时存在某个字母的小写形式和大写形式，则称这个字母为 特殊字母。\n返回 word 中 特殊字母 的数量。\n示例 1：\n输入word = \"aaAbcBC\"\n输出：3示例 2：\n输入word = \"abc\"\n输出：0\n\n提示：\n1 <= word.length <= 50\nword 仅由小写和大写英文字母组成。\n\"\"\"\n\nclass Solution {\n    public int numberOfSpecialChars(String word) {",
        "prompt_chat": "给你一个字符串 word。如果 word 中同时存在某个字母的小写形式和大写形式，则称这个字母为 特殊字母。\n返回 word 中 特殊字母 的数量。\n示例 1：\n输入word = \"aaAbcBC\"\n输出：3示例 2：\n输入word = \"abc\"\n输出：0\n\n提示：\n1 <= word.length <= 50\nword 仅由小写和大写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int numberOfSpecialChars(String word) {\n```",
        "solution": "class Solution {\n    public int numberOfSpecialChars(String word) {\n        int[] mask = new int[2];\n        for (char c : word.toCharArray()) {\n            mask[c >> 5 & 1] |= 1 << (c & 31);\n        }\n        return Integer.bitCount(mask[0] & mask[1]);\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String word_1 = \"aaAbcBC\";\n        int ans_1 = 3;\n        assert solution.numberOfSpecialChars(word_1) == ans_1;\n        String word_2 = \"abc\";\n        int ans_2 = 0;\n        assert solution.numberOfSpecialChars(word_2) == ans_2;\n        String word_3 = \"abBCab\";\n        int ans_3 = 1;\n        assert solution.numberOfSpecialChars(word_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int numberOfSpecialChars(String word) {",
        "function_name": "numberOfSpecialChars",
        "difficulty_level": "Easy",
        "time": "20240421"
    },
    {
        "id": "3121",
        "prompt_base": "\"\"\"\n给你一个字符串 word。如果 word 中同时出现某个字母 c 的小写形式和大写形式，并且 每个 小写形式的 c 都出现在第一个大写形式的 c 之前，则称字母 c 是一个 特殊字母 。\n返回 word 中 特殊字母 的数量。\n示例 1：\n输入word = \"aaAbcBC\"\n输出：3示例 2：\n输入word = \"abc\"\n输出：0\n\n提示：\n1 <= word.length <= 2 * 10^5\nword 仅由小写和大写英文字母组成。\n\"\"\"\n\nclass Solution {\n    public int numberOfSpecialChars(String word) {",
        "prompt_chat": "给你一个字符串 word。如果 word 中同时出现某个字母 c 的小写形式和大写形式，并且 每个 小写形式的 c 都出现在第一个大写形式的 c 之前，则称字母 c 是一个 特殊字母 。\n返回 word 中 特殊字母 的数量。\n示例 1：\n输入word = \"aaAbcBC\"\n输出：3示例 2：\n输入word = \"abc\"\n输出：0\n\n提示：\n1 <= word.length <= 2 * 10^5\nword 仅由小写和大写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int numberOfSpecialChars(String word) {\n```",
        "solution": "class Solution {\n    public int numberOfSpecialChars(String word) {\n        int ans = 0;\n        int[] state = new int[27];\n        for (char c : word.toCharArray()) {\n            int x = c & 31; // 转成数字 1~26\n            if ((c & 32) > 0) { // 小写字母\n                if (state[x] == 0) {\n                    state[x] = 1;\n                } else if (state[x] == 2) {\n                    state[x] = -1;\n                    ans--;\n                }\n            } else { // 大写字母\n                if (state[x] == 0) {\n                    state[x] = -1;\n                } else if (state[x] == 1) {\n                    state[x] = 2;\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String word_1 = \"aaAbcBC\";\n        int ans_1 = 3;\n        assert solution.numberOfSpecialChars(word_1) == ans_1;\n        String word_2 = \"abc\";\n        int ans_2 = 0;\n        assert solution.numberOfSpecialChars(word_2) == ans_2;\n        String word_3 = \"AbBCab\";\n        int ans_3 = 0;\n        assert solution.numberOfSpecialChars(word_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int numberOfSpecialChars(String word) {",
        "function_name": "numberOfSpecialChars",
        "difficulty_level": "Middle",
        "time": "20240421"
    },
    {
        "id": "3122",
        "prompt_base": "\"\"\"\n给你一个大小为 m x n 的二维矩形 grid 。每次 操作 中，你可以将 任一 格子的值修改为 任意 非负整数。完成所有操作后，你需要确保每个格子 grid[i][j] 的值满足：\n如果下面相邻格子存在的话，它们的值相等，也就是 grid[i][j] == grid[i + 1][j]（如果存在）。\n如果右边相邻格子存在的话，它们的值不相等，也就是 grid[i][j] != grid[i][j + 1]（如果存在）。\n请你返回需要的 最少 操作数目。\n示例 1：\n输入grid = [[1,0,2],[1,0,2]]\n输出：0示例 2：\n输入grid = [[1,1,1],[0,0,0]]\n输出：3\n\n提示：\n1 <= n, m <= 1000\n0 <= grid[i][j] <= 9\n\"\"\"\n\nclass Solution {\n    public int minimumOperations(int[][] grid) {",
        "prompt_chat": "给你一个大小为 m x n 的二维矩形 grid 。每次 操作 中，你可以将 任一 格子的值修改为 任意 非负整数。完成所有操作后，你需要确保每个格子 grid[i][j] 的值满足：\n如果下面相邻格子存在的话，它们的值相等，也就是 grid[i][j] == grid[i + 1][j]（如果存在）。\n如果右边相邻格子存在的话，它们的值不相等，也就是 grid[i][j] != grid[i][j + 1]（如果存在）。\n请你返回需要的 最少 操作数目。\n示例 1：\n输入grid = [[1,0,2],[1,0,2]]\n输出：0示例 2：\n输入grid = [[1,1,1],[0,0,0]]\n输出：3\n\n提示：\n1 <= n, m <= 1000\n0 <= grid[i][j] <= 9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumOperations(int[][] grid) {\n```",
        "solution": "class Solution {\n    public int minimumOperations(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] cnt = new int[n][10];\n        for (int[] row : grid) {\n            for (int j = 0; j < n; j++) {\n                cnt[j][row[j]]++;\n            }\n        }\n        int[][] memo = new int[n][11];\n        for (int[] row : memo) {\n            Arrays.fill(row, -1); // -1 表示没有计算过\n        }\n        return m * n - dfs(n - 1, 10, cnt, memo);\n    }\n\n    private int dfs(int i, int j, int[][] cnt, int[][] memo) {\n        if (i < 0) {\n            return 0;\n        }\n        if (memo[i][j] != -1) { // 之前计算过\n            return memo[i][j];\n        }\n        int res = 0;\n        for (int k = 0; k < 10; ++k) {\n            if (k != j) {\n                res = Math.max(res, dfs(i - 1, k, cnt, memo) + cnt[i][k]);\n            }\n        }\n        return memo[i][j] = res; // 记忆化\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] grid_1 = {{1,0,2},{1,0,2}};\n        int ans_1 = 0;\n        assert solution.minimumOperations(grid_1) == ans_1;\n        int[][] grid_2 = {{1,1,1},{0,0,0}};\n        int ans_2 = 3;\n        assert solution.minimumOperations(grid_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumOperations(int[][] grid) {",
        "function_name": "minimumOperations",
        "difficulty_level": "Middle",
        "time": "20240421"
    },
    {
        "id": "3123",
        "prompt_base": "\"\"\"\n给你一个 n 个节点的无向带权图，节点编号为 0 到 n - 1 。图中总共有 m 条边，用二维数组 edges 表示，其中 edges[i] = [a_i, b_i, w_i] 表示节点 a_i 和 b_i 之间有一条边权为 w_i 的边。\n对于节点 0 为出发点，节点 n - 1 为结束点的所有最短路，你需要返回一个长度为 m 的 boolean 数组 answer ，如果 edges[i] 至少 在其中一条最短路上，那么 answer[i] 为 true ，否则 answer[i] 为 false 。\n请你返回数组 answer。\n注意，图可能不连通。\n示例 1：\n输入n = 6, edges = [[0,1,4],[0,2,1],[1,3,2],[1,4,3],[1,5,1],[2,3,1],[3,5,3],[4,5,2]]\n输出：[true,true,true,false,true,true,true,false]示例 2：\n输入n = 4, edges = [[2,0,1],[0,1,1],[0,3,4],[3,2,2]]\n输出：[true,false,false,true]\n\n提示：\n2 <= n <= 5 * 10^4\nm == edges.length\n1 <= m <= min(5 * 10^4, n * (n - 1) / 2)\n0 <= a_i, b_i < n\na_i != b_i\n1 <= w_i <= 10^5\n图中没有重边。\n\"\"\"\n\nclass Solution {\n    public boolean[] findAnswer(int n, int[][] edges) {",
        "prompt_chat": "给你一个 n 个节点的无向带权图，节点编号为 0 到 n - 1 。图中总共有 m 条边，用二维数组 edges 表示，其中 edges[i] = [a_i, b_i, w_i] 表示节点 a_i 和 b_i 之间有一条边权为 w_i 的边。\n对于节点 0 为出发点，节点 n - 1 为结束点的所有最短路，你需要返回一个长度为 m 的 boolean 数组 answer ，如果 edges[i] 至少 在其中一条最短路上，那么 answer[i] 为 true ，否则 answer[i] 为 false 。\n请你返回数组 answer。\n注意，图可能不连通。\n示例 1：\n输入n = 6, edges = [[0,1,4],[0,2,1],[1,3,2],[1,4,3],[1,5,1],[2,3,1],[3,5,3],[4,5,2]]\n输出：[true,true,true,false,true,true,true,false]示例 2：\n输入n = 4, edges = [[2,0,1],[0,1,1],[0,3,4],[3,2,2]]\n输出：[true,false,false,true]\n\n提示：\n2 <= n <= 5 * 10^4\nm == edges.length\n1 <= m <= min(5 * 10^4, n * (n - 1) / 2)\n0 <= a_i, b_i < n\na_i != b_i\n1 <= w_i <= 10^5\n图中没有重边。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public boolean[] findAnswer(int n, int[][] edges) {\n```",
        "solution": "class Solution {\n    public boolean[] findAnswer(int n, int[][] edges) {\n        List<int[]>[] g = new ArrayList[n];\n        Arrays.setAll(g, i -> new ArrayList<>());\n        for (int i = 0; i < edges.length; i++) {\n            int[] e = edges[i];\n            int x = e[0], y = e[1], w = e[2];\n            g[x].add(new int[]{y, w, i});\n            g[y].add(new int[]{x, w, i});\n        }\n\n        long[] dis = new long[n];\n        Arrays.fill(dis, Long.MAX_VALUE);\n        dis[0] = 0;\n        PriorityQueue<long[]> pq = new PriorityQueue<>((a, b) -> Long.compare(a[0], b[0]));\n        pq.offer(new long[]{0, 0});\n        while (!pq.isEmpty()) {\n            long[] dxPair = pq.poll();\n            long dx = dxPair[0];\n            int x = (int) dxPair[1];\n            if (dx > dis[x]) {\n                continue;\n            }\n            for (int[] t : g[x]) {\n                int y = t[0];\n                int w = t[1];\n                long newDis = dx + w;\n                if (newDis < dis[y]) {\n                    dis[y] = newDis;\n                    pq.offer(new long[]{newDis, y});\n                }\n            }\n        }\n\n        boolean[] ans = new boolean[edges.length];\n        // 图不连通\n        if (dis[n - 1] == Long.MAX_VALUE) {\n            return ans;\n        }\n\n        // 从终点出发 DFS\n        boolean[] vis = new boolean[n];\n        dfs(n - 1, g, dis, ans, vis);\n        return ans;\n    }\n\n    private void dfs(int y, List<int[]>[] g, long[] dis, boolean[] ans, boolean[] vis) {\n        vis[y] = true;\n        for (int[] t : g[y]) {\n            int x = t[0];\n            int w = t[1];\n            int i = t[2];\n            if (dis[x] + w != dis[y]) {\n                continue;\n            }\n            ans[i] = true;\n            if (!vis[x]) {\n                dfs(x, g, dis, ans, vis);\n            }\n        }\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n_1 = 6;\n        int[][] edges_1 = {{0,1,4},{0,2,1},{1,3,2},{1,4,3},{1,5,1},{2,3,1},{3,5,3},{4,5,2}};\n        boolean[] ans_1 = {true,true,true,false,true,true,true,false};\n        assert Arrays.equals(solution.findAnswer(n_1, edges_1), ans_1);\n        int n_2 = 4;\n        int[][] edges_2 = {{2,0,1},{0,1,1},{0,3,4},{3,2,2}};\n        boolean[] ans_2 = {true,false,false,true};\n        assert Arrays.equals(solution.findAnswer(n_2, edges_2), ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public boolean[] findAnswer(int n, int[][] edges) {",
        "function_name": "findAnswer",
        "difficulty_level": "Hard",
        "time": "20240421"
    },
    {
        "id": "3131",
        "prompt_base": "\"\"\"\n给你两个长度相等的数组 nums1 和 nums2。\n数组 nums1 中的每个元素都与变量 x 所表示的整数相加。如果 x 为负数，则表现为元素值的减少。\n在与 x 相加后，nums1 和 nums2 相等 。当两个数组中包含相同的整数，并且这些整数出现的频次相同时，两个数组 相等 。\n返回整数 x 。\n示例 1：\n输入nums1 = [2,6,4], nums2 = [9,7,5]\n输出：3示例 2：\n输入nums1 = [10], nums2 = [5]\n输出：-5\n\n提示：\n1 <= nums1.length == nums2.length <= 100\n0 <= nums1[i], nums2[i] <= 1000\n测试用例以这样的方式生成：存在一个整数 x，使得 nums1 中的每个元素都与 x 相加后，nums1 与 nums2 相等。\n\"\"\"\n\nclass Solution {\n    public int addedInteger(int[] nums1, int[] nums2) {",
        "prompt_chat": "给你两个长度相等的数组 nums1 和 nums2。\n数组 nums1 中的每个元素都与变量 x 所表示的整数相加。如果 x 为负数，则表现为元素值的减少。\n在与 x 相加后，nums1 和 nums2 相等 。当两个数组中包含相同的整数，并且这些整数出现的频次相同时，两个数组 相等 。\n返回整数 x 。\n示例 1：\n输入nums1 = [2,6,4], nums2 = [9,7,5]\n输出：3示例 2：\n输入nums1 = [10], nums2 = [5]\n输出：-5\n\n提示：\n1 <= nums1.length == nums2.length <= 100\n0 <= nums1[i], nums2[i] <= 1000\n测试用例以这样的方式生成：存在一个整数 x，使得 nums1 中的每个元素都与 x 相加后，nums1 与 nums2 相等。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int addedInteger(int[] nums1, int[] nums2) {\n```",
        "solution": "class Solution {\n    public int addedInteger(int[] nums1, int[] nums2) {\n        int min1 = Integer.MAX_VALUE;\n        int min2 = Integer.MAX_VALUE;\n        for (int i = 0; i < nums1.length; i++) {\n            min1 = Math.min(min1, nums1[i]);\n            min2 = Math.min(min2, nums2[i]);\n        }\n        return min2 - min1;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums1_1 = {2,6,4};\n        int[] nums2_1 = {9,7,5};\n        int ans_1 = 3;\n        assert solution.addedInteger(nums1_1, nums2_1) == ans_1;\n        int[] nums1_2 = {10};\n        int[] nums2_2 = {5};\n        int ans_2 = -5;\n        assert solution.addedInteger(nums1_2, nums2_2) == ans_2;\n        int[] nums1_3 = {1,1,1,1};\n        int[] nums2_3 = {1,1,1,1};\n        int ans_3 = 0;\n        assert solution.addedInteger(nums1_3, nums2_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int addedInteger(int[] nums1, int[] nums2) {",
        "function_name": "addedInteger",
        "difficulty_level": "Easy",
        "time": "20240428"
    },
    {
        "id": "3132",
        "prompt_base": "\"\"\"\n给你两个整数数组 nums1 和 nums2。\n从 nums1 中移除两个元素，并且所有其他元素都与变量 x 所表示的整数相加。如果 x 为负数，则表现为元素值的减少。\n执行上述操作后，nums1 和 nums2 相等 。当两个数组中包含相同的整数，并且这些整数出现的频次相同时，两个数组 相等 。\n返回能够实现数组相等的 最小 整数 x 。\n示例 1：\n输入nums1 = [4,20,16,12,8], nums2 = [14,18,10]\n输出：-2示例 2：\n输入nums1 = [3,5,5,3], nums2 = [7,7]\n输出：2\n\n提示：\n3 <= nums1.length <= 200\nnums2.length == nums1.length - 2\n0 <= nums1[i], nums2[i] <= 1000\n测试用例以这样的方式生成：存在一个整数 x，nums1 中的每个元素都与 x 相加后，再移除两个元素，nums1 可以与 nums2 相等。\n\"\"\"\n\nclass Solution {\n    public int minimumAddedInteger(int[] nums1, int[] nums2) {",
        "prompt_chat": "给你两个整数数组 nums1 和 nums2。\n从 nums1 中移除两个元素，并且所有其他元素都与变量 x 所表示的整数相加。如果 x 为负数，则表现为元素值的减少。\n执行上述操作后，nums1 和 nums2 相等 。当两个数组中包含相同的整数，并且这些整数出现的频次相同时，两个数组 相等 。\n返回能够实现数组相等的 最小 整数 x 。\n示例 1：\n输入nums1 = [4,20,16,12,8], nums2 = [14,18,10]\n输出：-2示例 2：\n输入nums1 = [3,5,5,3], nums2 = [7,7]\n输出：2\n\n提示：\n3 <= nums1.length <= 200\nnums2.length == nums1.length - 2\n0 <= nums1[i], nums2[i] <= 1000\n测试用例以这样的方式生成：存在一个整数 x，nums1 中的每个元素都与 x 相加后，再移除两个元素，nums1 可以与 nums2 相等。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumAddedInteger(int[] nums1, int[] nums2) {\n```",
        "solution": "class Solution {\n    public int minimumAddedInteger(int[] nums1, int[] nums2) {\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        // 枚举保留 nums1[2] 或者 nums1[1] 或者 nums1[0]\n        // 倒着枚举是因为 nums1[i] 越大答案越小，第一个满足的就是答案\n        for (int i = 2; i > 0; i--) {\n            int diff = nums2[0] - nums1[i];\n            // 在 {nums1[i] + diff} 中找子序列 nums2\n            int j = 0;\n            for (int k = i; k < nums1.length; k++) {\n                if (nums2[j] == nums1[k] + diff && ++j == nums2.length) {\n                    // nums2 是 {nums1[i] + diff} 的子序列\n                    return diff;\n                }\n            }\n        }\n        // 题目保证答案一定存在\n        return nums2[0] - nums1[0];\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums1_1 = {4,20,16,12,8};\n        int[] nums2_1 = {14,18,10};\n        int ans_1 = -2;\n        assert solution.minimumAddedInteger(nums1_1, nums2_1) == ans_1;\n        int[] nums1_2 = {3,5,5,3};\n        int[] nums2_2 = {7,7};\n        int ans_2 = 2;\n        assert solution.minimumAddedInteger(nums1_2, nums2_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumAddedInteger(int[] nums1, int[] nums2) {",
        "function_name": "minimumAddedInteger",
        "difficulty_level": "Middle",
        "time": "20240428"
    },
    {
        "id": "3133",
        "prompt_base": "\"\"\"\n给你两个整数 n 和 x 。你需要构造一个长度为 n 的 正整数 数组 nums ，对于所有 0 <= i < n - 1 ，满足 nums[i + 1] 大于 nums[i] ，并且数组 nums 中所有元素的按位 AND 运算结果为 x 。\n返回 nums[n - 1] 可能的 最小 值。\n示例 1：\n输入n = 3, x = 4\n输出：6示例 2：\n输入n = 2, x = 7\n输出：15\n\n提示：\n1 <= n, x <= 10^8\n\"\"\"\n\nclass Solution {\n    public long minEnd(int n, int x) {",
        "prompt_chat": "给你两个整数 n 和 x 。你需要构造一个长度为 n 的 正整数 数组 nums ，对于所有 0 <= i < n - 1 ，满足 nums[i + 1] 大于 nums[i] ，并且数组 nums 中所有元素的按位 AND 运算结果为 x 。\n返回 nums[n - 1] 可能的 最小 值。\n示例 1：\n输入n = 3, x = 4\n输出：6示例 2：\n输入n = 2, x = 7\n输出：15\n\n提示：\n1 <= n, x <= 10^8\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long minEnd(int n, int x) {\n```",
        "solution": "class Solution {\n    public long minEnd(int n, int x) {\n        n--; // 先把 n 减一，这样下面讨论的 n 就是原来的 n-1\n        long ans = x;\n        int i = 0, j = 0;\n        while ((n >> j) > 0) {\n            // x 的第 i 个比特值是 0，即「空位」\n            if ((ans >> i & 1) == 0) {\n                // 空位填入 n 的第 j 个比特值\n                ans |= (long) (n >> j & 1) << i;\n                j++;\n            }\n            i++;\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n_1 = 3;\n        int x_1 = 4;\n        long ans_1 = 6;\n        assert solution.minEnd(n_1, x_1) == ans_1;\n        int n_2 = 2;\n        int x_2 = 7;\n        long ans_2 = 15;\n        assert solution.minEnd(n_2, x_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long minEnd(int n, int x) {",
        "function_name": "minEnd",
        "difficulty_level": "Middle",
        "time": "20240428"
    },
    {
        "id": "3134",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 。数组 nums 的 唯一性数组 是一个按元素从小到大排序的数组，包含了 nums 的所有非空子数组中不同元素的个数。\n换句话说，这是由所有 0 <= i <= j < nums.length 的 distinct(nums[i..j]) 组成的递增数组。其中，distinct(nums[i..j]) 表示从下标 i 到下标 j 的子数组中不同元素的数量。\n返回 nums 唯一性数组 的 中位数 。\n注意，数组的 中位数 定义为有序数组的中间元素。如果有两个中间元素，则取值较小的那个。\n示例 1：\n输入nums = [1,2,3]\n输出：1示例 2：\n输入nums = [3,4,3,4,5]\n输出：2\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\n\"\"\"\n\nclass Solution {\n    public int medianOfUniquenessArray(int[] nums) {",
        "prompt_chat": "给你一个整数数组 nums 。数组 nums 的 唯一性数组 是一个按元素从小到大排序的数组，包含了 nums 的所有非空子数组中不同元素的个数。\n换句话说，这是由所有 0 <= i <= j < nums.length 的 distinct(nums[i..j]) 组成的递增数组。其中，distinct(nums[i..j]) 表示从下标 i 到下标 j 的子数组中不同元素的数量。\n返回 nums 唯一性数组 的 中位数 。\n注意，数组的 中位数 定义为有序数组的中间元素。如果有两个中间元素，则取值较小的那个。\n示例 1：\n输入nums = [1,2,3]\n输出：1示例 2：\n输入nums = [3,4,3,4,5]\n输出：2\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int medianOfUniquenessArray(int[] nums) {\n```",
        "solution": "class Solution {\n    public int medianOfUniquenessArray(int[] nums) {\n        int n = nums.length;\n        long k = ((long) n * (n + 1) / 2 + 1) / 2;\n        int left = 0;\n        int right = n;\n        while (left + 1 < right) {\n            int mid = (left + right) / 2;\n            if (check(nums, mid, k)) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        return right;\n    }\n\n    private boolean check(int[] nums, int upper, long k) {\n        long cnt = 0;\n        int l = 0;\n        HashMap<Integer, Integer> freq = new HashMap<>();\n        for (int r = 0; r < nums.length; r++) {\n            freq.merge(nums[r], 1, Integer::sum);\n            while (freq.size() > upper) {\n                int out = nums[l++];\n                if (freq.merge(out, -1, Integer::sum) == 0) {\n                    freq.remove(out);\n                }\n            }\n            cnt += r - l + 1;\n            if (cnt >= k) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,3};\n        int ans_1 = 1;\n        assert solution.medianOfUniquenessArray(nums_1) == ans_1;\n        int[] nums_2 = {3,4,3,4,5};\n        int ans_2 = 2;\n        assert solution.medianOfUniquenessArray(nums_2) == ans_2;\n        int[] nums_3 = {4,3,5,4};\n        int ans_3 = 2;\n        assert solution.medianOfUniquenessArray(nums_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int medianOfUniquenessArray(int[] nums) {",
        "function_name": "medianOfUniquenessArray",
        "difficulty_level": "Hard",
        "time": "20240428"
    },
    {
        "id": "3136",
        "prompt_base": "\"\"\"\n有效单词 需要满足以下几个条件：至少 包含 3 个字符。由数字 0-9 和英文大小写字母组成。（不必包含所有这类字符。）至少 包含一个 元音字母 。至少 包含一个 辅音字母 。\n给你一个字符串 word 。如果 word 是一个有效单词，则返回 true ，否则返回 false 。\n注意：\n'a'、'e'、'i'、'o'、'u' 及其大写形式都属于 元音字母 。\n英文中的 辅音字母 是指那些除元音字母之外的字母。\n示例 1：\n输入word = \"234Adas\"\n输出：true示例 2：\n输入word = \"b3\"\n输出：false\n\n提示：\n1 <= word.length <= 20\nword 由英文大写和小写字母、数字、'@'、'#' 和 '$' 组成。\n\"\"\"\n\nclass Solution {\n    public boolean isValid(String word) {",
        "prompt_chat": "有效单词 需要满足以下几个条件：至少 包含 3 个字符。由数字 0-9 和英文大小写字母组成。（不必包含所有这类字符。）至少 包含一个 元音字母 。至少 包含一个 辅音字母 。\n给你一个字符串 word 。如果 word 是一个有效单词，则返回 true ，否则返回 false 。\n注意：\n'a'、'e'、'i'、'o'、'u' 及其大写形式都属于 元音字母 。\n英文中的 辅音字母 是指那些除元音字母之外的字母。\n示例 1：\n输入word = \"234Adas\"\n输出：true示例 2：\n输入word = \"b3\"\n输出：false\n\n提示：\n1 <= word.length <= 20\nword 由英文大写和小写字母、数字、'@'、'#' 和 '$' 组成。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public boolean isValid(String word) {\n```",
        "solution": "class Solution {\n    public boolean isValid(String word) {\n        if (word.length() < 3) {\n            return false;\n        }\n        boolean[] f = new boolean[2];\n        Arrays.fill(f, false);\n        for (char c : word.toCharArray()) {\n            if (Character.isAlphabetic(c)) {\n                c = Character.toLowerCase(c);\n                f[c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ? 1 : 0] = true;\n            } else if (!Character.isDigit(c)) {\n                return false;\n            }\n        }\n        return f[0] && f[1];\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String word_1 = \"234Adas\";\n        boolean ans_1 = true;\n        assert solution.isValid(word_1) == ans_1;\n        String word_2 = \"b3\";\n        boolean ans_2 = false;\n        assert solution.isValid(word_2) == ans_2;\n        String word_3 = \"a3$e\";\n        boolean ans_3 = false;\n        assert solution.isValid(word_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public boolean isValid(String word) {",
        "function_name": "isValid",
        "difficulty_level": "Easy",
        "time": "20240505"
    },
    {
        "id": "3137",
        "prompt_base": "\"\"\"\n给你一个长度为 n 的字符串 word 和一个整数 k ，其中 k 是 n 的因数。\n在一次操作中，你可以选择任意两个下标 i 和 j，其中 0 <= i, j < n ，且这两个下标都可以被 k 整除，然后用从 j 开始的长度为 k 的子串替换从 i 开始的长度为 k 的子串。也就是说，将子串 word[i..i + k - 1] 替换为子串 word[j..j + k - 1] 。\n返回使 word 成为 K 周期字符串 所需的 最少 操作次数。\n如果存在某个长度为 k 的字符串 s，使得 word 可以表示为任意次数连接 s ，则称字符串 word 是 K 周期字符串 。例如，如果 word == \"ababab\"，那么 word 就是 s = \"ab\" 时的 2 周期字符串 。\n示例 1：\n输入word = \"leetcodeleet\", k = 4\n输出：1示例 2：\n输入word = \"leetcoleet\", k = 2\n输出：3\n\n提示：\n1 <= n == word.length <= 10^5\n1 <= k <= word.length\nk 能整除 word.length 。\nword 仅由小写英文字母组成。\n\"\"\"\n\nclass Solution {\n    public int minimumOperationsToMakeKPeriodic(String word, int k) {",
        "prompt_chat": "给你一个长度为 n 的字符串 word 和一个整数 k ，其中 k 是 n 的因数。\n在一次操作中，你可以选择任意两个下标 i 和 j，其中 0 <= i, j < n ，且这两个下标都可以被 k 整除，然后用从 j 开始的长度为 k 的子串替换从 i 开始的长度为 k 的子串。也就是说，将子串 word[i..i + k - 1] 替换为子串 word[j..j + k - 1] 。\n返回使 word 成为 K 周期字符串 所需的 最少 操作次数。\n如果存在某个长度为 k 的字符串 s，使得 word 可以表示为任意次数连接 s ，则称字符串 word 是 K 周期字符串 。例如，如果 word == \"ababab\"，那么 word 就是 s = \"ab\" 时的 2 周期字符串 。\n示例 1：\n输入word = \"leetcodeleet\", k = 4\n输出：1示例 2：\n输入word = \"leetcoleet\", k = 2\n输出：3\n\n提示：\n1 <= n == word.length <= 10^5\n1 <= k <= word.length\nk 能整除 word.length 。\nword 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumOperationsToMakeKPeriodic(String word, int k) {\n```",
        "solution": "class Solution {\n    public int minimumOperationsToMakeKPeriodic(String word, int k) {\n        int n = word.length();\n        int mx = 0;\n        HashMap<String, Integer> cnt = new HashMap<>();\n        for (int i = k; i <= n; i += k) {\n            String sub = word.substring(i - k, i);\n            int c = cnt.merge(sub, 1, Integer::sum); // c = ++cnt[sub]\n            mx = Math.max(mx, c);\n        }\n        return n / k - mx;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String word_1 = \"leetcodeleet\";\n        int k_1 = 4;\n        int ans_1 = 1;\n        assert solution.minimumOperationsToMakeKPeriodic(word_1, k_1) == ans_1;\n        String word_2 = \"leetcoleet\";\n        int k_2 = 2;\n        int ans_2 = 3;\n        assert solution.minimumOperationsToMakeKPeriodic(word_2, k_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumOperationsToMakeKPeriodic(String word, int k) {",
        "function_name": "minimumOperationsToMakeKPeriodic",
        "difficulty_level": "Middle",
        "time": "20240505"
    },
    {
        "id": "3138",
        "prompt_base": "\"\"\"\n给你一个字符串 s ，它由某个字符串 t 和若干 t  的 同位字符串 连接而成。\n请你返回字符串 t 的 最小 可能长度。\n同位字符串 指的是重新排列一个单词得到的另外一个字符串，原来字符串中的每个字符在新字符串中都恰好只使用一次。\n示例 1：\n输入s = \"abba\"\n输出：2示例 2：\n输入s = \"cdef\"\n输出：4\n\n提示：\n1 <= s.length <= 10^5\ns 只包含小写英文字母。\n\"\"\"\n\nclass Solution {\n    public int minAnagramLength(String s) {",
        "prompt_chat": "给你一个字符串 s ，它由某个字符串 t 和若干 t  的 同位字符串 连接而成。\n请你返回字符串 t 的 最小 可能长度。\n同位字符串 指的是重新排列一个单词得到的另外一个字符串，原来字符串中的每个字符在新字符串中都恰好只使用一次。\n示例 1：\n输入s = \"abba\"\n输出：2示例 2：\n输入s = \"cdef\"\n输出：4\n\n提示：\n1 <= s.length <= 10^5\ns 只包含小写英文字母。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minAnagramLength(String s) {\n```",
        "solution": "class Solution {\n    public int minAnagramLength(String S) {\n        char[] s = S.toCharArray();\n        int n = s.length;\n        next:\n        for (int k = 1; k <= n / 2; k++) {\n            if (n % k > 0) {\n                continue;\n            }\n            int[] cnt0 = new int[26];\n            for (int j = 0; j < k; j++) {\n                cnt0[s[j] - 'a']++;\n            }\n            for (int i = k * 2; i <= n; i += k) {\n                int[] cnt = new int[26];\n                for (int j = i - k; j < i; j++) {\n                    cnt[s[j] - 'a']++;\n                }\n                if (!Arrays.equals(cnt, cnt0)) {\n                    continue next;\n                }\n            }\n            return k;\n        }\n        return n;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s_1 = \"abba\";\n        int ans_1 = 2;\n        assert solution.minAnagramLength(s_1) == ans_1;\n        String s_2 = \"cdef\";\n        int ans_2 = 4;\n        assert solution.minAnagramLength(s_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minAnagramLength(String s) {",
        "function_name": "minAnagramLength",
        "difficulty_level": "Middle",
        "time": "20240505"
    },
    {
        "id": "3139",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 和两个整数 cost1 和 cost2 。你可以执行以下 任一 操作 任意 次：从 nums 中选择下标 i 并且将 nums[i] 增加 1 ，开销为 cost1。选择 nums 中两个 不同 下标 i 和 j ，并且将 nums[i] 和 nums[j] 都 增加 1 ，开销为 cost2 。\n你的目标是使数组中所有元素都 相等 ，请你返回需要的 最小开销 之和。\n由于答案可能会很大，请你将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入nums = [4,1], cost1 = 5, cost2 = 2\n输出：15示例 2：\n输入nums = [2,3,3,3,5], cost1 = 2, cost2 = 1\n输出：6\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^6\n1 <= cost1 <= 10^6\n1 <= cost2 <= 10^6\n\"\"\"\n\nclass Solution {\n    public int minCostToEqualizeArray(int[] nums, int cost1, int cost2) {",
        "prompt_chat": "给你一个整数数组 nums 和两个整数 cost1 和 cost2 。你可以执行以下 任一 操作 任意 次：从 nums 中选择下标 i 并且将 nums[i] 增加 1 ，开销为 cost1。选择 nums 中两个 不同 下标 i 和 j ，并且将 nums[i] 和 nums[j] 都 增加 1 ，开销为 cost2 。\n你的目标是使数组中所有元素都 相等 ，请你返回需要的 最小开销 之和。\n由于答案可能会很大，请你将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入nums = [4,1], cost1 = 5, cost2 = 2\n输出：15示例 2：\n输入nums = [2,3,3,3,5], cost1 = 2, cost2 = 1\n输出：6\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^6\n1 <= cost1 <= 10^6\n1 <= cost2 <= 10^6\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minCostToEqualizeArray(int[] nums, int cost1, int cost2) {\n```",
        "solution": "class Solution {\n    public int minCostToEqualizeArray(int[] nums, int c1, int c2) {\n        final int MOD = 1_000_000_007;\n        long n = nums.length;\n        int m = Integer.MAX_VALUE;\n        int M = Integer.MIN_VALUE;\n        long sum = 0;\n        for (int x : nums) {\n            m = Math.min(m, x);\n            M = Math.max(M, x);\n            sum += x;\n        }\n\n        long base = n * M - sum;\n        if (n <= 2 || c1 * 2 <= c2) {\n            return (int) (base * c1 % MOD);\n        }\n\n        int i = (int) ((n * M - m * 2 - base + n - 3) / (n - 2));\n        long res1 = f(M, base, n, m, M, c1, c2);\n        long res2 = f(M + 1, base, n, m, M, c1, c2);\n        long res3 = f(i - 1, base, n, m, M, c1, c2);\n        long res4 = f(i, base, n, m, M, c1, c2);\n        long res5 = f(i + 1, base, n, m, M, c1, c2);\n        return (int) (i <= M ? Math.min(res1, res2) % MOD :\n                Math.min(Math.min(Math.min(res1, res3), res4), res5) % MOD);\n    }\n\n    private long f(int x, long base, long n, int m, int M, int c1, int c2) {\n        long s = base + (x - M) * n;\n        int d = x - m;\n        if (d * 2 <= s) {\n            return s / 2 * c2 + s % 2 * c1;\n        }\n        return (s - d) * c2 + (d * 2 - s) * c1;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {4,1};\n        int cost1_1 = 5;\n        int cost2_1 = 2;\n        int ans_1 = 15;\n        assert solution.minCostToEqualizeArray(nums_1, cost1_1, cost2_1) == ans_1;\n        int[] nums_2 = {2,3,3,3,5};\n        int cost1_2 = 2;\n        int cost2_2 = 1;\n        int ans_2 = 6;\n        assert solution.minCostToEqualizeArray(nums_2, cost1_2, cost2_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minCostToEqualizeArray(int[] nums, int cost1, int cost2) {",
        "function_name": "minCostToEqualizeArray",
        "difficulty_level": "Hard",
        "time": "20240505"
    },
    {
        "id": "3146",
        "prompt_base": "\"\"\"\n给你两个字符串 s 和 t，每个字符串中的字符都不重复，且 t 是 s 的一个排列。排列差 定义为 s 和 t 中每个字符在两个字符串中位置的绝对差值之和。返回 s 和 t 之间的 排列差 。\n示例 1：\n输入s = \"abc\", t = \"bac\"\n输出：2示例 2：\n输入s = \"abcde\", t = \"edbac\"\n输出：12\n\n提示：\n1 <= s.length <= 26\n每个字符在 s 中最多出现一次。\nt 是 s 的一个排列。\ns 仅由小写英文字母组成。\n\"\"\"\n\nclass Solution {\n    public int findPermutationDifference(String s, String t) {",
        "prompt_chat": "给你两个字符串 s 和 t，每个字符串中的字符都不重复，且 t 是 s 的一个排列。排列差 定义为 s 和 t 中每个字符在两个字符串中位置的绝对差值之和。返回 s 和 t 之间的 排列差 。\n示例 1：\n输入s = \"abc\", t = \"bac\"\n输出：2示例 2：\n输入s = \"abcde\", t = \"edbac\"\n输出：12\n\n提示：\n1 <= s.length <= 26\n每个字符在 s 中最多出现一次。\nt 是 s 的一个排列。\ns 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int findPermutationDifference(String s, String t) {\n```",
        "solution": "class Solution {\n    public int findPermutationDifference(String s, String t) {\n        int[] pos = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            pos[s.charAt(i) - 'a'] = i;\n        }\n        int ans = 0;\n        for (int i = 0; i < t.length(); i++) {\n            ans += Math.abs(i - pos[t.charAt(i) - 'a']);\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s_1 = \"abc\";\n        String t_1 = \"bac\";\n        int ans_1 = 2;\n        assert solution.findPermutationDifference(s_1, t_1) == ans_1;\n        String s_2 = \"abcde\";\n        String t_2 = \"edbac\";\n        int ans_2 = 12;\n        assert solution.findPermutationDifference(s_2, t_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int findPermutationDifference(String s, String t) {",
        "function_name": "findPermutationDifference",
        "difficulty_level": "Easy",
        "time": "20240512"
    },
    {
        "id": "3147",
        "prompt_base": "\"\"\"\n在神秘的地牢中，n 个魔法师站成一排。每个魔法师都拥有一个属性，这个属性可以给你提供能量。有些魔法师可能会给你负能量，即从你身上吸取能量。\n你被施加了一种诅咒，当你从魔法师 i 处吸收能量后，你将被立即传送到魔法师 (i + k) 处。这一过程将重复进行，直到你到达一个不存在 (i + k) 的魔法师为止。\n换句话说，你将选择一个起点，然后以 k 为间隔跳跃，直到到达魔法师序列的末端，在过程中吸收所有的能量。\n给定一个数组 energy 和一个整数k，返回你能获得的 最大 能量。\n示例 1：\n输入energy = [5,2,-10,-5,1], k = 3\n输出：3示例 2：\n输入energy = [-2,-3,-1], k = 2\n输出：-1\n\n提示：\n1 <= energy.length <= 10^5\n-1000 <= energy[i] <= 1000\n1 <= k <= energy.length - 1\n\"\"\"\n\nclass Solution {\n    public int maximumEnergy(int[] energy, int k) {",
        "prompt_chat": "在神秘的地牢中，n 个魔法师站成一排。每个魔法师都拥有一个属性，这个属性可以给你提供能量。有些魔法师可能会给你负能量，即从你身上吸取能量。\n你被施加了一种诅咒，当你从魔法师 i 处吸收能量后，你将被立即传送到魔法师 (i + k) 处。这一过程将重复进行，直到你到达一个不存在 (i + k) 的魔法师为止。\n换句话说，你将选择一个起点，然后以 k 为间隔跳跃，直到到达魔法师序列的末端，在过程中吸收所有的能量。\n给定一个数组 energy 和一个整数k，返回你能获得的 最大 能量。\n示例 1：\n输入energy = [5,2,-10,-5,1], k = 3\n输出：3示例 2：\n输入energy = [-2,-3,-1], k = 2\n输出：-1\n\n提示：\n1 <= energy.length <= 10^5\n-1000 <= energy[i] <= 1000\n1 <= k <= energy.length - 1\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maximumEnergy(int[] energy, int k) {\n```",
        "solution": "class Solution {\n    public int maximumEnergy(int[] energy, int k) {\n        int n = energy.length;\n        int ans = Integer.MIN_VALUE;\n        for (int i = n - k; i < n; i++) {\n            int s = 0;\n            for (int j = i; j >= 0; j -= k) {\n                s += energy[j];\n                ans = Math.max(ans, s);\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] energy_1 = {5,2,-10,-5,1};\n        int k_1 = 3;\n        int ans_1 = 3;\n        assert solution.maximumEnergy(energy_1, k_1) == ans_1;\n        int[] energy_2 = {-2,-3,-1};\n        int k_2 = 2;\n        int ans_2 = -1;\n        assert solution.maximumEnergy(energy_2, k_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maximumEnergy(int[] energy, int k) {",
        "function_name": "maximumEnergy",
        "difficulty_level": "Middle",
        "time": "20240512"
    },
    {
        "id": "3148",
        "prompt_base": "\"\"\"\n给你一个由 正整数 组成、大小为 m x n 的矩阵 grid。你可以从矩阵中的任一单元格移动到另一个位于正下方或正右侧的任意单元格（不必相邻）。从值为 c1 的单元格移动到值为 c2 的单元格的得分为 c2 - c1 。\n你可以从 任一 单元格开始，并且必须至少移动一次。\n返回你能得到的 最大 总得分。\n示例 1：\n输入grid = [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]\n输出：9示例 2：\n输入grid = [[4,3,2],[3,2,1]]\n输出：-1\n\n提示：\nm == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 10^5\n1 <= grid[i][j] <= 10^5\n\"\"\"\n\nclass Solution {\n    public int maxScore(List<List<Integer>> grid) {",
        "prompt_chat": "给你一个由 正整数 组成、大小为 m x n 的矩阵 grid。你可以从矩阵中的任一单元格移动到另一个位于正下方或正右侧的任意单元格（不必相邻）。从值为 c1 的单元格移动到值为 c2 的单元格的得分为 c2 - c1 。\n你可以从 任一 单元格开始，并且必须至少移动一次。\n返回你能得到的 最大 总得分。\n示例 1：\n输入grid = [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]\n输出：9示例 2：\n输入grid = [[4,3,2],[3,2,1]]\n输出：-1\n\n提示：\nm == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 10^5\n1 <= grid[i][j] <= 10^5\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maxScore(List<List<Integer>> grid) {\n```",
        "solution": "class Solution {\n    public int maxScore(List<List<Integer>> grid) {\n        int ans = Integer.MIN_VALUE;\n        int m = grid.size(), n = grid.get(0).size();\n        int[][] f = new int[m + 1][n + 1];\n        Arrays.fill(f[0], Integer.MAX_VALUE);\n        for (int i = 0; i < m; i++) {\n            f[i + 1][0] = Integer.MAX_VALUE;\n            List<Integer> row = grid.get(i);\n            for (int j = 0; j < n; j++) {\n                int mn = Math.min(f[i + 1][j], f[i][j + 1]);\n                int x = row.get(j);\n                ans = Math.max(ans, x - mn);\n                f[i + 1][j + 1] = Math.min(mn, x);\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<List<Integer>> level2_count1 = new ArrayList<>();\n        List<Integer> level1_count1 = new ArrayList<>();\n        level1_count1.add(9);\n        level1_count1.add(5);\n        level1_count1.add(7);\n        level1_count1.add(3);\n        level2_count1.add(level1_count1);\n        List<Integer> level1_count2 = new ArrayList<>();\n        level1_count2.add(8);\n        level1_count2.add(9);\n        level1_count2.add(6);\n        level1_count2.add(1);\n        level2_count1.add(level1_count2);\n        List<Integer> level1_count3 = new ArrayList<>();\n        level1_count3.add(6);\n        level1_count3.add(7);\n        level1_count3.add(14);\n        level1_count3.add(3);\n        level2_count1.add(level1_count3);\n        List<Integer> level1_count4 = new ArrayList<>();\n        level1_count4.add(2);\n        level1_count4.add(5);\n        level1_count4.add(3);\n        level1_count4.add(1);\n        level2_count1.add(level1_count4);\n        int ans_1 = 9;\n        assert solution.maxScore(level2_count1) == ans_1;\n        List<List<Integer>> level2_count2 = new ArrayList<>();\n        List<Integer> level1_count5 = new ArrayList<>();\n        level1_count5.add(4);\n        level1_count5.add(3);\n        level1_count5.add(2);\n        level2_count2.add(level1_count5);\n        List<Integer> level1_count6 = new ArrayList<>();\n        level1_count6.add(3);\n        level1_count6.add(2);\n        level1_count6.add(1);\n        level2_count2.add(level1_count6);\n        int ans_2 = -1;\n        assert solution.maxScore(level2_count2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maxScore(List<List<Integer>> grid) {",
        "function_name": "maxScore",
        "difficulty_level": "Middle",
        "time": "20240512"
    },
    {
        "id": "3149",
        "prompt_base": "\"\"\"\n给你一个数组 nums,它是 [0, 1, 2, ..., n - 1] 的一个 排列 。对于任意一个[0, 1, 2, ..., n - 1] 的排列 perm其 分数 定义为：score(perm) = |perm[0] - nums[perm[1]]| + |perm[1] - nums[perm[2]]| + ... + |perm[n - 1] - nums[perm[0]]|\n返回具有 最低 分数的排列 perm 。如果存在多个满足题意且分数相等的排列，则返回其中 字典序最小 的一个。\n示例 1：\n输入nums = [1,0,2]\n输出：[0,1,2]示例 2：\n输入nums = [0,2,1]\n输出：[0,2,1]\n\n提示：\n2 <= n == nums.length <= 14\nnums 是 [0, 1, 2, ..., n - 1] 的一个排列。\n\"\"\"\n\nclass Solution {\n    public int[] findPermutation(int[] nums) {",
        "prompt_chat": "给你一个数组 nums,它是 [0, 1, 2, ..., n - 1] 的一个 排列 。对于任意一个[0, 1, 2, ..., n - 1] 的排列 perm其 分数 定义为：score(perm) = |perm[0] - nums[perm[1]]| + |perm[1] - nums[perm[2]]| + ... + |perm[n - 1] - nums[perm[0]]|\n返回具有 最低 分数的排列 perm 。如果存在多个满足题意且分数相等的排列，则返回其中 字典序最小 的一个。\n示例 1：\n输入nums = [1,0,2]\n输出：[0,1,2]示例 2：\n输入nums = [0,2,1]\n输出：[0,2,1]\n\n提示：\n2 <= n == nums.length <= 14\nnums 是 [0, 1, 2, ..., n - 1] 的一个排列。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int[] findPermutation(int[] nums) {\n```",
        "solution": "class Solution {\n    public int[] findPermutation(int[] a) {\n        int n = a.length;\n        int[][] memo = new int[1 << n][n];\n        for (int[] row : memo) {\n            Arrays.fill(row, -1); // -1 表示没有计算过\n        }\n        int[] ans = new int[n];\n        makeAns(1, 0, a, memo, ans, 0);\n        return ans;\n    }\n\n    private int dfs(int s, int j, int[] a, int[][] memo) {\n        if (s == (1 << a.length) - 1) {\n            return Math.abs(j - a[0]);\n        }\n        if (memo[s][j] != -1) { // 之前计算过\n            return memo[s][j];\n        }\n        int res = Integer.MAX_VALUE;\n        for (int k = 1; k < a.length; k++) {\n            if ((s >> k & 1) == 0) { // k 之前没填过\n                res = Math.min(res, dfs(s | 1 << k, k, a, memo) + Math.abs(j - a[k]));\n            }\n        }\n        memo[s][j] = res; // 记忆化\n        return res;\n    }\n\n    private void makeAns(int s, int j, int[] a, int[][] memo, int[] ans, int i) {\n        ans[i] = j;\n        if (s == (1 << a.length) - 1) {\n            return;\n        }\n        int finalRes = dfs(s, j, a, memo);\n        for (int k = 1; k < a.length; k++) {\n            if ((s >> k & 1) == 0 && dfs(s | 1 << k, k, a, memo) + Math.abs(j - a[k]) == finalRes) {\n                makeAns(s | 1 << k, k, a, memo, ans, i + 1);\n                break;\n            }\n        }\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,0,2};\n        int[] ans_1 = {0,1,2};\n        assert Arrays.equals(solution.findPermutation(nums_1), ans_1);\n        int[] nums_2 = {0,2,1};\n        int[] ans_2 = {0,2,1};\n        assert Arrays.equals(solution.findPermutation(nums_2), ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int[] findPermutation(int[] nums) {",
        "function_name": "findPermutation",
        "difficulty_level": "Hard",
        "time": "20240512"
    },
    {
        "id": "3151",
        "prompt_base": "\"\"\"\n如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 特殊数组 。\nAging 有一个整数数组 nums。如果 nums 是一个 特殊数组 ，返回 true，否则返回 false。\n示例 1：\n输入nums = [1]\n输出：true示例 2：\n输入nums = [2,1,4]\n输出：true\n\n提示：\n1 <= nums.length <= 100\n1 <= nums[i] <= 100\n\"\"\"\n\nclass Solution {\n    public boolean isArraySpecial(int[] nums) {",
        "prompt_chat": "如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 特殊数组 。\nAging 有一个整数数组 nums。如果 nums 是一个 特殊数组 ，返回 true，否则返回 false。\n示例 1：\n输入nums = [1]\n输出：true示例 2：\n输入nums = [2,1,4]\n输出：true\n\n提示：\n1 <= nums.length <= 100\n1 <= nums[i] <= 100\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public boolean isArraySpecial(int[] nums) {\n```",
        "solution": "class Solution {\n    public boolean isArraySpecial(int[] nums) {\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i - 1] % 2 == nums[i] % 2) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1};\n        boolean ans_1 = true;\n        assert solution.isArraySpecial(nums_1) == ans_1;\n        int[] nums_2 = {2,1,4};\n        boolean ans_2 = true;\n        assert solution.isArraySpecial(nums_2) == ans_2;\n        int[] nums_3 = {4,3,1,6};\n        boolean ans_3 = false;\n        assert solution.isArraySpecial(nums_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public boolean isArraySpecial(int[] nums) {",
        "function_name": "isArraySpecial",
        "difficulty_level": "Easy",
        "time": "20240519"
    },
    {
        "id": "3152",
        "prompt_base": "\"\"\"\n如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 特殊数组 。\n周洋哥有一个整数数组 nums 和一个二维整数矩阵 queries，对于 queries[i] = [fromi, toi]，请你帮助周洋哥检查子数组 nums[fromi..toi] 是不是一个 特殊数组 。\n返回布尔数组 answer，如果 nums[fromi..toi] 是特殊数组，则 answer[i] 为 true ，否则，answer[i] 为 false 。\n示例 1：\n输入nums = [3,4,1,2,6], queries = [[0,4]]\n输出：[false]示例 2：\n输入nums = [4,3,1,6], queries = [[0,2],[2,3]]\n输出：[false,true]\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\n1 <= queries.length <= 10^5\nqueries[i].length == 2\n0 <= queries[i][0] <= queries[i][1] <= nums.length - 1\n\"\"\"\n\nclass Solution {\n    public boolean[] isArraySpecial(int[] nums, int[][] queries) {",
        "prompt_chat": "如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 特殊数组 。\n周洋哥有一个整数数组 nums 和一个二维整数矩阵 queries，对于 queries[i] = [fromi, toi]，请你帮助周洋哥检查子数组 nums[fromi..toi] 是不是一个 特殊数组 。\n返回布尔数组 answer，如果 nums[fromi..toi] 是特殊数组，则 answer[i] 为 true ，否则，answer[i] 为 false 。\n示例 1：\n输入nums = [3,4,1,2,6], queries = [[0,4]]\n输出：[false]示例 2：\n输入nums = [4,3,1,6], queries = [[0,2],[2,3]]\n输出：[false,true]\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\n1 <= queries.length <= 10^5\nqueries[i].length == 2\n0 <= queries[i][0] <= queries[i][1] <= nums.length - 1\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public boolean[] isArraySpecial(int[] nums, int[][] queries) {\n```",
        "solution": "class Solution {\n    public boolean[] isArraySpecial(int[] nums, int[][] queries) {\n        int[] s = new int[nums.length];\n        for (int i = 1; i < nums.length; i++) {\n            s[i] = s[i - 1] + (nums[i - 1] % 2 == nums[i] % 2 ? 1 : 0);\n        }\n        boolean[] ans = new boolean[queries.length];\n        for (int i = 0; i < queries.length; i++) {\n            int[] q = queries[i];\n            ans[i] = s[q[0]] == s[q[1]];\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {3,4,1,2,6};\n        int[][] queries_1 = {{0,4}};\n        boolean[] ans_1 = {false};\n        assert Arrays.equals(solution.isArraySpecial(nums_1, queries_1), ans_1);\n        int[] nums_2 = {4,3,1,6};\n        int[][] queries_2 = {{0,2},{2,3}};\n        boolean[] ans_2 = {false,true};\n        assert Arrays.equals(solution.isArraySpecial(nums_2, queries_2), ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public boolean[] isArraySpecial(int[] nums, int[][] queries) {",
        "function_name": "isArraySpecial",
        "difficulty_level": "Middle",
        "time": "20240519"
    },
    {
        "id": "3153",
        "prompt_base": "\"\"\"\n车尔尼有一个数组 nums ，它只包含 正 整数，所有正整数的数位长度都 相同 。\n两个整数的 数位不同 指的是两个整数 相同 位置上不同数字的数目。\n请车尔尼返回 nums 中 所有 整数对里，数位不同之和。\n示例 1：\n输入nums = [13,23,12]\n输出：4示例 2：\n输入nums = [10,10,10,10]\n输出：0\n\n提示：\n2 <= nums.length <= 10^5\n1 <= nums[i] < 10^9\nnums 中的整数都有相同的数位长度。\n\"\"\"\n\nclass Solution {\n    public long sumDigitDifferences(int[] nums) {",
        "prompt_chat": "车尔尼有一个数组 nums ，它只包含 正 整数，所有正整数的数位长度都 相同 。\n两个整数的 数位不同 指的是两个整数 相同 位置上不同数字的数目。\n请车尔尼返回 nums 中 所有 整数对里，数位不同之和。\n示例 1：\n输入nums = [13,23,12]\n输出：4示例 2：\n输入nums = [10,10,10,10]\n输出：0\n\n提示：\n2 <= nums.length <= 10^5\n1 <= nums[i] < 10^9\nnums 中的整数都有相同的数位长度。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long sumDigitDifferences(int[] nums) {\n```",
        "solution": "class Solution {\n    public long sumDigitDifferences(int[] nums) {\n        long ans = 0;\n        int[][] cnt = new int[Integer.toString(nums[0]).length()][10];\n        for (int k = 0; k < nums.length; k++) {\n            int x = nums[k];\n            for (int i = 0; x > 0; x /= 10, i++) {\n                int d = x % 10;\n                ans += k - cnt[i][d]++;\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {13,23,12};\n        long ans_1 = 4;\n        assert solution.sumDigitDifferences(nums_1) == ans_1;\n        int[] nums_2 = {10,10,10,10};\n        long ans_2 = 0;\n        assert solution.sumDigitDifferences(nums_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long sumDigitDifferences(int[] nums) {",
        "function_name": "sumDigitDifferences",
        "difficulty_level": "Middle",
        "time": "20240519"
    },
    {
        "id": "3154",
        "prompt_base": "\"\"\"\n给你有一个 非负 整数 k 。有一个无限长度的台阶，最低 一层编号为 0 。\n虎老师有一个整数 jump ，一开始值为 0 。虎老师从台阶 1 开始，虎老师可以使用 任意 次操作，目标是到达第 k 级台阶。假设虎老师位于台阶 i ，一次 操作 中，虎老师可以：向下走一级到 i - 1 ，但该操作 不能 连续使用，如果在台阶第 0 级也不能使用。向上走到台阶 i + 2^jump 处，然后 jump 变为 jump + 1 。\n请你返回虎老师到达台阶 k 处的总方案数。\n注意 ，虎老师可能到达台阶 k 处后，通过一些操作重新回到台阶 k 处，这视为不同的方案。\n示例 1：\n输入k = 0\n输出：2示例 2：\n输入k = 1\n输出：4\n\n提示：\n0 <= k <= 10^9\n\"\"\"\n\nclass Solution {\n    public int waysToReachStair(int k) {",
        "prompt_chat": "给你有一个 非负 整数 k 。有一个无限长度的台阶，最低 一层编号为 0 。\n虎老师有一个整数 jump ，一开始值为 0 。虎老师从台阶 1 开始，虎老师可以使用 任意 次操作，目标是到达第 k 级台阶。假设虎老师位于台阶 i ，一次 操作 中，虎老师可以：向下走一级到 i - 1 ，但该操作 不能 连续使用，如果在台阶第 0 级也不能使用。向上走到台阶 i + 2^jump 处，然后 jump 变为 jump + 1 。\n请你返回虎老师到达台阶 k 处的总方案数。\n注意 ，虎老师可能到达台阶 k 处后，通过一些操作重新回到台阶 k 处，这视为不同的方案。\n示例 1：\n输入k = 0\n输出：2示例 2：\n输入k = 1\n输出：4\n\n提示：\n0 <= k <= 10^9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int waysToReachStair(int k) {\n```",
        "solution": "class Solution {\n    public int waysToReachStair(int k) {\n        return dfs(1, 0, 0, k, new HashMap<>());\n    }\n\n    private int dfs(int i, int j, int preDown, int k, Map<Long, Integer> memo) {\n        if (i > k + 1) {\n            return 0;\n        }\n        long p = ((long) i << 32) | j << 1 | preDown; // 用一个 long 表示状态\n        if (memo.containsKey(p)) { // 之前算过了\n            return memo.get(p);\n        }\n        int res = i == k ? 1 : 0;\n        res += dfs(i + (1 << j), j + 1, 0, k, memo); // 操作二\n        if (preDown == 0 && i > 0) {\n            res += dfs(i - 1, j, 1, k, memo); // 操作一\n        }\n        memo.put(p, res); // 记忆化\n        return res;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int k_1 = 0;\n        int ans_1 = 2;\n        assert solution.waysToReachStair(k_1) == ans_1;\n        int k_2 = 1;\n        int ans_2 = 4;\n        assert solution.waysToReachStair(k_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int waysToReachStair(int k) {",
        "function_name": "waysToReachStair",
        "difficulty_level": "Hard",
        "time": "20240519"
    },
    {
        "id": "3162",
        "prompt_base": "\"\"\"\n给你两个整数数组 nums1 和 nums2，长度分别为 n 和 m。同时给你一个正整数 k。\n\n如果 nums1[i] 可以被 nums2[j] * k 整除，则称数对 (i, j) 为 优质数对（0 <= i <= n - 1, 0 <= j <= m - 1）。\n\n返回 优质数对 的总数。\n示例 1：\n输入nums1 = [1,3,4], nums2 = [1,3,4], k = 1\n输出：5示例 2：\n输入nums1 = [1,2,4,12], nums2 = [2,4], k = 3\n输出：2\n\n提示：\n1 <= n, m <= 50\n1 <= nums1[i], nums2[j] <= 50\n1 <= k <= 50\n\"\"\"\n\nclass Solution {\n    public int numberOfPairs(int[] nums1, int[] nums2, int k) {",
        "prompt_chat": "给你两个整数数组 nums1 和 nums2，长度分别为 n 和 m。同时给你一个正整数 k。\n\n如果 nums1[i] 可以被 nums2[j] * k 整除，则称数对 (i, j) 为 优质数对（0 <= i <= n - 1, 0 <= j <= m - 1）。\n\n返回 优质数对 的总数。\n示例 1：\n输入nums1 = [1,3,4], nums2 = [1,3,4], k = 1\n输出：5示例 2：\n输入nums1 = [1,2,4,12], nums2 = [2,4], k = 3\n输出：2\n\n提示：\n1 <= n, m <= 50\n1 <= nums1[i], nums2[j] <= 50\n1 <= k <= 50\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int numberOfPairs(int[] nums1, int[] nums2, int k) {\n```",
        "solution": "class Solution {\n    public long numberOfPairs(int[] nums1, int[] nums2, int k) {\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int x : nums1) {\n            if (x % k != 0) {\n                continue;\n            }\n            x /= k;\n            for (int d = 1; d * d <= x; d++) {\n                if (x % d > 0) {\n                    continue;\n                }\n                cnt.merge(d, 1, Integer::sum);\n                if (d * d < x) {\n                    cnt.merge(x / d, 1, Integer::sum);\n                }\n            }\n        }\n\n        long ans = 0;\n        for (int x : nums2) {\n            ans += cnt.getOrDefault(x, 0);\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums1_1 = {1,3,4};\n        int[] nums2_1 = {1,3,4};\n        int k_1 = 1;\n        int ans_1 = 5;\n        assert solution.numberOfPairs(nums1_1, nums2_1, k_1) == ans_1;\n        int[] nums1_2 = {1,2,4,12};\n        int[] nums2_2 = {2,4};\n        int k_2 = 3;\n        int ans_2 = 2;\n        assert solution.numberOfPairs(nums1_2, nums2_2, k_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int numberOfPairs(int[] nums1, int[] nums2, int k) {",
        "function_name": "numberOfPairs",
        "difficulty_level": "Easy",
        "time": "20240526"
    },
    {
        "id": "3163",
        "prompt_base": "\"\"\"\n给你一个字符串 word，请你使用以下算法进行压缩：从空字符串 comp 开始。当 word 不为空 时，执行以下操作：移除 word 的最长单字符前缀，该前缀由单一字符 c 重复多次组成，且该前缀长度 最多 为 9 。将前缀的长度和字符 c 追加到 comp 。\n返回字符串 comp 。\n示例 1：\n输入word = \"abcde\"\n输出：\"1a1b1c1d1e\"示例 2：\n输入word = \"aaaaaaaaaaaaaabb\"\n输出：\"9a5a2b\"\n\n提示：\n1 <= word.length <= 2 * 10^5\nword 仅由小写英文字母组成。\n\"\"\"\n\nclass Solution {\n    public String compressedString(String word) {",
        "prompt_chat": "给你一个字符串 word，请你使用以下算法进行压缩：从空字符串 comp 开始。当 word 不为空 时，执行以下操作：移除 word 的最长单字符前缀，该前缀由单一字符 c 重复多次组成，且该前缀长度 最多 为 9 。将前缀的长度和字符 c 追加到 comp 。\n返回字符串 comp 。\n示例 1：\n输入word = \"abcde\"\n输出：\"1a1b1c1d1e\"示例 2：\n输入word = \"aaaaaaaaaaaaaabb\"\n输出：\"9a5a2b\"\n\n提示：\n1 <= word.length <= 2 * 10^5\nword 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public String compressedString(String word) {\n```",
        "solution": "class Solution {\n    public String compressedString(String word) {\n        StringBuilder t = new StringBuilder();\n        char[] s = word.toCharArray();\n        int i0 = -1;\n        for (int i = 0; i < s.length; i++) {\n            char c = s[i];\n            if (i + 1 == s.length || c != s[i + 1]) {\n                int k = i - i0;\n                for (int j = 0; j < k / 9; j++) {\n                    t.append('9').append(c);\n                }\n                if (k % 9 > 0) {\n                    t.append((char) ('0' + (k % 9))).append(c);\n                }\n                i0 = i;\n            }\n        }\n        return t.toString();\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String word_1 = \"abcde\";\n        String ans_1 = \"1a1b1c1d1e\";\n    assert solution.compressedString(word_1).equals(ans_1);\n        String word_2 = \"aaaaaaaaaaaaaabb\";\n        String ans_2 = \"9a5a2b\";\n    assert solution.compressedString(word_2).equals(ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public String compressedString(String word) {",
        "function_name": "compressedString",
        "difficulty_level": "Middle",
        "time": "20240526"
    },
    {
        "id": "3164",
        "prompt_base": "\"\"\"\n给你两个整数数组 nums1 和 nums2，长度分别为 n 和 m。同时给你一个正整数 k。\n如果 nums1[i] 可以被 nums2[j] * k 整除，则称数对 (i, j) 为 优质数对（0 <= i <= n - 1, 0 <= j <= m - 1）。\n返回 优质数对 的总数。\n示例 1：\n输入nums1 = [1,3,4], nums2 = [1,3,4], k = 1\n输出：5示例 2：\n输入nums1 = [1,2,4,12], nums2 = [2,4], k = 3\n输出：2\n\n提示：\n1 <= n, m <= 10^5\n1 <= nums1[i], nums2[j] <= 10^6\n1 <= k <= 10^3\n\"\"\"\n\nclass Solution {\n    public long numberOfPairs(int[] nums1, int[] nums2, int k) {",
        "prompt_chat": "给你两个整数数组 nums1 和 nums2，长度分别为 n 和 m。同时给你一个正整数 k。\n如果 nums1[i] 可以被 nums2[j] * k 整除，则称数对 (i, j) 为 优质数对（0 <= i <= n - 1, 0 <= j <= m - 1）。\n返回 优质数对 的总数。\n示例 1：\n输入nums1 = [1,3,4], nums2 = [1,3,4], k = 1\n输出：5示例 2：\n输入nums1 = [1,2,4,12], nums2 = [2,4], k = 3\n输出：2\n\n提示：\n1 <= n, m <= 10^5\n1 <= nums1[i], nums2[j] <= 10^6\n1 <= k <= 10^3\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long numberOfPairs(int[] nums1, int[] nums2, int k) {\n```",
        "solution": "class Solution {\n    public long numberOfPairs(int[] nums1, int[] nums2, int k) {\n        Map<Integer, Integer> cnt1 = new HashMap<>();\n        for (int x : nums1) {\n            if (x % k == 0) {\n                cnt1.merge(x / k, 1, Integer::sum);\n            }\n        }\n        if (cnt1.isEmpty()) {\n            return 0;\n        }\n\n        Map<Integer, Integer> cnt2 = new HashMap<>();\n        for (int x : nums2) {\n            cnt2.merge(x, 1, Integer::sum);\n        }\n\n        long ans = 0;\n        int u = Collections.max(cnt1.keySet());\n        for (Map.Entry<Integer, Integer> e : cnt2.entrySet()) {\n            int s = 0;\n            int i = e.getKey();\n            for (int j = i; j <= u; j += i) {\n                if (cnt1.containsKey(j)) {\n                    s += cnt1.get(j);\n                }\n            }\n            ans += (long) s * e.getValue();\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums1_1 = {1,3,4};\n        int[] nums2_1 = {1,3,4};\n        int k_1 = 1;\n        long ans_1 = 5;\n        assert solution.numberOfPairs(nums1_1, nums2_1, k_1) == ans_1;\n        int[] nums1_2 = {1,2,4,12};\n        int[] nums2_2 = {2,4};\n        int k_2 = 3;\n        long ans_2 = 2;\n        assert solution.numberOfPairs(nums1_2, nums2_2, k_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long numberOfPairs(int[] nums1, int[] nums2, int k) {",
        "function_name": "numberOfPairs",
        "difficulty_level": "Middle",
        "time": "20240526"
    },
    {
        "id": "3165",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 和一个二维数组 queries，其中 queries[i] = [posi, xi]。\n对于每个查询 i，首先将 nums[posi] 设置为 xi，然后计算查询 i 的答案，该答案为 nums 中 不包含相邻元素 的 子序列 的 最大 和。\n返回所有查询的答案之和。\n由于最终答案可能非常大，返回其对 10^9 + 7 取余 的结果。\n子序列 是指从另一个数组中删除一些或不删除元素而不改变剩余元素顺序得到的数组。\n示例 1：\n输入nums = [3,5,9], queries = [[1,-2],[0,-3]]\n输出：21示例 2：\n输入nums = [0,-1], queries = [[0,-5]]\n输出：0\n\n提示：\n1 <= nums.length <= 5 * 10^4\n-10^5 <= nums[i] <= 10^5\n1 <= queries.length <= 5 * 10^4\nqueries[i] == [posi, xi]\n0 <= posi <= nums.length - 1\n-10^5 <= xi <= 10^5\n\"\"\"\n\nclass Solution {\n    public int maximumSumSubsequence(int[] nums, int[][] queries) {",
        "prompt_chat": "给你一个整数数组 nums 和一个二维数组 queries，其中 queries[i] = [posi, xi]。\n对于每个查询 i，首先将 nums[posi] 设置为 xi，然后计算查询 i 的答案，该答案为 nums 中 不包含相邻元素 的 子序列 的 最大 和。\n返回所有查询的答案之和。\n由于最终答案可能非常大，返回其对 10^9 + 7 取余 的结果。\n子序列 是指从另一个数组中删除一些或不删除元素而不改变剩余元素顺序得到的数组。\n示例 1：\n输入nums = [3,5,9], queries = [[1,-2],[0,-3]]\n输出：21示例 2：\n输入nums = [0,-1], queries = [[0,-5]]\n输出：0\n\n提示：\n1 <= nums.length <= 5 * 10^4\n-10^5 <= nums[i] <= 10^5\n1 <= queries.length <= 5 * 10^4\nqueries[i] == [posi, xi]\n0 <= posi <= nums.length - 1\n-10^5 <= xi <= 10^5\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maximumSumSubsequence(int[] nums, int[][] queries) {\n```",
        "solution": "class Solution {\n    public int maximumSumSubsequence(int[] nums, int[][] queries) {\n        int n = nums.length;\n        // 4 个数分别保存 f00, f01, f10, f11\n        long[][] t = new long[2 << (32 - Integer.numberOfLeadingZeros(n))][4];\n        build(t, nums, 1, 0, n - 1);\n        long ans = 0;\n        for (int[] q : queries) {\n            update(t, 1, 0, n - 1, q[0], q[1]);\n            ans += t[1][3]; // 注意 f11 没有任何限制，也就是整个数组的打家劫舍\n        }\n        return (int) (ans % 1_000_000_007);\n    }\n\n    private void maintain(long[][] t, int o) {\n        long[] a = t[o * 2], b = t[o * 2 + 1];\n        t[o][0] = Math.max(a[0] + b[2], a[1] + b[0]);\n        t[o][1] = Math.max(a[0] + b[3], a[1] + b[1]);\n        t[o][2] = Math.max(a[2] + b[2], a[3] + b[0]);\n        t[o][3] = Math.max(a[2] + b[3], a[3] + b[1]);\n    }\n\n    // 用 nums 初始化线段树\n    private void build(long[][] t, int[] nums, int o, int l, int r) {\n        if (l == r) {\n            t[o][3] = Math.max(nums[l], 0);\n            return;\n        }\n        int m = (l + r) / 2;\n        build(t, nums, o * 2, l, m);\n        build(t, nums, o * 2 + 1, m + 1, r);\n        maintain(t, o);\n    }\n\n    // 把 nums[i] 改成 val\n    private void update(long[][] t, int o, int l, int r, int i, int val) {\n        if (l == r) {\n            t[o][3] = Math.max(val, 0);\n            return;\n        }\n        int m = (l + r) / 2;\n        if (i <= m) {\n            update(t, o * 2, l, m, i, val);\n        } else {\n            update(t, o * 2 + 1, m + 1, r, i, val);\n        }\n        maintain(t, o);\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {3,5,9};\n        int[][] queries_1 = {{1,-2},{0,-3}};\n        int ans_1 = 21;\n        assert solution.maximumSumSubsequence(nums_1, queries_1) == ans_1;\n        int[] nums_2 = {0,-1};\n        int[][] queries_2 = {{0,-5}};\n        int ans_2 = 0;\n        assert solution.maximumSumSubsequence(nums_2, queries_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maximumSumSubsequence(int[] nums, int[][] queries) {",
        "function_name": "maximumSumSubsequence",
        "difficulty_level": "Hard",
        "time": "20240526"
    },
    {
        "id": "3168",
        "prompt_base": "\"\"\"\n给你一个字符串 s，模拟每秒钟的事件 i: 如果 s[i] == 'E'，表示有一位顾客进入候诊室并占用一把椅子。如果 s[i] == 'L'，表示有一位顾客离开候诊室，从而释放一把椅子。返回保证每位进入候诊室的顾客都能有椅子坐的 最少 椅子数，假设候诊室最初是 空的 。\n示例 1：\n输入s = \"EEEEEEE\"\n输出：7示例 2：\n输入s = \"ELELEEL\"\n输出：2\n\n提示：\n1 <= s.length <= 50\n s 仅由字母 'E' 和 'L' 组成。\ns 表示一个有效的进出序列。\n\"\"\"\n\nclass Solution {\n    public int minimumChairs(String s) {",
        "prompt_chat": "给你一个字符串 s，模拟每秒钟的事件 i: 如果 s[i] == 'E'，表示有一位顾客进入候诊室并占用一把椅子。如果 s[i] == 'L'，表示有一位顾客离开候诊室，从而释放一把椅子。返回保证每位进入候诊室的顾客都能有椅子坐的 最少 椅子数，假设候诊室最初是 空的 。\n示例 1：\n输入s = \"EEEEEEE\"\n输出：7示例 2：\n输入s = \"ELELEEL\"\n输出：2\n\n提示：\n1 <= s.length <= 50\n s 仅由字母 'E' 和 'L' 组成。\ns 表示一个有效的进出序列。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumChairs(String s) {\n```",
        "solution": "class Solution {\n    public int minimumChairs(String s) {\n        int ans = 0;\n        int cnt = 0;\n        for (char c : s.toCharArray()) {\n            if (c == 'E') {\n                ans = Math.max(ans, ++cnt);\n            } else {\n                cnt--;\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s_1 = \"EEEEEEE\";\n        int ans_1 = 7;\n        assert solution.minimumChairs(s_1) == ans_1;\n        String s_2 = \"ELELEEL\";\n        int ans_2 = 2;\n        assert solution.minimumChairs(s_2) == ans_2;\n        String s_3 = \"ELEELEELLL\";\n        int ans_3 = 3;\n        assert solution.minimumChairs(s_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumChairs(String s) {",
        "function_name": "minimumChairs",
        "difficulty_level": "Easy",
        "time": "20240602"
    },
    {
        "id": "3169",
        "prompt_base": "\"\"\"\n给你一个正整数 days，表示员工可工作的总天数（从第 1 天开始）。另给你一个二维数组 meetings，长度为 n，其中 meetings[i] = [start_i, end_i] 表示第 i 次会议的开始和结束天数（包含首尾）。\n\n返回员工可工作且没有安排会议的天数。\n\n注意：会议时间可能会有重叠。\n示例 1：\n输入days = 10, meetings = [[5,7],[1,3],[9,10]]\n输出：2示例 2：\n输入days = 5, meetings = [[2,4],[1,3]]\n输出：1\n\n提示：\n1 <= days <= 10^9 \n 1 <= meetings.length <= 10^5\nmeetings[i].length == 2\n1 <= meetings[i][0] <= meetings[i][1] <= days\n\"\"\"\n\nclass Solution {\n    public int countDays(int days, int[][] meetings) {",
        "prompt_chat": "给你一个正整数 days，表示员工可工作的总天数（从第 1 天开始）。另给你一个二维数组 meetings，长度为 n，其中 meetings[i] = [start_i, end_i] 表示第 i 次会议的开始和结束天数（包含首尾）。\n\n返回员工可工作且没有安排会议的天数。\n\n注意：会议时间可能会有重叠。\n示例 1：\n输入days = 10, meetings = [[5,7],[1,3],[9,10]]\n输出：2示例 2：\n输入days = 5, meetings = [[2,4],[1,3]]\n输出：1\n\n提示：\n1 <= days <= 10^9 \n 1 <= meetings.length <= 10^5\nmeetings[i].length == 2\n1 <= meetings[i][0] <= meetings[i][1] <= days\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int countDays(int days, int[][] meetings) {\n```",
        "solution": "class Solution {\n    public int countDays(int days, int[][] meetings) {\n        Arrays.sort(meetings, (p, q) -> p[0] - q[0]); // 按照左端点从小到大排序\n        int start = 1, end = 0; // 当前合并区间的左右端点\n        for (int[] p : meetings) {\n            if (p[0] > end) { // 不相交\n                days -= end - start + 1; // 当前合并区间的长度\n                start = p[0]; // 下一个合并区间的左端点\n            }\n            end = Math.max(end, p[1]);\n        }\n        days -= end - start + 1; // 最后一个合并区间的长度\n        return days;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int days_1 = 10;\n        int[][] meetings_1 = {{5,7},{1,3},{9,10}};\n        int ans_1 = 2;\n        assert solution.countDays(days_1, meetings_1) == ans_1;\n        int days_2 = 5;\n        int[][] meetings_2 = {{2,4},{1,3}};\n        int ans_2 = 1;\n        assert solution.countDays(days_2, meetings_2) == ans_2;\n        int days_3 = 6;\n        int[][] meetings_3 = {{1,6}};\n        int ans_3 = 0;\n        assert solution.countDays(days_3, meetings_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int countDays(int days, int[][] meetings) {",
        "function_name": "countDays",
        "difficulty_level": "Middle",
        "time": "20240602"
    },
    {
        "id": "3170",
        "prompt_base": "\"\"\"\n给你一个字符串 s 。它可能包含任意数量的 '*' 字符。你的任务是删除所有的 '*' 字符。\n\n当字符串还存在至少一个 '*' 字符时，你可以执行以下操作：删除最左边的 '*' 字符，同时删除该星号字符左边一个字典序 最小 的字符。如果有多个字典序最小的字符，你可以删除它们中的任意一个。\n\n请你返回删除所有 '*' 字符以后，剩余字符连接而成的 字典序最小 的字符串。\n示例 1：\n输入s = \"aaba*\"\n输出：\"aab\"示例 2：\n输入s = \"abc\"\n输出：\"abc\"\n\n提示：\n1 <= s.length <= 10^5 \n s 只含有小写英文字母和 '*' 字符。\n输入保证操作可以删除所有的 '*' 字符。\n\"\"\"\n\nclass Solution {\n    public String clearStars(String s) {",
        "prompt_chat": "给你一个字符串 s 。它可能包含任意数量的 '*' 字符。你的任务是删除所有的 '*' 字符。\n\n当字符串还存在至少一个 '*' 字符时，你可以执行以下操作：删除最左边的 '*' 字符，同时删除该星号字符左边一个字典序 最小 的字符。如果有多个字典序最小的字符，你可以删除它们中的任意一个。\n\n请你返回删除所有 '*' 字符以后，剩余字符连接而成的 字典序最小 的字符串。\n示例 1：\n输入s = \"aaba*\"\n输出：\"aab\"示例 2：\n输入s = \"abc\"\n输出：\"abc\"\n\n提示：\n1 <= s.length <= 10^5 \n s 只含有小写英文字母和 '*' 字符。\n输入保证操作可以删除所有的 '*' 字符。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public String clearStars(String s) {\n```",
        "solution": "class Solution {\n    public String clearStars(String S) {\n        char[] s = S.toCharArray();\n        List<Integer>[] st = new ArrayList[26];\n        Arrays.setAll(st, i -> new ArrayList<>());\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] != '*') {\n                st[s[i] - 'a'].add(i);\n                continue;\n            }\n            for (List<Integer> p : st) {\n                if (!p.isEmpty()) {\n                    p.remove(p.size() - 1);\n                    break;\n                }\n            }\n        }\n\n        List<Integer> idx = new ArrayList<>();\n        for (List<Integer> p : st) {\n            idx.addAll(p);\n        }\n        Collections.sort(idx);\n\n        StringBuilder t = new StringBuilder(idx.size());\n        for (int i : idx) {\n            t.append(s[i]);\n        }\n        return t.toString();\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s_1 = \"aaba*\";\n        String ans_1 = \"aab\";\n    assert solution.clearStars(s_1).equals(ans_1);\n        String s_2 = \"abc\";\n        String ans_2 = \"abc\";\n    assert solution.clearStars(s_2).equals(ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public String clearStars(String s) {",
        "function_name": "clearStars",
        "difficulty_level": "Middle",
        "time": "20240602"
    },
    {
        "id": "3171",
        "prompt_base": "\"\"\"\n给你一个数组 nums 和一个整数 k 。你需要找到 nums 的一个 子数组 ，满足子数组中所有元素按位与运算 AND 的值与 k 的 绝对差 尽可能 小 。换言之，你需要选择一个子数组 nums[l..r] 满足 |k - (nums[l] AND nums[l + 1] ... AND nums[r])| 最小。\n\n请你返回 最小 的绝对差值。\n\n子数组是数组中连续的 非空 元素序列。\n示例 1：\n输入nums = [1,2,4,5], k = 3\n输出：1示例 2：\n输入nums = [1,2,1,2], k = 2\n输出：0\n\n提示：\n1 <= nums.length <= 10^5 \n 1 <= nums[i] <= 10^9\n1 <= k <= 10^9\n\"\"\"\n\nclass Solution {\n    public int minimumDifference(int[] nums, int k) {",
        "prompt_chat": "给你一个数组 nums 和一个整数 k 。你需要找到 nums 的一个 子数组 ，满足子数组中所有元素按位与运算 AND 的值与 k 的 绝对差 尽可能 小 。换言之，你需要选择一个子数组 nums[l..r] 满足 |k - (nums[l] AND nums[l + 1] ... AND nums[r])| 最小。\n\n请你返回 最小 的绝对差值。\n\n子数组是数组中连续的 非空 元素序列。\n示例 1：\n输入nums = [1,2,4,5], k = 3\n输出：1示例 2：\n输入nums = [1,2,1,2], k = 2\n输出：0\n\n提示：\n1 <= nums.length <= 10^5 \n 1 <= nums[i] <= 10^9\n1 <= k <= 10^9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumDifference(int[] nums, int k) {\n```",
        "solution": "class Solution {\n    public int minimumDifference(int[] nums, int k) {\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i < nums.length; i++) {\n            int x = nums[i];\n            ans = Math.min(ans, Math.abs(x - k));\n            for (int j = i - 1; j >= 0 && (nums[j] & x) != nums[j]; j--) {\n                nums[j] &= x;\n                ans = Math.min(ans, Math.abs(nums[j] - k));\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,4,5};\n        int k_1 = 3;\n        int ans_1 = 1;\n        assert solution.minimumDifference(nums_1, k_1) == ans_1;\n        int[] nums_2 = {1,2,1,2};\n        int k_2 = 2;\n        int ans_2 = 0;\n        assert solution.minimumDifference(nums_2, k_2) == ans_2;\n        int[] nums_3 = {1};\n        int k_3 = 10;\n        int ans_3 = 9;\n        assert solution.minimumDifference(nums_3, k_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumDifference(int[] nums, int k) {",
        "function_name": "minimumDifference",
        "difficulty_level": "Hard",
        "time": "20240602"
    },
    {
        "id": "3178",
        "prompt_base": "\"\"\"\n给你两个 正整数 n 和 k。有 n 个编号从 0 到 n - 1 的孩子按顺序从左到右站成一队。\n最初，编号为 0 的孩子拿着一个球，并且向右传球。每过一秒，拿着球的孩子就会将球传给他旁边的孩子。一旦球到达队列的 任一端 ，即编号为 0 的孩子或编号为 n - 1 的孩子处，传球方向就会 反转 。\n返回 k 秒后接到球的孩子的编号。\n示例 1：\n输入n = 3, k = 5\n输出：1示例 2：\n输入n = 5, k = 6\n输出：2\n\n提示：\n2 <= n <= 50\n1 <= k <= 50\n\"\"\"\n\nclass Solution {\n    public int numberOfChild(int n, int k) {",
        "prompt_chat": "给你两个 正整数 n 和 k。有 n 个编号从 0 到 n - 1 的孩子按顺序从左到右站成一队。\n最初，编号为 0 的孩子拿着一个球，并且向右传球。每过一秒，拿着球的孩子就会将球传给他旁边的孩子。一旦球到达队列的 任一端 ，即编号为 0 的孩子或编号为 n - 1 的孩子处，传球方向就会 反转 。\n返回 k 秒后接到球的孩子的编号。\n示例 1：\n输入n = 3, k = 5\n输出：1示例 2：\n输入n = 5, k = 6\n输出：2\n\n提示：\n2 <= n <= 50\n1 <= k <= 50\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int numberOfChild(int n, int k) {\n```",
        "solution": "class Solution {\n    public int numberOfChild(int n, int k) {\n        int t = k % (n - 1);\n        return k / (n - 1) % 2 > 0 ? n - t - 1 : t;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n_1 = 3;\n        int k_1 = 5;\n        int ans_1 = 1;\n        assert solution.numberOfChild(n_1, k_1) == ans_1;\n        int n_2 = 5;\n        int k_2 = 6;\n        int ans_2 = 2;\n        assert solution.numberOfChild(n_2, k_2) == ans_2;\n        int n_3 = 4;\n        int k_3 = 2;\n        int ans_3 = 2;\n        assert solution.numberOfChild(n_3, k_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int numberOfChild(int n, int k) {",
        "function_name": "numberOfChild",
        "difficulty_level": "Easy",
        "time": "20240609"
    },
    {
        "id": "3179",
        "prompt_base": "\"\"\"\n给你两个整数 n 和 k。\n最初，你有一个长度为 n 的整数数组 a，对所有 0 <= i <= n - 1，都有 a[i] = 1 。每过一秒，你会同时更新每个元素为其前面所有元素的和加上该元素本身。例如，一秒后，a[0] 保持不变，a[1] 变为 a[0] + a[1]，a[2] 变为 a[0] + a[1] + a[2]，以此类推。\n返回 k 秒后 a[n - 1] 的值。\n由于答案可能非常大，返回其对 10^9 + 7 取余 后的结果。\n示例 1：\n输入n = 4, k = 5\n输出：56示例 2：\n输入n = 5, k = 3\n输出：35\n\n提示：\n1 <= n, k <= 1000\n\"\"\"\n\nclass Solution {\n    public int valueAfterKSeconds(int n, int k) {",
        "prompt_chat": "给你两个整数 n 和 k。\n最初，你有一个长度为 n 的整数数组 a，对所有 0 <= i <= n - 1，都有 a[i] = 1 。每过一秒，你会同时更新每个元素为其前面所有元素的和加上该元素本身。例如，一秒后，a[0] 保持不变，a[1] 变为 a[0] + a[1]，a[2] 变为 a[0] + a[1] + a[2]，以此类推。\n返回 k 秒后 a[n - 1] 的值。\n由于答案可能非常大，返回其对 10^9 + 7 取余 后的结果。\n示例 1：\n输入n = 4, k = 5\n输出：56示例 2：\n输入n = 5, k = 3\n输出：35\n\n提示：\n1 <= n, k <= 1000\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int valueAfterKSeconds(int n, int k) {\n```",
        "solution": "class Solution {\n    private static final int MOD = 1_000_000_007;\n    private static final int MX = 2001;\n\n    // 组合数模板\n    private static final long[] FAC = new long[MX];\n    private static final long[] INV_FAC = new long[MX];\n\n    static {\n        FAC[0] = 1;\n        for (int i = 1; i < MX; i++) {\n            FAC[i] = FAC[i - 1] * i % MOD;\n        }\n        INV_FAC[MX - 1] = pow(FAC[MX - 1], MOD - 2);\n        for (int i = MX - 1; i > 0; i--) {\n            INV_FAC[i - 1] = INV_FAC[i] * i % MOD;\n        }\n    }\n\n    private static long comb(int n, int k) {\n        return FAC[n] * INV_FAC[k] % MOD * INV_FAC[n - k] % MOD;\n    }\n\n    public int valueAfterKSeconds(int n, int k) {\n        return (int) comb(n + k - 1, k);\n    }\n\n    private static long pow(long x, int n) {\n        long res = 1;\n        for (; n > 0; n /= 2) {\n            if (n % 2 > 0) {\n                res = res * x % MOD;\n            }\n            x = x * x % MOD;\n        }\n        return res;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n_1 = 4;\n        int k_1 = 5;\n        int ans_1 = 56;\n        assert solution.valueAfterKSeconds(n_1, k_1) == ans_1;\n        int n_2 = 5;\n        int k_2 = 3;\n        int ans_2 = 35;\n        assert solution.valueAfterKSeconds(n_2, k_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int valueAfterKSeconds(int n, int k) {",
        "function_name": "valueAfterKSeconds",
        "difficulty_level": "Middle",
        "time": "20240609"
    },
    {
        "id": "3180",
        "prompt_base": "\"\"\"\n给你一个整数数组 rewardValues，长度为 n，代表奖励的值。\n最初，你的总奖励 x 为 0，所有下标都是 未标记 的。你可以执行以下操作 任意次 ：\n从区间 [0, n - 1] 中选择一个 未标记 的下标 i。\n如果 rewardValues[i] 大于 你当前的总奖励 x，则将 rewardValues[i] 加到 x 上（即 x = x + rewardValues[i]），并 标记 下标 i。\n以整数形式返回执行最优操作能够获得的 最大 总奖励。\n示例 1：\n输入rewardValues = [1,1,3,3]\n输出：4示例 2：\n输入rewardValues = [1,6,4,3,2]\n输出：11\n\n提示：\n1 <= rewardValues.length <= 2000\n1 <= rewardValues[i] <= 2000\n\"\"\"\n\nclass Solution {\n    public int maxTotalReward(int[] rewardValues) {",
        "prompt_chat": "给你一个整数数组 rewardValues，长度为 n，代表奖励的值。\n最初，你的总奖励 x 为 0，所有下标都是 未标记 的。你可以执行以下操作 任意次 ：\n从区间 [0, n - 1] 中选择一个 未标记 的下标 i。\n如果 rewardValues[i] 大于 你当前的总奖励 x，则将 rewardValues[i] 加到 x 上（即 x = x + rewardValues[i]），并 标记 下标 i。\n以整数形式返回执行最优操作能够获得的 最大 总奖励。\n示例 1：\n输入rewardValues = [1,1,3,3]\n输出：4示例 2：\n输入rewardValues = [1,6,4,3,2]\n输出：11\n\n提示：\n1 <= rewardValues.length <= 2000\n1 <= rewardValues[i] <= 2000\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maxTotalReward(int[] rewardValues) {\n```",
        "solution": "class Solution {\n    public int maxTotalReward(int[] rewardValues) {\n        BigInteger f = BigInteger.ONE;\n        for (int v : Arrays.stream(rewardValues).distinct().sorted().toArray()) {\n            BigInteger mask = BigInteger.ONE.shiftLeft(v).subtract(BigInteger.ONE);\n            f = f.or(f.and(mask).shiftLeft(v));\n        }\n        return f.bitLength() - 1;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] rewardValues_1 = {1,1,3,3};\n        int ans_1 = 4;\n        assert solution.maxTotalReward(rewardValues_1) == ans_1;\n        int[] rewardValues_2 = {1,6,4,3,2};\n        int ans_2 = 11;\n        assert solution.maxTotalReward(rewardValues_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maxTotalReward(int[] rewardValues) {",
        "function_name": "maxTotalReward",
        "difficulty_level": "Middle",
        "time": "20240609"
    },
    {
        "id": "3181",
        "prompt_base": "\"\"\"\n给你一个整数数组 rewardValues，长度为 n，代表奖励的值。最初，你的总奖励 x 为 0，所有下标都是 未标记 的。你可以执行以下操作 任意次 ：\n从区间 [0, n - 1] 中选择一个 未标记 的下标 i。\n如果 rewardValues[i] 大于 你当前的总奖励 x，则将 rewardValues[i] 加到 x 上（即 x = x + rewardValues[i]），并 标记 下标 i。\n以整数形式返回执行最优操作能够获得的 最大 总奖励。\n示例 1：\n输入rewardValues = [1,1,3,3]\n输出：4示例 2：\n输入rewardValues = [1,6,4,3,2]\n输出：11\n\n提示：\n1 <= rewardValues.length <= 5 * 10^4\n1 <= rewardValues[i] <= 5 * 10^4\n\"\"\"\n\nclass Solution {\n    public int maxTotalReward(int[] rewardValues) {",
        "prompt_chat": "给你一个整数数组 rewardValues，长度为 n，代表奖励的值。最初，你的总奖励 x 为 0，所有下标都是 未标记 的。你可以执行以下操作 任意次 ：\n从区间 [0, n - 1] 中选择一个 未标记 的下标 i。\n如果 rewardValues[i] 大于 你当前的总奖励 x，则将 rewardValues[i] 加到 x 上（即 x = x + rewardValues[i]），并 标记 下标 i。\n以整数形式返回执行最优操作能够获得的 最大 总奖励。\n示例 1：\n输入rewardValues = [1,1,3,3]\n输出：4示例 2：\n输入rewardValues = [1,6,4,3,2]\n输出：11\n\n提示：\n1 <= rewardValues.length <= 5 * 10^4\n1 <= rewardValues[i] <= 5 * 10^4\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maxTotalReward(int[] rewardValues) {\n```",
        "solution": "class Solution {\n    public int maxTotalReward(int[] rewardValues) {\n        int m = 0;\n        for (int v : rewardValues) {\n            m = Math.max(m, v);\n        }\n        for (int v : rewardValues) {\n            if (v == m - 1) {\n                return m * 2 - 1;\n            }\n        }\n\n        BigInteger f = BigInteger.ONE;\n        for (int v : Arrays.stream(rewardValues).distinct().sorted().toArray()) {\n            BigInteger mask = BigInteger.ONE.shiftLeft(v).subtract(BigInteger.ONE);\n            f = f.or(f.and(mask).shiftLeft(v));\n        }\n        return f.bitLength() - 1;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] rewardValues_1 = {1,1,3,3};\n        int ans_1 = 4;\n        assert solution.maxTotalReward(rewardValues_1) == ans_1;\n        int[] rewardValues_2 = {1,6,4,3,2};\n        int ans_2 = 11;\n        assert solution.maxTotalReward(rewardValues_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maxTotalReward(int[] rewardValues) {",
        "function_name": "maxTotalReward",
        "difficulty_level": "Hard",
        "time": "20240609"
    },
    {
        "id": "3184",
        "prompt_base": "\"\"\"\n给你一个整数数组 hours，表示以 小时 为单位的时间，返回一个整数，表示满足 i < j 且 hours[i] + hours[j] 构成 整天 的下标对 i, j 的数目。\n整天 定义为时间持续时间是 24 小时的 整数倍 。\n例如，1 天是 24 小时，2 天是 48 小时，3 天是 72 小时，以此类推。\n示例 1：\n输入hours = [12,12,30,24,24]\n输出：2示例 2：\n输入hours = [72,48,24,3]\n输出：3\n\n提示：\n1 <= hours.length <= 100\n1 <= hours[i] <= 10^9\n\"\"\"\n\nclass Solution {\n    public int countCompleteDayPairs(int[] hours) {",
        "prompt_chat": "给你一个整数数组 hours，表示以 小时 为单位的时间，返回一个整数，表示满足 i < j 且 hours[i] + hours[j] 构成 整天 的下标对 i, j 的数目。\n整天 定义为时间持续时间是 24 小时的 整数倍 。\n例如，1 天是 24 小时，2 天是 48 小时，3 天是 72 小时，以此类推。\n示例 1：\n输入hours = [12,12,30,24,24]\n输出：2示例 2：\n输入hours = [72,48,24,3]\n输出：3\n\n提示：\n1 <= hours.length <= 100\n1 <= hours[i] <= 10^9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int countCompleteDayPairs(int[] hours) {\n```",
        "solution": "class Solution {\n    public long countCompleteDayPairs(int[] hours) {\n        long ans = 0;\n        int[] cnt = new int[24];\n        for (int t : hours) {\n            // 先查询 cnt，再更新 cnt，因为题目要求 i<j\n            // 如果先更新，再查询，就把 i=j 的情况也考虑进去了\n            ans += cnt[(24 - t % 24) % 24];\n            cnt[t % 24]++;\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] hours_1 = {12,12,30,24,24};\n        int ans_1 = 2;\n        assert solution.countCompleteDayPairs(hours_1) == ans_1;\n        int[] hours_2 = {72,48,24,3};\n        int ans_2 = 3;\n        assert solution.countCompleteDayPairs(hours_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int countCompleteDayPairs(int[] hours) {",
        "function_name": "countCompleteDayPairs",
        "difficulty_level": "Easy",
        "time": "20240616"
    },
    {
        "id": "3185",
        "prompt_base": "\"\"\"\n给你一个整数数组 hours，表示以 小时 为单位的时间，返回一个整数，表示满足 i < j 且 hours[i] + hours[j] 构成 整天 的下标对 i, j 的数目。\n整天 定义为时间持续时间是 24 小时的 整数倍 。\n例如，1 天是 24 小时，2 天是 48 小时，3 天是 72 小时，以此类推。\n示例 1：\n输入hours = [12,12,30,24,24]\n输出：2示例 2：\n输入hours = [72,48,24,3]\n输出：3\n\n提示：\n1 <= hours.length <= 5 * 10^5\n1 <= hours[i] <= 10^9\n\"\"\"\n\nclass Solution {\n    public long countCompleteDayPairs(int[] hours) {",
        "prompt_chat": "给你一个整数数组 hours，表示以 小时 为单位的时间，返回一个整数，表示满足 i < j 且 hours[i] + hours[j] 构成 整天 的下标对 i, j 的数目。\n整天 定义为时间持续时间是 24 小时的 整数倍 。\n例如，1 天是 24 小时，2 天是 48 小时，3 天是 72 小时，以此类推。\n示例 1：\n输入hours = [12,12,30,24,24]\n输出：2示例 2：\n输入hours = [72,48,24,3]\n输出：3\n\n提示：\n1 <= hours.length <= 5 * 10^5\n1 <= hours[i] <= 10^9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long countCompleteDayPairs(int[] hours) {\n```",
        "solution": "class Solution {\n    public long countCompleteDayPairs(int[] hours) {\n        long ans = 0;\n        int[] cnt = new int[24];\n        for (int t : hours) {\n            // 先查询 cnt，再更新 cnt，因为题目要求 i<j\n            // 如果先更新，再查询，就把 i=j 的情况也考虑进去了\n            ans += cnt[(24 - t % 24) % 24];\n            cnt[t % 24]++;\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] hours_1 = {12,12,30,24,24};\n        long ans_1 = 2;\n        assert solution.countCompleteDayPairs(hours_1) == ans_1;\n        int[] hours_2 = {72,48,24,3};\n        long ans_2 = 3;\n        assert solution.countCompleteDayPairs(hours_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long countCompleteDayPairs(int[] hours) {",
        "function_name": "countCompleteDayPairs",
        "difficulty_level": "Middle",
        "time": "20240616"
    },
    {
        "id": "3186",
        "prompt_base": "\"\"\"\n一个魔法师有许多不同的咒语。\n给你一个数组 power ，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。\n已知魔法师使用伤害值为 power[i] 的咒语时，他们就 不能 使用伤害为 power[i] - 2 ，power[i] - 1 ，power[i] + 1 或者 power[i] + 2 的咒语。\n每个咒语最多只能被使用 一次 。\n请你返回这个魔法师可以达到的伤害值之和的 最大值 。\n示例 1：\n输入power = [1,1,3,4]\n输出：6示例 2：\n输入power = [7,1,6,6]\n输出：13\n\n提示：\n1 <= power.length <= 10^5\n1 <= power[i] <= 10^9\n\"\"\"\n\nclass Solution {\n    public long maximumTotalDamage(int[] power) {",
        "prompt_chat": "一个魔法师有许多不同的咒语。\n给你一个数组 power ，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。\n已知魔法师使用伤害值为 power[i] 的咒语时，他们就 不能 使用伤害为 power[i] - 2 ，power[i] - 1 ，power[i] + 1 或者 power[i] + 2 的咒语。\n每个咒语最多只能被使用 一次 。\n请你返回这个魔法师可以达到的伤害值之和的 最大值 。\n示例 1：\n输入power = [1,1,3,4]\n输出：6示例 2：\n输入power = [7,1,6,6]\n输出：13\n\n提示：\n1 <= power.length <= 10^5\n1 <= power[i] <= 10^9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long maximumTotalDamage(int[] power) {\n```",
        "solution": "class Solution {\n    public long maximumTotalDamage(int[] power) {\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int x : power) {\n            cnt.merge(x, 1, Integer::sum);\n        }\n\n        int n = cnt.size();\n        int[] a = new int[n];\n        int k = 0;\n        for (int x : cnt.keySet()) {\n            a[k++] = x;\n        }\n        Arrays.sort(a);\n\n        long[] memo = new long[n];\n        Arrays.fill(memo, -1);\n        return dfs(a, cnt, memo, n - 1);\n    }\n\n    private long dfs(int[] a, Map<Integer, Integer> cnt, long[] memo, int i) {\n        if (i < 0) {\n            return 0;\n        }\n        if (memo[i] != -1) {\n            return memo[i];\n        }\n        int x = a[i];\n        int j = i;\n        while (j > 0 && a[j - 1] >= x - 2) {\n            j--;\n        }\n        return memo[i] = Math.max(dfs(a, cnt, memo, i - 1), dfs(a, cnt, memo, j - 1) + (long) x * cnt.get(x));\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] power_1 = {1,1,3,4};\n        long ans_1 = 6;\n        assert solution.maximumTotalDamage(power_1) == ans_1;\n        int[] power_2 = {7,1,6,6};\n        long ans_2 = 13;\n        assert solution.maximumTotalDamage(power_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long maximumTotalDamage(int[] power) {",
        "function_name": "maximumTotalDamage",
        "difficulty_level": "Middle",
        "time": "20240616"
    },
    {
        "id": "3187",
        "prompt_base": "\"\"\"\n数组 arr 中 大于 前面和后面相邻元素的元素被称为 峰值 元素。\n给你一个整数数组 nums 和一个二维整数数组 queries 。\n你需要处理以下两种类型的操作：\nqueries[i] = [1, l_i, r_i] ，求出子数组 nums[l_i..r_i] 中 峰值 元素的数目。\nqueries[i] = [2, index_i, val_i] ，将 nums[index_i] 变为 val_i 。\n请你返回一个数组 answer ，它依次包含每一个第一种操作的答案。\n注意：子数组中 第一个 和 最后一个 元素都 不是 峰值元素。\n示例 1：\n输入nums = [3,1,4,2,5], queries = [[2,3,4],[1,0,4]]\n输出：[0]示例 2：\n输入nums = [4,1,4,2,1,5], queries = [[2,2,4],[1,0,2],[1,0,4]]\n输出：[0,1]\n\n提示：\n3 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\n1 <= queries.length <= 10^5\nqueries[i][0] == 1 或者 queries[i][0] == 2\n对于所有的 i ，都有：\nqueries[i][0] == 1 ：0 <= queries[i][1] <= queries[i][2] <= nums.length - 1\nqueries[i][0] == 2 ：0 <= queries[i][1] <= nums.length - 1, 1 <= queries[i][2] <= 10^5\n\"\"\"\n\nclass Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {",
        "prompt_chat": "数组 arr 中 大于 前面和后面相邻元素的元素被称为 峰值 元素。\n给你一个整数数组 nums 和一个二维整数数组 queries 。\n你需要处理以下两种类型的操作：\nqueries[i] = [1, l_i, r_i] ，求出子数组 nums[l_i..r_i] 中 峰值 元素的数目。\nqueries[i] = [2, index_i, val_i] ，将 nums[index_i] 变为 val_i 。\n请你返回一个数组 answer ，它依次包含每一个第一种操作的答案。\n注意：子数组中 第一个 和 最后一个 元素都 不是 峰值元素。\n示例 1：\n输入nums = [3,1,4,2,5], queries = [[2,3,4],[1,0,4]]\n输出：[0]示例 2：\n输入nums = [4,1,4,2,1,5], queries = [[2,2,4],[1,0,2],[1,0,4]]\n输出：[0,1]\n\n提示：\n3 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\n1 <= queries.length <= 10^5\nqueries[i][0] == 1 或者 queries[i][0] == 2\n对于所有的 i ，都有：\nqueries[i][0] == 1 ：0 <= queries[i][1] <= queries[i][2] <= nums.length - 1\nqueries[i][0] == 2 ：0 <= queries[i][1] <= nums.length - 1, 1 <= queries[i][2] <= 10^5\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n```",
        "solution": "class Fenwick {\n    private final int[] f;\n\n    Fenwick(int n) {\n        f = new int[n];\n    }\n\n    void update(int i, int val) {\n        for (; i < f.length; i += i & -i) {\n            f[i] += val;\n        }\n    }\n\n    private int pre(int i) {\n        int res = 0;\n        for (; i > 0; i &= i - 1) {\n            res += f[i];\n        }\n        return res;\n    }\n\n    int query(int l, int r) {\n        if (r < l) {\n            return 0;\n        }\n        return pre(r) - pre(l - 1);\n    }\n}\n\nclass Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {\n        int n = nums.length;\n        Fenwick f = new Fenwick(n - 1);\n        for (int i = 1; i < n - 1; i++) {\n            update(f, nums, i, 1);\n        }\n\n        List<Integer> ans = new ArrayList<>();\n        for (int[] q : queries) {\n            if (q[0] == 1) {\n                ans.add(f.query(q[1] + 1, q[2] - 1));\n                continue;\n            }\n            int i = q[1];\n            for (int j = Math.max(i - 1, 1); j <= Math.min(i + 1, n - 2); j++) {\n                update(f, nums, j, -1);\n            }\n            nums[i] = q[2];\n            for (int j = Math.max(i - 1, 1); j <= Math.min(i + 1, n - 2); j++) {\n                update(f, nums, j, 1);\n            }\n        }\n        return ans;\n    }\n\n    private void update(Fenwick f, int[] nums, int i, int val) {\n        if (nums[i - 1] < nums[i] && nums[i] > nums[i + 1]) {\n            f.update(i, val);\n        }\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {3,1,4,2,5};\n        int[][] queries_1 = {{2,3,4},{1,0,4}};\n        List<Integer> level1_count1 = new ArrayList<>();\n        level1_count1.add(0);\n    assert solution.countOfPeaks(nums_1, queries_1).equals(level1_count1);\n        int[] nums_2 = {4,1,4,2,1,5};\n        int[][] queries_2 = {{2,2,4},{1,0,2},{1,0,4}};\n        List<Integer> level1_count2 = new ArrayList<>();\n        level1_count2.add(0);\n        level1_count2.add(1);\n    assert solution.countOfPeaks(nums_2, queries_2).equals(level1_count2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {",
        "function_name": "countOfPeaks",
        "difficulty_level": "Hard",
        "time": "20240616"
    },
    {
        "id": "3194",
        "prompt_base": "\"\"\"\n你有一个初始为空的浮点数数组 averages。另给你一个包含 n 个整数的数组 nums，其中 n 为偶数。\n你需要重复以下步骤 n / 2 次：\n从 nums 中移除 最小 的元素 minElement 和 最大 的元素 maxElement。\n将 (minElement + maxElement) / 2 加入到 averages 中。\n返回 averages 中的 最小 元素。\n示例 1：\n输入nums = [7,8,3,4,15,13,4,1]\n输出：5.5示例 2：\n输入nums = [1,9,8,3,10,5]\n输出：5.5\n\n提示：\n2 <= n == nums.length <= 50\nn 为偶数。\n1 <= nums[i] <= 50\n\"\"\"\n\nclass Solution {\n    public double minimumAverage(int[] nums) {",
        "prompt_chat": "你有一个初始为空的浮点数数组 averages。另给你一个包含 n 个整数的数组 nums，其中 n 为偶数。\n你需要重复以下步骤 n / 2 次：\n从 nums 中移除 最小 的元素 minElement 和 最大 的元素 maxElement。\n将 (minElement + maxElement) / 2 加入到 averages 中。\n返回 averages 中的 最小 元素。\n示例 1：\n输入nums = [7,8,3,4,15,13,4,1]\n输出：5.5示例 2：\n输入nums = [1,9,8,3,10,5]\n输出：5.5\n\n提示：\n2 <= n == nums.length <= 50\nn 为偶数。\n1 <= nums[i] <= 50\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public double minimumAverage(int[] nums) {\n```",
        "solution": "class Solution {\n    public double minimumAverage(int[] nums) {\n        Arrays.sort(nums);\n        int ans = Integer.MAX_VALUE;\n        int n = nums.length;\n        for (int i = 0; i < n / 2; i++) {\n            ans = Math.min(ans, nums[i] + nums[n - 1 - i]);\n        }\n        return ans / 2.0;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {7,8,3,4,15,13,4,1};\n        double ans_1 = 5.5;\n        assert solution.minimumAverage(nums_1) == ans_1;\n        int[] nums_2 = {1,9,8,3,10,5};\n        double ans_2 = 5.5;\n        assert solution.minimumAverage(nums_2) == ans_2;\n        int[] nums_3 = {1,2,3,7,8,9};\n        double ans_3 = 5.0;\n        assert solution.minimumAverage(nums_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public double minimumAverage(int[] nums) {",
        "function_name": "minimumAverage",
        "difficulty_level": "Easy",
        "time": "20240623"
    },
    {
        "id": "3195",
        "prompt_base": "\"\"\"\n给你一个二维 二进制 数组 grid。请你找出一个边在水平方向和竖直方向上、面积 最小 的矩形，并且满足 grid 中所有的 1 都在矩形的内部。\n返回这个矩形可能的 最小 面积。\n示例 1：\n输入grid = [[0,1,0],[1,0,1]]\n输出：6示例 2：\n输入grid = [[0,0],[1,0]]\n输出：1\n\n提示：\n1 <= grid.length, grid[i].length <= 1000\ngrid[i][j] 是 0 或 1。\n输入保证 grid 中至少有一个 1 。\n\"\"\"\n\nclass Solution {\n    public int minimumArea(int[][] grid) {",
        "prompt_chat": "给你一个二维 二进制 数组 grid。请你找出一个边在水平方向和竖直方向上、面积 最小 的矩形，并且满足 grid 中所有的 1 都在矩形的内部。\n返回这个矩形可能的 最小 面积。\n示例 1：\n输入grid = [[0,1,0],[1,0,1]]\n输出：6示例 2：\n输入grid = [[0,0],[1,0]]\n输出：1\n\n提示：\n1 <= grid.length, grid[i].length <= 1000\ngrid[i][j] 是 0 或 1。\n输入保证 grid 中至少有一个 1 。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumArea(int[][] grid) {\n```",
        "solution": "class Solution {\n    public int minimumArea(int[][] grid) {\n        int left = grid[0].length;\n        int right = 0;\n        int top = grid.length;\n        int bottom = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[i].length; j++) {\n                if (grid[i][j] == 1) {\n                    left = Math.min(left, j);\n                    right = Math.max(right, j);\n                    top = Math.min(top, i);\n                    bottom = i;\n                }\n            }\n        }\n        return (right - left + 1) * (bottom - top + 1);\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] grid_1 = {{0,1,0},{1,0,1}};\n        int ans_1 = 6;\n        assert solution.minimumArea(grid_1) == ans_1;\n        int[][] grid_2 = {{0,0},{1,0}};\n        int ans_2 = 1;\n        assert solution.minimumArea(grid_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumArea(int[][] grid) {",
        "function_name": "minimumArea",
        "difficulty_level": "Middle",
        "time": "20240623"
    },
    {
        "id": "3196",
        "prompt_base": "\"\"\"\n给你一个长度为 n 的整数数组 nums。子数组 nums[l..r]（其中 0 <= l <= r < n）的 成本 定义为：cost(l, r) = nums[l] - nums[l + 1] + ... + nums[r] * (−1)^{r − l}\n你的任务是将 nums 分割成若干子数组，使得所有子数组的成本之和 最大化，并确保每个元素 正好 属于一个子数组。\n具体来说，如果 nums 被分割成 k 个子数组，且分割点为索引 i_1, i_2, ..., i_{k − 1}（其中 0 <= i_1 < i_2 < ... < i_{k - 1} < n - 1），则总成本为：\ncost(0, i_1) + cost(i_1 + 1, i_2) + ... + cost(i_{k − 1} + 1, n − 1)\n返回在最优分割方式下的子数组成本之和的最大值。\n注意：如果 nums 没有被分割，即 k = 1，则总成本即为 cost(0, n - 1)。\n示例 1：\n输入nums = [1,-2,3,4]\n输出：10示例 2：\n输入nums = [1,-1,1,-1]\n输出：4\n\n提示：\n1 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9\n\"\"\"\n\nclass Solution {\n    public long maximumTotalCost(int[] nums) {",
        "prompt_chat": "给你一个长度为 n 的整数数组 nums。子数组 nums[l..r]（其中 0 <= l <= r < n）的 成本 定义为：cost(l, r) = nums[l] - nums[l + 1] + ... + nums[r] * (−1)^{r − l}\n你的任务是将 nums 分割成若干子数组，使得所有子数组的成本之和 最大化，并确保每个元素 正好 属于一个子数组。\n具体来说，如果 nums 被分割成 k 个子数组，且分割点为索引 i_1, i_2, ..., i_{k − 1}（其中 0 <= i_1 < i_2 < ... < i_{k - 1} < n - 1），则总成本为：\ncost(0, i_1) + cost(i_1 + 1, i_2) + ... + cost(i_{k − 1} + 1, n − 1)\n返回在最优分割方式下的子数组成本之和的最大值。\n注意：如果 nums 没有被分割，即 k = 1，则总成本即为 cost(0, n - 1)。\n示例 1：\n输入nums = [1,-2,3,4]\n输出：10示例 2：\n输入nums = [1,-1,1,-1]\n输出：4\n\n提示：\n1 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long maximumTotalCost(int[] nums) {\n```",
        "solution": "class Solution {\n    public long maximumTotalCost(int[] a) {\n        int n = a.length;\n        long[] memo = new long[n];\n        Arrays.fill(memo, Long.MIN_VALUE); // Long.MIN_VALUE 表示没有计算过\n        return dfs(n - 1, a, memo);\n    }\n\n    private long dfs(int i, int[] a, long[] memo) {\n        if (i < 0) {\n            return 0;\n        }\n        if (i == 0) {\n            return a[0];\n        }\n        if (memo[i] != Long.MIN_VALUE) { // 之前计算过\n            return memo[i];\n        }\n        return memo[i] = Math.max(dfs(i - 1, a, memo) + a[i], dfs(i - 2, a, memo) + a[i - 1] - a[i]);\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,-2,3,4};\n        long ans_1 = 10;\n        assert solution.maximumTotalCost(nums_1) == ans_1;\n        int[] nums_2 = {1,-1,1,-1};\n        long ans_2 = 4;\n        assert solution.maximumTotalCost(nums_2) == ans_2;\n        int[] nums_3 = {0};\n        long ans_3 = 0;\n        assert solution.maximumTotalCost(nums_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long maximumTotalCost(int[] nums) {",
        "function_name": "maximumTotalCost",
        "difficulty_level": "Middle",
        "time": "20240623"
    },
    {
        "id": "3197",
        "prompt_base": "\"\"\"\n给你一个二维 二进制 数组 grid。你需要找到 3 个 不重叠、面积 非零 、边在水平方向和竖直方向上的矩形，并且满足 grid 中所有的 1 都在这些矩形的内部。\n返回这些矩形面积之和的 最小 可能值。\n注意，这些矩形可以相接。\n示例 1：\n输入grid = [[1,0,1],[1,1,1]]\n输出：5示例 2：\n输入grid = [[1,0,1,0],[0,1,0,1]]\n输出：5\n\n提示：\n1 <= grid.length, grid[i].length <= 30\ngrid[i][j] 是 0 或 1。\n输入保证 grid 中至少有三个 1 。\n\"\"\"\n\nclass Solution {\n    public int minimumSum(int[][] grid) {",
        "prompt_chat": "给你一个二维 二进制 数组 grid。你需要找到 3 个 不重叠、面积 非零 、边在水平方向和竖直方向上的矩形，并且满足 grid 中所有的 1 都在这些矩形的内部。\n返回这些矩形面积之和的 最小 可能值。\n注意，这些矩形可以相接。\n示例 1：\n输入grid = [[1,0,1],[1,1,1]]\n输出：5示例 2：\n输入grid = [[1,0,1,0],[0,1,0,1]]\n输出：5\n\n提示：\n1 <= grid.length, grid[i].length <= 30\ngrid[i][j] 是 0 或 1。\n输入保证 grid 中至少有三个 1 。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumSum(int[][] grid) {\n```",
        "solution": "class Solution {\n    public int minimumSum(int[][] grid) {\n        return Math.min(f(grid), f(rotate(grid)));\n    }\n\n    private int f(int[][] a) {\n        int ans = Integer.MAX_VALUE;\n        int m = a.length;\n        int n = a[0].length;\n        if (m >= 3) {\n            for (int i = 1; i < m; i++) {\n                for (int j = i + 1; j < m; j++) {\n                    // 图片上左\n                    int area = minimumArea(a, 0, i, 0, n);\n                    area += minimumArea(a, i, j, 0, n);\n                    area += minimumArea(a, j, m, 0, n);\n                    ans = Math.min(ans, area);\n                }\n            }\n        }\n        if (m >= 2 && n >= 2) {\n            for (int i = 1; i < m; i++) {\n                for (int j = 1; j < n; j++) {\n                    // 图片上中\n                    int area = minimumArea(a, 0, i, 0, n);\n                    area += minimumArea(a, i, m, 0, j);\n                    area += minimumArea(a, i, m, j, n);\n                    ans = Math.min(ans, area);\n                    // 图片上右\n                    area = minimumArea(a, 0, i, 0, j);\n                    area += minimumArea(a, 0, i, j, n);\n                    area += minimumArea(a, i, m, 0, n);\n                    ans = Math.min(ans, area);\n                }\n            }\n        }\n        return ans;\n    }\n\n    private int minimumArea(int[][] a, int u, int d, int l, int r) {\n        int left = a[0].length;\n        int right = 0;\n        int top = a.length;\n        int bottom = 0;\n        for (int i = u; i < d; i++) {\n            for (int j = l; j < r; j++) {\n                if (a[i][j] == 1) {\n                    left = Math.min(left, j);\n                    right = Math.max(right, j);\n                    top = Math.min(top, i);\n                    bottom = i;\n                }\n            }\n        }\n        return (right - left + 1) * (bottom - top + 1);\n    }\n\n    // 顺时针旋转矩阵 90°\n    private int[][] rotate(int[][] a) {\n        int m = a.length;\n        int n = a[0].length;\n        int[][] b = new int[n][m];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                b[j][m - 1 - i] = a[i][j];\n            }\n        }\n        return b;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] grid_1 = {{1,0,1},{1,1,1}};\n        int ans_1 = 5;\n        assert solution.minimumSum(grid_1) == ans_1;\n        int[][] grid_2 = {{1,0,1,0},{0,1,0,1}};\n        int ans_2 = 5;\n        assert solution.minimumSum(grid_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumSum(int[][] grid) {",
        "function_name": "minimumSum",
        "difficulty_level": "Hard",
        "time": "20240623"
    },
    {
        "id": "3200",
        "prompt_base": "\"\"\"\n给你两个整数 red 和 blue，分别表示红色球和蓝色球的数量。你需要使用这些球来组成一个三角形，满足第 1 行有 1 个球，第 2 行有 2 个球，第 3 行有 3 个球，依此类推。\n每一行的球必须是 相同 颜色，且相邻行的颜色必须 不同。\n返回可以实现的三角形的 最大 高度。\n示例 1：\n输入red = 2, blue = 4\n输出：3示例 2：\n输入red = 2, blue = 1\n输出：2\n\n提示：\n1 <= red, blue <= 100\n\"\"\"\n\nclass Solution {\n    public int maxHeightOfTriangle(int red, int blue) {",
        "prompt_chat": "给你两个整数 red 和 blue，分别表示红色球和蓝色球的数量。你需要使用这些球来组成一个三角形，满足第 1 行有 1 个球，第 2 行有 2 个球，第 3 行有 3 个球，依此类推。\n每一行的球必须是 相同 颜色，且相邻行的颜色必须 不同。\n返回可以实现的三角形的 最大 高度。\n示例 1：\n输入red = 2, blue = 4\n输出：3示例 2：\n输入red = 2, blue = 1\n输出：2\n\n提示：\n1 <= red, blue <= 100\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maxHeightOfTriangle(int red, int blue) {\n```",
        "solution": "class Solution {\n    public int maxHeightOfTriangle(int red, int blue) {\n        int[] cnt = new int[2];\n        for (int i = 1; ; i++) {\n            cnt[i % 2] += i;\n            if ((cnt[0] > red || cnt[1] > blue) && (cnt[0] > blue || cnt[1] > red)) {\n                return i - 1;\n            }\n        }\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int red_1 = 2;\n        int blue_1 = 4;\n        int ans_1 = 3;\n        assert solution.maxHeightOfTriangle(red_1, blue_1) == ans_1;\n        int red_2 = 2;\n        int blue_2 = 1;\n        int ans_2 = 2;\n        assert solution.maxHeightOfTriangle(red_2, blue_2) == ans_2;\n        int red_3 = 1;\n        int blue_3 = 1;\n        int ans_3 = 1;\n        assert solution.maxHeightOfTriangle(red_3, blue_3) == ans_3;\n        int red_4 = 10;\n        int blue_4 = 1;\n        int ans_4 = 2;\n        assert solution.maxHeightOfTriangle(red_4, blue_4) == ans_4;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maxHeightOfTriangle(int red, int blue) {",
        "function_name": "maxHeightOfTriangle",
        "difficulty_level": "Easy",
        "time": "20240630"
    },
    {
        "id": "3201",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums。nums 的子序列 sub 的长度为 x ，如果其满足以下条件，则称其为 有效子序列：\n(sub[0] + sub[1]) % 2 == (sub[1] + sub[2]) % 2 == ... == (sub[x - 2] + sub[x - 1]) % 2\n返回 nums 的 最长的有效子序列 的长度。\n一个 子序列 指的是从原数组中删除一些元素（也可以不删除任何元素），剩余元素保持原来顺序组成的新数组。\n示例 1：\n输入nums = [1,2,3,4]\n输出：4示例 2：\n输入nums = [1,2,1,1,2,1,2]\n输出：6\n\n提示：\n2 <= nums.length <= 2 * 10^5\n1 <= nums[i] <= 10^7\n\"\"\"\n\nclass Solution {\n    public int maximumLength(int[] nums) {",
        "prompt_chat": "给你一个整数数组 nums。nums 的子序列 sub 的长度为 x ，如果其满足以下条件，则称其为 有效子序列：\n(sub[0] + sub[1]) % 2 == (sub[1] + sub[2]) % 2 == ... == (sub[x - 2] + sub[x - 1]) % 2\n返回 nums 的 最长的有效子序列 的长度。\n一个 子序列 指的是从原数组中删除一些元素（也可以不删除任何元素），剩余元素保持原来顺序组成的新数组。\n示例 1：\n输入nums = [1,2,3,4]\n输出：4示例 2：\n输入nums = [1,2,1,1,2,1,2]\n输出：6\n\n提示：\n2 <= nums.length <= 2 * 10^5\n1 <= nums[i] <= 10^7\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maximumLength(int[] nums) {\n```",
        "solution": "class Solution {\n    public int maximumLength(int[] nums) {\n        int k = 2;\n        int ans = 0;\n        int[][] f = new int[k][k];\n        for (int x : nums) {\n            x %= k;\n            for (int y = 0; y < k; y++) {\n                f[y][x] = f[x][y] + 1;\n                ans = Math.max(ans, f[y][x]);\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,3,4};\n        int ans_1 = 4;\n        assert solution.maximumLength(nums_1) == ans_1;\n        int[] nums_2 = {1,2,1,1,2,1,2};\n        int ans_2 = 6;\n        assert solution.maximumLength(nums_2) == ans_2;\n        int[] nums_3 = {1,3};\n        int ans_3 = 2;\n        assert solution.maximumLength(nums_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maximumLength(int[] nums) {",
        "function_name": "maximumLength",
        "difficulty_level": "Middle",
        "time": "20240630"
    },
    {
        "id": "3202",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 和一个 正 整数 k 。nums 的一个 子序列 sub 的长度为 x ，如果其满足以下条件，则称其为 有效子序列 ：\n(sub[0] + sub[1]) % k == (sub[1] + sub[2]) % k == ... == (sub[x - 2] + sub[x - 1]) % k\n返回 nums 的 最长有效子序列 的长度。\n示例 1：\n输入nums = [1,2,3,4,5], k = 2\n输出：5示例 2：\n输入nums = [1,4,2,3,1,4], k = 3\n输出：4\n\n提示：\n2 <= nums.length <= 10^3\n1 <= nums[i] <= 10^7\n1 <= k <= 10^3\n\"\"\"\n\nclass Solution {\n    public int maximumLength(int[] nums, int k) {",
        "prompt_chat": "给你一个整数数组 nums 和一个 正 整数 k 。nums 的一个 子序列 sub 的长度为 x ，如果其满足以下条件，则称其为 有效子序列 ：\n(sub[0] + sub[1]) % k == (sub[1] + sub[2]) % k == ... == (sub[x - 2] + sub[x - 1]) % k\n返回 nums 的 最长有效子序列 的长度。\n示例 1：\n输入nums = [1,2,3,4,5], k = 2\n输出：5示例 2：\n输入nums = [1,4,2,3,1,4], k = 3\n输出：4\n\n提示：\n2 <= nums.length <= 10^3\n1 <= nums[i] <= 10^7\n1 <= k <= 10^3\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maximumLength(int[] nums, int k) {\n```",
        "solution": "class Solution {\n    public int maximumLength(int[] nums, int k) {\n        int ans = 0;\n        for (int m = 0; m < k; m++) {\n            int[] f = new int[k];\n            for (int x : nums) {\n                x %= k;\n                f[x] = f[(m - x + k) % k] + 1;\n                ans = Math.max(ans, f[x]);\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,3,4,5};\n        int k_1 = 2;\n        int ans_1 = 5;\n        assert solution.maximumLength(nums_1, k_1) == ans_1;\n        int[] nums_2 = {1,4,2,3,1,4};\n        int k_2 = 3;\n        int ans_2 = 4;\n        assert solution.maximumLength(nums_2, k_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maximumLength(int[] nums, int k) {",
        "function_name": "maximumLength",
        "difficulty_level": "Middle",
        "time": "20240630"
    },
    {
        "id": "3203",
        "prompt_base": "\"\"\"\n给你两棵 无向 树，分别有 n 和 m 个节点，节点编号分别为 0 到 n - 1 和 0 到 m - 1 。给你两个二维整数数组 edges1 和 edges2 ，长度分别为 n - 1 和 m - 1 ，其中 edges1[i] = [a_i, b_i] 表示在第一棵树中节点 a_i 和 b_i 之间有一条边，edges2[i] = [u_i, v_i] 表示在第二棵树中节点 u_i 和 v_i 之间有一条边。\n你必须在第一棵树和第二棵树中分别选一个节点，并用一条边连接它们。\n请你返回添加边后得到的树中，最小直径 为多少。\n一棵树的 直径 指的是树中任意两个节点之间的最长路径长度。\n示例 1：\n输入edges1 = [[0,1],[0,2],[0,3]], edges2 = [[0,1]]\n输出：3示例 2：\n输入edges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]\n输出：5\n\n提示：\n1 <= n, m <= 10^5\nedges1.length == n - 1\nedges2.length == m - 1\nedges1[i].length == edges2[i].length == 2\nedges1[i] = [a_i, b_i]\n0 <= a_i, b_i < n\nedges2[i] = [u_i, v_i]\n0 <= u_i, v_i < m\n输入保证 edges1 和 edges2 分别表示一棵合法的树。\n\"\"\"\n\nclass Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {",
        "prompt_chat": "给你两棵 无向 树，分别有 n 和 m 个节点，节点编号分别为 0 到 n - 1 和 0 到 m - 1 。给你两个二维整数数组 edges1 和 edges2 ，长度分别为 n - 1 和 m - 1 ，其中 edges1[i] = [a_i, b_i] 表示在第一棵树中节点 a_i 和 b_i 之间有一条边，edges2[i] = [u_i, v_i] 表示在第二棵树中节点 u_i 和 v_i 之间有一条边。\n你必须在第一棵树和第二棵树中分别选一个节点，并用一条边连接它们。\n请你返回添加边后得到的树中，最小直径 为多少。\n一棵树的 直径 指的是树中任意两个节点之间的最长路径长度。\n示例 1：\n输入edges1 = [[0,1],[0,2],[0,3]], edges2 = [[0,1]]\n输出：3示例 2：\n输入edges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]\n输出：5\n\n提示：\n1 <= n, m <= 10^5\nedges1.length == n - 1\nedges2.length == m - 1\nedges1[i].length == edges2[i].length == 2\nedges1[i] = [a_i, b_i]\n0 <= a_i, b_i < n\nedges2[i] = [u_i, v_i]\n0 <= u_i, v_i < m\n输入保证 edges1 和 edges2 分别表示一棵合法的树。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n```",
        "solution": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        int d1 = diameter(edges1);\n        int d2 = diameter(edges2);\n        return Math.max(Math.max(d1, d2), (d1 + 1) / 2 + (d2 + 1) / 2 + 1);\n    }\n\n    private int res;\n\n    private int diameter(int[][] edges) {\n        List<Integer>[] g = new ArrayList[edges.length + 1];\n        Arrays.setAll(g, i -> new ArrayList<>());\n        for (int[] e : edges) {\n            int x = e[0];\n            int y = e[1];\n            g[x].add(y);\n            g[y].add(x);\n        }\n\n        res = 0;\n        dfs(0, -1, g);\n        return res;\n    }\n\n    private int dfs(int x, int fa, List<Integer>[] g) {\n        int maxLen = 0;\n        for (int y : g[x]) {\n            if (y != fa) {\n                int subLen = dfs(y, x, g) + 1;\n                res = Math.max(res, maxLen + subLen);\n                maxLen = Math.max(maxLen, subLen);\n            }\n        }\n        return maxLen;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] edges1_1 = {{0,1},{0,2},{0,3}};\n        int[][] edges2_1 = {{0,1}};\n        int ans_1 = 3;\n        assert solution.minimumDiameterAfterMerge(edges1_1, edges2_1) == ans_1;\n        int[][] edges1_2 = {{0,1},{0,2},{0,3},{2,4},{2,5},{3,6},{2,7}};\n        int[][] edges2_2 = {{0,1},{0,2},{0,3},{2,4},{2,5},{3,6},{2,7}};\n        int ans_2 = 5;\n        assert solution.minimumDiameterAfterMerge(edges1_2, edges2_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {",
        "function_name": "minimumDiameterAfterMerge",
        "difficulty_level": "Hard",
        "time": "20240630"
    },
    {
        "id": "3210",
        "prompt_base": "\"\"\"\n给你一个字符串 s 和一个整数 k。请你使用以下算法加密字符串：\n对于字符串 s 中的每个字符 c，用字符串中 c 后面的第 k 个字符替换 c（以循环方式）。\n返回加密后的字符串。\n示例 1：\n输入s = \"dart\", k = 3\n输出：\"tdar\"示例 2：\n输入s = \"aaa\", k = 1\n输出：\"aaa\"\n\n提示：\n1 <= s.length <= 100\n1 <= k <= 10^4\ns 仅由小写英文字母组成。\n\"\"\"\n\nclass Solution {\n    public String getEncryptedString(String s, int k) {",
        "prompt_chat": "给你一个字符串 s 和一个整数 k。请你使用以下算法加密字符串：\n对于字符串 s 中的每个字符 c，用字符串中 c 后面的第 k 个字符替换 c（以循环方式）。\n返回加密后的字符串。\n示例 1：\n输入s = \"dart\", k = 3\n输出：\"tdar\"示例 2：\n输入s = \"aaa\", k = 1\n输出：\"aaa\"\n\n提示：\n1 <= s.length <= 100\n1 <= k <= 10^4\ns 仅由小写英文字母组成。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public String getEncryptedString(String s, int k) {\n```",
        "solution": "class Solution {\n    public String getEncryptedString(String s, int k) {\n        k %= s.length();\n        return s.substring(k) + s.substring(0, k);\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s_1 = \"dart\";\n        int k_1 = 3;\n        String ans_1 = \"tdar\";\n    assert solution.getEncryptedString(s_1, k_1).equals(ans_1);\n        String s_2 = \"aaa\";\n        int k_2 = 1;\n        String ans_2 = \"aaa\";\n    assert solution.getEncryptedString(s_2, k_2).equals(ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public String getEncryptedString(String s, int k) {",
        "function_name": "getEncryptedString",
        "difficulty_level": "Easy",
        "time": "20240707"
    },
    {
        "id": "3211",
        "prompt_base": "\"\"\"\n给你一个正整数 n。如果一个二进制字符串 x 的所有长度为 2 的子字符串中包含 至少 一个 \\\"1\\\"，则称 x 是一个 有效 字符串。\n返回所有长度为 n 的 有效 字符串，可以以任意顺序排列。\n示例 1：\n输入n = 3\n输出：[\"010\",\"011\",\"101\",\"110\",\"111\"]示例 2：\n输入n = 1\n输出：[\"0\",\"1\"]\n\n提示：\n1 <= n <= 18\n\"\"\"\n\nclass Solution {\n    public List<String> validStrings(int n) {",
        "prompt_chat": "给你一个正整数 n。如果一个二进制字符串 x 的所有长度为 2 的子字符串中包含 至少 一个 \\\"1\\\"，则称 x 是一个 有效 字符串。\n返回所有长度为 n 的 有效 字符串，可以以任意顺序排列。\n示例 1：\n输入n = 3\n输出：[\"010\",\"011\",\"101\",\"110\",\"111\"]示例 2：\n输入n = 1\n输出：[\"0\",\"1\"]\n\n提示：\n1 <= n <= 18\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public List<String> validStrings(int n) {\n```",
        "solution": "class Solution {\n    public List<String> validStrings(int n) {\n        List<String> ans = new ArrayList<>();\n        int mask = (1 << n) - 1;\n        for (int i = 0; i < (1 << n); i++) {\n            int x = mask ^ i;\n            if (((x >> 1) & x) == 0) {\n                ans.add(Integer.toBinaryString((1 << n) | i).substring(1));\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n_1 = 3;\n        List<String> level1_count1 = new ArrayList<>();\n        level1_count1.add(\"010\");\n        level1_count1.add(\"011\");\n        level1_count1.add(\"101\");\n        level1_count1.add(\"110\");\n        level1_count1.add(\"111\");\n    assert solution.validStrings(n_1).equals(level1_count1);\n        int n_2 = 1;\n        List<String> level1_count2 = new ArrayList<>();\n        level1_count2.add(\"0\");\n        level1_count2.add(\"1\");\n    assert solution.validStrings(n_2).equals(level1_count2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public List<String> validStrings(int n) {",
        "function_name": "validStrings",
        "difficulty_level": "Middle",
        "time": "20240707"
    },
    {
        "id": "3212",
        "prompt_base": "\"\"\"\n给你一个二维字符矩阵 grid，其中 grid[i][j] 可能是 'X'、'Y' 或 '.'，返回满足以下条件的\n子矩阵\n数量：\n包含 grid[0][0]\n'X' 和 'Y' 的频数相等。\n至少包含一个 'X'。\n示例 1：\n输入grid = [[\"X\",\"Y\",\".\"],[\"Y\",\".\",\".\"]]\n输出：3示例 2：\n输入grid = [[\"X\",\"X\"],[\"X\",\"Y\"]]\n输出：0\n\n提示：\n1 <= grid.length, grid[i].length <= 1000\ngrid[i][j] 可能是 'X'、'Y' 或 '.'.\n\"\"\"\n\nclass Solution {\n    public int numberOfSubmatrices(char[][] grid) {",
        "prompt_chat": "给你一个二维字符矩阵 grid，其中 grid[i][j] 可能是 'X'、'Y' 或 '.'，返回满足以下条件的\n子矩阵\n数量：\n包含 grid[0][0]\n'X' 和 'Y' 的频数相等。\n至少包含一个 'X'。\n示例 1：\n输入grid = [[\"X\",\"Y\",\".\"],[\"Y\",\".\",\".\"]]\n输出：3示例 2：\n输入grid = [[\"X\",\"X\"],[\"X\",\"Y\"]]\n输出：0\n\n提示：\n1 <= grid.length, grid[i].length <= 1000\ngrid[i][j] 可能是 'X'、'Y' 或 '.'.\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int numberOfSubmatrices(char[][] grid) {\n```",
        "solution": "class Solution {\n    public int numberOfSubmatrices(char[][] grid) {\n        int ans = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][][] sum = new int[m + 1][n + 1][2];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1][0] = sum[i + 1][j][0] + sum[i][j + 1][0] - sum[i][j][0];\n                sum[i + 1][j + 1][1] = sum[i + 1][j][1] + sum[i][j + 1][1] - sum[i][j][1];\n                if (grid[i][j] != '.') {\n                    sum[i + 1][j + 1][grid[i][j] & 1]++;\n                }\n                if (sum[i + 1][j + 1][0] > 0 && sum[i + 1][j + 1][0] == sum[i + 1][j + 1][1]) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        char[][] grid_1 = {{'X','Y','.'},{'Y','.','.'}};\n        int ans_1 = 3;\n        assert solution.numberOfSubmatrices(grid_1) == ans_1;\n        char[][] grid_2 = {{'X','X'},{'X','Y'}};\n        int ans_2 = 0;\n        assert solution.numberOfSubmatrices(grid_2) == ans_2;\n        char[][] grid_3 = {{'.','.'},{'.','.'}};\n        int ans_3 = 0;\n        assert solution.numberOfSubmatrices(grid_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int numberOfSubmatrices(char[][] grid) {",
        "function_name": "numberOfSubmatrices",
        "difficulty_level": "Middle",
        "time": "20240707"
    },
    {
        "id": "3213",
        "prompt_base": "\"\"\"\n给你一个字符串 target、一个字符串数组 words 以及一个整数数组 costs，这两个数组长度相同。设想一个空字符串 s。你可以执行以下操作任意次数（包括零次）：\n选择一个在范围  [0, words.length - 1] 的索引 i。\n将 words[i] 追加到 s。\n该操作的成本是 costs[i]。\n返回使 s 等于 target 的 最小 成本。如果不可能，返回 -1。\n示例 1：\n输入target = \"abcdef\", words = [\"abdef\",\"abc\",\"d\",\"def\",\"ef\"], costs = [100,1,1,10,5]\n输出：7示例 2：\n输入target = \"aaaa\", words = [\"z\",\"zz\",\"zzz\"], costs = [1,10,100]\n输出：-1\n\n提示：\n1 <= target.length <= 5 * 10^4\n1 <= words.length == costs.length <= 5 * 10^4\n1 <= words[i].length <= target.length\n所有 words[i].length 的总和小于或等于 5 * 10^4\ntarget 和 words[i] 仅由小写英文字母组成。\n1 <= costs[i] <= 10^4\n\"\"\"\n\nclass Solution {\n    public int minimumCost(String target, String[] words, int[] costs) {",
        "prompt_chat": "给你一个字符串 target、一个字符串数组 words 以及一个整数数组 costs，这两个数组长度相同。设想一个空字符串 s。你可以执行以下操作任意次数（包括零次）：\n选择一个在范围  [0, words.length - 1] 的索引 i。\n将 words[i] 追加到 s。\n该操作的成本是 costs[i]。\n返回使 s 等于 target 的 最小 成本。如果不可能，返回 -1。\n示例 1：\n输入target = \"abcdef\", words = [\"abdef\",\"abc\",\"d\",\"def\",\"ef\"], costs = [100,1,1,10,5]\n输出：7示例 2：\n输入target = \"aaaa\", words = [\"z\",\"zz\",\"zzz\"], costs = [1,10,100]\n输出：-1\n\n提示：\n1 <= target.length <= 5 * 10^4\n1 <= words.length == costs.length <= 5 * 10^4\n1 <= words[i].length <= target.length\n所有 words[i].length 的总和小于或等于 5 * 10^4\ntarget 和 words[i] 仅由小写英文字母组成。\n1 <= costs[i] <= 10^4\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumCost(String target, String[] words, int[] costs) {\n```",
        "solution": "class Solution {\n    private static final int INF = (int) 1e9;\n\n    public int minimumCost(String target, String[] words, int[] costs) {\n        int n = target.length();\n        int m = words.length;\n\n        Node root = new Node(0);\n        for (int i = 0; i < m; i++) {\n            Node cur = root;\n            for (char c : words[i].toCharArray()) {\n                if (cur.next[c - 'a'] == null) {\n                    cur.next[c - 'a'] = new Node(cur.len + 1);\n                }\n                cur = cur.next[c - 'a'];\n            }\n            cur.len = words[i].length();\n            cur.cost = Math.min(cur.cost, costs[i]);\n        }\n        Queue<Node> q = new ArrayDeque<>();\n        for (int i = 0; i < 26; i++) {\n            if (root.next[i] == null) {\n                root.next[i] = root;\n            } else {\n                root.next[i].fail = root;\n                root.next[i].sup_fail = root;\n                q.add(root.next[i]);\n            }\n        }\n        for (; !q.isEmpty(); q.remove()) {\n            Node u = q.peek();\n            for (int i = 0; i < 26; i++) {\n                if (u.next[i] == null) {\n                    u.next[i] = u.fail.next[i];\n                } else {\n                    u.next[i].fail = u.fail.next[i];\n                    if (u.next[i].fail.cost == INF) {\n                        u.next[i].sup_fail = u.next[i].fail.sup_fail;\n                    } else {\n                        u.next[i].sup_fail = u.next[i].fail;\n                    }\n                    q.add(u.next[i]);\n                }\n            }\n        }\n\n        int[] dp = new int[n + 1];\n        Node cur = root;\n        for (int i = 0; i < n; i++) {\n            cur = cur.next[target.charAt(i) - 'a'];\n            int min_cost = INF;\n            for (Node j = cur; j != null; j = j.sup_fail) {\n                min_cost = Math.min(min_cost, dp[i + 1 - j.len] + j.cost);\n            }\n            dp[i + 1] = min_cost;\n        }\n        return dp[n] < INF ? dp[n] : -1;\n    }\n\n    static class Node {\n        int len, cost;\n        Node fail, sup_fail;\n        Node[] next;\n\n        public Node(int len) {\n            this.len = len;\n            cost = INF;\n            next = new Node[26];\n        }\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String target_1 = \"abcdef\";\n        String[] words_1 = {\"abdef\",\"abc\",\"d\",\"def\",\"ef\"};\n        int[] costs_1 = {100,1,1,10,5};\n        int ans_1 = 7;\n        assert solution.minimumCost(target_1, words_1, costs_1) == ans_1;\n        String target_2 = \"aaaa\";\n        String[] words_2 = {\"z\",\"zz\",\"zzz\"};\n        int[] costs_2 = {1,10,100};\n        int ans_2 = -1;\n        assert solution.minimumCost(target_2, words_2, costs_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumCost(String target, String[] words, int[] costs) {",
        "function_name": "minimumCost",
        "difficulty_level": "Hard",
        "time": "20240707"
    },
    {
        "id": "3216",
        "prompt_base": "\"\"\"\n给你一个仅由数字组成的字符串 s，在最多交换一次 相邻 且具有相同 奇偶性 的数字后，返回可以得到的字典序最小的字符串。\n如果两个数字都是奇数或都是偶数，则它们具有相同的奇偶性。例如，5 和 9、2 和 4 奇偶性相同，而 6 和 9 奇偶性不同。\n示例 1：\n输入s = \"45320\"\n输出：\"43520\"示例 2：\n输入s = \"001\"\n输出：\"001\"\n\n提示：\n2 <= s.length <= 100\ns 仅由数字组成。\n\"\"\"\n\nclass Solution {\n    public String getSmallestString(String s) {",
        "prompt_chat": "给你一个仅由数字组成的字符串 s，在最多交换一次 相邻 且具有相同 奇偶性 的数字后，返回可以得到的字典序最小的字符串。\n如果两个数字都是奇数或都是偶数，则它们具有相同的奇偶性。例如，5 和 9、2 和 4 奇偶性相同，而 6 和 9 奇偶性不同。\n示例 1：\n输入s = \"45320\"\n输出：\"43520\"示例 2：\n输入s = \"001\"\n输出：\"001\"\n\n提示：\n2 <= s.length <= 100\ns 仅由数字组成。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public String getSmallestString(String s) {\n```",
        "solution": "class Solution {\n    public String getSmallestString(String s) {\n        char[] t = s.toCharArray();\n        for (int i = 1; i < t.length; i++) {\n            char x = t[i - 1];\n            char y = t[i];\n            if (x > y && x % 2 == y % 2) {\n                t[i - 1] = y;\n                t[i] = x;\n                break;\n            }\n        }\n        return new String(t);\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s_1 = \"45320\";\n        String ans_1 = \"43520\";\n    assert solution.getSmallestString(s_1).equals(ans_1);\n        String s_2 = \"001\";\n        String ans_2 = \"001\";\n    assert solution.getSmallestString(s_2).equals(ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public String getSmallestString(String s) {",
        "function_name": "getSmallestString",
        "difficulty_level": "Easy",
        "time": "20240714"
    },
    {
        "id": "3217",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 和一个链表的头节点 head。从链表中移除所有存在于 nums 中的节点后，返回修改后的链表的头节点。\n示例 1：\n输入nums = [1,2,3], head = [1,2,3,4,5]\n输出：[4,5]示例 2：\n输入nums = [1], head = [1,2,1,2,1,2]\n输出：[2,2,2]\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\nnums 中的所有元素都是唯一的。\n链表中的节点数在 [1, 10^5] 的范围内。\n1 <= Node.val <= 10^5\n输入保证链表中至少有一个值没有在 nums 中出现过。\n\"\"\"\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {",
        "prompt_chat": "给你一个整数数组 nums 和一个链表的头节点 head。从链表中移除所有存在于 nums 中的节点后，返回修改后的链表的头节点。\n示例 1：\n输入nums = [1,2,3], head = [1,2,3,4,5]\n输出：[4,5]示例 2：\n输入nums = [1], head = [1,2,1,2,1,2]\n输出：[2,2,2]\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\nnums 中的所有元素都是唯一的。\n链表中的节点数在 [1, 10^5] 的范围内。\n1 <= Node.val <= 10^5\n输入保证链表中至少有一个值没有在 nums 中出现过。\n\n请完成下面的代码来解决上述问题：\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n```",
        "solution": "class Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n        Set<Integer> set = new HashSet<>(nums.length); // 预分配空间\n        for (int x : nums) {\n            set.add(x);\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy;\n        while (cur.next != null) {\n            if (set.contains(cur.next.val)) {\n                cur.next = cur.next.next; // 删除\n            } else {\n                cur = cur.next; // 向后移动\n            }\n        }\n        return dummy.next;\n    }\n}",
        "reference": "class ArrayToLinkedListConverter {\n    public static ListNode listToLinkedList(int[] nums) {\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        for (int num : nums) {\n            current.next = new ListNode(num);\n            current = current.next;\n        }\n        return dummy.next;\n    }\n}\n\n\nclass LinkedListToArrayConverter {\n    public static List<Integer> linkedListToList(ListNode head) {\n        List<Integer> result = new ArrayList<>();\n        ListNode current = head;\n        while (current != null) {\n            result.add(current.val);\n            current = current.next;\n        }\n        return result;\n    }\n}\n\n\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,3};\n        ListNode head_1 = ArrayToLinkedListConverter.listToLinkedList(new int[]{1,2,3,4,5});\n        ListNode ans_1 = ArrayToLinkedListConverter.listToLinkedList(new int[]{4,5});\n        assert LinkedListToArrayConverter.linkedListToList(solution.modifiedList(nums_1, head_1)).equals(LinkedListToArrayConverter.linkedListToList(ans_1));\n        int[] nums_2 = {1};\n        ListNode head_2 = ArrayToLinkedListConverter.listToLinkedList(new int[]{1,2,1,2,1,2});\n        ListNode ans_2 = ArrayToLinkedListConverter.listToLinkedList(new int[]{2,2,2});\n        assert LinkedListToArrayConverter.linkedListToList(solution.modifiedList(nums_2, head_2)).equals(LinkedListToArrayConverter.linkedListToList(ans_2));\n        int[] nums_3 = {5};\n        ListNode head_3 = ArrayToLinkedListConverter.listToLinkedList(new int[]{1,2,3,4});\n        ListNode ans_3 = ArrayToLinkedListConverter.listToLinkedList(new int[]{1,2,3,4});\n        assert LinkedListToArrayConverter.linkedListToList(solution.modifiedList(nums_3, head_3)).equals(LinkedListToArrayConverter.linkedListToList(ans_3));\n    }\n}",
        "class_helper": "class ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}",
        "context": "class ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {",
        "function_name": "modifiedList",
        "difficulty_level": "Middle",
        "time": "20240714"
    },
    {
        "id": "3218",
        "prompt_base": "\"\"\"\n有一个 m x n 大小的矩形蛋糕，需要切成 1 x 1 的小块。\n给你整数 m ，n 和两个数组：\nhorizontalCut 的大小为 m - 1 ，其中 horizontalCut[i] 表示沿着水平线 i 切蛋糕的开销。\nverticalCut 的大小为 n - 1 ，其中 verticalCut[j] 表示沿着垂直线 j 切蛋糕的开销。\n一次操作中，你可以选择任意不是 1 x 1 大小的矩形蛋糕并执行以下操作之一：\n沿着水平线 i 切开蛋糕，开销为 horizontalCut[i] 。\n沿着垂直线 j 切开蛋糕，开销为 verticalCut[j] 。\n每次操作后，这块蛋糕都被切成两个独立的小蛋糕。\n每次操作的开销都为最开始对应切割线的开销，并且不会改变。\n请你返回将蛋糕全部切成 1 x 1 的蛋糕块的 最小 总开销。\n示例 1：\n输入m = 3, n = 2, horizontalCut = [1,3], verticalCut = [5]\n输出：13示例 2：\n输入m = 2, n = 2, horizontalCut = [7], verticalCut = [4]\n输出：15\n\n提示：\n1 <= m, n <= 20\nhorizontalCut.length == m - 1\nverticalCut.length == n - 1\n1 <= horizontalCut[i], verticalCut[i] <= 10^3\n\"\"\"\n\nclass Solution {\n    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {",
        "prompt_chat": "有一个 m x n 大小的矩形蛋糕，需要切成 1 x 1 的小块。\n给你整数 m ，n 和两个数组：\nhorizontalCut 的大小为 m - 1 ，其中 horizontalCut[i] 表示沿着水平线 i 切蛋糕的开销。\nverticalCut 的大小为 n - 1 ，其中 verticalCut[j] 表示沿着垂直线 j 切蛋糕的开销。\n一次操作中，你可以选择任意不是 1 x 1 大小的矩形蛋糕并执行以下操作之一：\n沿着水平线 i 切开蛋糕，开销为 horizontalCut[i] 。\n沿着垂直线 j 切开蛋糕，开销为 verticalCut[j] 。\n每次操作后，这块蛋糕都被切成两个独立的小蛋糕。\n每次操作的开销都为最开始对应切割线的开销，并且不会改变。\n请你返回将蛋糕全部切成 1 x 1 的蛋糕块的 最小 总开销。\n示例 1：\n输入m = 3, n = 2, horizontalCut = [1,3], verticalCut = [5]\n输出：13示例 2：\n输入m = 2, n = 2, horizontalCut = [7], verticalCut = [4]\n输出：15\n\n提示：\n1 <= m, n <= 20\nhorizontalCut.length == m - 1\nverticalCut.length == n - 1\n1 <= horizontalCut[i], verticalCut[i] <= 10^3\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n```",
        "solution": "class Solution {\n    public long minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n        Arrays.sort(horizontalCut); // 下面倒序遍历\n        Arrays.sort(verticalCut);\n        long ans = 0;\n        int i = m - 2;\n        int j = n - 2;\n        int cntH = 1;\n        int cntV = 1;\n        while (i >= 0 || j >= 0) {\n            if (j < 0 || i >= 0 && horizontalCut[i] > verticalCut[j]) {\n                ans += horizontalCut[i--] * cntH; // 横切\n                cntV++; // 需要竖切的蛋糕块增加\n            } else {\n                ans += verticalCut[j--] * cntV; // 竖切\n                cntH++; // 需要横切的蛋糕块增加\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int m_1 = 3;\n        int n_1 = 2;\n        int[] horizontalCut_1 = {1,3};\n        int[] verticalCut_1 = {5};\n        int ans_1 = 13;\n        assert solution.minimumCost(m_1, n_1, horizontalCut_1, verticalCut_1) == ans_1;\n        int m_2 = 2;\n        int n_2 = 2;\n        int[] horizontalCut_2 = {7};\n        int[] verticalCut_2 = {4};\n        int ans_2 = 15;\n        assert solution.minimumCost(m_2, n_2, horizontalCut_2, verticalCut_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {",
        "function_name": "minimumCost",
        "difficulty_level": "Middle",
        "time": "20240714"
    },
    {
        "id": "3219",
        "prompt_base": "\"\"\"\n有一个 m x n 大小的矩形蛋糕，需要切成 1 x 1 的小块。\n给你整数 m ，n 和两个数组：\nhorizontalCut 的大小为 m - 1 ，其中 horizontalCut[i] 表示沿着水平线 i 切蛋糕的开销。\nverticalCut 的大小为 n - 1 ，其中 verticalCut[j] 表示沿着垂直线 j 切蛋糕的开销。\n一次操作中，你可以选择任意不是 1 x 1 大小的矩形蛋糕并执行以下操作之一：\n沿着水平线 i 切开蛋糕，开销为 horizontalCut[i] 。\n沿着垂直线 j 切开蛋糕，开销为 verticalCut[j] 。\n每次操作后，这块蛋糕都被切成两个独立的小蛋糕。\n每次操作的开销都为最开始对应切割线的开销，并且不会改变。\n请你返回将蛋糕全部切成 1 x 1 的蛋糕块的 最小 总开销。\n示例 1：\n输入m = 3, n = 2, horizontalCut = [1,3], verticalCut = [5]\n输出：13示例 2：\n输入m = 2, n = 2, horizontalCut = [7], verticalCut = [4]\n输出：15\n\n提示：\n1 <= m, n <= 10^5\nhorizontalCut.length == m - 1\nverticalCut.length == n - 1\n1 <= horizontalCut[i], verticalCut[i] <= 10^3\n\"\"\"\n\nclass Solution {\n    public long minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {",
        "prompt_chat": "有一个 m x n 大小的矩形蛋糕，需要切成 1 x 1 的小块。\n给你整数 m ，n 和两个数组：\nhorizontalCut 的大小为 m - 1 ，其中 horizontalCut[i] 表示沿着水平线 i 切蛋糕的开销。\nverticalCut 的大小为 n - 1 ，其中 verticalCut[j] 表示沿着垂直线 j 切蛋糕的开销。\n一次操作中，你可以选择任意不是 1 x 1 大小的矩形蛋糕并执行以下操作之一：\n沿着水平线 i 切开蛋糕，开销为 horizontalCut[i] 。\n沿着垂直线 j 切开蛋糕，开销为 verticalCut[j] 。\n每次操作后，这块蛋糕都被切成两个独立的小蛋糕。\n每次操作的开销都为最开始对应切割线的开销，并且不会改变。\n请你返回将蛋糕全部切成 1 x 1 的蛋糕块的 最小 总开销。\n示例 1：\n输入m = 3, n = 2, horizontalCut = [1,3], verticalCut = [5]\n输出：13示例 2：\n输入m = 2, n = 2, horizontalCut = [7], verticalCut = [4]\n输出：15\n\n提示：\n1 <= m, n <= 10^5\nhorizontalCut.length == m - 1\nverticalCut.length == n - 1\n1 <= horizontalCut[i], verticalCut[i] <= 10^3\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n```",
        "solution": "class Solution {\n    public long minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n        Arrays.sort(horizontalCut); // 下面倒序遍历\n        Arrays.sort(verticalCut);\n        long ans = 0;\n        int i = m - 2;\n        int j = n - 2;\n        while (i >= 0 || j >= 0) {\n            if (j < 0 || i >= 0 && horizontalCut[i] > verticalCut[j]) {\n                ans += horizontalCut[i--] * (n - 1 - j); // 横切\n            } else {\n                ans += verticalCut[j--] * (m - 1 - i); // 竖切\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int m_1 = 3;\n        int n_1 = 2;\n        int[] horizontalCut_1 = {1,3};\n        int[] verticalCut_1 = {5};\n        long ans_1 = 13;\n        assert solution.minimumCost(m_1, n_1, horizontalCut_1, verticalCut_1) == ans_1;\n        int m_2 = 2;\n        int n_2 = 2;\n        int[] horizontalCut_2 = {7};\n        int[] verticalCut_2 = {4};\n        long ans_2 = 15;\n        assert solution.minimumCost(m_2, n_2, horizontalCut_2, verticalCut_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {",
        "function_name": "minimumCost",
        "difficulty_level": "Hard",
        "time": "20240714"
    },
    {
        "id": "3024",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始长度为 3 的整数数组 nums ，需要用它们来构造三角形。\n如果一个三角形的所有边长度相等，那么这个三角形称为 equilateral 。\n如果一个三角形恰好有两条边长度相等，那么这个三角形称为 isosceles 。\n如果一个三角形三条边的长度互不相同，那么这个三角形称为 scalene 。\n如果这个数组无法构成一个三角形，请你返回字符串 \\\"none\\\" ，否则返回一个字符串表示这个三角形的类型。\n示例 1：\n输入nums = [3,3,3]\n输出：\"equilateral\"示例 2：\n输入nums = [3,4,5]\n输出：\"scalene\"\n\n提示：\nnums.length == 3\n1 <= nums[i] <= 100\n\"\"\"\n\nclass Solution {\n    public String triangleType(int[] nums) {",
        "prompt_chat": "给你一个下标从 0 开始长度为 3 的整数数组 nums ，需要用它们来构造三角形。\n如果一个三角形的所有边长度相等，那么这个三角形称为 equilateral 。\n如果一个三角形恰好有两条边长度相等，那么这个三角形称为 isosceles 。\n如果一个三角形三条边的长度互不相同，那么这个三角形称为 scalene 。\n如果这个数组无法构成一个三角形，请你返回字符串 \\\"none\\\" ，否则返回一个字符串表示这个三角形的类型。\n示例 1：\n输入nums = [3,3,3]\n输出：\"equilateral\"示例 2：\n输入nums = [3,4,5]\n输出：\"scalene\"\n\n提示：\nnums.length == 3\n1 <= nums[i] <= 100\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public String triangleType(int[] nums) {\n```",
        "solution": "class Solution {\n    public String triangleType(int[] nums) {\n        Arrays.sort(nums);\n        int x = nums[0];\n        int y = nums[1];\n        int z = nums[2];\n        if (x + y <= z) { // 排序后，只需比较 x+y 和 z\n            return \"none\";\n        }\n        if (x == z) { // 排序了，说明 y 也和 x z 相等\n            return \"equilateral\";\n        }\n        if (x == y || y == z) {\n            return \"isosceles\";\n        }\n        return \"scalene\";\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {3,3,3};\n        String ans_1 = \"equilateral\";\n    assert solution.triangleType(nums_1).equals(ans_1);\n        int[] nums_2 = {3,4,5};\n        String ans_2 = \"scalene\";\n    assert solution.triangleType(nums_2).equals(ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public String triangleType(int[] nums) {",
        "function_name": "triangleType",
        "difficulty_level": "Easy",
        "time": "20240203"
    },
    {
        "id": "3025",
        "prompt_base": "\"\"\"\n给你一个  n x 2 的二维数组 points ，它表示二维平面上的一些点坐标，其中 points[i] = [x_i, y_i] 。\n计算点对 (A, B) 的数量，其中\nA 在 B 的左上角，并且\n它们形成的长方形中（或直线上）没有其它点（包括边界）。\n返回数量。\n示例 1：\n输入points = [[1,1],[2,2],[3,3]]\n输出：0示例 2：\n输入points = [[6,2],[4,4],[2,6]]\n输出：2\n\n提示：\n2 <= n <= 50\npoints[i].length == 2\n0 <= points[i][0], points[i][1] <= 50\npoints[i] 点对两两不同。\n\"\"\"\n\nclass Solution {\n    public int numberOfPairs(int[][] points) {",
        "prompt_chat": "给你一个  n x 2 的二维数组 points ，它表示二维平面上的一些点坐标，其中 points[i] = [x_i, y_i] 。\n计算点对 (A, B) 的数量，其中\nA 在 B 的左上角，并且\n它们形成的长方形中（或直线上）没有其它点（包括边界）。\n返回数量。\n示例 1：\n输入points = [[1,1],[2,2],[3,3]]\n输出：0示例 2：\n输入points = [[6,2],[4,4],[2,6]]\n输出：2\n\n提示：\n2 <= n <= 50\npoints[i].length == 2\n0 <= points[i][0], points[i][1] <= 50\npoints[i] 点对两两不同。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int numberOfPairs(int[][] points) {\n```",
        "solution": "class Solution {\n    public int numberOfPairs(int[][] points) {\n        Arrays.sort(points, (p, q) -> p[0] != q[0] ? p[0] - q[0] : q[1] - p[1]);\n        int ans = 0;\n        for (int i = 0; i < points.length; i++) {\n            int y0 = points[i][1];\n            int maxY = Integer.MIN_VALUE;\n            for (int j = i + 1; j < points.length; j++) {\n                int y = points[j][1];\n                if (y <= y0 && y > maxY) {\n                    maxY = y;\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] points_1 = {{1,1},{2,2},{3,3}};\n        int ans_1 = 0;\n        assert solution.numberOfPairs(points_1) == ans_1;\n        int[][] points_2 = {{6,2},{4,4},{2,6}};\n        int ans_2 = 2;\n        assert solution.numberOfPairs(points_2) == ans_2;\n        int[][] points_3 = {{3,1},{1,3},{1,1}};\n        int ans_3 = 2;\n        assert solution.numberOfPairs(points_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int numberOfPairs(int[][] points) {",
        "function_name": "numberOfPairs",
        "difficulty_level": "Middle",
        "time": "20240203"
    },
    {
        "id": "3026",
        "prompt_base": "\"\"\"\n给你一个长度为 n 的数组 nums 和一个 正 整数 k 。\n如果 nums 的一个子数组中，第一个元素和最后一个元素 差的绝对值恰好 为 k ，我们称这个子数组为 好 的。换句话说，如果子数组 nums[i..j] 满足 |nums[i] - nums[j]| == k ，那么它是一个好子数组。\n请你返回 nums 中 好 子数组的 最大 和，如果没有好子数组，返回 0 。\n示例 1：\n输入nums = [1,2,3,4,5,6], k = 1\n输出：11示例 2：\n输入nums = [-1,3,2,4,5], k = 3\n输出：11\n\n提示：\n2 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9\n1 <= k <= 10^9\n\"\"\"\n\nclass Solution {\n    public long maximumSubarraySum(int[] nums, int k) {",
        "prompt_chat": "给你一个长度为 n 的数组 nums 和一个 正 整数 k 。\n如果 nums 的一个子数组中，第一个元素和最后一个元素 差的绝对值恰好 为 k ，我们称这个子数组为 好 的。换句话说，如果子数组 nums[i..j] 满足 |nums[i] - nums[j]| == k ，那么它是一个好子数组。\n请你返回 nums 中 好 子数组的 最大 和，如果没有好子数组，返回 0 。\n示例 1：\n输入nums = [1,2,3,4,5,6], k = 1\n输出：11示例 2：\n输入nums = [-1,3,2,4,5], k = 3\n输出：11\n\n提示：\n2 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9\n1 <= k <= 10^9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long maximumSubarraySum(int[] nums, int k) {\n```",
        "solution": "class Solution {\n    public long maximumSubarraySum(int[] nums, int k) {\n        long ans = Long.MIN_VALUE;\n        long sum = 0;\n        Map<Integer, Long> minS = new HashMap<>();\n        for (int x : nums) {\n            long s1 = minS.getOrDefault(x - k, Long.MAX_VALUE / 2);\n            long s2 = minS.getOrDefault(x + k, Long.MAX_VALUE / 2);\n            ans = Math.max(ans, sum + x - Math.min(s1, s2));\n            minS.merge(x, sum, Math::min);\n            sum += x;\n        }\n        return ans > Long.MIN_VALUE / 4 ? ans : 0;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,3,4,5,6};\n        int k_1 = 1;\n        long ans_1 = 11;\n        assert solution.maximumSubarraySum(nums_1, k_1) == ans_1;\n        int[] nums_2 = {-1,3,2,4,5};\n        int k_2 = 3;\n        long ans_2 = 11;\n        assert solution.maximumSubarraySum(nums_2, k_2) == ans_2;\n        int[] nums_3 = {-1,-2,-3,-4};\n        int k_3 = 2;\n        long ans_3 = -6;\n        assert solution.maximumSubarraySum(nums_3, k_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long maximumSubarraySum(int[] nums, int k) {",
        "function_name": "maximumSubarraySum",
        "difficulty_level": "Middle",
        "time": "20240203"
    },
    {
        "id": "3027",
        "prompt_base": "\"\"\"\n给你一个  n x 2 的二维数组 points ，它表示二维平面上的一些点坐标，其中 points[i] = [x_i, y_i] 。\n我们定义 x 轴的正方向为 右 （x 轴递增的方向），x 轴的负方向为 左 （x 轴递减的方向）。类似的，我们定义 y 轴的正方向为 上 （y 轴递增的方向），y 轴的负方向为 下 （y 轴递减的方向）。\n你需要安排这 n 个人的站位，这 n 个人中包括 Alice 和 Bob 。你需要确保每个点处 恰好 有 一个 人。同时，Alice 想跟 Bob 单独玩耍，所以 Alice 会以 Alice 的坐标为 左上角 ，Bob 的坐标为 右下角 建立一个矩形的围栏（注意，围栏可能 不 包含任何区域，也就是说围栏可能是一条线段）。如果围栏的 内部 或者 边缘 上有任何其他人，Alice 都会难过。\n请你在确保 Alice 不会 难过的前提下，返回 Alice 和 Bob 可以选择的 点对 数目。\n注意，Alice 建立的围栏必须确保 Alice 的位置是矩形的左上角，Bob 的位置是矩形的右下角。比方说，以 (1, 1) ，(1, 3) ，(3, 1) 和 (3, 3) 为矩形的四个角，给定下图的两个输入，Alice 都不能建立围栏，原因如下：\n图一中，Alice 在 (3, 3) 且 Bob 在 (1, 1) ，Alice 的位置不是左上角且 Bob 的位置不是右下角。\n图二中，Alice 在 (1, 3) 且 Bob 在 (1, 1) ，Bob 的位置不是在围栏的右下角。\n示例 1：\n输入points = [[1,1],[2,2],[3,3]]\n输出：0示例 2：\n输入points = [[6,2],[4,4],[2,6]]\n输出：2\n\n提示：\n2 <= n <= 1000\npoints[i].length == 2\n-10^9 <= points[i][0], points[i][1] <= 10^9\npoints[i] 点对两两不同。\n\"\"\"\n\nclass Solution {\n    public int numberOfPairs(int[][] points) {",
        "prompt_chat": "给你一个  n x 2 的二维数组 points ，它表示二维平面上的一些点坐标，其中 points[i] = [x_i, y_i] 。\n我们定义 x 轴的正方向为 右 （x 轴递增的方向），x 轴的负方向为 左 （x 轴递减的方向）。类似的，我们定义 y 轴的正方向为 上 （y 轴递增的方向），y 轴的负方向为 下 （y 轴递减的方向）。\n你需要安排这 n 个人的站位，这 n 个人中包括 Alice 和 Bob 。你需要确保每个点处 恰好 有 一个 人。同时，Alice 想跟 Bob 单独玩耍，所以 Alice 会以 Alice 的坐标为 左上角 ，Bob 的坐标为 右下角 建立一个矩形的围栏（注意，围栏可能 不 包含任何区域，也就是说围栏可能是一条线段）。如果围栏的 内部 或者 边缘 上有任何其他人，Alice 都会难过。\n请你在确保 Alice 不会 难过的前提下，返回 Alice 和 Bob 可以选择的 点对 数目。\n注意，Alice 建立的围栏必须确保 Alice 的位置是矩形的左上角，Bob 的位置是矩形的右下角。比方说，以 (1, 1) ，(1, 3) ，(3, 1) 和 (3, 3) 为矩形的四个角，给定下图的两个输入，Alice 都不能建立围栏，原因如下：\n图一中，Alice 在 (3, 3) 且 Bob 在 (1, 1) ，Alice 的位置不是左上角且 Bob 的位置不是右下角。\n图二中，Alice 在 (1, 3) 且 Bob 在 (1, 1) ，Bob 的位置不是在围栏的右下角。\n示例 1：\n输入points = [[1,1],[2,2],[3,3]]\n输出：0示例 2：\n输入points = [[6,2],[4,4],[2,6]]\n输出：2\n\n提示：\n2 <= n <= 1000\npoints[i].length == 2\n-10^9 <= points[i][0], points[i][1] <= 10^9\npoints[i] 点对两两不同。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int numberOfPairs(int[][] points) {\n```",
        "solution": "class Solution {\n    public int numberOfPairs(int[][] points) {\n        Arrays.sort(points, (p, q) -> p[0] != q[0] ? p[0] - q[0] : q[1] - p[1]);\n        int ans = 0;\n        for (int i = 0; i < points.length; i++) {\n            int y0 = points[i][1];\n            int maxY = Integer.MIN_VALUE;\n            for (int j = i + 1; j < points.length; j++) {\n                int y = points[j][1];\n                if (y <= y0 && y > maxY) {\n                    maxY = y;\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] points_1 = {{1,1},{2,2},{3,3}};\n        int ans_1 = 0;\n        assert solution.numberOfPairs(points_1) == ans_1;\n        int[][] points_2 = {{6,2},{4,4},{2,6}};\n        int ans_2 = 2;\n        assert solution.numberOfPairs(points_2) == ans_2;\n        int[][] points_3 = {{3,1},{1,3},{1,1}};\n        int ans_3 = 2;\n        assert solution.numberOfPairs(points_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int numberOfPairs(int[][] points) {",
        "function_name": "numberOfPairs",
        "difficulty_level": "Hard",
        "time": "20240203"
    },
    {
        "id": "3038",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums ，如果 nums 至少 包含 2 个元素，你可以执行以下操作：\n选择 nums 中的前两个元素并将它们删除。\n一次操作的 分数 是被删除元素的和。\n在确保 所有操作分数相同 的前提下，请你求出 最多 能进行多少次操作。\n请你返回按照上述要求 最多 可以进行的操作次数。\n示例 1：\n输入nums = [3,2,1,4,5]\n输出：2示例 2：\n输入nums = [3,2,6,1,4]\n输出：1\n\n提示：\n2 <= nums.length <= 100\n1 <= nums[i] <= 1000\n\"\"\"\n\nclass Solution {\n    public int maxOperations(int[] nums) {",
        "prompt_chat": "给你一个整数数组 nums ，如果 nums 至少 包含 2 个元素，你可以执行以下操作：\n选择 nums 中的前两个元素并将它们删除。\n一次操作的 分数 是被删除元素的和。\n在确保 所有操作分数相同 的前提下，请你求出 最多 能进行多少次操作。\n请你返回按照上述要求 最多 可以进行的操作次数。\n示例 1：\n输入nums = [3,2,1,4,5]\n输出：2示例 2：\n输入nums = [3,2,6,1,4]\n输出：1\n\n提示：\n2 <= nums.length <= 100\n1 <= nums[i] <= 1000\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maxOperations(int[] nums) {\n```",
        "solution": "class Solution {\n    public int maxOperations(int[] nums) {\n        int n = nums.length, t = 0;\n        for (int i = 1; i < n; i += 2) {\n            if (nums[i] + nums[i - 1] != nums[1] + nums[0]) {\n                break;\n            }\n            t++;\n        }\n        return t;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {3,2,1,4,5};\n        int ans_1 = 2;\n        assert solution.maxOperations(nums_1) == ans_1;\n        int[] nums_2 = {3,2,6,1,4};\n        int ans_2 = 1;\n        assert solution.maxOperations(nums_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maxOperations(int[] nums) {",
        "function_name": "maxOperations",
        "difficulty_level": "Easy",
        "time": "20240217"
    },
    {
        "id": "3039",
        "prompt_base": "\"\"\"\n给你一个字符串 s 。请你进行以下操作直到 s 为 空 ：\n每次操作 依次 遍历 'a' 到 'z'，如果当前字符出现在 s 中，那么删除出现位置 最早 的该字符（如果存在的话）。\n例如，最初 s = \\\"aabcbbca\\\"。我们执行下述操作：\n移除下划线的字符  s = \\\"\\undeline{a}a\\underline{bc}bbca\\\"。结果字符串为 s = \\\"abbca\\\"。\n移除下划线的字符  s = \\\"\\underline{ab}b\\underline{c}a\\\"。结果字符串为 s = \\\"ba\\\"。\n移除下划线的字符  s = \\\"\\underline{ba}\\\"。结果字符串为 s = \\\"\\\"。\n请你返回进行 最后 一次操作 之前 的字符串 s 。在上面的例子中，答案是 \\\"ba\\\"。\n示例 1：\n输入s = \"aabcbbca\"\n输出：\"ba\"示例 2：\n输入s = \"abcd\"\n输出：\"abcd\"\n\n提示：\n1 <= s.length <= 5 * 10^5\ns 只包含小写英文字母。\n\"\"\"\n\nclass Solution {\n    public String lastNonEmptyString(String s) {",
        "prompt_chat": "给你一个字符串 s 。请你进行以下操作直到 s 为 空 ：\n每次操作 依次 遍历 'a' 到 'z'，如果当前字符出现在 s 中，那么删除出现位置 最早 的该字符（如果存在的话）。\n例如，最初 s = \\\"aabcbbca\\\"。我们执行下述操作：\n移除下划线的字符  s = \\\"\\undeline{a}a\\underline{bc}bbca\\\"。结果字符串为 s = \\\"abbca\\\"。\n移除下划线的字符  s = \\\"\\underline{ab}b\\underline{c}a\\\"。结果字符串为 s = \\\"ba\\\"。\n移除下划线的字符  s = \\\"\\underline{ba}\\\"。结果字符串为 s = \\\"\\\"。\n请你返回进行 最后 一次操作 之前 的字符串 s 。在上面的例子中，答案是 \\\"ba\\\"。\n示例 1：\n输入s = \"aabcbbca\"\n输出：\"ba\"示例 2：\n输入s = \"abcd\"\n输出：\"abcd\"\n\n提示：\n1 <= s.length <= 5 * 10^5\ns 只包含小写英文字母。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public String lastNonEmptyString(String s) {\n```",
        "solution": "class Solution {\n    public String lastNonEmptyString(String S) {\n        int[] cnt = new int[26];\n        int[] last = new int[26];\n        char[] s = S.toCharArray();\n        for (int i = 0; i < s.length; i++) {\n            int b = s[i] - 'a';\n            cnt[b]++;\n            last[b] = i;\n        }\n\n        // 注：也可以再遍历一次 s 直接得到答案，但效率不如下面，毕竟至多 26 个数\n        List<Integer> ids = new ArrayList<>();\n        int mx = Arrays.stream(cnt).max().orElseThrow();\n        for (int i = 0; i < 26; i++) {\n            if (cnt[i] == mx) {\n                ids.add(last[i]);\n            }\n        }\n        Collections.sort(ids);\n\n        StringBuilder t = new StringBuilder(ids.size());\n        for (int i : ids) {\n            t.append(s[i]);\n        }\n        return t.toString();\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s_1 = \"aabcbbca\";\n        String ans_1 = \"ba\";\n    assert solution.lastNonEmptyString(s_1).equals(ans_1);\n        String s_2 = \"abcd\";\n        String ans_2 = \"abcd\";\n    assert solution.lastNonEmptyString(s_2).equals(ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public String lastNonEmptyString(String s) {",
        "function_name": "lastNonEmptyString",
        "difficulty_level": "Middle",
        "time": "20240217"
    },
    {
        "id": "3040",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums ，如果 nums 至少 包含 2 个元素，你可以执行以下操作中的 任意 一个：\n选择 nums 中最前面两个元素并且删除它们。\n选择 nums 中最后两个元素并且删除它们。\n选择 nums 中第一个和最后一个元素并且删除它们。\n一次操作的 分数 是被删除元素的和。\n在确保 所有操作分数相同 的前提下，请你求出 最多 能进行多少次操作。\n请你返回按照上述要求 最多 可以进行的操作次数。\n示例 1：\n输入nums = [3,2,1,2,3,4]\n输出：3示例 2：\n输入nums = [3,2,6,1,4]\n输出：2\n\n提示：\n2 <= nums.length <= 2000\n1 <= nums[i] <= 1000\n\"\"\"\n\nclass Solution {\n    public int maxOperations(int[] nums) {",
        "prompt_chat": "给你一个整数数组 nums ，如果 nums 至少 包含 2 个元素，你可以执行以下操作中的 任意 一个：\n选择 nums 中最前面两个元素并且删除它们。\n选择 nums 中最后两个元素并且删除它们。\n选择 nums 中第一个和最后一个元素并且删除它们。\n一次操作的 分数 是被删除元素的和。\n在确保 所有操作分数相同 的前提下，请你求出 最多 能进行多少次操作。\n请你返回按照上述要求 最多 可以进行的操作次数。\n示例 1：\n输入nums = [3,2,1,2,3,4]\n输出：3示例 2：\n输入nums = [3,2,6,1,4]\n输出：2\n\n提示：\n2 <= nums.length <= 2000\n1 <= nums[i] <= 1000\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maxOperations(int[] nums) {\n```",
        "solution": "class Solution {\n    int[] nums;\n    int[][] memo;\n\n    public int maxOperations(int[] nums) {\n        int n = nums.length;\n        this.nums = nums;\n        this.memo = new int[n][n];\n        int res = 0;\n        res = Math.max(res, helper(0, n - 1, nums[0] + nums[n - 1]));\n        res = Math.max(res, helper(0, n - 1, nums[0] + nums[1]));\n        res = Math.max(res, helper(0, n - 1, nums[n - 2] + nums[n - 1]));\n        return res;\n    }\n\n    public int helper(int i, int j, int target) {\n        for (int k = 0; k < nums.length; k++) {\n            Arrays.fill(memo[k], -1);\n        }\n        return dfs(i, j, target);\n    }\n\n    public int dfs(int i, int j, int target) {\n        if (i >= j) {\n            return 0;\n        }\n        if (memo[i][j] != -1) {\n            return memo[i][j];\n        }\n        int ans = 0;\n        if (nums[i] + nums[i + 1] == target) {\n            ans = Math.max(ans, dfs(i + 2, j, target) + 1);\n        }\n        if (nums[j - 1] + nums[j] == target) {\n            ans = Math.max(ans, dfs(i, j - 2, target) + 1);\n        }\n        if (nums[i] + nums[j] == target) {\n            ans = Math.max(ans, dfs(i + 1, j - 1, target) + 1);\n        }\n        memo[i][j] = ans;\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {3,2,1,2,3,4};\n        int ans_1 = 3;\n        assert solution.maxOperations(nums_1) == ans_1;\n        int[] nums_2 = {3,2,6,1,4};\n        int ans_2 = 2;\n        assert solution.maxOperations(nums_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maxOperations(int[] nums) {",
        "function_name": "maxOperations",
        "difficulty_level": "Middle",
        "time": "20240217"
    },
    {
        "id": "3041",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始只包含 正 整数的数组 nums 。一开始，你可以将数组中 任意数量 元素增加 至多 1 。\n修改后，你可以从最终数组中选择 一个或者更多 元素，并确保这些元素升序排序后是 连续 的。比方说，[3, 4, 5] 是连续的，但是 [3, 4, 6] 和 [1, 1, 2, 3] 不是连续的。\n请你返回 最多 可以选出的元素数目。\n示例 1：\n输入nums = [2,1,5,1,1]\n输出：3示例 2：\n输入nums = [1,4,7,10]\n输出：1\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^6\n\"\"\"\n\nclass Solution {\n    public int maxSelectedElements(int[] nums) {",
        "prompt_chat": "给你一个下标从 0 开始只包含 正 整数的数组 nums 。一开始，你可以将数组中 任意数量 元素增加 至多 1 。\n修改后，你可以从最终数组中选择 一个或者更多 元素，并确保这些元素升序排序后是 连续 的。比方说，[3, 4, 5] 是连续的，但是 [3, 4, 6] 和 [1, 1, 2, 3] 不是连续的。\n请你返回 最多 可以选出的元素数目。\n示例 1：\n输入nums = [2,1,5,1,1]\n输出：3示例 2：\n输入nums = [1,4,7,10]\n输出：1\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^6\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maxSelectedElements(int[] nums) {\n```",
        "solution": "class Solution {\n    public int maxSelectedElements(int[] nums) {\n        Arrays.sort(nums);\n        Map<Integer, Integer> f = new HashMap<>();\n        for (int x : nums) {\n            f.put(x + 1, f.getOrDefault(x, 0) + 1);\n            f.put(x, f.getOrDefault(x - 1, 0) + 1);\n        }\n        int ans = 0;\n        for (int res : f.values()) {\n            ans = Math.max(ans, res);\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {2,1,5,1,1};\n        int ans_1 = 3;\n        assert solution.maxSelectedElements(nums_1) == ans_1;\n        int[] nums_2 = {1,4,7,10};\n        int ans_2 = 1;\n        assert solution.maxSelectedElements(nums_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maxSelectedElements(int[] nums) {",
        "function_name": "maxSelectedElements",
        "difficulty_level": "Hard",
        "time": "20240217"
    },
    {
        "id": "3065",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的整数数组 nums 和一个整数 k。\n一次操作中，你可以删除 nums 中的最小元素。\n你需要使数组中的所有元素都大于或等于 k ，请你返回需要的 最少 操作次数。\n示例 1：\n输入nums = [2,11,10,1,3], k = 10\n输出：3示例 2：\n输入nums = [1,1,2,4,9], k = 1\n输出：0\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 10^9\n1 <= k <= 10^9\n输入保证至少有一个满足 nums[i] >= k 的下标 i 存在。\n\"\"\"\n\nclass Solution {\n    public int minOperations(int[] nums, int k) {",
        "prompt_chat": "给你一个下标从 0 开始的整数数组 nums 和一个整数 k。\n一次操作中，你可以删除 nums 中的最小元素。\n你需要使数组中的所有元素都大于或等于 k ，请你返回需要的 最少 操作次数。\n示例 1：\n输入nums = [2,11,10,1,3], k = 10\n输出：3示例 2：\n输入nums = [1,1,2,4,9], k = 1\n输出：0\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 10^9\n1 <= k <= 10^9\n输入保证至少有一个满足 nums[i] >= k 的下标 i 存在。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minOperations(int[] nums, int k) {\n```",
        "solution": "class Solution {\n    public int minOperations(int[] nums, int k) {\n        int ans = 0;\n        for (int x : nums) {\n            if (x < k) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {2,11,10,1,3};\n        int k_1 = 10;\n        int ans_1 = 3;\n        assert solution.minOperations(nums_1, k_1) == ans_1;\n        int[] nums_2 = {1,1,2,4,9};\n        int k_2 = 1;\n        int ans_2 = 0;\n        assert solution.minOperations(nums_2, k_2) == ans_2;\n        int[] nums_3 = {1,1,2,4,9};\n        int k_3 = 9;\n        int ans_3 = 4;\n        assert solution.minOperations(nums_3, k_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minOperations(int[] nums, int k) {",
        "function_name": "minOperations",
        "difficulty_level": "Easy",
        "time": "20240302"
    },
    {
        "id": "3066",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的整数数组 nums 和一个整数 k。\n一次操作中，你将执行：\n选择 nums 中最小的两个整数 x 和 y。\n将 x 和 y 从 nums 中删除。\n将 min(x, y) * 2 + max(x, y) 添加到数组中的任意位置。\n注意，只有当 nums 至少包含两个元素时，你才可以执行以上操作。\n你需要使数组中的所有元素都大于或等于 k ，请你返回需要的 最少 操作次数。\n示例 1：\n输入nums = [2,11,10,1,3], k = 10\n输出：2示例 2：\n输入nums = [1,1,2,4,9], k = 20\n输出：4\n\n提示：\n2 <= nums.length <= 2 * 10^5\n1 <= nums[i] <= 10^9\n1 <= k <= 10^9\n输入保证答案一定存在，也就是说一定存在一个操作序列使数组中所有元素都大于等于 k 。\n\"\"\"\n\nclass Solution {\n    public int minOperations(int[] nums, int k) {",
        "prompt_chat": "给你一个下标从 0 开始的整数数组 nums 和一个整数 k。\n一次操作中，你将执行：\n选择 nums 中最小的两个整数 x 和 y。\n将 x 和 y 从 nums 中删除。\n将 min(x, y) * 2 + max(x, y) 添加到数组中的任意位置。\n注意，只有当 nums 至少包含两个元素时，你才可以执行以上操作。\n你需要使数组中的所有元素都大于或等于 k ，请你返回需要的 最少 操作次数。\n示例 1：\n输入nums = [2,11,10,1,3], k = 10\n输出：2示例 2：\n输入nums = [1,1,2,4,9], k = 20\n输出：4\n\n提示：\n2 <= nums.length <= 2 * 10^5\n1 <= nums[i] <= 10^9\n1 <= k <= 10^9\n输入保证答案一定存在，也就是说一定存在一个操作序列使数组中所有元素都大于等于 k 。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minOperations(int[] nums, int k) {\n```",
        "solution": "class Solution {\n    public int minOperations(int[] nums, int k) {\n        int ans = 0;\n        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (int x : nums) {\n            pq.offer((long) x);\n        }\n        while (pq.peek() < k) {\n            long x = pq.poll();\n            long y = pq.poll();\n            pq.offer(x * 2 + y);\n            ans++;\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {2,11,10,1,3};\n        int k_1 = 10;\n        int ans_1 = 2;\n        assert solution.minOperations(nums_1, k_1) == ans_1;\n        int[] nums_2 = {1,1,2,4,9};\n        int k_2 = 20;\n        int ans_2 = 4;\n        assert solution.minOperations(nums_2, k_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minOperations(int[] nums, int k) {",
        "function_name": "minOperations",
        "difficulty_level": "Middle",
        "time": "20240302"
    },
    {
        "id": "3067",
        "prompt_base": "\"\"\"\n给你一棵无根带权树，树中总共有 n 个节点，分别表示 n 个服务器，服务器从 0 到 n - 1 编号。同时给你一个数组 edges ，其中 edges[i] = [a_i, b_i, weight_i] 表示节点 a_i 和 b_i 之间有一条双向边，边的权值为 weight_i 。再给你一个整数 signalSpeed。\n如果两台服务器 a 和 b 是通过服务器 c 可连接的，则：\na < b ，a != c 且 b != c 。\n从 c 到 a 的距离是可以被 signalSpeed 整除的。\n从 c 到 b 的距离是可以被 signalSpeed 整除的。\n从 c 到 b 的路径与从 c 到 a 的路径没有任何公共边。\n请你返回一个长度为 n 的整数数组 count ，其中 count[i] 表示通过服务器 i 可连接 的服务器对的 数目 。\n示例 1：\n输入edges = [[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], signalSpeed = 1\n输出：[0,4,6,6,4,0]示例 2：\n输入edges = [[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], signalSpeed = 3\n输出：[2,0,0,0,0,0,2]\n\n提示：\n2 <= n <= 1000\nedges.length == n - 1\nedges[i].length == 3\n0 <= a_i, b_i < n\nedges[i] = [a_i, b_i, weight_i]\n1 <= weight_i <= 10^6\n1 <= signalSpeed <= 10^6\n输入保证 edges 构成一棵合法的树。\n\"\"\"\n\nclass Solution {\n    public int[] countPairsOfConnectableServers(int[][] edges, int signalSpeed) {",
        "prompt_chat": "给你一棵无根带权树，树中总共有 n 个节点，分别表示 n 个服务器，服务器从 0 到 n - 1 编号。同时给你一个数组 edges ，其中 edges[i] = [a_i, b_i, weight_i] 表示节点 a_i 和 b_i 之间有一条双向边，边的权值为 weight_i 。再给你一个整数 signalSpeed。\n如果两台服务器 a 和 b 是通过服务器 c 可连接的，则：\na < b ，a != c 且 b != c 。\n从 c 到 a 的距离是可以被 signalSpeed 整除的。\n从 c 到 b 的距离是可以被 signalSpeed 整除的。\n从 c 到 b 的路径与从 c 到 a 的路径没有任何公共边。\n请你返回一个长度为 n 的整数数组 count ，其中 count[i] 表示通过服务器 i 可连接 的服务器对的 数目 。\n示例 1：\n输入edges = [[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], signalSpeed = 1\n输出：[0,4,6,6,4,0]示例 2：\n输入edges = [[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], signalSpeed = 3\n输出：[2,0,0,0,0,0,2]\n\n提示：\n2 <= n <= 1000\nedges.length == n - 1\nedges[i].length == 3\n0 <= a_i, b_i < n\nedges[i] = [a_i, b_i, weight_i]\n1 <= weight_i <= 10^6\n1 <= signalSpeed <= 10^6\n输入保证 edges 构成一棵合法的树。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int[] countPairsOfConnectableServers(int[][] edges, int signalSpeed) {\n```",
        "solution": "class Solution {\n    public int[] countPairsOfConnectableServers(int[][] edges, int signalSpeed) {\n        int n = edges.length + 1;\n        List<int[]>[] graph = new ArrayList[n];\n        Arrays.setAll(graph, i -> new ArrayList<>());\n\n        for (int[] e : edges) {\n            int u = e[0];\n            int v = e[1];\n            int w = e[2];\n            graph[u].add(new int[]{v, w});\n            graph[v].add(new int[]{u, w});\n        }\n\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            int pre = 0;\n            for (int[] e : graph[i]) {\n                int cnt = dfs(e[0], i, e[1] % signalSpeed, signalSpeed, graph);\n                res[i] += pre * cnt;\n                pre += cnt;\n            }\n        }\n        return res;\n    }\n\n    private int dfs(int p, int root, int curr, int signalSpeed, List<int[]>[] graph) {\n        int res = 0;\n        if (curr == 0) {\n            res++;\n        }\n        for (int[] e : graph[p]) {\n            int v = e[0];\n            int cost = e[1];\n            if (v != root) {\n                res += dfs(v, p, (curr + cost) % signalSpeed, signalSpeed, graph);\n            }\n        }\n        return res;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] edges_1 = {{0,1,1},{1,2,5},{2,3,13},{3,4,9},{4,5,2}};\n        int signalSpeed_1 = 1;\n        int[] ans_1 = {0,4,6,6,4,0};\n        assert Arrays.equals(solution.countPairsOfConnectableServers(edges_1, signalSpeed_1), ans_1);\n        int[][] edges_2 = {{0,6,3},{6,5,3},{0,3,1},{3,2,7},{3,1,6},{3,4,2}};\n        int signalSpeed_2 = 3;\n        int[] ans_2 = {2,0,0,0,0,0,2};\n        assert Arrays.equals(solution.countPairsOfConnectableServers(edges_2, signalSpeed_2), ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int[] countPairsOfConnectableServers(int[][] edges, int signalSpeed) {",
        "function_name": "countPairsOfConnectableServers",
        "difficulty_level": "Middle",
        "time": "20240302"
    },
    {
        "id": "3068",
        "prompt_base": "\"\"\"\n给你一棵 n 个节点的 无向 树，节点从 0 到 n - 1 编号。树以长度为 n - 1 下标从 0 开始的二维整数数组 edges 的形式给你，其中 edges[i] = [u_i, v_i] 表示树中节点 u_i 和 v_i 之间有一条边。同时给你一个 正 整数 k 和一个长度为 n 下标从 0 开始的 非负 整数数组 nums ，其中 nums[i] 表示节点 i 的 价值 。\nAlice 想 最大化 树中所有节点价值之和。为了实现这一目标，Alice 可以执行以下操作 任意 次（包括 0 次）：\n选择连接节点 u 和 v 的边 [u, v] ，并将它们的值更新为：\nnums[u] = nums[u] XOR k\nnums[v] = nums[v] XOR k\n请你返回 Alice 通过执行以上操作 任意次 后，可以得到所有节点 价值之和 的 最大值 。\n示例 1：\n输入nums = [1,2,1], k = 3, edges = [[0,1],[0,2]]\n输出：6示例 2：\n输入nums = [2,3], k = 7, edges = [[0,1]]\n输出：9\n\n提示：\n2 <= n == nums.length <= 2 * 10^4\n1 <= k <= 10^9\n0 <= nums[i] <= 10^9\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\n输入保证 edges 构成一棵合法的树。\n\"\"\"\n\nclass Solution {\n    public long maximumValueSum(int[] nums, int k, int[][] edges) {",
        "prompt_chat": "给你一棵 n 个节点的 无向 树，节点从 0 到 n - 1 编号。树以长度为 n - 1 下标从 0 开始的二维整数数组 edges 的形式给你，其中 edges[i] = [u_i, v_i] 表示树中节点 u_i 和 v_i 之间有一条边。同时给你一个 正 整数 k 和一个长度为 n 下标从 0 开始的 非负 整数数组 nums ，其中 nums[i] 表示节点 i 的 价值 。\nAlice 想 最大化 树中所有节点价值之和。为了实现这一目标，Alice 可以执行以下操作 任意 次（包括 0 次）：\n选择连接节点 u 和 v 的边 [u, v] ，并将它们的值更新为：\nnums[u] = nums[u] XOR k\nnums[v] = nums[v] XOR k\n请你返回 Alice 通过执行以上操作 任意次 后，可以得到所有节点 价值之和 的 最大值 。\n示例 1：\n输入nums = [1,2,1], k = 3, edges = [[0,1],[0,2]]\n输出：6示例 2：\n输入nums = [2,3], k = 7, edges = [[0,1]]\n输出：9\n\n提示：\n2 <= n == nums.length <= 2 * 10^4\n1 <= k <= 10^9\n0 <= nums[i] <= 10^9\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\n输入保证 edges 构成一棵合法的树。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long maximumValueSum(int[] nums, int k, int[][] edges) {\n```",
        "solution": "class Solution {\n    public long maximumValueSum(int[] nums, int k, int[][] edges) {\n        int n = nums.length;\n        List<Integer>[] g = new ArrayList[n];\n        Arrays.setAll(g, i -> new ArrayList<>());\n        for (int[] e : edges) {\n            int x = e[0];\n            int y = e[1];\n            g[x].add(y);\n            g[y].add(x);\n        }\n        return dfs(0, -1, g, nums, k)[0];\n    }\n\n    private long[] dfs(int x, int fa, List<Integer>[] g, int[] nums, int k) {\n        long f0 = 0, f1 = Long.MIN_VALUE; // f[x][0] 和 f[x][1]\n        for (int y : g[x]) {\n            if (y != fa) {\n                long[] r = dfs(y, x, g, nums, k);\n                long t = Math.max(f1 + r[0], f0 + r[1]);\n                f0 = Math.max(f0 + r[0], f1 + r[1]);\n                f1 = t;\n            }\n        }\n        return new long[]{Math.max(f0 + nums[x], f1 + (nums[x] ^ k)),\n                          Math.max(f1 + nums[x], f0 + (nums[x] ^ k))};\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,1};\n        int k_1 = 3;\n        int[][] edges_1 = {{0,1},{0,2}};\n        long ans_1 = 6;\n        assert solution.maximumValueSum(nums_1, k_1, edges_1) == ans_1;\n        int[] nums_2 = {2,3};\n        int k_2 = 7;\n        int[][] edges_2 = {{0,1}};\n        long ans_2 = 9;\n        assert solution.maximumValueSum(nums_2, k_2, edges_2) == ans_2;\n        int[] nums_3 = {7,7,7,7,7,7};\n        int k_3 = 3;\n        int[][] edges_3 = {{0,1},{0,2},{0,3},{0,4},{0,5}};\n        long ans_3 = 42;\n        assert solution.maximumValueSum(nums_3, k_3, edges_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long maximumValueSum(int[] nums, int k, int[][] edges) {",
        "function_name": "maximumValueSum",
        "difficulty_level": "Hard",
        "time": "20240302"
    },
    {
        "id": "3079",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums ，数组中的元素都是 正 整数。定义一个加密函数 encrypt ，encrypt(x) 将一个整数 x 中 每一个 数位都用 x 中的 最大 数位替换。比方说 encrypt(523) = 555 且 encrypt(213) = 333 。\n请你返回数组中所有元素加密后的 和 。\n示例 1：\n输入nums = [1,2,3]\n输出：6示例 2：\n输入nums = [10,21,31]\n输出：66\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 1000\n\"\"\"\n\nclass Solution {\n    public int sumOfEncryptedInt(int[] nums) {",
        "prompt_chat": "给你一个整数数组 nums ，数组中的元素都是 正 整数。定义一个加密函数 encrypt ，encrypt(x) 将一个整数 x 中 每一个 数位都用 x 中的 最大 数位替换。比方说 encrypt(523) = 555 且 encrypt(213) = 333 。\n请你返回数组中所有元素加密后的 和 。\n示例 1：\n输入nums = [1,2,3]\n输出：6示例 2：\n输入nums = [10,21,31]\n输出：66\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 1000\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int sumOfEncryptedInt(int[] nums) {\n```",
        "solution": "class Solution {\n    public int sumOfEncryptedInt(int[] nums) {\n        int ans = 0;\n        for (int x : nums) {\n            int mx = 0;\n            int base = 0;\n            for (; x > 0; x /= 10) {\n                mx = Math.max(mx, x % 10);\n                base = base * 10 + 1;\n            }\n            ans += mx * base;\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,3};\n        int ans_1 = 6;\n        assert solution.sumOfEncryptedInt(nums_1) == ans_1;\n        int[] nums_2 = {10,21,31};\n        int ans_2 = 66;\n        assert solution.sumOfEncryptedInt(nums_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int sumOfEncryptedInt(int[] nums) {",
        "function_name": "sumOfEncryptedInt",
        "difficulty_level": "Easy",
        "time": "20240316"
    },
    {
        "id": "3080",
        "prompt_base": "\"\"\"\n给你一个长度为 n 下标从 0 开始的正整数数组 nums 。同时给你一个长度为 m 的二维操作数组 queries ，其中 queries[i] = [index_i, k_i] 。\n一开始，数组中的所有元素都 未标记 。你需要依次对数组执行 m 次操作，第 i 次操作中，你需要执行：\n如果下标 index_i 对应的元素还没标记，那么标记这个元素。\n然后标记 k_i 个数组中还没有标记的 最小 元素。如果有元素的值相等，那么优先标记它们中下标较小的。如果少于 k_i 个未标记元素存在，那么将它们全部标记。\n请你返回一个长度为 m 的数组 answer ，其中 answer[i]是第 i 次操作后数组中还没标记元素的 和 。\n示例 1：\n输入nums = [1,2,2,1,2,3,1], queries = [[1,2],[3,3],[4,2]]\n输出：[8,3,0]示例 2：\n输入nums = [1,4,2,3], queries = [[0,1]]\n输出：[7]\n\n提示：\nn == nums.length\nm == queries.length\n1 <= m <= n <= 10^5\n1 <= nums[i] <= 10^5\nqueries[i].length == 2\n0 <= index_i, k_i <= n - 1\n\"\"\"\n\nclass Solution {\n    public long[] unmarkedSumArray(int[] nums, int[][] queries) {",
        "prompt_chat": "给你一个长度为 n 下标从 0 开始的正整数数组 nums 。同时给你一个长度为 m 的二维操作数组 queries ，其中 queries[i] = [index_i, k_i] 。\n一开始，数组中的所有元素都 未标记 。你需要依次对数组执行 m 次操作，第 i 次操作中，你需要执行：\n如果下标 index_i 对应的元素还没标记，那么标记这个元素。\n然后标记 k_i 个数组中还没有标记的 最小 元素。如果有元素的值相等，那么优先标记它们中下标较小的。如果少于 k_i 个未标记元素存在，那么将它们全部标记。\n请你返回一个长度为 m 的数组 answer ，其中 answer[i]是第 i 次操作后数组中还没标记元素的 和 。\n示例 1：\n输入nums = [1,2,2,1,2,3,1], queries = [[1,2],[3,3],[4,2]]\n输出：[8,3,0]示例 2：\n输入nums = [1,4,2,3], queries = [[0,1]]\n输出：[7]\n\n提示：\nn == nums.length\nm == queries.length\n1 <= m <= n <= 10^5\n1 <= nums[i] <= 10^5\nqueries[i].length == 2\n0 <= index_i, k_i <= n - 1\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long[] unmarkedSumArray(int[] nums, int[][] queries) {\n```",
        "solution": "class Solution {\n    public long[] unmarkedSumArray(int[] nums, int[][] queries) {\n        int n = nums.length;\n        long s = 0;\n        Integer[] ids = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            s += nums[i];\n            ids[i] = i;\n        }\n        Arrays.sort(ids, (i, j) -> nums[i] - nums[j]); // 稳定排序\n\n        long[] ans = new long[queries.length];\n        int j = 0;\n        for (int qi = 0; qi < queries.length; qi++) {\n            int[] q = queries[qi];\n            int i = q[0];\n            int k = q[1];\n            s -= nums[i];\n            nums[i] = 0; // 标记\n            for (; j < n && k > 0; j++) {\n                i = ids[j];\n                if (nums[i] > 0) { // 没有被标记\n                    s -= nums[i];\n                    nums[i] = 0;\n                    k--;\n                }\n            }\n            ans[qi] = s;\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,2,1,2,3,1};\n        int[][] queries_1 = {{1,2},{3,3},{4,2}};\n        long[] ans_1 = {8,3,0};\n        assert Arrays.equals(solution.unmarkedSumArray(nums_1, queries_1), ans_1);\n        int[] nums_2 = {1,4,2,3};\n        int[][] queries_2 = {{0,1}};\n        long[] ans_2 = {7};\n        assert Arrays.equals(solution.unmarkedSumArray(nums_2, queries_2), ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long[] unmarkedSumArray(int[] nums, int[][] queries) {",
        "function_name": "unmarkedSumArray",
        "difficulty_level": "Middle",
        "time": "20240316"
    },
    {
        "id": "3081",
        "prompt_base": "\"\"\"\n给你一个字符串 s 。s[i] 要么是小写英文字母，要么是问号 '?' 。\n对于长度为 m 且 只 含有小写英文字母的字符串 t ，我们定义函数 cost(i) 为下标 i 之前（也就是范围 [0, i - 1] 中）出现过与 t[i] 相同 字符出现的次数。\n字符串 t 的 分数 为所有下标 i 的 cost(i) 之 和 。比方说，字符串 t = \\\"aab\\\" ：\ncost(0) = 0\ncost(1) = 1\ncost(2) = 0\n所以，字符串 \\\"aab\\\" 的分数为 0 + 1 + 0 = 1 。\n你的任务是用小写英文字母 替换 s 中 所有 问号，使 s 的 分数最小 。\n请你返回替换所有问号 '?' 之后且分数最小的字符串。如果有多个字符串的 分数最小 ，那么返回字典序最小的一个。\n示例 1：\n输入s = \"???\"\n输出：\"abc\"示例 2：\n输入s = \"a?a?\"\n输出：\"abac\"\n\n提示：\n1 <= s.length <= 10^5\ns[i] 要么是小写英文字母，要么是 '?' 。\n\"\"\"\n\nclass Solution {\n    public String minimizeStringValue(String s) {",
        "prompt_chat": "给你一个字符串 s 。s[i] 要么是小写英文字母，要么是问号 '?' 。\n对于长度为 m 且 只 含有小写英文字母的字符串 t ，我们定义函数 cost(i) 为下标 i 之前（也就是范围 [0, i - 1] 中）出现过与 t[i] 相同 字符出现的次数。\n字符串 t 的 分数 为所有下标 i 的 cost(i) 之 和 。比方说，字符串 t = \\\"aab\\\" ：\ncost(0) = 0\ncost(1) = 1\ncost(2) = 0\n所以，字符串 \\\"aab\\\" 的分数为 0 + 1 + 0 = 1 。\n你的任务是用小写英文字母 替换 s 中 所有 问号，使 s 的 分数最小 。\n请你返回替换所有问号 '?' 之后且分数最小的字符串。如果有多个字符串的 分数最小 ，那么返回字典序最小的一个。\n示例 1：\n输入s = \"???\"\n输出：\"abc\"示例 2：\n输入s = \"a?a?\"\n输出：\"abac\"\n\n提示：\n1 <= s.length <= 10^5\ns[i] 要么是小写英文字母，要么是 '?' 。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public String minimizeStringValue(String s) {\n```",
        "solution": "class Solution {\n    public String minimizeStringValue(String S) {\n        char[] s = S.toCharArray();\n        int[] freq = new int[26];\n        int q = 0;\n        for (char c : s) {\n            if (c != '?') {\n                freq[c - 'a']++;\n            } else {\n                q++;\n            }\n        }\n        PriorityQueue<Pair<Integer, Character>> pq = new PriorityQueue<>(26, (a, b) -> {\n            int c = a.getKey().compareTo(b.getKey());\n            return c != 0 ? c : a.getValue().compareTo(b.getValue());\n        });\n        for (char c = 'a'; c <= 'z'; c++) {\n            pq.add(new Pair<>(freq[c - 'a'], c));\n        }\n\n        char[] t = new char[q];\n        for (int i = 0; i < q; i++) {\n            Pair<Integer, Character> p = pq.poll();\n            char c = p.getValue();\n            t[i] = c;\n            pq.add(new Pair<>(p.getKey() + 1, c)); // 出现次数加一\n        }\n        Arrays.sort(t); // 排序，因为要求字典序最小\n\n        for (int i = 0, j = 0; i < s.length; i++) {\n            if (s[i] == '?') {\n                s[i] = t[j++]; // 填入字母\n            }\n        }\n        return new String(s);\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s_1 = \"???\";\n        String ans_1 = \"abc\";\n    assert solution.minimizeStringValue(s_1).equals(ans_1);\n        String s_2 = \"a?a?\";\n        String ans_2 = \"abac\";\n    assert solution.minimizeStringValue(s_2).equals(ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public String minimizeStringValue(String s) {",
        "function_name": "minimizeStringValue",
        "difficulty_level": "Middle",
        "time": "20240316"
    },
    {
        "id": "3082",
        "prompt_base": "\"\"\"\n给你一个长度为 n 的整数数组 nums 和一个 正 整数 k 。\n一个整数数组的 能量 定义为和 等于 k 的子序列的数目。\n请你返回 nums 中所有子序列的 能量和 。\n由于答案可能很大，请你将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入nums = [1,2,3], k = 3\n输出：6示例 2：\n输入nums = [2,3,3], k = 5\n输出：4\n\n提示：\n1 <= n <= 100\n1 <= nums[i] <= 10^4\n1 <= k <= 100\n\"\"\"\n\nclass Solution {\n    public int sumOfPower(int[] nums, int k) {",
        "prompt_chat": "给你一个长度为 n 的整数数组 nums 和一个 正 整数 k 。\n一个整数数组的 能量 定义为和 等于 k 的子序列的数目。\n请你返回 nums 中所有子序列的 能量和 。\n由于答案可能很大，请你将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入nums = [1,2,3], k = 3\n输出：6示例 2：\n输入nums = [2,3,3], k = 5\n输出：4\n\n提示：\n1 <= n <= 100\n1 <= nums[i] <= 10^4\n1 <= k <= 100\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int sumOfPower(int[] nums, int k) {\n```",
        "solution": "class Solution {\n    public int sumOfPower(int[] nums, int k) {\n        final int MOD = 1_000_000_007;\n        int n = nums.length;\n        int[][] f = new int[k + 1][n + 1];\n        f[0][0] = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = k; j >= nums[i]; j--) {\n                for (int c = i + 1; c > 0; c--) {\n                    f[j][c] = (f[j][c] + f[j - nums[i]][c - 1]) % MOD;\n                }\n            }\n        }\n\n        long ans = 0;\n        int pow2 = 1;\n        for (int i = n; i > 0; i--) {\n            ans = (ans + (long) f[k][i] * pow2) % MOD;\n            pow2 = pow2 * 2 % MOD;\n        }\n        return (int) ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,3};\n        int k_1 = 3;\n        int ans_1 = 6;\n        assert solution.sumOfPower(nums_1, k_1) == ans_1;\n        int[] nums_2 = {2,3,3};\n        int k_2 = 5;\n        int ans_2 = 4;\n        assert solution.sumOfPower(nums_2, k_2) == ans_2;\n        int[] nums_3 = {1,2,3};\n        int k_3 = 7;\n        int ans_3 = 0;\n        assert solution.sumOfPower(nums_3, k_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int sumOfPower(int[] nums, int k) {",
        "function_name": "sumOfPower",
        "difficulty_level": "Hard",
        "time": "20240316"
    },
    {
        "id": "3095",
        "prompt_base": "\"\"\"\n给你一个 非负 整数数组 nums 和一个整数 k 。\n如果一个数组中所有元素的按位或运算 OR 的值 至少 为 k ，那么我们称这个数组是 特别的 。\n请你返回 nums 中 最短特别非空 子数组的长度，如果特别子数组不存在，那么返回 -1 。\n示例 1：\n输入nums = [1,2,3], k = 2\n输出：1示例 2：\n输入nums = [2,1,8], k = 10\n输出：3\n\n提示：\n1 <= nums.length <= 50\n0 <= nums[i] <= 50\n0 <= k < 64\n\"\"\"\n\nclass Solution {\n    public int minimumSubarrayLength(int[] nums, int k) {",
        "prompt_chat": "给你一个 非负 整数数组 nums 和一个整数 k 。\n如果一个数组中所有元素的按位或运算 OR 的值 至少 为 k ，那么我们称这个数组是 特别的 。\n请你返回 nums 中 最短特别非空 子数组的长度，如果特别子数组不存在，那么返回 -1 。\n示例 1：\n输入nums = [1,2,3], k = 2\n输出：1示例 2：\n输入nums = [2,1,8], k = 10\n输出：3\n\n提示：\n1 <= nums.length <= 50\n0 <= nums[i] <= 50\n0 <= k < 64\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumSubarrayLength(int[] nums, int k) {\n```",
        "solution": "class Solution {\n    public int minimumSubarrayLength(int[] nums, int k) {\n        int ans = Integer.MAX_VALUE;\n        List<int[]> ors = new ArrayList<>(); // 保存 (右端点为 i 的子数组 OR, 该子数组左端点的最大值)\n        for (int i = 0; i < nums.length; i++) {\n            ors.add(new int[]{0, i});\n            int j = 0;\n            for (int[] or : ors) {\n                or[0] |= nums[i];\n                if (or[0] >= k) {\n                    ans = Math.min(ans, i - or[1] + 1);\n                }\n                if (ors.get(j)[0] == or[0]) {\n                    ors.get(j)[1] = or[1]; // 原地去重：合并相同值，左端点取靠右的\n                } else {\n                    ors.set(++j, or);\n                }\n            }\n            ors.subList(j + 1, ors.size()).clear(); // 去重：移除多余元素\n        }\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,3};\n        int k_1 = 2;\n        int ans_1 = 1;\n        assert solution.minimumSubarrayLength(nums_1, k_1) == ans_1;\n        int[] nums_2 = {2,1,8};\n        int k_2 = 10;\n        int ans_2 = 3;\n        assert solution.minimumSubarrayLength(nums_2, k_2) == ans_2;\n        int[] nums_3 = {1,2};\n        int k_3 = 0;\n        int ans_3 = 1;\n        assert solution.minimumSubarrayLength(nums_3, k_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumSubarrayLength(int[] nums, int k) {",
        "function_name": "minimumSubarrayLength",
        "difficulty_level": "Easy",
        "time": "20240330"
    },
    {
        "id": "3096",
        "prompt_base": "\"\"\"\n给你一个长度为 n 的二进制数组 possible 。\nAlice 和 Bob 正在玩一个有 n 个关卡的游戏，游戏中有一些关卡是 困难 模式，其他的关卡是 简单 模式。如果 possible[i] == 0 ，那么第 i 个关卡是 困难 模式。一个玩家通过一个简单模式的关卡可以获得 1 分，通过困难模式的关卡将失去 1 分。\n游戏的一开始，Alice 将从第 0 级开始 按顺序 完成一些关卡，然后 Bob 会完成剩下的所有关卡。\n假设两名玩家都采取最优策略，目的是 最大化 自己的得分，Alice 想知道自己 最少 需要完成多少个关卡，才能获得比 Bob 更多的分数。\n请你返回 Alice 获得比 Bob 更多的分数所需要完成的 最少 关卡数目，如果 无法 达成，那么返回 -1 。\n注意，每个玩家都至少需要完成 1 个关卡。\n示例 1：\n输入possible = [1,0,1,0]\n输出：1示例 2：\n输入possible = [1,1,1,1,1]\n输出：3\n\n提示：\n2 <= n == possible.length <= 10^5\npossible[i] 要么是 0 要么是 1 。\n\"\"\"\n\nclass Solution {\n    public int minimumLevels(int[] possible) {",
        "prompt_chat": "给你一个长度为 n 的二进制数组 possible 。\nAlice 和 Bob 正在玩一个有 n 个关卡的游戏，游戏中有一些关卡是 困难 模式，其他的关卡是 简单 模式。如果 possible[i] == 0 ，那么第 i 个关卡是 困难 模式。一个玩家通过一个简单模式的关卡可以获得 1 分，通过困难模式的关卡将失去 1 分。\n游戏的一开始，Alice 将从第 0 级开始 按顺序 完成一些关卡，然后 Bob 会完成剩下的所有关卡。\n假设两名玩家都采取最优策略，目的是 最大化 自己的得分，Alice 想知道自己 最少 需要完成多少个关卡，才能获得比 Bob 更多的分数。\n请你返回 Alice 获得比 Bob 更多的分数所需要完成的 最少 关卡数目，如果 无法 达成，那么返回 -1 。\n注意，每个玩家都至少需要完成 1 个关卡。\n示例 1：\n输入possible = [1,0,1,0]\n输出：1示例 2：\n输入possible = [1,1,1,1,1]\n输出：3\n\n提示：\n2 <= n == possible.length <= 10^5\npossible[i] 要么是 0 要么是 1 。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumLevels(int[] possible) {\n```",
        "solution": "class Solution {\n    public int minimumLevels(int[] possible) {\n        // cnt1 - cnt0 = cnt1 - (n - cnt1) = cnt1 * 2 - n\n        int n = possible.length;\n        int s = 0;\n        for (int x : possible) {\n            s += x;\n        }\n        s = s * 2 - n;\n        int pre = 0;\n        for (int i = 0; i < n - 1; i++) {\n            pre += possible[i] == 1 ? 2 : -2;\n            if (pre > s) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] possible_1 = {1,0,1,0};\n        int ans_1 = 1;\n        assert solution.minimumLevels(possible_1) == ans_1;\n        int[] possible_2 = {1,1,1,1,1};\n        int ans_2 = 3;\n        assert solution.minimumLevels(possible_2) == ans_2;\n        int[] possible_3 = {0,0};\n        int ans_3 = -1;\n        assert solution.minimumLevels(possible_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumLevels(int[] possible) {",
        "function_name": "minimumLevels",
        "difficulty_level": "Middle",
        "time": "20240330"
    },
    {
        "id": "3097",
        "prompt_base": "\"\"\"\n给你一个 非负 整数数组 nums 和一个整数 k 。\n如果一个数组中所有元素的按位或运算 OR 的值 至少 为 k ，那么我们称这个数组是 特别的 。\n请你返回 nums 中 最短特别非空 子数组的长度，如果特别子数组不存在，那么返回 -1 。\n示例 1：\n输入nums = [1,2,3], k = 2\n输出：1示例 2：\n输入nums = [2,1,8], k = 10\n输出：3\n\n提示：\n1 <= nums.length <= 2 * 10^5\n0 <= nums[i] <= 10^9\n0 <= k <= 10^9\n\"\"\"\n\nclass Solution {\n    public int minimumSubarrayLength(int[] nums, int k) {",
        "prompt_chat": "给你一个 非负 整数数组 nums 和一个整数 k 。\n如果一个数组中所有元素的按位或运算 OR 的值 至少 为 k ，那么我们称这个数组是 特别的 。\n请你返回 nums 中 最短特别非空 子数组的长度，如果特别子数组不存在，那么返回 -1 。\n示例 1：\n输入nums = [1,2,3], k = 2\n输出：1示例 2：\n输入nums = [2,1,8], k = 10\n输出：3\n\n提示：\n1 <= nums.length <= 2 * 10^5\n0 <= nums[i] <= 10^9\n0 <= k <= 10^9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumSubarrayLength(int[] nums, int k) {\n```",
        "solution": "class Solution {\n    public int minimumSubarrayLength(int[] nums, int k) {\n        int ans = Integer.MAX_VALUE;\n        int[][] ors = new int[32][2]; // 保存 (右端点为 i 的子数组 OR, 该子数组左端点的最大值)\n        int m = 0;\n        for (int i = 0; i < nums.length; i++) {\n            ors[m][0] = 0;\n            ors[m++][1] = i;\n            int j = 0;\n            for (int idx = 0; idx < m; idx++) {\n                ors[idx][0] |= nums[i];\n                if (ors[idx][0] >= k) {\n                    ans = Math.min(ans, i - ors[idx][1] + 1);\n                }\n                if (ors[j][0] != ors[idx][0]) {\n                    ors[++j][0] = ors[idx][0];\n                }\n                ors[j][1] = ors[idx][1];\n            }\n            m = j + 1; // 去重：移除多余元素\n        }\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,3};\n        int k_1 = 2;\n        int ans_1 = 1;\n        assert solution.minimumSubarrayLength(nums_1, k_1) == ans_1;\n        int[] nums_2 = {2,1,8};\n        int k_2 = 10;\n        int ans_2 = 3;\n        assert solution.minimumSubarrayLength(nums_2, k_2) == ans_2;\n        int[] nums_3 = {1,2};\n        int k_3 = 0;\n        int ans_3 = 1;\n        assert solution.minimumSubarrayLength(nums_3, k_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumSubarrayLength(int[] nums, int k) {",
        "function_name": "minimumSubarrayLength",
        "difficulty_level": "Middle",
        "time": "20240330"
    },
    {
        "id": "3098",
        "prompt_base": "\"\"\"\n给你一个长度为 n 的整数数组 nums 和一个 正 整数 k 。\n一个子序列的 能量 定义为子序列中 任意 两个元素的差值绝对值的 最小值 。\n请你返回 nums 中长度 等于 k 的 所有 子序列的 能量和 。\n由于答案可能会很大，将答案对 10^9 + 7 取余 后返回。\n示例 1：\n输入nums = [1,2,3,4], k = 3\n输出：4示例 2：\n输入nums = [2,2], k = 2\n输出：0\n\n提示：\n2 <= n == nums.length <= 50\n-10^8 <= nums[i] <= 10^8\n2 <= k <= n\n\"\"\"\n\nclass Solution {\n    public int sumOfPowers(int[] nums, int k) {",
        "prompt_chat": "给你一个长度为 n 的整数数组 nums 和一个 正 整数 k 。\n一个子序列的 能量 定义为子序列中 任意 两个元素的差值绝对值的 最小值 。\n请你返回 nums 中长度 等于 k 的 所有 子序列的 能量和 。\n由于答案可能会很大，将答案对 10^9 + 7 取余 后返回。\n示例 1：\n输入nums = [1,2,3,4], k = 3\n输出：4示例 2：\n输入nums = [2,2], k = 2\n输出：0\n\n提示：\n2 <= n == nums.length <= 50\n-10^8 <= nums[i] <= 10^8\n2 <= k <= n\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int sumOfPowers(int[] nums, int k) {\n```",
        "solution": "class Solution {\n    int MOD = (int) 1e9 + 7;\n    Map<String , Long> memo;\n    public int sumOfPowers(int[] nums, int k) {\n        memo = new HashMap<>();\n        Arrays.sort(nums);\n        //递归入口 ， pre 和 min 取Integer.MAX_VALUE / 2 ，防止计算负数时溢出\n        return (int) dfs(nums.length - 1 , k , Integer.MAX_VALUE / 2 , Integer.MAX_VALUE / 2 , nums);\n    }\n    long dfs(int i , int rest , int pre , int min , int[] nums){\n        //当前剩余i + 1 个数字， 剩余数字小于还要选择的数字， 怎么选都不能够选出k个数 ， 返回0\n        if (i + 1 < rest){\n            return 0;\n        }\n        //选够了\n        if (rest == 0){\n            return min;\n        }\n        //把当前状态 映射为字符串\n        String key = i + \"#\" + rest + \"#\" + pre + \"#\" + min;\n        //如果之前计算过\n        if (memo.containsKey(key)){\n            return memo.get(key);\n        }\n        //不选 当前元素\n        long res1 = dfs(i - 1, rest , pre , min , nums);\n        //选 当前元素\n        long res2 = dfs(i - 1 , rest - 1 , nums[i] , Math.min(min , pre - nums[i]) , nums);\n        memo.put(key , (res1 + res2) % MOD);\n        return (res1 + res2) % MOD;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,3,4};\n        int k_1 = 3;\n        int ans_1 = 4;\n        assert solution.sumOfPowers(nums_1, k_1) == ans_1;\n        int[] nums_2 = {2,2};\n        int k_2 = 2;\n        int ans_2 = 0;\n        assert solution.sumOfPowers(nums_2, k_2) == ans_2;\n        int[] nums_3 = {4,3,-1};\n        int k_3 = 2;\n        int ans_3 = 10;\n        assert solution.sumOfPowers(nums_3, k_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int sumOfPowers(int[] nums, int k) {",
        "function_name": "sumOfPowers",
        "difficulty_level": "Hard",
        "time": "20240330"
    },
    {
        "id": "3110",
        "prompt_base": "\"\"\"\n给你一个字符串 s 。一个字符串的 分数 定义为相邻字符 ASCII 码差值绝对值的和。请你返回 s 的 分数 。\n示例 1：\n输入s = \"hello\"\n输出：13示例 2：\n输入s = \"zaz\"\n输出：50\n\n提示：\n2 <= s.length <= 100\ns 只包含小写英文字母。\n\"\"\"\n\nclass Solution {\n    public int scoreOfString(String s) {",
        "prompt_chat": "给你一个字符串 s 。一个字符串的 分数 定义为相邻字符 ASCII 码差值绝对值的和。请你返回 s 的 分数 。\n示例 1：\n输入s = \"hello\"\n输出：13示例 2：\n输入s = \"zaz\"\n输出：50\n\n提示：\n2 <= s.length <= 100\ns 只包含小写英文字母。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int scoreOfString(String s) {\n```",
        "solution": "class Solution {\n    public int scoreOfString(String S) {\n        char[] s = S.toCharArray();\n        int ans = 0;\n        for (int i = 1; i < s.length; i++) {\n            ans += Math.abs(s[i] - s[i - 1]);\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s_1 = \"hello\";\n        int ans_1 = 13;\n        assert solution.scoreOfString(s_1) == ans_1;\n        String s_2 = \"zaz\";\n        int ans_2 = 50;\n        assert solution.scoreOfString(s_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int scoreOfString(String s) {",
        "function_name": "scoreOfString",
        "difficulty_level": "Easy",
        "time": "20240413"
    },
    {
        "id": "3111",
        "prompt_base": "\"\"\"\n给你一个二维整数数组 point ，其中 points[i] = [x_i, y_i] 表示二维平面内的一个点。同时给你一个整数 w 。你需要用矩形 覆盖所有 点。\n每个矩形的左下角在某个点 (x_1, 0) 处，且右上角在某个点 (x_2, y_2) 处，其中 x_1 <= x_2 且 y_2 >= 0 ，同时对于每个矩形都 必须 满足 x_2 - x_1 <= w 。\n如果一个点在矩形内或者在边上，我们说这个点被矩形覆盖了。\n请你在确保每个点都 至少 被一个矩形覆盖的前提下，最少 需要多少个矩形。\n注意：一个点可以被多个矩形覆盖。\n示例 1：\n输入points = [[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]], w = 1\n输出：2示例 2：\n输入points = [[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], w = 2\n输出：3\n\n提示：\n1 <= points.length <= 10^5\npoints[i].length == 2\n0 <= x_i == points[i][0] <= 10^9\n0 <= y_i == points[i][1] <= 10^9\n0 <= w <= 10^9\n所有点坐标 (x_i, y_i) 互不相同。\n\"\"\"\n\nclass Solution {\n    public int minRectanglesToCoverPoints(int[][] points, int w) {",
        "prompt_chat": "给你一个二维整数数组 point ，其中 points[i] = [x_i, y_i] 表示二维平面内的一个点。同时给你一个整数 w 。你需要用矩形 覆盖所有 点。\n每个矩形的左下角在某个点 (x_1, 0) 处，且右上角在某个点 (x_2, y_2) 处，其中 x_1 <= x_2 且 y_2 >= 0 ，同时对于每个矩形都 必须 满足 x_2 - x_1 <= w 。\n如果一个点在矩形内或者在边上，我们说这个点被矩形覆盖了。\n请你在确保每个点都 至少 被一个矩形覆盖的前提下，最少 需要多少个矩形。\n注意：一个点可以被多个矩形覆盖。\n示例 1：\n输入points = [[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]], w = 1\n输出：2示例 2：\n输入points = [[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], w = 2\n输出：3\n\n提示：\n1 <= points.length <= 10^5\npoints[i].length == 2\n0 <= x_i == points[i][0] <= 10^9\n0 <= y_i == points[i][1] <= 10^9\n0 <= w <= 10^9\n所有点坐标 (x_i, y_i) 互不相同。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minRectanglesToCoverPoints(int[][] points, int w) {\n```",
        "solution": "class Solution {\n    public int minRectanglesToCoverPoints(int[][] points, int w) {\n        Arrays.sort(points, (p, q) -> p[0] - q[0]);\n        int ans = 0;\n        int x2 = -1;\n        for (int[] p : points) {\n            if (p[0] > x2) {\n                ans++;\n                x2 = p[0] + w;\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] points_1 = {{2,1},{1,0},{1,4},{1,8},{3,5},{4,6}};\n        int w_1 = 1;\n        int ans_1 = 2;\n        assert solution.minRectanglesToCoverPoints(points_1, w_1) == ans_1;\n        int[][] points_2 = {{0,0},{1,1},{2,2},{3,3},{4,4},{5,5},{6,6}};\n        int w_2 = 2;\n        int ans_2 = 3;\n        assert solution.minRectanglesToCoverPoints(points_2, w_2) == ans_2;\n        int[][] points_3 = {{2,3},{1,2}};\n        int w_3 = 0;\n        int ans_3 = 2;\n        assert solution.minRectanglesToCoverPoints(points_3, w_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minRectanglesToCoverPoints(int[][] points, int w) {",
        "function_name": "minRectanglesToCoverPoints",
        "difficulty_level": "Middle",
        "time": "20240413"
    },
    {
        "id": "3112",
        "prompt_base": "\"\"\"\n给你一个二维数组 edges 表示一个 n 个点的无向图，其中 edges[i] = [u_i, v_i, length_i] 表示节点 u_i 和节点 v_i 之间有一条需要 length_i 单位时间通过的无向边。\n同时给你一个数组 disappear ，其中 disappear[i] 表示节点 i 从图中消失的时间点，在那一刻及以后，你无法再访问这个节点。\n注意，图有可能一开始是不连通的，两个节点之间也可能有多条边。\n请你返回数组 answer ，answer[i] 表示从节点 0 到节点 i 需要的 最少 单位时间。如果从节点 0 出发 无法 到达节点 i ，那么 answer[i] 为 -1 。\n示例 1：\n输入n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]\n输出：[0,-1,4]示例 2：\n输入n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]\n输出：[0,2,3]\n\n提示：\n1 <= n <= 5 * 10^4\n0 <= edges.length <= 10^5\nedges[i] == [u_i, v_i, length_i]\n0 <= u_i, v_i <= n - 1\n1 <= length_i <= 10^5\ndisappear.length == n\n1 <= disappear[i] <= 10^5\n\"\"\"\n\nclass Solution {\n    public int[] minimumTime(int n, int[][] edges, int[] disappear) {",
        "prompt_chat": "给你一个二维数组 edges 表示一个 n 个点的无向图，其中 edges[i] = [u_i, v_i, length_i] 表示节点 u_i 和节点 v_i 之间有一条需要 length_i 单位时间通过的无向边。\n同时给你一个数组 disappear ，其中 disappear[i] 表示节点 i 从图中消失的时间点，在那一刻及以后，你无法再访问这个节点。\n注意，图有可能一开始是不连通的，两个节点之间也可能有多条边。\n请你返回数组 answer ，answer[i] 表示从节点 0 到节点 i 需要的 最少 单位时间。如果从节点 0 出发 无法 到达节点 i ，那么 answer[i] 为 -1 。\n示例 1：\n输入n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]\n输出：[0,-1,4]示例 2：\n输入n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]\n输出：[0,2,3]\n\n提示：\n1 <= n <= 5 * 10^4\n0 <= edges.length <= 10^5\nedges[i] == [u_i, v_i, length_i]\n0 <= u_i, v_i <= n - 1\n1 <= length_i <= 10^5\ndisappear.length == n\n1 <= disappear[i] <= 10^5\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int[] minimumTime(int n, int[][] edges, int[] disappear) {\n```",
        "solution": "class Solution {\n    public int[] minimumTime(int n, int[][] edges, int[] disappear) {\n        List<int[]>[] g = new ArrayList[n]; // 稀疏图用邻接表\n        Arrays.setAll(g, i -> new ArrayList<>());\n        for (int[] e : edges) {\n            int x = e[0];\n            int y = e[1];\n            int wt = e[2];\n            g[x].add(new int[]{y, wt});\n            g[y].add(new int[]{x, wt});\n        }\n\n        int[] dis = new int[n];\n        Arrays.fill(dis, -1);\n        dis[0] = 0;\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[0] - b[0]));\n        pq.offer(new int[]{0, 0});\n        while (!pq.isEmpty()) {\n            int[] p = pq.poll();\n            int dx = p[0];\n            int x = p[1];\n            if (dx > dis[x]) { // x 之前出堆过\n                continue;\n            }\n            for (int[] e : g[x]) {\n                int y = e[0];\n                int newDis = dx + e[1];\n                if (newDis < disappear[y] && (dis[y] < 0 || newDis < dis[y])) {\n                    dis[y] = newDis; // 更新 x 的邻居的最短路\n                    pq.offer(new int[]{newDis, y});\n                }\n            }\n        }\n        return dis;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n_1 = 3;\n        int[][] edges_1 = {{0,1,2},{1,2,1},{0,2,4}};\n        int[] disappear_1 = {1,1,5};\n        int[] ans_1 = {0,-1,4};\n        assert Arrays.equals(solution.minimumTime(n_1, edges_1, disappear_1), ans_1);\n        int n_2 = 3;\n        int[][] edges_2 = {{0,1,2},{1,2,1},{0,2,4}};\n        int[] disappear_2 = {1,3,5};\n        int[] ans_2 = {0,2,3};\n        assert Arrays.equals(solution.minimumTime(n_2, edges_2, disappear_2), ans_2);\n        int n_3 = 2;\n        int[][] edges_3 = {{0,1,1}};\n        int[] disappear_3 = {1,1};\n        int[] ans_3 = {0,-1};\n        assert Arrays.equals(solution.minimumTime(n_3, edges_3, disappear_3), ans_3);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int[] minimumTime(int n, int[][] edges, int[] disappear) {",
        "function_name": "minimumTime",
        "difficulty_level": "Middle",
        "time": "20240413"
    },
    {
        "id": "3113",
        "prompt_base": "\"\"\"\n给你一个 正 整数数组 nums 。\n请你求出 nums 中有多少个子数组，满足子数组中 第一个 和 最后一个 元素都是这个子数组中的 最大 值。\n示例 1：\n输入nums = [1,4,3,3,2]\n输出：6示例 2：\n输入nums = [3,3,3]\n输出：6\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\n\"\"\"\n\nclass Solution {\n    public long numberOfSubarrays(int[] nums) {",
        "prompt_chat": "给你一个 正 整数数组 nums 。\n请你求出 nums 中有多少个子数组，满足子数组中 第一个 和 最后一个 元素都是这个子数组中的 最大 值。\n示例 1：\n输入nums = [1,4,3,3,2]\n输出：6示例 2：\n输入nums = [3,3,3]\n输出：6\n\n提示：\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long numberOfSubarrays(int[] nums) {\n```",
        "solution": "class Solution {\n    public long numberOfSubarrays(int[] nums) {\n        long ans = nums.length;\n        Deque<int[]> st = new ArrayDeque<>();\n        st.push(new int[]{Integer.MAX_VALUE, 0}); // 无穷大哨兵\n        for (int x : nums) {\n            while (x > st.peek()[0]) {\n                st.pop();\n            }\n            if (x == st.peek()[0]) {\n                ans += st.peek()[1]++;\n            } else {\n                st.push(new int[]{x, 1});\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,4,3,3,2};\n        long ans_1 = 6;\n        assert solution.numberOfSubarrays(nums_1) == ans_1;\n        int[] nums_2 = {3,3,3};\n        long ans_2 = 6;\n        assert solution.numberOfSubarrays(nums_2) == ans_2;\n        int[] nums_3 = {1};\n        long ans_3 = 1;\n        assert solution.numberOfSubarrays(nums_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long numberOfSubarrays(int[] nums) {",
        "function_name": "numberOfSubarrays",
        "difficulty_level": "Hard",
        "time": "20240413"
    },
    {
        "id": "3127",
        "prompt_base": "\"\"\"\n给你一个二维 3 x 3 的矩阵 grid ，每个格子都是一个字符，要么是 'B' ，要么是 'W' 。字符 'W' 表示白色，字符 'B' 表示黑色。\n你的任务是改变 至多一个 格子的颜色，使得矩阵中存在一个 2 x 2 颜色完全相同的正方形。\n如果可以得到一个相同颜色的 2 x 2 正方形，那么返回 true ，否则返回 false 。\n示例 1：\n输入grid = [[\"B\",\"W\",\"B\"],[\"B\",\"W\",\"W\"],[\"B\",\"W\",\"B\"]]\n输出：true示例 2：\n输入grid = [[\"B\",\"W\",\"B\"],[\"W\",\"B\",\"W\"],[\"B\",\"W\",\"B\"]]\n输出：false\n\n提示：\ngrid.length == 3\ngrid[i].length == 3\ngrid[i][j] 要么是 'W' ，要么是 'B' 。\n\"\"\"\n\nclass Solution {\n    public boolean canMakeSquare(char[][] grid) {",
        "prompt_chat": "给你一个二维 3 x 3 的矩阵 grid ，每个格子都是一个字符，要么是 'B' ，要么是 'W' 。字符 'W' 表示白色，字符 'B' 表示黑色。\n你的任务是改变 至多一个 格子的颜色，使得矩阵中存在一个 2 x 2 颜色完全相同的正方形。\n如果可以得到一个相同颜色的 2 x 2 正方形，那么返回 true ，否则返回 false 。\n示例 1：\n输入grid = [[\"B\",\"W\",\"B\"],[\"B\",\"W\",\"W\"],[\"B\",\"W\",\"B\"]]\n输出：true示例 2：\n输入grid = [[\"B\",\"W\",\"B\"],[\"W\",\"B\",\"W\"],[\"B\",\"W\",\"B\"]]\n输出：false\n\n提示：\ngrid.length == 3\ngrid[i].length == 3\ngrid[i][j] 要么是 'W' ，要么是 'B' 。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public boolean canMakeSquare(char[][] grid) {\n```",
        "solution": "class Solution {\n    public boolean canMakeSquare(char[][] grid) {\n        return check(grid, 0, 0) || check(grid, 0, 1) || check(grid, 1, 0) || check(grid, 1, 1);\n    }\n\n    private boolean check(char[][] grid, int i, int j) {\n        int[] cnt = new int[2];\n        cnt[grid[i][j] & 1]++;\n        cnt[grid[i][j + 1] & 1]++;\n        cnt[grid[i + 1][j] & 1]++;\n        cnt[grid[i + 1][j + 1] & 1]++;\n        return cnt[0] >= 3 || cnt[1] >= 3;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        char[][] grid_1 = {{'B','W','B'},{'B','W','W'},{'B','W','B'}};\n        boolean ans_1 = true;\n        assert solution.canMakeSquare(grid_1) == ans_1;\n        char[][] grid_2 = {{'B','W','B'},{'W','B','W'},{'B','W','B'}};\n        boolean ans_2 = false;\n        assert solution.canMakeSquare(grid_2) == ans_2;\n        char[][] grid_3 = {{'B','W','B'},{'B','W','W'},{'B','W','W'}};\n        boolean ans_3 = true;\n        assert solution.canMakeSquare(grid_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public boolean canMakeSquare(char[][] grid) {",
        "function_name": "canMakeSquare",
        "difficulty_level": "Easy",
        "time": "20240427"
    },
    {
        "id": "3128",
        "prompt_base": "\"\"\"\n给你一个二维 boolean 矩阵 grid 。请你返回使用 grid 中的 3 个元素可以构建的 直角三角形 数目，且满足 3 个元素值 都 为 1 。\n注意：\n如果 grid 中 3 个元素满足：一个元素与另一个元素在 同一行，同时与第三个元素在 同一列 ，那么这 3 个元素称为一个 直角三角形 。这 3 个元素互相之间不需要相邻。\n示例 1：\n输入grid = [[0,1,0],[0,1,1],[0,1,0]]\n输出：2示例 2：\n输入grid = [[1,0,0,0],[0,1,0,1],[1,0,0,0]]\n输出：0\n\n提示：\n1 <= grid.length <= 1000\n1 <= grid[i].length <= 1000\n0 <= grid[i][j] <= 1\n\"\"\"\n\nclass Solution {\n    public long numberOfRightTriangles(int[][] grid) {",
        "prompt_chat": "给你一个二维 boolean 矩阵 grid 。请你返回使用 grid 中的 3 个元素可以构建的 直角三角形 数目，且满足 3 个元素值 都 为 1 。\n注意：\n如果 grid 中 3 个元素满足：一个元素与另一个元素在 同一行，同时与第三个元素在 同一列 ，那么这 3 个元素称为一个 直角三角形 。这 3 个元素互相之间不需要相邻。\n示例 1：\n输入grid = [[0,1,0],[0,1,1],[0,1,0]]\n输出：2示例 2：\n输入grid = [[1,0,0,0],[0,1,0,1],[1,0,0,0]]\n输出：0\n\n提示：\n1 <= grid.length <= 1000\n1 <= grid[i].length <= 1000\n0 <= grid[i][j] <= 1\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long numberOfRightTriangles(int[][] grid) {\n```",
        "solution": "class Solution {\n    public long numberOfRightTriangles(int[][] grid) {\n        int n = grid[0].length;\n        int[] colSum = new int[n];\n        Arrays.fill(colSum, -1); // 提前减一\n        for (int j = 0; j < n; j++) {\n            for (int[] row : grid) {\n                colSum[j] += row[j];\n            }\n        }\n\n        long ans = 0;\n        for (int[] row : grid) {\n            int rowSum = -1; // 提前减一\n            for (int x : row) {\n                rowSum += x;\n            }\n            for (int j = 0; j < row.length; j++) {\n                if (row[j] == 1) {\n                    ans += rowSum * colSum[j];\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] grid_1 = {{0,1,0},{0,1,1},{0,1,0}};\n        long ans_1 = 2;\n        assert solution.numberOfRightTriangles(grid_1) == ans_1;\n        int[][] grid_2 = {{1,0,0,0},{0,1,0,1},{1,0,0,0}};\n        long ans_2 = 0;\n        assert solution.numberOfRightTriangles(grid_2) == ans_2;\n        int[][] grid_3 = {{1,0,1},{1,0,0},{1,0,0}};\n        long ans_3 = 2;\n        assert solution.numberOfRightTriangles(grid_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long numberOfRightTriangles(int[][] grid) {",
        "function_name": "numberOfRightTriangles",
        "difficulty_level": "Middle",
        "time": "20240427"
    },
    {
        "id": "3129",
        "prompt_base": "\"\"\"\n给你 3 个正整数 zero ，one 和 limit 。\n一个 二进制数组 arr 如果满足以下条件，那么我们称它是 稳定的 ：\n0 在 arr 中出现次数 恰好 为 zero 。\n1 在 arr 中出现次数 恰好 为 one 。\narr 中每个长度超过 limit 的 子数组 都 同时 包含 0 和 1 。\n请你返回 稳定 二进制数组的 总 数目。\n由于答案可能很大，将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入zero = 1, one = 1, limit = 2\n输出：2示例 2：\n输入zero = 1, one = 2, limit = 1\n输出：1\n\n提示：\n1 <= zero, one, limit <= 200\n\"\"\"\n\nclass Solution {\n    public int numberOfStableArrays(int zero, int one, int limit) {",
        "prompt_chat": "给你 3 个正整数 zero ，one 和 limit 。\n一个 二进制数组 arr 如果满足以下条件，那么我们称它是 稳定的 ：\n0 在 arr 中出现次数 恰好 为 zero 。\n1 在 arr 中出现次数 恰好 为 one 。\narr 中每个长度超过 limit 的 子数组 都 同时 包含 0 和 1 。\n请你返回 稳定 二进制数组的 总 数目。\n由于答案可能很大，将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入zero = 1, one = 1, limit = 2\n输出：2示例 2：\n输入zero = 1, one = 2, limit = 1\n输出：1\n\n提示：\n1 <= zero, one, limit <= 200\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int numberOfStableArrays(int zero, int one, int limit) {\n```",
        "solution": "class Solution {\n    private static final int MOD = 1_000_000_007;\n\n    public int numberOfStableArrays(int zero, int one, int limit) {\n        int[][][] memo = new int[zero + 1][one + 1][2];\n        for (int[][] m : memo) {\n            for (int[] m2 : m) {\n                Arrays.fill(m2, -1); // -1 表示没有计算过\n            }\n        }\n        return (dfs(zero, one, 0, limit, memo) + dfs(zero, one, 1, limit, memo)) % MOD;\n    }\n\n    private int dfs(int i, int j, int k, int limit, int[][][] memo) {\n        if (i == 0) { // 递归边界\n            return k == 1 && j <= limit ? 1 : 0;\n        }\n        if (j == 0) { // 递归边界\n            return k == 0 && i <= limit ? 1 : 0;\n        }\n        if (memo[i][j][k] != -1) { // 之前计算过\n            return memo[i][j][k];\n        }\n        if (k == 0) {\n            // + MOD 保证答案非负\n            memo[i][j][k] = (int) (((long) dfs(i - 1, j, 0, limit, memo) + dfs(i - 1, j, 1, limit, memo) +\n                    (i > limit ? MOD - dfs(i - limit - 1, j, 1, limit, memo) : 0)) % MOD);\n        } else {\n            memo[i][j][k] = (int) (((long) dfs(i, j - 1, 0, limit, memo) + dfs(i, j - 1, 1, limit, memo) +\n                    (j > limit ? MOD - dfs(i, j - limit - 1, 0, limit, memo) : 0)) % MOD);\n        }\n        return memo[i][j][k];\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int zero_1 = 1;\n        int one_1 = 1;\n        int limit_1 = 2;\n        int ans_1 = 2;\n        assert solution.numberOfStableArrays(zero_1, one_1, limit_1) == ans_1;\n        int zero_2 = 1;\n        int one_2 = 2;\n        int limit_2 = 1;\n        int ans_2 = 1;\n        assert solution.numberOfStableArrays(zero_2, one_2, limit_2) == ans_2;\n        int zero_3 = 3;\n        int one_3 = 3;\n        int limit_3 = 2;\n        int ans_3 = 14;\n        assert solution.numberOfStableArrays(zero_3, one_3, limit_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int numberOfStableArrays(int zero, int one, int limit) {",
        "function_name": "numberOfStableArrays",
        "difficulty_level": "Middle",
        "time": "20240427"
    },
    {
        "id": "3130",
        "prompt_base": "\"\"\"\n给你 3 个正整数 zero ，one 和 limit 。一个 二进制数组 arr 如果满足以下条件，那么我们称它是 稳定的 ：\n0 在 arr 中出现次数 恰好 为 zero 。\n1 在 arr 中出现次数 恰好 为 one 。\narr 中每个长度超过 limit 的 子数组 都 同时 包含 0 和 1 。\n请你返回 稳定 二进制数组的 总 数目。\n由于答案可能很大，将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入zero = 1, one = 1, limit = 2\n输出：2示例 2：\n输入zero = 1, one = 2, limit = 1\n输出：1\n\n提示：\n1 <= zero, one, limit <= 1000\n\"\"\"\n\nclass Solution {\n    public int numberOfStableArrays(int zero, int one, int limit) {",
        "prompt_chat": "给你 3 个正整数 zero ，one 和 limit 。一个 二进制数组 arr 如果满足以下条件，那么我们称它是 稳定的 ：\n0 在 arr 中出现次数 恰好 为 zero 。\n1 在 arr 中出现次数 恰好 为 one 。\narr 中每个长度超过 limit 的 子数组 都 同时 包含 0 和 1 。\n请你返回 稳定 二进制数组的 总 数目。\n由于答案可能很大，将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入zero = 1, one = 1, limit = 2\n输出：2示例 2：\n输入zero = 1, one = 2, limit = 1\n输出：1\n\n提示：\n1 <= zero, one, limit <= 1000\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int numberOfStableArrays(int zero, int one, int limit) {\n```",
        "solution": "class Solution {\n    public int numberOfStableArrays(int zero, int one, int limit) {\n        final int MOD = 1_000_000_007;\n        int[][][] f = new int[zero + 1][one + 1][2];\n        for (int i = 1; i <= Math.min(limit, zero); i++) {\n            f[i][0][0] = 1;\n        }\n        for (int j = 1; j <= Math.min(limit, one); j++) {\n            f[0][j][1] = 1;\n        }\n        for (int i = 1; i <= zero; i++) {\n            for (int j = 1; j <= one; j++) {\n                // + MOD 保证答案非负\n                f[i][j][0] = (int) (((long) f[i - 1][j][0] + f[i - 1][j][1] + (i > limit ? MOD - f[i - limit - 1][j][1] : 0)) % MOD);\n                f[i][j][1] = (int) (((long) f[i][j - 1][0] + f[i][j - 1][1] + (j > limit ? MOD - f[i][j - limit - 1][0] : 0)) % MOD);\n            }\n        }\n        return (f[zero][one][0] + f[zero][one][1]) % MOD;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int zero_1 = 1;\n        int one_1 = 1;\n        int limit_1 = 2;\n        int ans_1 = 2;\n        assert solution.numberOfStableArrays(zero_1, one_1, limit_1) == ans_1;\n        int zero_2 = 1;\n        int one_2 = 2;\n        int limit_2 = 1;\n        int ans_2 = 1;\n        assert solution.numberOfStableArrays(zero_2, one_2, limit_2) == ans_2;\n        int zero_3 = 3;\n        int one_3 = 3;\n        int limit_3 = 2;\n        int ans_3 = 14;\n        assert solution.numberOfStableArrays(zero_3, one_3, limit_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int numberOfStableArrays(int zero, int one, int limit) {",
        "function_name": "numberOfStableArrays",
        "difficulty_level": "Hard",
        "time": "20240427"
    },
    {
        "id": "3142",
        "prompt_base": "\"\"\"\n给你一个大小为 m x n 的二维矩阵 grid 。你需要判断每一个格子 grid[i][j] 是否满足：\n如果它下面的格子存在，那么它需要等于它下面的格子，也就是 grid[i][j] == grid[i + 1][j] 。\n如果它右边的格子存在，那么它需要不等于它右边的格子，也就是 grid[i][j] != grid[i][j + 1] 。\n如果 所有 格子都满足以上条件，那么返回 true ，否则返回 false 。\n示例 1：\n输入grid = [[1,0,2],[1,0,2]]\n输出：true示例 2：\n输入grid =  [[1,1,1],[0,0,0]]\n输出：false\n\n提示：\n1 <= n, m <= 10\n0 <= grid[i][j] <= 9\n\"\"\"\n\nclass Solution {\n    public boolean satisfiesConditions(int[][] grid) {",
        "prompt_chat": "给你一个大小为 m x n 的二维矩阵 grid 。你需要判断每一个格子 grid[i][j] 是否满足：\n如果它下面的格子存在，那么它需要等于它下面的格子，也就是 grid[i][j] == grid[i + 1][j] 。\n如果它右边的格子存在，那么它需要不等于它右边的格子，也就是 grid[i][j] != grid[i][j + 1] 。\n如果 所有 格子都满足以上条件，那么返回 true ，否则返回 false 。\n示例 1：\n输入grid = [[1,0,2],[1,0,2]]\n输出：true示例 2：\n输入grid =  [[1,1,1],[0,0,0]]\n输出：false\n\n提示：\n1 <= n, m <= 10\n0 <= grid[i][j] <= 9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public boolean satisfiesConditions(int[][] grid) {\n```",
        "solution": "class Solution {\n    public boolean satisfiesConditions(int[][] grid) {\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[i].length; j++) {\n                if (j > 0 && grid[i][j] == grid[i][j - 1] || i > 0 && grid[i][j] != grid[i - 1][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] grid_1 = {{1,0,2},{1,0,2}};\n        boolean ans_1 = true;\n        assert solution.satisfiesConditions(grid_1) == ans_1;\n        int[][] grid_2 =  {{1,1,1},{0,0,0}};\n        boolean ans_2 = false;\n        assert solution.satisfiesConditions(grid_2) == ans_2;\n        int[][] grid_3 = {{1},{2},{3}};\n        boolean ans_3 = false;\n        assert solution.satisfiesConditions(grid_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public boolean satisfiesConditions(int[][] grid) {",
        "function_name": "satisfiesConditions",
        "difficulty_level": "Easy",
        "time": "20240511"
    },
    {
        "id": "3143",
        "prompt_base": "\"\"\"\n给你一个二维数组 points 和一个字符串 s ，其中 points[i] 表示第 i 个点的坐标，s[i] 表示第 i 个点的 标签 。\n如果一个正方形的中心在 (0, 0) ，所有边都平行于坐标轴，且正方形内 不 存在标签相同的两个点，那么我们称这个正方形是 合法 的。\n请你返回 合法 正方形中可以包含的 最多 点数。\n注意：\n如果一个点位于正方形的边上或者在边以内，则认为该点位于正方形内。\n正方形的边长可以为零。\n示例 1：\n输入points = [[2,2],[-1,-2],[-4,4],[-3,1],[3,-3]], s = \"abdca\"\n输出：2示例 2：\n输入points = [[1,1],[-2,-2],[-2,2]], s = \"abb\"\n输出：1\n\n提示：\n1 <= s.length, points.length <= 10^5\npoints[i].length == 2\n-10^9 <= points[i][0], points[i][1] <= 10^9\ns.length == points.length\npoints 中的点坐标互不相同。\ns 只包含小写英文字母。\n\"\"\"\n\nclass Solution {\n    public int maxPointsInsideSquare(int[][] points, String s) {",
        "prompt_chat": "给你一个二维数组 points 和一个字符串 s ，其中 points[i] 表示第 i 个点的坐标，s[i] 表示第 i 个点的 标签 。\n如果一个正方形的中心在 (0, 0) ，所有边都平行于坐标轴，且正方形内 不 存在标签相同的两个点，那么我们称这个正方形是 合法 的。\n请你返回 合法 正方形中可以包含的 最多 点数。\n注意：\n如果一个点位于正方形的边上或者在边以内，则认为该点位于正方形内。\n正方形的边长可以为零。\n示例 1：\n输入points = [[2,2],[-1,-2],[-4,4],[-3,1],[3,-3]], s = \"abdca\"\n输出：2示例 2：\n输入points = [[1,1],[-2,-2],[-2,2]], s = \"abb\"\n输出：1\n\n提示：\n1 <= s.length, points.length <= 10^5\npoints[i].length == 2\n-10^9 <= points[i][0], points[i][1] <= 10^9\ns.length == points.length\npoints 中的点坐标互不相同。\ns 只包含小写英文字母。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maxPointsInsideSquare(int[][] points, String s) {\n```",
        "solution": "class Solution {\n    private int ans;\n\n    public int maxPointsInsideSquare(int[][] points, String S) {\n        char[] s = S.toCharArray();\n        int left = -1, right = 1_000_000_001;\n        while (left + 1 < right) {\n            int mid = (left + right) >>> 1;\n            if (check(mid, points, s)) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        return ans;\n    }\n\n    boolean check(int size, int[][] points, char[] s) {\n        int vis = 0;\n        for (int i = 0; i < points.length; i++) {\n            int x = points[i][0];\n            int y = points[i][1];\n            int c = s[i] - 'a';\n            if (Math.abs(x) <= size && Math.abs(y) <= size) {\n                if ((vis >> c & 1) > 0) {\n                    return false;\n                }\n                vis |= 1 << c;\n            }\n        }\n        ans = Integer.bitCount(vis);\n        return true;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] points_1 = {{2,2},{-1,-2},{-4,4},{-3,1},{3,-3}};\n        String s_1 = \"abdca\";\n        int ans_1 = 2;\n        assert solution.maxPointsInsideSquare(points_1, s_1) == ans_1;\n        int[][] points_2 = {{1,1},{-2,-2},{-2,2}};\n        String s_2 = \"abb\";\n        int ans_2 = 1;\n        assert solution.maxPointsInsideSquare(points_2, s_2) == ans_2;\n        int[][] points_3 = {{1,1},{-1,-1},{2,-2}};\n        String s_3 = \"ccd\";\n        int ans_3 = 0;\n        assert solution.maxPointsInsideSquare(points_3, s_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maxPointsInsideSquare(int[][] points, String s) {",
        "function_name": "maxPointsInsideSquare",
        "difficulty_level": "Middle",
        "time": "20240511"
    },
    {
        "id": "3144",
        "prompt_base": "\"\"\"\n给你一个字符串 s ，你需要将它分割成一个或者更多的 平衡 子字符串。比方说，s == \"ababcc\" 那么 (\"abab\", \"c\", \"c\") ，(\"ab\", \"abc\", \"c\") 和 (\"ababcc\") 都是合法分割，但是 (\"a\", \"bab\", \"cc\") ，(\"aba\", \"bc\", \"c\") 和 (\"ab\", \"abcc\") 不是，不平衡的子字符串用粗体表示。\n请你返回 s 最少 能分割成多少个平衡子字符串。\n注意：一个 平衡 字符串指的是字符串中所有字符出现的次数都相同。\n示例 1：\n输入s = \"fabccddg\"\n输出：3示例 2：\n输入s = \"abababaccddb\"\n输出：2\n\n提示：\n1 <= s.length <= 1000\ns 只包含小写英文字母。\n\"\"\"\n\nclass Solution {\n    public int minimumSubstringsInPartition(String s) {",
        "prompt_chat": "给你一个字符串 s ，你需要将它分割成一个或者更多的 平衡 子字符串。比方说，s == \"ababcc\" 那么 (\"abab\", \"c\", \"c\") ，(\"ab\", \"abc\", \"c\") 和 (\"ababcc\") 都是合法分割，但是 (\"a\", \"bab\", \"cc\") ，(\"aba\", \"bc\", \"c\") 和 (\"ab\", \"abcc\") 不是，不平衡的子字符串用粗体表示。\n请你返回 s 最少 能分割成多少个平衡子字符串。\n注意：一个 平衡 字符串指的是字符串中所有字符出现的次数都相同。\n示例 1：\n输入s = \"fabccddg\"\n输出：3示例 2：\n输入s = \"abababaccddb\"\n输出：2\n\n提示：\n1 <= s.length <= 1000\ns 只包含小写英文字母。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumSubstringsInPartition(String s) {\n```",
        "solution": "class Solution {\n    public int minimumSubstringsInPartition(String S) {\n        char[] s = S.toCharArray();\n        int n = s.length;\n        int[] memo = new int[n];\n        Arrays.fill(memo, -1); // -1 表示没有计算过\n        return dfs(n - 1, s, memo);\n    }\n\n    private int dfs(int i, char[] s, int[] memo) {\n        if (i < 0) {\n            return 0;\n        }\n        if (memo[i] != -1) { // 之前计算过\n            return memo[i];\n        }\n        int res = Integer.MAX_VALUE;\n        int[] cnt = new int[26];\n        int k = 0, maxCnt = 0;\n        for (int j = i; j >= 0; j--) {\n            k += cnt[s[j] - 'a']++ == 0 ? 1 : 0;\n            maxCnt = Math.max(maxCnt, cnt[s[j] - 'a']);\n            if (i - j + 1 == k * maxCnt) {\n                res = Math.min(res, dfs(j - 1, s, memo) + 1);\n            }\n        }\n        memo[i] = res; // 记忆化\n        return res;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s_1 = \"fabccddg\";\n        int ans_1 = 3;\n        assert solution.minimumSubstringsInPartition(s_1) == ans_1;\n        String s_2 = \"abababaccddb\";\n        int ans_2 = 2;\n        assert solution.minimumSubstringsInPartition(s_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumSubstringsInPartition(String s) {",
        "function_name": "minimumSubstringsInPartition",
        "difficulty_level": "Middle",
        "time": "20240511"
    },
    {
        "id": "3145",
        "prompt_base": "\"\"\"\n一个整数 x 的 强数组 指的是满足和为 x 的二的幂的最短有序数组。比方说，11 的强数组为 [1, 2, 8] 。\n我们将每一个正整数 i （即1，2，3等等）的 强数组 连接得到数组 big_nums ，big_nums 开始部分为 [\\underline{1}, \\underline{2}, \\underline{1, 2}, \\underline{4}, \\underline{1, 4}, \\underline{2, 4}, \\underline{1, 2, 4}, 8, ...] 。\n给你一个二维整数数组 queries ，其中 queries[i] = [from_i, to_i, mod_i] ，你需要计算 (big_nums[from_i] * big_nums[from_i + 1] * ... * big_nums[to_i]) % mod_i 。\n请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。\n示例 1：\n输入queries = [[1,3,7]]\n输出：[4]示例 2：\n输入queries = [[2,5,3],[7,7,4]]\n输出：[2,2]\n\n提示：\n1 <= queries.length <= 500\nqueries[i].length == 3\n0 <= queries[i][0] <= queries[i][1] <= 10^15\n1 <= queries[i][2] <= 10^5\n\"\"\"\n\nclass Solution {\n    public int[] findProductsOfElements(long[][] queries) {",
        "prompt_chat": "一个整数 x 的 强数组 指的是满足和为 x 的二的幂的最短有序数组。比方说，11 的强数组为 [1, 2, 8] 。\n我们将每一个正整数 i （即1，2，3等等）的 强数组 连接得到数组 big_nums ，big_nums 开始部分为 [\\underline{1}, \\underline{2}, \\underline{1, 2}, \\underline{4}, \\underline{1, 4}, \\underline{2, 4}, \\underline{1, 2, 4}, 8, ...] 。\n给你一个二维整数数组 queries ，其中 queries[i] = [from_i, to_i, mod_i] ，你需要计算 (big_nums[from_i] * big_nums[from_i + 1] * ... * big_nums[to_i]) % mod_i 。\n请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。\n示例 1：\n输入queries = [[1,3,7]]\n输出：[4]示例 2：\n输入queries = [[2,5,3],[7,7,4]]\n输出：[2,2]\n\n提示：\n1 <= queries.length <= 500\nqueries[i].length == 3\n0 <= queries[i][0] <= queries[i][1] <= 10^15\n1 <= queries[i][2] <= 10^5\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int[] findProductsOfElements(long[][] queries) {\n```",
        "solution": "class Solution {\n    public int[] findProductsOfElements(long[][] queries) {\n        int[] ans = new int[queries.length];\n        for (int i = 0; i < queries.length; i++) {\n            long[] q = queries[i];\n            long er = sumE(q[1] + 1);\n            long el = sumE(q[0]);\n            ans[i] = pow(2, er - el, q[2]);\n        }\n        return ans;\n    }\n\n    private long sumE(long k) {\n        long res = 0, n = 0, cnt1 = 0, sumI = 0;\n        for (long i = 63 - Long.numberOfLeadingZeros(k + 1); i > 0; i--) {\n            long c = (cnt1 << i) + (i << (i - 1)); // 新增的幂次个数\n            if (c <= k) {\n                k -= c;\n                res += (sumI << i) + ((i * (i - 1) / 2) << (i - 1));\n                sumI += i; // 之前填的 1 的幂次之和\n                cnt1++; // 之前填的 1 的个数\n                n |= 1L << i; // 填 1\n            }\n        }\n        // 最低位单独计算\n        if (cnt1 <= k) {\n            k -= cnt1;\n            res += sumI;\n            n++; // 填 1\n        }\n        // 剩余的 k 个幂次，由 n 的低 k 个 1 补充\n        while (k-- > 0) {\n            res += Long.numberOfTrailingZeros(n);\n            n &= n - 1;\n        }\n        return res;\n    }\n\n    private int pow(long x, long n, long mod) {\n        long res = 1 % mod;\n        for (; n > 0; n /= 2) {\n            if (n % 2 == 1) {\n                res = res * x % mod;\n            }\n            x = x * x % mod;\n        }\n        return (int) res;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        long[][] queries_1 = {{1,3,7}};\n        int[] ans_1 = {4};\n        assert Arrays.equals(solution.findProductsOfElements(queries_1), ans_1);\n        long[][] queries_2 = {{2,5,3},{7,7,4}};\n        int[] ans_2 = {2,2};\n        assert Arrays.equals(solution.findProductsOfElements(queries_2), ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int[] findProductsOfElements(long[][] queries) {",
        "function_name": "findProductsOfElements",
        "difficulty_level": "Hard",
        "time": "20240511"
    },
    {
        "id": "3158",
        "prompt_base": "\"\"\"\n给你一个数组 nums ，数组中的数字 要么 出现一次，要么 出现两次。\n请你返回数组中所有出现两次数字的按位 XOR 值，如果没有数字出现过两次，返回 0 。\n示例 1：\n输入nums = [1,2,1,3]\n输出：1示例 2：\n输入nums = [1,2,3]\n输出：0\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 50\nnums 中每个数字要么出现过一次，要么出现过两次。\n\"\"\"\n\nclass Solution {\n    public int duplicateNumbersXOR(int[] nums) {",
        "prompt_chat": "给你一个数组 nums ，数组中的数字 要么 出现一次，要么 出现两次。\n请你返回数组中所有出现两次数字的按位 XOR 值，如果没有数字出现过两次，返回 0 。\n示例 1：\n输入nums = [1,2,1,3]\n输出：1示例 2：\n输入nums = [1,2,3]\n输出：0\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 50\nnums 中每个数字要么出现过一次，要么出现过两次。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int duplicateNumbersXOR(int[] nums) {\n```",
        "solution": "class Solution {\n    public int duplicateNumbersXOR(int[] nums) {\n        int ans = 0;\n        long vis = 0;\n        for (int x : nums) {\n            if ((vis >> x & 1) > 0) {\n                ans ^= x;\n            } else {\n                vis |= 1L << x;\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,1,3};\n        int ans_1 = 1;\n        assert solution.duplicateNumbersXOR(nums_1) == ans_1;\n        int[] nums_2 = {1,2,3};\n        int ans_2 = 0;\n        assert solution.duplicateNumbersXOR(nums_2) == ans_2;\n        int[] nums_3 = {1,2,2,1};\n        int ans_3 = 3;\n        assert solution.duplicateNumbersXOR(nums_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int duplicateNumbersXOR(int[] nums) {",
        "function_name": "duplicateNumbersXOR",
        "difficulty_level": "Easy",
        "time": "20240525"
    },
    {
        "id": "3159",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums ，一个整数数组 queries 和一个整数 x 。\n对于每个查询 queries[i] ，你需要找到 nums 中第 queries[i] 个 x 的位置，并返回它的下标。如果数组中 x 的出现次数少于 queries[i] ，该查询的答案为 -1 。\n请你返回一个整数数组 answer ，包含所有查询的答案。\n示例 1：\n输入nums = [1,3,1,7], queries = [1,3,2,4], x = 1\n输出：[0,-1,2,-1]示例 2：\n输入nums = [1,2,3], queries = [10], x = 5\n输出：[-1]\n\n提示：\n1 <= nums.length, queries.length <= 10^5\n1 <= queries[i] <= 10^5\n1 <= nums[i], x <= 10^4\n\"\"\"\n\nclass Solution {\n    public int[] occurrencesOfElement(int[] nums, int[] queries, int x) {",
        "prompt_chat": "给你一个整数数组 nums ，一个整数数组 queries 和一个整数 x 。\n对于每个查询 queries[i] ，你需要找到 nums 中第 queries[i] 个 x 的位置，并返回它的下标。如果数组中 x 的出现次数少于 queries[i] ，该查询的答案为 -1 。\n请你返回一个整数数组 answer ，包含所有查询的答案。\n示例 1：\n输入nums = [1,3,1,7], queries = [1,3,2,4], x = 1\n输出：[0,-1,2,-1]示例 2：\n输入nums = [1,2,3], queries = [10], x = 5\n输出：[-1]\n\n提示：\n1 <= nums.length, queries.length <= 10^5\n1 <= queries[i] <= 10^5\n1 <= nums[i], x <= 10^4\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int[] occurrencesOfElement(int[] nums, int[] queries, int x) {\n```",
        "solution": "class Solution {\n    public int[] occurrencesOfElement(int[] nums, int[] queries, int x) {\n        List<Integer> pos = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == x) {\n                pos.add(i);\n            }\n        }\n        for (int i = 0; i < queries.length; i++) {\n            if (queries[i] > pos.size()) {\n                queries[i] = -1;\n            } else {\n                queries[i] = pos.get(queries[i] - 1);\n            }\n        }\n        return queries;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,3,1,7};\n        int[] queries_1 = {1,3,2,4};\n        int x_1 = 1;\n        int[] ans_1 = {0,-1,2,-1};\n        assert Arrays.equals(solution.occurrencesOfElement(nums_1, queries_1, x_1), ans_1);\n        int[] nums_2 = {1,2,3};\n        int[] queries_2 = {10};\n        int x_2 = 5;\n        int[] ans_2 = {-1};\n        assert Arrays.equals(solution.occurrencesOfElement(nums_2, queries_2, x_2), ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int[] occurrencesOfElement(int[] nums, int[] queries, int x) {",
        "function_name": "occurrencesOfElement",
        "difficulty_level": "Middle",
        "time": "20240525"
    },
    {
        "id": "3160",
        "prompt_base": "\"\"\"\n给你一个整数 limit 和一个大小为 n x 2 的二维数组 queries 。\n总共有 limit + 1 个球，每个球的编号为 [0, limit] 中一个 互不相同 的数字。一开始，所有球都没有颜色。queries 中每次操作的格式为 [x, y] ，你需要将球 x 染上颜色 y 。每次操作之后，你需要求出所有球中 不同 颜色的数目。\n请你返回一个长度为 n 的数组 result ，其中 result[i] 是第 i 次操作以后不同颜色的数目。\n注意 ，没有染色的球不算作一种颜色。\n示例 1：\n输入limit = 4, queries = [[1,4],[2,5],[1,3],[3,4]]\n输出：[1,2,2,3]示例 2：\n输入limit = 4, queries = [[0,1],[1,2],[2,2],[3,4],[4,5]]\n输出：[1,2,2,3,4]\n\n提示：\n1 <= limit <= 10^9\n1 <= n == queries.length <= 10^5\nqueries[i].length == 2\n0 <= queries[i][0] <= limit\n1 <= queries[i][1] <= 10^9\n\"\"\"\n\nclass Solution {\n    public int[] queryResults(int limit, int[][] queries) {",
        "prompt_chat": "给你一个整数 limit 和一个大小为 n x 2 的二维数组 queries 。\n总共有 limit + 1 个球，每个球的编号为 [0, limit] 中一个 互不相同 的数字。一开始，所有球都没有颜色。queries 中每次操作的格式为 [x, y] ，你需要将球 x 染上颜色 y 。每次操作之后，你需要求出所有球中 不同 颜色的数目。\n请你返回一个长度为 n 的数组 result ，其中 result[i] 是第 i 次操作以后不同颜色的数目。\n注意 ，没有染色的球不算作一种颜色。\n示例 1：\n输入limit = 4, queries = [[1,4],[2,5],[1,3],[3,4]]\n输出：[1,2,2,3]示例 2：\n输入limit = 4, queries = [[0,1],[1,2],[2,2],[3,4],[4,5]]\n输出：[1,2,2,3,4]\n\n提示：\n1 <= limit <= 10^9\n1 <= n == queries.length <= 10^5\nqueries[i].length == 2\n0 <= queries[i][0] <= limit\n1 <= queries[i][1] <= 10^9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int[] queryResults(int limit, int[][] queries) {\n```",
        "solution": "class Solution {\n    public int[] queryResults(int limit, int[][] queries) {\n        int[] ans = new int[queries.length];\n        Map<Integer, Integer> color = new HashMap<>();\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int i = 0; i < queries.length; i++) {\n            int[] q = queries[i];\n            int x = q[0];\n            int y = q[1];\n            if (color.containsKey(x)) {\n                int c = color.get(x);\n                if (cnt.merge(c, -1, Integer::sum) == 0) {\n                    cnt.remove(c);\n                }\n            }\n            color.put(x, y);\n            cnt.merge(y, 1, Integer::sum);\n            ans[i] = cnt.size();\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int limit_1 = 4;\n        int[][] queries_1 = {{1,4},{2,5},{1,3},{3,4}};\n        int[] ans_1 = {1,2,2,3};\n        assert Arrays.equals(solution.queryResults(limit_1, queries_1), ans_1);\n        int limit_2 = 4;\n        int[][] queries_2 = {{0,1},{1,2},{2,2},{3,4},{4,5}};\n        int[] ans_2 = {1,2,2,3,4};\n        assert Arrays.equals(solution.queryResults(limit_2, queries_2), ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int[] queryResults(int limit, int[][] queries) {",
        "function_name": "queryResults",
        "difficulty_level": "Middle",
        "time": "20240525"
    },
    {
        "id": "3161",
        "prompt_base": "\"\"\"\n有一条无限长的数轴，原点在 0 处，沿着 x 轴 正 方向无限延伸。\n给你一个二维数组 queries ，它包含两种操作：\n操作类型 1 ：queries[i] = [1, x] 。在距离原点 x 处建一个障碍物。数据保证当操作执行的时候，位置 x 处 没有 任何障碍物。\n操作类型 2 ：queries[i] = [2, x, sz] 。判断在数轴范围 [0, x] 内是否可以放置一个长度为 sz 的物块，这个物块需要 完全 放置在范围 [0, x] 内。如果物块与任何障碍物有重合，那么这个物块 不能 被放置，但物块可以与障碍物刚好接触。注意，你只是进行查询，并 不是 真的放置这个物块。每个查询都是相互独立的。\n请你返回一个 boolean 数组results ，如果第 i 个操作类型 2 的操作你可以放置物块，那么 results[i] 为 true ，否则为 false 。\n示例 1：\n输入queries = [[1,2],[2,3,3],[2,3,1],[2,2,2]]\n输出：[false,true,true]示例 2：\n输入queries = [[1,7],[2,7,6],[1,2],[2,7,5],[2,7,6]]\n输出：[true,true,false]\n\n提示：\n1 <= queries.length <= 15 * 10^4\n2 <= queries[i].length <= 3\n1 <= queries[i][0] <= 2\n1 <= x, sz <= min(5 * 10^4, 3 * queries.length)\n输入保证操作 1 中，x 处不会有障碍物。\n输入保证至少有一个操作类型 2 。\n\"\"\"\n\nclass Solution {\n    public List<Boolean> getResults(int[][] queries) {",
        "prompt_chat": "有一条无限长的数轴，原点在 0 处，沿着 x 轴 正 方向无限延伸。\n给你一个二维数组 queries ，它包含两种操作：\n操作类型 1 ：queries[i] = [1, x] 。在距离原点 x 处建一个障碍物。数据保证当操作执行的时候，位置 x 处 没有 任何障碍物。\n操作类型 2 ：queries[i] = [2, x, sz] 。判断在数轴范围 [0, x] 内是否可以放置一个长度为 sz 的物块，这个物块需要 完全 放置在范围 [0, x] 内。如果物块与任何障碍物有重合，那么这个物块 不能 被放置，但物块可以与障碍物刚好接触。注意，你只是进行查询，并 不是 真的放置这个物块。每个查询都是相互独立的。\n请你返回一个 boolean 数组results ，如果第 i 个操作类型 2 的操作你可以放置物块，那么 results[i] 为 true ，否则为 false 。\n示例 1：\n输入queries = [[1,2],[2,3,3],[2,3,1],[2,2,2]]\n输出：[false,true,true]示例 2：\n输入queries = [[1,7],[2,7,6],[1,2],[2,7,5],[2,7,6]]\n输出：[true,true,false]\n\n提示：\n1 <= queries.length <= 15 * 10^4\n2 <= queries[i].length <= 3\n1 <= queries[i][0] <= 2\n1 <= x, sz <= min(5 * 10^4, 3 * queries.length)\n输入保证操作 1 中，x 处不会有障碍物。\n输入保证至少有一个操作类型 2 。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public List<Boolean> getResults(int[][] queries) {\n```",
        "solution": "class Solution {\n    public List<Boolean> getResults(int[][] queries) {\n        int m = 0;\n        for (int[] q : queries) {\n            m = Math.max(m, q[1]);\n        }\n        m++;\n\n        TreeSet<Integer> set = new TreeSet<>(List.of(0, m)); // 哨兵\n        int[] t = new int[2 << (32 - Integer.numberOfLeadingZeros(m))];\n\n        List<Boolean> ans = new ArrayList<>();\n        for (int[] q : queries) {\n            int x = q[1];\n            int pre = set.floor(x - 1); // x 左侧最近障碍物的位置\n            if (q[0] == 1) {\n                int nxt = set.ceiling(x); // x 右侧最近障碍物的位置\n                set.add(x);\n                update(t, 1, 0, m, x, x - pre);   // 更新 d[x] = x - pre\n                update(t, 1, 0, m, nxt, nxt - x); // 更新 d[nxt] = nxt - x\n            } else {\n                // 最大长度要么是 [0,pre] 中的最大 d，要么是 [pre,x] 这一段的长度\n                int maxGap = Math.max(query(t, 1, 0, m, pre), x - pre);\n                ans.add(maxGap >= q[2]);\n            }\n        }\n        return ans;\n    }\n\n    // 把 i 处的值改成 val\n    private void update(int[] t, int o, int l, int r, int i, int val) {\n        if (l == r) {\n            t[o] = val;\n            return;\n        }\n        int m = (l + r) / 2;\n        if (i <= m) {\n            update(t, o * 2, l, m, i, val);\n        } else {\n            update(t, o * 2 + 1, m + 1, r, i, val);\n        }\n        t[o] = Math.max(t[o * 2], t[o * 2 + 1]);\n    }\n\n    // 查询 [0,R] 中的最大值\n    private int query(int[] t, int o, int l, int r, int R) {\n        if (r <= R) {\n            return t[o];\n        }\n        int m = (l + r) / 2;\n        if (R <= m) {\n            return query(t, o * 2, l, m, R);\n        }\n        return Math.max(t[o * 2], query(t, o * 2 + 1, m + 1, r, R));\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] queries_1 = {{1,2},{2,3,3},{2,3,1},{2,2,2}};\n        List<Boolean> level1_count1 = new ArrayList<>();\n        level1_count1.add(false);\n        level1_count1.add(true);\n        level1_count1.add(true);\n    assert solution.getResults(queries_1).equals(level1_count1);\n        int[][] queries_2 = {{1,7},{2,7,6},{1,2},{2,7,5},{2,7,6}};\n        List<Boolean> level1_count2 = new ArrayList<>();\n        level1_count2.add(true);\n        level1_count2.add(true);\n        level1_count2.add(false);\n    assert solution.getResults(queries_2).equals(level1_count2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public List<Boolean> getResults(int[][] queries) {",
        "function_name": "getResults",
        "difficulty_level": "Hard",
        "time": "20240525"
    },
    {
        "id": "3174",
        "prompt_base": "\"\"\"\n给你一个字符串 s 。\n你的任务是重复以下操作删除 所有 数字字符：删除 第一个数字字符 以及它左边 最近 的 非数字 字符。\n请你返回删除所有数字字符以后剩下的字符串。\n示例 1：\n输入s = \"abc\"\n输出：\"abc\"示例 2：\n输入s = \"cb34\"\n输出：\"\"\n\n提示：\n1 <= s.length <= 100\ns 只包含小写英文字母和数字字符。\n输入保证所有数字都可以按以上操作被删除。\n\"\"\"\n\nclass Solution {\n    public String clearDigits(String s) {",
        "prompt_chat": "给你一个字符串 s 。\n你的任务是重复以下操作删除 所有 数字字符：删除 第一个数字字符 以及它左边 最近 的 非数字 字符。\n请你返回删除所有数字字符以后剩下的字符串。\n示例 1：\n输入s = \"abc\"\n输出：\"abc\"示例 2：\n输入s = \"cb34\"\n输出：\"\"\n\n提示：\n1 <= s.length <= 100\ns 只包含小写英文字母和数字字符。\n输入保证所有数字都可以按以上操作被删除。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public String clearDigits(String s) {\n```",
        "solution": "class Solution {\n    public String clearDigits(String s) {\n        StringBuilder st = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                st.deleteCharAt(st.length() - 1);\n            } else {\n                st.append(c);\n            }\n        }\n        return st.toString();\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s_1 = \"abc\";\n        String ans_1 = \"abc\";\n    assert solution.clearDigits(s_1).equals(ans_1);\n        String s_2 = \"cb34\";\n        String ans_2 = \"\";\n    assert solution.clearDigits(s_2).equals(ans_2);\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public String clearDigits(String s) {",
        "function_name": "clearDigits",
        "difficulty_level": "Easy",
        "time": "20240608"
    },
    {
        "id": "3175",
        "prompt_base": "\"\"\"\n有 n 位玩家在进行比赛，玩家编号依次为 0 到 n - 1 。\n给你一个长度为 n 的整数数组 skills 和一个 正 整数 k ，其中 skills[i] 是第 i 位玩家的技能等级。skills 中所有整数 互不相同 。所有玩家从编号 0 到 n - 1 排成一列。\n比赛进行方式如下：\n队列中最前面两名玩家进行一场比赛，技能等级 更高 的玩家胜出。\n比赛后，获胜者保持在队列的开头，而失败者排到队列的末尾。\n这个比赛的赢家是 第一位连续 赢下 k 场比赛的玩家。\n请你返回这个比赛的赢家编号。\n示例 1：\n输入skills = [4,2,6,3,9], k = 2\n输出：2示例 2：\n输入skills = [2,5,4], k = 3\n输出：1\n\n提示：\nn == skills.length\n2 <= n <= 10^5\n1 <= k <= 10^9\n1 <= skills[i] <= 10^6\nskills 中的整数互不相同。\n\"\"\"\n\nclass Solution {\n    public int findWinningPlayer(int[] skills, int k) {",
        "prompt_chat": "有 n 位玩家在进行比赛，玩家编号依次为 0 到 n - 1 。\n给你一个长度为 n 的整数数组 skills 和一个 正 整数 k ，其中 skills[i] 是第 i 位玩家的技能等级。skills 中所有整数 互不相同 。所有玩家从编号 0 到 n - 1 排成一列。\n比赛进行方式如下：\n队列中最前面两名玩家进行一场比赛，技能等级 更高 的玩家胜出。\n比赛后，获胜者保持在队列的开头，而失败者排到队列的末尾。\n这个比赛的赢家是 第一位连续 赢下 k 场比赛的玩家。\n请你返回这个比赛的赢家编号。\n示例 1：\n输入skills = [4,2,6,3,9], k = 2\n输出：2示例 2：\n输入skills = [2,5,4], k = 3\n输出：1\n\n提示：\nn == skills.length\n2 <= n <= 10^5\n1 <= k <= 10^9\n1 <= skills[i] <= 10^6\nskills 中的整数互不相同。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int findWinningPlayer(int[] skills, int k) {\n```",
        "solution": "class Solution {\n    public int findWinningPlayer(int[] skills, int k) {\n        int mxI = 0;\n        int win = 0;\n        for (int i = 1; i < skills.length && win < k; i++) {\n            if (skills[i] > skills[mxI]) { // 新的最大值\n                mxI = i;\n                win = 0;\n            }\n            win++; // 获胜回合 +1\n        }\n        return mxI;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] skills_1 = {4,2,6,3,9};\n        int k_1 = 2;\n        int ans_1 = 2;\n        assert solution.findWinningPlayer(skills_1, k_1) == ans_1;\n        int[] skills_2 = {2,5,4};\n        int k_2 = 3;\n        int ans_2 = 1;\n        assert solution.findWinningPlayer(skills_2, k_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int findWinningPlayer(int[] skills, int k) {",
        "function_name": "findWinningPlayer",
        "difficulty_level": "Middle",
        "time": "20240608"
    },
    {
        "id": "3176",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 和一个 非负 整数 k 。如果一个整数序列 seq 满足在范围下标范围 [0, seq.length - 2] 中存在 不超过 k 个下标 i 满足 seq[i] != seq[i + 1] ，那么我们称这个整数序列为 好 序列。\n请你返回 nums 中 好 n子序列 的最长长度\n示例 1：\n输入nums = [1,2,1,1,3], k = 2\n输出：4示例 2：\n输入nums = [1,2,3,4,5,1], k = 0\n输出：2\n\n提示：\n1 <= nums.length <= 500\n1 <= nums[i] <= 10^9\n0 <= k <= min(nums.length, 25)\n\"\"\"\n\nclass Solution {\n    public int maximumLength(int[] nums, int k) {",
        "prompt_chat": "给你一个整数数组 nums 和一个 非负 整数 k 。如果一个整数序列 seq 满足在范围下标范围 [0, seq.length - 2] 中存在 不超过 k 个下标 i 满足 seq[i] != seq[i + 1] ，那么我们称这个整数序列为 好 序列。\n请你返回 nums 中 好 n子序列 的最长长度\n示例 1：\n输入nums = [1,2,1,1,3], k = 2\n输出：4示例 2：\n输入nums = [1,2,3,4,5,1], k = 0\n输出：2\n\n提示：\n1 <= nums.length <= 500\n1 <= nums[i] <= 10^9\n0 <= k <= min(nums.length, 25)\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maximumLength(int[] nums, int k) {\n```",
        "solution": "class Solution {\n    public int maximumLength(int[] nums, int k) {\n        Map<Integer, int[]> fs = new HashMap<>();\n        int[][] records = new int[k + 1][3];\n        for (int x : nums) {\n            int[] f = fs.computeIfAbsent(x, i -> new int[k + 1]);\n            for (int j = k; j >= 0; j--) {\n                f[j]++;\n                if (j > 0) {\n                    int mx = records[j - 1][0], mx2 = records[j - 1][1], num = records[j - 1][2];\n                    f[j] = Math.max(f[j], (x != num ? mx : mx2) + 1);\n                }\n\n                // records[j] 维护 fs[.][j] 的 mx, mx2, num\n                int v = f[j];\n                int[] p = records[j];\n                if (v > p[0]) {\n                    if (x != p[2]) {\n                        p[2] = x;\n                        p[1] = p[0];\n                    }\n                    p[0] = v;\n                } else if (x != p[2] && v > p[1]) {\n                    p[1] = v;\n                }\n            }\n        }\n        return records[k][0];\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,1,1,3};\n        int k_1 = 2;\n        int ans_1 = 4;\n        assert solution.maximumLength(nums_1, k_1) == ans_1;\n        int[] nums_2 = {1,2,3,4,5,1};\n        int k_2 = 0;\n        int ans_2 = 2;\n        assert solution.maximumLength(nums_2, k_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maximumLength(int[] nums, int k) {",
        "function_name": "maximumLength",
        "difficulty_level": "Middle",
        "time": "20240608"
    },
    {
        "id": "3177",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 和一个 非负 整数 k 。如果一个整数序列 seq 满足在范围下标范围 [0, seq.length - 2] 中存在 不超过 k 个下标 i 满足 seq[i] != seq[i + 1] ，那么我们称这个整数序列为 好 序列。\n请你返回 nums 中 好 子序列 的最长长度\n示例 1：\n输入nums = [1,2,1,1,3], k = 2\n输出：4示例 2：\n输入nums = [1,2,3,4,5,1], k = 0\n输出：2\n\n提示：\n1 <= nums.length <= 5 * 10^3\n1 <= nums[i] <= 10^9\n0 <= k <= min(50, nums.length)\n\"\"\"\n\nclass Solution {\n    public int maximumLength(int[] nums, int k) {",
        "prompt_chat": "给你一个整数数组 nums 和一个 非负 整数 k 。如果一个整数序列 seq 满足在范围下标范围 [0, seq.length - 2] 中存在 不超过 k 个下标 i 满足 seq[i] != seq[i + 1] ，那么我们称这个整数序列为 好 序列。\n请你返回 nums 中 好 子序列 的最长长度\n示例 1：\n输入nums = [1,2,1,1,3], k = 2\n输出：4示例 2：\n输入nums = [1,2,3,4,5,1], k = 0\n输出：2\n\n提示：\n1 <= nums.length <= 5 * 10^3\n1 <= nums[i] <= 10^9\n0 <= k <= min(50, nums.length)\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int maximumLength(int[] nums, int k) {\n```",
        "solution": "class Solution {\n    public int maximumLength(int[] nums, int k) {\n        Map<Integer, int[]> fs = new HashMap<>();\n        int[] mx = new int[k + 2];\n        for (int x : nums) {\n            int[] f = fs.computeIfAbsent(x, i -> new int[k + 1]);\n            for (int j = k; j >= 0; j--) {\n                f[j] = Math.max(f[j], mx[j]) + 1;\n                mx[j + 1] = Math.max(mx[j + 1], f[j]);\n            }\n        }\n        return mx[k + 1];\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,1,1,3};\n        int k_1 = 2;\n        int ans_1 = 4;\n        assert solution.maximumLength(nums_1, k_1) == ans_1;\n        int[] nums_2 = {1,2,3,4,5,1};\n        int k_2 = 0;\n        int ans_2 = 2;\n        assert solution.maximumLength(nums_2, k_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int maximumLength(int[] nums, int k) {",
        "function_name": "maximumLength",
        "difficulty_level": "Hard",
        "time": "20240608"
    },
    {
        "id": "3190",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 。一次操作中，你可以将 nums 中的 任意 一个元素增加或者减少 1 。\n请你返回将 nums 中所有元素都可以被 3 整除的 最少 操作次数。\n示例 1：\n输入nums = [1,2,3,4]\n输出：3示例 2：\n输入nums = [3,6,9]\n输出：0\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 50\n\"\"\"\n\nclass Solution {\n    public int minimumOperations(int[] nums) {",
        "prompt_chat": "给你一个整数数组 nums 。一次操作中，你可以将 nums 中的 任意 一个元素增加或者减少 1 。\n请你返回将 nums 中所有元素都可以被 3 整除的 最少 操作次数。\n示例 1：\n输入nums = [1,2,3,4]\n输出：3示例 2：\n输入nums = [3,6,9]\n输出：0\n\n提示：\n1 <= nums.length <= 50\n1 <= nums[i] <= 50\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minimumOperations(int[] nums) {\n```",
        "solution": "class Solution {\n    public int minimumOperations(int[] nums) {\n        int ans = 0;\n        for (int x : nums) {\n            ans += x % 3 != 0 ? 1 : 0;\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,2,3,4};\n        int ans_1 = 3;\n        assert solution.minimumOperations(nums_1) == ans_1;\n        int[] nums_2 = {3,6,9};\n        int ans_2 = 0;\n        assert solution.minimumOperations(nums_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minimumOperations(int[] nums) {",
        "function_name": "minimumOperations",
        "difficulty_level": "Easy",
        "time": "20240622"
    },
    {
        "id": "3191",
        "prompt_base": "\"\"\"\n给你一个二进制数组 nums 。你可以对数组执行以下操作 任意 次（也可以 0 次）：\n选择数组中 任意连续 3 个元素，并将它们 全部反转 。\n反转 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。\n请你返回将 nums 中所有元素变为 1 的 最少 操作次数。如果无法全部变成 1 ，返回 -1 。\n示例 1：\n输入nums = [0,1,1,1,0,0]\n输出：3示例 2：\n输入nums = [0,1,1,1]\n输出：-1\n\n提示：\n3 <= nums.length <= 10^5\n0 <= nums[i] <= 1\n\"\"\"\n\nclass Solution {\n    public int minOperations(int[] nums) {",
        "prompt_chat": "给你一个二进制数组 nums 。你可以对数组执行以下操作 任意 次（也可以 0 次）：\n选择数组中 任意连续 3 个元素，并将它们 全部反转 。\n反转 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。\n请你返回将 nums 中所有元素变为 1 的 最少 操作次数。如果无法全部变成 1 ，返回 -1 。\n示例 1：\n输入nums = [0,1,1,1,0,0]\n输出：3示例 2：\n输入nums = [0,1,1,1]\n输出：-1\n\n提示：\n3 <= nums.length <= 10^5\n0 <= nums[i] <= 1\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minOperations(int[] nums) {\n```",
        "solution": "class Solution {\n    public int minOperations(int[] nums) {\n        int n = nums.length;\n        int ans = 0;\n        for (int i = 0; i < n - 2; i++) {\n            if (nums[i] == 0) {\n                nums[i + 1] ^= 1;\n                nums[i + 2] ^= 1;\n                ans++;\n            }\n        }\n        return nums[n - 2] != 0 && nums[n - 1] != 0 ? ans : -1;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {0,1,1,1,0,0};\n        int ans_1 = 3;\n        assert solution.minOperations(nums_1) == ans_1;\n        int[] nums_2 = {0,1,1,1};\n        int ans_2 = -1;\n        assert solution.minOperations(nums_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minOperations(int[] nums) {",
        "function_name": "minOperations",
        "difficulty_level": "Middle",
        "time": "20240622"
    },
    {
        "id": "3192",
        "prompt_base": "\"\"\"\n给你一个二进制数组 nums 。你可以对数组执行以下操作 任意 次（也可以 0 次）：\n选择数组中 任意 一个下标 i ，并将从下标 i 开始一直到数组末尾 所有 元素 反转 。\n反转 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。\n请你返回将 nums 中所有元素变为 1 的 最少 操作次数。\n示例 1：\n输入nums = [0,1,1,0,1]\n输出：4示例 2：\n输入nums = [1,0,0,0]\n输出：1\n\n提示：\n1 <= nums.length <= 10^5\n0 <= nums[i] <= 1\n\"\"\"\n\nclass Solution {\n    public int minOperations(int[] nums) {",
        "prompt_chat": "给你一个二进制数组 nums 。你可以对数组执行以下操作 任意 次（也可以 0 次）：\n选择数组中 任意 一个下标 i ，并将从下标 i 开始一直到数组末尾 所有 元素 反转 。\n反转 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。\n请你返回将 nums 中所有元素变为 1 的 最少 操作次数。\n示例 1：\n输入nums = [0,1,1,0,1]\n输出：4示例 2：\n输入nums = [1,0,0,0]\n输出：1\n\n提示：\n1 <= nums.length <= 10^5\n0 <= nums[i] <= 1\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int minOperations(int[] nums) {\n```",
        "solution": "class Solution {\n    public int minOperations(int[] nums) {\n        int ans = 0;\n        for (int x : nums) {\n            if (x == ans % 2) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {0,1,1,0,1};\n        int ans_1 = 4;\n        assert solution.minOperations(nums_1) == ans_1;\n        int[] nums_2 = {1,0,0,0};\n        int ans_2 = 1;\n        assert solution.minOperations(nums_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int minOperations(int[] nums) {",
        "function_name": "minOperations",
        "difficulty_level": "Middle",
        "time": "20240622"
    },
    {
        "id": "3193",
        "prompt_base": "\"\"\"\n给你一个整数 n 和一个二维数组 requirements ，其中 requirements[i] = [end_i, cnt_i] 表示这个要求中的末尾下标和 逆序对 的数目。\n整数数组 nums 中一个下标对 (i, j) 如果满足以下条件，那么它们被称为一个 逆序对 ：\ni < j 且 nums[i] > nums[j]\n请你返回 [0, 1, 2, ..., n - 1] 的 排列 perm 的数目，满足对 所有 的 requirements[i] 都有 perm[0..end_i] 恰好有 cnt_i 个逆序对。\n由于答案可能会很大，将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入n = 3, requirements = [[2,2],[0,0]]\n输出：2示例 2：\n输入n = 3, requirements = [[2,2],[1,1],[0,0]]\n输出：1\n\n提示：\n2 <= n <= 300\n1 <= requirements.length <= n\nrequirements[i] = [end_i, cnt_i]\n0 <= end_i <= n - 1\n0 <= cnt_i <= 400\n输入保证至少有一个 i 满足 end_i == n - 1 。\n输入保证所有的 end_i 互不相同。\n\"\"\"\n\nclass Solution {\n    public int numberOfPermutations(int n, int[][] requirements) {",
        "prompt_chat": "给你一个整数 n 和一个二维数组 requirements ，其中 requirements[i] = [end_i, cnt_i] 表示这个要求中的末尾下标和 逆序对 的数目。\n整数数组 nums 中一个下标对 (i, j) 如果满足以下条件，那么它们被称为一个 逆序对 ：\ni < j 且 nums[i] > nums[j]\n请你返回 [0, 1, 2, ..., n - 1] 的 排列 perm 的数目，满足对 所有 的 requirements[i] 都有 perm[0..end_i] 恰好有 cnt_i 个逆序对。\n由于答案可能会很大，将它对 10^9 + 7 取余 后返回。\n示例 1：\n输入n = 3, requirements = [[2,2],[0,0]]\n输出：2示例 2：\n输入n = 3, requirements = [[2,2],[1,1],[0,0]]\n输出：1\n\n提示：\n2 <= n <= 300\n1 <= requirements.length <= n\nrequirements[i] = [end_i, cnt_i]\n0 <= end_i <= n - 1\n0 <= cnt_i <= 400\n输入保证至少有一个 i 满足 end_i == n - 1 。\n输入保证所有的 end_i 互不相同。\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int numberOfPermutations(int n, int[][] requirements) {\n```",
        "solution": "class Solution {\n    public int numberOfPermutations(int n, int[][] requirements) {\n        int[] req = new int[n];\n        Arrays.fill(req, -1);\n        req[0] = 0;\n        int m = 0;\n        for (int[] p : requirements) {\n            req[p[0]] = p[1];\n            m = Math.max(m, p[1]);\n        }\n        if (req[0] > 0) {\n            return 0;\n        }\n\n        int[][] memo = new int[n][m + 1];\n        for (int[] row : memo) {\n            Arrays.fill(row, -1); // -1 表示没有计算过\n        }\n        return dfs(n - 1, req[n - 1], req, memo);\n    }\n\n    private int dfs(int i, int j, int[] req, int[][] memo) {\n        if (i == 0) {\n            return 1;\n        }\n        if (memo[i][j] != -1) { // 之前计算过\n            return memo[i][j];\n        }\n        int res = 0;\n        int r = req[i - 1];\n        if (r >= 0) {\n            if (j >= r && j - i <= r) {\n                res = dfs(i - 1, r, req, memo);\n            }\n        } else {\n            for (int k = 0; k <= Math.min(i, j); k++) {\n                res = (res + dfs(i - 1, j - k, req, memo)) % 1_000_000_007;\n            }\n        }\n        return memo[i][j] = res; // 记忆化\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n_1 = 3;\n        int[][] requirements_1 = {{2,2},{0,0}};\n        int ans_1 = 2;\n        assert solution.numberOfPermutations(n_1, requirements_1) == ans_1;\n        int n_2 = 3;\n        int[][] requirements_2 = {{2,2},{1,1},{0,0}};\n        int ans_2 = 1;\n        assert solution.numberOfPermutations(n_2, requirements_2) == ans_2;\n        int n_3 = 2;\n        int[][] requirements_3 = {{0,0},{1,0}};\n        int ans_3 = 1;\n        assert solution.numberOfPermutations(n_3, requirements_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int numberOfPermutations(int n, int[][] requirements) {",
        "function_name": "numberOfPermutations",
        "difficulty_level": "Hard",
        "time": "20240622"
    },
    {
        "id": "3206",
        "prompt_base": "\"\"\"\n给你一个整数数组 colors ，它表示一个由红色和蓝色瓷砖组成的环，第 i 块瓷砖的颜色为 colors[i] ：\ncolors[i] == 0 表示第 i 块瓷砖的颜色是 红色 。\ncolors[i] == 1 表示第 i 块瓷砖的颜色是 蓝色 。\n环中连续 3 块瓷砖的颜色如果是 交替 颜色（也就是说中间瓷砖的颜色与它 左边 和 右边 的颜色都不同），那么它被称为一个 交替 组。请你返回 交替 组的数目。\n注意 ，由于 colors 表示一个 环 ，第一块 瓷砖和 最后一块 瓷砖是相邻的。\n示例 1：\n输入colors = [1,1,1]\n输出：0示例 2：\n输入colors = [0,1,0,0,1]\n输出：3\n\n提示：\n3 <= colors.length <= 100\n0 <= colors[i] <= 1\n\"\"\"\n\nclass Solution {\n    public int numberOfAlternatingGroups(int[] colors) {",
        "prompt_chat": "给你一个整数数组 colors ，它表示一个由红色和蓝色瓷砖组成的环，第 i 块瓷砖的颜色为 colors[i] ：\ncolors[i] == 0 表示第 i 块瓷砖的颜色是 红色 。\ncolors[i] == 1 表示第 i 块瓷砖的颜色是 蓝色 。\n环中连续 3 块瓷砖的颜色如果是 交替 颜色（也就是说中间瓷砖的颜色与它 左边 和 右边 的颜色都不同），那么它被称为一个 交替 组。请你返回 交替 组的数目。\n注意 ，由于 colors 表示一个 环 ，第一块 瓷砖和 最后一块 瓷砖是相邻的。\n示例 1：\n输入colors = [1,1,1]\n输出：0示例 2：\n输入colors = [0,1,0,0,1]\n输出：3\n\n提示：\n3 <= colors.length <= 100\n0 <= colors[i] <= 1\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int numberOfAlternatingGroups(int[] colors) {\n```",
        "solution": "class Solution {\n    public int numberOfAlternatingGroups(int[] colors) {\n        int k = 3;\n        int n = colors.length;\n        int ans = 0;\n        int cnt = 0;\n        for (int i = 0; i < n * 2; i++) {\n            if (i > 0 && colors[i % n] == colors[(i - 1) % n]) {\n                cnt = 0;\n            }\n            cnt++;\n            if (i >= n && cnt >= k) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] colors_1 = {1,1,1};\n        int ans_1 = 0;\n        assert solution.numberOfAlternatingGroups(colors_1) == ans_1;\n        int[] colors_2 = {0,1,0,0,1};\n        int ans_2 = 3;\n        assert solution.numberOfAlternatingGroups(colors_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int numberOfAlternatingGroups(int[] colors) {",
        "function_name": "numberOfAlternatingGroups",
        "difficulty_level": "Easy",
        "time": "20240706"
    },
    {
        "id": "3207",
        "prompt_base": "\"\"\"\n给你一个下标从 0 开始的整数数组 enemyEnergies ，它表示一个下标从 0 开始的敌人能量数组。\n同时给你一个整数 currentEnergy ，它表示你一开始拥有的能量值总量。\n你一开始的分数为 0 ，且一开始所有的敌人都未标记。\n你可以通过以下操作 之一 任意次（也可以 0 次）来得分：\n选择一个 未标记 且满足 currentEnergy >= enemyEnergies[i] 的敌人 i 。在这个操作中：你会获得 1 分。你的能量值减少 enemyEnergies[i] ，也就是说 currentEnergy = currentEnergy - enemyEnergies[i] 。\n如果你目前 至少 有 1 分，你可以选择一个 未标记 的敌人 i 。在这个操作中：你的能量值增加 enemyEnergies[i] ，也就是说 currentEnergy = currentEnergy + enemyEnergies[i] 。敌人 i 被标记 。\n请你返回通过以上操作，最多 可以获得多少分。\n示例 1：\n输入enemyEnergies = [3,2,2], currentEnergy = 2\n输出：3示例 2：\n输入enemyEnergies = [2], currentEnergy = 10\n输出：5\n\n提示：\n1 <= enemyEnergies.length <= 10^5\n1 <= enemyEnergies[i] <= 10^9\n0 <= currentEnergy <= 10^9\n\"\"\"\n\nclass Solution {\n    public long maximumPoints(int[] enemyEnergies, int currentEnergy) {",
        "prompt_chat": "给你一个下标从 0 开始的整数数组 enemyEnergies ，它表示一个下标从 0 开始的敌人能量数组。\n同时给你一个整数 currentEnergy ，它表示你一开始拥有的能量值总量。\n你一开始的分数为 0 ，且一开始所有的敌人都未标记。\n你可以通过以下操作 之一 任意次（也可以 0 次）来得分：\n选择一个 未标记 且满足 currentEnergy >= enemyEnergies[i] 的敌人 i 。在这个操作中：你会获得 1 分。你的能量值减少 enemyEnergies[i] ，也就是说 currentEnergy = currentEnergy - enemyEnergies[i] 。\n如果你目前 至少 有 1 分，你可以选择一个 未标记 的敌人 i 。在这个操作中：你的能量值增加 enemyEnergies[i] ，也就是说 currentEnergy = currentEnergy + enemyEnergies[i] 。敌人 i 被标记 。\n请你返回通过以上操作，最多 可以获得多少分。\n示例 1：\n输入enemyEnergies = [3,2,2], currentEnergy = 2\n输出：3示例 2：\n输入enemyEnergies = [2], currentEnergy = 10\n输出：5\n\n提示：\n1 <= enemyEnergies.length <= 10^5\n1 <= enemyEnergies[i] <= 10^9\n0 <= currentEnergy <= 10^9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long maximumPoints(int[] enemyEnergies, int currentEnergy) {\n```",
        "solution": "class Solution {\n    public long maximumPoints(int[] enemyEnergies, int currentEnergy) {\n        int mn = Integer.MAX_VALUE;\n        long s = 0;\n        for (int e : enemyEnergies) {\n            mn = Math.min(mn, e);\n            s += e;\n        }\n        if (currentEnergy < mn) {\n            return 0;\n        }\n        return (currentEnergy + s - mn) / mn;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] enemyEnergies_1 = {3,2,2};\n        int currentEnergy_1 = 2;\n        long ans_1 = 3;\n        assert solution.maximumPoints(enemyEnergies_1, currentEnergy_1) == ans_1;\n        int[] enemyEnergies_2 = {2};\n        int currentEnergy_2 = 10;\n        long ans_2 = 5;\n        assert solution.maximumPoints(enemyEnergies_2, currentEnergy_2) == ans_2;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long maximumPoints(int[] enemyEnergies, int currentEnergy) {",
        "function_name": "maximumPoints",
        "difficulty_level": "Middle",
        "time": "20240706"
    },
    {
        "id": "3208",
        "prompt_base": "\"\"\"\n给你一个整数数组 colors 和一个整数 k ，colors表示一个由红色和蓝色瓷砖组成的环，第 i 块瓷砖的颜色为 colors[i] ：\ncolors[i] == 0 表示第 i 块瓷砖的颜色是 红色 。\ncolors[i] == 1 表示第 i 块瓷砖的颜色是 蓝色 。\n环中连续 k 块瓷砖的颜色如果是 交替 颜色（也就是说除了第一块和最后一块瓷砖以外，中间瓷砖的颜色与它 左边 和 右边 的颜色都不同），那么它被称为一个 交替 组。\n请你返回 交替 组的数目。\n注意 ，由于 colors 表示一个 环 ，第一块 瓷砖和 最后一块 瓷砖是相邻的。\n示例 1：\n输入colors = [0,1,0,1,0], k = 3\n输出：3示例 2：\n输入colors = [0,1,0,0,1,0,1], k = 6\n输出：2\n\n提示：\n3 <= colors.length <= 10^5\n0 <= colors[i] <= 1\n3 <= k <= colors.length\n\"\"\"\n\nclass Solution {\n    public int numberOfAlternatingGroups(int[] colors, int k) {",
        "prompt_chat": "给你一个整数数组 colors 和一个整数 k ，colors表示一个由红色和蓝色瓷砖组成的环，第 i 块瓷砖的颜色为 colors[i] ：\ncolors[i] == 0 表示第 i 块瓷砖的颜色是 红色 。\ncolors[i] == 1 表示第 i 块瓷砖的颜色是 蓝色 。\n环中连续 k 块瓷砖的颜色如果是 交替 颜色（也就是说除了第一块和最后一块瓷砖以外，中间瓷砖的颜色与它 左边 和 右边 的颜色都不同），那么它被称为一个 交替 组。\n请你返回 交替 组的数目。\n注意 ，由于 colors 表示一个 环 ，第一块 瓷砖和 最后一块 瓷砖是相邻的。\n示例 1：\n输入colors = [0,1,0,1,0], k = 3\n输出：3示例 2：\n输入colors = [0,1,0,0,1,0,1], k = 6\n输出：2\n\n提示：\n3 <= colors.length <= 10^5\n0 <= colors[i] <= 1\n3 <= k <= colors.length\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public int numberOfAlternatingGroups(int[] colors, int k) {\n```",
        "solution": "class Solution {\n    public int numberOfAlternatingGroups(int[] colors, int k) {\n        int n = colors.length;\n        int ans = 0;\n        int cnt = 0;\n        for (int i = 0; i < n * 2; i++) {\n            if (i > 0 && colors[i % n] == colors[(i - 1) % n]) {\n                cnt = 0;\n            }\n            cnt++;\n            if (i >= n && cnt >= k) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] colors_1 = {0,1,0,1,0};\n        int k_1 = 3;\n        int ans_1 = 3;\n        assert solution.numberOfAlternatingGroups(colors_1, k_1) == ans_1;\n        int[] colors_2 = {0,1,0,0,1,0,1};\n        int k_2 = 6;\n        int ans_2 = 2;\n        assert solution.numberOfAlternatingGroups(colors_2, k_2) == ans_2;\n        int[] colors_3 = {1,1,0,1};\n        int k_3 = 4;\n        int ans_3 = 0;\n        assert solution.numberOfAlternatingGroups(colors_3, k_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public int numberOfAlternatingGroups(int[] colors, int k) {",
        "function_name": "numberOfAlternatingGroups",
        "difficulty_level": "Middle",
        "time": "20240706"
    },
    {
        "id": "3209",
        "prompt_base": "\"\"\"\n给你一个整数数组 nums 和一个整数 k ，请你返回 nums 中有多少个子数组满足：子数组中所有元素按位 AND 的结果为 k 。\n示例 1：\n输入nums = [1,1,1], k = 1\n输出：6示例 2：\n输入nums = [1,1,2], k = 1\n输出：3\n\n提示：\n1 <= nums.length <= 10^5\n0 <= nums[i], k <= 10^9\n\"\"\"\n\nclass Solution {\n    public long countSubarrays(int[] nums, int k) {",
        "prompt_chat": "给你一个整数数组 nums 和一个整数 k ，请你返回 nums 中有多少个子数组满足：子数组中所有元素按位 AND 的结果为 k 。\n示例 1：\n输入nums = [1,1,1], k = 1\n输出：6示例 2：\n输入nums = [1,1,2], k = 1\n输出：3\n\n提示：\n1 <= nums.length <= 10^5\n0 <= nums[i], k <= 10^9\n\n请完成下面的代码来解决上述问题：\n```java\nclass Solution {\n    public long countSubarrays(int[] nums, int k) {\n```",
        "solution": "class Solution {\n    public long countSubarrays(int[] nums, int k) {\n        long ans = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int x = nums[i];\n            for (int j = i - 1; j >= 0 && (nums[j] & x) != nums[j]; j--) {\n                nums[j] &= x;\n            }\n            ans += lowerBound(nums, i + 1, k + 1) - lowerBound(nums, i + 1, k);\n        }\n        return ans;\n    }\n\n    // https://www.bilibili.com/video/BV1AP41137w7/\n    private int lowerBound(int[] nums, int right, int target) {\n        int left = -1; // 开区间 (left, right)\n        while (left + 1 < right) { // 区间不为空\n            // 循环不变量：\n            // nums[left] < target\n            // nums[right] >= target\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target) {\n                left = mid; // 范围缩小到 (mid, right)\n            } else {\n                right = mid; // 范围缩小到 (left, mid)\n            }\n        }\n        return right;\n    }\n}",
        "reference": "public class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums_1 = {1,1,1};\n        int k_1 = 1;\n        long ans_1 = 6;\n        assert solution.countSubarrays(nums_1, k_1) == ans_1;\n        int[] nums_2 = {1,1,2};\n        int k_2 = 1;\n        long ans_2 = 3;\n        assert solution.countSubarrays(nums_2, k_2) == ans_2;\n        int[] nums_3 = {1,2,3};\n        int k_3 = 2;\n        long ans_3 = 2;\n        assert solution.countSubarrays(nums_3, k_3) == ans_3;\n    }\n}",
        "class_helper": "",
        "context": "class Solution {\n    public long countSubarrays(int[] nums, int k) {",
        "function_name": "countSubarrays",
        "difficulty_level": "Hard",
        "time": "20240706"
    }
]