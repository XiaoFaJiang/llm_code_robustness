{"cpp_code_str": "\n#include <iostream>\n#include <string>\n#include <vector>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nvector<string> split_lowerstring(const string& text) {\n    vector<string> result;\n    regex pattern(\"[a-z][^a-z]*\");\n    smatch matches;\n    string::const_iterator search_start = text.cbegin();\n    \n    try {\n        while (regex_search(search_start, text.cend(), matches, pattern)) {\n            result.push_back(matches.str(0));\n            search_start = matches.suffix().first;\n        }\n    } catch (const regex_error& e) {\n        cerr << \"Regex error: \" << e.what() << \" Code: \" << e.code() << endl;\n    }\n    \n    return result;\n}\n\n\n", "cpp_test": "int main()\n{\n    assert((split_lowerstring(\"AbCd\") == vector<string>{\"bC\",\"d\"}));\n    assert((split_lowerstring(\"Python\") == vector<string>{\"y\", \"t\", \"h\", \"o\", \"n\"}));\n    assert((split_lowerstring(\"Programming\") == vector<string>{\"r\", \"o\", \"g\", \"r\", \"a\", \"m\", \"m\", \"i\", \"n\", \"g\"}));\n}", "backup": "```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nvector<string> split_lowerstring(const string& text) {\n    vector<string> result;\n    regex pattern(\"[a-z][^a-z]*\");\n    smatch matches;\n    string::const_iterator search_start = text.cbegin();\n    \n    try {\n        while (regex_search(search_start, text.cend(), matches, pattern)) {\n            result.push_back(matches.str(0));\n            search_start = matches.suffix().first;\n        }\n    } catch (const regex_error& e) {\n        cerr << \"Regex error: \" << e.what() << \" Code: \" << e.code() << endl;\n    }\n    \n    return result;\n}\n\nint main()\n{\n    assert((split_lowerstring(\"AbCd\") == vector<string>{\"bC\",\"d\"}));\n    assert((split_lowerstring(\"Python\") == vector<string>{\"y\", \"t\", \"h\", \"o\", \"n\"}));\n    assert((split_lowerstring(\"Programming\") == vector<string>{\"r\", \"o\", \"g\", \"r\", \"a\", \"m\", \"m\", \"i\", \"n\", \"g\"}));\n}\n```"}
{"cpp_code_str": "\n#include <regex>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nstring text_lowercase_underscore(string text) {\n    regex patterns(\"^[a-z]+_[a-z]+$\");\n    if (regex_search(text, patterns)) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}\n\n\n", "cpp_test": "int main() {\n    assert(text_lowercase_underscore(\"aab_cbbbc\") == \"Found a match!\");\n    assert(text_lowercase_underscore(\"aab_Abbbc\") == \"Not matched!\");\n    assert(text_lowercase_underscore(\"Aaab_abbbc\") == \"Not matched!\");\n    assert(text_lowercase_underscore(\"aab-cbbbc\") == \"Not matched!\");\n}", "backup": "```cpp\n#include <regex>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nstring text_lowercase_underscore(string text) {\n    regex patterns(\"^[a-z]+_[a-z]+$\");\n    if (regex_search(text, patterns)) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}\n\nint main() {\n    assert(text_lowercase_underscore(\"aab_cbbbc\") == \"Found a match!\");\n    assert(text_lowercase_underscore(\"aab_Abbbc\") == \"Not matched!\");\n    assert(text_lowercase_underscore(\"Aaab_abbbc\") == \"Not matched!\");\n    assert(text_lowercase_underscore(\"aab-cbbbc\") == \"Not matched!\");\n}\n```"}
{"cpp_code_str": "\n#include <iostream>\n#include <string>\n#include <vector>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nvector<string> remove(const vector<string>& list) {\n    regex pattern(\"[0-9]\");\n    vector<string> result;\n    for (const auto& item : list) {\n        result.push_back(regex_replace(item, pattern, string(\"\")));\n    }\n    return result;\n}\n\n\n", "cpp_test": "int main()\n{\n    assert(remove({\"4words\", \"3letters\", \"4digits\"}) == vector<string>({\"words\", \"letters\", \"digits\"}));\n    assert(remove({\"28Jan\",\"12Jan\",\"11Jan\"}) == vector<string>({\"Jan\",\"Jan\",\"Jan\"}));\n    assert(remove({\"wonder1\",\"wonder2\",\"wonder3\"}) == vector<string>({\"wonder\",\"wonder\",\"wonder\"}));\n}", "backup": "```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nvector<string> remove(const vector<string>& list) {\n    regex pattern(\"[0-9]\");\n    vector<string> result;\n    for (const auto& item : list) {\n        result.push_back(regex_replace(item, pattern, string(\"\")));\n    }\n    return result;\n}\n\nint main()\n{\n    assert(remove({\"4words\", \"3letters\", \"4digits\"}) == vector<string>({\"words\", \"letters\", \"digits\"}));\n    assert(remove({\"28Jan\",\"12Jan\",\"11Jan\"}) == vector<string>({\"Jan\",\"Jan\",\"Jan\"}));\n    assert(remove({\"wonder1\",\"wonder2\",\"wonder3\"}) == vector<string>({\"wonder\",\"wonder\",\"wonder\"}));\n}\n```"}
{"cpp_code_str": "\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\n\nvector<int> func(vector<vector<int>>& nums, int k) {\n    unordered_map<int, int> d;\n    for (auto& row : nums) {\n        for (int i : row) {\n            d[i]++;\n        }\n    }\n    \n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    for (auto& p : d) {\n        int key = p.first;\n        int v = p.second;\n        if (pq.size() < k) {\n            pq.emplace(v, key);\n        } else {\n            if (v > pq.top().first) {\n                pq.pop();\n                pq.emplace(v, key);\n            }\n        }\n    }\n    \n    vector<int> result;\n    while (!pq.empty()) {\n        result.push_back(pq.top().second);\n        pq.pop();\n    }\n    \n    return result;\n}\n\n\n", "cpp_test": "int main()\n{\n    assert((func({{1, 2, 6}, {1, 3, 4, 5, 7, 8}, {1, 3, 5, 6, 8, 9}, {2, 5, 7, 11}, {1, 4, 7, 8, 12}}, 3) == vector<int>({5, 7, 1})));\n    assert((func({{1, 2, 6}, {1, 3, 4, 5, 7, 8}, {1, 3, 5, 6, 8, 9}, {2, 5, 7, 11}, {1, 4, 7, 8, 12}}, 1) == vector<int>({1})));\n    assert((func({{1, 2, 6}, {1, 3, 4, 5, 7, 8}, {1, 3, 5, 6, 8, 9}, {2, 5, 7, 11}, {1, 4, 7, 8, 12}}, 5) == vector<int>({6, 5, 7, 8, 1})));\n}", "backup": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\n\nvector<int> func(vector<vector<int>>& nums, int k) {\n    unordered_map<int, int> d;\n    for (auto& row : nums) {\n        for (int i : row) {\n            d[i]++;\n        }\n    }\n    \n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    for (auto& p : d) {\n        int key = p.first;\n        int v = p.second;\n        if (pq.size() < k) {\n            pq.emplace(v, key);\n        } else {\n            if (v > pq.top().first) {\n                pq.pop();\n                pq.emplace(v, key);\n            }\n        }\n    }\n    \n    vector<int> result;\n    while (!pq.empty()) {\n        result.push_back(pq.top().second);\n        pq.pop();\n    }\n    \n    return result;\n}\n\nint main()\n{\n    assert((func({{1, 2, 6}, {1, 3, 4, 5, 7, 8}, {1, 3, 5, 6, 8, 9}, {2, 5, 7, 11}, {1, 4, 7, 8, 12}}, 3) == vector<int>({5, 7, 1})));\n    assert((func({{1, 2, 6}, {1, 3, 4, 5, 7, 8}, {1, 3, 5, 6, 8, 9}, {2, 5, 7, 11}, {1, 4, 7, 8, 12}}, 1) == vector<int>({1})));\n    assert((func({{1, 2, 6}, {1, 3, 4, 5, 7, 8}, {1, 3, 5, 6, 8, 9}, {2, 5, 7, 11}, {1, 4, 7, 8, 12}}, 5) == vector<int>({6, 5, 7, 8, 1})));\n}\n```"}
{"cpp_code_str": "\n#include <iostream>\n#include <queue>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n#include <vector>\nusing namespace std;\n\nstring rearrange_string(string S) {\n    unordered_map<char, int> ctr;\n    for (char c : S) {\n        ctr[c]++;\n    }\n    \n    auto comp = [](const pair<int, char>& left, const pair<int, char>& right) {\n        if (left.first == right.first) return left.second > right.second;\n        return left.first < right.first;\n    };\n    \n    priority_queue<pair<int, char>, vector<pair<int, char>>, decltype(comp)> heap(comp);\n    \n    for (auto& kv : ctr) {\n        heap.push(make_pair(-kv.second, kv.first));\n    }\n    \n    if (-heap.top().first * 2 > S.length() + 1) {\n        return \"\";\n    }\n    \n    string ans = \"\";\n    while (heap.size() >= 2) {\n        auto p1 = heap.top(); heap.pop();\n        auto p2 = heap.top(); heap.pop();\n        \n        ans += p1.second;\n        ans += p2.second;\n        \n        if (++p1.first != 0) heap.push(p1);\n        if (++p2.first != 0) heap.push(p2);\n    }\n    \n    if (!heap.empty()) {\n        ans += heap.top().second;\n    }\n    \n    return ans;\n}\n\n\n", "cpp_test": "int main() {\n    assert(rearrange_string(\"aab\") == \"aba\");\n    assert(rearrange_string(\"aabb\") == \"abab\");\n    assert(rearrange_string(\"abccdd\") == \"cdabcd\");\n}", "backup": "```cpp\n#include <iostream>\n#include <queue>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n#include <vector>\nusing namespace std;\n\nstring rearrange_string(string S) {\n    unordered_map<char, int> ctr;\n    for (char c : S) {\n        ctr[c]++;\n    }\n    \n    auto comp = [](const pair<int, char>& left, const pair<int, char>& right) {\n        if (left.first == right.first) return left.second > right.second;\n        return left.first < right.first;\n    };\n    \n    priority_queue<pair<int, char>, vector<pair<int, char>>, decltype(comp)> heap(comp);\n    \n    for (auto& kv : ctr) {\n        heap.push(make_pair(-kv.second, kv.first));\n    }\n    \n    if (-heap.top().first * 2 > S.length() + 1) {\n        return \"\";\n    }\n    \n    string ans = \"\";\n    while (heap.size() >= 2) {\n        auto p1 = heap.top(); heap.pop();\n        auto p2 = heap.top(); heap.pop();\n        \n        ans += p1.second;\n        ans += p2.second;\n        \n        if (++p1.first != 0) heap.push(p1);\n        if (++p2.first != 0) heap.push(p2);\n    }\n    \n    if (!heap.empty()) {\n        ans += heap.top().second;\n    }\n    \n    return ans;\n}\n\nint main() {\n    assert(rearrange_string(\"aab\") == \"aba\");\n    assert(rearrange_string(\"aabb\") == \"abab\");\n    assert(rearrange_string(\"abccdd\") == \"cdabcd\");\n}\n```"}
{"cpp_code_str": "\n#include <iostream>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nstring text_match(const string& text) {\n    try {\n        regex pattern(\"^[a-z]+_[a-z]+$\");\n        if (regex_search(text, pattern)) {\n            return \"Found a match!\";\n        } else {\n            return \"Not matched!\";\n        }\n    } catch (const regex_error& e) {\n        cout << \"Regex error: \" << e.what() << endl;\n        return \"Regex error\";\n    }\n}\n\n\n", "cpp_test": "int main() {\n    assert(text_match(\"aab_cbbbc\") == \"Found a match!\");\n    assert(text_match(\"aab_Abbbc\") == \"Not matched!\");\n    assert(text_match(\"Aaab_abbbc\") == \"Not matched!\");\n    assert(text_match(\"aab-cbbbc\") == \"Not matched!\");\n}", "backup": "```cpp\n#include <iostream>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nstring text_match(const string& text) {\n    try {\n        regex pattern(\"^[a-z]+_[a-z]+$\");\n        if (regex_search(text, pattern)) {\n            return \"Found a match!\";\n        } else {\n            return \"Not matched!\";\n        }\n    } catch (const regex_error& e) {\n        cout << \"Regex error: \" << e.what() << endl;\n        return \"Regex error\";\n    }\n}\n\nint main() {\n    assert(text_match(\"aab_cbbbc\") == \"Found a match!\");\n    assert(text_match(\"aab_Abbbc\") == \"Not matched!\");\n    assert(text_match(\"Aaab_abbbc\") == \"Not matched!\");\n    assert(text_match(\"aab-cbbbc\") == \"Not matched!\");\n}\n```"}
{"cpp_code_str": "\n#include <iostream>\n#include <regex>\n#include <cassert>\nusing namespace std;\n\nstring text_match_string(string text) {\n    try {\n        regex pattern(\"^\\\\w+\");\n        if (regex_search(text, pattern)) {\n            return \"Found a match!\";\n        } else {\n            return \"Not matched!\";\n        }\n    } catch (const regex_error& e) {\n        cerr << \"Regex error: \" << e.what() << endl;\n        return \"Regex error!\";\n    }\n}\n\n\n", "cpp_test": "int main() {\n    assert(text_match_string(\" python\") == \"Not matched!\");\n    assert(text_match_string(\"python\") == \"Found a match!\");\n    assert(text_match_string(\"  lang\") == \"Not matched!\");\n    assert(text_match_string(\"foo\") == \"Found a match!\");\n}", "backup": "```cpp\n#include <iostream>\n#include <regex>\n#include <cassert>\nusing namespace std;\n\nstring text_match_string(string text) {\n    try {\n        regex pattern(\"^\\\\w+\");\n        if (regex_search(text, pattern)) {\n            return \"Found a match!\";\n        } else {\n            return \"Not matched!\";\n        }\n    } catch (const regex_error& e) {\n        cerr << \"Regex error: \" << e.what() << endl;\n        return \"Regex error!\";\n    }\n}\n\nint main() {\n    assert(text_match_string(\" python\") == \"Not matched!\");\n    assert(text_match_string(\"python\") == \"Found a match!\");\n    assert(text_match_string(\"  lang\") == \"Not matched!\");\n    assert(text_match_string(\"foo\") == \"Found a match!\");\n}\n```"}
{"cpp_code_str": "\n#include <iostream>\n#include <vector>\n#include <typeinfo>\n#include <cassert>\n\nusing namespace std;\n\nint recursive_list_sum(const vector<int>& data_list);\n\nint recursive_list_sum(const vector<vector<int>>& data_list) {\n    int total = 0;\n    for(auto &element: data_list) {\n        total += recursive_list_sum(element);\n    }\n    return total;\n}\n\nint recursive_list_sum(const vector<int>& data_list) {\n    int total = 0;\n    for(auto &element: data_list) {\n        total += element;\n    }\n    return total;\n}\n\n\n", "cpp_test": "int main() {\n    assert(recursive_list_sum({1, 2, 3, 4, 5, 6}) == 21);\n    assert(recursive_list_sum({7, 10, 15, 14, 19, 41}) == 106);\n    assert(recursive_list_sum({10, 20, 30, 40, 50, 60}) == 210);\n    return 0;\n}", "backup": "```cpp\n#include <iostream>\n#include <vector>\n#include <typeinfo>\n#include <cassert>\n\nusing namespace std;\n\nint recursive_list_sum(const vector<int>& data_list);\n\nint recursive_list_sum(const vector<vector<int>>& data_list) {\n    int total = 0;\n    for(auto &element: data_list) {\n        total += recursive_list_sum(element);\n    }\n    return total;\n}\n\nint recursive_list_sum(const vector<int>& data_list) {\n    int total = 0;\n    for(auto &element: data_list) {\n        total += element;\n    }\n    return total;\n}\n\nint main() {\n    assert(recursive_list_sum({1, 2, 3, 4, 5, 6}) == 21);\n    assert(recursive_list_sum({7, 10, 15, 14, 19, 41}) == 106);\n    assert(recursive_list_sum({10, 20, 30, 40, 50, 60}) == 210);\n    return 0;\n}\n```"}
{"cpp_code_str": "\n#include <iostream>\n#include <string>\n#include <vector>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nvector<string> multiple_split(const string& text) {\n    regex delimiter(\"; |, |\\\\*|\\n\");\n    vector<string> result;\n    sregex_token_iterator iter(text.begin(), text.end(), delimiter, -1);\n    sregex_token_iterator end;\n    while(iter != end) {\n        result.push_back(*iter++);\n    }\n    return result;\n}\n\n\n", "cpp_test": "int main()\n{\n    vector<string> res1 = multiple_split(\"Forces of the \\ndarkness*are coming into the play.\");\n    assert((res1 == vector<string>{\"Forces of the \", \"darkness\", \"are coming into the play.\"}));\n\n    vector<string> res2 = multiple_split(\"Mi Box runs on the \\n Latest android*which has google assistance and chromecast.\");\n    assert((res2 == vector<string>{\"Mi Box runs on the \", \" Latest android\", \"which has google assistance and chromecast.\"}));\n\n    vector<string> res3 = multiple_split(\"Certain services\\nare subjected to change*over the seperate subscriptions.\");\n    assert((res3 == vector<string>{\"Certain services\", \"are subjected to change\", \"over the seperate subscriptions.\"}));\n}", "backup": "```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nvector<string> multiple_split(const string& text) {\n    regex delimiter(\"; |, |\\\\*|\\n\");\n    vector<string> result;\n    sregex_token_iterator iter(text.begin(), text.end(), delimiter, -1);\n    sregex_token_iterator end;\n    while(iter != end) {\n        result.push_back(*iter++);\n    }\n    return result;\n}\n\nint main()\n{\n    vector<string> res1 = multiple_split(\"Forces of the \\ndarkness*are coming into the play.\");\n    assert((res1 == vector<string>{\"Forces of the \", \"darkness\", \"are coming into the play.\"}));\n\n    vector<string> res2 = multiple_split(\"Mi Box runs on the \\n Latest android*which has google assistance and chromecast.\");\n    assert((res2 == vector<string>{\"Mi Box runs on the \", \" Latest android\", \"which has google assistance and chromecast.\"}));\n\n    vector<string> res3 = multiple_split(\"Certain services\\nare subjected to change*over the seperate subscriptions.\");\n    assert((res3 == vector<string>{\"Certain services\", \"are subjected to change\", \"over the seperate subscriptions.\"}));\n}\n```"}
{"cpp_code_str": "\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nint kth_element(vector<int>& arr, int n, int k) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                swap(arr[j], arr[j + 1]);\n            }\n        }\n    }\n    return arr[k - 1];\n}\n\n\n", "cpp_test": "int main() {\n    vector<int> arr1 = {12, 3, 5, 7, 19};\n    assert(kth_element(arr1, 5, 2) == 3);\n\n    vector<int> arr2 = {17, 24, 8, 23};\n    assert(kth_element(arr2, 4, 3) == 23); // The expected result should be 23 here not 8.\n\n    vector<int> arr3 = {16, 21, 25, 36, 4};\n    assert(kth_element(arr3, 5, 4) == 25); // The expected result should be 25 here not 36.\n\n    return 0;\n}", "backup": "```cpp\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nint kth_element(vector<int>& arr, int n, int k) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                swap(arr[j], arr[j + 1]);\n            }\n        }\n    }\n    return arr[k - 1];\n}\n\nint main() {\n    vector<int> arr1 = {12, 3, 5, 7, 19};\n    assert(kth_element(arr1, 5, 2) == 3);\n\n    vector<int> arr2 = {17, 24, 8, 23};\n    assert(kth_element(arr2, 4, 3) == 23); // The expected result should be 23 here not 8.\n\n    vector<int> arr3 = {16, 21, 25, 36, 4};\n    assert(kth_element(arr3, 5, 4) == 25); // The expected result should be 25 here not 36.\n\n    return 0;\n}\n```"}
{"cpp_code_str": "\n#include <vector>\n#include <map>\n#include <tuple>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename T>\nstring tuple_to_string(const T& tup) {\n    stringstream ss;\n    ss << \"(\";\n    std::apply([&ss](auto&&... args) {((ss << args << \", \"), ...);}, tup);\n    string result = ss.str();\n    result.pop_back();\n    result.pop_back();\n    result += \")\";\n    return result;\n}\n\ntemplate<typename... Ts>\nstring assign_freq(vector<tuple<Ts...>> test_list) {\n    map<tuple<Ts...>, int> freq_map;\n    for (const auto& item : test_list) {\n        freq_map[item]++;\n    }\n    vector<tuple<Ts..., int>> result;\n    for (const auto& entry : freq_map) {\n        auto extended = tuple_cat(entry.first, make_tuple(entry.second));\n        result.push_back(extended);\n    }\n    stringstream ss;\n    ss << \"[\";\n    for (const auto& item : result) {\n        ss << tuple_to_string(item) << \", \";\n    }\n    if (!result.empty()) {\n        ss.seekp(-2, ios_base::end);\n    }\n    ss << \"]\";\n    return ss.str();\n}\n\n\n", "cpp_test": "int main() {\n    assert(assign_freq({make_tuple(6, 5, 8), make_tuple(2, 7), make_tuple(6, 5, 8), make_tuple(6, 5, 8), make_tuple(9), make_tuple(2, 7)}) == \"[(6, 5, 8, 3), (2, 7, 2), (9, 1)]\");\n    assert(assign_freq({make_tuple(4, 2, 4), make_tuple(7, 1), make_tuple(4, 8), make_tuple(4, 2, 4), make_tuple(9, 2), make_tuple(7, 1)}) == \"[(4, 2, 4, 2), (7, 1, 2), (4, 8, 1), (9, 2, 1)]\");\n    assert(assign_freq({make_tuple(11, 13, 10), make_tuple(17, 21), make_tuple(4, 2, 3), make_tuple(17, 21), make_tuple(9, 2), make_tuple(4, 2, 3)}) == \"[(11, 13, 10, 1), (17, 21, 2), (4, 2, 3, 2), (9, 2, 1)]\");\n}", "backup": "```cpp\n#include <vector>\n#include <map>\n#include <tuple>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename T>\nstring tuple_to_string(const T& tup) {\n    stringstream ss;\n    ss << \"(\";\n    std::apply([&ss](auto&&... args) {((ss << args << \", \"), ...);}, tup);\n    string result = ss.str();\n    result.pop_back();\n    result.pop_back();\n    result += \")\";\n    return result;\n}\n\ntemplate<typename... Ts>\nstring assign_freq(vector<tuple<Ts...>> test_list) {\n    map<tuple<Ts...>, int> freq_map;\n    for (const auto& item : test_list) {\n        freq_map[item]++;\n    }\n    vector<tuple<Ts..., int>> result;\n    for (const auto& entry : freq_map) {\n        auto extended = tuple_cat(entry.first, make_tuple(entry.second));\n        result.push_back(extended);\n    }\n    stringstream ss;\n    ss << \"[\";\n    for (const auto& item : result) {\n        ss << tuple_to_string(item) << \", \";\n    }\n    if (!result.empty()) {\n        ss.seekp(-2, ios_base::end);\n    }\n    ss << \"]\";\n    return ss.str();\n}\n\nint main() {\n    assert(assign_freq({make_tuple(6, 5, 8), make_tuple(2, 7), make_tuple(6, 5, 8), make_tuple(6, 5, 8), make_tuple(9), make_tuple(2, 7)}) == \"[(6, 5, 8, 3), (2, 7, 2), (9, 1)]\");\n    assert(assign_freq({make_tuple(4, 2, 4), make_tuple(7, 1), make_tuple(4, 8), make_tuple(4, 2, 4), make_tuple(9, 2), make_tuple(7, 1)}) == \"[(4, 2, 4, 2), (7, 1, 2), (4, 8, 1), (9, 2, 1)]\");\n    assert(assign_freq({make_tuple(11, 13, 10), make_tuple(17, 21), make_tuple(4, 2, 3), make_tuple(17, 21), make_tuple(9, 2), make_tuple(4, 2, 3)}) == \"[(11, 13, 10, 1), (17, 21, 2), (4, 2, 3, 2), (9, 2, 1)]\");\n}\n```"}
{"cpp_code_str": "\n#include <vector>\n#include <string>\n#include <tuple>\n#include <cassert>\n\nusing namespace std;\n\nvector<tuple<int, int>> tuple_int_str(const vector<tuple<string, string>>& tuple_str) {\n    vector<tuple<int, int>> result;\n    for (const auto& x : tuple_str) {\n        int first = stoi(get<0>(x));\n        int second = stoi(get<1>(x));\n        result.push_back(make_tuple(first, second));\n    }\n    return result;\n}\n\n\n", "cpp_test": "int main()\n{\n    vector<tuple<string, string>> test1 = {{\"333\", \"33\"}, {\"1416\", \"55\"}};\n    auto t1 = tuple_int_str(test1);\n    assert((get<0>(t1) == make_tuple(333, 33)) && (get<1>(t1) == make_tuple(1416, 55)));\n\n    vector<tuple<string, string>> test2 = {{\"999\", \"99\"}, {\"1000\", \"500\"}};\n    auto t2 = tuple_int_str(test2);\n    assert((get<0>(t2) == make_tuple(999, 99)) && (get<1>(t2) == make_tuple(1000, 500)));\n\n    vector<tuple<string, string>> test3 = {{\"666\", \"66\"}, {\"1500\", \"555\"}};\n    auto t3 = tuple_int_str(test3);\n    assert((get<0>(t3) == make_tuple(666, 66)) && (get<1>(t3) == make_tuple(1500, 555)));\n}", "backup": "```cpp\n#include <vector>\n#include <string>\n#include <tuple>\n#include <cassert>\n\nusing namespace std;\n\nvector<tuple<int, int>> tuple_int_str(const vector<tuple<string, string>>& tuple_str) {\n    vector<tuple<int, int>> result;\n    for (const auto& x : tuple_str) {\n        int first = stoi(get<0>(x));\n        int second = stoi(get<1>(x));\n        result.push_back(make_tuple(first, second));\n    }\n    return result;\n}\n\nint main()\n{\n    vector<tuple<string, string>> test1 = {{\"333\", \"33\"}, {\"1416\", \"55\"}};\n    auto t1 = tuple_int_str(test1);\n    assert((get<0>(t1) == make_tuple(333, 33)) && (get<1>(t1) == make_tuple(1416, 55)));\n\n    vector<tuple<string, string>> test2 = {{\"999\", \"99\"}, {\"1000\", \"500\"}};\n    auto t2 = tuple_int_str(test2);\n    assert((get<0>(t2) == make_tuple(999, 99)) && (get<1>(t2) == make_tuple(1000, 500)));\n\n    vector<tuple<string, string>> test3 = {{\"666\", \"66\"}, {\"1500\", \"555\"}};\n    auto t3 = tuple_int_str(test3);\n    assert((get<0>(t3) == make_tuple(666, 66)) && (get<1>(t3) == make_tuple(1500, 555)));\n}\n```"}
{"cpp_code_str": "\n#include <iostream>\n#include <string>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nstring remove_splchar(const string& text) {\n    regex pattern(\"[\\\\W_]+\");\n    return regex_replace(text, pattern, string(\"\"));\n}\n\n\n", "cpp_test": "int main() {\n    assert(remove_splchar(\"python  @#&^%$*program123\") == \"pythonprogram123\");\n    assert(remove_splchar(\"python %^$@!^&*()  programming24%$^^()    language\") == \"pythonprogramming24language\");\n    assert(remove_splchar(\"python   ^%&^()(+_)(_^&67)                  program\") == \"python67program\");\n}", "backup": "```cpp\n#include <iostream>\n#include <string>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nstring remove_splchar(const string& text) {\n    regex pattern(\"[\\\\W_]+\");\n    return regex_replace(text, pattern, string(\"\"));\n}\n\nint main() {\n    assert(remove_splchar(\"python  @#&^%$*program123\") == \"pythonprogram123\");\n    assert(remove_splchar(\"python %^$@!^&*()  programming24%$^^()    language\") == \"pythonprogramming24language\");\n    assert(remove_splchar(\"python   ^%&^()(+_)(_^&67)                  program\") == \"python67program\");\n}\n```"}
{"cpp_code_str": "\n#include <string>\n#include <vector>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nstring string_literals(const vector<string>& patterns, const string& text) {\n    for (const auto& pattern : patterns) {\n        regex re_pattern(pattern);\n        if (regex_search(text, re_pattern)) {\n            return \"Matched!\";\n        }\n    }\n    return \"Not Matched!\";\n}\n\n\n", "cpp_test": "int main()\n{\n    assert(string_literals({\"language\"}, \"python language\") == \"Matched!\");\n    assert(string_literals({\"program\"}, \"python language\") == \"Not Matched!\");\n    assert(string_literals({\"python\"}, \"programming language\") == \"Not Matched!\");\n}", "backup": "```cpp\n#include <string>\n#include <vector>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nstring string_literals(const vector<string>& patterns, const string& text) {\n    for (const auto& pattern : patterns) {\n        regex re_pattern(pattern);\n        if (regex_search(text, re_pattern)) {\n            return \"Matched!\";\n        }\n    }\n    return \"Not Matched!\";\n}\n\nint main()\n{\n    assert(string_literals({\"language\"}, \"python language\") == \"Matched!\");\n    assert(string_literals({\"program\"}, \"python language\") == \"Not Matched!\");\n    assert(string_literals({\"python\"}, \"programming language\") == \"Not Matched!\");\n}\n```"}
{"cpp_code_str": "\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\ndouble distance_lat_long(double slat, double slon, double elat, double elon) {\n    slat = slat * M_PI / 180.0;\n    slon = slon * M_PI / 180.0;\n    elat = elat * M_PI / 180.0;\n    elon = elon * M_PI / 180.0;\n    double dist = 6371.01 * acos(sin(slat) * sin(elat) + cos(slat) * cos(elat) * cos(slon - elon));\n    return dist;\n}\n\n\n", "cpp_test": "int main()\n{\n    assert(abs(distance_lat_long(23.5, 67.5, 25.5, 69.5) - 12179.372041317429) < 0.0001);\n    assert(abs(distance_lat_long(10.5, 20.5, 30.5, 40.5) - 6069.397933300514) < 0.0001);\n    assert(abs(distance_lat_long(10, 20, 30, 40) - 6783.751974994595) < 0.0001);\n}", "backup": "```cpp\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\ndouble distance_lat_long(double slat, double slon, double elat, double elon) {\n    slat = slat * M_PI / 180.0;\n    slon = slon * M_PI / 180.0;\n    elat = elat * M_PI / 180.0;\n    elon = elon * M_PI / 180.0;\n    double dist = 6371.01 * acos(sin(slat) * sin(elat) + cos(slat) * cos(elat) * cos(slon - elon));\n    return dist;\n}\n\nint main()\n{\n    assert(abs(distance_lat_long(23.5, 67.5, 25.5, 69.5) - 12179.372041317429) < 0.0001);\n    assert(abs(distance_lat_long(10.5, 20.5, 30.5, 40.5) - 6069.397933300514) < 0.0001);\n    assert(abs(distance_lat_long(10, 20, 30, 40) - 6783.751974994595) < 0.0001);\n}\n```"}
{"cpp_code_str": "\n#include <iostream>\n#include <regex>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nstring check_literals(string text, vector<string> patterns) {\n    for (auto pattern : patterns) {\n        if (regex_search(text, regex(pattern))) {\n            return \"Matched!\";\n        }\n    }\n    return \"Not Matched!\";\n}\n\n\n", "cpp_test": "int main()\n{\n    assert(check_literals(\"The quick brown fox jumps over the lazy dog.\", {\"fox\"}) == \"Matched!\");\n    assert(check_literals(\"The quick brown fox jumps over the lazy dog.\", {\"horse\"}) == \"Not Matched!\");\n    assert(check_literals(\"The quick brown fox jumps over the lazy dog.\", {\"lazy\"}) == \"Matched!\");\n}", "backup": "```cpp\n#include <iostream>\n#include <regex>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nstring check_literals(string text, vector<string> patterns) {\n    for (auto pattern : patterns) {\n        if (regex_search(text, regex(pattern))) {\n            return \"Matched!\";\n        }\n    }\n    return \"Not Matched!\";\n}\n\nint main()\n{\n    assert(check_literals(\"The quick brown fox jumps over the lazy dog.\", {\"fox\"}) == \"Matched!\");\n    assert(check_literals(\"The quick brown fox jumps over the lazy dog.\", {\"horse\"}) == \"Not Matched!\");\n    assert(check_literals(\"The quick brown fox jumps over the lazy dog.\", {\"lazy\"}) == \"Matched!\");\n}\n```"}
{"cpp_code_str": "\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\nvector<tuple<int, int>> remove_tuples(vector<tuple<int, int>> test_list, int K) {\n    vector<tuple<int, int>> res;\n    for (auto ele : test_list) {\n        if (tuple_size<decltype(ele)>::value != K) {\n            res.push_back(ele);\n        }\n    }\n    return res;\n}\n\n\n", "cpp_test": "int main()\n{\n    assert(remove_tuples({make_tuple(4, 5), make_tuple(8, 6, 7), make_tuple(3, 4, 6, 7)}, 1) == vector<tuple<int, int>>{make_tuple(4, 5), make_tuple(8, 6, 7), make_tuple(3, 4, 6, 7)});\n    assert(remove_tuples({make_tuple(1, 2, 3), make_tuple(3, 4, 6, 7)}, 2) == vector<tuple<int, int>>{make_tuple(1, 2, 3), make_tuple(3, 4, 6, 7)});\n    assert(remove_tuples({make_tuple(4, 3), make_tuple(1)}, 3) == vector<tuple<int, int>>{make_tuple(4, 3), make_tuple(1)});\n}", "backup": "```cpp\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\nvector<tuple<int, int>> remove_tuples(vector<tuple<int, int>> test_list, int K) {\n    vector<tuple<int, int>> res;\n    for (auto ele : test_list) {\n        if (tuple_size<decltype(ele)>::value != K) {\n            res.push_back(ele);\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    assert(remove_tuples({make_tuple(4, 5), make_tuple(8, 6, 7), make_tuple(3, 4, 6, 7)}, 1) == vector<tuple<int, int>>{make_tuple(4, 5), make_tuple(8, 6, 7), make_tuple(3, 4, 6, 7)});\n    assert(remove_tuples({make_tuple(1, 2, 3), make_tuple(3, 4, 6, 7)}, 2) == vector<tuple<int, int>>{make_tuple(1, 2, 3), make_tuple(3, 4, 6, 7)});\n    assert(remove_tuples({make_tuple(4, 3), make_tuple(1)}, 3) == vector<tuple<int, int>>{make_tuple(4, 3), make_tuple(1)});\n}\n```"}
{"cpp_code_str": "", "cpp_test": "", "backup": ""}
{"cpp_code_str": "\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nvector<int> heap_replace(vector<int>& heap, int a) {\n    make_heap(heap.begin(), heap.end(), greater<int>());\n    pop_heap(heap.begin(), heap.end(), greater<int>());\n    heap.pop_back();\n    heap.push_back(a);\n    push_heap(heap.begin(), heap.end(), greater<int>());\n    sort_heap(heap.begin(), heap.end(), greater<int>());\n    return heap;\n}\n\n\n", "cpp_test": "int main() {\n    vector<int> heap1 = {25, 44, 68, 21, 39, 23, 89};\n    vector<int> heap2 = {25, 44, 68, 21, 39, 23, 89};\n    vector<int> heap3 = {25, 44, 68, 21, 39, 23, 89};\n\n    assert(heap_replace(heap1, 21) == vector<int>({21, 23, 25, 39, 44, 68, 89}));\n    assert(heap_replace(heap2, 110) == vector<int>({23, 25, 39, 44, 68, 89, 110}));\n    assert(heap_replace(heap3, 500) == vector<int>({23, 25, 39, 44, 68, 89, 500}));\n}", "backup": "```cpp\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nvector<int> heap_replace(vector<int>& heap, int a) {\n    make_heap(heap.begin(), heap.end(), greater<int>());\n    pop_heap(heap.begin(), heap.end(), greater<int>());\n    heap.pop_back();\n    heap.push_back(a);\n    push_heap(heap.begin(), heap.end(), greater<int>());\n    sort_heap(heap.begin(), heap.end(), greater<int>());\n    return heap;\n}\n\nint main() {\n    vector<int> heap1 = {25, 44, 68, 21, 39, 23, 89};\n    vector<int> heap2 = {25, 44, 68, 21, 39, 23, 89};\n    vector<int> heap3 = {25, 44, 68, 21, 39, 23, 89};\n\n    assert(heap_replace(heap1, 21) == vector<int>({21, 23, 25, 39, 44, 68, 89}));\n    assert(heap_replace(heap2, 110) == vector<int>({23, 25, 39, 44, 68, 89, 110}));\n    assert(heap_replace(heap3, 500) == vector<int>({23, 25, 39, 44, 68, 89, 500}));\n}\n```"}
{"cpp_code_str": "\n#include <regex>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nbool is_allowed_specific_char(string str) {\n    try {\n        regex get_char(\"[^a-zA-Z0-9\\\\.]\");\n        return !regex_search(str, get_char);\n    } catch (regex_error& e) {\n        return false; \n    }\n}\n\n\n", "cpp_test": "int main() {\n    assert(is_allowed_specific_char(\"ABCDEFabcdef123450\") == true);\n    assert(is_allowed_specific_char(\"*&%@#!}{\") == false);\n    assert(is_allowed_specific_char(\"HELLOhowareyou98765\") == true);\n}", "backup": "```cpp\n#include <regex>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nbool is_allowed_specific_char(string str) {\n    try {\n        regex get_char(\"[^a-zA-Z0-9\\\\.]\");\n        return !regex_search(str, get_char);\n    } catch (regex_error& e) {\n        return false; \n    }\n}\n\nint main() {\n    assert(is_allowed_specific_char(\"ABCDEFabcdef123450\") == true);\n    assert(is_allowed_specific_char(\"*&%@#!}{\") == false);\n    assert(is_allowed_specific_char(\"HELLOhowareyou98765\") == true);\n}\n```"}
{"cpp_code_str": "\n#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n\nusing namespace std;\n\nint min_Operations(int A, int B) {\n    if (A > B) {\n        swap(A, B);\n    }\n    B = B / std::gcd(A, B);\n    return B - 1;\n}\n\n\n", "cpp_test": "int main() {\n    assert(min_Operations(2, 4) == 1);\n    assert(min_Operations(4, 10) == 4);\n    assert(min_Operations(1, 4) == 3);\n}", "backup": "```cpp\n#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n\nusing namespace std;\n\nint min_Operations(int A, int B) {\n    if (A > B) {\n        swap(A, B);\n    }\n    B = B / std::gcd(A, B);\n    return B - 1;\n}\n\nint main() {\n    assert(min_Operations(2, 4) == 1);\n    assert(min_Operations(4, 10) == 4);\n    assert(min_Operations(1, 4) == 3);\n}\n```"}
{"cpp_code_str": "\n#include <iostream>\n#include <regex>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nstring replace_max_specialchar(string text, int n) {\n    regex pattern(\"[ ,.]\");\n    string result = text;\n    auto start = result.begin();\n    for (int i = 0; i < n; ++i) {\n        auto it = regex_search(start, result.end(), pattern) ? result.begin() + distance(result.begin(), start) + distance(start, regex_iterator<string::iterator>(start, result.end(), pattern)->prefix().second) : result.end();\n        if (it == result.end()) break;\n        *it = ':';\n        start = it + 1;\n    }\n    return result;\n}\n\n\n", "cpp_test": "int main() {\n    assert(replace_max_specialchar(\"Python language, Programming language.\", 2) == \"Python:language: Programming language.\");\n    assert(replace_max_specialchar(\"a b c,d e f\", 3) == \"a:b:c:d e f\");\n    assert(replace_max_specialchar(\"ram reshma,ram rahim\", 1) == \"ram:reshma,ram rahim\");\n}", "backup": "```cpp\n#include <iostream>\n#include <regex>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nstring replace_max_specialchar(string text, int n) {\n    regex pattern(\"[ ,.]\");\n    string result = text;\n    auto start = result.begin();\n    for (int i = 0; i < n; ++i) {\n        auto it = regex_search(start, result.end(), pattern) ? result.begin() + distance(result.begin(), start) + distance(start, regex_iterator<string::iterator>(start, result.end(), pattern)->prefix().second) : result.end();\n        if (it == result.end()) break;\n        *it = ':';\n        start = it + 1;\n    }\n    return result;\n}\n\nint main() {\n    assert(replace_max_specialchar(\"Python language, Programming language.\", 2) == \"Python:language: Programming language.\");\n    assert(replace_max_specialchar(\"a b c,d e f\", 3) == \"a:b:c:d e f\");\n    assert(replace_max_specialchar(\"ram reshma,ram rahim\", 1) == \"ram:reshma,ram rahim\");\n}\n```"}
{"cpp_code_str": "\n#include <tuple>\n#include <typeinfo>\n#include <cassert>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\ntemplate<typename... Args>\nbool check_type(const tuple<Args...>& test_tuple) {\n    const type_info& first_type = typeid(get<0>(test_tuple));\n    return apply([&first_type](auto&&... args) -> bool {\n        return ((typeid(args) == first_type) && ...);\n    }, test_tuple);\n}\n\n\n", "cpp_test": "int main()\n{\n    assert(check_type(make_tuple(5, 6, 7, 3, 5, 6)) == true);\n    assert(check_type(make_tuple(1, 2, \"4\")) == false);\n    assert(check_type(make_tuple(3, 2, 1, 4, 5)) == true);\n}", "backup": "```cpp\n#include <tuple>\n#include <typeinfo>\n#include <cassert>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\ntemplate<typename... Args>\nbool check_type(const tuple<Args...>& test_tuple) {\n    const type_info& first_type = typeid(get<0>(test_tuple));\n    return apply([&first_type](auto&&... args) -> bool {\n        return ((typeid(args) == first_type) && ...);\n    }, test_tuple);\n}\n\nint main()\n{\n    assert(check_type(make_tuple(5, 6, 7, 3, 5, 6)) == true);\n    assert(check_type(make_tuple(1, 2, \"4\")) == false);\n    assert(check_type(make_tuple(3, 2, 1, 4, 5)) == true);\n}\n```"}
{"cpp_code_str": "\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nint max_sum(vector<vector<int>>& tri, int n) {\n    if (n > 1) {\n        tri[1][1] = tri[1][1] + tri[0][0];\n        tri[1][0] = tri[1][0] + tri[0][0];\n    }\n    for (int i = 2; i < n; i++) {\n        tri[i][0] = tri[i][0] + tri[i - 1][0];\n        tri[i][i] = tri[i][i] + tri[i - 1][i - 1];\n        for (int j = 1; j < i; j++) {\n            if (tri[i][j] + tri[i - 1][j - 1] >= tri[i][j] + tri[i - 1][j]) {\n                tri[i][j] = tri[i][j] + tri[i - 1][j - 1];\n            } else {\n                tri[i][j] = tri[i][j] + tri[i - 1][j];\n            }\n        }\n    }\n    return *max_element(tri[n - 1].begin(), tri[n - 1].end());\n}\n\n\n", "cpp_test": "int main() {\n    vector<vector<int>> tri1{{1}, {2, 1}, {3, 3, 2}};\n    vector<vector<int>> tri2{{1}, {1, 2}, {4, 1, 12}};\n    vector<vector<int>> tri3{{2}, {3, 2}, {13, 23, 12}};\n\n    assert(max_sum(tri1, 3) == 6);\n    assert(max_sum(tri2, 3) == 15);\n    assert(max_sum(tri3, 3) == 28);\n\n    return 0;\n}", "backup": "```cpp\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nint max_sum(vector<vector<int>>& tri, int n) {\n    if (n > 1) {\n        tri[1][1] = tri[1][1] + tri[0][0];\n        tri[1][0] = tri[1][0] + tri[0][0];\n    }\n    for (int i = 2; i < n; i++) {\n        tri[i][0] = tri[i][0] + tri[i - 1][0];\n        tri[i][i] = tri[i][i] + tri[i - 1][i - 1];\n        for (int j = 1; j < i; j++) {\n            if (tri[i][j] + tri[i - 1][j - 1] >= tri[i][j] + tri[i - 1][j]) {\n                tri[i][j] = tri[i][j] + tri[i - 1][j - 1];\n            } else {\n                tri[i][j] = tri[i][j] + tri[i - 1][j];\n            }\n        }\n    }\n    return *max_element(tri[n - 1].begin(), tri[n - 1].end());\n}\n\nint main() {\n    vector<vector<int>> tri1{{1}, {2, 1}, {3, 3, 2}};\n    vector<vector<int>> tri2{{1}, {1, 2}, {4, 1, 12}};\n    vector<vector<int>> tri3{{2}, {3, 2}, {13, 23, 12}};\n\n    assert(max_sum(tri1, 3) == 6);\n    assert(max_sum(tri2, 3) == 15);\n    assert(max_sum(tri3, 3) == 28);\n\n    return 0;\n}\n```"}
