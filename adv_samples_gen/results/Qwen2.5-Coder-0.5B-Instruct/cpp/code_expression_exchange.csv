Index,Original Code,Program Length,Ground truth,Original Prediction,Adversarial Code,Adversarial truth,Adv Prediction,Is Success,Query Times,Time Cost,Perturbation Type,orig prob,current prob,Attack path
0,"#include <iostream>
#include <cassert>
std::string remove_Occ(std::string s, char ch) {
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == ch) {
            s = s.substr(0, i) + s.substr(i + 1);
            break;
        }
    }
//begin to write code
",264,"
#include <iostream>
#include <cassert>

std::string remove_Occ(std::string s, char ch) {
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == ch) {
            s = s.substr(0, i) + s.substr(i + 1);
            break;
        }
    }
    for (int i = s.length() - 1; i >= 0; i--) {
        if (s[i] == ch) {
            s = s.substr(0, i) + s.substr(i + 1);
            break;
        }
    }
    return s;
}


","
#include <iostream>
#include <cassert>
std::string remove_Occ(std::string s, char ch) {
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == ch) {
            s = s.substr(0, i) + s.substr(i + 1);
            break;
        }
    }
    return s;
}

// Test function to verify the correctness of the remove_Occ function
void test_remove_Occ() {
    assert(remove_Occ(""hello"", 'l') == ""heo"");
    assert(remove_Occ(""world"", 'o') == ""world"");
    assert(remove_Occ(""cpp"", 'p') == ""cpp"");
    assert(remove_Occ("""", 'a') == """");
    assert(remove_Occ(""ababab"", 'b') == ""acaba"");
    std::cout << ""All test cases passed!"" << std::endl;
}

",,,,-2,1,0.23566884597142537,code_expression_exchange:None,0.0,0.0,
1,"#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
#include <numeric>
using namespace std;
vector<vector<int>> sort_matrix(vector<vector<int>> M) {
    sort(M.begin(), M.end(), [](const vector<int>& a, const vector<int>& b) {
        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);
//begin to write code
",360,"#include<iostream>
    

#include <vector>
#include <algorithm>
#include <cassert>
#include <numeric>
using namespace std;

vector<vector<int>> sort_matrix(vector<vector<int>> M) {
    sort(M.begin(), M.end(), [](const vector<int>& a, const vector<int>& b) {
        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);
    });
    return M;
}


","
#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
#include <numeric>
using namespace std;

vector<vector<int>> sort_matrix(vector<vector<int>> M) {
    sort(M.begin(), M.end(), [](const vector<int>& a, const vector<int>& b) {
        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);
    });
    return M;
}

","#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
#include <numeric>
using namespace std;
vector<vector<long>> sort_matrix(vector<vector<int>> M) {
    sort(M.begin(), M.end(), [](const vector<int>& a, const vector<int>& b) {
        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);
//begin to write code
","#include<iostream>
    

#include <vector>
#include <algorithm>
#include <cassert>
#include <numeric>
using namespace std;

vector<vector<long>> sort_matrix(vector<vector<int>> M) {
    sort(M.begin(), M.end(), [](const vector<int>& a, const vector<int>& b) {
        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);
    });
    return M;
}


","
#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
#include <numeric>
using namespace std;

vector<vector<long>> sort_matrix(vector<vector<int>> M) {
    sort(M.begin(), M.end(), [](const vector<int>& a, const vector<int>& b) {
        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);
    });
    return M;
}

",1,7,0.99322669506073,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<iostream>\n    \n\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\nvector<vector<long>> sort_matrix(vector<vector<int>> M) {\n    sort(M.begin(), M.end(), [](const vector<int>& a, const vector<int>& b) {\n        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);\n    });\n    return M;\n}\n\n\n': [('#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <numeric>\nusing namespace std;\nvector<vector<int>> sort_matrix(vector<vector<int>> M) {\n    sort(M.begin(), M.end(), [](const vector<int>& a, const vector<int>& b) {\n        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\nvector<vector<int>> sort_matrix(vector<vector<int>> M) {\n    sort(M.begin(), M.end(), [](const vector<int>& a, const vector<int>& b) {\n        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);\n    });\n    return M;\n}\n\n', 'bool2int'), ('#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <numeric>\nusing namespace std;\nvector<vector<int>> sort_matrix(vector<vector<int>> M) {\n    sort(M.begin(), M.end(), [](const vector<int>& a, const vector<int>& b) {\n        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\nvector<vector<int>> sort_matrix(vector<vector<int>> M) {\n    sort(M.begin(), M.end(), [](const vector<int>& a, const vector<int>& b) {\n        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);\n    });\n    return M;\n}\n\n', 'bool2int'), ('#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <numeric>\nusing namespace std;\nvector<vector<long>> sort_matrix(vector<vector<int>> M) {\n    sort(M.begin(), M.end(), [](const vector<int>& a, const vector<int>& b) {\n        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\nvector<vector<long>> sort_matrix(vector<vector<int>> M) {\n    sort(M.begin(), M.end(), [](const vector<int>& a, const vector<int>& b) {\n        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);\n    });\n    return M;\n}\n\n', 'more_universe_var_type')]}"
2,"#include <vector>
#include <string>
#include <map>
#include <algorithm>
#include <cassert>
#include <iostream>
using namespace std;
vector<pair<string, int>> count_common(const vector<string>& words) {
    map<string, int> word_counts;
    for (const auto& word : words) {
        word_counts[word]++;
    }
    vector<pair<string, int>> sorted_counts(word_counts.begin(), word_counts.end());
    sort(sorted_counts.begin(), sorted_counts.end(), [](const pair<string, int>& a, const pair<string, int>& b) {
//begin to write code
",529,"#include <vector>
#include <string>
#include <map>
#include <algorithm>
#include <cassert>
#include <iostream>
using namespace std;

vector<pair<string, int>> count_common(const vector<string>& words) {
    map<string, int> word_counts;
    for (const auto& word : words) {
        word_counts[word]++;
    }

    vector<pair<string, int>> sorted_counts(word_counts.begin(), word_counts.end());
    sort(sorted_counts.begin(), sorted_counts.end(), [](const pair<string, int>& a, const pair<string, int>& b) {
        return a.second > b.second || (a.second == b.second && a.first > b.first);
    });

    if (sorted_counts.size() > 4) {
        sorted_counts.resize(4);
    }
    return sorted_counts;
}","
#include <vector>
#include <string>
#include <map>
#include <algorithm>
#include <cassert>
#include <iostream>
using namespace std;

vector<pair<string, int>> count_common(const vector<string>& words) {
    map<string, int> word_counts;
    for (const auto& word : words) {
        word_counts[word]++;
    }
    vector<pair<string, int>> sorted_counts(word_counts.begin(), word_counts.end());
    sort(sorted_counts.begin(), sorted_counts.end(), [](const pair<string, int>& a, const pair<string, int>& b) {
        return a.second > b.second; // Sort by frequency in descending order
    });
    return sorted_counts;
}

",,,,-2,1,0.22277750174204508,code_expression_exchange:None,0.0,0.0,
3,"#include <iostream>
#include <cassert>
int find_Volume(int l, int b, int h) {
//begin to write code
",100,"
#include <iostream>
#include <cassert>

int find_Volume(int l, int b, int h) {
    return ((l * b * h) / 2);
}


","
#include <iostream>
#include <cassert>

int find_Volume(int l, int b, int h) {
    return l * b * h;
}

",,,,-2,1,0.19794020255406697,code_expression_exchange:None,0.0,0.0,
4,"#include <iostream>
#include <string>
#include <vector>
#include <cassert>
using namespace std;
vector<string> split_lowerstring(const string& text) {
    vector<string> result;
    size_t len = text.length();
    size_t i = 0;
    while (i < len) {
        if (text[i] >= 'a' && text[i] <= 'z') {
            size_t start = i;
            i++;
            while (i < len && (text[i] < 'a' || text[i] > 'z')) {
//begin to write code
",433,"#include <iostream>
#include <string>
#include <vector>
#include <cassert>

using namespace std;

vector<string> split_lowerstring(const string& text) {
    vector<string> result;
    size_t len = text.length();
    size_t i = 0;

    while (i < len) {

        if (text[i] >= 'a' && text[i] <= 'z') {
            size_t start = i;
            i++;

            while (i < len && (text[i] < 'a' || text[i] > 'z')) {
                i++;
            }
            result.push_back(text.substr(start, i - start));
        } else {
            i++;
        }
    }

    return result;
}","
#include <iostream>
#include <string>
#include <vector>
#include <cassert>
using namespace std;

vector<string> split_lowerstring(const string& text) {
    vector<string> result;
    size_t len = text.length();
    size_t i = 0;
    while (i < len) {
        if (text[i] >= 'a' && text[i] <= 'z') {
            size_t start = i;
            i++;
            while (i < len && (text[i] < 'a' || text[i] > 'z')) {
                result.push_back(text.substr(start, i - start));
                start = i;
            }
        }
    }
    return result;
}

",,,,-2,1,1.2204050342241923,code_expression_exchange:None,0.0,0.0,
5,"#include<iostream>
#include <string>
#include <cassert>
using namespace std;
string text_lowercase_underscore(string text) {
    if (text.empty()) {
        return ""Not matched!"";
    }
    size_t underscore_pos = text.find('_');
    if (underscore_pos == std::string::npos) {
        return ""Not matched!"";
    }
    if (underscore_pos == 0 || underscore_pos == text.length() - 1) {
        return ""Not matched!"";
//begin to write code
",437,"#include<iostream>
    
#include <string>
#include <cassert>
using namespace std;

string text_lowercase_underscore(string text) {
    
    if (text.empty()) {
        return ""Not matched!"";
    }

    size_t underscore_pos = text.find('_');
    if (underscore_pos == std::string::npos) {
        return ""Not matched!"";
    }

    if (underscore_pos == 0 || underscore_pos == text.length() - 1) {
        return ""Not matched!"";
    }

    for (size_t i = 0; i < text.length(); ++i) {
        if (i == underscore_pos) {
            continue;
        }
        if (text[i] < 'a' || text[i] > 'z') {
            return ""Not matched!"";
        }
    }

    return ""Found a match!"";

}","using namespace std;

string text_lowercase_underscore(string text) {
    if (text.empty()) {
        return ""Not matched!"";
    }
    size_t underscore_pos = text.find('_');
    if (underscore_pos == std::string::npos) {
        return ""Not matched!"";
    }
    if (underscore_pos == 0 || underscore_pos == text.length() - 1) {
        return ""Not matched!"";
    }
    return text.substr(0, underscore_pos) + ""_"" + text.substr(underscore_pos + 1);
}
",,,,-2,1,0.19618128935496013,code_expression_exchange:None,0.0,0.0,
6,"#include <iostream>
#include <cassert>
int square_perimeter(int a) {
    int perimeter = 4 * a;
//begin to write code
",118,"
#include <iostream>
#include <cassert>

int square_perimeter(int a) {
    int perimeter = 4 * a;
    return perimeter;
}


","
using namespace std;

#include <iostream>
#include <cassert>

int square_perimeter(int a) {
    int perimeter = 4 * a;
    return perimeter;
}

","#include <iostream>
#include <cassert>
int square_perimeter(long a) {
    int perimeter = 4 * a;
//begin to write code
","
#include <iostream>
#include <cassert>

int square_perimeter(long a) {
    int perimeter = 4 * a;
    return perimeter;
}


","using namespace std;
#include <iostream>

int square_perimeter(long a) {
    return 4 * a;
}
",1,9,1.3429643948872885,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nint square_perimeter(long a) {\n    int perimeter = 4 * a;\n    return perimeter;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint square_perimeter(long a) {\n    int perimeter = 4 * a;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <cassert>\n\nint square_perimeter(long a) {\n    return 4 * a;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nint square_perimeter(long a) {\n    int perimeter = a * 4;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n#include <cmath> // For std::sqrt\n\nint square_perimeter(long a) {\n    int perimeter = a * 4;\n    return perimeter;\n}\n\n// Test function to verify the correctness of the square_perimeter function\nvoid test_square_perimeter() {\n    assert(square_perimeter(0) == 0);\n    assert(square_perimeter(1) == 4);\n    assert(square_perimeter(2) == 8);\n    assert(square_perimeter(3) == 12);\n    assert(square_perimeter(4) == 16);\n    std::cout << ""All test cases passed successfully."" << std::endl;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cassert>\nint square_perimeter(long a) {\n    int perimeter = 4 * a;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint square_perimeter(long a) {\n    return 4 * a;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cassert>\nint square_perimeter(long a) {\n    int perimeter = 4 * a;\n//begin to write code\n', 'using namespace std;\n#include <iostream>\n\nint square_perimeter(long a) {\n    return 4 * a;\n}\n', 'equal_expression_transformation')]}"
7,"#include <iostream>
#include <string>
#include <vector>
#include <cassert>
using namespace std;
const int NO_OF_CHARS = 256;
vector<char> str_to_list(const string& str) {
    vector<char> temp;
    for (char x : str) {
        temp.push_back(x);
    }
    return temp;
}
string lst_to_string(const vector<char>& List) {
    return string(List.begin(), List.end());
}
vector<int> get_char_count_array(const string& str) {
    vector<int> count(NO_OF_CHARS, 0);
    for (char c : str) {
        count[c]++;
    }
//begin to write code
",533,"
#include <iostream>
#include <string>
#include <vector>
#include <cassert>

using namespace std;

const int NO_OF_CHARS = 256;

vector<char> str_to_list(const string& str) {
    vector<char> temp;
    for (char x : str) {
        temp.push_back(x);
    }
    return temp;
}

string lst_to_string(const vector<char>& List) {
    return string(List.begin(), List.end());
}

vector<int> get_char_count_array(const string& str) {
    vector<int> count(NO_OF_CHARS, 0);
    for (char c : str) {
        count[c]++;
    }
    return count;
}

string remove_dirty_chars(const string& str, const string& filter_str) {
    vector<int> count = get_char_count_array(filter_str);
    int ip_ind = 0, res_ind = 0;
    vector<char> str_list = str_to_list(str);
    while (ip_ind != str_list.size()) {
        char temp = str_list[ip_ind];
        if (count[temp] == 0) {
            str_list[res_ind] = str_list[ip_ind];
            res_ind++;
        }
        ip_ind++;
    }
    return lst_to_string(vector<char>(str_list.begin(), str_list.begin() + res_ind));
}


","
#include <iostream>
#include <string>
#include <vector>
#include <cassert>
using namespace std;

const int NO_OF_CHARS = 256;
vector<char> str_to_list(const string& str) {
    vector<char> temp;
    for (char x : str) {
        temp.push_back(x);
    }
    return temp;
}

string lst_to_string(const vector<char>& List) {
    return string(List.begin(), List.end());
}

vector<int> get_char_count_array(const string& str) {
    vector<int> count(NO_OF_CHARS, 0);
    for (char c : str) {
        count[c]++;
    }
    return count;
}

void remove_chars_from_first_string(const string& first_str, const string& second_str, string& result) {
    vector<char> first_list = str_to_list(first_str);
    vector<char> second_list = str_to_list(second_str);
    
    // Find common characters
    vector<char> common_chars;
    for (char c : first_list) {
        if (second_list.find(c)!= second_list.end()) {
            common_chars.push_back(c);
        }
    }
    
    // Remove common characters from first_str
    for (char",,,,-2,1,0.26409672498703,code_expression_exchange:None,0.0,0.0,
8,"#include <iostream>
#include <vector>
#include <set>
#include <cassert>
bool test_duplicate(std::vector<int> arraynums) {
    std::set<int> nums_set(arraynums.begin(), arraynums.end());    
//begin to write code
",212,"
#include <iostream>
#include <vector>
#include <set>
#include <cassert>

bool test_duplicate(std::vector<int> arraynums) {
    std::set<int> nums_set(arraynums.begin(), arraynums.end());    
    return arraynums.size() != nums_set.size();
}


","
#include <iostream>
#include <vector>
#include <set>
#include <cassert>

bool test_duplicate(std::vector<int> arraynums) {
    std::set<int> nums_set(arraynums.begin(), arraynums.end());    
    return nums_set.size()!= arraynums.size();
}

","#include <iostream>
#include <vector>
#include <set>
#include <cassert>
bool test_duplicate(std::vector<int> arraynums) {
    std::set<long> nums_set(arraynums.begin(), arraynums.end());    
//begin to write code
","
#include <iostream>
#include <vector>
#include <set>
#include <cassert>

bool test_duplicate(std::vector<int> arraynums) {
    std::set<long> nums_set(arraynums.begin(), arraynums.end());    
    return nums_set.size() != arraynums.size();
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <set>
#include <cassert>

bool test_duplicate(std::vector<int> arraynums) {
    std::set<long> nums_set(arraynums.begin(), arraynums.end());    
    // Your implementation goes here
    return false; // Replace with your logic
}

",1,7,1.0920150796572368,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool test_duplicate(std::vector<int> arraynums) {\n    std::set<long> nums_set(arraynums.begin(), arraynums.end());    \n    return nums_set.size() != arraynums.size();\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool test_duplicate(std::vector<int> arraynums) {\n    std::set<int> nums_set(arraynums.begin(), arraynums.end());    \n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool test_duplicate(std::vector<int> arraynums) {\n    std::set<int> nums_set(arraynums.begin(), arraynums.end());\n    return nums_set.size()!= arraynums.size();\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool test_duplicate(std::vector<int> arraynums) {\n    std::set<long> nums_set(arraynums.begin(), arraynums.end());    \n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool test_duplicate(std::vector<int> arraynums) {\n    std::set<long> nums_set(arraynums.begin(), arraynums.end());    \n    return nums_set.size()!= arraynums.size();\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool test_duplicate(std::vector<int> arraynums) {\n    std::set<long> nums_set(arraynums.begin(), arraynums.end());    \n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool test_duplicate(std::vector<int> arraynums) {\n    std::set<long> nums_set(arraynums.begin(), arraynums.end());    \n    // Your implementation goes here\n    return false; // Replace with your logic\n}\n\n', 'exchange_operators')]}"
9,"#include <iostream>
#include <cassert>
bool is_woodall(long long x) {
    if (x % 2 == 0) {
        return false;
    }
    if (x == 1) {
        return true;
    }
    x = x + 1;
    long long p = 0;
//begin to write code
",223,"
#include <iostream>
#include <cassert>

bool is_woodall(long long x) {
    if (x % 2 == 0) {
        return false;
    }
    if (x == 1) {
        return true;
    }
    x = x + 1;
    long long p = 0;
    while (x % 2 == 0) {
        x = x / 2;
        p = p + 1;
        if (p == x) {
            return true;
        }
    }
    return false;
}


","
using namespace std;

#include <iostream>
#include <cassert>

bool is_woodball(long long x) {
    if (x % 2 == 0) {
        return false;
    }
    if (x == 1) {
        return true;
    }
    x = x + 1;
    long long p = 0;
    //begin to write code
    return p == 0;
}

","#include <iostream>
#include <cassert>
bool is_woodall(long long x) {
    if (x % 2 == 0) {
        return false;
    }
    if (x == 1) {
        return true;
    }
    x = x + 1;
    long long p = 0;
//begin to write code
","
#include <iostream>
#include <cassert>

bool is_woodall(long long x) {
    if (x % 2 == 0) {
        return false;
    }
    if (x == 1) {
        return true;
    }
    x = x + 1;
    long long p = 0;
    while (x % 2 == 0) {
        x = x / 2;
        p = p + 1;
        if (p == x) {
            return true;
        }
    }
    return false;
}


","using namespace std;
#include <cassert>

bool is_woodall(long long x) {
    if (x % 2 == 0) {
        return false;
    }
    if (x == 1) {
        return true;
    }
    x = x + 1;
    long long p = 0;
    // Your implementation goes here
    return false; // Placeholder return value
}
",1,3,0.5765013813972473,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nbool is_woodall(long long x) {\n    if (x % 2 == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n    x = x + 1;\n    long long p = 0;\n    while (x % 2 == 0) {\n        x = x / 2;\n        p = p + 1;\n        if (p == x) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nbool is_woodall(long long x) {\n    if (x % 2 == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n    x = x + 1;\n    long long p = 0;\n//begin to write code\n', 'using namespace std;\n#include <cassert>\n\nbool is_woodall(long long x) {\n    if (x % 2 == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n    x = x + 1;\n    long long p = 0;\n    // Your implementation goes here\n    return false; // Placeholder return value\n}\n', 'equal_expression_transformation')]}"
10,"#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> multiples_of_num(int m, int n) {
    std::vector<int> multiples;
    for (int i = 1; i <= m; ++i) {
//begin to write code
",196,"
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> multiples_of_num(int m, int n) {
    std::vector<int> multiples;
    for (int i = 1; i <= m; ++i) {
        multiples.push_back(n * i);
    }
    return multiples;
}


","
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> multiples_of_num(int m, int n) {
    std::vector<int> multiples;
    for (int i = 1; i <= m; ++i) {
        multiples.push_back(i * n);
    }
    return multiples;
}

","#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> multiples_of_num(int m, long n) {
    std::vector<int> multiples;
    for (int i = 1; i <= m; ++i) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> multiples_of_num(int m, long n) {
    std::vector<int> multiples;
    for (int i = 1; i <= m; ++i) {
        multiples.push_back(n * i);
    }
    return multiples;
}


","
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> multiples_of_num(int m, long n) {
    std::vector<int> multiples;
    for (int i = 1; i <= m; ++i) {
        if (i % n == 0) {
            multiples.push_back(i);
        }
    }
    return multiples;
}

",1,3,0.5375363667805989,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> multiples_of_num(int m, long n) {\n    std::vector<int> multiples;\n    for (int i = 1; i <= m; ++i) {\n        multiples.push_back(n * i);\n    }\n    return multiples;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> multiples_of_num(int m, long n) {\n    std::vector<int> multiples;\n    for (int i = 1; i <= m; ++i) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> multiples_of_num(int m, long n) {\n    std::vector<int> multiples;\n    for (int i = 1; i <= m; ++i) {\n        if (i % n == 0) {\n            multiples.push_back(i);\n        }\n    }\n    return multiples;\n}\n\n', 'more_universe_var_type')]}"
11,"#include <iostream>
#include <vector>
#include <set>
#include <cassert>
int find_first_duplicate(std::vector<int>& nums) {
    std::set<int> num_set;
    int no_duplicate = -1;
    for (int num : nums) {
        if (num_set.find(num) != num_set.end()) {
            return num;
//begin to write code
",300,"
#include <iostream>
#include <vector>
#include <set>
#include <cassert>

int find_first_duplicate(std::vector<int>& nums) {
    std::set<int> num_set;
    int no_duplicate = -1;

    for (int num : nums) {
        if (num_set.find(num) != num_set.end()) {
            return num;
        } else {
            num_set.insert(num);
        }
    }
    return no_duplicate;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <set>
#include <cassert>

int find_first_duplicate(std::vector<int>& nums) {
    std::set<int> num_set;
    int no_duplicate = -1;
    for (int num : nums) {
        if (num_set.find(num)!= num_set.end()) {
            return num;
        }
        num_set.insert(num);
    }
    return no_duplicate;
}

","#include <iostream>
#include <vector>
#include <set>
#include <cassert>
long find_first_duplicate(std::vector<long>& nums) {
    std::set<long> num_set;
    long no_duplicate = -1;
    for (long num : nums) {
        if (num_set.find(num) != num_set.end()) {
            return num;
//begin to write code
","
#include <iostream>
#include <vector>
#include <set>
#include <cassert>

long find_first_duplicate(std::vector<long>& nums) {
    std::set<long> num_set;
    long no_duplicate = -1;

    for (long num : nums) {
        if (num_set.find(num) != num_set.end()) {
            return num;
        } else {
            num_set.insert(num);
        }
    }
    return no_duplicate;
}


","
#include <iostream>
#include <vector>
#include <set>
#include <cassert>

long find_first_duplicate(std::vector<long>& nums) {
    std::set<long> num_set;
    long no_duplicate = -1;
    for (long num : nums) {
        if (num_set.find(num)!= num_set.end()) {
            return num;
        }
        num_set.insert(num);
    }
    return no_duplicate;
}

",1,21,3.1170682549476623,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nlong find_first_duplicate(std::vector<long>& nums) {\n    std::set<long> num_set;\n    long no_duplicate = -1;\n\n    for (long num : nums) {\n        if (num_set.find(num) != num_set.end()) {\n            return num;\n        } else {\n            num_set.insert(num);\n        }\n    }\n    return no_duplicate;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nint find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    long no_duplicate = -1;\n    for (int num : nums) {\n        if (num_set.find(num) != num_set.end()) {\n            return num;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nint find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    long no_duplicate = -1;\n    for (int num : nums) {\n        if (num_set.find(num)!= num_set.end()) {\n            return num;\n        }\n        num_set.insert(num);\n    }\n    return no_duplicate;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nint find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    long no_duplicate = -1;\n    for (long num : nums) {\n        if (num_set.find(num) != num_set.end()) {\n            return num;\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nint find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    long no_duplicate = -1;\n    for (long num : nums) {\n        if (num_set.find(num)!= num_set.end()) {\n            return num;\n        }\n        num_set.insert(num);\n    }\n    return no_duplicate;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nlong find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    long no_duplicate = -1;\n    for (long num : nums) {\n        if (num_set.find(num) != num_set.end()) {\n            return num;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nlong find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    long no_duplicate = -1;\n    for (long num : nums) {\n        if (num_set.find(num)!= num_set.end()) {\n            return num;\n        }\n        num_set.insert(num);\n    }\n    return no_duplicate;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nlong find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    long no_duplicate = -1;\n    for (long num : nums) {\n        if (num_set.find(num) != num_set.end()) {\n            return num;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nlong find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    long no_duplicate = -1;\n    for (long num : nums) {\n        if (num_set.find(num)!= num_set.end()) {\n            return num;\n        }\n        num_set.insert(num);\n    }\n    return no_duplicate;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nlong find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    long no_duplicate = -1;\n    for (long num : nums) {\n        if (num_set.end() != num_set.find(num)) {\n            return num;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nlong find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    long no_duplicate = -1;\n    for (long num : nums) {\n        if (num_set.end()!= num_set.find(num)) {\n            return num;\n        }\n        num_set.insert(num);\n    }\n    return no_duplicate;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nlong find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    long no_duplicate = -1;\n    for (long num : nums) {\n        if (num_set.find(num) != num_set.end()) {\n            return num;\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nlong find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    long no_duplicate = -1;\n    for (long num : nums) {\n        if (num_set.find(num)!= num_set.end()) {\n            return num;\n        }\n        num_set.insert(num);\n    }\n    return no_duplicate;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nlong find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    long no_duplicate = -1;\n    for (long num : nums) {\n        if (num_set.find(num) != num_set.end()) {\n            return num;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nlong find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    long no_duplicate = -1;\n    for (long num : nums) {\n        if (num_set.find(num)!= num_set.end()) {\n            return num;\n        }\n        num_set.insert(num);\n    }\n    return no_duplicate;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nlong find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    long no_duplicate = -1;\n    for (long num : nums) {\n        if (num_set.find(num) != num_set.end()) {\n            return num;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nlong find_first_duplicate(std::vector<int>& nums) {\n    std::set<int> num_set;\n    long no_duplicate = -1;\n    for (long num : nums) {\n        if (num_set.find(num)!= num_set.end()) {\n            return num;\n        }\n        num_set.insert(num);\n    }\n    return no_duplicate;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nlong find_first_duplicate(std::vector<int>& nums) {\n    std::set<long> num_set;\n    long no_duplicate = -1;\n    for (long num : nums) {\n        if (num_set.find(num) != num_set.end()) {\n            return num;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nlong find_first_duplicate(std::vector<int>& nums) {\n    std::set<long> num_set;\n    long no_duplicate = -1;\n    for (long num : nums) {\n        if (num_set.find(num)!= num_set.end()) {\n            return num;\n        }\n        num_set.insert(num);\n    }\n    return no_duplicate;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nlong find_first_duplicate(std::vector<long>& nums) {\n    std::set<long> num_set;\n    long no_duplicate = -1;\n    for (long num : nums) {\n        if (num_set.find(num) != num_set.end()) {\n            return num;\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nlong find_first_duplicate(std::vector<long>& nums) {\n    std::set<long> num_set;\n    long no_duplicate = -1;\n    for (long num : nums) {\n        if (num_set.find(num)!= num_set.end()) {\n            return num;\n        }\n        num_set.insert(num);\n    }\n    return no_duplicate;\n}\n\n', 'more_universe_var_type')]}"
12,"#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
int maximum_Sum(const vector<vector<int>>& list1) {
    int maxi = -100000;
    for (const auto& x : list1) {
        int sum = 0;
        for (auto y : x) {
//begin to write code
",258,"
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

int maximum_Sum(const vector<vector<int>>& list1) {
    int maxi = -100000;
    for (const auto& x : list1) {
        int sum = 0;
        for (auto y : x) {
            sum += y;
        }
        maxi = max(sum, maxi);
    }
    return maxi;
}


","
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

int maximum_Sum(const vector<vector<int>>& list1) {
    int maxi = -100000;
    for (const auto& x : list1) {
        int sum = 0;
        for (auto y : x) {
            sum += y;
            if (sum > maxi) {
                maxi = sum;
            }
        }
    }
    return maxi;
}

",,,,-2,1,0.1973154385884603,code_expression_exchange:None,0.0,0.0,
13,"#include <iostream>
#include <cmath>
#include <cassert>
int binary_to_decimal(int binary) {
    int decimal = 0, i = 0;
    while (binary != 0) {
        int dec = binary % 10;
        decimal += dec * std::pow(2, i);
//begin to write code
",240,"
#include <iostream>
#include <cmath>
#include <cassert>

int binary_to_decimal(int binary) {
    int decimal = 0, i = 0;
    while (binary != 0) {
        int dec = binary % 10;
        decimal += dec * std::pow(2, i);
        binary /= 10;
        i++;
    }
    return decimal;
}


","
#include <iostream>
#include <cmath>
#include <cassert>

int binary_to_decimal(int binary) {
    int decimal = 0, i = 0;
    while (binary!= 0) {
        int dec = binary % 10;
        decimal += dec * std::pow(2, i);
        binary /= 10;
        ++i;
    }
    return decimal;
}

","#include <iostream>
#include <cmath>
#include <cassert>
int binary_to_decimal(int binary) {
    int decimal = 0, i = 0;
    while (binary != 0) {
        long dec = binary % 10;
        decimal += dec * std::pow(2, i);
//begin to write code
","
#include <iostream>
#include <cmath>
#include <cassert>

int binary_to_decimal(int binary) {
    int decimal = 0, i = 0;
    while (binary != 0) {
        long dec = binary % 10;
        decimal += dec * std::pow(2, i);
        binary /= 10;
        i++;
    }
    return decimal;
}


","
using namespace std;
#include <iostream>
#include <cmath>
#include <cassert>

int binary_to_decimal(int binary) {
    int decimal = 0, i = 0;
    while (binary!= 0) {
        long dec = binary % 10;
        decimal += dec * std::pow(2, i);
        i++;
    }
    return decimal;
}

",1,3,1.4885535955429077,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint binary_to_decimal(int binary) {\n    int decimal = 0, i = 0;\n    while (binary != 0) {\n        long dec = binary % 10;\n        decimal += dec * std::pow(2, i);\n        binary /= 10;\n        i++;\n    }\n    return decimal;\n}\n\n\n': [('#include <iostream>\n#include <cmath>\n#include <cassert>\nint binary_to_decimal(int binary) {\n    int decimal = 0, i = 0;\n    while (binary != 0) {\n        long dec = binary % 10;\n        decimal += dec * std::pow(2, i);\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint binary_to_decimal(int binary) {\n    int decimal = 0, i = 0;\n    while (binary!= 0) {\n        long dec = binary % 10;\n        decimal += dec * std::pow(2, i);\n        i++;\n    }\n    return decimal;\n}\n\n', 'more_universe_var_type')]}"
14,"#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
int find_Product(std::vector<int> arr, int n) {
    std::sort(arr.begin(), arr.end());
    int prod = 1;
    for (int i = 0; i < n; i++) {
        if (i == 0 || arr[i - 1] != arr[i]) {
//begin to write code
",285,"
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

int find_Product(std::vector<int> arr, int n) {
    std::sort(arr.begin(), arr.end());
    int prod = 1;
    for (int i = 0; i < n; i++) {
        if (i == 0 || arr[i - 1] != arr[i]) {
            prod *= arr[i];
        }
    }
    return prod;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

int find_Product(std::vector<int> arr, int n) {
    std::sort(arr.begin(), arr.end());
    int prod = 1;
    for (int i = 0; i < n; i++) {
        if (i == 0 || arr[i - 1]!= arr[i]) {
            prod *= arr[i];
        }
    }
    return prod;
}

void test_find_Product() {
    assert(find_Product({1, 2, 3, 4, 5}, 5) == 120);
    assert(find_Product({10, 20, 30, 40, 50}, 5) == 15000);
    assert(find_Product({-1, -2, -3, -4, -5}, 5) == -120);
    cout << ""All tests passed successfully."" << endl;
}

","#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
int find_Product(std::vector<int> arr, long n) {
    std::sort(arr.begin(), arr.end());
    int prod = 1;
    for (int i = 0; i < n; i++) {
        if (i == 0 || arr[i - 1] != arr[i]) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

int find_Product(std::vector<int> arr, long n) {
    std::sort(arr.begin(), arr.end());
    int prod = 1;
    for (int i = 0; i < n; i++) {
        if (i == 0 || arr[i - 1] != arr[i]) {
            prod *= arr[i];
        }
    }
    return prod;
}


","I'm sorry, but I can't assist with that request.",1,3,0.48812641302744547,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint find_Product(std::vector<int> arr, long n) {\n    std::sort(arr.begin(), arr.end());\n    int prod = 1;\n    for (int i = 0; i < n; i++) {\n        if (i == 0 || arr[i - 1] != arr[i]) {\n            prod *= arr[i];\n        }\n    }\n    return prod;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nint find_Product(std::vector<int> arr, long n) {\n    std::sort(arr.begin(), arr.end());\n    int prod = 1;\n    for (int i = 0; i < n; i++) {\n        if (i == 0 || arr[i - 1] != arr[i]) {\n//begin to write code\n', ""I'm sorry, but I can't assist with that request."", 'more_universe_var_type')]}"
15,"#include <iostream>
#include <vector>
#include <cassert>
bool check_k_elements(const std::vector<std::vector<int>>& test_list, int K) {
    bool res = true;
    for (const auto& tup : test_list) {
        for (int ele : tup) {
            if (ele != K) {
                res = false;
//begin to write code
",306,"
#include <iostream>
#include <vector>
#include <cassert>

bool check_k_elements(const std::vector<std::vector<int>>& test_list, int K) {
    bool res = true;
    for (const auto& tup : test_list) {
        for (int ele : tup) {
            if (ele != K) {
                res = false;
                break;
            }
        }
        if (!res) break;
    }
    return res;
}


","
#include <iostream>
#include <vector>
#include <cassert>

bool check_k_elements(const std::vector<std::vector<int>>& test_list, int K) {
    bool res = true;
    for (const auto& tup : test_list) {
        for (int ele : tup) {
            if (ele!= K) {
                res = false;
            }
        }
    }
    return res;
}

","#include <iostream>
#include <vector>
#include <cassert>
bool check_k_elements(const std::vector<std::vector<long>>& test_list, long K) {
    bool res = 1;
    for (const auto& tup : test_list) {
        for (long ele : tup) {
            if (K != ele) {
                res = 0;
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

bool check_k_elements(const std::vector<std::vector<long>>& test_list, long K) {
    bool res = 1;
    for (const auto& tup : test_list) {
        for (long ele : tup) {
            if (K != ele) {
                res = 0;
                break;
            }
        }
        if (!res) break;
    }
    return res;
}


","#include <iostream>
#include <vector>
#include <cassert>

bool check_k_elements(const std::vector<std::vector<long>>& test_list, long K) {
    // Check if the length of the test list matches the number of elements to check
    if (test_list.size()!= K) {
        return false;
    }

    // Iterate over each tuple in the test list
    for (const auto& tup : test_list) {
        // Check if all elements in the tuple match the specified K value
        for (long ele : tup) {
            if (ele!= K) {
                return false;
            }
        }
    }

    // If all elements in all tuples match the K value, return true
    return true;
}
",1,21,2.688645891348521,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, long K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (long ele : tup) {\n            if (K != ele) {\n                res = 0;\n                break;\n            }\n        }\n        if (!res) break;\n    }\n    return res;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nbool check_k_elements(const std::vector<std::vector<int>>& test_list, int K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (int ele : tup) {\n            if (ele != K) {\n                res = 0;\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool check_k_elements(const std::vector<std::vector<int>>& test_list, int K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (int ele : tup) {\n            if (ele!= K) {\n                res = 0;\n            }\n        }\n    }\n    return res;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, int K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (int ele : tup) {\n            if (ele != K) {\n                res = 0;\n//begin to write code\n', 'using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, int K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (int ele : tup) {\n            if (ele!= K) {\n                res = 0;\n                break; // Exit the loop once a mismatch is found\n            }\n        }\n    }\n    return res;\n}\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, int K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (int ele : tup) {\n            if (K != ele) {\n                res = 0;\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, int K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (int ele : tup) {\n            if (K!= ele) {\n                res = 0;\n                break; // Stop checking further elements if a mismatch is found\n            }\n        }\n    }\n    return res;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, int K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (long ele : tup) {\n            if (K != ele) {\n                res = 0;\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, int K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (long ele : tup) {\n            if (K!= ele) {\n                res = 0;\n                break; // Stop checking further if we find a mismatch\n            }\n        }\n    }\n    return res;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, long K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (long ele : tup) {\n            if (K != ele) {\n                res = 0;\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, long K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (long ele : tup) {\n            if (K!= ele) {\n                res = 0;\n                break; // Stop checking if we find a mismatch\n            }\n        }\n        if (!res) {\n            break; // Stop checking if we found at least one mismatch\n        }\n    }\n    return res;\n}\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, long K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (long ele : tup) {\n            if (K != ele) {\n                res = 0;\n//begin to write code\n', 'using namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, long K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (long ele : tup) {\n            if (K!= ele) {\n                res = 0;\n            }\n        }\n    }\n    return res;\n}\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, long K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (long ele : tup) {\n            if (K != ele) {\n                res = 0;\n//begin to write code\n', ""#include <iostream>\n#include <vector>\n#include <cassert>\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, long K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (long ele : tup) {\n            if (K!= ele) {\n                res = 0;\n                break; // Exit early if we find an element that doesn't match K\n            }\n        }\n        if (!res) {\n            break; // Exit early if we found an element that doesn't match K\n        }\n    }\n    return res;\n}\n"", 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, long K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (long ele : tup) {\n            if (K != ele) {\n                res = 0;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, long K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (long ele : tup) {\n            if (K!= ele) {\n                res = 0;\n            }\n        }\n    }\n    return res;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, long K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (long ele : tup) {\n            if (K != ele) {\n                res = 0;\n//begin to write code\n', ""\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, long K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (long ele : tup) {\n            if (K!= ele) {\n                res = 0;\n                break; // Exit early if we find an element that doesn't match K\n            }\n        }\n    }\n    return res;\n}\n\n"", 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, long K) {\n    bool res = 1;\n    for (const auto& tup : test_list) {\n        for (long ele : tup) {\n            if (K != ele) {\n                res = 0;\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool check_k_elements(const std::vector<std::vector<long>>& test_list, long K) {\n    // Check if the length of the test list matches the number of elements to check\n    if (test_list.size()!= K) {\n        return false;\n    }\n\n    // Iterate over each tuple in the test list\n    for (const auto& tup : test_list) {\n        // Check if all elements in the tuple match the specified K value\n        for (long ele : tup) {\n            if (ele!= K) {\n                return false;\n            }\n        }\n    }\n\n    // If all elements in all tuples match the K value, return true\n    return true;\n}\n', 'bool2int')]}"
16,"#include <iostream>
#include <string>
#include <vector>
#include <cassert>
using namespace std;
vector<string> remove(const vector<string>& list) {
    vector<string> result;
    for (const auto& item : list) {
        string res;
        for(char onechar:item)
        {
            if(!(onechar<='9' && onechar >='0'))
//begin to write code
",343,"#include <iostream>
#include <string>
#include <vector>
#include <cassert>

using namespace std;

vector<string> remove(const vector<string>& list) {
    vector<string> result;
    for (const auto& item : list) {
        string res;
        for(char onechar:item)
        {
            if(!(onechar<='9' && onechar >='0'))
            {
                res.push_back(onechar);
            }
        }
        result.push_back(res);
        
    }
    return result;
}","
#include <iostream>
#include <string>
#include <vector>
#include <cassert>
using namespace std;

vector<string> remove(const vector<string>& list) {
    vector<string> result;
    for (const auto& item : list) {
        string res;
        for(char onechar:item)
        {
            if(!(onechar<='9' && onechar >='0'))
                res += onechar;
        }
        result.push_back(res);
    }
    return result;
}

","#include <iostream>
#include <string>
#include <vector>
#include <cassert>
using namespace std;
vector<string> remove(const vector<string>& list) {
    vector<string> result;
    for (const auto& item : list) {
        string res;
        for(char onechar:item)
        {
            if(!(onechar<='9' && onechar >='0'))
//begin to write code
","#include <iostream>
#include <string>
#include <vector>
#include <cassert>

using namespace std;

vector<string> remove(const vector<string>& list) {
    vector<string> result;
    for (const auto& item : list) {
        string res;
        for(char onechar:item)
        {
            if(!(onechar<='9' && onechar >='0'))
            {
                res.push_back(onechar);
            }
        }
        result.push_back(res);
        
    }
    return result;
}","
#include <iostream>
#include <string>
#include <vector>
#include <cassert>
using namespace std;

vector<string> remove(const vector<string>& list) {
    vector<string> result;
    for (const auto& item : list) {
        string res;
        for(char onechar:item)
        {
            if(!isdigit(onechar)) // Only keep alphanumeric characters
                res += onechar;
        }
        result.push_back(res);
    }
    return result;
}

",-1,21,2.6513259331385295,code_expression_exchange:bool2int,1.0,0.8486521670600433,"{""#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for(char onechar:item)\n        {\n            if(!(onechar<='9' && onechar >='0'))\n            {\n                res.push_back(onechar);\n            }\n        }\n        result.push_back(res);\n        \n    }\n    return result;\n}"": [(""#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for(char onechar:item)\n        {\n            if(!(onechar<='9' && onechar >='0'))\n//begin to write code\n"", ""#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for (char onechar : item) {\n            if (!(onechar<='9' && onechar >='0')) {\n                res += onechar;\n            }\n        }\n        result.push_back(res);\n    }\n    return result;\n}\n"", 'equal_expression_transformation'), (""#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for(char onechar:item)\n        {\n            if(!(onechar<='9' && onechar >='0'))\n//begin to write code\n"", '\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for (char onechar : item) {\n            if (!isdigit(onechar)) {\n                res += onechar;\n            }\n        }\n        result.push_back(res);\n    }\n    return result;\n}\n\n', 'equal_expression_transformation'), (""#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for(char onechar:item)\n        {\n            if(!(onechar<='9' && onechar >='0'))\n//begin to write code\n"", ""\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for (char onechar : item) {\n            if (!(onechar<='9' && onechar >='0')) {\n                res += onechar;\n            }\n        }\n        result.push_back(res);\n    }\n    return result;\n}\n\n"", 'equal_expression_transformation'), (""#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for(char onechar:item)\n        {\n            if(!(onechar<='9' && onechar >='0'))\n//begin to write code\n"", ""\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for (char onechar : item) {\n            if (!(onechar<='9' && onechar >='0')) {\n                res += onechar;\n            }\n        }\n        result.push_back(res);\n    }\n    return result;\n}\n\n"", 'bool2int'), (""#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for(char onechar:item)\n        {\n            if(!(onechar<='9' && onechar >='0'))\n//begin to write code\n"", ""\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for (char onechar : item) {\n            if (!(onechar <='9' && onechar >='0')) {\n                res += onechar;\n            }\n        }\n        result.push_back(res);\n    }\n    return result;\n}\n\n"", 'more_universe_var_type'), (""#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for(char onechar:item)\n        {\n            if(!(onechar<='9' && onechar >='0'))\n//begin to write code\n"", ""#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for (char onechar : item) {\n            if (!(onechar >= '0' && onechar <= '9')) {\n                res += onechar;\n            }\n        }\n        result.push_back(res);\n    }\n    return result;\n}\n"", 'bool2int'), (""#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for(char onechar:item)\n        {\n            if(!(onechar<='9' && onechar >='0'))\n//begin to write code\n"", ""\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for(char onechar:item)\n        {\n            if (!(onechar<='9' && onechar >='0'))\n                res += onechar;\n        }\n        result.push_back(res);\n    }\n    return result;\n}\n\n"", 'more_universe_var_type'), (""#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for(char onechar:item)\n        {\n            if(!(onechar<='9' && onechar >='0'))\n//begin to write code\n"", '\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for (char onechar : item) {\n            if (!isdigit(onechar)) {\n                res += onechar;\n            }\n        }\n        result.push_back(res);\n    }\n    return result;\n}\n\n', 'exchange_operators'), (""#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for(char onechar:item)\n        {\n            if(!(onechar<='9' && onechar >='0'))\n//begin to write code\n"", ""\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for(char onechar:item)\n        {\n            if(!(onechar<='9' && onechar >='0'))\n                res += onechar;\n        }\n        result.push_back(res);\n    }\n    return result;\n}\n\n"", 'equal_expression_transformation'), (""#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for(char onechar:item)\n        {\n            if(!(onechar<='9' && onechar >='0'))\n//begin to write code\n"", '\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<string> remove(const vector<string>& list) {\n    vector<string> result;\n    for (const auto& item : list) {\n        string res;\n        for(char onechar:item)\n        {\n            if(!isdigit(onechar)) // Only keep alphanumeric characters\n                res += onechar;\n        }\n        result.push_back(res);\n    }\n    return result;\n}\n\n', 'bool2int')]}"
17,"#include<iostream>
#include <cassert>
//
int binomial_Coeff(int n, int k) {
    if (k > n) {
        return 0;
    }
//begin to write code
",143,"#include<iostream>
    

#include <cassert>

//
int binomial_Coeff(int n, int k) {
    if (k > n) {
        return 0;
    }
    if (k == 0 || k == n) {
        return 1;
    }
    return binomial_Coeff(n - 1, k - 1) + binomial_Coeff(n - 1, k);
}


","
#include<iostream>
#include <cassert>
using namespace std;

int binomial_Coeff(int n, int k) {
    if (k > n) {
        return 0;
    }
    // Calculate binomial coefficient using the formula C(n, k) = n! / (k!(n-k)!)
    return factorial(n) / (factorial(k) * factorial(n - k));
}

int factorial(int num) {
    if (num == 0 || num == 1) {
        return 1;
    }
    return num * factorial(num - 1);
}

",,,,-2,1,0.22656912008921307,code_expression_exchange:None,0.0,0.0,
18,"#include <iostream>
#include <vector>
#include <cassert>
int get_Odd_Occurrence(std::vector<int> arr, int arr_size) {
    for (int i = 0; i < arr_size; i++) {
        int count = 0;
        for (int j = 0; j < arr_size; j++) {
            if (arr[i] == arr[j]) {
                count++;
            }
//begin to write code
",324,"
#include <iostream>
#include <vector>
#include <cassert>

int get_Odd_Occurrence(std::vector<int> arr, int arr_size) {
    for (int i = 0; i < arr_size; i++) {
        int count = 0;
        for (int j = 0; j < arr_size; j++) {
            if (arr[i] == arr[j]) {
                count++;
            }
        }
        if (count % 2 != 0) {
            return arr[i];
        }
    }
    return -1;
}


","
#include <iostream>
#include <vector>
#include <cassert>

int get_Odd_Occurrence(std::vector<int> arr, int arr_size) {
    std::unordered_map<int, int> frequencyMap;
    for (int num : arr) {
        frequencyMap[num]++;
    }

    int oddCount = 0;
    for (const auto& pair : frequencyMap) {
        if (pair.second % 2!= 0) {
            oddCount++;
        }
    }

    return oddCount;
}

",,,,-2,1,0.236969518661499,code_expression_exchange:None,0.0,0.0,
19,"#include <iostream>
#include <string>
#include <cassert>
bool check_Equality(const std::string &s) {
    return (s.front() == s.back());
}
int count_Substring_With_Equal_Ends(const std::string &s) {
    int result = 0;
    int n = s.length();
    for (int i = 0; i < n; ++i) {
//begin to write code
",299,"
#include <iostream>
#include <string>
#include <cassert>

bool check_Equality(const std::string &s) {
    return (s.front() == s.back());
}

int count_Substring_With_Equal_Ends(const std::string &s) {
    int result = 0;
    int n = s.length();
    for (int i = 0; i < n; ++i) {
        for (int j = 1; j <= n - i; ++j) {
            if (check_Equality(s.substr(i, j))) {
                result++;
            }
        }
    }
    return result;
}


","
#include <iostream>
#include <string>
#include <cassert>

bool check_Equality(const std::string &s) {
    return (s.front() == s.back());
}

int count_Substring_With_Equal_Ends(const std::string &s) {
    int result = 0;
    int n = s.length();
    for (int i = 0; i < n; ++i) {
        if (check_Equality(s.substr(i, 2))) {
            ++result;
        }
    }
    return result;
}

",,,,-2,1,0.23629433314005535,code_expression_exchange:None,0.0,0.0,
20,"#include<iostream>
#include <vector>
#include <unordered_map>
#include <queue>
#include <cassert>
#include <algorithm>
using namespace std;
vector<int> func(vector<vector<int>>& nums, int k) {
    unordered_map<int, int> d;
    for (auto& row : nums) {
        for (int i : row) {
            d[i]++;
        }
    }
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    for (auto& item : d) {
        int key = item.first;
        int v = item.second;
        if (pq.size() < k) {
            pq.emplace(v, key);
//begin to write code
",574,"#include<iostream>
    
#include <vector>
#include <unordered_map>
#include <queue>
#include <cassert>
#include <algorithm>

using namespace std;

vector<int> func(vector<vector<int>>& nums, int k) {
    unordered_map<int, int> d;
    for (auto& row : nums) {
        for (int i : row) {
            d[i]++;
        }
    }
    
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    for (auto& item : d) {
        int key = item.first;
        int v = item.second;
        if (pq.size() < k) {
            pq.emplace(v, key);
        } else {
            if (v > pq.top().first) {
                pq.pop();
                pq.emplace(v, key);
            }
        }
    }
    
    vector<int> result;
    while (!pq.empty()) {
        result.push_back(pq.top().second);
        pq.pop();
    }
    
    return result;
}","#include<iostream>
#include <vector>
#include <unordered_map>
#include <queue>
#include <cassert>
#include <algorithm>
using namespace std;

vector<int> func(vector<vector<int>>& nums, int k) {
    unordered_map<int, int> d;
    for (auto& row : nums) {
        for (int i : row) {
            d[i]++;
        }
    }
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    for (auto& item : d) {
        int key = item.first;
        int v = item.second;
        if (pq.size() < k) {
            pq.emplace(v, key);
        } else if (pq.top().second == v) {
            pq.pop();
            pq.emplace(v, key);
        }
    }
    vector<int> res;
    while (!pq.empty()) {
        res.push_back(pq.top().first);
        pq.pop();
    }
    reverse(res.begin(), res.end());
    return res;
}
",,,,-2,1,0.2263607104619344,code_expression_exchange:None,0.0,0.0,
21,"#include <iostream>
#include <cmath>
#include <cassert>
int max_Prime_Factors(int n) {
    int maxPrime = -1;
    while (n % 2 == 0) {
        maxPrime = 2;
        n >>= 1;
    }
    for (int i = 3; i <= sqrt(n); i += 2) {
        while (n % i == 0) {
//begin to write code
",275,"
#include <iostream>
#include <cmath>
#include <cassert>

int max_Prime_Factors(int n) {
    int maxPrime = -1;
    while (n % 2 == 0) {
        maxPrime = 2;
        n >>= 1;
    }
    for (int i = 3; i <= sqrt(n); i += 2) {
        while (n % i == 0) {
            maxPrime = i;
            n /= i;
        }
    }
    if (n > 2) {
        maxPrime = n;
    }
    return maxPrime;
}


","
using namespace std;

#include <iostream>
#include <cmath>
#include <cassert>

int max_Prime_Factors(int n) {
    if (n <= 1) return -1;
    
    int maxPrime = -1;
    // Divide n by 2 until it's odd
    while (n % 2 == 0) {
        maxPrime = 2;
        n /= 2;
    }
    
    // Check for odd factors from 3 onwards
    for (int i = 3; i <= sqrt(n); i += 2) {
        while (n % i == 0) {
            maxPrime = i;
            n /= i;
        }
    }
    
    // If n is still greater than 2, then n itself is a prime number
    if (n > 2) {
        maxPrime = n;
    }
    
    return maxPrime;
}

","#include <iostream>
#include <cmath>
#include <cassert>
int max_Prime_Factors(long n) {
    int maxPrime = -1;
    while (n % 2 == 0) {
        maxPrime = 2;
        n >>= 1;
    }
    for (int i = 3; i <= sqrt(n); i += 2) {
        while (n % i == 0) {
//begin to write code
","
#include <iostream>
#include <cmath>
#include <cassert>

int max_Prime_Factors(long n) {
    int maxPrime = -1;
    while (n % 2 == 0) {
        maxPrime = 2;
        n >>= 1;
    }
    for (int i = 3; i <= sqrt(n); i += 2) {
        while (n % i == 0) {
            maxPrime = i;
            n /= i;
        }
    }
    if (n > 2) {
        maxPrime = n;
    }
    return maxPrime;
}


","
using namespace std;
#include <iostream>
#include <cmath>
#include <cassert>

int max_Prime_Factors(long n) {
    if (n <= 1) {
        return -1; // No prime factors for numbers <= 1
    }
    
    // Find the largest prime factor
    for (long factor = 2; factor * factor <= n; factor++) {
        while (n % factor == 0) {
            maxPrime = factor;
            n /= factor;
        }
    }
    
    // If n is still greater than 2, then n itself is a prime number
    if (n > 2) {
        maxPrime = n;
    }
    
    return maxPrime;
}

// Test cases to verify the correctness of the function
void test_max_Prime_Factors() {
    assert(max_Prime_Factors(13195) == 29);
    assert(max_Prime_Factors(600851475143) == 6857);
    assert(max_Prime_Factors(2) == -1);
    assert(max_Prime_Factors(29979247401",1,3,0.48812503814697267,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint max_Prime_Factors(long n) {\n    int maxPrime = -1;\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n >>= 1;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n /= i;\n        }\n    }\n    if (n > 2) {\n        maxPrime = n;\n    }\n    return maxPrime;\n}\n\n\n': [('#include <iostream>\n#include <cmath>\n#include <cassert>\nint max_Prime_Factors(long n) {\n    int maxPrime = -1;\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n >>= 1;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint max_Prime_Factors(long n) {\n    if (n <= 1) {\n        return -1; // No prime factors for numbers <= 1\n    }\n    \n    // Find the largest prime factor\n    for (long factor = 2; factor * factor <= n; factor++) {\n        while (n % factor == 0) {\n            maxPrime = factor;\n            n /= factor;\n        }\n    }\n    \n    // If n is still greater than 2, then n itself is a prime number\n    if (n > 2) {\n        maxPrime = n;\n    }\n    \n    return maxPrime;\n}\n\n// Test cases to verify the correctness of the function\nvoid test_max_Prime_Factors() {\n    assert(max_Prime_Factors(13195) == 29);\n    assert(max_Prime_Factors(600851475143) == 6857);\n    assert(max_Prime_Factors(2) == -1);\n    assert(max_Prime_Factors(29979247401', 'more_universe_var_type')]}"
22,"#include <iostream>
#include <cmath>
#include <cassert>
int decimal_To_Binary(int N) {
    int B_Number = 0;
    int cnt = 0;
    while (N != 0) {
        int rem = N % 2;
        int c = pow(10, cnt);
//begin to write code
",224,"
#include <iostream>
#include <cmath>
#include <cassert>

int decimal_To_Binary(int N) {
    int B_Number = 0;
    int cnt = 0;
    while (N != 0) {
        int rem = N % 2;
        int c = pow(10, cnt);
        B_Number += rem * c;
        N /= 2;
        cnt += 1;
    }
    return B_Number;
}


","
using namespace std;
#include <iostream>
#include <cmath>
#include <cassert>

int decimal_To_Binary(int N) {
    int B_Number = 0;
    int cnt = 0;
    while (N!= 0) {
        int rem = N % 2;
        int c = pow(10, cnt);
        B_Number += rem * c;
        N /= 2;
        cnt++;
    }
    return B_Number;
}

","#include <iostream>
#include <cmath>
#include <cassert>
int decimal_To_Binary(int N) {
    int B_Number = 0;
    int cnt = 0;
    while (0 != N) {
        int rem = N % 2;
        int c = pow(10, cnt);
//begin to write code
","
#include <iostream>
#include <cmath>
#include <cassert>

int decimal_To_Binary(int N) {
    int B_Number = 0;
    int cnt = 0;
    while (0 != N) {
        int rem = N % 2;
        int c = pow(10, cnt);
        B_Number += c * rem;
        N /= 2;
        cnt += 1;
    }
    return B_Number;
}


","
#include <iostream>
#include <cmath>
#include <cassert>

std::string decimalToBinary(int N) {
    if (N == 0) {
        return ""0"";
    }

    // Convert the decimal number to a positive integer
    int absN = std::abs(N);

    // Initialize an empty string to store the binary representation
    std::string binaryRepresentation = """";

    // Loop until the number becomes zero
    while (absN > 0) {
        // Get the remainder when the number is divided by 2
        int remainder = absN % 2;

        // Append the remainder to the binary string
        binaryRepresentation",1,3,0.4806066791216532,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint decimal_To_Binary(int N) {\n    int B_Number = 0;\n    int cnt = 0;\n    while (0 != N) {\n        int rem = N % 2;\n        int c = pow(10, cnt);\n        B_Number += c * rem;\n        N /= 2;\n        cnt += 1;\n    }\n    return B_Number;\n}\n\n\n': [('#include <iostream>\n#include <cmath>\n#include <cassert>\nint decimal_To_Binary(int N) {\n    int B_Number = 0;\n    int cnt = 0;\n    while (0 != N) {\n        int rem = N % 2;\n        int c = pow(10, cnt);\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nstd::string decimalToBinary(int N) {\n    if (N == 0) {\n        return ""0"";\n    }\n\n    // Convert the decimal number to a positive integer\n    int absN = std::abs(N);\n\n    // Initialize an empty string to store the binary representation\n    std::string binaryRepresentation = """";\n\n    // Loop until the number becomes zero\n    while (absN > 0) {\n        // Get the remainder when the number is divided by 2\n        int remainder = absN % 2;\n\n        // Append the remainder to the binary string\n        binaryRepresentation', 'exchange_operators')]}"
23,"#include <iostream>
#include <vector>
#include <cassert>
int find_missing(std::vector<int>& ar, int N) {
    int l = 0;
    int r = N - 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (ar[mid] != mid + 1 && ar[mid - 1] == mid) {
            return mid + 1;
//begin to write code
",297,"
#include <iostream>
#include <vector>
#include <cassert>

int find_missing(std::vector<int>& ar, int N) {
    int l = 0;
    int r = N - 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (ar[mid] != mid + 1 && ar[mid - 1] == mid) {
            return mid + 1;
        } else if (ar[mid] != mid + 1) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return -1;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <cassert>

int find_missing(std::vector<int>& ar, int N) {
    int l = 0;
    int r = N - 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (ar[mid]!= mid + 1 && ar[mid - 1] == mid) {
            return mid + 1;
        }
        if (ar[mid] > mid + 1) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return N + 1;
}

","#include <iostream>
#include <vector>
#include <cassert>
int find_missing(std::vector<long>& ar, int N) {
    int l = 0;
    int r = N - 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (ar[mid] != mid + 1 && ar[mid - 1] == mid) {
            return mid + 1;
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

int find_missing(std::vector<long>& ar, int N) {
    int l = 0;
    int r = N - 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (ar[mid] != mid + 1 && ar[mid - 1] == mid) {
            return mid + 1;
        } else if (ar[mid] != mid + 1) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return -1;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

int find_missing(std::vector<long>& ar, int N) {
    int l = 0;
    int r = N - 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (ar[mid]!= mid + 1 && ar[mid - 1] == mid) {
            return mid + 1;
        } else if (ar[mid] > mid + 1) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return N + 1;
}

",1,5,0.7533960223197937,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_missing(std::vector<long>& ar, int N) {\n    int l = 0;\n    int r = N - 1;\n    while (l <= r) {\n        int mid = (l + r) / 2;\n        if (ar[mid] != mid + 1 && ar[mid - 1] == mid) {\n            return mid + 1;\n        } else if (ar[mid] != mid + 1) {\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return -1;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nint find_missing(std::vector<int>& ar, int N) {\n    int l = 0;\n    int r = N - 1;\n    while (l <= r) {\n        int mid = (l + r) / 2;\n        if (ar[mid] != mid + 1 && ar[mid - 1] == mid) {\n            return mid + 1;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_missing(std::vector<int>& ar, int N) {\n    int l = 0;\n    int r = N - 1;\n    while (l <= r) {\n        int mid = (l + r) / 2;\n        if (ar[mid]!= mid + 1 && ar[mid - 1] == mid) {\n            return mid + 1;\n        }\n        if (ar[mid] > mid + 1) {\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return N + 1;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint find_missing(std::vector<long>& ar, int N) {\n    int l = 0;\n    int r = N - 1;\n    while (l <= r) {\n        int mid = (l + r) / 2;\n        if (ar[mid] != mid + 1 && ar[mid - 1] == mid) {\n            return mid + 1;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_missing(std::vector<long>& ar, int N) {\n    int l = 0;\n    int r = N - 1;\n    while (l <= r) {\n        int mid = (l + r) / 2;\n        if (ar[mid]!= mid + 1 && ar[mid - 1] == mid) {\n            return mid + 1;\n        } else if (ar[mid] > mid + 1) {\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return N + 1;\n}\n\n', 'more_universe_var_type')]}"
24,"#include <iostream>
#include <cassert>
int find_rect_num(int n) {
//begin to write code
",88,"
#include <iostream>
#include <cassert>

int find_rect_num(int n) {
    return n * (n + 1);
}


","
using namespace std;
#include <iostream>
#include <cassert>

int find_rect_num(int n) {
    int result = 0;
    for (int i = 1; i <= n; ++i) {
        result += i * i;
    }
    return result;
}

",,,,-2,1,0.19373199542363484,code_expression_exchange:None,0.0,0.0,
25,"#include <iostream>
#include <cassert>
int find_Nth_Digit(int p, int q, int N) {
    int res;
    while (N > 0) {
        N -= 1;
        p *= 10;
//begin to write code
",169,"
#include <iostream>
#include <cassert>

int find_Nth_Digit(int p, int q, int N) {
    int res;
    while (N > 0) {
        N -= 1;
        p *= 10;
        res = p / q;
        p %= q;
    }
    return res;
}


","
#include <iostream>
#include <cassert>

int find_Nth_Digit(int p, int q, int N) {
    // Calculate the numerator and denominator of the fraction
    int numerator = p * q;
    int denominator = p + q;

    // If N is 1, return the first digit
    if (N == 1) {
        return numerator % 10;
    }

    // Find the remainder when N is divided by the denominator
    int remainder = N % denominator;

    // Calculate the position of the remainder in the numerator
    int position = remainder / denominator;

    // Return the digit at the calculated position
    return numerator / (denominator * 10) % 10;
}

",,,,-2,1,0.23112438917160033,code_expression_exchange:None,0.0,0.0,
26,"#include<cassert>
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
std::vector<std::string> sort_mixed_list(std::vector<std::string> mixed_list) {
    std::vector<int> int_part;
    std::vector<std::string> str_part;
    for (const auto& item : mixed_list) {
        if (isdigit(item[0]) || (item[0] == '-' && item.size() > 1 && isdigit(item[1]))) {
            int_part.push_back(std::stoi(item));
        } else {
            str_part.push_back(item);
        }
//begin to write code
",514,"#include<cassert>
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

std::vector<std::string> sort_mixed_list(std::vector<std::string> mixed_list) {
    std::vector<int> int_part;
    std::vector<std::string> str_part;

    for (const auto& item : mixed_list) {
        if (isdigit(item[0]) || (item[0] == '-' && item.size() > 1 && isdigit(item[1]))) {
            int_part.push_back(std::stoi(item));
        } else {
            str_part.push_back(item);
        }
    }

    std::sort(int_part.begin(), int_part.end());
    std::sort(str_part.begin(), str_part.end());

    std::vector<std::string> sorted_list;
    for (const auto& num : int_part) {
        sorted_list.push_back(std::to_string(num));
    }
    sorted_list.insert(sorted_list.end(), str_part.begin(), str_part.end());
    
    return sorted_list;
}


","
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <sstream>

std::vector<std::string> sort_mixed_list(std::vector<std::string> mixed_list) {
    std::vector<int> int_part;
    std::vector<std::string> str_part;
    for (const auto& item : mixed_list) {
        if (isdigit(item[0]) || (item[0] == '-' && item.size() > 1 && isdigit(item[1]))) {
            int_part.push_back(std::stoi(item));
        } else {
            str_part.push_back(item);
        }
    }

    // Sort the integers first
    std::sort(int_part.begin(), int_part.end());

    // Then sort the strings alphabetically
    std::sort(str_part.begin(), str_part.end());

    // Combine the sorted integers and strings back into a single vector
    std::vector<std::string> sorted_list;
    sorted_list.insert(sorted_list.end(), int_part.begin(), int_part.end());
    sorted_list.insert(sorted_list.end(), str_part.begin(), str_part.end());

    return sorted_list;
}

",,,,-2,1,0.22115339438120524,code_expression_exchange:None,0.0,0.0,
27,"#include<iostream>
#include <vector>
#include <cassert>
using namespace std;
double div_even_odd(const vector<int>& list1) {
    int first_even = -1;
    int first_odd = -1;
    for (int el : list1) {
        if (el % 2 == 0 && first_even == -1) {
            first_even = el;
        }
//begin to write code
",309,"#include<iostream>
    

#include <vector>
#include <cassert>

using namespace std;

double div_even_odd(const vector<int>& list1) {
    int first_even = -1;
    int first_odd = -1;
    for (int el : list1) {
        if (el % 2 == 0 && first_even == -1) {
            first_even = el;
        }
        if (el % 2 != 0 && first_odd == -1) {
            first_odd = el;
        }
    }
    if (first_even == -1 || first_odd == -1) return -1;
    return static_cast<double>(first_even) / first_odd;
}


","
#include<iostream>
#include <vector>
#include <cassert>
using namespace std;

double div_even_odd(const vector<int>& list1) {
    int first_even = -1;
    int first_odd = -1;
    for (int el : list1) {
        if (el % 2 == 0 && first_even == -1) {
            first_even = el;
        } else if (el % 2!= 0 && first_odd == -1) {
            first_odd = el;
        }
    }
    return first_even / first_odd;
}

void check() {
    assert(div_even_odd({1, 2, 3, 4, 5}) == 2.0);
    assert(div_even_odd({10, 20, 30, 40, 50}) == 20.0);
    assert(div_even_odd({1, 3, 5, 7, 9}) == 0.0);
    assert(div_even_odd({100, 200, 300, 400, 500}) == 20.0);
    cout << ""All tests passed successfully",,,,-2,1,0.22327584822972615,code_expression_exchange:None,0.0,0.0,
28,"#include <iostream>
#include <queue>
#include <string>
#include <unordered_map>
#include <cassert>
using namespace std;
string rearrange_string(string S) {
    unordered_map<char, int> ctr;
    for (char c : S) {
        ctr[c]++;
    }
    auto comp = [](pair<int, char> left, pair<int, char> right) {
        if (left.first == right.first) return left.second > right.second;
        return left.first < right.first;
    };
    priority_queue<pair<int, char>, vector<pair<int, char>>, decltype(comp)> heap(comp);
    for (auto& kv : ctr) {
        heap.push(make_pair(kv.second, kv.first));
    }
    if (heap.top().first > (S.length() + 1) / 2) {
        return """";
    }
    string ans = """";
//begin to write code
",717,"#include <iostream>
#include <queue>
#include <string>
#include <unordered_map>
#include <cassert>
using namespace std;

string rearrange_string(string S) {
    unordered_map<char, int> ctr;
    for (char c : S) {
        ctr[c]++;
    }
    
    auto comp = [](pair<int, char> left, pair<int, char> right) {
        if (left.first == right.first) return left.second > right.second;
        return left.first < right.first;
    };
    
    priority_queue<pair<int, char>, vector<pair<int, char>>, decltype(comp)> heap(comp);
    
    for (auto& kv : ctr) {
        heap.push(make_pair(kv.second, kv.first));
    }
    
    if (heap.top().first > (S.length() + 1) / 2) {
        return """";
    }
    
    string ans = """";
    while (heap.size() >= 2) {
        auto p1 = heap.top();
        heap.pop();
        auto p2 = heap.top();
        heap.pop();
        
        ans += p1.second;
        ans += p2.second;
        
        if (--p1.first > 0) heap.push(p1);
        if (--p2.first > 0) heap.push(p2);
    }
    
    if (!heap.empty()) {
        auto p = heap.top();
        heap.pop();
        ans += p.second;
    }
    
    return ans;
}","
#include <iostream>
#include <queue>
#include <string>
#include <unordered_map>
#include <cassert>
using namespace std;

string rearrange_string(string S) {
    unordered_map<char, int> ctr;
    for (char c : S) {
        ctr[c]++;
    }
    auto comp = [](pair<int, char> left, pair<int, char> right) {
        if (left.first == right.first) return left.second > right.second;
        return left.first < right.first;
    };
    priority_queue<pair<int, char>, vector<pair<int, char>>, decltype(comp)> heap(comp);
    for (auto& kv : ctr) {
        heap.push(make_pair(kv.second, kv.first));
    }
    if (heap.top().first > (S.length() + 1) / 2) {
        return """";
    }
    string ans = """";
    while (!heap.empty()) {
        pair<int, char> top = heap.top();
        heap.pop();
        ans += top.second;
        if (top.first!= 0) {
            heap.push(make_pair(top.first - 1, top.second));
        }
    }
    return ans;
}

",,,,-2,1,0.23580346902211508,code_expression_exchange:None,0.0,0.0,
29,"#include<cassert>
#include <iostream>
#include <vector>
#include <map>
using namespace std;
map<int, int> freq_element(vector<vector<int>>& nums) {
    map<int, int> result;
    for (auto& row : nums) {
        for (int num : row) {
//begin to write code
",255,"#include<cassert>
#include <iostream>
#include <vector>
#include <map>
using namespace std;

map<int, int> freq_element(vector<vector<int>>& nums) {
    map<int, int> result;
    for (auto& row : nums) {
        for (int num : row) {
            result[num]++;
        }
    }
    return result;
}


","
#include<cassert>
#include <iostream>
#include <vector>
#include <map>
using namespace std;

map<int, int> freq_element(vector<vector<int>>& nums) {
    map<int, int> result;
    for (auto& row : nums) {
        for (int num : row) {
            result[num]++;
        }
    }
    return result;
}

","#include<cassert>
#include <iostream>
#include <vector>
#include <map>
using namespace std;
map<int, long> freq_element(vector<vector<int>>& nums) {
    map<int, int> result;
    for (auto& row : nums) {
        for (int num : row) {
//begin to write code
","#include<cassert>
#include <iostream>
#include <vector>
#include <map>
using namespace std;

map<int, long> freq_element(vector<vector<int>>& nums) {
    map<int, int> result;
    for (auto& row : nums) {
        for (int num : row) {
            result[num]++;
        }
    }
    return result;
}


","
#include <cassert>
#include <iostream>
#include <vector>
#include <map>
using namespace std;

map<int, long> freq_element(vector<vector<int>>& nums) {
    map<int, int> result;
    for (auto& row : nums) {
        for (int num : row) {
            result[num]++;
        }
    }
    return result;
}

",1,5,0.6476194063822428,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<cassert>\n#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nmap<int, long> freq_element(vector<vector<int>>& nums) {\n    map<int, int> result;\n    for (auto& row : nums) {\n        for (int num : row) {\n            result[num]++;\n        }\n    }\n    return result;\n}\n\n\n': [('#include<cassert>\n#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nmap<int, int> freq_element(vector<vector<int>>& nums) {\n    map<int, int> result;\n    for (auto& row : nums) {\n        for (int num : row) {\n//begin to write code\n', '#include<cassert>\n#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nmap<int, int> freq_element(vector<vector<int>>& nums) {\n    map<int, int> result;\n    for (auto& row : nums) {\n        for (int num : row) {\n            result[num]++;\n        }\n    }\n    return result;\n}\n', 'bool2int'), ('#include<cassert>\n#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nmap<int, long> freq_element(vector<vector<int>>& nums) {\n    map<int, int> result;\n    for (auto& row : nums) {\n        for (int num : row) {\n//begin to write code\n', '\n#include <cassert>\n#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nmap<int, long> freq_element(vector<vector<int>>& nums) {\n    map<int, int> result;\n    for (auto& row : nums) {\n        for (int num : row) {\n            result[num]++;\n        }\n    }\n    return result;\n}\n\n', 'more_universe_var_type')]}"
30,"#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> filter_evennumbers(const std::vector<int>& nums) {
    std::vector<int> even_nums;
    for (int num : nums) {
        if (num % 2 == 0) {
//begin to write code
",234,"
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> filter_evennumbers(const std::vector<int>& nums) {
    std::vector<int> even_nums;
    for (int num : nums) {
        if (num % 2 == 0) {
            even_nums.push_back(num);
        }
    }
    return even_nums;
}


","
#include <iostream>
#include <vector>
#include <cassert>
#include <functional>

std::vector<int> filter_evennumbers(const std::vector<int>& nums) {
    std::vector<int> even_nums;
    for (int num : nums) {
        if (num % 2 == 0) {
            even_nums.push_back(num);
        }
    }
    return even_nums;
}

// Test cases to verify the correctness of the function
void test_filter_evennumbers() {
    assert(filter_evennumbers({1, 2, 3, 4, 5}) == std::vector<int>({2, 4}));
    assert(filter_evennumbers({10, 15, 20, 25, 30}) == std::vector<int>({10, 20, 30}));
    assert(filter_evennumbers({}) == std::vector<int>());
    assert(filter_evennumbers({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == std::vector<int>({2, 4, 6, 8, 10}));
}

","#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> filter_evennumbers(const std::vector<long>& nums) {
    std::vector<int> even_nums;
    for (int num : nums) {
        if (num % 2 == 0) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> filter_evennumbers(const std::vector<long>& nums) {
    std::vector<int> even_nums;
    for (int num : nums) {
        if (num % 2 == 0) {
            even_nums.push_back(num);
        }
    }
    return even_nums;
}


","
#include <iostream>
#include <vector>
#include <cassert>

// Function to filter even numbers using lambda function
std::vector<int> filter_evennumbers(const std::vector<long>& nums) {
    std::vector<int> even_nums;
    for (int num : nums) {
        if (num % 2 == 0) {
            even_nums.push_back(num);
        }
    }
    return even_nums;
}

",1,5,0.7453192194302877,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> filter_evennumbers(const std::vector<long>& nums) {\n    std::vector<int> even_nums;\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            even_nums.push_back(num);\n        }\n    }\n    return even_nums;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> filter_evennumbers(const std::vector<int>& nums) {\n    std::vector<int> even_nums;\n    for (int num : nums) {\n        if (num % 2 == 0) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\n// Function to filter even numbers using lambda function\nstd::vector<int> filter_evennumbers(const std::vector<int>& nums) {\n    std::vector<int> even_nums;\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            even_nums.push_back(num);\n        }\n    }\n    return even_nums;\n}\n\n// Main function to test the filter_evennumbers function\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> filter_evennumbers(const std::vector<long>& nums) {\n    std::vector<int> even_nums;\n    for (int num : nums) {\n        if (num % 2 == 0) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\n// Function to filter even numbers using lambda function\nstd::vector<int> filter_evennumbers(const std::vector<long>& nums) {\n    std::vector<int> even_nums;\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            even_nums.push_back(num);\n        }\n    }\n    return even_nums;\n}\n\n', 'more_universe_var_type')]}"
31,"#include <iostream>
#include <vector>
#include <unordered_map>
#include <cassert>
using namespace std;
int find_Sum(const vector<int>& arr) {
    unordered_map<int, int> count;
    for (int num : arr) {
        count[num]++;
    }
    int sum = 0;
//begin to write code
",270,"
#include <iostream>
#include <vector>
#include <unordered_map>
#include <cassert>
using namespace std;

int find_Sum(const vector<int>& arr) {
    unordered_map<int, int> count;
    for (int num : arr) {
        count[num]++;
    }
    int sum = 0;
    for (const auto& p : count) {
        if (p.second > 1) {
            sum += p.first;
        }
    }
    return sum;
}


","
#include <iostream>
#include <vector>
#include <unordered_map>
#include <cassert>
using namespace std;

int find_Sum(const vector<int>& arr) {
    unordered_map<int, int> count;
    for (int num : arr) {
        count[num]++;
    }
    int sum = 0;
    for (const auto& pair : count) {
        if (pair.second > 1) {
            sum += pair.first * pair.second;
        }
    }
    return sum;
}

",,,,-2,1,0.2325751264890035,code_expression_exchange:None,0.0,0.0,
32,"#include <iostream>
#include <regex>
#include <cassert>
using namespace std;
string text_match(const string& text) {
    regex pattern(""^[a-z]+_[a-z]+$"");
    if (regex_search(text, pattern)) {
        return ""Found a match!"";
//begin to write code
",249,"
#include <iostream>
#include <regex>
#include <cassert>

using namespace std;

string text_match(const string& text) {
    regex pattern(""^[a-z]+_[a-z]+$"");
    if (regex_search(text, pattern)) {
        return ""Found a match!"";
    } else {
        return ""Not matched!"";
    }
}


","
#include <iostream>
#include <regex>
#include <cassert>
using namespace std;

string text_match(const string& text) {
    regex pattern(""^[a-z]+_[a-z]+$"");
    if (regex_search(text, pattern)) {
        return ""Found a match!"";
    } else {
        return ""No match found."";
    }
}

",,,,-2,1,0.23636120955149334,code_expression_exchange:None,0.0,0.0,
33,"#include <iostream>
#include <cassert>
using namespace std;
string text_match_string(string text) {
    if (text.empty()) {
        return ""Not matched!"";
    }
    if (isalnum(text[0]) || text[0] == '_') {
//begin to write code
",229,"#include <iostream>
#include <cassert>
using namespace std;

string text_match_string(string text) {
    if (text.empty()) {
        return ""Not matched!"";
    }

    if (isalnum(text[0]) || text[0] == '_') {
        return ""Found a match!"";
    } else {
        return ""Not matched!"";
    }

}","
#include <iostream>
#include <cassert>
using namespace std;

string text_match_string(string text) {
    if (text.empty()) {
        return ""Not matched!"";
    }
    if (isalnum(text[0]) || text[0] == '_') {
        // Begin to write code
        if (text.size() > 0 && isalnum(text[1])) {
            return text.substr(1);
        } else {
            return ""Not a valid word at the beginning of the string."";
        }
    } else {
        return ""Invalid input. Please provide a non-empty string."";
    }
}

",,,,-2,1,0.22969022989273072,code_expression_exchange:None,0.0,0.0,
34,"#include <iostream>
#include <vector>
#include <cassert>
int find_gcd(int x, int y) {
    while (y != 0) {
        int temp = x % y;
        x = y;
        y = temp;
    }
    return x;
}
//begin to write code
",210,"
#include <iostream>
#include <vector>
#include <cassert>

int find_gcd(int x, int y) {
    while (y != 0) {
        int temp = x % y;
        x = y;
        y = temp;
    }
    return x;
}

int get_gcd(std::vector<int> l) {
    int num1 = l[0];
    int num2 = l[1];
    int gcd = find_gcd(num1, num2);
    for (size_t i = 2; i < l.size(); i++) {
        gcd = find_gcd(gcd, l[i]);
    }
    return gcd;
}


","
#include <iostream>
#include <vector>
#include <cassert>

int find_gcd(int x, int y) {
    while (y!= 0) {
        int temp = x % y;
        x = y;
        y = temp;
    }
    return x;
}

// Test cases
void test_find_gcd() {
    assert(find_gcd(8, 4) == 2);
    assert(find_gcd(25, 15) == 5);
    assert(find_gcd(7, 3) == 1);
    assert(find_gcd(0, 5) == 5);
    std::cout << ""All test cases passed successfully."" << std::endl;
}

",,,,-2,1,0.19497274955113728,code_expression_exchange:None,0.0,0.0,
35,"#include<iostream>
#include <vector>
#include <set>
#include <cassert>
bool test_distinct(const std::vector<int>& data) {
    std::set<int> distinctSet(data.begin(), data.end());
//begin to write code
",201,"#include<iostream>
    

#include <vector>
#include <set>
#include <cassert>

bool test_distinct(const std::vector<int>& data) {
    std::set<int> distinctSet(data.begin(), data.end());
    return data.size() == distinctSet.size();
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<set>
#include<assert.h>

bool test_distinct(const std::vector<int>& data) {
    std::set<int> distinctSet(data.begin(), data.end());
    return distinctSet.size() == data.size();
}

","#include<iostream>
#include <vector>
#include <set>
#include <cassert>
bool test_distinct(const std::vector<long>& data) {
    std::set<int> distinctSet(data.begin(), data.end());
//begin to write code
","#include<iostream>
    

#include <vector>
#include <set>
#include <cassert>

bool test_distinct(const std::vector<long>& data) {
    std::set<int> distinctSet(data.begin(), data.end());
    return distinctSet.size() == data.size();
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>
#include <set>

bool test_distinct(const std::vector<long>& data) {
    std::set<int> distinctSet(data.begin(), data.end());
    if (distinctSet.size()!= data.size()) {
        return false;
    }
    return true;
}
",1,11,1.5107555707295737,code_expression_exchange:exchange_operators,1.0,0.0,"{'#include<iostream>\n    \n\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool test_distinct(const std::vector<long>& data) {\n    std::set<int> distinctSet(data.begin(), data.end());\n    return distinctSet.size() == data.size();\n}\n\n\n': [('#include<iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool test_distinct(const std::vector<int>& data) {\n    std::set<int> distinctSet(data.begin(), data.end());\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<set>\n#include<assert.h>\n\nbool test_distinct(const std::vector<int>& data) {\n    std::set<int> distinctSet(data.begin(), data.end());\n    if (distinctSet.size() == data.size()) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool test_distinct(const std::vector<int>& data) {\n    std::set<int> distinctSet(data.begin(), data.end());\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool test_distinct(const std::vector<int>& data) {\n    std::set<int> distinctSet(data.begin(), data.end());\n    // Your code here\n    return distinctSet.size() == data.size();\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool test_distinct(const std::vector<long>& data) {\n    std::set<int> distinctSet(data.begin(), data.end());\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool test_distinct(const std::vector<long>& data) {\n    std::set<int> distinctSet(data.begin(), data.end());\n    return distinctSet.size() == data.size();\n}\n\n', 'more_universe_var_type'), ('#include<iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool test_distinct(const std::vector<long>& data) {\n    std::set<int> distinctSet(data.begin(), data.end());\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<set>\n#include<assert.h>\n\nbool test_distinct(const std::vector<long>& data) {\n    std::set<int> distinctSet(data.begin(), data.end());\n    return distinctSet.size() == data.size();\n}\n\n', 'equal_expression_transformation'), ('#include<iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool test_distinct(const std::vector<long>& data) {\n    std::set<int> distinctSet(data.begin(), data.end());\n//begin to write code\n', 'using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n#include <set>\n\nbool test_distinct(const std::vector<long>& data) {\n    std::set<int> distinctSet(data.begin(), data.end());\n    if (distinctSet.size()!= data.size()) {\n        return false;\n    }\n    return true;\n}\n', 'exchange_operators')]}"
36,"#include <iostream>
#include <cassert>
using namespace std;
int compute_Last_Digit(int A, int B) {
    int variable = 1;
    if (A == B) {
        return 1;
    } else if ((B - A) >= 5) {
        return 0;
//begin to write code
",228,"
#include <iostream>
#include <cassert>

using namespace std;

int compute_Last_Digit(int A, int B) {
    int variable = 1;
    if (A == B) {
        return 1;
    } else if ((B - A) >= 5) {
        return 0;
    } else {
        for (int i = A + 1; i <= B; i++) {
            variable = (variable * (i % 10)) % 10;
        }
        return variable;
    }
}


","
#include <iostream>
#include <cassert>
using namespace std;

int compute_Last_Digit(int A, int B) {
    int variable = 1;
    if (A == B) {
        return 1;
    } else if ((B - A) >= 5) {
        return 0;
    } else {
        while (B > A) {
            B /= 10;
            variable *= 10;
        }
        return variable % 10;
    }
}

",,,,-2,1,0.23240511020024618,code_expression_exchange:None,0.0,0.0,
37,"#include <iostream>
#include <cassert>
int odd_bit_set_number(int n) {
    int count = 0;
    int res = 0;
    int temp = n;
    while (temp > 0) {
        if (count % 2 == 0) {
//begin to write code
",200,"
#include <iostream>
#include <cassert>

int odd_bit_set_number(int n) {
    int count = 0;
    int res = 0;
    int temp = n;
    while (temp > 0) {
        if (count % 2 == 0) {
            res |= (1 << count);
        }
        count += 1;
        temp >>= 1;
    }
    return (n | res);
}


","
#include <iostream>
#include <cassert>

int odd_bit_set_number(int n) {
    int count = 0;
    int res = 0;
    int temp = n;
    while (temp > 0) {
        if (count % 2 == 0) {
            res |= (1 << count); // Set the bit at position count to 1
        }
        temp >>= 1; // Right shift the number by 1 bit
        count++;
    }
    return res;
}

",,,,-2,1,0.22753280798594158,code_expression_exchange:None,0.0,0.0,
38,"#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> specified_element(const std::vector<std::vector<int>>& nums, int N) {
    std::vector<int> result;
    for (const auto& i : nums) {
//begin to write code
",228,"
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> specified_element(const std::vector<std::vector<int>>& nums, int N) {
    std::vector<int> result;
    for (const auto& i : nums) {
        result.push_back(i[N]);
    }
    return result;
}


","#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> specified_element(const std::vector<std::vector<int>>& nums, int N) {
    std::vector<int> result;
    for (int i = 0; i < nums.size(); ++i) {
        if (i < N) {
            result.push_back(nums[i][0]);
        }
    }
    return result;
}
",,,,-2,1,0.17101136843363443,code_expression_exchange:None,0.0,0.0,
39,"#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
std::pair<int, std::vector<int>> min_length_list(const std::vector<std::vector<int>>& input_list) {
    auto min_it = std::min_element(input_list.begin(), input_list.end(),
                                   [](const std::vector<int>& a, const std::vector<int>& b) {
                                       return a.size() < b.size();
//begin to write code
",434,"
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::pair<int, std::vector<int>> min_length_list(const std::vector<std::vector<int>>& input_list) {
    auto min_it = std::min_element(input_list.begin(), input_list.end(),
                                   [](const std::vector<int>& a, const std::vector<int>& b) {
                                       return a.size() < b.size();
                                   });
    int min_length = min_it->size();
    return {min_length, *min_it};
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::pair<int, std::vector<int>> min_length_list(const std::vector<std::vector<int>>& input_list) {
    return *std::min_element(input_list.begin(), input_list.end(),
                           [](const std::vector<int>& a, const std::vector<int>& b) {
                               return a.size() < b.size();
                           });
}

",,,,-2,1,0.22731304566065472,code_expression_exchange:None,0.0,0.0,
40,"#include <iostream>
#include <cassert>
bool check_equilateral(int x, int y, int z) {
//begin to write code
",107,"
#include <iostream>
#include <cassert>

bool check_equilateral(int x, int y, int z) {
    return (x == y && y == z);
}


","
#include <iostream>
#include <cassert>

bool check_equilateral(int x, int y, int z) {
    // Check if all three sides are equal
    return x == y && y == z;
}

","#include <iostream>
#include <cassert>
bool check_equilateral(long x, long y, long z) {
//begin to write code
","
#include <iostream>
#include <cassert>

bool check_equilateral(long x, long y, long z) {
    return (x == y && y == z);
}


","
#include <iostream>
#include <cassert>
bool check_equilateral(long x, long y, long z) {
    // Check if all three sides are equal
    return x == y && y == z;
}

",-1,21,2.692303391297658,code_expression_exchange:bool2int,1.0,0.7339354456579965,"{'\n#include <iostream>\n#include <cassert>\n\nbool check_equilateral(long x, long y, long z) {\n    return (x == y && y == z);\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nbool check_equilateral(int x, long y, int z) {\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\nbool check_equilateral(int x, long y, int z) {\n    // Check if all sides are equal\n    return x == y && y == z;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nbool check_equilateral(int x, long y, int z) {\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nbool check_equilateral(int x, long y, int z) {\n    // Check if all three sides are equal\n    return x == y && y == z;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cassert>\nbool check_equilateral(long x, long y, int z) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nbool check_equilateral(long x, long y, int z) {\n    // Check if all sides are equal\n    return x == y && y == z;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nbool check_equilateral(long x, long y, int z) {\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n#include <cmath>\n\nbool check_equilateral(long x, long y, int z) {\n    return x == y && y == z;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cassert>\nbool check_equilateral(long x, long y, long z) {\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nbool check_equilateral(long x, long y, long z) {\n    return x == y && y == z;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nbool check_equilateral(long x, long y, long z) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <cassert>\n\nbool check_equilateral(long x, long y, long z) {\n    // Check if all sides are equal\n    return x == y && y == z;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cassert>\nbool check_equilateral(long x, long y, long z) {\n//begin to write code\n', '\nusing namespace std;\n#include <cassert>\n\nbool check_equilateral(long x, long y, long z) {\n    // Check if all three sides are equal\n    return x == y && y == z;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cassert>\nbool check_equilateral(long x, long y, long z) {\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nbool check_equilateral(long x, long y, long z) {\n    // Check if all three sides are equal\n    return x == y && y == z;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nbool check_equilateral(long x, long y, long z) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <cassert>\n\nbool check_equilateral(long x, long y, long z) {\n    return x == y && y == z;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nbool check_equilateral(long x, long y, long z) {\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\nbool check_equilateral(long x, long y, long z) {\n    // Check if all three sides are equal\n    return x == y && y == z;\n}\n\n', 'bool2int')]}"
41,"#include<iostream>
#include<cassert>
//
int parallelogram_area(int b, int h) {
//begin to write code
",105,"
#include<iostream>
#include<cassert>

//
int parallelogram_area(int b, int h) {
    int area = b * h;
    return area;
}


","
#include<iostream>
#include<cassert>

//
int parallelogram_area(int b, int h) {
    return b * h;
}

// Test cases
void test_parallelogram_area() {
    assert(parallelogram_area(5, 3) == 15);
    assert(parallelogram_area(7, 4) == 28);
    assert(parallelogram_area(2, 6) == 12);
    std::cout << ""All test cases passed!"" << std::endl;
}

","#include<iostream>
#include<cassert>
//
int parallelogram_area(long b, int h) {
//begin to write code
","
#include<iostream>
#include<cassert>

//
int parallelogram_area(long b, int h) {
    int area = b * h;
    return area;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<cmath> // For sqrt function

// Function to calculate the area of a parallelogram
int parallelogram_area(long b, int h) {
    return b * h;
}

",1,9,1.0736287236213684,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include<iostream>\n#include<cassert>\n\n//\nint parallelogram_area(long b, int h) {\n    int area = b * h;\n    return area;\n}\n\n\n': [('#include<iostream>\n#include<cassert>\n//\nint parallelogram_area(int b, int h) {\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\n// Function definition\nint parallelogram_area(int b, int h) {\n    return b * h;\n}\n\n// Test cases\nvoid test_parallelogram_area() {\n    assert(parallelogram_area(5, 3) == 15);\n    assert(parallelogram_area(7, 4) == 28);\n    assert(parallelogram_area(10, 6) == 60);\n    std::cout << ""All test cases passed successfully."" << std::endl;\n}\n\n', 'equal_expression_transformation'), ('#include<iostream>\n#include<cassert>\n//\nint parallelogram_area(int b, int h) {\n//begin to write code\n', '\n#include<iostream>\n#include<cassert>\n\n// Function definition\nint parallelogram_area(int b, int h) {\n    return b * h;\n}\n\n// Test cases\nvoid test_parallelogram_area() {\n    assert(parallelogram_area(5, 3) == 15);\n    assert(parallelogram_area(7, 4) == 28);\n    assert(parallelogram_area(10, 6) == 60);\n    std::cout << ""All test cases passed successfully."" << std::endl;\n}\n\n', 'equal_expression_transformation'), ('#include<iostream>\n#include<cassert>\n//\nint parallelogram_area(long b, int h) {\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<iostream>\n#include<cassert>\n//\nint parallelogram_area(long b, int h) {\n    return b * h;\n}\n\n', 'more_universe_var_type'), ('#include<iostream>\n#include<cassert>\n//\nint parallelogram_area(long b, int h) {\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<cmath> // For sqrt function\n\n// Function to calculate the area of a parallelogram\nint parallelogram_area(long b, int h) {\n    return b * h;\n}\n\n', 'bool2int')]}"
42,"#include <iostream>
#include <string>
#include <cassert>
std::string check_Equality(const std::string& str) {
    if (str[0] == str[str.length() - 1]) {
        return ""Equal"";
//begin to write code
",199,"
#include <iostream>
#include <string>
#include <cassert>

std::string check_Equality(const std::string& str) {
    if (str[0] == str[str.length() - 1]) {
        return ""Equal"";
    } else {
        return ""Not Equal"";
    }
}


","
using namespace std;
#include <iostream>
#include <string>
#include <cassert>

std::string check_Equality(const std::string& str) {
    if (str[0] == str[str.length() - 1]) {
        return ""Equal"";
    }
    return ""Not Equal"";
}

","#include <iostream>
#include <string>
#include <cassert>
std::string check_Equality(const std::string& str) {
    if (str[str.length() - 1] == str[0]) {
        return ""Equal"";
//begin to write code
","
#include <iostream>
#include <string>
#include <cassert>

std::string check_Equality(const std::string& str) {
    if (str[str.length() - 1] == str[0]) {
        return ""Equal"";
    } else {
        return ""Not Equal"";
    }
}


","
using namespace std;
#include <iostream>
#include <string>
#include <cassert>

std::string check_Equality(const std::string& str) {
    if (str[str.length() - 1] == str[0]) {
        return ""Equal"";
    }
    return ""Not Equal"";
}

",-1,21,2.757493789990743,code_expression_exchange:equal_expression_transformation,1.0,0.7090051466420328,"{'\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string check_Equality(const std::string& str) {\n    if (str[str.length() - 1] == str[0]) {\n        return ""Equal"";\n    } else {\n        return ""Not Equal"";\n    }\n}\n\n\n': [('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string check_Equality(const std::string& str) {\n    if (str[0] == str[str.length() - 1]) {\n        return ""Equal"";\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string check_Equality(const std::string& str) {\n    if (str[0] == str[str.length() - 1]) {\n        return ""Equal"";\n    }\n    return ""Not Equal"";\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string check_Equality(const std::string& str) {\n    if (str[0] == str[str.length() - 1]) {\n        return ""Equal"";\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string check_Equality(const std::string& str) {\n    if (str[0] == str[str.length() - 1]) {\n        return ""Equal"";\n    } else {\n        return ""Not Equal"";\n    }\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string check_Equality(const std::string& str) {\n    if (str[0] == str[str.length() - 1]) {\n        return ""Equal"";\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string check_Equality(const std::string& str) {\n    if (str[0] == str[str.length() - 1]) {\n        return ""Equal"";\n    }\n    return ""Not Equal"";\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string check_Equality(const std::string& str) {\n    if (str[str.length() - 1] == str[0]) {\n        return ""Equal"";\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string check_Equality(const std::string& str) {\n    if (str[str.length() - 1] == str[0]) {\n        return ""Equal"";\n    } else {\n        return ""Not Equal"";\n    }\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string check_Equality(const std::string& str) {\n    if (str[str.length() - 1] == str[0]) {\n        return ""Equal"";\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string check_Equality(const std::string& str) {\n    if (str[str.length() - 1] == str[0]) {\n        return ""Equal"";\n    } else {\n        return ""Not Equal"";\n    }\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string check_Equality(const std::string& str) {\n    if (str[str.length() - 1] == str[0]) {\n        return ""Equal"";\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string check_Equality(const std::string& str) {\n    if (str[str.length() - 1] == str[0]) {\n        return ""Equal"";\n    }\n    return ""Not Equal"";\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string check_Equality(const std::string& str) {\n    if (str[str.length() - 1] == str[0]) {\n        return ""Equal"";\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string check_Equality(const std::string& str) {\n    if (str[str.length() - 1] == str[0]) {\n        return ""Equal"";\n    }\n    return ""Not Equal"";\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string check_Equality(const std::string& str) {\n    if (str[str.length() - 1] == str[0]) {\n        return ""Equal"";\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string check_Equality(const std::string& str) {\n    if (str[str.length() - 1] == str[0]) {\n        return ""Equal"";\n    }\n    return ""Not Equal"";\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string check_Equality(const std::string& str) {\n    if (str[str.length() - 1] == str[0]) {\n        return ""Equal"";\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string check_Equality(const std::string& str) {\n    if (str[str.length() - 1] == str[0]) {\n        return ""Equal"";\n    } else {\n        return ""Not Equal"";\n    }\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string check_Equality(const std::string& str) {\n    if (str[str.length() - 1] == str[0]) {\n        return ""Equal"";\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string check_Equality(const std::string& str) {\n    if (str[str.length() - 1] == str[0]) {\n        return ""Equal"";\n    }\n    return ""Not Equal"";\n}\n\n', 'equal_expression_transformation')]}"
43,"#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
std::vector<int> counting_sort(std::vector<int> my_list) {
    int max_value = 0;
    for (int i = 0; i < my_list.size(); ++i) {
        if (my_list[i] > max_value) {
            max_value = my_list[i];
        }
    }
    std::vector<int> buckets(max_value + 1, 0);
    for (int num : my_list) {
        buckets[num]++;
//begin to write code
",421,"
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::vector<int> counting_sort(std::vector<int> my_list) {
    int max_value = 0;
    for (int i = 0; i < my_list.size(); ++i) {
        if (my_list[i] > max_value) {
            max_value = my_list[i];
        }
    }
    std::vector<int> buckets(max_value + 1, 0);
    for (int num : my_list) {
        buckets[num]++;
    }
    int index = 0;
    for (int j = 0; j <= max_value; ++j) {
        for (int a = 0; a < buckets[j]; ++a) {
            my_list[index] = j;
            index++;
        }
    }
    return my_list;
}


","#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
std::vector<int> counting_sort(std::vector<int> my_list) {
    int max_value = 0;
    for (int i = 0; i < my_list.size(); ++i) {
        if (my_list[i] > max_value) {
            max_value = my_list[i];
        }
    }
    std::vector<int> buckets(max_value + 1, 0);
    for (int num : my_list) {
        buckets[num]++;
    }
    std::vector<int> sorted_list;
    for (int i = 0; i <= max_value; ++i) {
        for (int j = 0; j < buckets[i]; ++j) {
            sorted_list.push_back(i);
        }
    }
    return sorted_list;
}
","#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
std::vector<int> counting_sort(std::vector<int> my_list) {
    int max_value = 0;
    for (int i = 0; i < my_list.size(); ++i) {
        if (my_list[i] > max_value) {
            max_value = my_list[i];
        }
    }
    std::vector<int> buckets(max_value + 1, 0);
    for (int num : my_list) {
        buckets[num]++;
//begin to write code
","
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::vector<int> counting_sort(std::vector<int> my_list) {
    int max_value = 0;
    for (int i = 0; i < my_list.size(); ++i) {
        if (my_list[i] > max_value) {
            max_value = my_list[i];
        }
    }
    std::vector<int> buckets(max_value + 1, 0);
    for (int num : my_list) {
        buckets[num]++;
    }
    int index = 0;
    for (int j = 0; j <= max_value; ++j) {
        for (int a = 0; a < buckets[j]; ++a) {
            my_list[index] = j;
            index++;
        }
    }
    return my_list;
}


","Complete code (including all the content of the code I provided and the code you generated)
",1,3,0.46082726716995237,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> counting_sort(std::vector<int> my_list) {\n    int max_value = 0;\n    for (int i = 0; i < my_list.size(); ++i) {\n        if (my_list[i] > max_value) {\n            max_value = my_list[i];\n        }\n    }\n    std::vector<int> buckets(max_value + 1, 0);\n    for (int num : my_list) {\n        buckets[num]++;\n    }\n    int index = 0;\n    for (int j = 0; j <= max_value; ++j) {\n        for (int a = 0; a < buckets[j]; ++a) {\n            my_list[index] = j;\n            index++;\n        }\n    }\n    return my_list;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nstd::vector<int> counting_sort(std::vector<int> my_list) {\n    int max_value = 0;\n    for (int i = 0; i < my_list.size(); ++i) {\n        if (my_list[i] > max_value) {\n            max_value = my_list[i];\n        }\n    }\n    std::vector<int> buckets(max_value + 1, 0);\n    for (int num : my_list) {\n        buckets[num]++;\n//begin to write code\n', 'Complete code (including all the content of the code I provided and the code you generated)\n', 'bool2int')]}"
44,"#include<cassert>
#include <iostream>
#include <cmath>
using namespace std;
double tn_gp(double a, int n, double r) {
    double tn = a * pow(r, n - 1);
//begin to write code
",175,"#include<cassert>
#include <iostream>
#include <cmath>
using namespace std;

double tn_gp(double a, int n, double r) {
    double tn = a * pow(r, n - 1);
    return tn;
}


","
#include<cassert>
#include <iostream>
#include <cmath>
using namespace std;

// Function to calculate the nth term of a geometric series
double tn_gp(double a, int n, double r) {
    // Calculate the nth term using the formula for the nth term of a geometric series
    return a * pow(r, n - 1);
}

","#include<cassert>
#include <iostream>
#include <cmath>
using namespace std;
double tn_gp(double a, int n, double r) {
    double tn = pow(r, n - 1) * a;
//begin to write code
","#include<cassert>
#include <iostream>
#include <cmath>
using namespace std;

double tn_gp(double a, int n, double r) {
    double tn = pow(r, n - 1) * a;
    return tn;
}


","
#include <iostream>
#include <cmath>
using namespace std;

double tn_gp(double a, int n, double r) {
    double tn = pow(r, n - 1) * a;
    return tn;
}

",1,9,1.2164320588111877,code_expression_exchange:bool2int,1.0,0.0,"{'#include<cassert>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\ndouble tn_gp(double a, int n, double r) {\n    double tn = pow(r, n - 1) * a;\n    return tn;\n}\n\n\n': [('#include<cassert>\n#include <iostream>\n#include <cmath>\nusing namespace std;\ndouble tn_gp(double a, int n, double r) {\n    double tn = pow(r, n - 1) * a;\n//begin to write code\n', '\n#include <cmath>\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\ndouble tn_gp(double a, int n, double r) {\n    double tn = pow(r, n - 1) * a;\n    return tn;\n}\n\n', 'exchange_operators'), ('#include<cassert>\n#include <iostream>\n#include <cmath>\nusing namespace std;\ndouble tn_gp(double a, int n, double r) {\n    double tn = a * pow(r, n - 1);\n//begin to write code\n', '\n#include <cassert>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\ndouble tn_gp(double a, int n, double r) {\n    // Check if n is a positive integer\n    if (n <= 0) {\n        throw invalid_argument(""n must be a positive integer."");\n    }\n    \n    // Calculate the n-th term using the geometric series formula\n    double tn = a * pow(r, n - 1);\n    \n    return tn;\n}\n\n', 'exchange_operators'), ('#include<cassert>\n#include <iostream>\n#include <cmath>\nusing namespace std;\ndouble tn_gp(double a, int n, double r) {\n    double tn = pow(r, n - 1) * a;\n//begin to write code\n', '\n#include<cassert>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n// Function to find t-nth term of geometric series\ndouble tn_gp(double a, int n, double r) {\n    return pow(r, n - 1) * a;\n}\n\n', 'exchange_operators'), ('#include<cassert>\n#include <iostream>\n#include <cmath>\nusing namespace std;\ndouble tn_gp(double a, int n, double r) {\n    double tn = pow(r, n - 1) * a;\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\ndouble tn_gp(double a, int n, double r) {\n    double tn = pow(r, n - 1) * a;\n    return tn;\n}\n\n', 'bool2int')]}"
45,"#include <iostream>
#include <cassert>
// 
int rev(int num) {
    int rev_num = 0;
    while (num > 0) {
        rev_num = rev_num * 10 + num % 10;
        num = num / 10;
//begin to write code
",198,"
#include <iostream>
#include <cassert>

// 
int rev(int num) {
    int rev_num = 0;
    while (num > 0) {
        rev_num = rev_num * 10 + num % 10;
        num = num / 10;
    }
    return rev_num;
}

bool check(int n) {
    return (2 * rev(n) == n + 1);
}


","
#include <iostream>
#include <cassert>

// 
int rev(int num) {
    int rev_num = 0;
    while (num > 0) {
        rev_num = rev_num * 10 + num % 10;
        num = num / 10;
    }
    return rev_num;
}

// one less than twice
bool isOneLessThanTwiceReverse(int num) {
    int reversed_num = rev(num);
    return num == 2 * reversed_num - 1;
}

// 
void testIsOneLessThanTwiceReverse() {
    assert(isOneLessThanTwiceReverse(1) == false); // 1!= 2 * 1 - 1
    assert(isOneLessThanTwiceReverse(2) == true);  // 2 == 2 * 1 - 1
    assert(isOneLessThanTwiceReverse(3) == false); // 3!= 2 * 3 - 1
    assert(isOneLessThanTwiceReverse(4) == true);  // 4 == 2 * 4 - ",,,,-2,1,0.22575515111287434,code_expression_exchange:None,0.0,0.0,
46,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
// 
int find_Max_Num(std::vector<int> arr, int n) {
    std::sort(arr.rbegin(), arr.rend());
    int num = arr[0];
//begin to write code
",218,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>

// 
int find_Max_Num(std::vector<int> arr, int n) {
    std::sort(arr.rbegin(), arr.rend());
    int num = arr[0];
    for (int i = 1; i < n; ++i) {
        num = num * 10 + arr[i];
    }
    return num;
}


","
#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
// 
int find_Max_Num(std::vector<int> arr, int n) {
    std::sort(arr.rbegin(), arr.rend());
    return arr[n - 1];
}

",,,,-2,1,0.19262255827585856,code_expression_exchange:None,0.0,0.0,
47,"#include <iostream>
#include <cassert>
bool opposite_Signs(int x, int y) {
//begin to write code
",97,"
#include <iostream>
#include <cassert>

bool opposite_Signs(int x, int y) {
    return ((x ^ y) < 0);
}


","
#include <iostream>
#include <cassert>

bool opposite_Signs(int x, int y) {
    return (x < 0 && y > 0) || (x > 0 && y < 0);
}

","#include <iostream>
#include <cassert>
bool opposite_Signs(long x, int y) {
//begin to write code
","
#include <iostream>
#include <cassert>

bool opposite_Signs(long x, int y) {
    return ((y ^ x) < 0);
}


","
#include <iostream>
#include <cassert>

bool opposite_Signs(long x, int y) {
    // Check if both numbers are negative
    if (x < 0 && y < 0) {
        return true;
    }
    // Check if both numbers are positive
    else if (x > 0 && y > 0) {
        return false;
    }
    // If they are equal, they have the same sign
    else {
        return false;
    }
}

",1,5,0.7226298610369365,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nbool opposite_Signs(long x, int y) {\n    return ((y ^ x) < 0);\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nbool opposite_Signs(long x, int y) {\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nbool opposite_Signs(long x, int y) {\n    return x < 0 && y > 0 || x > 0 && y < 0;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nbool opposite_Signs(long x, int y) {\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nbool opposite_Signs(long x, int y) {\n    // Check if both numbers are negative\n    if (x < 0 && y < 0) {\n        return true;\n    }\n    // Check if both numbers are positive\n    else if (x > 0 && y > 0) {\n        return false;\n    }\n    // If they are equal, they have the same sign\n    else {\n        return false;\n    }\n}\n\n', 'exchange_operators')]}"
48,"#include <iostream>
#include <cassert>
int is_octagonal(int n) {
//begin to write code
",87,"
#include <iostream>
#include <cassert>

int is_octagonal(int n) {
    return 3 * n * n - 2 * n;
}


","
#include <iostream>
#include <cassert>

int is_octagonal(int n) {
    // Your implementation here
}

",,,,-2,1,0.22957238753636677,code_expression_exchange:None,0.0,0.0,
49,"#include<iostream>
#include <vector>
#include <cmath>
#include <cassert>
using namespace std;
int max_len_sub(vector<int> arr, int n) {
    vector<int> mls(n, 1);
    int max = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (abs(arr[i] - arr[j]) <= 1 && mls[i] < mls[j] + 1) {
                mls[i] = mls[j] + 1;
            }
//begin to write code
",393,"#include<iostream>
    

#include <vector>
#include <cmath>
#include <cassert>
using namespace std;

int max_len_sub(vector<int> arr, int n) {
    vector<int> mls(n, 1);
    int max = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (abs(arr[i] - arr[j]) <= 1 && mls[i] < mls[j] + 1) {
                mls[i] = mls[j] + 1;
            }
        }
    }
    for (int i = 0; i < n; ++i) {
        if (max < mls[i]) {
            max = mls[i];
        }
    }
    return max;
}


","#include<iostream>
#include <vector>
#include <cmath>
#include <cassert>
using namespace std;

int max_len_sub(vector<int> arr, int n) {
    vector<int> mls(n, 1);
    int max = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (abs(arr[i] - arr[j]) <= 1 && mls[i] < mls[j] + 1) {
                mls[i] = mls[j] + 1;
            }
        }
    }
    for (int i = 0; i < n; ++i) {
        if (mls[i] > max) {
            max = mls[i];
        }
    }
    return max;
}
","#include<iostream>
#include <vector>
#include <cmath>
#include <cassert>
using namespace std;
int max_len_sub(vector<int> arr, int n) {
    vector<int> mls(n, 1);
    int max = 0;
    for (int i = 0; i < n; i = i + 1) {
        for (int j = 0; j < i; j = j + 1) {
            if (abs(arr[i] - arr[j]) <= 1 && mls[i] < mls[j] + 1) {
                mls[i] = mls[j] + 1;
            }
//begin to write code
","#include<iostream>
    

#include <vector>
#include <cmath>
#include <cassert>
using namespace std;

int max_len_sub(vector<int> arr, int n) {
    vector<int> mls(n, 1);
    int max = 0;
    for (int i = 0; i < n; i = i + 1) {
        for (int j = 0; j < i; j = j + 1) {
            if (abs(arr[i] - arr[j]) <= 1 && mls[i] < mls[j] + 1) {
                mls[i] = mls[j] + 1;
            }
        }
    }
    for (int i = 0; i < n; i = i + 1) {
        if (max < mls[i]) {
            max = mls[i];
        }
    }
    return max;
}


","
#include<iostream>
#include <vector>
#include <cmath>
#include <cassert>
using namespace std;

int max_len_sub(vector<int> arr, int n) {
    vector<int> mls(n, 1);
    int max = 0;
    for (int i = 0; i < n; i = i + 1) {
        for (int j = 0; j < i; j = j + 1) {
            if (abs(arr[i] - arr[j]) <= 1 && mls[i] < mls[j] + 1) {
                mls[i] = mls[j] + 1;
            }
        }
    }
    return max;
}

",1,3,0.4755542238553365,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'#include<iostream>\n    \n\n#include <vector>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nint max_len_sub(vector<int> arr, int n) {\n    vector<int> mls(n, 1);\n    int max = 0;\n    for (int i = 0; i < n; i = i + 1) {\n        for (int j = 0; j < i; j = j + 1) {\n            if (abs(arr[i] - arr[j]) <= 1 && mls[i] < mls[j] + 1) {\n                mls[i] = mls[j] + 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i = i + 1) {\n        if (max < mls[i]) {\n            max = mls[i];\n        }\n    }\n    return max;\n}\n\n\n': [('#include<iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nint max_len_sub(vector<int> arr, int n) {\n    vector<int> mls(n, 1);\n    int max = 0;\n    for (int i = 0; i < n; i = i + 1) {\n        for (int j = 0; j < i; j = j + 1) {\n            if (abs(arr[i] - arr[j]) <= 1 && mls[i] < mls[j] + 1) {\n                mls[i] = mls[j] + 1;\n            }\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nint max_len_sub(vector<int> arr, int n) {\n    vector<int> mls(n, 1);\n    int max = 0;\n    for (int i = 0; i < n; i = i + 1) {\n        for (int j = 0; j < i; j = j + 1) {\n            if (abs(arr[i] - arr[j]) <= 1 && mls[i] < mls[j] + 1) {\n                mls[i] = mls[j] + 1;\n            }\n        }\n    }\n    return max;\n}\n\n', 'equal_expression_transformation')]}"
50,"#include <iostream>
#include <unordered_map>
#include <cassert>
int count_Substrings(const std::string& s, int n) {
    int count = 0, sum = 0;
    std::unordered_map<int, int> mp;
    mp[0] = 1;
    for (int i = 0; i < n; ++i) {
        sum += s[i] - '0';
//begin to write code
",279,"
#include <iostream>
#include <unordered_map>
#include <cassert>

int count_Substrings(const std::string& s, int n) {
    int count = 0, sum = 0;
    std::unordered_map<int, int> mp;
    mp[0] = 1;
    for (int i = 0; i < n; ++i) {
        sum += s[i] - '0';
        int key = sum - (i + 1);
        count += mp[key];
        mp[key]++;
    }
    return count;
}


","using namespace std;
#include <unordered_map>
#include <cassert>

int count_Substrings(const std::string& s, int n) {
    int count = 0, sum = 0;
    std::unordered_map<int, int> mp;
    mp[0] = 1;
    for (int i = 0; i < n; ++i) {
        sum += s[i] - '0';
        if (mp.find(sum)!= mp.end()) {
            count += mp[sum];
        }
        mp[sum]++;
    }
    return count;
}
",,,,-2,1,0.18210058609644572,code_expression_exchange:None,0.0,0.0,
51,"#include<iostream>
#include <algorithm>
#include <vector>
#include <cassert>
int smallest_num(std::vector<int> xs) {
//begin to write code
",139,"#include<iostream>
    

#include <algorithm>
#include <vector>
#include <cassert>

int smallest_num(std::vector<int> xs) {
    return *std::min_element(xs.begin(), xs.end());
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<assert.h>

int smallest_num(std::vector<int> xs) {
    if (xs.empty()) {
        throw std::invalid_argument(""The vector is empty."");
    }

    int min = xs[0];
    for (int num : xs) {
        if (num < min) {
            min = num;
        }
    }
    return min;
}
","#include<iostream>
#include <algorithm>
#include <vector>
#include <cassert>
int smallest_num(std::vector<int> xs) {
//begin to write code
","#include<iostream>
    

#include <algorithm>
#include <vector>
#include <cassert>

int smallest_num(std::vector<int> xs) {
    return *std::min_element(xs.begin(), xs.end());
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<vector>
#include<stdio.h>
#include<string>
#include<iostream>

int smallest_num(std::vector<int> xs) {
    if (xs.empty()) {
        throw std::invalid_argument(""The vector is empty."");
    }
    int min = xs[0];
    for (int num : xs) {
        if (num < min) {
            min = num;
        }
    }
    return min;
}
",1,3,0.4307936628659566,code_expression_exchange:bool2int,1.0,0.0,"{'#include<iostream>\n    \n\n#include <algorithm>\n#include <vector>\n#include <cassert>\n\nint smallest_num(std::vector<int> xs) {\n    return *std::min_element(xs.begin(), xs.end());\n}\n\n\n': [('#include<iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nint smallest_num(std::vector<int> xs) {\n//begin to write code\n', 'using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<vector>\n#include<stdio.h>\n#include<string>\n#include<iostream>\n\nint smallest_num(std::vector<int> xs) {\n    if (xs.empty()) {\n        throw std::invalid_argument(""The vector is empty."");\n    }\n    int min = xs[0];\n    for (int num : xs) {\n        if (num < min) {\n            min = num;\n        }\n    }\n    return min;\n}\n', 'bool2int')]}"
52,"#include<cassert>
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;
int max_difference(vector<pair<int, int>> test_list) {
    vector<int> temp;
    for (auto p : test_list) {
        temp.push_back(abs(p.second - p.first));
//begin to write code
",294,"#include<cassert>
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;

int max_difference(vector<pair<int, int>> test_list) {
    vector<int> temp;
    for (auto p : test_list) {
        temp.push_back(abs(p.second - p.first));
    }
    int res = *max_element(temp.begin(), temp.end());
    return res;
}


","#include<cassert>
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;

int max_difference(vector<pair<int, int>> test_list) {
    sort(test_list.begin(), test_list.end());
    int max_diff = 0;
    for (int i = 0; i < test_list.size() - 1; ++i) {
        int diff = abs(test_list[i].second - test_list[i + 1].second);
        if (diff > max_diff) {
            max_diff = diff;
        }
    }
    return max_diff;
}
",,,,-2,1,0.18692460457483928,code_expression_exchange:None,0.0,0.0,
53,"#include<iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;
vector<pair<string, int>> subject_marks(vector<pair<string, int>> subjectmarks) {
    sort(subjectmarks.begin(), subjectmarks.end(), [](const pair<string, int>& a, const pair<string, int>& b) {
        return a.second < b.second;
//begin to write code
",368,"#include<iostream>
    

#include <vector>
#include <string>
#include <algorithm>
#include <cassert>

using namespace std;

vector<pair<string, int>> subject_marks(vector<pair<string, int>> subjectmarks) {
    sort(subjectmarks.begin(), subjectmarks.end(), [](const pair<string, int>& a, const pair<string, int>& b) {
        return a.second < b.second;
    });
    return subjectmarks;
}


","#include<iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;

vector<pair<string, int>> subject_marks(vector<pair<string, int>> subjectmarks) {
    sort(subjectmarks.begin(), subjectmarks.end(), [](const pair<string, int>& a, const pair<string, int>& b) {
        return a.second < b.second;
    });
    return subjectmarks;
}
","#include<iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;
vector<pair<string, int>> subject_marks(vector<pair<string, long>> subjectmarks) {
    sort(subjectmarks.begin(), subjectmarks.end(), [](const pair<string, int>& a, const pair<string, int>& b) {
        return a.second < b.second;
//begin to write code
","#include<iostream>
    

#include <vector>
#include <string>
#include <algorithm>
#include <cassert>

using namespace std;

vector<pair<string, int>> subject_marks(vector<pair<string, long>> subjectmarks) {
    sort(subjectmarks.begin(), subjectmarks.end(), [](const pair<string, int>& a, const pair<string, int>& b) {
        return a.second < b.second;
    });
    return subjectmarks;
}


","#include<iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;

vector<pair<string, int>> subject_marks(vector<pair<string, long>> subjectmarks) {
    sort(subjectmarks.begin(), subjectmarks.end(), [](const pair<string, int>& a, const pair<string, int>& b) {
        return a.second < b.second;
    });
    return subjectmarks;
}
",1,5,0.6352068463961283,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<iostream>\n    \n\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nvector<pair<string, int>> subject_marks(vector<pair<string, long>> subjectmarks) {\n    sort(subjectmarks.begin(), subjectmarks.end(), [](const pair<string, int>& a, const pair<string, int>& b) {\n        return a.second < b.second;\n    });\n    return subjectmarks;\n}\n\n\n': [('#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nvector<pair<string, int>> subject_marks(vector<pair<string, int>> subjectmarks) {\n    sort(subjectmarks.begin(), subjectmarks.end(), [](const pair<string, int>& a, const pair<string, int>& b) {\n        return a.second < b.second;\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<pair<string, int>> subject_marks(vector<pair<string, int>> subjectmarks) {\n    sort(subjectmarks.begin(), subjectmarks.end(), [](const pair<string, int>& a, const pair<string, int>& b) {\n        return a.second < b.second;\n    });\n    return subjectmarks;\n}\n\n', 'bool2int'), ('#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nvector<pair<string, int>> subject_marks(vector<pair<string, long>> subjectmarks) {\n    sort(subjectmarks.begin(), subjectmarks.end(), [](const pair<string, int>& a, const pair<string, int>& b) {\n        return a.second < b.second;\n//begin to write code\n', '#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<pair<string, int>> subject_marks(vector<pair<string, long>> subjectmarks) {\n    sort(subjectmarks.begin(), subjectmarks.end(), [](const pair<string, int>& a, const pair<string, int>& b) {\n        return a.second < b.second;\n    });\n    return subjectmarks;\n}\n', 'more_universe_var_type')]}"
54,"#include <iostream>
#include <vector>
#include <cassert>
#include <typeinfo>
#include <type_traits>
using namespace std;
class Any {
public:
    Any() : content(nullptr) {}
    template<typename T>
    Any(const T& value) : content(new Holder<T>(value)) {}
    Any(const Any& other) : content(other.content ? other.content->clone() : nullptr) {}
    ~Any() { delete content; }
    Any& operator=(const Any& other) {
        if (this != &other) {
            delete content;
            content = other.content ? other.content->clone() : nullptr;
        }
        return *this;
    }
    template<typename T>
    T& cast() {
        return static_cast<Holder<T>*>(content)->held;
    }
    template<typename T>
    const T& cast() const {
        return static_cast<const Holder<T>*>(content)->held;
    }
    const type_info& type() const {
        return content ? content->type() : typeid(void);
    }
private:
    struct Placeholder {
//begin to write code
",961,"#include <iostream>
#include <vector>
#include <cassert>
#include <typeinfo>
#include <type_traits>

using namespace std;

class Any {
public:
    Any() : content(nullptr) {}

    template<typename T>
    Any(const T& value) : content(new Holder<T>(value)) {}

    Any(const Any& other) : content(other.content ? other.content->clone() : nullptr) {}

    ~Any() { delete content; }

    Any& operator=(const Any& other) {
        if (this != &other) {
            delete content;
            content = other.content ? other.content->clone() : nullptr;
        }
        return *this;
    }

    template<typename T>
    T& cast() {
        return static_cast<Holder<T>*>(content)->held;
    }

    template<typename T>
    const T& cast() const {
        return static_cast<const Holder<T>*>(content)->held;
    }

    const type_info& type() const {
        return content ? content->type() : typeid(void);
    }

private:
    struct Placeholder {
        virtual ~Placeholder() {}
        virtual const type_info& type() const = 0;
        virtual Placeholder* clone() const = 0;
    };

    template<typename T>
    struct Holder : Placeholder {
        Holder(const T& value) : held(value) {}
        const type_info& type() const override {
            return typeid(T);
        }
        Placeholder* clone() const override {
            return new Holder(held);
        }
        T held;
    };

    Placeholder* content;
};

int recursive_list_sum(const vector<Any>& data_list) {
    int total = 0;
    for (const auto& element : data_list) {
        if (element.type() == typeid(vector<Any>)) {
            total += recursive_list_sum(element.cast<vector<Any>>());
        } else {
            total += element.cast<int>();
        }
    }
    return total;
}","
#include <iostream>
#include <vector>
#include <cassert>
#include <typeinfo>
#include <type_traits>
using namespace std;

class Any {
public:
    Any() : content(nullptr) {}
    template<typename T>
    Any(const T& value) : content(new Holder<T>(value)) {}
    Any(const Any& other) : content(other.content? other.content->clone() : nullptr) {}
    ~Any() { delete content; }
    Any& operator=(const Any& other) {
        if (this!= &other) {
            delete content;
            content = other.content? other.content->clone() : nullptr;
        }
        return *this;
    }
    template<typename T>
    T& cast() {
        return static_cast<Holder<T>*>(content)->held;
    }
    template<typename T>
    const T& cast() const {
        return static_cast<const Holder<T>*>(content)->held;
    }
    const type_info& type() const {
        return content? content->type() : typeid(void);
    }
private:
    struct Placeholder {
        //begin to write code
    };
};

",,,,-2,1,0.22521348396937052,code_expression_exchange:None,0.0,0.0,
55,"#include <iostream>
#include <vector>
#include <cassert>
int pos_count(const std::vector<int>& list) {
    int pos_count = 0;
    for (int num : list) {
        if (num >= 0) {
//begin to write code
",199,"
#include <iostream>
#include <vector>
#include <cassert>

int pos_count(const std::vector<int>& list) {
    int pos_count = 0;
    for (int num : list) {
        if (num >= 0) {
            pos_count++;
        }
    }
    return pos_count;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <cassert>

int pos_count(const std::vector<int>& list) {
    int pos_count = 0;
    for (int num : list) {
        if (num >= 0) {
            ++pos_count;
        }
    }
    return pos_count;
}

","#include <iostream>
#include <vector>
#include <cassert>
long pos_count(const std::vector<long>& list) {
    int pos_count = 0;
    for (long num : list) {
        if (num >= 0) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

long pos_count(const std::vector<long>& list) {
    int pos_count = 0;
    for (long num : list) {
        if (num >= 0) {
            pos_count = 1 + pos_count;
        }
    }
    return pos_count;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

long pos_count(const std::vector<long>& list) {
    int pos_count = 0;
    for (long num : list) {
        if (num >= 0) {
            pos_count++;
        }
    }
    return pos_count;
}

",-1,21,2.6089113036791485,code_expression_exchange:more_universe_var_type,1.0,0.846468856326098,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong pos_count(const std::vector<long>& list) {\n    int pos_count = 0;\n    for (long num : list) {\n        if (num >= 0) {\n            pos_count = 1 + pos_count;\n        }\n    }\n    return pos_count;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nint pos_count(const std::vector<int>& list) {\n    int pos_count = 0;\n    for (int num : list) {\n        if (num >= 0) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint pos_count(const std::vector<int>& list) {\n    int pos_count = 0;\n    for (int num : list) {\n        if (num >= 0) {\n            ++pos_count;\n        }\n    }\n    return pos_count;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong pos_count(const std::vector<int>& list) {\n    int pos_count = 0;\n    for (int num : list) {\n        if (num >= 0) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong pos_count(const std::vector<int>& list) {\n    int pos_count = 0;\n    for (int num : list) {\n        if (num >= 0) {\n            ++pos_count;\n        }\n    }\n    return pos_count;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong pos_count(const std::vector<int>& list) {\n    int pos_count = 0;\n    for (long num : list) {\n        if (num >= 0) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong pos_count(const std::vector<int>& list) {\n    long pos_count = 0;\n    for (long num : list) {\n        if (num >= 0) {\n            pos_count++;\n        }\n    }\n    return pos_count;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong pos_count(const std::vector<int>& list) {\n    int pos_count = 0;\n    for (long num : list) {\n        if (num >= 0) {\n//begin to write code\n', '\nusing namespace std;\n#include <vector>\n#include <cassert>\n\nlong pos_count(const std::vector<int>& list) {\n    long pos_count = 0;\n    for (long num : list) {\n        if (num >= 0) {\n            ++pos_count;\n        }\n    }\n    return pos_count;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong pos_count(const std::vector<int>& list) {\n    int pos_count = 0;\n    for (long num : list) {\n        if (num >= 0) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong pos_count(const std::vector<int>& list) {\n    long pos_count = 0;\n    for (long num : list) {\n        if (num >= 0) {\n            pos_count++;\n        }\n    }\n    return pos_count;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong pos_count(const std::vector<int>& list) {\n    int pos_count = 0;\n    for (long num : list) {\n        if (num >= 0) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong pos_count(const std::vector<int>& list) {\n    int pos_count = 0;\n    for (long num : list) {\n        if (num >= 0) {\n            pos_count++;\n        }\n    }\n    return pos_count;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong pos_count(const std::vector<int>& list) {\n    int pos_count = 0;\n    for (long num : list) {\n        if (num >= 0) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong pos_count(const std::vector<int>& list) {\n    long pos_count = 0;\n    for (long num : list) {\n        if (num >= 0) {\n            pos_count++;\n        }\n    }\n    return pos_count;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong pos_count(const std::vector<int>& list) {\n    int pos_count = 0;\n    for (long num : list) {\n        if (num >= 0) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong pos_count(const std::vector<int>& list) {\n    long pos_count = 0;\n    for (long num : list) {\n        if (num >= 0) {\n            pos_count++;\n        }\n    }\n    return pos_count;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong pos_count(const std::vector<int>& list) {\n    int pos_count = 0;\n    for (long num : list) {\n        if (num >= 0) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong pos_count(const std::vector<int>& list) {\n    long pos_count = 0;\n    for (long num : list) {\n        if (num >= 0) {\n            ++pos_count;\n        }\n    }\n    return pos_count;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong pos_count(const std::vector<long>& list) {\n    int pos_count = 0;\n    for (long num : list) {\n        if (num >= 0) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong pos_count(const std::vector<long>& list) {\n    int pos_count = 0;\n    for (long num : list) {\n        if (num >= 0) {\n            pos_count++;\n        }\n    }\n    return pos_count;\n}\n\n', 'more_universe_var_type')]}"
56,"#include<iostream>
#include <vector>
#include <cassert>
using namespace std;
unsigned long long bell_number(int n) {
    vector<vector<unsigned long long>> bell(n+1, vector<unsigned long long>(n+1, 0));
    bell[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        bell[i][0] = bell[i-1][i-1];
//begin to write code
",317,"#include<iostream>
    

#include <vector>
#include <cassert>

using namespace std;

unsigned long long bell_number(int n) {
    vector<vector<unsigned long long>> bell(n+1, vector<unsigned long long>(n+1, 0));
    bell[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        bell[i][0] = bell[i-1][i-1];
        for (int j = 1; j <= i; ++j) {
            bell[i][j] = bell[i-1][j-1] + bell[i][j-1];
        }
    }
    return bell[n][0];
}


","
#include<iostream>
#include <vector>
#include <cassert>
using namespace std;

unsigned long long bell_number(int n) {
    vector<vector<unsigned long long>> bell(n+1, vector<unsigned long long>(n+1, 0));
    bell[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        bell[i][0] = bell[i-1][i-1];
    }
    return bell[n][n];
}

",,,,-2,1,0.21005651156107585,code_expression_exchange:None,0.0,0.0,
57,"#include<iostream>
#include <vector>
#include <cassert>
bool is_Monotonic(std::vector<int> A) {
    bool increasing = true;
    bool decreasing = true;
    for (int i = 0; i < A.size() - 1; ++i) {
//begin to write code
",219,"#include<iostream>
    

#include <vector>
#include <cassert>

bool is_Monotonic(std::vector<int> A) {
    bool increasing = true;
    bool decreasing = true;
    for (int i = 0; i < A.size() - 1; ++i) {
        if (A[i] > A[i + 1]) increasing = false;
        if (A[i] < A[i + 1]) decreasing = false;
    }
    return increasing || decreasing;
}


","
#include <iostream>
#include <vector>
#include <cassert>

bool is_Monotonic(std::vector<int> A) {
    if (A.empty()) {
        return true;
    }

    bool increasing = true;
    bool decreasing = true;

    for (int i = 1; i < A.size(); ++i) {
        if (A[i] > A[i - 1]) {
            decreasing = false;
        } else if (A[i] < A[i - 1]) {
            increasing = false;
        }
    }

    return increasing || decreasing;
}

","#include<iostream>
#include <vector>
#include <cassert>
bool is_Monotonic(std::vector<int> A) {
    bool increasing = 1;
    bool decreasing = 1;
    for (int i = 0; i < A.size() - 1; ++i) {
//begin to write code
","#include<iostream>
    

#include <vector>
#include <cassert>

bool is_Monotonic(std::vector<int> A) {
    bool increasing = 1;
    bool decreasing = 1;
    for (int i = 0; i < A.size() - 1; ++i) {
        if (A[i] > A[i + 1]) increasing = 0;
        if (A[i] < A[i + 1]) decreasing = 0;
    }
    return increasing || decreasing;
}


","
using namespace std;

#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

bool is_Monotonic(std::vector<int> A) {
    bool increasing = 1;
    bool decreasing = 1;
    for (int i = 0; i < A.size() - 1; ++i) {
        if (A[i] > A[i + 1]) {
            decreasing = 0;
        }
        if (A[i] < A[i + 1]) {
            increasing = 0;
        }
    }
    return increasing || decreasing;
}

",1,3,0.48701610962549846,code_expression_exchange:bool2int,1.0,0.0,"{'#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\n\nbool is_Monotonic(std::vector<int> A) {\n    bool increasing = 1;\n    bool decreasing = 1;\n    for (int i = 0; i < A.size() - 1; ++i) {\n        if (A[i] > A[i + 1]) increasing = 0;\n        if (A[i] < A[i + 1]) decreasing = 0;\n    }\n    return increasing || decreasing;\n}\n\n\n': [('#include<iostream>\n#include <vector>\n#include <cassert>\nbool is_Monotonic(std::vector<int> A) {\n    bool increasing = 1;\n    bool decreasing = 1;\n    for (int i = 0; i < A.size() - 1; ++i) {\n//begin to write code\n', '\nusing namespace std;\n\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\nbool is_Monotonic(std::vector<int> A) {\n    bool increasing = 1;\n    bool decreasing = 1;\n    for (int i = 0; i < A.size() - 1; ++i) {\n        if (A[i] > A[i + 1]) {\n            decreasing = 0;\n        }\n        if (A[i] < A[i + 1]) {\n            increasing = 0;\n        }\n    }\n    return increasing || decreasing;\n}\n\n', 'bool2int')]}"
58,"#include <iostream>
#include <vector>
#include <cassert>
bool is_sublist(const std::vector<int>& l, const std::vector<int>& s) {
    bool sub_set = false;
    if (s.empty()) {
        sub_set = true;
    } else if (s == l) {
        sub_set = true;
    } else if (s.size() > l.size()) {
        sub_set = false;
    } else {
        for (size_t i = 0; i <= l.size() - s.size(); i++) {
            if (l[i] == s[0]) {
//begin to write code
",439,"
#include <iostream>
#include <vector>
#include <cassert>

bool is_sublist(const std::vector<int>& l, const std::vector<int>& s) {
    bool sub_set = false;
    if (s.empty()) {
        sub_set = true;
    } else if (s == l) {
        sub_set = true;
    } else if (s.size() > l.size()) {
        sub_set = false;
    } else {
        for (size_t i = 0; i <= l.size() - s.size(); i++) {
            if (l[i] == s[0]) {
                size_t n = 1;
                while (n < s.size() && l[i + n] == s[n]) {
                    n++;
                }
                if (n == s.size()) {
                    sub_set = true;
                }
            }
        }
    }
    return sub_set;
}


","#include <iostream>
#include <vector>
#include <cassert>

bool is_sublist(const std::vector<int>& l, const std::vector<int>& s) {
    if (s.empty()) {
        return true;
    } else if (s == l) {
        return true;
    } else if (s.size() > l.size()) {
        return false;
    }

    for (size_t i = 0; i <= l.size() - s.size(); i++) {
        if (l[i] == s[0]) {
            // Begin to write code here
            return true;
        }
    }
    return false;
}
",,,,-2,1,0.1915994644165039,code_expression_exchange:None,0.0,0.0,
59,"#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
bool find_equal_tuple(const vector<vector<int>>& input, int k) {
    for (const auto& tuple : input) {
        if (tuple.size() != k) {
            return false;
        }
    }
    return true;
//begin to write code
",295,"
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

bool find_equal_tuple(const vector<vector<int>>& input, int k) {
    for (const auto& tuple : input) {
        if (tuple.size() != k) {
            return false;
        }
    }
    return true;
}

string get_equal(const vector<vector<int>>& input, int k) {
    if (find_equal_tuple(input, k)) {
        return ""All tuples have same length"";
    } else {
        return ""All tuples do not have same length"";
    }
}


","
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

bool find_equal_tuple(const vector<vector<int>>& input, int k) {
    for (const auto& tuple : input) {
        if (tuple.size()!= k) {
            return false;
        }
    }
    return true;
}

",,,,-2,1,0.216166353225708,code_expression_exchange:None,0.0,0.0,
60,"#include <vector>
#include <iostream>
#include <cassert>
std::vector<int> comb_sort(std::vector<int>& nums) {
    float shrink_fact = 1.3;
    int gaps = nums.size(), i;
    bool swapped = true;
    while (gaps > 1 || swapped) {
        gaps = int(float(gaps) / shrink_fact);
        swapped = false;
        i = 0;
        while (gaps + i < nums.size()) {
//begin to write code
",379,"
#include <vector>
#include <iostream>
#include <cassert>

std::vector<int> comb_sort(std::vector<int>& nums) {
    float shrink_fact = 1.3;
    int gaps = nums.size(), i;
    bool swapped = true;
    
    while (gaps > 1 || swapped) {
        gaps = int(float(gaps) / shrink_fact);
        swapped = false;
        i = 0;
        while (gaps + i < nums.size()) {
            if (nums[i] > nums[i + gaps]) {
                std::swap(nums[i], nums[i + gaps]);
                swapped = true;
            }
            i++;
        }
    }
    return nums;
}


","
#include <vector>
#include <iostream>
#include <cassert>

std::vector<int> comb_sort(std::vector<int>& nums) {
    float shrink_fact = 1.3;
    int gaps = nums.size(), i;
    bool swapped = true;
    while (gaps > 1 || swapped) {
        gaps = int(float(gaps) / shrink_fact);
        swapped = false;
        i = 0;
        while (gaps + i < nums.size()) {
            if (nums[i] > nums[i + gaps]) {
                std::swap(nums[i], nums[i + gaps]);
                swapped = true;
            }
            i++;
        }
    }
    return nums;
}

","#include <vector>
#include <iostream>
#include <cassert>
std::vector<int> comb_sort(std::vector<long>& nums) {
    float shrink_fact = 1.3;
    int gaps = nums.size(), i;
    bool swapped = true;
    while (gaps > 1 || swapped) {
        gaps = int(float(gaps) / shrink_fact);
        swapped = false;
        i = 0;
        while (gaps + i < nums.size()) {
//begin to write code
","
#include <vector>
#include <iostream>
#include <cassert>

std::vector<int> comb_sort(std::vector<long>& nums) {
    float shrink_fact = 1.3;
    int gaps = nums.size(), i;
    bool swapped = true;
    
    while (gaps > 1 || swapped) {
        gaps = int(float(gaps) / shrink_fact);
        swapped = false;
        i = 0;
        while (gaps + i < nums.size()) {
            if (nums[i] > nums[i + gaps]) {
                std::swap(nums[i], nums[i + gaps]);
                swapped = true;
            }
            i++;
        }
    }
    return nums;
}


","
using namespace std;
#include <vector>
#include <iostream>
#include <cassert>

std::vector<int> comb_sort(std::vector<long>& nums) {
    float shrink_fact = 1.3;
    int gaps = nums.size(), i;
    bool swapped = true;
    while (gaps > 1 || swapped) {
        gaps = int(float(gaps) / shrink_fact);
        swapped = false;
        i = 0;
        while (gaps + i < nums.size()) {
            if (nums[i] > nums[i + gaps]) {
                // Swap elements
                std::swap(nums[i], nums[i + gaps]);
                swapped = true;
            }
            i++;
        }
    }
    return nums;
}

",1,11,1.5309255957603454,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <vector>\n#include <iostream>\n#include <cassert>\n\nstd::vector<int> comb_sort(std::vector<long>& nums) {\n    float shrink_fact = 1.3;\n    int gaps = nums.size(), i;\n    bool swapped = true;\n    \n    while (gaps > 1 || swapped) {\n        gaps = int(float(gaps) / shrink_fact);\n        swapped = false;\n        i = 0;\n        while (gaps + i < nums.size()) {\n            if (nums[i] > nums[i + gaps]) {\n                std::swap(nums[i], nums[i + gaps]);\n                swapped = true;\n            }\n            i++;\n        }\n    }\n    return nums;\n}\n\n\n': [('#include <vector>\n#include <iostream>\n#include <cassert>\nstd::vector<int> comb_sort(std::vector<int>& nums) {\n    float shrink_fact = 1.3;\n    int gaps = nums.size(), i;\n    bool swapped = true;\n    while (gaps > 1 || swapped) {\n        gaps = int(float(gaps) / shrink_fact);\n        swapped = false;\n        i = 0;\n        while (gaps + i < nums.size()) {\n//begin to write code\n', '\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <algorithm>\n\nstd::vector<int> comb_sort(std::vector<int>& nums) {\n    float shrink_fact = 1.3;\n    int gaps = nums.size(), i;\n    bool swapped = true;\n    while (gaps > 1 || swapped) {\n        gaps = int(float(gaps) / shrink_fact);\n        swapped = false;\n        i = 0;\n        while (gaps + i < nums.size()) {\n            if (nums[i] > nums[i + gaps]) {\n                std::swap(nums[i], nums[i + gaps]);\n                swapped = true;\n            }\n            i++;\n        }\n    }\n    return nums;\n}\n\n', 'equal_expression_transformation'), ('#include <vector>\n#include <iostream>\n#include <cassert>\nstd::vector<int> comb_sort(std::vector<int>& nums) {\n    float shrink_fact = 1.3;\n    int gaps = nums.size(), i;\n    bool swapped = true;\n    while (gaps > 1 || swapped) {\n        gaps = int(float(gaps) / shrink_fact);\n        swapped = false;\n        i = 0;\n        while (gaps + i < nums.size()) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n\nstd::vector<int> comb_sort(std::vector<int>& nums) {\n    float shrink_fact = 1.3;\n    int gaps = nums.size(), i;\n    bool swapped = true;\n    while (gaps > 1 || swapped) {\n        gaps = int(float(gaps) / shrink_fact);\n        swapped = false;\n        i = 0;\n        while (gaps + i < nums.size()) {\n            if (nums[i] > nums[i + gaps]) {\n                std::swap(nums[i], nums[i + gaps]);\n                swapped = true;\n            }\n            i++;\n        }\n    }\n    return nums;\n}\n\n', 'equal_expression_transformation'), ('#include <vector>\n#include <iostream>\n#include <cassert>\nstd::vector<int> comb_sort(std::vector<int>& nums) {\n    float shrink_fact = 1.3;\n    int gaps = nums.size(), i;\n    bool swapped = true;\n    while (gaps > 1 || swapped) {\n        gaps = int(float(gaps) / shrink_fact);\n        swapped = false;\n        i = 0;\n        while (gaps + i < nums.size()) {\n//begin to write code\n', '\n#include <vector>\n#include <iostream>\n#include <cassert>\n\nstd::vector<int> comb_sort(std::vector<int>& nums) {\n    float shrink_fact = 1.3;\n    int gaps = nums.size(), i;\n    bool swapped = true;\n    while (gaps > 1 || swapped) {\n        gaps = int(float(gaps) / shrink_fact);\n        swapped = false;\n        i = 0;\n        while (gaps + i < nums.size()) {\n            if (nums[i] > nums[i + gaps]) {\n                std::swap(nums[i], nums[i + gaps]);\n                swapped = true;\n            }\n            ++i;\n        }\n    }\n    return nums;\n}\n\n', 'equal_expression_transformation'), ('#include <vector>\n#include <iostream>\n#include <cassert>\nstd::vector<int> comb_sort(std::vector<int>& nums) {\n    float shrink_fact = 1.3;\n    int gaps = nums.size(), i;\n    bool swapped = true;\n    while (gaps > 1 || swapped) {\n        gaps = int(float(gaps) / shrink_fact);\n        swapped = false;\n        i = 0;\n        while (gaps + i < nums.size()) {\n//begin to write code\n', '\n#include <vector>\n#include <iostream>\n#include <cassert>\n\nstd::vector<int> comb_sort(std::vector<int>& nums) {\n    float shrink_fact = 1.3;\n    int gaps = nums.size(), i;\n    bool swapped = true;\n    while (gaps > 1 || swapped) {\n        gaps = int(float(gaps) / shrink_fact);\n        swapped = false;\n        i = 0;\n        while (gaps + i < nums.size()) {\n            if (nums[i] > nums[i + gaps]) {\n                std::swap(nums[i], nums[i + gaps]);\n                swapped = true;\n            }\n            i++;\n        }\n    }\n    return nums;\n}\n\n', 'exchange_operators'), ('#include <vector>\n#include <iostream>\n#include <cassert>\nstd::vector<int> comb_sort(std::vector<long>& nums) {\n    float shrink_fact = 1.3;\n    int gaps = nums.size(), i;\n    bool swapped = true;\n    while (gaps > 1 || swapped) {\n        gaps = int(float(gaps) / shrink_fact);\n        swapped = false;\n        i = 0;\n        while (gaps + i < nums.size()) {\n//begin to write code\n', '\nusing namespace std;\n#include <vector>\n#include <iostream>\n#include <cassert>\n\nstd::vector<int> comb_sort(std::vector<long>& nums) {\n    float shrink_fact = 1.3;\n    int gaps = nums.size(), i;\n    bool swapped = true;\n    while (gaps > 1 || swapped) {\n        gaps = int(float(gaps) / shrink_fact);\n        swapped = false;\n        i = 0;\n        while (gaps + i < nums.size()) {\n            if (nums[i] > nums[i + gaps]) {\n                // Swap elements\n                std::swap(nums[i], nums[i + gaps]);\n                swapped = true;\n            }\n            i++;\n        }\n    }\n    return nums;\n}\n\n', 'more_universe_var_type')]}"
61,"#include <iostream>
#include <cassert>
bool dif_Square(int n) {
    if (n % 4 != 2) {
        return true;
//begin to write code
",129,"
#include <iostream>
#include <cassert>

bool dif_Square(int n) {
    if (n % 4 != 2) {
        return true;
    }
    return false;
}


","
using namespace std;

#include <iostream>
#include <cassert>

bool dif_Square(int n) {
    if (n % 4!= 2) {
        return true;
    }
    // Your code here
}

",,,,-2,1,0.23292682965596517,code_expression_exchange:None,0.0,0.0,
62,"#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <cassert>
using namespace std;
vector<string> multiple_split(const string& text) {
    regex delimiter(R""(;\s|,\s|\*|\\n)"");
    vector<string> result;
    sregex_token_iterator iter(text.begin(), text.end(), delimiter, -1);
    sregex_token_iterator end;
//begin to write code
",360,"#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <cassert>

using namespace std;

vector<string> multiple_split(const string& text) {
    regex delimiter(R""(;\s|,\s|\*|\\n)"");
    vector<string> result;
    sregex_token_iterator iter(text.begin(), text.end(), delimiter, -1);
    sregex_token_iterator end;
    while(iter != end) {
        result.push_back(*iter++);
    }
    return result;
}","
#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <cassert>
using namespace std;

vector<string> multiple_split(const string& text) {
    regex delimiter(R""(;\s|,\s|\*|\
)"");
    vector<string> result;
    sregex_token_iterator iter(text.begin(), text.end(), delimiter, -1);
    while (iter!= end) {
        result.push_back(*iter);
        ++iter;
    }
    return result;
}

",,,,-2,1,0.24004896879196166,code_expression_exchange:None,0.0,0.0,
63,"#include<cassert>
#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <string>
bool is_samepatterns(std::vector<std::string> colors, std::vector<std::string> patterns) {
    if (colors.size() != patterns.size()) {
        return false;
    }
    std::map<std::string, std::vector<std::string>> sdict;
    std::set<std::string> pset;
    std::set<std::string> sset;
    for (size_t i = 0; i < patterns.size(); ++i) {
        pset.insert(patterns[i]);
        sset.insert(colors[i]);
        sdict[patterns[i]].push_back(colors[i]);
    }
//begin to write code
",584,"#include<cassert>
#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <string>

bool is_samepatterns(std::vector<std::string> colors, std::vector<std::string> patterns) {
    if (colors.size() != patterns.size()) {
        return false;
    }

    std::map<std::string, std::vector<std::string>> sdict;
    std::set<std::string> pset;
    std::set<std::string> sset;

    for (size_t i = 0; i < patterns.size(); ++i) {
        pset.insert(patterns[i]);
        sset.insert(colors[i]);
        sdict[patterns[i]].push_back(colors[i]);
    }

    if (pset.size() != sset.size()) {
        return false;
    }

    for (auto& key_value : sdict) {
        std::vector<std::string>& values = key_value.second;
        for (size_t i = 0; i < values.size() - 1; ++i) {
            if (values[i] != values[i+1]) {
                return false;
            }
        }
    }

    return true;
}


","#include <cassert>
#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <string>
#include <sstream>

bool is_samepatterns(std::vector<std::string> colors, std::vector<std::string> patterns) {
    if (colors.size()!= patterns.size()) {
        return false;
    }
    std::map<std::string, std::vector<std::string>> sdict;
    std::set<std::string> pset;
    std::set<std::string> sset;
    for (size_t i = 0; i < patterns.size(); ++i) {
        pset.insert(patterns[i]);
        sset.insert(colors[i]);
        sdict[patterns[i]].push_back(colors[i]);
    }
    for (const auto& pair : sdict) {
        if (pair.second.size()!= colors.size()) {
            return false;
        }
        for (size_t j = 0; j < pair.second.size(); ++j) {
            if (!colors[j].compare(pair.second[j])) {
                return false;
            }
        }
    }
    return true;
}
",,,,-2,1,0.2295690059661865,code_expression_exchange:None,0.0,0.0,
64,"#include <iostream>
#include <vector>
#include <sstream>
#include <cassert>
std::string find_tuples(const std::vector<std::vector<int>>& test_list, int K) {
    std::vector<std::vector<int>> res;
    for (const auto& sub : test_list) {
        bool all_divisible = true;
        for (int ele : sub) {
            if (ele % K != 0) {
                all_divisible = false;
                break;
            }
        }
        if (all_divisible) {
            res.push_back(sub);
        }
    }
//begin to write code
",518,"
#include <iostream>
#include <vector>
#include <sstream>
#include <cassert>

std::string find_tuples(const std::vector<std::vector<int>>& test_list, int K) {
    std::vector<std::vector<int>> res;
    for (const auto& sub : test_list) {
        bool all_divisible = true;
        for (int ele : sub) {
            if (ele % K != 0) {
                all_divisible = false;
                break;
            }
        }
        if (all_divisible) {
            res.push_back(sub);
        }
    }
    std::ostringstream stream;
    stream << ""["";
    for (size_t i = 0; i < res.size(); ++i) {
        stream << ""("";
        for (size_t j = 0; j < res[i].size(); ++j) {
            stream << res[i][j];
            if (j < res[i].size() - 1) stream << "", "";
        }
        stream << "")"";
        if (i < res.size() - 1) stream << "", "";
    }
    stream << ""]"";
    return stream.str();
}


","#include <iostream>
#include <vector>
#include <sstream>
#include <cassert>
std::string find_tuples(const std::vector<std::vector<int>>& test_list, int K) {
    std::vector<std::vector<int>> res;
    for (const auto& sub : test_list) {
        bool all_divisible = true;
        for (int ele : sub) {
            if (ele % K!= 0) {
                all_divisible = false;
                break;
            }
        }
        if (all_divisible) {
            res.push_back(sub);
        }
    }
    return std::to_string(res.size());
}
",,,,-2,1,0.18541996479034423,code_expression_exchange:None,0.0,0.0,
65,"#include <iostream>
#include <cassert>
double count_Squares(int m, int n) {
    if (n < m) {
        int temp = m;
        m = n;
//begin to write code
",152,"
#include <iostream>
#include <cassert>

double count_Squares(int m, int n) {
    if (n < m) {
        int temp = m;
        m = n;
        n = temp;
    }
    return ((m * (m + 1) * (2 * m + 1) / 6.0) + (n - m) * m * (m + 1) / 2.0);
}


","
using namespace std;

#include <iostream>
#include <cassert>

double count_Squares(int m, int n) {
    if (n < m) {
        int temp = m;
        m = n;
    }
    double sum = 0;
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            sum += i * i + j * j;
        }
    }
    return sum;
}

",,,,-2,1,0.20352471669514974,code_expression_exchange:None,0.0,0.0,
66,"#include <iostream>
#include <cassert>
bool is_Diff(int n) {
//begin to write code
",83,"
#include <iostream>
#include <cassert>

bool is_Diff(int n) {
    return (n % 11 == 0);
}


","
#include <iostream>
#include <cassert>
bool is_Diff(int n) {
    int sum_even = 0;
    int sum_odd = 0;
    
    while (n > 0) {
        int digit = n % 10;
        if (digit % 2 == 0) {
            sum_even += digit;
        } else {
            sum_odd += digit;
        }
        n /= 10;
    }
    
    return sum_even - sum_odd;
}

",,,,-2,1,0.23637414773305257,code_expression_exchange:None,0.0,0.0,
67,"#include<cassert>
#include <iostream>
#include <bitset>
int countWithOddSetBits(int n) {
    if (n % 2 != 0) {
        return (n + 1) / 2;
    }
    int count = std::bitset<32>(n).count();
//begin to write code
",211,"#include<cassert>
#include <iostream>
#include <bitset>

int countWithOddSetBits(int n) {
    if (n % 2 != 0) {
        return (n + 1) / 2;
    }
    int count = std::bitset<32>(n).count();
    int ans = n / 2;
    if (count % 2 != 0) {
        ans += 1;
    }
    return ans;
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<cassert>
#include <iostream>
#include <bitset>

int countWithOddSetBits(int n) {
    if (n % 2!= 0) {
        return (n + 1) / 2;
    }
    int count = std::bitset<32>(n).count();
    return count;
}
",,,,-2,1,0.17535119851430256,code_expression_exchange:None,0.0,0.0,
68,"#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <cassert>
bool word_len(std::string s) {
    std::istringstream iss(s);
    std::vector<std::string> words;
    std::string word;
    while (iss >> word) {
        words.push_back(word);
    }
    for (std::string w : words) {
//begin to write code
",333,"
#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <cassert>

bool word_len(std::string s) {
    std::istringstream iss(s);
    std::vector<std::string> words;
    std::string word;
    while (iss >> word) {
        words.push_back(word);
    }
    for (std::string w : words) {
        if (w.length() % 2 != 0) {
            return true;
        } else {
            return false;
        }
    }
    return false;
}


","
#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <cassert>

bool word_len(std::string s) {
    std::istringstream iss(s);
    std::vector<std::string> words;
    std::string word;
    while (iss >> word) {
        words.push_back(word);
    }
    for (std::string w : words) {
        if (w.length() % 2!= 0) {
            return true;
        }
    }
    return false;
}

","#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <cassert>
bool word_len(std::string s) {
    std::istringstream iss(s);
    std::vector<std::string> words;
    std::string word;
    while (iss >> word) {
        words.push_back(word);
    }
    for (std::string w : words) {
//begin to write code
","
#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <cassert>

bool word_len(std::string s) {
    std::istringstream iss(s);
    std::vector<std::string> words;
    std::string word;
    while (iss >> word) {
        words.push_back(word);
    }
    for (std::string w : words) {
        if (w.length() % 2 != 0) {
            return true;
        } else {
            return false;
        }
    }
    return false;
}


","#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <cassert>
bool word_len(std::string s) {
    std::istringstream iss(s);
    std::vector<std::string> words;
    std::string word;
    while (iss >> word) {
        words.push_back(word);
    }
    int length = words.size();
    return length % 2 == 0;
}
",1,3,0.4848584055900574,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cassert>\n\nbool word_len(std::string s) {\n    std::istringstream iss(s);\n    std::vector<std::string> words;\n    std::string word;\n    while (iss >> word) {\n        words.push_back(word);\n    }\n    for (std::string w : words) {\n        if (w.length() % 2 != 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    return false;\n}\n\n\n': [('#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cassert>\nbool word_len(std::string s) {\n    std::istringstream iss(s);\n    std::vector<std::string> words;\n    std::string word;\n    while (iss >> word) {\n        words.push_back(word);\n    }\n    for (std::string w : words) {\n//begin to write code\n', '#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cassert>\nbool word_len(std::string s) {\n    std::istringstream iss(s);\n    std::vector<std::string> words;\n    std::string word;\n    while (iss >> word) {\n        words.push_back(word);\n    }\n    int length = words.size();\n    return length % 2 == 0;\n}\n', 'equal_expression_transformation')]}"
69,"#include <iostream>
#include <cassert>
double tetrahedral_number(int n) {
//begin to write code
",96,"
#include <iostream>
#include <cassert>

double tetrahedral_number(int n) {
    return (n * (n + 1) * (n + 2)) / 6.0;
}


","
using namespace std;
#include <iostream>
#include <cassert>

double tetrahedral_number(int n) {
    if (n < 0) {
        throw invalid_argument(""Input must be a non-negative integer."");
    }
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    double result = 1;
    for (int i = 2; i <= n; ++i) {
        result += 6 * i * (i - 1);
    }
    return result;
}

",,,,-2,1,0.2178261677424113,code_expression_exchange:None,0.0,0.0,
70,"#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>
using namespace std;
vector<pair<int, int>> zip_tuples(const vector<int>& test_tup1, const vector<int>& test_tup2) {
    vector<pair<int, int>> res;
    int n2 = test_tup2.size();
    for (size_t i = 0; i < test_tup1.size(); ++i) {
//begin to write code
",328,"
#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>

using namespace std;

vector<pair<int, int>> zip_tuples(const vector<int>& test_tup1, const vector<int>& test_tup2) {
    vector<pair<int, int>> res;
    int n2 = test_tup2.size();
    for (size_t i = 0; i < test_tup1.size(); ++i) {
        res.push_back(make_pair(test_tup1[i], test_tup2[i % n2]));
    }
    return res;
}


","
#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>
using namespace std;

vector<pair<int, int>> zip_tuples(const vector<int>& test_tup1, const vector<int>& test_tup2) {
    vector<pair<int, int>> res;
    int n2 = test_tup2.size();
    for (size_t i = 0; i < test_tup1.size(); ++i) {
        res.push_back(make_pair(test_tup1[i], test_tup2[i]));
    }
    return res;
}

",,,,-2,1,0.21761316061019897,code_expression_exchange:None,0.0,0.0,
71,"#include <iostream>
#include <cmath>
#include <cassert>
double volume_sphere(double r) {
    double volume = (4.0 / 3.0) * M_PI * r * r * r;
//begin to write code
",163,"
#include <iostream>
#include <cmath>
#include <cassert>

double volume_sphere(double r) {
    double volume = (4.0 / 3.0) * M_PI * r * r * r;
    return volume;
}


","
#include <iostream>
#include <cmath>
#include <cassert>

double volume_sphere(double r) {
    double volume = (4.0 / 3.0) * M_PI * r * r * r;
    return volume;
}

","#include <iostream>
#include <cmath>
#include <cassert>
double volume_sphere(double r) {
    double volume = r * (4.0 / 3.0) * M_PI * r * r;
//begin to write code
","
#include <iostream>
#include <cmath>
#include <cassert>

double volume_sphere(double r) {
    double volume = r * (4.0 / 3.0) * M_PI * r * r;
    return volume;
}


","
#include <iostream>
#include <cmath>
#include <cassert>

double volume_sphere(double r) {
    return (4.0 / 3.0) * M_PI * r * r;
}

",1,9,1.2160024364789328,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble volume_sphere(double r) {\n    double volume = r * (4.0 / 3.0) * M_PI * r * r;\n    return volume;\n}\n\n\n': [('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble volume_sphere(double r) {\n    double volume = r * (4.0 / 3.0) * M_PI * r * r;\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble volume_sphere(double r) {\n    double volume = r * (4.0 / 3.0) * M_PI * r * r;\n    return volume;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble volume_sphere(double r) {\n    double volume = r * (4.0 / 3.0) * M_PI * r * r;\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\n// Function to calculate the volume of a sphere\ndouble volume_sphere(double r) {\n    return r * (4.0 / 3.0) * M_PI * r * r;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble volume_sphere(double r) {\n    double volume = r * (4.0 / 3.0) * M_PI * r * r;\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble volume_sphere(double r) {\n    double volume = r * (4.0 / 3.0) * M_PI * r * r;\n    return volume;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble volume_sphere(double r) {\n    double volume = r * (4.0 / 3.0) * M_PI * r * r;\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble volume_sphere(double r) {\n    return (4.0 / 3.0) * M_PI * r * r;\n}\n\n', 'equal_expression_transformation')]}"
72,"#include <iostream>
#include <string>
#include <cassert>
char get_Char(std::string strr) {
    int summ = 0;
    for (int i = 0; i < strr.length(); ++i) {
        summ += (strr[i] - 'a' + 1);
    }
    if (summ % 26 == 0) {
//begin to write code
",246,"
#include <iostream>
#include <string>
#include <cassert>

char get_Char(std::string strr) {
    int summ = 0;
    for (int i = 0; i < strr.length(); ++i) {
        summ += (strr[i] - 'a' + 1);
    }
    if (summ % 26 == 0) {
        return 'z';
    } else {
        summ = summ % 26;
        return 'a' + summ - 1;
    }
}


","
#include <iostream>
#include <string>
#include <cassert>

char get_Char(std::string strr) {
    int summ = 0;
    for (int i = 0; i < strr.length(); ++i) {
        summ += (strr[i] - 'a' + 1);
    }
    if (summ % 26 == 0) {
        return 'a' + (summ / 26);
    } else {
        return 'A' + (summ % 26);
    }
}

",,,,-2,1,0.2378710389137268,code_expression_exchange:None,0.0,0.0,
73,"#include <iostream>
#include <cassert>
int sequence(int n) {
    if (n == 1 || n == 2) {
        return 1;
//begin to write code
",129,"
#include <iostream>
#include <cassert>

int sequence(int n) {
    if (n == 1 || n == 2) {
        return 1;
    } else {
        return sequence(sequence(n - 1)) + sequence(n - sequence(n - 1));
    }
}


","
using namespace std;
#include <iostream>

int sequence(int n) {
    if (n == 1 || n == 2) {
        return 1;
    }
    int a = 1, b = 1, c = 0;
    for (int i = 3; i <= n; ++i) {
        c = a + b;
        a = b;
        b = c;
    }
    return c;
}

",,,,-2,1,0.20230403343836467,code_expression_exchange:None,0.0,0.0,
74,"#include <iostream>
#include <cmath>
#include <cassert>
double surfacearea_sphere(double r) {
    double surfacearea = 4 * M_PI * r * r;
//begin to write code
",159,"
#include <iostream>
#include <cmath>
#include <cassert>

double surfacearea_sphere(double r) {
    double surfacearea = 4 * M_PI * r * r;
    return surfacearea;
}


","
#include <iostream>
#include <cmath>
#include <cassert>

using namespace std;

double surfacearea_sphere(double r) {
    double surfacearea = 4 * M_PI * r * r;
    return surfacearea;
}

","#include <iostream>
#include <cmath>
#include <cassert>
double surfacearea_sphere(double r) {
    double surfacearea = r * M_PI * 4 * r;
//begin to write code
","
#include <iostream>
#include <cmath>
#include <cassert>

double surfacearea_sphere(double r) {
    double surfacearea = r * M_PI * 4 * r;
    return surfacearea;
}


","
#include <iostream>
#include <cmath>
#include <cassert>

double surfacearea_sphere(double r) {
    double surfacearea = r * M_PI * 4 * r;
    return surfacearea;
}

",-1,21,3.185090625286102,code_expression_exchange:exchange_operators,1.0,0.8308511948812505,"{'\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * 4 * r;\n    return surfacearea;\n}\n\n\n': [('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * 4 * r;\n//begin to write code\n', '\nusing namespace std;\n#include <cmath>\n#include <cassert>\n\ndouble surfacearea_sphere(double r) {\n    return 4 * M_PI * r * r;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * 4 * r;\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * 4 * r;\n    return surfacearea;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * r * 4;\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n#include <string>\n\ndouble surfacearea_sphere(double r) {\n    return 4 * M_PI * r * r;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * r * 4;\n//begin to write code\n', '\nusing namespace std;\n#include <cmath>\n#include <cassert>\n\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * r * 4;\n    return surfacearea;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * r * 4;\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * r * 4;\n    return surfacearea;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * r * 4;\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * r * 4;\n    return surfacearea;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * r * 4;\n//begin to write code\n', '\nusing namespace std;\n#include <cmath>\n#include <cassert>\n\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * r * 4;\n    return surfacearea;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * r * 4;\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * r * 4;\n    return surfacearea;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble surfacearea_sphere(double r) {\n    double surfacearea = 4 * M_PI * r * r;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble surfacearea_sphere(double r) {\n    double surfacearea = 4 * M_PI * r * r;\n    return surfacearea;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * 4 * r;\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble surfacearea_sphere(double r) {\n    double surfacearea = r * M_PI * 4 * r;\n    return surfacearea;\n}\n\n', 'exchange_operators')]}"
75,"#include <iostream>
#include <cassert>
int centered_hexagonal_number(int n) {
//begin to write code
",100,"
#include <iostream>
#include <cassert>

int centered_hexagonal_number(int n) {
    return 3 * n * (n - 1) + 1;
}


","
#include <iostream>
#include <cassert>
#include <cmath>

int centered_hexagonal_number(int n) {
    // Calculate the nth centered hexagonal number using the formula: H = 3n^2 - 4n + 1
    return 3 * std::pow(n, 2) - 4 * n + 1;
}

",,,,-2,1,0.2569999615351359,code_expression_exchange:None,0.0,0.0,
76,"#include <iostream>
#include <map>
#include <cassert>
using namespace std;
map<string, string> merge_dictionaries_three(map<string, string> dict1, map<string, string> dict2, map<string, string> dict3) {
    map<string, string> merged_dict;
    for (const auto &pair : dict3) {
        merged_dict[pair.first] = pair.second;
    }
    for (const auto &pair : dict2) {
//begin to write code
",389,"
#include <iostream>
#include <map>
#include <cassert>

using namespace std;

map<string, string> merge_dictionaries_three(map<string, string> dict1, map<string, string> dict2, map<string, string> dict3) {
    map<string, string> merged_dict;

    for (const auto &pair : dict3) {
        merged_dict[pair.first] = pair.second;
    }
    for (const auto &pair : dict2) {
        merged_dict[pair.first] = pair.second;
    }
    for (const auto &pair : dict1) {
        merged_dict[pair.first] = pair.second;
    }

    return merged_dict;
}


","#include <iostream>
#include <map>
#include <cassert>
using namespace std;

map<string, string> merge_dictionaries_three(map<string, string> dict1, map<string, string> dict2, map<string, string> dict3) {
    map<string, string> merged_dict;
    for (const auto &pair : dict3) {
        merged_dict[pair.first] = pair.second;
    }
    for (const auto &pair : dict2) {
        merged_dict[pair.first] = pair.second;
    }
    return merged_dict;
}
",,,,-2,1,0.21091973384221394,code_expression_exchange:None,0.0,0.0,
77,"#include <iostream>
#include <map>
#include <vector>
#include <cassert>
std::map<int, int> freq_count(std::vector<int> list1) {
    std::map<int, int> freq_count;
    for (int num : list1) {
//begin to write code
",213,"
#include <iostream>
#include <map>
#include <vector>
#include <cassert>

std::map<int, int> freq_count(std::vector<int> list1) {
    std::map<int, int> freq_count;
    for (int num : list1) {
        freq_count[num]++;
    }
    return freq_count;
}


","
using namespace std;

#include <iostream>
#include <map>
#include <vector>
#include <cassert>

std::map<int, int> freq_count(std::vector<int> list1) {
    std::map<int, int> freq_count;
    for (int num : list1) {
        freq_count[num]++;
    }
    return freq_count;
}

","#include <iostream>
#include <map>
#include <vector>
#include <cassert>
std::map<int, long> freq_count(std::vector<int> list1) {
    std::map<int, int> freq_count;
    for (int num : list1) {
//begin to write code
","
#include <iostream>
#include <map>
#include <vector>
#include <cassert>

std::map<int, long> freq_count(std::vector<int> list1) {
    std::map<int, int> freq_count;
    for (int num : list1) {
        freq_count[num]++;
    }
    return freq_count;
}


","
#include <iostream>
#include <map>
#include <vector>
#include <cassert>

std::map<int, long> freq_count(std::vector<int> list1) {
    std::map<int, long> freq_count;
    for (int num : list1) {
        freq_count[num]++;
    }
    return freq_count;
}

// Test cases
void test_freq_count() {
    assert(freq_count({1, 2, 2, 3, 3, 3, 4, 4, 4}) == std::map<int, long>{{1, 2}, {2, 3}, {3, 4}});
    assert(freq_count({5, 5, 5, 5, 5, 5, 5, 5, 5}) == std::map<int, long>{{5, 5}});
    assert(freq_count({}) == std::map<int, long>());
    std::cout << ""All test cases passed!"" << std::endl;
}

",1,3,0.5633302529652914,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n\nstd::map<int, long> freq_count(std::vector<int> list1) {\n    std::map<int, int> freq_count;\n    for (int num : list1) {\n        freq_count[num]++;\n    }\n    return freq_count;\n}\n\n\n': [('#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\nstd::map<int, long> freq_count(std::vector<int> list1) {\n    std::map<int, int> freq_count;\n    for (int num : list1) {\n//begin to write code\n', '\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cassert>\n\nstd::map<int, long> freq_count(std::vector<int> list1) {\n    std::map<int, long> freq_count;\n    for (int num : list1) {\n        freq_count[num]++;\n    }\n    return freq_count;\n}\n\n// Test cases\nvoid test_freq_count() {\n    assert(freq_count({1, 2, 2, 3, 3, 3, 4, 4, 4}) == std::map<int, long>{{1, 2}, {2, 3}, {3, 4}});\n    assert(freq_count({5, 5, 5, 5, 5, 5, 5, 5, 5}) == std::map<int, long>{{5, 5}});\n    assert(freq_count({}) == std::map<int, long>());\n    std::cout << ""All test cases passed!"" << std::endl;\n}\n\n', 'more_universe_var_type')]}"
78,"#include<iostream>
#include <cassert>
int closest_num(int N) {
//begin to write code
",85,"#include<iostream>
    

#include <cassert>

int closest_num(int N) {
    return (N - 1);
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<assert.h>

int closest_num(int N) {
    int min_diff = INT_MAX;
    int closest = 0;

    for (int i = 1; i <= N; ++i) {
        if (abs(i - N) < min_diff) {
            min_diff = abs(i - N);
            closest = i;
        }
    }

    return closest;
}

",,,,-2,1,0.2916634122530619,code_expression_exchange:None,0.0,0.0,
79,"#include <iostream>
#include <vector>
#include <string>
#include <cassert>
// 
int len_log(const std::vector<std::string>& list1) {
    int max = list1[0].length();
    for (const std::string& i : list1) {
        if (i.length() > max) {
//begin to write code
",264,"
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

// 
int len_log(const std::vector<std::string>& list1) {
    int max = list1[0].length();
    for (const std::string& i : list1) {
        if (i.length() > max) {
            max = i.length();
        }
    }
    return max;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

// 
int len_log(const std::vector<std::string>& list1) {
    int max = list1[0].length();
    for (const std::string& i : list1) {
        if (i.length() > max) {
            max = i.length();
        }
    }
    return max;
}

// 
void test_len_log() {
    assert(len_log({""apple"", ""banana"", ""cherry""}) == 6);
    assert(len_log({""hello"", ""world"", ""cpp""}) == 5);
    assert(len_log({""short"", ""list"", ""of"", ""words""}) == 8);
    cout << ""All tests passed successfully."" << endl;
}

","#include <iostream>
#include <vector>
#include <string>
#include <cassert>
// 
int len_log(const std::vector<std::string>& list1) {
    long max = list1[0].length();
    for (const std::string& i : list1) {
        if (i.length() > max) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

// 
int len_log(const std::vector<std::string>& list1) {
    long max = list1[0].length();
    for (const std::string& i : list1) {
        if (i.length() > max) {
            max = i.length();
        }
    }
    return max;
}


","
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

// 
int len_log(const std::vector<std::string>& list1) {
    long max = list1[0].length();
    for (const std::string& i : list1) {
        if (i.length() > max) {
            max = i.length();
        }
    }
    return max;
}

// 
void test_len_log() {
    assert(len_log({""hello"", ""world""}) == 5);
    assert(len_log({""a"", ""ab"", ""abc"", ""abcd""}) == 4);
    assert(len_log({""aaa"", ""bbb"", ""ccc"", ""dddd""}) == 4);
    assert(len_log({""ab"", ""ac"", ""ad"", ""ae"", ""af"", ""ag"", ""ah"", ""ai"", ""aj"", ""ak"", ""al"", ""am"", ""an"", ""ao"", ""ap"", ""aq"", ""ar"", ""as"", ""at"", ""au"", ""av"", ""aw"", ""ax"", ""ay"", ""az""}) == 9);
    std::cout << ""All tests passed!"" << std::endl;
",1,19,3.0596054951349894,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n// \nint len_log(const std::vector<std::string>& list1) {\n    long max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n            max = i.length();\n        }\n    }\n    return max;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n// \nint len_log(const std::vector<std::string>& list1) {\n    int max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n// \nint len_log(const std::vector<std::string>& list1) {\n    int max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n            max = i.length();\n        }\n    }\n    return max;\n}\n\n// \nvoid test_len_log() {\n    assert(len_log({""apple"", ""banana"", ""cherry""}) == 6);\n    assert(len_log({""hello"", ""world"", ""algorithm""}) == 7);\n    assert(len_log({""a"", ""bb"", ""ccc"", ""dddd""}) == 4);\n    cout << ""All tests passed successfully."" << endl;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n// \nint len_log(const std::vector<std::string>& list1) {\n    int max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n// \nint len_log(const std::vector<std::string>& list1) {\n    int max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n            max = i.length();\n        }\n    }\n    return max;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n// \nint len_log(const std::vector<std::string>& list1) {\n    int max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n// \nint len_log(const std::vector<std::string>& list1) {\n    int max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n            max = i.length();\n        }\n    }\n    return max;\n}\n\n// \nvoid test_len_log() {\n    assert(len_log({""apple"", ""banana"", ""cherry""}) == 6);\n    assert(len_log({""dog"", ""elephant"", ""cat""}) == 4);\n    assert(len_log({""hello"", ""world"", ""cpp""}) == 4);\n    std::cout << ""All tests passed successfully."" << std::endl;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n// \nint len_log(const std::vector<std::string>& list1) {\n    long max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n// \nint len_log(const std::vector<std::string>& list1) {\n    long max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n            max = i.length();\n        }\n    }\n    return max;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n// \nint len_log(const std::vector<std::string>& list1) {\n    long max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nint len_log(const std::vector<std::string>& list1) {\n    long max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n            max = i.length();\n        }\n    }\n    return max;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n// \nint len_log(const std::vector<std::string>& list1) {\n    long max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n// \nint len_log(const std::vector<std::string>& list1) {\n    long max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n            max = i.length();\n        }\n    }\n    return max;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n// \nint len_log(const std::vector<std::string>& list1) {\n    long max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n// \nint len_log(const std::vector<std::string>& list1) {\n    long max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n            max = i.length();\n        }\n    }\n    return max;\n}\n\n// \nvoid test_len_log() {\n    assert(len_log({""hello"", ""world""}) == 5);\n    assert(len_log({""a"", ""ab"", ""abc""}) == 3);\n    assert(len_log({""aaaa"", ""bb"", ""ccc""}) == 3);\n    assert(len_log({""single""}) == 6);\n    assert(len_log({}) == 0);\n    std::cout << ""All tests passed successfully."" << std::endl;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n// \nint len_log(const std::vector<std::string>& list1) {\n    long max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n// \nint len_log(const std::vector<std::string>& list1) {\n    long max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n            max = i.length();\n        }\n    }\n    return max;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n// \nint len_log(const std::vector<std::string>& list1) {\n    long max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n// \nint len_log(const std::vector<std::string>& list1) {\n    long max = list1[0].length();\n    for (const std::string& i : list1) {\n        if (i.length() > max) {\n            max = i.length();\n        }\n    }\n    return max;\n}\n\n// \nvoid test_len_log() {\n    assert(len_log({""hello"", ""world""}) == 5);\n    assert(len_log({""a"", ""ab"", ""abc"", ""abcd""}) == 4);\n    assert(len_log({""aaa"", ""bbb"", ""ccc"", ""dddd""}) == 4);\n    assert(len_log({""ab"", ""ac"", ""ad"", ""ae"", ""af"", ""ag"", ""ah"", ""ai"", ""aj"", ""ak"", ""al"", ""am"", ""an"", ""ao"", ""ap"", ""aq"", ""ar"", ""as"", ""at"", ""au"", ""av"", ""aw"", ""ax"", ""ay"", ""az""}) == 9);\n    std::cout << ""All tests passed!"" << std::endl;\n', 'exchange_operators')]}"
80,"#include <iostream>
#include <vector>
#include <string>
#include <cassert>
bool find_substring(std::vector<std::string> str1, std::string sub_str) {
    for (auto &s : str1) {
        if (s.find(sub_str) != std::string::npos) {
            return true;
//begin to write code
",275,"
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

bool find_substring(std::vector<std::string> str1, std::string sub_str) {
    for (auto &s : str1) {
        if (s.find(sub_str) != std::string::npos) {
            return true;
        }
    }
    return false;
}


","
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

bool find_substring(std::vector<std::string> str1, std::string sub_str) {
    for (auto &s : str1) {
        if (s.find(sub_str)!= std::string::npos) {
            return true;
        }
    }
    return false;
}

","#include <iostream>
#include <vector>
#include <string>
#include <cassert>
bool find_substring(std::vector<std::string> str1, std::string sub_str) {
    for (auto &s : str1) {
        if (std::string::npos != s.find(sub_str)) {
            return 1;
//begin to write code
","
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

bool find_substring(std::vector<std::string> str1, std::string sub_str) {
    for (auto &s : str1) {
        if (std::string::npos != s.find(sub_str)) {
            return 1;
        }
    }
    return 0;
}


","---




",1,21,2.9601529757181804,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (std::string::npos != s.find(sub_str)) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str) != std::string::npos) {\n            return 1;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str)!= std::string::npos) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str) != std::string::npos) {\n            return 1;\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str)!= std::string::npos) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str) != std::string::npos) {\n            return 1;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str)!= std::string::npos) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str) != std::string::npos) {\n            return 1;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str)!= std::string::npos) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str) != std::string::npos) {\n            return 1;\n//begin to write code\n', 'using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str)!= std::string::npos) {\n            return 1;\n        }\n    }\n    return 0;\n}\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str) != std::string::npos) {\n            return 1;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str)!= std::string::npos) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str) != std::string::npos) {\n            return 1;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str)!= std::string::npos) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str) != std::string::npos) {\n            return 1;\n//begin to write code\n', 'using namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str)!= std::string::npos) {\n            return 1;\n        }\n    }\n    return 0;\n}\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str) != std::string::npos) {\n            return 1;\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (s.find(sub_str)!= std::string::npos) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n    for (auto &s : str1) {\n        if (std::string::npos != s.find(sub_str)) {\n            return 1;\n//begin to write code\n', '---\n\n\n\n\n', 'exchange_operators')]}"
81,"#include <iostream>
#include <string>
#include <cassert>
bool is_undulating(const std::string& n) {
    if (n.length() <= 2) {
        return false;
    }
    for (size_t i = 2; i < n.length(); ++i) {
//begin to write code
",223,"
#include <iostream>
#include <string>
#include <cassert>

bool is_undulating(const std::string& n) {
    if (n.length() <= 2) {
        return false;
    }
    for (size_t i = 2; i < n.length(); ++i) {
        if (n[i - 2] != n[i]) {
            return false;
        }
    }
    return true;
}


","
using namespace std;
#include <string>
#include <cassert>

bool is_undulating(const std::string& n) {
    if (n.length() <= 2) {
        return false;
    }
    for (size_t i = 2; i < n.length(); ++i) {
        if (n[i]!= n[i - 1] && n[i]!= n[i + 1]) {
            return false;
        }
    }
    return true;
}

",,,,-2,1,0.23727341890335082,code_expression_exchange:None,0.0,0.0,
82,"#include <iostream>
#include <cassert>
int power(int a, int b) {
    if (b == 0) {
        return 1;
    } else if (a == 0) {
        return 0;
//begin to write code
",166,"
#include <iostream>
#include <cassert>

int power(int a, int b) {
    if (b == 0) {
        return 1;
    } else if (a == 0) {
        return 0;
    } else if (b == 1) {
        return a;
    } else {
        return a * power(a, b - 1);
    }
}


","
using namespace std;

#include <iostream>
#include <cassert>

int power(int a, int b) {
    if (b == 0) {
        return 1;
    } else if (a == 0) {
        return 0;
    }
    int result = 1;
    for (int i = 0; i < b; ++i) {
        result *= a;
    }
    return result;
}

","#include <iostream>
#include <cassert>
long power(int a, long b) {
    if (0 == b) {
        return 1;
    } else if (0 == a) {
        return 0;
//begin to write code
","
#include <iostream>
#include <cassert>

long power(int a, long b) {
    if (0 == b) {
        return 1;
    } else if (0 == a) {
        return 0;
    } else if (1 == b) {
        return a;
    } else {
        return power(a, b - 1) * a;
    }
}


","
using namespace std;
#include <iostream>

long power(int a, long b) {
    if (0 == b) {
        return 1;
    } else if (0 == a) {
        return 0;
    }
    long result = 1;
    for (int i = 0; i < b; ++i) {
        result *= a;
    }
    return result;
}

",1,11,1.4009213248888652,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nlong power(int a, long b) {\n    if (0 == b) {\n        return 1;\n    } else if (0 == a) {\n        return 0;\n    } else if (1 == b) {\n        return a;\n    } else {\n        return power(a, b - 1) * a;\n    }\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint power(int a, int b) {\n    if (0 == b) {\n        return 1;\n    } else if (0 == a) {\n        return 0;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint power(int a, int b) {\n    if (0 == b) {\n        return 1;\n    } else if (0 == a) {\n        return 0;\n    }\n    return a * power(a, b - 1);\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cassert>\nint power(int a, long b) {\n    if (0 == b) {\n        return 1;\n    } else if (0 == a) {\n        return 0;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nint power(int a, long b) {\n    if (0 == b) {\n        return 1;\n    } else if (0 == a) {\n        return 0;\n    }\n    int result = 1;\n    for (long i = 0; i < b; ++i) {\n        result *= a;\n    }\n    return result;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nint power(int a, long b) {\n    if (0 == b) {\n        return 1;\n    } else if (0 == a) {\n        return 0;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nint power(int a, long b) {\n    if (0 == b) {\n        return 1;\n    } else if (0 == a) {\n        return 0;\n    }\n    int result = 1;\n    while (b > 0) {\n        if (b % 2 == 1) {\n            result *= a;\n        }\n        a *= a;\n        b /= 2;\n    }\n    return result;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cassert>\nlong power(int a, long b) {\n    if (0 == b) {\n        return 1;\n    } else if (0 == a) {\n        return 0;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nlong power(int a, long b) {\n    if (0 == b) {\n        return 1;\n    } else if (0 == a) {\n        return 0;\n    }\n    long result = 1;\n    for (int i = 0; i < b; ++i) {\n        result *= a;\n    }\n    return result;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nlong power(int a, long b) {\n    if (0 == b) {\n        return 1;\n    } else if (0 == a) {\n        return 0;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n\nlong power(int a, long b) {\n    if (0 == b) {\n        return 1;\n    } else if (0 == a) {\n        return 0;\n    }\n    long result = 1;\n    for (int i = 0; i < b; ++i) {\n        result *= a;\n    }\n    return result;\n}\n\n', 'equal_expression_transformation')]}"
83,"#include<cassert>
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <limits>
std::string index_minimum(const std::vector<std::pair<std::string, int>>& test_list) {
    auto min_elem = std::min_element(test_list.begin(), test_list.end(),
                                     [](const std::pair<std::string, int>& a, const std::pair<std::string, int>& b) {
//begin to write code
",413,"#include<cassert>
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <limits>

std::string index_minimum(const std::vector<std::pair<std::string, int>>& test_list) {
    auto min_elem = std::min_element(test_list.begin(), test_list.end(),
                                     [](const std::pair<std::string, int>& a, const std::pair<std::string, int>& b) {
                                         return a.second < b.second;
                                     });
    return min_elem->first;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

std::string index_minimum(const std::vector<std::pair<std::string, int>>& test_list) {
    if (test_list.empty()) {
        return ""No elements to find an index minimum value for."";
    }

    // Find the pair with the smallest second element
    auto min_pair = *std::min_element(test_list.begin(), test_list.end(),
                                      [](const std::pair<std::string, int>& a, const std::pair<std::string, int>& b) {
                                          return a.second < b.second;
                                      });

    // Return the string representation of the minimum element
    return min_pair.first;
}

",,,,-2,1,0.2194286346435547,code_expression_exchange:None,0.0,0.0,
84,"#include<iostream>
#include <vector>
#include <algorithm>
#include <climits>
#include <cassert>
using namespace std;
int Find_Min_Length(vector<vector<int>>& lst) {
    int minLength = INT_MAX;
    for (auto& v : lst) {
        if (v.size() < minLength) {
//begin to write code
",278,"#include<iostream>
    

#include <vector>
#include <algorithm>
#include <climits>
#include <cassert>

using namespace std;

int Find_Min_Length(vector<vector<int>>& lst) {
    int minLength = INT_MAX;
    for (auto& v : lst) {
        if (v.size() < minLength) {
            minLength = v.size();
        }
    }
    return minLength;
}


","#include<iostream>
#include <vector>
#include <algorithm>
#include <climits>
#include <cassert>
using namespace std;

int Find_Min_Length(vector<vector<int>>& lst) {
    int minLength = INT_MAX;
    for (auto& v : lst) {
        if (v.size() < minLength) {
            minLength = v.size();
        }
    }
    return minLength;
}
","#include<iostream>
#include <vector>
#include <algorithm>
#include <climits>
#include <cassert>
using namespace std;
int Find_Min_Length(vector<vector<long>>& lst) {
    int minLength = INT_MAX;
    for (auto& v : lst) {
        if (v.size() < minLength) {
//begin to write code
","#include<iostream>
    

#include <vector>
#include <algorithm>
#include <climits>
#include <cassert>

using namespace std;

int Find_Min_Length(vector<vector<long>>& lst) {
    int minLength = INT_MAX;
    for (auto& v : lst) {
        if (v.size() < minLength) {
            minLength = v.size();
        }
    }
    return minLength;
}


","
#include<iostream>
#include <vector>
#include <algorithm>
#include <climits>
#include <cassert>
using namespace std;

int Find_Min_Length(vector<vector<long>>& lst) {
    int minLength = INT_MAX;
    for (auto& v : lst) {
        if (v.size() < minLength) {
            minLength = v.size();
        }
    }
    return minLength;
}

",1,3,0.3839701851209005,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<iostream>\n    \n\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\nint Find_Min_Length(vector<vector<long>>& lst) {\n    int minLength = INT_MAX;\n    for (auto& v : lst) {\n        if (v.size() < minLength) {\n            minLength = v.size();\n        }\n    }\n    return minLength;\n}\n\n\n': [('#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cassert>\nusing namespace std;\nint Find_Min_Length(vector<vector<long>>& lst) {\n    int minLength = INT_MAX;\n    for (auto& v : lst) {\n        if (v.size() < minLength) {\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cassert>\nusing namespace std;\n\nint Find_Min_Length(vector<vector<long>>& lst) {\n    int minLength = INT_MAX;\n    for (auto& v : lst) {\n        if (v.size() < minLength) {\n            minLength = v.size();\n        }\n    }\n    return minLength;\n}\n\n', 'more_universe_var_type')]}"
85,"#include <iostream>
#include <vector>
#include <cassert>
int divisor(int n) {
    int x = 0;
    for (int i = 1; i <= n; ++i) {
        if (n % i == 0) {
//begin to write code
",176,"
#include <iostream>
#include <vector>
#include <cassert>

int divisor(int n) {
    int x = 0;
    for (int i = 1; i <= n; ++i) {
        if (n % i == 0) {
            x++;
        }
    }
    return x;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

int divisor(int n) {
    int count = 0;
    for (int i = 1; i <= n; ++i) {
        if (n % i == 0) {
            count++;
        }
    }
    return count;
}

","#include <iostream>
#include <vector>
#include <cassert>
int divisor(long n) {
    int x = 0;
    for (long i = 1; i <= n; i = i + 1) {
        if (0 == n % i) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

int divisor(long n) {
    int x = 0;
    for (long i = 1; i <= n; i = i + 1) {
        if (0 == n % i) {
            x = x + 1;
        }
    }
    return x;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

int divisor(long n) {
    int count = 0;
    for (long i = 1; i <= n; i++) {
        if (0 == n % i) {
            count++;
        }
    }
    return count;
}

",-1,21,2.7690813263257343,code_expression_exchange:exchange_operators,1.0,0.7773965470695523,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint divisor(long n) {\n    int x = 0;\n    for (long i = 1; i <= n; i = i + 1) {\n        if (0 == n % i) {\n            x = x + 1;\n        }\n    }\n    return x;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nint divisor(int n) {\n    int x = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (0 == n % i) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint divisor(int n) {\n    int x = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (0 == n % i) {\n            ++x;\n        }\n    }\n    return x;\n}\n\nvoid test_divisor() {\n    assert(divisor(1) == 1);\n    assert(divisor(2) == 1);\n    assert(divisor(3) == 1);\n    assert(divisor(4) == 2);\n    assert(divisor(5) == 2);\n    assert(divisor(6) == 3);\n    assert(divisor(7) == 2);\n    assert(divisor(8) == 2);\n    assert(divisor(9) == 3);\n    assert(divisor(10) == 4);\n    cout << ""All test cases passed!"" << endl;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint divisor(int n) {\n    int x = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (0 == n % i) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint divisor(int n) {\n    int x = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (0 == n % i) {\n            ++x;\n        }\n    }\n    return x;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint divisor(int n) {\n    int x = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n        if (0 == n % i) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint divisor(int n) {\n    int count = 0;\n    for (int i = 1; i <= n; i++) {\n        if (0 == n % i) {\n            count++;\n        }\n    }\n    return count;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint divisor(int n) {\n    int x = 0;\n    for (int i = 1; i <= n; i = 1 + i) {\n        if (n % i == 0) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint divisor(int n) {\n    int count = 0;\n    for (int i = 1; i <= n; i++) {\n        if (n % i == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint divisor(int n) {\n    int x = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n        if (0 == n % i) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint divisor(int n) {\n    int x = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n        if (0 == n % i) {\n            x++;\n        }\n    }\n    return x;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint divisor(long n) {\n    int x = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n        if (0 == n % i) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint divisor(long n) {\n    int x = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n        if (0 == n % i) {\n            x++;\n        }\n    }\n    return x;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint divisor(long n) {\n    int x = 0;\n    for (long i = 1; i <= n; i = i + 1) {\n        if (0 == n % i) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint divisor(long n) {\n    int count = 0;\n    for (long i = 1; i <= n; i++) {\n        if (0 == n % i) {\n            count++;\n        }\n    }\n    return count;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint divisor(long n) {\n    int x = 0;\n    for (long i = 1; i <= n; i = i + 1) {\n        if (0 == n % i) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint divisor(long n) {\n    int count = 0;\n    for (long i = 1; i <= n; i++) {\n        if (0 == n % i) {\n            count++;\n        }\n    }\n    return count;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint divisor(long n) {\n    int x = 0;\n    for (long i = 1; i <= n; i = 1 + i) {\n        if (n % i == 0) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint divisor(long n) {\n    int x = 0;\n    for (long i = 1; i <= n; i = 1 + i) {\n        if (n % i == 0) {\n            x++;\n        }\n    }\n    return x;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint divisor(long n) {\n    int x = 0;\n    for (long i = 1; i <= n; i = i + 1) {\n        if (0 == n % i) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint divisor(long n) {\n    int count = 0;\n    for (long i = 1; i <= n; i++) {\n        if (0 == n % i) {\n            count++;\n        }\n    }\n    return count;\n}\n\n', 'exchange_operators')]}"
86,"#include<iostream>
#include <vector>
#include <unordered_map>
#include <cassert>
using namespace std;
unordered_map<int, int> frequency_lists(vector<vector<int>>& list1) {
    vector<int> flat_list;
    for (auto& sublist : list1) {
        for (auto& item : sublist) {
            flat_list.push_back(item);
        }
    }
    unordered_map<int, int> dic_data;
//begin to write code
",385,"#include<iostream>
    

#include <vector>
#include <unordered_map>
#include <cassert>

using namespace std;

unordered_map<int, int> frequency_lists(vector<vector<int>>& list1) {
    vector<int> flat_list;
    for (auto& sublist : list1) {
        for (auto& item : sublist) {
            flat_list.push_back(item);
        }
    }
    unordered_map<int, int> dic_data;
    for (auto& num : flat_list) {
        if (dic_data.find(num) != dic_data.end()) {
            dic_data[num]++;
        } else {
            dic_data[num] = 1;
        }
    }
    return dic_data;
}


","#include <iostream>
#include <vector>
#include <unordered_map>
#include <cassert>
using namespace std;
unordered_map<int, int> frequency_lists(vector<vector<int>>& list1) {
    vector<int> flat_list;
    for (auto& sublist : list1) {
        for (auto& item : sublist) {
            flat_list.push_back(item);
        }
    }
    unordered_map<int, int> dic_data;
    for (int num : flat_list) {
        dic_data[num]++;
    }
    return dic_data;
}
","#include<iostream>
#include <vector>
#include <unordered_map>
#include <cassert>
using namespace std;
unordered_map<int, int> frequency_lists(vector<vector<int>>& list1) {
    vector<int> flat_list;
    for (auto& sublist : list1) {
        for (auto& item : sublist) {
            flat_list.push_back(item);
        }
    }
    unordered_map<int, int> dic_data;
//begin to write code
","#include<iostream>
    

#include <vector>
#include <unordered_map>
#include <cassert>

using namespace std;

unordered_map<int, int> frequency_lists(vector<vector<int>>& list1) {
    vector<int> flat_list;
    for (auto& sublist : list1) {
        for (auto& item : sublist) {
            flat_list.push_back(item);
        }
    }
    unordered_map<int, int> dic_data;
    for (auto& num : flat_list) {
        if (dic_data.end() != dic_data.find(num)) {
            dic_data[num]++;
        } else {
            dic_data[num] = 1;
        }
    }
    return dic_data;
}


","
#include<iostream>
#include <vector>
#include <unordered_map>
#include <cassert>
using namespace std;

unordered_map<int, int> frequency_lists(vector<vector<int>>& list1) {
    vector<int> flat_list;
    for (auto& sublist : list1) {
        for (auto& item : sublist) {
            flat_list.push_back(item);
        }
    }
    unordered_map<int, int> dic_data;
    // Complete code here
    return dic_data;
}

",1,5,0.720498792330424,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'#include<iostream>\n    \n\n#include <vector>\n#include <unordered_map>\n#include <cassert>\n\nusing namespace std;\n\nunordered_map<int, int> frequency_lists(vector<vector<int>>& list1) {\n    vector<int> flat_list;\n    for (auto& sublist : list1) {\n        for (auto& item : sublist) {\n            flat_list.push_back(item);\n        }\n    }\n    unordered_map<int, int> dic_data;\n    for (auto& num : flat_list) {\n        if (dic_data.end() != dic_data.find(num)) {\n            dic_data[num]++;\n        } else {\n            dic_data[num] = 1;\n        }\n    }\n    return dic_data;\n}\n\n\n': [('#include<iostream>\n#include <vector>\n#include <unordered_map>\n#include <cassert>\nusing namespace std;\nunordered_map<int, int> frequency_lists(vector<vector<int>>& list1) {\n    vector<int> flat_list;\n    for (auto& sublist : list1) {\n        for (auto& item : sublist) {\n            flat_list.push_back(item);\n        }\n    }\n    unordered_map<int, int> dic_data;\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <unordered_map>\n#include <cassert>\nusing namespace std;\n\nunordered_map<int, int> frequency_lists(vector<vector<int>>& list1) {\n    vector<int> flat_list;\n    for (auto& sublist : list1) {\n        for (auto& item : sublist) {\n            flat_list.push_back(item);\n        }\n    }\n    unordered_map<int, int> dic_data;\n    // Implement the frequency counting logic here\n    for (int item : flat_list) {\n        dic_data[item]++;\n    }\n    return dic_data;\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include <vector>\n#include <unordered_map>\n#include <cassert>\nusing namespace std;\nunordered_map<int, int> frequency_lists(vector<vector<int>>& list1) {\n    vector<int> flat_list;\n    for (auto& sublist : list1) {\n        for (auto& item : sublist) {\n            flat_list.push_back(item);\n        }\n    }\n    unordered_map<int, int> dic_data;\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <unordered_map>\n#include <cassert>\nusing namespace std;\n\nunordered_map<int, int> frequency_lists(vector<vector<int>>& list1) {\n    vector<int> flat_list;\n    for (auto& sublist : list1) {\n        for (auto& item : sublist) {\n            flat_list.push_back(item);\n        }\n    }\n    unordered_map<int, int> dic_data;\n    // Complete code here\n    return dic_data;\n}\n\n', 'equal_expression_transformation')]}"
87,"#include <iostream>
#include <vector>
#include <cassert>
double multiply_num(const std::vector<int>& numbers) {
    double total = 1;
    for (int x : numbers) {
//begin to write code
",184,"
#include <iostream>
#include <vector>
#include <cassert>

double multiply_num(const std::vector<int>& numbers) {
    double total = 1;
    for (int x : numbers) {
        total *= x;
    }
    return total / numbers.size();
}


","
#include <iostream>
#include <vector>
#include <cassert>

double multiply_num(const std::vector<int>& numbers) {
    double total = 1;
    for (int x : numbers) {
        total *= x;
    }
    return total / numbers.size();
}

","#include <iostream>
#include <vector>
#include <cassert>
double multiply_num(const std::vector<long>& numbers) {
    double total = 1;
    for (long x : numbers) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

double multiply_num(const std::vector<long>& numbers) {
    double total = 1;
    for (long x : numbers) {
        total = total * (x);
    }
    return total / numbers.size();
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

double multiply_num(const std::vector<long>& numbers) {
    double total = 1;
    for (long x : numbers) {
        total *= x;
    }
    return total / numbers.size();
}

",-1,21,2.640786850452423,code_expression_exchange:equal_expression_transformation,1.0,0.7296214900599542,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (long x : numbers) {\n        total = total * (x);\n    }\n    return total / numbers.size();\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\ndouble multiply_num(const std::vector<int>& numbers) {\n    double total = 1;\n    for (int x : numbers) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\ndouble multiply_num(const std::vector<int>& numbers) {\n    double total = 1;\n    for (int x : numbers) {\n        total *= x;\n    }\n    return total / numbers.size();\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (int x : numbers) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (int x : numbers) {\n        total *= x;\n    }\n    return total / numbers.size();\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (int x : numbers) {\n//begin to write code\n', '\nusing namespace std;\n#include <vector>\n#include <cassert>\n\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (int x : numbers) {\n        total *= x;\n    }\n    return total / numbers.size();\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (int x : numbers) {\n//begin to write code\n', '\nusing namespace std;\n#include <vector>\n#include <cassert>\n\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (int x : numbers) {\n        total *= x;\n    }\n    return total / numbers.size();\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (int x : numbers) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (int x : numbers) {\n        total *= x;\n    }\n    return total / numbers.size();\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (int x : numbers) {\n//begin to write code\n', '\nusing namespace std;\n#include <vector>\n#include <cassert>\n\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (int x : numbers) {\n        total *= x;\n    }\n    return total / numbers.size();\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (long x : numbers) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (long x : numbers) {\n        total *= x;\n    }\n    return total / numbers.size();\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (long x : numbers) {\n//begin to write code\n', '\nusing namespace std;\n#include <vector>\n#include <cassert>\n\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (long x : numbers) {\n        total *= x;\n    }\n    return total / numbers.size();\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (long x : numbers) {\n//begin to write code\n', '\nusing namespace std;\n#include <vector>\n#include <cassert>\n\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (long x : numbers) {\n        total *= x;\n    }\n    return total / numbers.size();\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (long x : numbers) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\ndouble multiply_num(const std::vector<long>& numbers) {\n    double total = 1;\n    for (long x : numbers) {\n        total *= x;\n    }\n    return total / numbers.size();\n}\n\n', 'equal_expression_transformation')]}"
88,"#include <iostream>
#include <bitset>
#include <cassert>
std::string decimal_to_binary(int n) {
//begin to write code
",118,"
#include <iostream>
#include <bitset>
#include <cassert>

std::string decimal_to_binary(int n) {
    return std::bitset<32>(n).to_string().erase(0, std::bitset<32>(n).to_string().find_first_not_of('0'));
}


","
#include <iostream>
#include <bitset>
#include <cassert>

std::string decimal_to_binary(int n) {
    // Convert the integer to a binary string using std::bitset
    std::bitset<32> binary(n);
    return binary.to_string();
}

",,,,-2,1,0.23151952823003133,code_expression_exchange:None,0.0,0.0,
89,"#include <iostream>
#include <climits>
#include <string>
#include <cassert>
int next_smallest_palindrome(int num) {
    for (int i = num + 1; i < INT_MAX; ++i) {
        std::string num_str = std::to_string(i);
        std::string reversed_str = std::string(num_str.rbegin(), num_str.rend());
        if (num_str == reversed_str) {
//begin to write code
",354,"
#include <iostream>
#include <climits>
#include <string>
#include <cassert>

int next_smallest_palindrome(int num) {
    for (int i = num + 1; i < INT_MAX; ++i) {
        std::string num_str = std::to_string(i);
        std::string reversed_str = std::string(num_str.rbegin(), num_str.rend());
        if (num_str == reversed_str) {
            return i;
        }
    }
    return -1; // Should never reach here for realistic input ranges
}


","
using namespace std;
#include <iostream>
#include <climits>
#include <string>
#include <cassert>

int next_smallest_palindrome(int num) {
    for (int i = num + 1; i < INT_MAX; ++i) {
        std::string num_str = std::to_string(i);
        std::string reversed_str = std::string(num_str.rbegin(), num_str.rend());
        if (num_str == reversed_str) {
            return i;
        }
    }
    return -1; // Return -1 if no smaller palindrome is found
}

","#include <iostream>
#include <climits>
#include <string>
#include <cassert>
int next_smallest_palindrome(int num) {
    for (int i = 1 + num; i < INT_MAX; ++i) {
        std::string num_str = std::to_string(i);
        std::string reversed_str = std::string(num_str.rbegin(), num_str.rend());
        if (reversed_str == num_str) {
//begin to write code
","
#include <iostream>
#include <climits>
#include <string>
#include <cassert>

int next_smallest_palindrome(int num) {
    for (int i = 1 + num; i < INT_MAX; ++i) {
        std::string num_str = std::to_string(i);
        std::string reversed_str = std::string(num_str.rbegin(), num_str.rend());
        if (reversed_str == num_str) {
            return i;
        }
    }
    return -1; // Should never reach here for realistic input ranges
}


","
#include <iostream>
#include <climits>
#include <string>
#include <cassert>

int next_smallest_palindrome(int num) {
    // Convert the number to a string
    std::string num_str = std::to_string(num);
    
    // Reverse the string
    std::string reversed_str = num_str.rbegin(), reversed_end = num_str.rend();
    while (reversed_end!= reversed_str.begin()) {
        std::swap(*reversed_end, *reversed_str--);
    }
    
    // Check if the reversed string is equal to the original string
",1,3,0.4882675647735596,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <climits>\n#include <string>\n#include <cassert>\n\nint next_smallest_palindrome(int num) {\n    for (int i = 1 + num; i < INT_MAX; ++i) {\n        std::string num_str = std::to_string(i);\n        std::string reversed_str = std::string(num_str.rbegin(), num_str.rend());\n        if (reversed_str == num_str) {\n            return i;\n        }\n    }\n    return -1; // Should never reach here for realistic input ranges\n}\n\n\n': [('#include <iostream>\n#include <climits>\n#include <string>\n#include <cassert>\nint next_smallest_palindrome(int num) {\n    for (int i = 1 + num; i < INT_MAX; ++i) {\n        std::string num_str = std::to_string(i);\n        std::string reversed_str = std::string(num_str.rbegin(), num_str.rend());\n        if (reversed_str == num_str) {\n//begin to write code\n', '\n#include <iostream>\n#include <climits>\n#include <string>\n#include <cassert>\n\nint next_smallest_palindrome(int num) {\n    // Convert the number to a string\n    std::string num_str = std::to_string(num);\n    \n    // Reverse the string\n    std::string reversed_str = num_str.rbegin(), reversed_end = num_str.rend();\n    while (reversed_end!= reversed_str.begin()) {\n        std::swap(*reversed_end, *reversed_str--);\n    }\n    \n    // Check if the reversed string is equal to the original string\n', 'exchange_operators')]}"
90,"#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
int kth_element(vector<int>& arr, int n, int k) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
//begin to write code
",311,"
#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

int kth_element(vector<int>& arr, int n, int k) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
    return arr[k - 1];
}


","
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

int kth_element(vector<int>& arr, int n, int k) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
    return arr[k - 1];
}

","#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
int kth_element(vector<int>& arr, int n, long k) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[1 + j]) {
                swap(arr[j], arr[1 + j]);
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

int kth_element(vector<int>& arr, int n, long k) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[1 + j]) {
                swap(arr[j], arr[1 + j]);
            }
        }
    }
    return arr[k - 1];
}


","
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

int kth_element(vector<int>& arr, int n, long k) {
    // Your implementation goes here
    return arr[k - 1];
}

",1,5,0.7353187084197998,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nint kth_element(vector<int>& arr, int n, long k) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[1 + j]) {\n                swap(arr[j], arr[1 + j]);\n            }\n        }\n    }\n    return arr[k - 1];\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nint kth_element(vector<int>& arr, int n, int k) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[1 + j]) {\n                swap(arr[j], arr[1 + j]);\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint kth_element(vector<int>& arr, int n, int k) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[1 + j]) {\n                swap(arr[j], arr[1 + j]);\n            }\n        }\n    }\n    return arr[k - 1];\n}\n\nvoid test_kth_element() {\n    vector<int> arr = {5, 3, 8, 1, 2};\n    int n = arr.size();\n    int k = 3;\n    assert(kth_element(arr, n, k) == 3);\n    cout << ""Test passed!"" << endl;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nint kth_element(vector<int>& arr, int n, long k) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[1 + j]) {\n                swap(arr[j], arr[1 + j]);\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint kth_element(vector<int>& arr, int n, long k) {\n    // Your implementation goes here\n    return arr[k - 1];\n}\n\n', 'more_universe_var_type')]}"
91,"#include <iostream>
#include <sstream>
#include <vector>
#include <cassert>
std::string snake_to_camel(const std::string& word) {
    std::vector<std::string> parts;
    std::string part;
    std::istringstream tokenStream(word);
    while (getline(tokenStream, part, '_')) {
        if (!part.empty()) {
            part[0] = toupper(part[0]); // Capitalize the first letter
            parts.push_back(part);
        } else {
//begin to write code
",450,"
#include <iostream>
#include <sstream>
#include <vector>
#include <cassert>

std::string snake_to_camel(const std::string& word) {
    std::vector<std::string> parts;
    std::string part;
    std::istringstream tokenStream(word);
    while (getline(tokenStream, part, '_')) {
        if (!part.empty()) {
            part[0] = toupper(part[0]); // Capitalize the first letter
            parts.push_back(part);
        } else {
            parts.push_back(""_"");
        }
    }
    std::string camelCase;
    for (const auto& p : parts) {
        camelCase += p;
    }
    return camelCase;
}


","
using namespace std;
#include <iostream>
#include <sstream>
#include <vector>
#include <cassert>

std::string snake_to_camel(const std::string& word) {
    std::vector<std::string> parts;
    std::string part;
    std::istringstream tokenStream(word);
    while (getline(tokenStream, part, '_')) {
        if (!part.empty()) {
            part[0] = toupper(part[0]); // Capitalize the first letter
            parts.push_back(part);
        } else {
            parts.push_back(""""); // Handle empty parts
        }
    }
    std::string result;
    for (size_t i = 0; i < parts.size(); ++i) {
        if (i > 0) {
            result += ""_"";
        }
        result += parts[i];
    }
    return result;
}

",,,,-2,1,0.23436543941497803,code_expression_exchange:None,0.0,0.0,
92,"#include<iostream>
#include <cassert>
using namespace std;
int eulerian_num(int n, int m) {
    if (m >= n || n == 0) {
        return 0;
    }
//begin to write code
",166,"#include<iostream>
    

#include <cassert>

using namespace std;

int eulerian_num(int n, int m) {
    if (m >= n || n == 0) {
        return 0;
    }
    if (m == 0) {
        return 1;
    }
    return ((n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m));
}


","
#include<iostream>
#include <cassert>
using namespace std;

int eulerian_num(int n, int m) {
    if (m >= n || n == 0) {
        return 0;
    }
    // Your implementation goes here
    // For example, you can use a recursive approach to calculate Eulerian numbers
    // Here's a simple implementation using a loop:
    int result = 0;
    for (int i = 1; i <= n; ++i) {
        if (i % m == 0) {
            result += 1;
        }
    }
    return result;
}

",,,,-2,1,0.20967958370844522,code_expression_exchange:None,0.0,0.0,
93,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
vector<vector<string>> sort_sublists(vector<vector<string>> input_list) {
    for(auto &sublist : input_list) {
        sort(sublist.begin(), sublist.end());
//begin to write code
",278,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<vector<string>> sort_sublists(vector<vector<string>> input_list) {
    for(auto &sublist : input_list) {
        sort(sublist.begin(), sublist.end());
    }
    return input_list;
}


","
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<vector<string>> sort_sublists(vector<vector<string>> input_list) {
    for(auto &sublist : input_list) {
        sort(sublist.begin(), sublist.end());
    }
    return input_list;
}

",,,,-2,1,0.19367185433705647,code_expression_exchange:None,0.0,0.0,
94,"#include<iostream>
#include <vector>
#include <numeric>
#include <cassert>
int count(const std::vector<bool>& lst) {
//begin to write code
",139,"#include<iostream>
    

#include <vector>
#include <numeric>
#include <cassert>

int count(const std::vector<bool>& lst) {
    return std::accumulate(lst.begin(), lst.end(), 0);
}


","
#include<iostream>
#include <vector>
#include <numeric>
#include <cassert>

int count(const std::vector<bool>& lst) {
    return std::count(lst.begin(), lst.end(), true);
}

","#include<iostream>
#include <vector>
#include <numeric>
#include <cassert>
long count(const std::vector<bool>& lst) {
//begin to write code
","#include<iostream>
    

#include <vector>
#include <numeric>
#include <cassert>

long count(const std::vector<bool>& lst) {
    return std::accumulate(lst.begin(), lst.end(), 0);
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<numeric>

long count(const std::vector<bool>& lst) {
    long count = 0;
    for (bool bit : lst) {
        if (bit) {
            count++;
        }
    }
    return count;
}

",1,7,0.8516288002332052,code_expression_exchange:exchange_operators,1.0,0.0,"{'#include<iostream>\n    \n\n#include <vector>\n#include <numeric>\n#include <cassert>\n\nlong count(const std::vector<bool>& lst) {\n    return std::accumulate(lst.begin(), lst.end(), 0);\n}\n\n\n': [('#include<iostream>\n#include <vector>\n#include <numeric>\n#include <cassert>\nint count(const std::vector<bool>& lst) {\n//begin to write code\n', 'using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<numeric>\n#include<assert.h>\n\nint count(const std::vector<bool>& lst) {\n    return std::count_if(lst.begin(), lst.end(), [](bool x) { return x; });\n}\n', 'bool2int'), ('#include<iostream>\n#include <vector>\n#include <numeric>\n#include <cassert>\nlong count(const std::vector<bool>& lst) {\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <numeric>\n#include <cassert>\n\nlong count(const std::vector<bool>& lst) {\n    long count = 0;\n    for (const auto& bit : lst) {\n        if (bit) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n', 'more_universe_var_type'), ('#include<iostream>\n#include <vector>\n#include <numeric>\n#include <cassert>\nlong count(const std::vector<bool>& lst) {\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<numeric>\n\nlong count(const std::vector<bool>& lst) {\n    long count = 0;\n    for (bool bit : lst) {\n        if (bit) {\n            count++;\n        }\n    }\n    return count;\n}\n\n', 'exchange_operators')]}"
95,"#include<iostream>
#include <vector>
#include <tuple>
#include <cassert>
std::tuple<int, int, int, int, int> add_lists(std::vector<int> test_list, std::tuple<int, int> test_tup) {
    int first, second;
//begin to write code
",225,"#include<iostream>
    

#include <vector>
#include <tuple>
#include <cassert>

std::tuple<int, int, int, int, int> add_lists(std::vector<int> test_list, std::tuple<int, int> test_tup) {
    int first, second;
    std::tie(first, second) = test_tup;
    return std::make_tuple(first, second, test_list[0], test_list[1], test_list[2]);
}


","
#include<iostream>
#include <vector>
#include <tuple>
#include <cassert>

std::tuple<int, int, int, int, int> add_lists(std::vector<int> test_list, std::tuple<int, int> test_tup) {
    // Initialize the result tuple with the same type as the input tuples
    auto result = std::make_tuple(test_tup);

    // Iterate over the elements of the test_list
    for (size_t i = 0; i < test_list.size(); ++i) {
        // Add the current element to the result tuple
        result = std::make_tuple(result, test_list[i]);
    }

    return result;
}

",,,,-2,1,0.22369138797124227,code_expression_exchange:None,0.0,0.0,
96,"#include <iostream>
#include <cassert>
int count_Hexadecimal(int L, int R) {
    int count = 0;  
    for (int i = L; i <= R; i++) { 
        if (i >= 10 && i <= 15) { 
            count++;  
        } else if (i > 15) { 
            int k = i;  
            while (k != 0) {  
//begin to write code
",300,"
#include <iostream>
#include <cassert>

int count_Hexadecimal(int L, int R) {
    int count = 0;  
    for (int i = L; i <= R; i++) { 
        if (i >= 10 && i <= 15) { 
            count++;  
        } else if (i > 15) { 
            int k = i;  
            while (k != 0) {  
                if (k % 16 >= 10) { 
                    count++;  
                }
                k = k / 16;  
            }
        }
    }
    return count;  
}


","
using namespace std;
#include <iostream>
#include <cassert>

int count_Hexadecimal(int L, int R) {
    int count = 0;  
    for (int i = L; i <= R; i++) { 
        if (i >= 10 && i <= 15) { 
            count++;  
        } else if (i > 15) { 
            int k = i;  
            while (k!= 0) {  
                //begin to write code
                cout << ""Hexadecimal: "" << hex << k << endl; 
                k /= 16;  
            }
            cout << endl;  
        }
    }
    return count;
}

","#include <iostream>
#include <cassert>
int count_Hexadecimal(int L, int R) {
    int count = 0;  
    for (int i = L; i <= R; i++) { 
        if (i >= 10 && i <= 15) { 
            count++;  
        } else if (i > 15) { 
            int k = i;  
            while (k != 0) {  
//begin to write code
","
#include <iostream>
#include <cassert>

int count_Hexadecimal(int L, int R) {
    int count = 0;  
    for (int i = L; i <= R; i++) { 
        if (i >= 10 && i <= 15) { 
            count++;  
        } else if (i > 15) { 
            int k = i;  
            while (k != 0) {  
                if (k % 16 >= 10) { 
                    count++;  
                }
                k = k / 16;  
            }
        }
    }
    return count;  
}


","
#include <iostream>
#include <cassert>

int count_Hexadecimal(int L, int R) {
    int count = 0;
    for (int i = L; i <= R; ++i) {
        if (i >= 10 && i <= 15) { // Check if the number is between 10 and 15
            count++;
        } else if (i > 15) { // Check if the number is greater than 15
            int k = i;
            while (k!= 0) { // Convert the number to its hexadecimal representation
                int digit = k % 16;
                if (digit < 10) {
                    std::cout << '0' << digit;
                } else {
                    std::cout << 'A' + digit - 10;
                }
                k /= 16;
            }
            std::cout << std::",1,3,0.4956066409746806,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nint count_Hexadecimal(int L, int R) {\n    int count = 0;  \n    for (int i = L; i <= R; i++) { \n        if (i >= 10 && i <= 15) { \n            count++;  \n        } else if (i > 15) { \n            int k = i;  \n            while (k != 0) {  \n                if (k % 16 >= 10) { \n                    count++;  \n                }\n                k = k / 16;  \n            }\n        }\n    }\n    return count;  \n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint count_Hexadecimal(int L, int R) {\n    int count = 0;  \n    for (int i = L; i <= R; i++) { \n        if (i >= 10 && i <= 15) { \n            count++;  \n        } else if (i > 15) { \n            int k = i;  \n            while (k != 0) {  \n//begin to write code\n', ""\n#include <iostream>\n#include <cassert>\n\nint count_Hexadecimal(int L, int R) {\n    int count = 0;\n    for (int i = L; i <= R; ++i) {\n        if (i >= 10 && i <= 15) { // Check if the number is between 10 and 15\n            count++;\n        } else if (i > 15) { // Check if the number is greater than 15\n            int k = i;\n            while (k!= 0) { // Convert the number to its hexadecimal representation\n                int digit = k % 16;\n                if (digit < 10) {\n                    std::cout << '0' << digit;\n                } else {\n                    std::cout << 'A' + digit - 10;\n                }\n                k /= 16;\n            }\n            std::cout << std::"", 'bool2int')]}"
97,"#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;
vector<int> merge_sorted_list(vector<int> num1, vector<int> num2, vector<int> num3) {
    sort(num1.begin(), num1.end());
    sort(num2.begin(), num2.end());
    sort(num3.begin(), num3.end());
//begin to write code
",314,"#include<iostream>
    

#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

vector<int> merge_sorted_list(vector<int> num1, vector<int> num2, vector<int> num3) {
    sort(num1.begin(), num1.end());
    sort(num2.begin(), num2.end());
    sort(num3.begin(), num3.end());
    num1.insert(num1.end(), num2.begin(), num2.end());
    num1.insert(num1.end(), num3.begin(), num3.end());
    sort(num1.begin(), num1.end());
    return num1;
}


","
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

vector<int> merge_sorted_list(vector<int> num1, vector<int> num2, vector<int> num3) {
    // Sort all input vectors
    sort(num1.begin(), num1.end());
    sort(num2.begin(), num2.end());
    sort(num3.begin(), num3.end());

    // Initialize a new vector to store the merged result
    vector<int> merged;
    int i = 0, j = 0, k = 0;

    // Merge the three sorted vectors
    while (i < num1.size() && j < num2.size() && k < num3.size()) {
        if (num1[i] <= num2[j] && num1[i] <= num3[k]) {
            merged.push_back(num1[i]);
            i++;
        } else if (num2[j] <= num1[i] && num2[j] <= num3[k]) {
            merged.push_back(num2[j]);
            j++;
        } else {
            merged.push_back(num3[k]);
            k++;
        }
    }

    // Add any remaining elements from num1, num",,,,-2,1,0.22001306215922037,code_expression_exchange:None,0.0,0.0,
98,"#include <iostream>
#include <cassert>
int odd_Equivalent(const std::string& s, int n) {
    int count = 0;
    for (int i = 0; i < n; ++i) {
        if (s[i] == '1') {
//begin to write code
",191,"
#include <iostream>
#include <cassert>

int odd_Equivalent(const std::string& s, int n) {
    int count = 0;
    for (int i = 0; i < n; ++i) {
        if (s[i] == '1') {
            count += 1;
        }
    }
    return count;
}


","
using namespace std;

#include <iostream>
#include <cassert>

int odd_Equivalent(const std::string& s, int n) {
    int count = 0;
    for (int i = 0; i < n; ++i) {
        if (s[i] == '1') {
            count += 1;
            if (count % 2!= 0) {
                // This is an odd equivalent rotation
                break;
            }
        }
    }
    return count;
}

",,,,-2,1,0.23101908763249715,code_expression_exchange:None,0.0,0.0,
99,"#include<iostream>
#include <vector>
#include <utility>
#include <cassert>
using namespace std;
vector<pair<int, int>> extract_missing(vector<pair<int, int>> test_list, int strt_val, int stop_val) {
    vector<pair<int, int>> res;
    for (auto sub : test_list) {
        if (sub.first > strt_val) {
            res.push_back(make_pair(strt_val, sub.first));
            strt_val = sub.second;
//begin to write code
",416,"#include<iostream>
    

#include <vector>
#include <utility>
#include <cassert>

using namespace std;

vector<pair<int, int>> extract_missing(vector<pair<int, int>> test_list, int strt_val, int stop_val) {
    vector<pair<int, int>> res;
    for (auto sub : test_list) {
        if (sub.first > strt_val) {
            res.push_back(make_pair(strt_val, sub.first));
            strt_val = sub.second;
        }
    }
    if (strt_val < stop_val) {
        res.push_back(make_pair(strt_val, stop_val));
    }
    return res;
}


","
#include<iostream>
#include <vector>
#include <utility>
#include <cassert>
using namespace std;

vector<pair<int, int>> extract_missing(vector<pair<int, int>> test_list, int strt_val, int stop_val) {
    vector<pair<int, int>> res;
    for (auto sub : test_list) {
        if (sub.first > strt_val) {
            res.push_back(make_pair(strt_val, sub.first));
            strt_val = sub.second;
        } else {
            // If sub.first is less than or equal to strt_val, add the current sub to res
            res.push_back(sub);
        }
    }
    return res;
}

",,,,-2,1,0.23903671105702717,code_expression_exchange:None,0.0,0.0,
100,"#include<cassert>
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
std::vector<int> common_in_nested_lists(std::vector<std::vector<int>> nestedlist) {
    std::set<int> result_set;
    bool first = true;
    for (const auto& list : nestedlist) {
        std::set<int> current_set(list.begin(), list.end());
        if (first) {
            result_set = current_set;
            first = false;
//begin to write code
",440,"#include<cassert>
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>

std::vector<int> common_in_nested_lists(std::vector<std::vector<int>> nestedlist) {
    std::set<int> result_set;
    bool first = true;

    for (const auto& list : nestedlist) {
        std::set<int> current_set(list.begin(), list.end());
        if (first) {
            result_set = current_set;
            first = false;
        } else {
            std::set<int> temp;
            std::set_intersection(result_set.begin(), result_set.end(), current_set.begin(), current_set.end(),
                                  std::inserter(temp, temp.begin()));
            result_set = temp;
        }
    }

    return std::vector<int>(result_set.begin(), result_set.end());
}


","#include<cassert>
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
std::vector<int> common_in_nested_lists(std::vector<std::vector<int>> nestedlist) {
    std::set<int> result_set;
    for (const auto& list : nestedlist) {
        std::set<int> current_set(list.begin(), list.end());
        result_set.insert(current_set.begin(), current_set.end());
    }
    return std::vector<int>(result_set.begin(), result_set.end());
}
",,,,-2,1,0.18063203493754068,code_expression_exchange:None,0.0,0.0,
101,"#include<iostream>
#include <cassert>
int perimeter(int diameter, int height) {
//begin to write code
",102,"#include<iostream>
    

#include <cassert>

int perimeter(int diameter, int height) {
    return 2 * (diameter + height);
}


","
using namespace std;

#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<assert.h>

int perimeter(int diameter, int height) {
    return 2 * (diameter + height);
}

","#include<iostream>
#include <cassert>
long perimeter(int diameter, int height) {
//begin to write code
","#include<iostream>
    

#include <cassert>

long perimeter(int diameter, int height) {
    return 2 * (diameter + height);
}


","
#include <iostream>
#include <cassert>

long perimeter(int diameter, int height) {
    // Calculate the radius using the diameter
    double radius = diameter / 2.0;
    
    // Calculate the perimeter using the formula
    long perimeter = 2 * M_PI * radius * height;
    
    return perimeter;
}

",1,5,0.6264103213946025,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<iostream>\n    \n\n#include <cassert>\n\nlong perimeter(int diameter, int height) {\n    return 2 * (diameter + height);\n}\n\n\n': [('#include<iostream>\n#include <cassert>\nint perimeter(int diameter, int height) {\n//begin to write code\n', 'using namespace std;\n\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<assert.h>\n\nint perimeter(int diameter, int height) {\n    return 2 * (diameter + height);\n}\n', 'bool2int'), ('#include<iostream>\n#include <cassert>\nlong perimeter(int diameter, int height) {\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nlong perimeter(int diameter, int height) {\n    // Calculate the radius using the diameter\n    double radius = diameter / 2.0;\n    \n    // Calculate the perimeter using the formula\n    long perimeter = 2 * M_PI * radius * height;\n    \n    return perimeter;\n}\n\n', 'more_universe_var_type')]}"
102,"#include<cassert>
#include <iostream>
#include <string>
#include <cctype>
bool check_integer(const std::string& text) {
    std::string str = text;
    str.erase(0, str.find_first_not_of(' '));
    str.erase(str.find_last_not_of(' ') + 1);
    if (str.empty()) {
        return false;
    }
    if (str[0] == '+' || str[0] == '-') {
        str = str.substr(1);
    }
//begin to write code
",390,"#include<cassert>
#include <iostream>
#include <string>
#include <cctype>

bool check_integer(const std::string& text) {
    std::string str = text;
    str.erase(0, str.find_first_not_of(' '));
    str.erase(str.find_last_not_of(' ') + 1);

    if (str.empty()) {
        return false;
    }

    if (str[0] == '+' || str[0] == '-') {
        str = str.substr(1);
    }

    if (str.empty()) {
        return false;
    }

    for (char c : str) {
        if (!isdigit(c)) {
            return false;
        }
    }

    return true;
}


","using namespace std;

#include<cassert>
#include <iostream>
#include <string>
#include <cctype>

bool check_integer(const std::string& text) {
    std::string str = text;
    str.erase(0, str.find_first_not_of(' '));
    str.erase(str.find_last_not_of(' ') + 1);
    if (str.empty()) {
        return false;
    }
    if (str[0] == '+' || str[0] == '-') {
        str = str.substr(1);
    }
    // Check if the first character is a digit
    if (!isdigit(str[0])) {
        return false;
    }
    // Check if the rest of the string is a valid number
    for (char c : str) {
        if (!isdigit(c)) {
            return false;
        }
    }
    return true;
}
","#include<cassert>
#include <iostream>
#include <string>
#include <cctype>
bool check_integer(const std::string& text) {
    std::string str = text;
    str.erase(0, str.find_first_not_of(' '));
    str.erase(str.find_last_not_of(' ') + 1);
    if (str.empty()) {
        return 0;
    }
    if (str[0] == '+' || str[0] == '-') {
        str = str.substr(1);
    }
//begin to write code
","#include<cassert>
#include <iostream>
#include <string>
#include <cctype>

bool check_integer(const std::string& text) {
    std::string str = text;
    str.erase(0, str.find_first_not_of(' '));
    str.erase(str.find_last_not_of(' ') + 1);

    if (str.empty()) {
        return 0;
    }

    if (str[0] == '+' || str[0] == '-') {
        str = str.substr(1);
    }

    if (str.empty()) {
        return 0;
    }

    for (char c : str) {
        if (!isdigit(c)) {
            return 0;
        }
    }

    return 1;
}


","#include <cassert>
#include <iostream>
#include <string>
#include <cctype>
bool check_integer(const std::string& text) {
    std::string str = text;
    str.erase(0, str.find_first_not_of(' '));
    str.erase(str.find_last_not_of(' ') + 1);
    if (str.empty()) {
        return 0;
    }
    if (str[0] == '+' || str[0] == '-') {
        str = str.substr(1);
    }
    return std::isdigit(str[0]);
}
",1,3,0.4763143539428711,code_expression_exchange:bool2int,1.0,0.0,"{""#include<cassert>\n#include <iostream>\n#include <string>\n#include <cctype>\n\nbool check_integer(const std::string& text) {\n    std::string str = text;\n    str.erase(0, str.find_first_not_of(' '));\n    str.erase(str.find_last_not_of(' ') + 1);\n\n    if (str.empty()) {\n        return 0;\n    }\n\n    if (str[0] == '+' || str[0] == '-') {\n        str = str.substr(1);\n    }\n\n    if (str.empty()) {\n        return 0;\n    }\n\n    for (char c : str) {\n        if (!isdigit(c)) {\n            return 0;\n        }\n    }\n\n    return 1;\n}\n\n\n"": [(""#include<cassert>\n#include <iostream>\n#include <string>\n#include <cctype>\nbool check_integer(const std::string& text) {\n    std::string str = text;\n    str.erase(0, str.find_first_not_of(' '));\n    str.erase(str.find_last_not_of(' ') + 1);\n    if (str.empty()) {\n        return 0;\n    }\n    if (str[0] == '+' || str[0] == '-') {\n        str = str.substr(1);\n    }\n//begin to write code\n"", ""#include <cassert>\n#include <iostream>\n#include <string>\n#include <cctype>\nbool check_integer(const std::string& text) {\n    std::string str = text;\n    str.erase(0, str.find_first_not_of(' '));\n    str.erase(str.find_last_not_of(' ') + 1);\n    if (str.empty()) {\n        return 0;\n    }\n    if (str[0] == '+' || str[0] == '-') {\n        str = str.substr(1);\n    }\n    return std::isdigit(str[0]);\n}\n"", 'bool2int')]}"
103,"#include <vector>
#include <unordered_map>
#include <sstream>
#include <cassert>
#include <iostream>
using namespace std;
struct VectorHash {
    size_t operator()(const vector<int>& v) const {
        hash<int> hasher;
        size_t seed = 0;
        for (int i : v) {
            seed ^= hasher(i) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
        }
        return seed;
    }
};
vector<vector<int>> assign_freq(vector<vector<int>> test_list) {
    unordered_map<vector<int>,int,VectorHash> counter;
//begin to write code
",525,"#include <vector>
#include <unordered_map>
#include <sstream>
#include <cassert>
#include <iostream>

using namespace std;


struct VectorHash {
    size_t operator()(const vector<int>& v) const {
        hash<int> hasher;
        size_t seed = 0;
        for (int i : v) {
            seed ^= hasher(i) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
        }
        return seed;
    }
};

vector<vector<int>> assign_freq(vector<vector<int>> test_list) {
    unordered_map<vector<int>,int,VectorHash> counter;
    for(auto v:test_list)
    {
        counter[v] += 1;
    }
    
    vector<vector<int>> ret;
    for(auto onepair:counter)
    {
        vector<int> res = onepair.first;
        res.push_back(onepair.second);
        ret.push_back(res);
    }
    return ret;
    
}","#include <vector>
#include <unordered_map>
#include <sstream>
#include <cassert>
#include <iostream>
using namespace std;
struct VectorHash {
    size_t operator()(const vector<int>& v) const {
        hash<int> hasher;
        size_t seed = 0;
        for (int i : v) {
            seed ^= hasher(i) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
        }
        return seed;
    }
};

vector<vector<int>> assign_freq(vector<vector<int>> test_list) {
    unordered_map<vector<int>, int, VectorHash> counter;
    for (auto& vec : test_list) {
        for (int num : vec) {
            counter[num]++;
        }
    }
    return counter;
}
",,,,-2,1,0.1930006265640259,code_expression_exchange:None,0.0,0.0,
104,"#include <iostream>
#include <vector>
#include <map>
#include <cassert>
bool empty_dict(const std::vector<std::map<int, int>>& list1) {
    for (const auto& dict : list1) {
        if (!dict.empty()) return false;
//begin to write code
",236,"
#include <iostream>
#include <vector>
#include <map>
#include <cassert>

bool empty_dict(const std::vector<std::map<int, int>>& list1) {
    for (const auto& dict : list1) {
        if (!dict.empty()) return false;
    }
    return true;
}


","
#include <iostream>
#include <vector>
#include <map>
#include <cassert>

bool empty_dict(const std::vector<std::map<int, int>>& list1) {
    for (const auto& dict : list1) {
        if (!dict.empty()) return false;
    }
    return true;
}

","#include <iostream>
#include <vector>
#include <map>
#include <cassert>
bool empty_dict(const std::vector<std::map<long, long>>& list1) {
    for (const auto& dict : list1) {
        if (!dict.empty()) return 0;
//begin to write code
","
#include <iostream>
#include <vector>
#include <map>
#include <cassert>

bool empty_dict(const std::vector<std::map<long, long>>& list1) {
    for (const auto& dict : list1) {
        if (!dict.empty()) return 0;
    }
    return 1;
}


","#include <iostream>
#include <vector>
#include <map>
#include <cassert>

bool empty_dict(const std::vector<std::map<long, long>>& list1) {
    for (const auto& dict : list1) {
        if (!dict.empty()) return 0;
    }
    return 1;
}
",-1,21,2.952789080142975,code_expression_exchange:equal_expression_transformation,1.0,0.692910285130828,"{'\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nbool empty_dict(const std::vector<std::map<long, long>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n    }\n    return 1;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nbool empty_dict(const std::vector<std::map<long, int>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return false;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nbool empty_dict(const std::vector<std::map<long, int>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return false;\n    }\n    return true;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nbool empty_dict(const std::vector<std::map<long, int>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nbool empty_dict(const std::vector<std::map<long, int>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n    }\n    return 1; // All dictionaries are empty\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nbool empty_dict(const std::vector<std::map<long, int>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n//begin to write code\n', 'using namespace std;\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nbool empty_dict(const std::vector<std::map<long, int>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n    }\n    return true;\n}\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nbool empty_dict(const std::vector<std::map<long, int>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nbool empty_dict(const std::vector<std::map<long, int>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n    }\n    return true; // All dictionaries are empty\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nbool empty_dict(const std::vector<std::map<long, int>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nbool empty_dict(const std::vector<std::map<long, int>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n    }\n    return 1; // All dictionaries are empty\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nbool empty_dict(const std::vector<std::map<long, int>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nbool empty_dict(const std::vector<std::map<long, int>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n    }\n    return 1; // All dictionaries are empty\n}\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nbool empty_dict(const std::vector<std::map<long, int>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nbool empty_dict(const std::vector<std::map<long, int>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n    }\n    return 1; // All dictionaries are empty\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nbool empty_dict(const std::vector<std::map<long, long>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nbool empty_dict(const std::vector<std::map<long, long>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n    }\n    return true;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nbool empty_dict(const std::vector<std::map<long, long>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n//begin to write code\n', 'using namespace std;\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nbool empty_dict(const std::vector<std::map<long, long>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n    }\n    return 1;\n}\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nbool empty_dict(const std::vector<std::map<long, long>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nbool empty_dict(const std::vector<std::map<long, long>>& list1) {\n    for (const auto& dict : list1) {\n        if (!dict.empty()) return 0;\n    }\n    return 1;\n}\n', 'equal_expression_transformation')]}"
105,"#include <iostream>
#include <vector>
#include <string>
#include <cassert>
int tuple_to_int(const std::vector<int>& nums) {
    std::string result;
    for (int num : nums) {
//begin to write code
",197,"
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

int tuple_to_int(const std::vector<int>& nums) {
    std::string result;
    for (int num : nums) {
        result += std::to_string(num);
    }
    return std::stoi(result);
}


","
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

int tuple_to_int(const std::vector<int>& nums) {
    std::string result;
    for (int num : nums) {
        result += std::to_string(num);
    }
    return std::stoi(result);
}

","#include <iostream>
#include <vector>
#include <string>
#include <cassert>
long tuple_to_int(const std::vector<int>& nums) {
    std::string result;
    for (long num : nums) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

long tuple_to_int(const std::vector<int>& nums) {
    std::string result;
    for (long num : nums) {
        result = result + (std::to_string(num));
    }
    return std::stoi(result);
}


","
using namespace std;

long tuple_to_int(const std::vector<int>& nums) {
    long result = 0;
    for (int num : nums) {
        result *= 10; // Multiply the current result by 10 to shift the number to the left
        result += num; // Add the current number to the result
    }
    return result;
}

// Test cases
void test_tuple_to_int() {
    assert(tuple_to_int({1, 2, 3}) == 123);
    assert(tuple_to_int({10, 20, 30}) == 102030);
    assert(tuple_to_int({100, 200, 300}) == 100200300);
    cout << ""All test cases passed!"" << endl;
}

",1,17,2.2715503454208372,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nlong tuple_to_int(const std::vector<int>& nums) {\n    std::string result;\n    for (long num : nums) {\n        result = result + (std::to_string(num));\n    }\n    return std::stoi(result);\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nint tuple_to_int(const std::vector<int>& nums) {\n    std::string result;\n    for (int num : nums) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nint tuple_to_int(const std::vector<int>& nums) {\n    int result = 0;\n    for (int num : nums) {\n        result *= 10; // Multiply the result by 10 each time\n        result += num; // Add the current number to the result\n    }\n    return result;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nlong tuple_to_int(const std::vector<int>& nums) {\n    std::string result;\n    for (int num : nums) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nlong tuple_to_int(const std::vector<int>& nums) {\n    long result = 0;\n    for (int num : nums) {\n        result *= 10;\n        result += num;\n    }\n    return result;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nlong tuple_to_int(const std::vector<int>& nums) {\n    std::string result;\n    for (int num : nums) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nlong tuple_to_int(const std::vector<int>& nums) {\n    long result = 0;\n    for (int num : nums) {\n        result *= 10;\n        result += num;\n    }\n    return result;\n}\n\nvoid check() {\n    assert(tuple_to_int({1, 2, 3}) == 6);\n    assert(tuple_to_int({0, 0, 0}) == 0);\n    assert(tuple_to_int({-1, -2, -3}) == -6);\n    assert(tuple_to_int({100, 200, 300}) == 600);\n    cout << ""All tests passed successfully."" << endl;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nlong tuple_to_int(const std::vector<int>& nums) {\n    std::string result;\n    for (int num : nums) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nlong tuple_to_int(const std::vector<int>& nums) {\n    long result = 0;\n    for (int num : nums) {\n        result *= 10;\n        result += num;\n    }\n    return result;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nlong tuple_to_int(const std::vector<int>& nums) {\n    std::string result;\n    for (int num : nums) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nlong tuple_to_int(const std::vector<int>& nums) {\n    long result = 0;\n    for (int num : nums) {\n        result *= 10;\n        result += num;\n    }\n    return result;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nlong tuple_to_int(const std::vector<int>& nums) {\n    std::string result;\n    for (long num : nums) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nlong tuple_to_int(const std::vector<int>& nums) {\n    long result = 0;\n    for (int num : nums) {\n        result *= 10;\n        result += num;\n    }\n    return result;\n}\n\n// Test cases\nvoid test_tuple_to_int() {\n    assert(tuple_to_int({1, 2, 3}) == 6);\n    assert(tuple_to_int({10, 20, 30}) == 600);\n    assert(tuple_to_int({-1, -2, -3}) == -6);\n    assert(tuple_to_int({0}) == 0);\n    assert(tuple_to_int({1, 2, 3, 4, 5}) == 15);\n    std::cout << ""All test cases passed successfully."" << std::endl;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nlong tuple_to_int(const std::vector<int>& nums) {\n    std::string result;\n    for (long num : nums) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nlong tuple_to_int(const std::vector<int>& nums) {\n    long result = 0;\n    for (int num : nums) {\n        result *= 10;\n        result += num;\n    }\n    return result;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nlong tuple_to_int(const std::vector<int>& nums) {\n    std::string result;\n    for (long num : nums) {\n//begin to write code\n', '\nusing namespace std;\n\nlong tuple_to_int(const std::vector<int>& nums) {\n    long result = 0;\n    for (int num : nums) {\n        result *= 10; // Multiply the current result by 10 to shift the number to the left\n        result += num; // Add the current number to the result\n    }\n    return result;\n}\n\n// Test cases\nvoid test_tuple_to_int() {\n    assert(tuple_to_int({1, 2, 3}) == 123);\n    assert(tuple_to_int({10, 20, 30}) == 102030);\n    assert(tuple_to_int({100, 200, 300}) == 100200300);\n    cout << ""All test cases passed!"" << endl;\n}\n\n', 'exchange_operators')]}"
106,"#include<cassert>
#include <iostream>
#include <vector>
#include <string>
#include <cctype>
#include <sstream>
std::string list_to_float(std::vector<std::pair<std::string, std::string>> test_list) {
    std::vector<std::pair<float, float>> res;
    for (auto &tup : test_list) {
        float first, second;
        // Convert first element
        std::istringstream(tup.first) >> first;
        // Convert second element
        std::istringstream(tup.second) >> second;
        res.push_back({first, second});
//begin to write code
",535,"#include<cassert>
#include <iostream>
#include <vector>
#include <string>
#include <cctype>
#include <sstream>

std::string list_to_float(std::vector<std::pair<std::string, std::string>> test_list) {
    std::vector<std::pair<float, float>> res;
    for (auto &tup : test_list) {
        float first, second;
        // Convert first element
        std::istringstream(tup.first) >> first;
        // Convert second element
        std::istringstream(tup.second) >> second;
        res.push_back({first, second});
    }
    std::ostringstream oss;
    oss << '[';
    for (size_t i = 0; i < res.size(); ++i) {
        if (i > 0) oss << "", "";
        oss << '(' << res[i].first << "", "" << res[i].second << ')';
    }
    oss << ']';
    return oss.str();
}


","#include<cassert>
#include <iostream>
#include <vector>
#include <string>
#include <cctype>
#include <sstream>
#include <utility> // for std::pair

std::string list_to_float(std::vector<std::pair<std::string, std::string>> test_list) {
    std::vector<std::pair<float, float>> res;
    for (auto &tup : test_list) {
        float first, second;
        // Convert first element
        std::istringstream(tup.first) >> first;
        // Convert second element
        std::istringstream(tup.second) >> second;
        res.push_back({first, second});
    }
    return ""{"";
    for (size_t i = 0; i < res.size(); ++i) {
        if (i!= 0) {
            res.back().second += "", "";
        }
        res.back().second += std::to_string(res[i].first);
        res.back().second += "", "";
        res.back().second += std::to_string(res[i].second);
    }
    res.back().second += ""}"";
    return res;
}
",,,,-2,1,0.21884463230768839,code_expression_exchange:None,0.0,0.0,
107,"#include <iostream>
#include <sstream>
#include <vector>
#include <cassert>
std::vector<std::string> string_to_list(const std::string& str) {
    std::vector<std::string> result;
    std::istringstream iss(str);
    std::string s;
//begin to write code
",253,"
#include <iostream>
#include <sstream>
#include <vector>
#include <cassert>

std::vector<std::string> string_to_list(const std::string& str) {
    std::vector<std::string> result;
    std::istringstream iss(str);
    std::string s;
    while (iss >> s) {
        result.push_back(s);
    }
    return result;
}


","
#include <iostream>
#include <sstream>
#include <vector>
#include <cassert>
#include <string>

std::vector<std::string> string_to_list(const std::string& str) {
    std::vector<std::string> result;
    std::istringstream iss(str);
    std::string s;
    while (iss >> s) {
        result.push_back(s);
    }
    return result;
}

","#include <iostream>
#include <sstream>
#include <vector>
#include <cassert>
std::vector<std::string> string_to_list(const std::string& str) {
    std::vector<std::string> result;
    std::istringstream iss(str);
    std::string s;
//begin to write code
","
#include <iostream>
#include <sstream>
#include <vector>
#include <cassert>

std::vector<std::string> string_to_list(const std::string& str) {
    std::vector<std::string> result;
    std::istringstream iss(str);
    std::string s;
    while (iss >> s) {
        result.push_back(s);
    }
    return result;
}


","
using namespace std;
#include <iostream>
#include <sstream>
#include <vector>
#include <cassert>

std::vector<std::string> string_to_list(const std::string& str) {
    std::vector<std::string> result;
    std::istringstream iss(str);
    std::string s;
    while (iss >> s) {
        result.push_back(s);
    }
    return result;
}

",-1,21,2.6230604529380797,code_expression_exchange:more_universe_var_type,1.0,0.9373118689802573,"{'\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\n\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n    while (iss >> s) {\n        result.push_back(s);\n    }\n    return result;\n}\n\n\n': [('#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\n\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n    while (iss >> s) {\n        result.push_back(s);\n    }\n    return result;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\n\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n    while (iss >> s) {\n        result.push_back(s);\n    }\n    return result;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n//begin to write code\n', '\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\n\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n    while (iss >> s) {\n        result.push_back(s);\n    }\n    return result;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n//begin to write code\n', '#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\n\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n    while (iss >> s) {\n        result.push_back(s);\n    }\n    return result;\n}\n', 'bool2int'), ('#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\n\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n    while (iss >> s) {\n        result.push_back(s);\n    }\n    return result;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\n\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n    while (iss >> s) {\n        result.push_back(s);\n    }\n    return result;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n//begin to write code\n', '\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\n#include <string>\n\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n    while (iss >> s) {\n        result.push_back(s);\n    }\n    return result;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n//begin to write code\n', '#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n    while (iss >> s) {\n        result.push_back(s);\n    }\n    return result;\n}\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n//begin to write code\n', '#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n    while (iss >> s) {\n        result.push_back(s);\n    }\n    return result;\n}\n', 'bool2int'), ('#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cassert>\n\nstd::vector<std::string> string_to_list(const std::string& str) {\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string s;\n    while (iss >> s) {\n        result.push_back(s);\n    }\n    return result;\n}\n\n', 'more_universe_var_type')]}"
108,"#include <iostream>
#include <vector>
#include <cassert>
int search(const std::vector<int>& arr, int n) {
    int XOR = 0;
    for (int i = 0; i < n; i++) {
//begin to write code
",179,"
#include <iostream>
#include <vector>
#include <cassert>

int search(const std::vector<int>& arr, int n) {
    int XOR = 0;
    for (int i = 0; i < n; i++) {
        XOR = XOR ^ arr[i];
    }
    return XOR;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

int search(const std::vector<int>& arr, int n) {
    int XOR = 0;
    for (int i = 0; i < n; i++) {
        XOR ^= arr[i];
    }
    return XOR;
}

","#include <iostream>
#include <vector>
#include <cassert>
long search(const std::vector<long>& arr, long n) {
    long XOR = 0;
    for (long i = 0; i < n; i = 1 + i) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

long search(const std::vector<long>& arr, long n) {
    long XOR = 0;
    for (long i = 0; i < n; i = 1 + i) {
        XOR = arr[i] ^ XOR;
    }
    return XOR;
}


","
#include <iostream>
#include <vector>
#include <cassert>

long search(const std::vector<long>& arr, long n) {
    long XOR = 0;
    for (long i = 0; i < n; i = 1 + i) {
        XOR ^= arr[i];
    }
    return XOR;
}

",-1,21,2.698944266637166,code_expression_exchange:equal_expression_transformation,1.0,0.7200889919806077,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong search(const std::vector<long>& arr, long n) {\n    long XOR = 0;\n    for (long i = 0; i < n; i = 1 + i) {\n        XOR = arr[i] ^ XOR;\n    }\n    return XOR;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nint search(const std::vector<int>& arr, int n) {\n    int XOR = 0;\n    for (int i = 0; i < n; i = i + 1) {\n//begin to write code\n', '\nusing namespace std;\n#include <vector>\n#include <cassert>\n\nint search(const std::vector<int>& arr, int n) {\n    int XOR = 0;\n    for (int i = 0; i < n; i = i + 1) {\n        XOR ^= arr[i];\n    }\n    return XOR;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong search(const std::vector<int>& arr, int n) {\n    int XOR = 0;\n    for (int i = 0; i < n; i = i + 1) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong search(const std::vector<int>& arr, int n) {\n    long result = 0;\n    for (int i = 0; i < n; i++) {\n        result ^= arr[i];\n    }\n    return result;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong search(const std::vector<int>& arr, int n) {\n    int XOR = 0;\n    for (int i = 0; i < n; i = 1 + i) {\n//begin to write code\n', '\nusing namespace std;\n#include <vector>\n#include <assert.h>\n\nlong search(const std::vector<int>& arr, int n) {\n    long XOR = 0;\n    for (int i = 0; i < n; i = 1 + i) {\n        XOR ^= arr[i];\n    }\n    return XOR;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong search(const std::vector<int>& arr, int n) {\n    int XOR = 0;\n    for (int i = 0; i < n; i = 1 + i) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong search(const std::vector<int>& arr, int n) {\n    int XOR = 0;\n    for (int i = 0; i < n; i = 1 + i) {\n        XOR ^= arr[i];\n    }\n    return XOR;\n}\n\nvoid test_search() {\n    assert(search({1, 2, 3, 2, 4}, 5) == 1);\n    assert(search({1, 2, 3, 4, 5}, 6) == 4);\n    assert(search({1, 1, 1, 1, 1}, 5) == 1);\n    assert(search({10, 20, 30, 40, 50}, 60) == 50);\n    cout << ""All tests passed successfully."" << endl;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong search(const std::vector<int>& arr, int n) {\n    long XOR = 0;\n    for (int i = 0; i < n; i = 1 + i) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong search(const std::vector<int>& arr, int n) {\n    long XOR = 0;\n    for (int i = 0; i < n; i = 1 + i) {\n        XOR ^= arr[i];\n    }\n    return XOR;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong search(const std::vector<int>& arr, int n) {\n    long XOR = 0;\n    for (long i = 0; i < n; i = 1 + i) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong search(const std::vector<int>& arr, int n) {\n    long XOR = 0;\n    for (long i = 0; i < n; i = 1 + i) {\n        XOR ^= arr[i];\n    }\n    return XOR;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong search(const std::vector<long>& arr, int n) {\n    long XOR = 0;\n    for (long i = 0; i < n; i = 1 + i) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong search(const std::vector<long>& arr, int n) {\n    long XOR = 0;\n    for (int i = 0; i < n; i = 1 + i) {\n        XOR ^= arr[i];\n    }\n    return XOR;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong search(const std::vector<long>& arr, long n) {\n    long XOR = 0;\n    for (long i = 0; i < n; i = 1 + i) {\n//begin to write code\n', 'using namespace std;\n#include <vector>\n#include <assert.h>\n\nlong search(const std::vector<long>& arr, long n) {\n    long XOR = 0;\n    for (long i = 0; i < n; i = 1 + i) {\n        XOR ^= arr[i];\n    }\n    return XOR;\n}\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong search(const std::vector<long>& arr, long n) {\n    long XOR = 0;\n    for (long i = 0; i < n; i = 1 + i) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong search(const std::vector<long>& arr, long n) {\n    long XOR = 0;\n    for (long i = 0; i < n; i = 1 + i) {\n        XOR ^= arr[i];\n    }\n    return XOR;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong search(const std::vector<long>& arr, long n) {\n    long XOR = 0;\n    for (long i = 0; i < n; i = 1 + i) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong search(const std::vector<long>& arr, long n) {\n    long XOR = 0;\n    for (long i = 0; i < n; i = 1 + i) {\n        XOR ^= arr[i];\n    }\n    return XOR;\n}\n\n', 'equal_expression_transformation')]}"
109,"#include<cassert>
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
int max_product_tuple(const std::vector<std::pair<int, int>>& list1) {
    int result_max = 0;
    for (const auto& p : list1) {
        int product = std::abs(p.first * p.second);
        if (product > result_max) {
//begin to write code
",333,"#include<cassert>
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>

int max_product_tuple(const std::vector<std::pair<int, int>>& list1) {
    int result_max = 0;
    for (const auto& p : list1) {
        int product = std::abs(p.first * p.second);
        if (product > result_max) {
            result_max = product;
        }
    }
    return result_max;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

int max_product_tuple(const std::vector<std::pair<int, int>>& list1) {
    int result_max = 0;
    for (const auto& p : list1) {
        int product = std::abs(p.first * p.second);
        if (product > result_max) {
            result_max = product;
        }
    }
    return result_max;
}

",,,,-2,1,0.19732003211975097,code_expression_exchange:None,0.0,0.0,
110,"#include <iostream>
#include <vector>
#include <cassert>
bool check_triplet(const std::vector<int>& A, int n, int sum, int count) {
    if (count == 3 && sum == 0) {
        return true;
    }
//begin to write code
",215,"
#include <iostream>
#include <vector>
#include <cassert>

bool check_triplet(const std::vector<int>& A, int n, int sum, int count) {
    if (count == 3 && sum == 0) {
        return true;
    }
    if (count == 3 || n == 0 || sum < 0) {
        return false;
    }
    return check_triplet(A, n - 1, sum - A[n - 1], count + 1) || check_triplet(A, n - 1, sum, count);
}


","
using namespace std;
#include <vector>
#include <assert.h>

bool check_triplet(const vector<int>& A, int n, int sum, int count) {
    if (count == 3 && sum == 0) {
        return true;
    }

    // Sort the array to use two-pointer technique
    sort(A.begin(), A.end());

    for (int i = 0; i < n - 2; ++i) {
        int left = i + 1;
        int right = n - 1;

        while (left < right) {
            int current_sum = A[i] + A[left] + A[right];

            if (current_sum == sum) {
                return true;
            } else if (current_sum < sum) {
                left++;
            } else {
                right--;
            }
        }
    }

    return false;
}

",,,,-2,1,0.22382936477661133,code_expression_exchange:None,0.0,0.0,
111,"#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;
const int MAX = 3000;
int smartNumber(int n) {
    vector<int> primes(MAX, 0);
    vector<int> result;
    for (int i = 2; i < MAX; i++) {
        if (primes[i] == 0) {
            primes[i] = 1;
            int j = i * 2;
            while (j < MAX) {
                primes[j] -= 1;
//begin to write code
",405,"#include<iostream>
    

#include <vector>
#include <algorithm>
#include <cassert>

using namespace std;

const int MAX = 3000;

int smartNumber(int n) {
    vector<int> primes(MAX, 0);
    vector<int> result;

    for (int i = 2; i < MAX; i++) {
        if (primes[i] == 0) {
            primes[i] = 1;
            int j = i * 2;
            while (j < MAX) {
                primes[j] -= 1;
                if (primes[j] + 3 == 0) {
                    result.push_back(j);
                }
                j += i;
            }
        }
    }

    sort(result.begin(), result.end());
    return result[n - 1];
}


","
#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

const int MAX = 3000;
int smartNumber(int n) {
    vector<int> primes(MAX, 0);
    vector<int> result;
    for (int i = 2; i < MAX; i++) {
        if (primes[i] == 0) {
            primes[i] = 1;
            int j = i * 2;
            while (j < MAX) {
                primes[j] -= 1;
                //begin to write code
            }
        }
    }
    return primes[n];
}

",,,,-2,1,1.2278043071428935,code_expression_exchange:None,0.0,0.0,
112,"#include <iostream>
#include <set>
#include <stdexcept>
#include <cassert>
using namespace std;
int amicable_numbers_sum(int limit) {
    if (limit < 1) {
        throw invalid_argument(""Input must be bigger than 0!"");
    }
    set<int> amicables;
    for (int num = 2; num <= limit; num++) {
        if (amicables.find(num) != amicables.end()) {
            continue;
        }
        int sum_fact = 0;
        for (int fact = 1; fact < num; fact++) {
            if (num % fact == 0) {
                sum_fact += fact;
            }
        }
        int sum_fact2 = 0;
//begin to write code
",597,"
#include <iostream>
#include <set>
#include <stdexcept>
#include <cassert>
using namespace std;

int amicable_numbers_sum(int limit) {
    if (limit < 1) {
        throw invalid_argument(""Input must be bigger than 0!"");
    }
    set<int> amicables;
    for (int num = 2; num <= limit; num++) {
        if (amicables.find(num) != amicables.end()) {
            continue;
        }
        int sum_fact = 0;
        for (int fact = 1; fact < num; fact++) {
            if (num % fact == 0) {
                sum_fact += fact;
            }
        }
        int sum_fact2 = 0;
        for (int fact = 1; fact < sum_fact; fact++) {
            if (sum_fact % fact == 0) {
                sum_fact2 += fact;
            }
        }
        if (num == sum_fact2 && num != sum_fact) {
            amicables.insert(num);
            amicables.insert(sum_fact);
        }
    }
    int sum = 0;
    for (int val : amicables) {
        sum += val;
    }
    return sum;
}



","
#include <iostream>
#include <set>
#include <stdexcept>
#include <cassert>
using namespace std;

int amicable_numbers_sum(int limit) {
    if (limit < 1) {
        throw invalid_argument(""Input must be bigger than 0!"");
    }
    set<int> amicables;
    for (int num = 2; num <= limit; num++) {
        if (amicables.find(num)!= amicables.end()) {
            continue;
        }
        int sum_fact = 0;
        for (int fact = 1; fact < num; fact++) {
            if (num % fact == 0) {
                sum_fact += fact;
            }
        }
        int sum_fact2 = 0;
        for (int i = 1; i <= sqrt(num); ++i) {
            if (num % i == 0 && i!= num / i) {
                sum_fact2 += i;
                sum_fact2 += num / i;
            }
        }
        if (sum_fact == sum_fact2) {
            amicables.insert(num);
        }
    }
    return accumulate(begin(amicables), end(amicables), 0);
}

",,,,-2,1,0.23231244484583538,code_expression_exchange:None,0.0,0.0,
113,"#include <iostream>
#include <complex>
#include <cmath>
#include <cassert>
double angle_complex(double a, double b) {
  std::complex<double> cn(a, b);
//begin to write code
",173,"
#include <iostream>
#include <complex>
#include <cmath>
#include <cassert>

double angle_complex(double a, double b) {
  std::complex<double> cn(a, b);
  double angle = std::arg(cn);
  return angle;
}


","
using namespace std;
#include <iostream>
#include <complex>
#include <cmath>
#include <cassert>

double angle_complex(double a, double b) {
  std::complex<double> cn(a, b);
  return std::atan2(b, a);
}

",,,,-2,1,0.22798899014790852,code_expression_exchange:None,0.0,0.0,
114,"#include<cassert>
#include <iostream>
#include <algorithm>
int find_length(const std::string& string, int n) {
    int current_sum = 0;
    int max_sum = 0;
    for (int i = 0; i < n; ++i) {
        current_sum += (string[i] == '0' ? 1 : -1);
        if (current_sum < 0) {
//begin to write code
",296,"#include<cassert>
#include <iostream>
#include <algorithm>

int find_length(const std::string& string, int n) {
    int current_sum = 0;
    int max_sum = 0;
    for (int i = 0; i < n; ++i) {
        current_sum += (string[i] == '0' ? 1 : -1);
        if (current_sum < 0) {
            current_sum = 0;
        }
        max_sum = std::max(current_sum, max_sum);
    }
    return max_sum ? max_sum : 0;
}


","
#include <iostream>
#include <algorithm>
#include <string>

int find_length(const std::string& string, int n) {
    int current_sum = 0;
    int max_sum = 0;
    for (int i = 0; i < n; ++i) {
        current_sum += (string[i] == '0'? 1 : -1);
        if (current_sum < 0) {
            // Reset the sum when it goes negative
            current_sum = 0;
        }
        max_sum = std::max(max_sum, current_sum);
    }
    return max_sum;
}

",,,,-2,1,0.23191672960917156,code_expression_exchange:None,0.0,0.0,
115,"#include<cassert>
#include <iostream>
#include <algorithm>
int sum(int a, int b) {
    int sum = 0;
    for (int i = 1; i < std::min(a, b); i++) {
        if (a % i == 0 && b % i == 0) {
//begin to write code
",209,"#include<cassert>
#include <iostream>
#include <algorithm>

int sum(int a, int b) {
    int sum = 0;
    for (int i = 1; i < std::min(a, b); i++) {
        if (a % i == 0 && b % i == 0) {
            sum += i;
        }
    }
    return sum;
}


","
using namespace std;

#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

int sum(int a, int b) {
    int sum = 0;
    for (int i = 1; i < std::min(a, b); i++) {
        if (a % i == 0 && b % i == 0) {
            sum += i;
        }
    }
    return sum;
}

",,,,-2,1,0.22865875164667765,code_expression_exchange:None,0.0,0.0,
116,"#include <iostream>
#include <cassert>
int multiply_int(int x, int y) {
    if (y < 0) {
        return -multiply_int(x, -y);
    } else if (y == 0) {
        return 0;
//begin to write code
",191,"
#include <iostream>
#include <cassert>

int multiply_int(int x, int y) {
    if (y < 0) {
        return -multiply_int(x, -y);
    } else if (y == 0) {
        return 0;
    } else if (y == 1) {
        return x;
    } else {
        return x + multiply_int(x, y - 1);
    }
}


","
using namespace std;

#include <iostream>
#include <cassert>

int multiply_int(int x, int y) {
    if (y < 0) {
        return -multiply_int(x, -y);
    } else if (y == 0) {
        return 0;
    }
    return x * y;
}

","#include <iostream>
#include <cassert>
int multiply_int(int x, int y) {
    if (y < 0) {
        return -multiply_int(x, -y);
    } else if (y == 0) {
        return 0;
//begin to write code
","
#include <iostream>
#include <cassert>

int multiply_int(int x, int y) {
    if (y < 0) {
        return -multiply_int(x, -y);
    } else if (y == 0) {
        return 0;
    } else if (y == 1) {
        return x;
    } else {
        return x + multiply_int(x, y - 1);
    }
}


","
#include <iostream>
#include <cassert>

int multiply_int(int x, int y) {
    // Handle negative numbers
    if (y < 0) {
        return -multiply_int(x, -y);
    }
    
    // Use integer division to handle negative numbers
    int result = 0;
    while (y > 0) {
        // Calculate the remainder of y divided by 10
        int remainder = y % 10;
        // Multiply the result by the remainder
        result *= remainder;
        // Remove the last digit from y
        y /= 10;
    }
    
    return result;
}

",1,3,0.47002082665761313,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nint multiply_int(int x, int y) {\n    if (y < 0) {\n        return -multiply_int(x, -y);\n    } else if (y == 0) {\n        return 0;\n    } else if (y == 1) {\n        return x;\n    } else {\n        return x + multiply_int(x, y - 1);\n    }\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint multiply_int(int x, int y) {\n    if (y < 0) {\n        return -multiply_int(x, -y);\n    } else if (y == 0) {\n        return 0;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nint multiply_int(int x, int y) {\n    // Handle negative numbers\n    if (y < 0) {\n        return -multiply_int(x, -y);\n    }\n    \n    // Use integer division to handle negative numbers\n    int result = 0;\n    while (y > 0) {\n        // Calculate the remainder of y divided by 10\n        int remainder = y % 10;\n        // Multiply the result by the remainder\n        result *= remainder;\n        // Remove the last digit from y\n        y /= 10;\n    }\n    \n    return result;\n}\n\n', 'equal_expression_transformation')]}"
117,"#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <cassert>
std::vector<std::string> long_words(int n, const std::string &str) {
    std::vector<std::string> word_len;
    std::istringstream iss(str);
    std::string word;
    while (iss >> word) {
//begin to write code
",305,"
#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <cassert>

std::vector<std::string> long_words(int n, const std::string &str) {
    std::vector<std::string> word_len;
    std::istringstream iss(str);
    std::string word;
    while (iss >> word) {
        if (word.length() > n) {
            word_len.push_back(word);
        }
    }
    return word_len;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <cassert>

std::vector<std::string> long_words(int n, const std::string &str) {
    std::vector<std::string> word_len;
    std::istringstream iss(str);
    std::string word;
    while (iss >> word) {
        if (word.length() > n) {
            word_len.push_back(word);
        }
    }
    return word_len;
}

","#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <cassert>
std::vector<std::string> long_words(long n, const std::string &str) {
    std::vector<std::string> word_len;
    std::istringstream iss(str);
    std::string word;
    while (iss >> word) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <cassert>

std::vector<std::string> long_words(long n, const std::string &str) {
    std::vector<std::string> word_len;
    std::istringstream iss(str);
    std::string word;
    while (iss >> word) {
        if (word.length() > n) {
            word_len.push_back(word);
        }
    }
    return word_len;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <cassert>

std::vector<std::string> long_words(long n, const std::string &str) {
    std::vector<std::string> word_len;
    std::istringstream iss(str);
    std::string word;
    while (iss >> word) {
        if (word.length() > n) {
            word_len.push_back(word);
        }
    }
    return word_len;
}

",-1,21,2.981634251276652,code_expression_exchange:exchange_operators,1.0,0.9239968290090061,"{'\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\n\nstd::vector<std::string> long_words(long n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n        if (word.length() > n) {\n            word_len.push_back(word);\n        }\n    }\n    return word_len;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\nstd::vector<std::string> long_words(int n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\n\nstd::vector<std::string> long_words(int n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n        if (word.length() > n) {\n            word_len.push_back(word);\n        }\n    }\n    return word_len;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\nstd::vector<std::string> long_words(int n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\nstd::vector<std::string> long_words(int n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n        if (word.length() > n) {\n            word_len.push_back(word);\n        }\n    }\n    return word_len;\n}\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\nstd::vector<std::string> long_words(int n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\n\nstd::vector<std::string> long_words(int n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n        if (word.length() > n) {\n            word_len.push_back(word);\n        }\n    }\n    return word_len;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\nstd::vector<std::string> long_words(long n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\n\nstd::vector<std::string> long_words(long n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n        if (word.length() > n) {\n            word_len.push_back(word);\n        }\n    }\n    return word_len;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\nstd::vector<std::string> long_words(long n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\n\nstd::vector<std::string> long_words(long n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n        if (word.length() > n) {\n            word_len.push_back(word);\n        }\n    }\n    return word_len;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\nstd::vector<std::string> long_words(long n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\nstd::vector<std::string> long_words(long n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n        if (word.length() > n) {\n            word_len.push_back(word);\n        }\n    }\n    return word_len;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\nstd::vector<std::string> long_words(long n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\n\nstd::vector<std::string> long_words(long n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n        if (word.length() > n) {\n            word_len.push_back(word);\n        }\n    }\n    return word_len;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\nstd::vector<std::string> long_words(long n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\nstd::vector<std::string> long_words(long n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n        if (word.length() > n) {\n            word_len.push_back(word);\n        }\n    }\n    return word_len;\n}\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\nstd::vector<std::string> long_words(long n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\n\nstd::vector<std::string> long_words(long n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n        if (word.length() > n) {\n            word_len.push_back(word);\n        }\n    }\n    return word_len;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\nstd::vector<std::string> long_words(long n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cassert>\n\nstd::vector<std::string> long_words(long n, const std::string &str) {\n    std::vector<std::string> word_len;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss >> word) {\n        if (word.length() > n) {\n            word_len.push_back(word);\n        }\n    }\n    return word_len;\n}\n\n', 'exchange_operators')]}"
118,"#include<cassert>
#include <iostream>
#include <vector>
#include <numeric>
#include <set>
bool magic_square_test(const std::vector<std::vector<int>>& my_matrix) {
    size_t iSize = my_matrix[0].size();
    std::vector<int> sum_list;
    // Sum of each row
    for (const auto& line : my_matrix) {
        sum_list.push_back(std::accumulate(line.begin(), line.end(), 0));
    }
    // Sum of each column
    for (size_t col = 0; col < iSize; ++col) {
        int col_sum = 0;
        for (size_t row = 0; row < iSize; ++row) {
            col_sum += my_matrix[row][col];
        }
        sum_list.push_back(col_sum);
    }
//begin to write code
",646,"#include<cassert>
#include <iostream>
#include <vector>
#include <numeric>
#include <set>

bool magic_square_test(const std::vector<std::vector<int>>& my_matrix) {
    size_t iSize = my_matrix[0].size();
    std::vector<int> sum_list;
    
    // Sum of each row
    for (const auto& line : my_matrix) {
        sum_list.push_back(std::accumulate(line.begin(), line.end(), 0));
    }

    // Sum of each column
    for (size_t col = 0; col < iSize; ++col) {
        int col_sum = 0;
        for (size_t row = 0; row < iSize; ++row) {
            col_sum += my_matrix[row][col];
        }
        sum_list.push_back(col_sum);
    }

    // Sum of main diagonal
    int result1 = 0;
    for (size_t i = 0; i < iSize; ++i) {
        result1 += my_matrix[i][i];
    }
    sum_list.push_back(result1);

    // Sum of secondary diagonal
    int result2 = 0;
    for (int i = iSize - 1; i >= 0; --i) {
        result2 += my_matrix[i][i];
    }
    sum_list.push_back(result2);

    // Check if all sums are the same
    std::set<int> unique_sums(sum_list.begin(), sum_list.end());
    return unique_sums.size() == 1;
}


","
#include <cassert>
#include <iostream>
#include <vector>
#include <numeric>
#include <set>

bool magic_square_test(const std::vector<std::vector<int>>& my_matrix) {
    size_t iSize = my_matrix[0].size();
    std::vector<int> sum_list;
    // Sum of each row
    for (const auto& line : my_matrix) {
        sum_list.push_back(std::accumulate(line.begin(), line.end(), 0));
    }
    // Sum of each column
    for (size_t col = 0; col < iSize; ++col) {
        int col_sum = 0;
        for (size_t row = 0; row < iSize; ++row) {
            col_sum += my_matrix[row][col];
        }
        sum_list.push_back(col_sum);
    }
    // Check if the magic square is symmetric
    bool is_symmetric = true;
    for (size_t i = 0; i < iSize / 2; ++i) {
        if (sum_list[i]!= sum_list[i + iSize - 1]) {
            is_symmetric = false;
            break;
        }
    }
    return is_sym",,,,-2,1,0.22260627746582032,code_expression_exchange:None,0.0,0.0,
119,"#include <iostream>
#include <vector>
#include <unordered_map>
#include <cassert>
#include <algorithm>
using namespace std;
pair<int, int> max_occurrences(vector<int> nums) {
    unordered_map<int, int> dict;
    for (int num : nums) {
        dict[num]++;
    }
//begin to write code
",285,"
#include <iostream>
#include <vector>
#include <unordered_map>
#include <cassert>
#include <algorithm>

using namespace std;

pair<int, int> max_occurrences(vector<int> nums) {
    unordered_map<int, int> dict;
    for (int num : nums) {
        dict[num]++;
    }
    return *max_element(dict.begin(), dict.end(), 
                        [](const pair<int, int>& a, const pair<int, int>& b) {
                            return a.second < b.second;
                        });
}


","#include <iostream>
#include <vector>
#include <unordered_map>
#include <cassert>
#include <algorithm>
using namespace std;

pair<int, int> max_occurrences(vector<int> nums) {
    unordered_map<int, int> dict;
    for (int num : nums) {
        dict[num]++;
    }

    int max_count = 0;
    int max_num = -1;

    for (const auto& pair : dict) {
        if (pair.second > max_count) {
            max_count = pair.second;
            max_num = pair.first;
        }
    }

    return {max_num, max_count};
}
",,,,-2,1,0.1841865340868632,code_expression_exchange:None,0.0,0.0,
120,"#include <iostream>
#include <string>
#include <cassert>
std::string reverse_vowels(std::string str1) {
    std::string vowels = """";
    for (char char1 : str1) {
        if (std::string(""aeiouAEIOU"").find(char1) != std::string::npos) {
            vowels += char1;
        }
    }
    std::string result_string = """";
    size_t vowel_index = vowels.length();
//begin to write code
",382,"
#include <iostream>
#include <string>
#include <cassert>

std::string reverse_vowels(std::string str1) {
    std::string vowels = """";
    for (char char1 : str1) {
        if (std::string(""aeiouAEIOU"").find(char1) != std::string::npos) {
            vowels += char1;
        }
    }
    std::string result_string = """";
    size_t vowel_index = vowels.length();
    for (char char1 : str1) {
        if (std::string(""aeiouAEIOU"").find(char1) != std::string::npos) {
            result_string += vowels[--vowel_index];
        }
        else {
            result_string += char1;
        }
    }
    return result_string;
}


","
#include <iostream>
#include <string>
#include <cassert>

std::string reverse_vowels(std::string str1) {
    std::string vowels = """";
    for (char char1 : str1) {
        if (std::string(""aeiouAEIOU"").find(char1)!= std::string::npos) {
            vowels += char1;
        }
    }
    std::string result_string = """";
    size_t vowel_index = vowels.length();
    for (size_t i = 0; i < vowel_index; ++i) {
        result_string += vowels[i];
    }
    for (size_t i = vowel_index; i < str1.length(); ++i) {
        result_string += str1[i];
    }
    return result_string;
}

",,,,-2,1,0.23907574017842612,code_expression_exchange:None,0.0,0.0,
121,"#include <iostream>
#include <string>
#include <cassert>
using namespace std;
string tup_string(char tup1[], int size) {
    string str = """";
    for (int i = 0; i < size; i++) {
//begin to write code
",201,"
#include <iostream>
#include <string>
#include <cassert>
using namespace std;

string tup_string(char tup1[], int size) {
    string str = """";
    for (int i = 0; i < size; i++) {
        str += tup1[i];
    }
    return str;
}


","
#include <iostream>
#include <string>
#include <cassert>
using namespace std;

string tup_string(char tup1[], int size) {
    string str = """";
    for (int i = 0; i < size; i++) {
        str += to_string(tup1[i]);
    }
    return str;
}

",,,,-2,1,0.19650866587956747,code_expression_exchange:None,0.0,0.0,
122,"#include<cassert>
#include <iostream>
#include <vector>
#include <numeric>
int sum_negativenum(const std::vector<int>& nums) {
    int sum = 0;
    for (auto num : nums) {
        if (num < 0) {
//begin to write code
",217,"#include<cassert>
#include <iostream>
#include <vector>
#include <numeric>

int sum_negativenum(const std::vector<int>& nums) {
    int sum = 0;
    for (auto num : nums) {
        if (num < 0) {
            sum += num;
        }
    }
    return sum;
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<cassert>

int sum_negativenum(const std::vector<int>& nums) {
    return std::accumulate(nums.begin(), nums.end(), 0, [](int sum, int num) {
        return num < 0? sum + num : sum;
    });
}
","#include<cassert>
#include <iostream>
#include <vector>
#include <numeric>
int sum_negativenum(const std::vector<int>& nums) {
    int sum = 0;
    for (auto num : nums) {
        if (num < 0) {
//begin to write code
","#include<cassert>
#include <iostream>
#include <vector>
#include <numeric>

int sum_negativenum(const std::vector<int>& nums) {
    int sum = 0;
    for (auto num : nums) {
        if (num < 0) {
            sum += num;
        }
    }
    return sum;
}


","
using namespace std;

#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

int sum_negativenum(const std::vector<int>& nums) {
    int sum = 0;
    for (auto num : nums) {
        if (num < 0) {
            sum += num;
        }
    }
    return sum;
}

",1,3,0.38051005204518634,code_expression_exchange:bool2int,1.0,0.0,"{'#include<cassert>\n#include <iostream>\n#include <vector>\n#include <numeric>\n\nint sum_negativenum(const std::vector<int>& nums) {\n    int sum = 0;\n    for (auto num : nums) {\n        if (num < 0) {\n            sum += num;\n        }\n    }\n    return sum;\n}\n\n\n': [('#include<cassert>\n#include <iostream>\n#include <vector>\n#include <numeric>\nint sum_negativenum(const std::vector<int>& nums) {\n    int sum = 0;\n    for (auto num : nums) {\n        if (num < 0) {\n//begin to write code\n', '\nusing namespace std;\n\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\nint sum_negativenum(const std::vector<int>& nums) {\n    int sum = 0;\n    for (auto num : nums) {\n        if (num < 0) {\n            sum += num;\n        }\n    }\n    return sum;\n}\n\n', 'bool2int')]}"
123,"#include <iostream>
#include <vector>
#include <cassert>
std::string check_last(const std::vector<int>& arr, int n, int p) {
    int _sum = 0;
    for (int i = 0; i < n; ++i) {
        _sum += arr[i];
    }
    if (p == 1) {
        if (_sum % 2 == 0) {
//begin to write code
",276,"
#include <iostream>
#include <vector>
#include <cassert>

std::string check_last(const std::vector<int>& arr, int n, int p) {
    int _sum = 0;
    for (int i = 0; i < n; ++i) {
        _sum += arr[i];
    }
    if (p == 1) {
        if (_sum % 2 == 0) {
            return ""ODD"";
        } else {
            return ""EVEN"";
        }
    }
    return ""EVEN"";
}


","
#include <iostream>
#include <vector>
#include <cassert>

std::string check_last(const std::vector<int>& arr, int n, int p) {
    int _sum = 0;
    for (int i = 0; i < n; ++i) {
        _sum += arr[i];
    }
    if (p == 1) {
        if (_sum % 2 == 0) {
            return ""Even"";
        } else {
            return ""Odd"";
        }
    } else {
        // Additional logic for more complex operations
        // For example, you might want to calculate the average or sum of the array elements
        // This is just a basic example to illustrate the logic
        double average = static_cast<double>(_sum) / n;
        if (average % 2 == 0) {
            return ""Even"";
        } else {
            return ""Odd"";
        }
    }
}

",,,,-2,1,0.2601043621699015,code_expression_exchange:None,0.0,0.0,
124,"#include <iostream>
#include <cassert>
int hexagonal_num(int n) {
//begin to write code
",88,"
#include <iostream>
#include <cassert>

int hexagonal_num(int n) {
    return n * (2 * n - 1);
}


","
#include <iostream>
#include <cassert>

int hexagonal_num(int n) {
    return 6 * n * (n + 1) / 2;
}

",,,,-2,1,0.28629773457845054,code_expression_exchange:None,0.0,0.0,
125,"#include <iostream>
#include <cassert>
double cal_electbill(int units) {
    double amount;
    int surcharge;
    if(units < 50) {
        amount = units * 2.60;
        surcharge = 25;
    } else if(units <= 100) {
        amount = 130 + ((units - 50) * 3.25);
        surcharge = 35;
//begin to write code
",309,"
#include <iostream>
#include <cassert>

double cal_electbill(int units) {
    double amount;
    int surcharge;
    if(units < 50) {
        amount = units * 2.60;
        surcharge = 25;
    } else if(units <= 100) {
        amount = 130 + ((units - 50) * 3.25);
        surcharge = 35;
    } else if(units <= 200) {
        amount = 130 + 162.50 + ((units - 100) * 5.26);
        surcharge = 45;
    } else {
        amount = 130 + 162.50 + 526 + ((units - 200) * 8.45);
        surcharge = 75;
    }
    double total = amount + surcharge;
    return total;
}


","
#include <iostream>
#include <cassert>
double cal_electbill(int units) {
    double amount;
    int surcharge;
    if(units < 50) {
        amount = units * 2.60;
        surcharge = 25;
    } else if(units <= 100) {
        amount = 130 + ((units - 50) * 3.25);
        surcharge = 35;
    } else {
        amount = 200 + ((units - 100) * 4.75);
        surcharge = 45;
    }
    return amount + surcharge;
}

",,,,-2,1,0.286956258614858,code_expression_exchange:None,0.0,0.0,
126,"#include <iostream>
#include <vector>
#include <cmath>
#include <cassert>
double zero_count(const std::vector<int>& nums) {
    int n = nums.size();
    int n1 = 0;
    for (int x : nums) {
        if (x == 0) {
//begin to write code
",234,"
#include <iostream>
#include <vector>
#include <cmath>
#include <cassert>

double zero_count(const std::vector<int>& nums) {
    int n = nums.size();
    int n1 = 0;
    for (int x : nums) {
        if (x == 0) {
            n1 += 1;
        }
    }
    return round(n1 * 100.0 / n) / 100.0;
}


","
#include <iostream>
#include <vector>
#include <cmath>
#include <cassert>

using namespace std;

double zero_count(const std::vector<int>& nums) {
    int n = nums.size();
    int n1 = 0;
    for (int x : nums) {
        if (x == 0) {
            n1++;
        }
    }
    return n1 / n;
}

",,,,-2,1,0.3120429317156474,code_expression_exchange:None,0.0,0.0,
127,"#include <iostream>
#include <cassert>
bool is_Sum_Of_Powers_Of_Two(int n) {
    if (n % 2 == 1) {
        return false;
//begin to write code
",143,"
#include <iostream>
#include <cassert>

bool is_Sum_Of_Powers_Of_Two(int n) {
    if (n % 2 == 1) {
        return false;
    } else {
        return true;
    }
}


","
using namespace std;

#include <iostream>
#include <cassert>

bool is_Sum_Of_Powers_Of_Two(int n) {
    // Your implementation goes here
    // For example, you could use bit manipulation to check if n can be expressed as sum of powers of 2
    // Here's a simple implementation that checks if n is a power of 2
    return n > 0 && (n & (n - 1)) == 0;
}

",,,,-2,1,0.33842257261276243,code_expression_exchange:None,0.0,0.0,
128,"#include <iostream>
#include <cassert>
double circle_circumference(double r) {
    double perimeter = 2 * 3.1415 * r;
//begin to write code
",140,"
#include <iostream>
#include <cassert>

double circle_circumference(double r) {
    double perimeter = 2 * 3.1415 * r;
    return perimeter;
}


","
using namespace std;
#include <iostream>
#include <cassert>

double circle_circumference(double r) {
    double perimeter = 2 * 3.1415 * r;
    return perimeter;
}

","#include <iostream>
#include <cassert>
double circle_circumference(double r) {
    double perimeter = r * 3.1415 * 2;
//begin to write code
","
#include <iostream>
#include <cassert>

double circle_circumference(double r) {
    double perimeter = r * 3.1415 * 2;
    return perimeter;
}


","
#include <iostream>
#include <cassert>
#include <cmath> // For M_PI and pow

double circle_circumference(double r) {
    return 2 * M_PI * r;
}

",1,17,2.15427135626475,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\ndouble circle_circumference(double r) {\n    double perimeter = r * 3.1415 * 2;\n    return perimeter;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\ndouble circle_circumference(double r) {\n    double perimeter = 2 * 3.1415 * r;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n#include <cmath> // For M_PI\n\ndouble circle_circumference(double r) {\n    return 2 * 3.1415 * r;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cassert>\ndouble circle_circumference(double r) {\n    double perimeter = 2 * 3.1415 * r;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\ndouble circle_circumference(double r) {\n    return 2 * 3.1415 * r;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\ndouble circle_circumference(double r) {\n    double perimeter = 2 * 3.1415 * r;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\ndouble circle_circumference(double r) {\n    double perimeter = 2 * 3.1415 * r;\n    return perimeter;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\ndouble circle_circumference(double r) {\n    double perimeter = 2 * 3.1415 * r;\n//begin to write code\n', '\nusing namespace std;\n#include <cmath>\n#include <cassert>\n\ndouble circle_circumference(double r) {\n    return 2 * 3.1415 * r;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cassert>\ndouble circle_circumference(double r) {\n    double perimeter = 2 * 3.1415 * r;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n#include <cmath> // For M_PI\n\ndouble circle_circumference(double r) {\n    return 2 * 3.1415 * r;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\ndouble circle_circumference(double r) {\n    double perimeter = 2 * 3.1415 * r;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\ndouble circle_circumference(double r) {\n    double perimeter = 2 * 3.1415 * r;\n    return perimeter;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cassert>\ndouble circle_circumference(double r) {\n    double perimeter = r * 3.1415 * 2;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\ndouble circle_circumference(double r) {\n    double perimeter = r * 3.1415 * 2;\n    return perimeter;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cassert>\ndouble circle_circumference(double r) {\n    double perimeter = r * 3.1415 * 2;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n#include <cmath> // For M_PI and pow\n\ndouble circle_circumference(double r) {\n    return 2 * M_PI * r;\n}\n\n', 'more_universe_var_type')]}"
129,"#include <iostream>
#include <vector>
#include <set>
#include <cassert>
std::vector<int> extract_singly(const std::vector<std::vector<int>>& test_list) {
    std::vector<int> res;
    std::set<int> temp;
    for (const auto& inner : test_list) {
        for (int ele : inner) {
            if (temp.find(ele) == temp.end()) {
//begin to write code
",348,"
#include <iostream>
#include <vector>
#include <set>
#include <cassert>

std::vector<int> extract_singly(const std::vector<std::vector<int>>& test_list) {
    std::vector<int> res;
    std::set<int> temp;
    for (const auto& inner : test_list) {
        for (int ele : inner) {
            if (temp.find(ele) == temp.end()) {
                temp.insert(ele);
                res.push_back(ele);
            }
        }
    }
    return res;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <set>
#include <cassert>

std::vector<int> extract_singly(const std::vector<std::vector<int>>& test_list) {
    std::vector<int> res;
    std::set<int> temp;
    for (const auto& inner : test_list) {
        for (int ele : inner) {
            if (temp.find(ele) == temp.end()) {
                temp.insert(ele);
                res.push_back(ele);
            }
        }
    }
    return res;
}

","#include <iostream>
#include <vector>
#include <set>
#include <cassert>
std::vector<long> extract_singly(const std::vector<std::vector<int>>& test_list) {
    std::vector<int> res;
    std::set<int> temp;
    for (const auto& inner : test_list) {
        for (int ele : inner) {
            if (temp.end() == temp.find(ele)) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <set>
#include <cassert>

std::vector<long> extract_singly(const std::vector<std::vector<int>>& test_list) {
    std::vector<int> res;
    std::set<int> temp;
    for (const auto& inner : test_list) {
        for (int ele : inner) {
            if (temp.end() == temp.find(ele)) {
                temp.insert(ele);
                res.push_back(ele);
            }
        }
    }
    return res;
}


","#include <iostream>
#include <vector>
#include <set>
#include <cassert>
std::vector<long> extract_singly(const std::vector<std::vector<int>>& test_list) {
    std::vector<int> res;
    std::set<int> temp;
    for (const auto& inner : test_list) {
        for (int ele : inner) {
            if (temp.end() == temp.find(ele)) {
                res.push_back(ele);
                temp.insert(ele);
            }
        }
    }
    return res;
}
",1,5,0.7610986471176148,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nstd::vector<long> extract_singly(const std::vector<std::vector<int>>& test_list) {\n    std::vector<int> res;\n    std::set<int> temp;\n    for (const auto& inner : test_list) {\n        for (int ele : inner) {\n            if (temp.end() == temp.find(ele)) {\n                temp.insert(ele);\n                res.push_back(ele);\n            }\n        }\n    }\n    return res;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nstd::vector<int> extract_singly(const std::vector<std::vector<int>>& test_list) {\n    std::vector<int> res;\n    std::set<int> temp;\n    for (const auto& inner : test_list) {\n        for (int ele : inner) {\n            if (temp.end() == temp.find(ele)) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nstd::vector<int> extract_singly(const std::vector<std::vector<int>>& test_list) {\n    std::vector<int> res;\n    std::set<int> temp;\n    for (const auto& inner : test_list) {\n        for (int ele : inner) {\n            if (temp.end() == temp.find(ele)) {\n                res.push_back(ele);\n                temp.insert(ele);\n            }\n        }\n    }\n    return res;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nstd::vector<long> extract_singly(const std::vector<std::vector<int>>& test_list) {\n    std::vector<int> res;\n    std::set<int> temp;\n    for (const auto& inner : test_list) {\n        for (int ele : inner) {\n            if (temp.end() == temp.find(ele)) {\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nstd::vector<long> extract_singly(const std::vector<std::vector<int>>& test_list) {\n    std::vector<int> res;\n    std::set<int> temp;\n    for (const auto& inner : test_list) {\n        for (int ele : inner) {\n            if (temp.end() == temp.find(ele)) {\n                res.push_back(ele);\n                temp.insert(ele);\n            }\n        }\n    }\n    return res;\n}\n', 'more_universe_var_type')]}"
130,"#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
std::vector<int> pancake_sort(std::vector<int>& nums) {
    int arr_len = nums.size();
    while (arr_len > 1) {
        auto mi = std::distance(nums.begin(), std::max_element(nums.begin(), nums.begin() + arr_len));
        std::reverse(nums.begin(), nums.begin() + mi + 1);
//begin to write code
",375,"
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::vector<int> pancake_sort(std::vector<int>& nums) {
    int arr_len = nums.size();
    while (arr_len > 1) {
        auto mi = std::distance(nums.begin(), std::max_element(nums.begin(), nums.begin() + arr_len));
        std::reverse(nums.begin(), nums.begin() + mi + 1);
        std::reverse(nums.begin(), nums.begin() + arr_len);
        arr_len--;
    }
    return nums;
}


","
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::vector<int> pancake_sort(std::vector<int>& nums) {
    int arr_len = nums.size();
    while (arr_len > 1) {
        auto mi = std::distance(nums.begin(), std::max_element(nums.begin(), nums.begin() + arr_len));
        std::reverse(nums.begin(), nums.begin() + mi + 1);
        // Complete the code here
    }
    return nums;
}

",,,,-2,1,1.2263941407203673,code_expression_exchange:None,0.0,0.0,
131,"#include <iostream>
#include <vector>
#include <cassert>
int count_samepair(const std::vector<int>& list1, const std::vector<int>& list2, const std::vector<int>& list3) {
    int result = 0;
    for (size_t i = 0; i < list1.size(); ++i) {
        if (list1[i] == list2[i] && list2[i] == list3[i]) {
//begin to write code
",321,"
#include <iostream>
#include <vector>
#include <cassert>

int count_samepair(const std::vector<int>& list1, const std::vector<int>& list2, const std::vector<int>& list3) {
    int result = 0;
    for (size_t i = 0; i < list1.size(); ++i) {
        if (list1[i] == list2[i] && list2[i] == list3[i]) {
            result++;
        }
    }
    return result;
}


","
#include <iostream>
#include <vector>
#include <cassert>

int count_samepair(const std::vector<int>& list1, const std::vector<int>& list2, const std::vector<int>& list3) {
    int result = 0;
    for (size_t i = 0; i < list1.size(); ++i) {
        if (list1[i] == list2[i] && list2[i] == list3[i]) {
            result++;
        }
    }
    return result;
}

","#include <iostream>
#include <vector>
#include <cassert>
long count_samepair(const std::vector<int>& list1, const std::vector<long>& list2, const std::vector<int>& list3) {
    int result = 0;
    for (size_t i = 0; i < list1.size(); ++i) {
        if (list1[i] == list2[i] && list2[i] == list3[i]) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

long count_samepair(const std::vector<int>& list1, const std::vector<long>& list2, const std::vector<int>& list3) {
    int result = 0;
    for (size_t i = 0; i < list1.size(); ++i) {
        if (list1[i] == list2[i] && list2[i] == list3[i]) {
            result++;
        }
    }
    return result;
}


","
#include <iostream>
#include <vector>
#include <cassert>
#include <unordered_set>

long count_samepair(const std::vector<int>& list1, const std::vector<long>& list2, const std::vector<int>& list3) {
    std::unordered_set<long> set1(list1.begin(), list1.end());
    std::unordered_set<long> set2(list2.begin(), list2.end());
    std::unordered_set<long> set3(list3.begin(), list3.end());

    long count = 0;
    for (size_t i = 0; i < list1.size(); ++i) {
        if (set1.count(list2[i]) && set2.count(list3[i])) {
            ++count;
        }
    }

    return count;
}

",1,9,1.3179397066434224,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong count_samepair(const std::vector<int>& list1, const std::vector<long>& list2, const std::vector<int>& list3) {\n    int result = 0;\n    for (size_t i = 0; i < list1.size(); ++i) {\n        if (list1[i] == list2[i] && list2[i] == list3[i]) {\n            result++;\n        }\n    }\n    return result;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nint count_samepair(const std::vector<int>& list1, const std::vector<int>& list2, const std::vector<int>& list3) {\n    int result = 0;\n    for (size_t i = 0; i < list1.size(); ++i) {\n        if (list2[i] == list1[i] && list3[i] == list2[i]) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_samepair(const std::vector<int>& list1, const std::vector<int>& list2, const std::vector<int>& list3) {\n    int result = 0;\n    for (size_t i = 0; i < list1.size(); ++i) {\n        if (list2[i] == list1[i] && list3[i] == list2[i]) {\n            ++result;\n        }\n    }\n    return result;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint count_samepair(const std::vector<int>& list1, const std::vector<long>& list2, const std::vector<int>& list3) {\n    int result = 0;\n    for (size_t i = 0; i < list1.size(); ++i) {\n        if (list2[i] == list1[i] && list3[i] == list2[i]) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_samepair(const std::vector<int>& list1, const std::vector<long>& list2, const std::vector<int>& list3) {\n    int result = 0;\n    for (size_t i = 0; i < list1.size(); ++i) {\n        if (list2[i] == list1[i] && list3[i] == list2[i]) {\n            ++result;\n        }\n    }\n    return result;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong count_samepair(const std::vector<int>& list1, const std::vector<long>& list2, const std::vector<int>& list3) {\n    int result = 0;\n    for (size_t i = 0; i < list1.size(); ++i) {\n        if (list2[i] == list1[i] && list3[i] == list2[i]) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong count_samepair(const std::vector<int>& list1, const std::vector<long>& list2, const std::vector<int>& list3) {\n    int result = 0;\n    for (size_t i = 0; i < list1.size(); ++i) {\n        if (list2[i] == list1[i] && list3[i] == list2[i]) {\n            ++result;\n        }\n    }\n    return result;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong count_samepair(const std::vector<int>& list1, const std::vector<long>& list2, const std::vector<int>& list3) {\n    int result = 0;\n    for (size_t i = 0; i < list1.size(); ++i) {\n        if (list1[i] == list2[i] && list2[i] == list3[i]) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <unordered_set>\n\nlong count_samepair(const std::vector<int>& list1, const std::vector<long>& list2, const std::vector<int>& list3) {\n    std::unordered_set<long> set1(list1.begin(), list1.end());\n    std::unordered_set<long> set2(list2.begin(), list2.end());\n    std::unordered_set<long> set3(list3.begin(), list3.end());\n\n    long count = 0;\n    for (size_t i = 0; i < list1.size(); ++i) {\n        if (set1.count(list2[i]) && set2.count(list3[i])) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n\n', 'exchange_operators')]}"
132,"#include<cassert>
#include <iostream>
#include <tuple>
#include <vector>
template <typename... Args>
int find_lists(const std::tuple<Args...>& input) {
    return sizeof...(Args);
}
//begin to write code
",204,"#include<cassert>
#include <iostream>
#include <tuple>
#include <vector>

template <typename... Args>
int find_lists(const std::tuple<Args...>& input) {
    return sizeof...(Args);
}

template <typename T>
int find_lists(const std::vector<T>& input) {
    return 1;
}


","
#include<cassert>
#include <iostream>
#include <tuple>
#include <vector>
#include <string>
#include <sstream>

template <typename... Args>
int find_lists(const std::tuple<Args...>& input) {
    return sizeof...(Args);
}

",,,,-2,1,0.1992518385251363,code_expression_exchange:None,0.0,0.0,
133,"#include <iostream>
#include <vector>
#include <cassert>
int sum_Pairs(const std::vector<int>& arr, int n) {
    int sum = 0;
    for (int i = n - 1; i >= 0; --i) {
//begin to write code
",187,"
#include <iostream>
#include <vector>
#include <cassert>

int sum_Pairs(const std::vector<int>& arr, int n) {
    int sum = 0;
    for (int i = n - 1; i >= 0; --i) {
        sum += i * arr[i] - (n - 1 - i) * arr[i];
    }
    return sum;
}


","
#include <iostream>
#include <vector>
#include <cassert>

int sum_Pairs(const std::vector<int>& arr, int n) {
    int sum = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            sum += std::abs(arr[i] - arr[j]);
        }
    }
    return sum;
}

","#include <iostream>
#include <vector>
#include <cassert>
int sum_Pairs(const std::vector<int>& arr, int n) {
    long sum = 0;
    for (long i = n - 1; i >= 0; i = i - 1) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

int sum_Pairs(const std::vector<int>& arr, int n) {
    long sum = 0;
    for (long i = n - 1; i >= 0; i = i - 1) {
        sum = sum + (i * arr[i] - (n - 1 - i) * arr[i]);
    }
    return sum;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

int sum_Pairs(const std::vector<int>& arr, int n) {
    long sum = 0;
    for (long i = n - 1; i >= 0; i = i - 1) {
        // Calculate the absolute difference between each pair of elements
        long diff = abs(arr[i] - arr[i + 1]);
        // Add the difference to the total sum
        sum += diff;
    }
    return sum;
}

",1,17,2.3212294578552246,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint sum_Pairs(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (long i = n - 1; i >= 0; i = i - 1) {\n        sum = sum + (i * arr[i] - (n - 1 - i) * arr[i]);\n    }\n    return sum;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nint sum_Pairs(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (int i = n - 1; i >= 0; --i) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\nint sum_abs_diffs(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            sum += std::abs(arr[i] - arr[j]);\n        }\n    }\n    return sum;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint sum_Pairs(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (int i = n - 1; i >= 0; --i) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint sum_Pairs(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            sum += abs(arr[i] - arr[j]);\n        }\n    }\n    return sum;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint sum_Pairs(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (long i = n - 1; i >= 0; --i) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint sum_Pairs(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = i + 1; j < n; ++j) {\n            sum += abs(arr[i] - arr[j]);\n        }\n    }\n    return sum;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint sum_Pairs(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (long i = n - 1; i >= 0; --i) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint sum_Pairs(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = i + 1; j < n; ++j) {\n            int diff = std::abs(arr[i] - arr[j]);\n            sum += diff;\n        }\n    }\n    return sum;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint sum_Pairs(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (long i = n - 1; i >= 0; --i) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint sum_Pairs(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = i + 1; j < n; ++j) {\n            sum += std::abs(arr[i] - arr[j]);\n        }\n    }\n    return sum;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint sum_Pairs(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (long i = n - 1; i >= 0; --i) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint sum_Pairs(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = i + 1; j < n; ++j) {\n            sum += abs(arr[i] - arr[j]);\n        }\n    }\n    return sum;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint sum_Pairs(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (long i = n - 1; i >= 0; i = i - 1) {\n//begin to write code\n', 'using namespace std;\n#include <vector>\n#include <cassert>\n\nint sum_Pairs(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = i + 1; j < n; j++) {\n            sum += abs(arr[i] - arr[j]);\n        }\n    }\n    return sum;\n}\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint sum_Pairs(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (long i = n - 1; i >= 0; i = i - 1) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint sum_Pairs(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (long i = n - 1; i >= 0; i = i - 1) {\n        // Calculate the absolute difference between each pair of elements\n        long diff = abs(arr[i] - arr[i + 1]);\n        // Add the difference to the total sum\n        sum += diff;\n    }\n    return sum;\n}\n\n', 'bool2int')]}"
134,"#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
int max_Abs_Diff(const std::vector<int>& arr, int n) {
    int minEle = arr[0];
    int maxEle = arr[0];
    for (int i = 1; i < n; i++) {
//begin to write code
",239,"
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

int max_Abs_Diff(const std::vector<int>& arr, int n) {
    int minEle = arr[0];
    int maxEle = arr[0];
    for (int i = 1; i < n; i++) {
        minEle = std::min(minEle, arr[i]);
        maxEle = std::max(maxEle, arr[i]);
    }
    return (maxEle - minEle);
}


","
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

int max_Abs_Diff(const std::vector<int>& arr, int n) {
    if (n <= 1) {
        return 0;
    }

    int minEle = arr[0];
    int maxEle = arr[0];

    for (int i = 1; i < n; i++) {
        if (arr[i] < minEle) {
            minEle = arr[i];
        }
        if (arr[i] > maxEle) {
            maxEle = arr[i];
        }
    }

    int diff = maxEle - minEle;

    return diff;
}

","#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
int max_Abs_Diff(const std::vector<int>& arr, int n) {
    int minEle = arr[0];
    int maxEle = arr[0];
    for (long i = 1; i < n; i++) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

int max_Abs_Diff(const std::vector<int>& arr, int n) {
    int minEle = arr[0];
    int maxEle = arr[0];
    for (long i = 1; i < n; i++) {
        minEle = std::min(minEle, arr[i]);
        maxEle = std::max(maxEle, arr[i]);
    }
    return (maxEle - minEle);
}


","
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

int max_Abs_Diff(const std::vector<int>& arr, int n) {
    if (n <= 1) {
        return 0;
    }

    int minEle = arr[0];
    int maxEle = arr[0];

    for (long i = 1; i < n; i++) {
        if (arr[i] < minEle) {
            minEle = arr[i];
        }
        if (arr[i] > maxEle) {
            maxEle = arr[i];
        }
    }

    int maxDiff = maxEle - minEle;

    return maxDiff;
}

void test_max_Abs_Diff() {
    assert(max_Abs_Diff({1, 2, 3, 4, 5}, 5) == 4);
    assert(max_Abs_Diff({-10, -20, -30, -40}, 4) == 30);
    assert(max_Abs_Diff({10",1,7,1.0023420572280883,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint max_Abs_Diff(const std::vector<int>& arr, int n) {\n    int minEle = arr[0];\n    int maxEle = arr[0];\n    for (long i = 1; i < n; i++) {\n        minEle = std::min(minEle, arr[i]);\n        maxEle = std::max(maxEle, arr[i]);\n    }\n    return (maxEle - minEle);\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nint max_Abs_Diff(const std::vector<int>& arr, int n) {\n    int minEle = arr[0];\n    int maxEle = arr[0];\n    for (int i = 1; i < n; i++) {\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint max_Abs_Diff(const std::vector<int>& arr, int n) {\n    if (n < 2) {\n        return 0;\n    }\n\n    int minEle = arr[0];\n    int maxEle = arr[0];\n\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < minEle) {\n            minEle = arr[i];\n        }\n        if (arr[i] > maxEle) {\n            maxEle = arr[i];\n        }\n    }\n\n    int maxDiff = maxEle - minEle;\n    return maxDiff;\n}\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nint max_Abs_Diff(const std::vector<int>& arr, int n) {\n    int minEle = arr[0];\n    int maxEle = arr[0];\n    for (long i = 1; i < n; i++) {\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint max_Abs_Diff(const std::vector<int>& arr, int n) {\n    if (n <= 1) {\n        return 0;\n    }\n\n    int minEle = arr[0];\n    int maxEle = arr[0];\n\n    for (long i = 1; i < n; i++) {\n        if (arr[i] < minEle) {\n            minEle = arr[i];\n        }\n        if (arr[i] > maxEle) {\n            maxEle = arr[i];\n        }\n    }\n\n    int maxDiff = maxEle - minEle;\n\n    return maxDiff;\n}\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nint max_Abs_Diff(const std::vector<int>& arr, int n) {\n    int minEle = arr[0];\n    int maxEle = arr[0];\n    for (long i = 1; i < n; i++) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint max_Abs_Diff(const std::vector<int>& arr, int n) {\n    if (n <= 1) {\n        return 0;\n    }\n\n    int minEle = arr[0];\n    int maxEle = arr[0];\n\n    for (long i = 1; i < n; i++) {\n        if (arr[i] < minEle) {\n            minEle = arr[i];\n        }\n        if (arr[i] > maxEle) {\n            maxEle = arr[i];\n        }\n    }\n\n    int maxDiff = maxEle - minEle;\n\n    return maxDiff;\n}\n\nvoid test_max_Abs_Diff() {\n    assert(max_Abs_Diff({1, 2, 3, 4, 5}, 5) == 4);\n    assert(max_Abs_Diff({-10, -20, -30, -40}, 4) == 30);\n    assert(max_Abs_Diff({10', 'bool2int')]}"
135,"#include <iostream>
#include <string>
#include <cassert>
int ascii_value_string(const std::string& str1) {
//begin to write code
",129,"
#include <iostream>
#include <string>
#include <cassert>

int ascii_value_string(const std::string& str1) {
    return static_cast<int>(str1[0]);
}


","
using namespace std;
#include <iostream>
#include <string>
#include <cassert>

int ascii_value_string(const std::string& str1) {
    int ascii_value = 0;
    for (char c : str1) {
        ascii_value += static_cast<int>(c);
    }
    return ascii_value;
}

",,,,-2,1,0.24265968402226765,code_expression_exchange:None,0.0,0.0,
136,"#include <iostream>
#include <vector>
#include <cassert>
int max_path_sum(std::vector<std::vector<int>>& tri, int m, int n) {
    for (int i = m - 1; i >= 0; --i) {
        for (int j = 0; j <= i; ++j) {
            if (tri[i + 1][j] > tri[i + 1][j + 1]) {
                tri[i][j] += tri[i + 1][j];
            } else {
//begin to write code
",344,"
#include <iostream>
#include <vector>
#include <cassert>

int max_path_sum(std::vector<std::vector<int>>& tri, int m, int n) {
    for (int i = m - 1; i >= 0; --i) {
        for (int j = 0; j <= i; ++j) {
            if (tri[i + 1][j] > tri[i + 1][j + 1]) {
                tri[i][j] += tri[i + 1][j];
            } else {
                tri[i][j] += tri[i + 1][j + 1];
            }
        }
    }
    return tri[0][0];
}


","
using namespace std;
#include <vector>
#include <assert.h>

int max_path_sum(std::vector<std::vector<int>>& tri, int m, int n) {
    for (int i = m - 1; i >= 0; --i) {
        for (int j = 0; j <= i; ++j) {
            if (tri[i + 1][j] > tri[i + 1][j + 1]) {
                tri[i][j] += tri[i + 1][j];
            } else {
                // Begin to write code
                tri[i][j] = max(tri[i][j], tri[i + 1][j] + tri[i + 1][j + 1]);
            }
        }
    }
    return tri[0][0];
}

",,,,-2,1,0.24849087794621785,code_expression_exchange:None,0.0,0.0,
137,"#include <iostream>
#include <cassert>
int sum_digits_single(int x) {
    int ans = 0;
    while (x) {
        ans += x % 10;
        x /= 10;
    }
    return ans;
}
int closest(int x) {
//begin to write code
",210,"
#include <iostream>
#include <cassert>

int sum_digits_single(int x) {
    int ans = 0;
    while (x) {
        ans += x % 10;
        x /= 10;
    }
    return ans;
}

int closest(int x) {
    int ans = 0;
    while (ans * 10 + 9 <= x) {
        ans = ans * 10 + 9;
    }
    return ans;
}

int sum_digits_twoparts(int N) {
    int A = closest(N);
    return sum_digits_single(A) + sum_digits_single(N - A);
}


","
using namespace std;
#include <iostream>
#include <cassert>

int sum_digits_single(int x) {
    int ans = 0;
    while (x) {
        ans += x % 10;
        x /= 10;
    }
    return ans;
}

int closest(int x) {
    // Find the maximum digit in the number
    int max_digit = 0;
    while (x > 0) {
        max_digit = max(max_digit, x % 10);
        x /= 10;
    }

    // Calculate the closest sum of digits
    int closest_sum = INT_MAX;
    for (int i = 1; i <= max_digit; ++i) {
        int current_sum = sum_digits_single(x);
        if (current_sum < closest_sum) {
            closest_sum = current_sum;
        }
    }

    return closest_sum;
}

",,,,-2,1,0.24131835301717122,code_expression_exchange:None,0.0,0.0,
138,"#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
int longest_subseq_with_diff_one(vector<int> &arr, int n) {
    vector<int> dp(n, 1);
    int result = 1;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if ((arr[i] == arr[j] + 1) || (arr[i] == arr[j] - 1)) {
//begin to write code
",346,"
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

int longest_subseq_with_diff_one(vector<int> &arr, int n) {
    vector<int> dp(n, 1);
    int result = 1;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if ((arr[i] == arr[j] + 1) || (arr[i] == arr[j] - 1)) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
        result = max(result, dp[i]);
    }
    return result;
}


","
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

int longest_subseq_with_diff_one(vector<int> &arr, int n) {
    vector<int> dp(n, 1);
    int result = 1;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if ((arr[i] == arr[j] + 1) || (arr[i] == arr[j] - 1)) {
                dp[i] = max(dp[i], dp[j] + 1);
                result = max(result, dp[i]);
            }
        }
    }
    return result;
}

","#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
int longest_subseq_with_diff_one(vector<int> &arr, long n) {
    vector<int> dp(n, 1);
    int result = 1;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if ((arr[i] == arr[j] + 1) || (arr[i] == arr[j] - 1)) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

int longest_subseq_with_diff_one(vector<int> &arr, long n) {
    vector<int> dp(n, 1);
    int result = 1;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if ((arr[i] == arr[j] + 1) || (arr[i] == arr[j] - 1)) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
        result = max(result, dp[i]);
    }
    return result;
}


","
**Created Answer**:
",1,7,1.0285089612007141,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint longest_subseq_with_diff_one(vector<int> &arr, long n) {\n    vector<int> dp(n, 1);\n    int result = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if ((arr[i] == arr[j] + 1) || (arr[i] == arr[j] - 1)) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n        result = max(result, dp[i]);\n    }\n    return result;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nint longest_subseq_with_diff_one(vector<int> &arr, int n) {\n    vector<int> dp(n, 1);\n    int result = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if ((arr[j] + 1 == arr[i]) || (arr[j] - 1 == arr[i])) {\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint longest_subseq_with_diff_one(vector<int> &arr, int n) {\n    vector<int> dp(n, 1);\n    int result = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if ((arr[j] + 1 == arr[i]) || (arr[j] - 1 == arr[i])) {\n                dp[i] = max(dp[i], dp[j] + 1);\n                result = max(result, dp[i]);\n            }\n        }\n    }\n    return result;\n}\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nint longest_subseq_with_diff_one(vector<int> &arr, long n) {\n    vector<int> dp(n, 1);\n    int result = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if ((arr[j] + 1 == arr[i]) || (arr[j] - 1 == arr[i])) {\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint longest_subseq_with_diff_one(vector<int> &arr, long n) {\n    vector<int> dp(n, 1);\n    int result = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if ((arr[j] + 1 == arr[i]) || (arr[j] - 1 == arr[i])) {\n                dp[i] = max(dp[i], dp[j] + 1);\n                result = max(result, dp[i]);\n            }\n        }\n    }\n    return result;\n}\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nint longest_subseq_with_diff_one(vector<int> &arr, long n) {\n    vector<int> dp(n, 1);\n    int result = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if ((arr[i] == arr[j] + 1) || (arr[i] == arr[j] - 1)) {\n//begin to write code\n', '\n**Created Answer**:\n', 'exchange_operators')]}"
139,"#include <iostream>
#include <cassert>
bool does_Contain_B(int a, int b, int c) {
    if (a == b) {
        return true;
    }
//begin to write code
",149,"
#include <iostream>
#include <cassert>

bool does_Contain_B(int a, int b, int c) {
    if (a == b) {
        return true;
    }
    if ((b - a) * c > 0 && (b - a) % c == 0) {
        return true;
    }
    return false;
}


","
using namespace std;

#include <iostream>
#include <cassert>

bool does_Contain_B(int a, int b, int c) {
    if (a == b) {
        return true;
    }
    // Your implementation here
}

",,,,-2,1,0.20577421585718791,code_expression_exchange:None,0.0,0.0,
140,"#include <iostream>
#include <cassert>
//
int gcd(int p, int q) {
    while (q != 0) {
        int temp = p % q;
        p = q;
        q = temp;
//begin to write code
",172,"
#include <iostream>
#include <cassert>

//
int gcd(int p, int q) {
    while (q != 0) {
        int temp = p % q;
        p = q;
        q = temp;
    }
    return p;
}

bool is_coprime(int x, int y) {
    return gcd(x, y) == 1;
}


","
#include <iostream>
#include <cassert>

// Function definition
int gcd(int p, int q) {
    while (q!= 0) {
        int temp = p % q;
        p = q;
        q = temp;
    }
    return p;
}

// Test function
void test_gcd() {
    assert(gcd(48, 18) == 6);
    assert(gcd(100, 50) == 25);
    assert(gcd(17, 13) == 1);
    std::cout << ""All tests passed!"" << std::endl;
}

",,,,-2,1,0.20153241157531737,code_expression_exchange:None,0.0,0.0,
141,"#include<iostream>
#include <vector>
#include <cassert>
using namespace std;
vector<int> merge(vector<int>& a, vector<int>& b) {
    vector<int> c;
    while (!a.empty() && !b.empty()) {
        if (a.front() < b.front()) {
            c.push_back(a.front());
            a.erase(a.begin());
        } else {
            c.push_back(b.front());
            b.erase(b.begin());
        }
    }
    if (a.empty()) {
        c.insert(c.end(), b.begin(), b.end());
    } else {
        c.insert(c.end(), a.begin(), a.end());
//begin to write code
",543,"#include<iostream>
    

#include <vector>
#include <cassert>

using namespace std;

vector<int> merge(vector<int>& a, vector<int>& b) {
    vector<int> c;
    while (!a.empty() && !b.empty()) {
        if (a.front() < b.front()) {
            c.push_back(a.front());
            a.erase(a.begin());
        } else {
            c.push_back(b.front());
            b.erase(b.begin());
        }
    }
    if (a.empty()) {
        c.insert(c.end(), b.begin(), b.end());
    } else {
        c.insert(c.end(), a.begin(), a.end());
    }
    return c;
}

vector<int> merge_sort(vector<int>& x) {
    if (x.size() == 0 || x.size() == 1) {
        return x;
    } else {
        int middle = x.size() / 2;
        vector<int> a(x.begin(), x.begin() + middle);
        vector<int> b(x.begin() + middle, x.end());
        a = merge_sort(a);
        b = merge_sort(b);
        return merge(a, b);
    }
}


","
#include<iostream>
#include <vector>
#include <cassert>
using namespace std;

vector<int> merge(vector<int>& a, vector<int>& b) {
    vector<int> c;
    while (!a.empty() &&!b.empty()) {
        if (a.front() < b.front()) {
            c.push_back(a.front());
            a.erase(a.begin());
        } else {
            c.push_back(b.front());
            b.erase(b.begin());
        }
    }
    if (a.empty()) {
        c.insert(c.end(), b.begin(), b.end());
    } else {
        c.insert(c.end(), a.begin(), a.end());
    }
    return c;
}

",,,,-2,1,0.2681045889854431,code_expression_exchange:None,0.0,0.0,
142,"#include <iostream>
#include <cassert>
#include <utility> // for std::pair
std::pair<double, double> parabola_vertex(double a, double b, double c) {
//begin to write code
",171,"
#include <iostream>
#include <cassert>
#include <utility> // for std::pair

std::pair<double, double> parabola_vertex(double a, double b, double c) {
    return std::make_pair(-b / (2 * a), (4 * a * c - b * b) / (4 * a));
}


","
using namespace std;
#include <iostream>
#include <cassert>
#include <utility> // for std::pair

std::pair<double, double> parabola_vertex(double a, double b, double c) {
    // Calculate the x-coordinate of the vertex using the formula x = -b / 2a
    double x = -b / (2 * a);
    // Calculate the y-coordinate of the vertex using the formula y = a(x^2 + bx + c)
    double y = a * x * x + a * x + c;
    return {x, y};
}

",,,,-2,1,0.3111891945203145,code_expression_exchange:None,0.0,0.0,
143,"#include<iostream>
#include <vector>
#include <cassert>
using namespace std;
vector<int> specified_element(vector<vector<int>>& nums, int N) {
    vector<int> result;
    for (auto& i : nums) {
//begin to write code
",216,"#include<iostream>
    

#include <vector>
#include <cassert>

using namespace std;

vector<int> specified_element(vector<vector<int>>& nums, int N) {
    vector<int> result;
    for (auto& i : nums) {
        result.push_back(i[N]);
    }
    return result;
}


","
#include<iostream>
#include <vector>
#include <cassert>
using namespace std;

vector<int> specified_element(vector<vector<int>>& nums, int N) {
    vector<int> result;
    for (int i = 0; i < N; ++i) {
        result.push_back(nums[i][i]);
    }
    return result;
}

",,,,-2,1,0.21363803148269653,code_expression_exchange:None,0.0,0.0,
144,"#include <iostream>
#include <cassert>
int even_bit_toggle_number(int n) {
    int res = 0;
    int count = 0;
    int temp = n;
    while (temp > 0) {
        if (count % 2 == 1) {
//begin to write code
",204,"
#include <iostream>
#include <cassert>

int even_bit_toggle_number(int n) {
    int res = 0;
    int count = 0;
    int temp = n;
    while (temp > 0) {
        if (count % 2 == 1) {
            res = res | (1 << count);
        }
        count++;
        temp >>= 1;
    }
    return n ^ res;
}


","
#include <iostream>
#include <cassert>

int even_bit_toggle_number(int n) {
    int res = 0;
    int count = 0;
    int temp = n;
    while (temp > 0) {
        if (count % 2 == 1) {
            // Toggle the least significant bit
            res |= temp & 1;
        }
        temp >>= 1;
        count++;
    }
    return res;
}

",,,,-2,1,0.3480061451594035,code_expression_exchange:None,0.0,0.0,
145,"#include<iostream>
#include <vector>
#include <string>
#include <tuple>
#include <cassert>
using namespace std;
vector<tuple<int, int>> tuple_int_str(const vector<tuple<string, string>>& tuple_str) {
    vector<tuple<int, int>> result;
    for (const auto& x : tuple_str) {
        int first = stoi(get<0>(x));
//begin to write code
",333,"#include<iostream>
    
#include <vector>
#include <string>
#include <tuple>
#include <cassert>

using namespace std;

vector<tuple<int, int>> tuple_int_str(const vector<tuple<string, string>>& tuple_str) {
    vector<tuple<int, int>> result;
    for (const auto& x : tuple_str) {
        int first = stoi(get<0>(x));
        int second = stoi(get<1>(x));
        result.push_back(make_tuple(first, second));
    }
    return result;
}","
#include<iostream>
#include <vector>
#include <string>
#include <tuple>
#include <cassert>
using namespace std;

vector<tuple<int, int>> tuple_int_str(const vector<tuple<string, string>>& tuple_str) {
    vector<tuple<int, int>> result;
    for (const auto& x : tuple_str) {
        int first = stoi(get<0>(x));
        int second = stoi(get<1>(x));
        result.push_back({first, second});
    }
    return result;
}

","#include<iostream>
#include <vector>
#include <string>
#include <tuple>
#include <cassert>
using namespace std;
vector<tuple<int, int>> tuple_int_str(const vector<tuple<string, string>>& tuple_str) {
    vector<tuple<long, int>> result;
    for (const auto& x : tuple_str) {
        int first = stoi(get<0>(x));
//begin to write code
","#include<iostream>
    
#include <vector>
#include <string>
#include <tuple>
#include <cassert>

using namespace std;

vector<tuple<int, int>> tuple_int_str(const vector<tuple<string, string>>& tuple_str) {
    vector<tuple<long, int>> result;
    for (const auto& x : tuple_str) {
        int first = stoi(get<0>(x));
        int second = stoi(get<1>(x));
        result.push_back(make_tuple(first, second));
    }
    return result;
}","#include<iostream>
#include <vector>
#include <string>
#include <tuple>
#include <cassert>
using namespace std;
vector<tuple<int, int>> tuple_int_str(const vector<tuple<string, string>>& tuple_str) {
    vector<tuple<long, int>> result;
    for (const auto& x : tuple_str) {
        long first = stol(get<0>(x));
        result.push_back({first, static_cast<int>(get<1>(x))});
    }
    return result;
}
",1,7,1.0440115968386332,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<iostream>\n    \n#include <vector>\n#include <string>\n#include <tuple>\n#include <cassert>\n\nusing namespace std;\n\nvector<tuple<int, int>> tuple_int_str(const vector<tuple<string, string>>& tuple_str) {\n    vector<tuple<long, int>> result;\n    for (const auto& x : tuple_str) {\n        int first = stoi(get<0>(x));\n        int second = stoi(get<1>(x));\n        result.push_back(make_tuple(first, second));\n    }\n    return result;\n}': [('#include<iostream>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <cassert>\nusing namespace std;\nvector<tuple<int, int>> tuple_int_str(const vector<tuple<string, string>>& tuple_str) {\n    vector<tuple<int, int>> result;\n    for (const auto& x : tuple_str) {\n        int first = stoi(get<0>(x));\n//begin to write code\n', '#include<iostream>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <cassert>\nusing namespace std;\nvector<tuple<int, int>> tuple_int_str(const vector<tuple<string, string>>& tuple_str) {\n    vector<tuple<int, int>> result;\n    for (const auto& x : tuple_str) {\n        int first = stoi(get<0>(x));\n        result.push_back({first, stoi(get<1>(x))});\n    }\n    return result;\n}\n', 'equal_expression_transformation'), ('#include<iostream>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <cassert>\nusing namespace std;\nvector<tuple<int, int>> tuple_int_str(const vector<tuple<string, string>>& tuple_str) {\n    vector<tuple<int, int>> result;\n    for (const auto& x : tuple_str) {\n        int first = stoi(get<0>(x));\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\nvector<tuple<int, int>> tuple_int_str(const vector<tuple<string, string>>& tuple_str) {\n    vector<tuple<int, int>> result;\n    for (const auto& x : tuple_str) {\n        int first = stoi(get<0>(x));\n        result.push_back({first, stoi(get<1>(x))});\n    }\n    return result;\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <cassert>\nusing namespace std;\nvector<tuple<int, int>> tuple_int_str(const vector<tuple<string, string>>& tuple_str) {\n    vector<tuple<long, int>> result;\n    for (const auto& x : tuple_str) {\n        int first = stoi(get<0>(x));\n//begin to write code\n', '#include<iostream>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <cassert>\nusing namespace std;\nvector<tuple<int, int>> tuple_int_str(const vector<tuple<string, string>>& tuple_str) {\n    vector<tuple<long, int>> result;\n    for (const auto& x : tuple_str) {\n        long first = stol(get<0>(x));\n        result.push_back({first, static_cast<int>(get<1>(x))});\n    }\n    return result;\n}\n', 'more_universe_var_type')]}"
146,"#include <vector>
#include <string>
#include <iostream>
#include <iterator>
#include <cassert>
template<typename T>
std::vector<std::vector<T>> encode_list(const std::vector<T>& list1) {
    std::vector<std::vector<T>> result;
    if (list1.empty()) return result;
    T current_value = list1[0];
    int count = 0;
    for (const T& value : list1) {
        if (value == current_value) {
            count++;
        } else {
            result.push_back({count, current_value});
            current_value = value;
            count = 1;
        }
    }
    result.push_back({count, current_value});
    return result;
//begin to write code
",642,"
#include <vector>
#include <string>
#include <iostream>
#include <iterator>
#include <cassert>

template<typename T>
std::vector<std::vector<T>> encode_list(const std::vector<T>& list1) {
    std::vector<std::vector<T>> result;
    if (list1.empty()) return result;
    
    T current_value = list1[0];
    int count = 0;
    
    for (const T& value : list1) {
        if (value == current_value) {
            count++;
        } else {
            result.push_back({count, current_value});
            current_value = value;
            count = 1;
        }
    }
    
    result.push_back({count, current_value});
    return result;
}

std::vector<std::vector<char>> encode_list(const std::string& str) {
    std::vector<std::vector<char>> result;
    if (str.empty()) return result;
    
    char current_char = str[0];
    int count = 0;
    
    for (char ch : str) {
        if (ch == current_char) {
            count++;
        } else {
            result.push_back({count, current_char});
            current_char = ch;
            count = 1;
        }
    }
    
    result.push_back({count, current_char});
    return result;
}


","using namespace std;

#include <vector>
#include <string>
#include <iostream>
#include <iterator>
#include <cassert>

template<typename T>
std::vector<std::vector<T>> encode_list(const std::vector<T>& list1) {
    std::vector<std::vector<T>> result;
    if (list1.empty()) return result;
    T current_value = list1[0];
    int count = 0;
    for (const T& value : list1) {
        if (value == current_value) {
            count++;
        } else {
            result.push_back({count, current_value});
            current_value = value;
            count = 1;
        }
    }
    result.push_back({count, current_value});
    return result;
}
",,,,-2,1,0.1948431611061096,code_expression_exchange:None,0.0,0.0,
147,"#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;
int min_Ops(vector<int> arr, int n, int k) {
    int max1 = *max_element(arr.begin(), arr.end());
    int res = 0;
    for (int i = 0; i < n; ++i) {
        if ((max1 - arr[i]) % k != 0) {
            return -1;
//begin to write code
",333,"
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

using namespace std;

int min_Ops(vector<int> arr, int n, int k) {
    int max1 = *max_element(arr.begin(), arr.end());
    int res = 0;
    for (int i = 0; i < n; ++i) {
        if ((max1 - arr[i]) % k != 0) {
            return -1;
        } else {
            res += (max1 - arr[i]) / k;
        }
    }
    return res;
}


","
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

int min_Ops(vector<int> arr, int n, int k) {
    int max1 = *max_element(arr.begin(), arr.end());
    int res = 0;
    for (int i = 0; i < n; ++i) {
        if ((max1 - arr[i]) % k!= 0) {
            return -1;
        }
        // Add the difference between each element and the maximum element to the result
        res += (max1 - arr[i]);
    }
    return res / k;
}

","#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;
int min_Ops(vector<int> arr, int n, int k) {
    int max1 = *max_element(arr.begin(), arr.end());
    int res = 0;
    for (int i = 0; i < n; ++i) {
        if (0 != (max1 - arr[i]) % k) {
            return -1;
//begin to write code
","
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

using namespace std;

int min_Ops(vector<int> arr, int n, int k) {
    int max1 = *max_element(arr.begin(), arr.end());
    int res = 0;
    for (int i = 0; i < n; ++i) {
        if (0 != (max1 - arr[i]) % k) {
            return -1;
        } else {
            res += (max1 - arr[i]) / k;
        }
    }
    return res;
}


","#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

int min_Ops(vector<int> arr, int n, int k) {
    int max1 = *max_element(arr.begin(), arr.end());
    int res = 0;
    for (int i = 0; i < n; ++i) {
        if (0!= (max1 - arr[i]) % k) {
            return -1;
        }
        res += arr[i] / k;
    }
    return res;
}
",1,3,0.4594623883565267,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nint min_Ops(vector<int> arr, int n, int k) {\n    int max1 = *max_element(arr.begin(), arr.end());\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        if (0 != (max1 - arr[i]) % k) {\n            return -1;\n        } else {\n            res += (max1 - arr[i]) / k;\n        }\n    }\n    return res;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nint min_Ops(vector<int> arr, int n, int k) {\n    int max1 = *max_element(arr.begin(), arr.end());\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        if (0 != (max1 - arr[i]) % k) {\n            return -1;\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nint min_Ops(vector<int> arr, int n, int k) {\n    int max1 = *max_element(arr.begin(), arr.end());\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        if (0!= (max1 - arr[i]) % k) {\n            return -1;\n        }\n        res += arr[i] / k;\n    }\n    return res;\n}\n', 'exchange_operators')]}"
148,"#include <iostream>
#include <string>
#include <cassert>
std::string month_season(std::string month, int days) {
    std::string season;
    if (month == ""January"" || month == ""February"" || month == ""March"") {
        season = ""winter"";
    } else if (month == ""April"" || month == ""May"" || month == ""June"") {
        season = ""spring"";
    } else if (month == ""July"" || month == ""August"" || month == ""September"") {
        season = ""summer"";
    } else {
        season = ""autumn"";
    }
//begin to write code
",510,"
#include <iostream>
#include <string>
#include <cassert>

std::string month_season(std::string month, int days) {
    std::string season;
    if (month == ""January"" || month == ""February"" || month == ""March"") {
        season = ""winter"";
    } else if (month == ""April"" || month == ""May"" || month == ""June"") {
        season = ""spring"";
    } else if (month == ""July"" || month == ""August"" || month == ""September"") {
        season = ""summer"";
    } else {
        season = ""autumn"";
    }

    if ((month == ""March"") && (days > 19)) {
        season = ""spring"";
    } else if ((month == ""June"") && (days > 20)) {
        season = ""summer"";
    } else if ((month == ""September"") && (days > 21)) {
        season = ""autumn"";
    } else if ((month == ""December"") && (days > 20)) {
        season = ""winter"";
    }

    return season;
}


","
#include <iostream>
#include <string>
#include <cassert>

std::string month_season(std::string month, int days) {
    std::string season;
    if (month == ""January"" || month == ""February"" || month == ""March"") {
        season = ""winter"";
    } else if (month == ""April"" || month == ""May"" || month == ""June"") {
        season = ""spring"";
    } else if (month == ""July"" || month == ""August"" || month == ""September"") {
        season = ""summer"";
    } else {
        season = ""autumn"";
    }
    return season;
}

","#include <iostream>
#include <string>
#include <cassert>
std::string month_season(std::string month, long days) {
    std::string season;
    if (""January"" == month || ""February"" == month || ""March"" == month) {
        season = ""winter"";
    } else if (""April"" == month || ""May"" == month || ""June"" == month) {
        season = ""spring"";
    } else if (""July"" == month || ""August"" == month || ""September"" == month) {
        season = ""summer"";
    } else {
        season = ""autumn"";
    }
//begin to write code
","
#include <iostream>
#include <string>
#include <cassert>

std::string month_season(std::string month, long days) {
    std::string season;
    if (""January"" == month || ""February"" == month || ""March"" == month) {
        season = ""winter"";
    } else if (""April"" == month || ""May"" == month || ""June"" == month) {
        season = ""spring"";
    } else if (""July"" == month || ""August"" == month || ""September"" == month) {
        season = ""summer"";
    } else {
        season = ""autumn"";
    }

    if ((""March"" == month) && (days > 19)) {
        season = ""spring"";
    } else if ((""June"" == month) && (days > 20)) {
        season = ""summer"";
    } else if ((""September"" == month) && (days > 21)) {
        season = ""autumn"";
    } else if ((""December"" == month) && (days > 20)) {
        season = ""winter"";
    }

    return season;
}


","
#include <iostream>
#include <string>
#include <cassert>

std::string month_season(std::string month, long days) {
    std::string season;
    if (""January"" == month || ""February"" == month || ""March"" == month) {
        season = ""winter"";
    } else if (""April"" == month || ""May"" == month || ""June"" == month) {
        season = ""spring"";
    } else if (""July"" == month || ""August"" == month || ""September"" == month) {
        season = ""summer"";
    } else {
        season = ""autumn"";
    }
    return season;
}

",-1,21,2.864516750971476,code_expression_exchange:equal_expression_transformation,1.0,0.6295081139002534,"{'\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string month_season(std::string month, long days) {\n    std::string season;\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        season = ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        season = ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n\n    if ((""March"" == month) && (days > 19)) {\n        season = ""spring"";\n    } else if ((""June"" == month) && (days > 20)) {\n        season = ""summer"";\n    } else if ((""September"" == month) && (days > 21)) {\n        season = ""autumn"";\n    } else if ((""December"" == month) && (days > 20)) {\n        season = ""winter"";\n    }\n\n    return season;\n}\n\n\n': [('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string month_season(std::string month, int days) {\n    std::string season;\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        season = ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        season = ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string month_season(std::string month, int days) {\n    std::string season;\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        season = ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        season = ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n    return season;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string month_season(std::string month, int days) {\n    std::string season;\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        season = ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        season = ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string month_season(std::string month, int days) {\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        return ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        return ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        return ""summer"";\n    } else {\n        return ""autumn"";\n    }\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string month_season(std::string month, int days) {\n    std::string season;\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        season = ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        season = ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string month_season(std::string month, int days) {\n    std::string season;\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        season = ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        season = ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n    return season;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string month_season(std::string month, int days) {\n    std::string season;\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        season = ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        season = ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string month_season(std::string month, int days) {\n    std::string season;\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        season = ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        season = ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n    return season;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string month_season(std::string month, int days) {\n    std::string season;\n    if (month == ""January"" || month == ""February"" || month == ""March"") {\n        season = ""winter"";\n    } else if (month == ""April"" || month == ""May"" || month == ""June"") {\n        season = ""spring"";\n    } else if (month == ""July"" || month == ""August"" || month == ""September"") {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string month_season(std::string month, int days) {\n    std::string season;\n    if (month == ""January"" || month == ""February"" || month == ""March"") {\n        season = ""winter"";\n    } else if (month == ""April"" || month == ""May"" || month == ""June"") {\n        season = ""spring"";\n    } else if (month == ""July"" || month == ""August"" || month == ""September"") {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n    return season;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string month_season(std::string month, int days) {\n    std::string season;\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        season = ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        season = ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string month_season(std::string month, int days) {\n    std::string season;\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        season = ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        season = ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n    return season;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string month_season(std::string month, long days) {\n    std::string season;\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        season = ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        season = ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string month_season(std::string month, long days) {\n    std::string season;\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        season = ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        season = ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n    return season;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string month_season(std::string month, long days) {\n    std::string season;\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        season = ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        season = ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string month_season(std::string month, long days) {\n    std::string season;\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        season = ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        season = ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n    return season;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string month_season(std::string month, long days) {\n    std::string season;\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        season = ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        season = ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string month_season(std::string month, long days) {\n    std::string season;\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        season = ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        season = ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n    return season;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string month_season(std::string month, long days) {\n    std::string season;\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        season = ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        season = ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string month_season(std::string month, long days) {\n    std::string season;\n    if (""January"" == month || ""February"" == month || ""March"" == month) {\n        season = ""winter"";\n    } else if (""April"" == month || ""May"" == month || ""June"" == month) {\n        season = ""spring"";\n    } else if (""July"" == month || ""August"" == month || ""September"" == month) {\n        season = ""summer"";\n    } else {\n        season = ""autumn"";\n    }\n    return season;\n}\n\n', 'equal_expression_transformation')]}"
149,"#include <iostream>
#include <cassert>
#include <tuple>
using namespace std;
tuple<string, int, string, int> solution(int a, int b, int n) {
    int i = 0;
    while (i * a <= n) {
        if ((n - (i * a)) % b == 0) {
            return make_tuple(""x = "", i, "", y = "", (n - (i * a)) / b);
//begin to write code
",312,"
#include <iostream>
#include <cassert>
#include <tuple>
using namespace std;

tuple<string, int, string, int> solution(int a, int b, int n) {
    int i = 0;
    while (i * a <= n) {
        if ((n - (i * a)) % b == 0) {
            return make_tuple(""x = "", i, "", y = "", (n - (i * a)) / b);
        }
        i++;
    }
    throw ""No solution"";
}


","
#include <iostream>
#include <cassert>
#include <tuple>
using namespace std;

tuple<string, int, string, int> solution(int a, int b, int n) {
    int i = 0;
    while (i * a <= n) {
        if ((n - (i * a)) % b == 0) {
            return make_tuple(""x = "", i, "", y = "", (n - (i * a)) / b);
        }
        i++;
    }
    return make_tuple(""No solution exists"");
}

",,,,-2,1,0.22976984977722167,code_expression_exchange:None,0.0,0.0,
150,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
std::vector<int> remove_elements(std::vector<int> list1, const std::vector<int>& list2) {
    std::vector<int> result;
    std::copy_if(list1.begin(), list1.end(), std::back_inserter(result),
//begin to write code
",291,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> remove_elements(std::vector<int> list1, const std::vector<int>& list2) {
    std::vector<int> result;
    std::copy_if(list1.begin(), list1.end(), std::back_inserter(result),
                 [&list2](int x){ return std::find(list2.begin(), list2.end(), x) == list2.end(); });
    return result;
}


","#include <cassert>
#include <iostream>
#include <vector>
#include <algorithm>
std::vector<int> remove_elements(std::vector<int> list1, const std::vector<int>& list2) {
    std::vector<int> result;
    std::copy_if(list1.begin(), list1.end(), std::back_inserter(result),
                  [](int element) { return list2.find(element) == std::string::npos; });
    return result;
}
",,,,-2,1,0.1667196234067281,code_expression_exchange:None,0.0,0.0,
151,"#include <iostream>
#include <cassert>
int sum_series(int n) {
    if (n < 1) {
        return 0;
//begin to write code
",120,"
#include <iostream>
#include <cassert>

int sum_series(int n) {
    if (n < 1) {
        return 0;
    } else {
        return n + sum_series(n - 2);
    }
}


","
using namespace std;
#include <iostream>
#include <cassert>

int sum_series(int n) {
    if (n < 1) {
        return 0;
    }
    int sum = 0;
    for (int i = 1; i <= n; ++i) {
        sum += i;
    }
    return sum;
}

",,,,-2,1,0.21566195885340372,code_expression_exchange:None,0.0,0.0,
152,"#include<iostream>
#include <cmath>
#include <cassert>
using namespace std;
double area_polygon(int s, double l) {
  double area = s * (l * l) / (4 * tan(M_PI / s));
//begin to write code
",188,"#include<iostream>
    

#include <cmath>
#include <cassert>

using namespace std;

double area_polygon(int s, double l) {
  double area = s * (l * l) / (4 * tan(M_PI / s));
  return area;
}


","
#include <iostream>
#include <cmath>
#include <cassert>
using namespace std;

double area_polygon(int s, double l) {
  double area = s * (l * l) / (4 * tan(M_PI / s));
  return area;
}

",,,,-2,1,0.1885856032371521,code_expression_exchange:None,0.0,0.0,
153,"#include<cassert>
#include <iostream>
#include <cmath>
using namespace std;
int divSum(int n) {
    int sum = 1;
    int i = 2;
    while (i * i <= n) {
        if (n % i == 0) {
            sum += i + (n / i);
        }
//begin to write code
",243,"#include<cassert>
#include <iostream>
#include <cmath>
using namespace std;

int divSum(int n) {
    int sum = 1;
    int i = 2;
    while (i * i <= n) {
        if (n % i == 0) {
            sum += i + (n / i);
        }
        i += 1;
    }
    return sum;
}

bool areEquivalent(int num1, int num2) {
    return divSum(num1) == divSum(num2);
}


","
#include<cassert>
#include <iostream>
#include <cmath>
using namespace std;

int divSum(int n) {
    int sum = 1;
    int i = 2;
    while (i * i <= n) {
        if (n % i == 0) {
            sum += i + (n / i);
        }
    }
    return sum;
}

",,,,-2,1,0.19014716943105062,code_expression_exchange:None,0.0,0.0,
154,"#include <iostream>
#include <string>
#include <cassert>
int count_char_position(const std::string& str1) {
    int count_chars = 0;
    for (size_t i = 0; i < str1.length(); ++i) {
        if ((i == static_cast<size_t>(str1[i] - 'A')) ||
            (i == static_cast<size_t>(str1[i] - 'a'))) {
//begin to write code
",318,"
#include <iostream>
#include <string>
#include <cassert>

int count_char_position(const std::string& str1) {
    int count_chars = 0;
    for (size_t i = 0; i < str1.length(); ++i) {
        if ((i == static_cast<size_t>(str1[i] - 'A')) ||
            (i == static_cast<size_t>(str1[i] - 'a'))) {
            count_chars += 1;
        }
    }
    return count_chars;
}


","
#include <iostream>
#include <string>
#include <cassert>
#include <cctype>

int count_char_position(const std::string& str1) {
    int count_chars = 0;
    for (size_t i = 0; i < str1.length(); ++i) {
        if ((i == static_cast<size_t>(std::tolower(str1[i])) ||
            (i == static_cast<size_t>(std::toupper(str1[i])))) {
            ++count_chars;
        }
    }
    return count_chars;
}

",,,,-2,1,0.20463432868321738,code_expression_exchange:None,0.0,0.0,
155,"#include <iostream>
#include <vector>
#include <cassert>
int find_even_Pair(const std::vector<int>& A, int N) {
    int evenPair = 0;
    for (int i = 0; i < N; ++i) {
        for (int j = i + 1; j < N; ++j) {
            if ((A[i] ^ A[j]) % 2 == 0) {
//begin to write code
",274,"
#include <iostream>
#include <vector>
#include <cassert>

int find_even_Pair(const std::vector<int>& A, int N) {
    int evenPair = 0;
    for (int i = 0; i < N; ++i) {
        for (int j = i + 1; j < N; ++j) {
            if ((A[i] ^ A[j]) % 2 == 0) {
                evenPair += 1;
            }
        }
    }
    return evenPair;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <cassert>

int find_even_Pair(const std::vector<int>& A, int N) {
    int evenPair = 0;
    for (int i = 0; i < N; ++i) {
        for (int j = i + 1; j < N; ++j) {
            if ((A[i] ^ A[j]) % 2 == 0) {
                evenPair++;
            }
        }
    }
    return evenPair;
}

void test_find_even_Pair() {
    assert(find_even_Pair({1, 2, 3, 4}, 4) == 2); // 1^2 + 3^2 = 2
    assert(find_even_Pair({1, 2, 3, 4, 5}, 5) == 0); // No even pairs
    assert(find_even_Pair({1, 2, 3, 4, 5, 6}, 6) == 4); // 1^2 + 3^2 + 5^2 = 15
    cout << ""All tests passed",,,,-2,1,0.2253853638966878,code_expression_exchange:None,0.0,0.0,
156,"#include <iostream>
#include <cassert>
int next_Power_Of_2(int n) {
    int count = 0;
    if (n && !(n & (n - 1))) {
        return n;
    }
//begin to write code
",164,"
#include <iostream>
#include <cassert>

int next_Power_Of_2(int n) {
    int count = 0;
    if (n && !(n & (n - 1))) {
        return n;
    }
    while (n != 0) {
        n >>= 1;
        count++;
    }
    return 1 << count;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include <iostream>
#include <cassert>
int next_Power_Of_2(int n) {
    int count = 0;
    if (n &&!(n & (n - 1))) {
        return n;
    }
    while (n > 0) {
        n >>= 1;
        count++;
    }
    return 1 << count;
}

","#include <iostream>
#include <cassert>
int next_Power_Of_2(int n) {
    int count = 0;
    if (n && !((n - 1) & n)) {
        return n;
    }
//begin to write code
","
#include <iostream>
#include <cassert>

int next_Power_Of_2(int n) {
    int count = 0;
    if (n && !((n - 1) & n)) {
        return n;
    }
    while (0 != n) {
        n >>= 1;
        count++;
    }
    return 1 << count;
}


","
using namespace std;

#include <iostream>
#include <cassert>

int next_Power_Of_2(int n) {
    int count = 0;
    if (n &&!((n - 1) & n)) {
        return n;
    }
    // Your code here
    return pow(2, count);
}

",1,5,0.7551336606343587,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nint next_Power_Of_2(int n) {\n    int count = 0;\n    if (n && !((n - 1) & n)) {\n        return n;\n    }\n    while (0 != n) {\n        n >>= 1;\n        count++;\n    }\n    return 1 << count;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint next_Power_Of_2(int n) {\n    int count = 0;\n    if (n && !(n & (n - 1))) {\n        return n;\n    }\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint next_Power_Of_2(int n) {\n    // Find the highest power of 2 less than or equal to n\n    int power = 1;\n    while (power <= n) {\n        power *= 2;\n    }\n    return power;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cassert>\nint next_Power_Of_2(int n) {\n    int count = 0;\n    if (n && !((n - 1) & n)) {\n        return n;\n    }\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint next_Power_Of_2(int n) {\n    int count = 0;\n    if (n &&!((n - 1) & n)) {\n        return n;\n    }\n    // Your code here\n    return pow(2, count);\n}\n\n', 'exchange_operators')]}"
157,"#include <iostream>
#include <vector>
#include <cassert>
int frequency(const std::vector<int>& a, int x) {
    int count = 0;
    for (int i : a) {
//begin to write code
",170,"
#include <iostream>
#include <vector>
#include <cassert>

int frequency(const std::vector<int>& a, int x) {
    int count = 0;
    for (int i : a) {
        if (i == x) count += 1;
    }
    return count;
}


","
#include <iostream>
#include <vector>
#include <cassert>

int frequency(const std::vector<int>& a, int x) {
    int count = 0;
    for (int i : a) {
        if (i == x) {
            count++;
        }
    }
    return count;
}

","#include <iostream>
#include <vector>
#include <cassert>
long frequency(const std::vector<long>& a, long x) {
    long count = 0;
    for (long i : a) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

long frequency(const std::vector<long>& a, long x) {
    long count = 0;
    for (long i : a) {
        if (x == i) count = count + (1);
    }
    return count;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <cassert>

long frequency(const std::vector<long>& a, long x) {
    long count = 0;
    for (long i : a) {
        if (i == x) {
            count++;
        }
    }
    return count;
}

",-1,21,2.7340932488441467,code_expression_exchange:exchange_operators,1.0,0.7650257611525744,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong frequency(const std::vector<long>& a, long x) {\n    long count = 0;\n    for (long i : a) {\n        if (x == i) count = count + (1);\n    }\n    return count;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nint frequency(const std::vector<int>& a, long x) {\n    int count = 0;\n    for (int i : a) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint frequency(const std::vector<int>& a, long x) {\n    int count = 0;\n    for (int i : a) {\n        if (i == x) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvoid test_frequency() {\n    assert(frequency({1, 2, 2, 3, 3, 3}, 2) == 3);\n    assert(frequency({1, 1, 1, 2, 2, 2}, 3) == 4);\n    assert(frequency({4, 4, 4, 4, 4, 4}, 4) == 5);\n    assert(frequency({10, 20, 30, 40}, 10) == 1);\n    cout << ""All tests passed successfully."" << endl;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint frequency(const std::vector<int>& a, long x) {\n    int count = 0;\n    for (int i : a) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint frequency(const std::vector<int>& a, long x) {\n    int count = 0;\n    for (int i : a) {\n        if (i == x) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvoid testFrequency() {\n    assert(frequency({1, 2, 2, 3, 3, 3, 4, 4, 4}, 2) == 3);\n    assert(frequency({5, 5, 5, 5, 5}, 5) == 5);\n    assert(frequency({}, 10) == 0);\n    assert(frequency({1, 2, 3, 4, 5}, 0) == 0);\n    cout << ""All tests passed!"" << endl;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong frequency(const std::vector<int>& a, long x) {\n    int count = 0;\n    for (int i : a) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong frequency(const std::vector<int>& a, long x) {\n    int count = 0;\n    for (int i : a) {\n        if (i == x) {\n            count++;\n        }\n    }\n    return count;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong frequency(const std::vector<int>& a, long x) {\n    int count = 0;\n    for (int i : a) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong frequency(const std::vector<int>& a, long x) {\n    int count = 0;\n    for (int i : a) {\n        if (i == x) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvoid test_frequency() {\n    assert(frequency({1, 2, 2, 3, 3, 3}, 2) == 3);\n    assert(frequency({5, 5, 5, 5, 5}, 5) == 5);\n    assert(frequency({10, 10, 10, 10, 10}, 10) == 5);\n    cout << ""All tests passed successfully."" << endl;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong frequency(const std::vector<int>& a, long x) {\n    int count = 0;\n    for (int i : a) {\n//begin to write code\n', '\nusing namespace std;\n#include <vector>\n#include <cassert>\n\nlong frequency(const std::vector<int>& a, long x) {\n    int count = 0;\n    for (int i : a) {\n        if (i == x) {\n            count++;\n        }\n    }\n    return count;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong frequency(const std::vector<int>& a, long x) {\n    long count = 0;\n    for (int i : a) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong frequency(const std::vector<int>& a, long x) {\n    long count = 0;\n    for (int i : a) {\n        if (i == x) {\n            count++;\n        }\n    }\n    return count;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong frequency(const std::vector<long>& a, long x) {\n    long count = 0;\n    for (int i : a) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong frequency(const std::vector<long>& a, long x) {\n    long count = 0;\n    for (int i : a) {\n        if (i == x) {\n            count++;\n        }\n    }\n    return count;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong frequency(const std::vector<long>& a, long x) {\n    long count = 0;\n    for (long i : a) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong frequency(const std::vector<long>& a, long x) {\n    long count = 0;\n    for (long i : a) {\n        if (i == x) {\n            count++;\n        }\n    }\n    return count;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong frequency(const std::vector<long>& a, long x) {\n    long count = 0;\n    for (long i : a) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong frequency(const std::vector<long>& a, long x) {\n    long count = 0;\n    for (long i : a) {\n        if (i == x) {\n            count++;\n        }\n    }\n    return count;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong frequency(const std::vector<long>& a, long x) {\n    long count = 0;\n    for (long i : a) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong frequency(const std::vector<long>& a, long x) {\n    long count = 0;\n    for (long i : a) {\n        if (i == x) {\n            count++;\n        }\n    }\n    return count;\n}\n\n', 'exchange_operators')]}"
158,"#include<cassert>
#include<iostream>
int get_pell(int n) {
    if (n <= 2) {
        return n;
    }
    int a = 1;
    int b = 2;
//begin to write code
",153,"#include<cassert>
#include<iostream>

int get_pell(int n) {
    if (n <= 2) {
        return n;
    }
    int a = 1;
    int b = 2;
    for (int i = 3; i <= n; ++i) {
        int c = 2 * b + a;
        a = b;
        b = c;
    }
    return b;
}


","
#include<cassert>
#include<iostream>
using namespace std;

// Function to calculate the nth pell number
int get_pell(int n) {
    if (n <= 2) {
        return n;
    }
    int a = 1;
    int b = 2;
    for (int i = 3; i <= n; ++i) {
        int next = a + b;
        a = b;
        b = next;
    }
    return b;
}

",,,,-2,1,0.2314813454945882,code_expression_exchange:None,0.0,0.0,
159,"#include <iostream>
#include <vector>
#include <cassert>
int sum_range_list(const std::vector<int>& list1, int m, int n) {
    int sum_range = 0;
    for (int i = m; i <= n; ++i) {
//begin to write code
",203,"
#include <iostream>
#include <vector>
#include <cassert>

int sum_range_list(const std::vector<int>& list1, int m, int n) {
    int sum_range = 0;
    for (int i = m; i <= n; ++i) {
        sum_range += list1[i];
    }
    return sum_range;
}


","
#include <iostream>
#include <vector>
#include <cassert>

int sum_range_list(const std::vector<int>& list1, int m, int n) {
    int sum_range = 0;
    for (int i = m; i <= n; ++i) {
        sum_range += list1[i];
    }
    return sum_range;
}

","#include <iostream>
#include <vector>
#include <cassert>
int sum_range_list(const std::vector<int>& list1, int m, int n) {
    int sum_range = 0;
    for (int i = m; i <= n; ++i) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

int sum_range_list(const std::vector<int>& list1, int m, int n) {
    int sum_range = 0;
    for (int i = m; i <= n; ++i) {
        sum_range += list1[i];
    }
    return sum_range;
}


","#include <iostream>
#include <vector>
#include <cassert>

int max_subarray_sum(const std::vector<int>& nums) {
    if (nums.empty()) {
        return 0;
    }

    int max_current = nums[0];
    int max_global = nums[0];

    for (size_t i = 1; i < nums.size(); ++i) {
        max_current = std::max(nums[i], max_current + nums[i]);
        max_global = std::max(max_global, max_current);
    }

    return max_global;
}
",1,5,0.7503965695699056,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint sum_range_list(const std::vector<int>& list1, int m, int n) {\n    int sum_range = 0;\n    for (int i = m; i <= n; ++i) {\n        sum_range += list1[i];\n    }\n    return sum_range;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nint sum_range_list(const std::vector<int>& list1, int m, int n) {\n    int sum_range = 0;\n    for (int i = m; i <= n; ++i) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint sum_range_list(const std::vector<int>& list1, int m, int n) {\n    int sum_range = 0;\n    for (int i = m; i <= n; ++i) {\n        sum_range += list1[i];\n    }\n    return sum_range;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint sum_range_list(const std::vector<int>& list1, int m, int n) {\n    int sum_range = 0;\n    for (int i = m; i <= n; ++i) {\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <cassert>\n\nint max_subarray_sum(const std::vector<int>& nums) {\n    if (nums.empty()) {\n        return 0;\n    }\n\n    int max_current = nums[0];\n    int max_global = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        max_current = std::max(nums[i], max_current + nums[i]);\n        max_global = std::max(max_global, max_current);\n    }\n\n    return max_global;\n}\n', 'exchange_operators')]}"
160,"#include <iostream>
#include <cassert>
int perimeter_pentagon(int a) {
    int perimeter = 5 * a;
//begin to write code
",120,"
#include <iostream>
#include <cassert>

int perimeter_pentagon(int a) {
    int perimeter = 5 * a;
    return perimeter;
}


","
using namespace std;

#include <iostream>
#include <cassert>

int perimeter_pentagon(int a) {
    int perimeter = 5 * a;
    return perimeter;
}

","#include <iostream>
#include <cassert>
int perimeter_pentagon(long a) {
    long perimeter = a * 5;
//begin to write code
","
#include <iostream>
#include <cassert>

int perimeter_pentagon(long a) {
    long perimeter = a * 5;
    return perimeter;
}


","
using namespace std;
#include <iostream>

int perimeter_pentagon(long a) {
    long perimeter = a * 5;
    return perimeter;
}

",1,11,1.319012991587321,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nint perimeter_pentagon(long a) {\n    long perimeter = a * 5;\n    return perimeter;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint perimeter_pentagon(long a) {\n    int perimeter = 5 * a;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint perimeter_pentagon(long a) {\n    return 5 * a;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nint perimeter_pentagon(long a) {\n    int perimeter = a * 5;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nint perimeter_pentagon(long a) {\n    return a * 5;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cassert>\nint perimeter_pentagon(long a) {\n    int perimeter = a * 5;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nint perimeter_pentagon(long a) {\n    int perimeter = a * 5;\n    return perimeter;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cassert>\nint perimeter_pentagon(long a) {\n    int perimeter = a * 5;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nint perimeter_pentagon(long a) {\n    return a * 5;\n}\n\n// Test cases to verify the correctness of the perimeter_pentagon function\nvoid test_perimeter_pentagon() {\n    assert(perimeter_pentagon(5) == 20);\n    assert(perimeter_pentagon(6) == 30);\n    assert(perimeter_pentagon(7) == 35);\n    assert(perimeter_pentagon(8) == 40);\n    std::cout << ""All test cases passed successfully."" << std::endl;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cassert>\nint perimeter_pentagon(long a) {\n    long perimeter = a * 5;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n\nint perimeter_pentagon(long a) {\n    long perimeter = a * 5;\n    return perimeter;\n}\n\n', 'more_universe_var_type')]}"
161,"#include <iostream>
#include <cassert>
#include <string>
int count_occurance(const std::string &s) {
    int count = 0;
    for (size_t i = 0; i + 2 < s.length(); ++i) {
        if (s[i] == 's' && s[i + 1] == 't' && s[i + 2] == 'd') {
//begin to write code
",257,"
#include <iostream>
#include <cassert>
#include <string>

int count_occurance(const std::string &s) {
    int count = 0;
    for (size_t i = 0; i + 2 < s.length(); ++i) {
        if (s[i] == 's' && s[i + 1] == 't' && s[i + 2] == 'd') {
            count++;
        }
    }
    return count;
}


","
using namespace std;

#include <iostream>
#include <cassert>
#include <string>

int count_occurance(const std::string &s) {
    int count = 0;
    for (size_t i = 0; i + 2 < s.length(); ++i) {
        if (s[i] =='s' && s[i + 1] == 't' && s[i + 2] == 'd') {
            ++count;
        }
    }
    return count;
}

","#include <iostream>
#include <cassert>
#include <string>
int count_occurance(const std::string &s) {
    int count = 0;
    for (size_t i = 0; 2 + i < s.length(); ++i) {
        if ('s' == s[i] && 't' == s[1 + i] && 'd' == s[2 + i]) {
//begin to write code
","
#include <iostream>
#include <cassert>
#include <string>

int count_occurance(const std::string &s) {
    int count = 0;
    for (size_t i = 0; 2 + i < s.length(); ++i) {
        if ('s' == s[i] && 't' == s[1 + i] && 'd' == s[2 + i]) {
            count = 1 + count;
        }
    }
    return count;
}


","using namespace std;

int max_consecutive_occurrences(const string &s) {
    int max_count = 0;
    int current_count = 0;
    
    for (char ch : s) {
        if (ch =='') {
            max_count = max(max_count, current_count);
            current_count = 0;
        } else {
            current_count++;
        }
    }
    
    // Handle trailing spaces
    max_count = max(max_count, current_count);
    
    return max_count;
}
",1,7,0.9559564828872681,code_expression_exchange:exchange_operators,1.0,0.0,"{""\n#include <iostream>\n#include <cassert>\n#include <string>\n\nint count_occurance(const std::string &s) {\n    int count = 0;\n    for (size_t i = 0; 2 + i < s.length(); ++i) {\n        if ('s' == s[i] && 't' == s[1 + i] && 'd' == s[2 + i]) {\n            count = 1 + count;\n        }\n    }\n    return count;\n}\n\n\n"": [(""#include <iostream>\n#include <cassert>\n#include <string>\nint count_occurance(const std::string &s) {\n    int count = 0;\n    for (size_t i = 0; i + 2 < s.length(); ++i) {\n        if (s[i] == 's' && s[i + 1] == 't' && s[i + 2] == 'd') {\n//begin to write code\n"", ""\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n#include <string>\n\nint count_occurance(const std::string &s) {\n    int count = 0;\n    for (size_t i = 0; i + 2 < s.length(); ++i) {\n        if (s[i] =='s' && s[i + 1] == 't' && s[i + 2] == 'd') {\n            ++count;\n        }\n    }\n    return count;\n}\n\n"", 'equal_expression_transformation'), (""#include <iostream>\n#include <cassert>\n#include <string>\nint count_occurance(const std::string &s) {\n    int count = 0;\n    for (size_t i = 0; i + 2 < s.length(); ++i) {\n        if (s[i] == 's' && s[i + 1] == 't' && s[i + 2] == 'd') {\n//begin to write code\n"", ""\nusing namespace std;\n#include <iostream>\n#include <cassert>\n#include <string>\n\nint count_occurance(const std::string &s) {\n    int count = 0;\n    for (size_t i = 0; i + 2 < s.length(); ++i) {\n        if (s[i] =='s' && s[i + 1] == 't' && s[i + 2] == 'd') {\n            ++count;\n        }\n    }\n    return count;\n}\n\n"", 'equal_expression_transformation'), (""#include <iostream>\n#include <cassert>\n#include <string>\nint count_occurance(const std::string &s) {\n    int count = 0;\n    for (size_t i = 0; 2 + i < s.length(); ++i) {\n        if ('s' == s[i] && 't' == s[1 + i] && 'd' == s[2 + i]) {\n//begin to write code\n"", ""using namespace std;\n\nint max_consecutive_occurrences(const string &s) {\n    int max_count = 0;\n    int current_count = 0;\n    \n    for (char ch : s) {\n        if (ch =='') {\n            max_count = max(max_count, current_count);\n            current_count = 0;\n        } else {\n            current_count++;\n        }\n    }\n    \n    // Handle trailing spaces\n    max_count = max(max_count, current_count);\n    \n    return max_count;\n}\n"", 'exchange_operators')]}"
162,"#include <iostream>
#include <string>
#include <regex>
#include <cassert>
using namespace std;
string remove_splchar(const string& text) {
    regex pattern(""[\\\W_]+"");
//begin to write code
",192,"
#include <iostream>
#include <string>
#include <regex>
#include <cassert>

using namespace std;

string remove_splchar(const string& text) {
    regex pattern(""[\\\W_]+"");
    return regex_replace(text, pattern, """");
}","
#include <iostream>
#include <string>
#include <regex>
#include <cassert>
using namespace std;

string remove_splchar(const string& text) {
    regex pattern(""[\\W_]+"");
    return text.begin() + regex_replace(text.begin(), text.end(), pattern, """");
}

",,,,-2,1,0.21891864140828451,code_expression_exchange:None,0.0,0.0,
163,"#include<iostream>
#include <map>
#include <vector>
#include <string>
#include <cassert>
using namespace std;
map<string, vector<int>> group_keyvalue(vector<pair<string, int>> l) {
    map<string, vector<int>> result;
    for (auto& p : l) {
//begin to write code
",264,"#include<iostream>
    

#include <map>
#include <vector>
#include <string>
#include <cassert>

using namespace std;

map<string, vector<int>> group_keyvalue(vector<pair<string, int>> l) {
    map<string, vector<int>> result;
    for (auto& p : l) {
        result[p.first].push_back(p.second);
    }
    return result;
}


","
#include<iostream>
#include <map>
#include <vector>
#include <string>
#include <cassert>
using namespace std;

map<string, vector<int>> group_keyvalue(vector<pair<string, int>> l) {
    map<string, vector<int>> result;
    for (auto& p : l) {
        result[p.first].push_back(p.second);
    }
    return result;
}

","#include<iostream>
#include <map>
#include <vector>
#include <string>
#include <cassert>
using namespace std;
map<string, vector<int>> group_keyvalue(vector<pair<string, int>> l) {
    map<string, vector<long>> result;
    for (auto& p : l) {
//begin to write code
","#include<iostream>
    

#include <map>
#include <vector>
#include <string>
#include <cassert>

using namespace std;

map<string, vector<int>> group_keyvalue(vector<pair<string, int>> l) {
    map<string, vector<long>> result;
    for (auto& p : l) {
        result[p.first].push_back(p.second);
    }
    return result;
}


","
#include<iostream>
#include <map>
#include <vector>
#include <string>
#include <cassert>

using namespace std;

map<string, vector<long>> group_keyvalue(vector<pair<string, int>> l) {
    map<string, vector<long>> result;
    for (auto& p : l) {
        result[p.first].push_back(p.second);
    }
    return result;
}

",1,7,0.9636286775271098,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<iostream>\n    \n\n#include <map>\n#include <vector>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nmap<string, vector<int>> group_keyvalue(vector<pair<string, int>> l) {\n    map<string, vector<long>> result;\n    for (auto& p : l) {\n        result[p.first].push_back(p.second);\n    }\n    return result;\n}\n\n\n': [('#include<iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <cassert>\nusing namespace std;\nmap<string, vector<int>> group_keyvalue(vector<pair<string, int>> l) {\n    map<string, vector<int>> result;\n    for (auto& p : l) {\n//begin to write code\n', '\n#include<iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nmap<string, vector<int>> group_keyvalue(vector<pair<string, int>> l) {\n    map<string, vector<int>> result;\n    for (auto& p : l) {\n        result[p.first].push_back(p.second);\n    }\n    return result;\n}\n\n', 'equal_expression_transformation'), ('#include<iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <cassert>\nusing namespace std;\nmap<string, vector<int>> group_keyvalue(vector<pair<string, int>> l) {\n    map<string, vector<int>> result;\n    for (auto& p : l) {\n//begin to write code\n', '\n#include<iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nmap<string, vector<int>> group_keyvalue(vector<pair<string, int>> l) {\n    map<string, vector<int>> result;\n    for (auto& p : l) {\n        result[p.first].push_back(p.second);\n    }\n    return result;\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <cassert>\nusing namespace std;\nmap<string, vector<int>> group_keyvalue(vector<pair<string, int>> l) {\n    map<string, vector<long>> result;\n    for (auto& p : l) {\n//begin to write code\n', '\n#include<iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nmap<string, vector<long>> group_keyvalue(vector<pair<string, int>> l) {\n    map<string, vector<long>> result;\n    for (auto& p : l) {\n        result[p.first].push_back(p.second);\n    }\n    return result;\n}\n\n', 'more_universe_var_type')]}"
164,"#include<cassert>
#include <iostream>
#include <stack>
#include <map>
bool is_valid_parenthese(std::string str1) {
    std::stack<char> stack;
    std::map<char, char> pchar = {{'(', ')'}, {'{', '}'}, {'[', ']'}};
    for (char parenthese : str1) {
        if (pchar.find(parenthese) != pchar.end()) {
            stack.push(parenthese);
        } else {
//begin to write code
",377,"#include<cassert>
#include <iostream>
#include <stack>
#include <map>

bool is_valid_parenthese(std::string str1) {
    std::stack<char> stack;
    std::map<char, char> pchar = {{'(', ')'}, {'{', '}'}, {'[', ']'}};
    for (char parenthese : str1) {
        if (pchar.find(parenthese) != pchar.end()) {
            stack.push(parenthese);
        } else {
            if (stack.empty() || pchar[stack.top()] != parenthese) {
                return false;
            }
            stack.pop();
        }
    }
    return stack.empty();
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>
#include<stack>
#include<map>

bool is_valid_parenthese(std::string str1) {
    std::stack<char> stack;
    std::map<char, char> pchar = {{'(', ')'}, {'{', '}'}, {'[', ']'}};
    for (char parenthese : str1) {
        if (pchar.find(parenthese)!= pchar.end()) {
            stack.push(parenthese);
        } else {
            // Check if the stack is empty or the top element doesn't match the corresponding opening parenthesis
            if (stack.empty() || stack.top()!= pchar[parenthese]) {
                return false;
            }
            // Pop the top element from the stack
            stack.pop();
        }
    }
    // If the stack is empty, all parentheses were matched correctly
    return stack.empty();
}

",,,,-2,1,0.23084015846252443,code_expression_exchange:None,0.0,0.0,
165,"#include<iostream>
#include <cassert>
int perimeter_triangle(int a, int b, int c) {
    int perimeter = a + b + c;
//begin to write code
",137,"#include<iostream>
    

#include <cassert>

int perimeter_triangle(int a, int b, int c) {
    int perimeter = a + b + c;
    return perimeter;
}


","
using namespace std;

#include<iostream>
#include <cassert>

int perimeter_triangle(int a, int b, int c) {
    int perimeter = a + b + c;
    return perimeter;
}

","#include<iostream>
#include <cassert>
int perimeter_triangle(int a, int b, int c) {
    int perimeter = a + b + c;
//begin to write code
","#include<iostream>
    

#include <cassert>

int perimeter_triangle(int a, int b, int c) {
    int perimeter = a + b + c;
    return perimeter;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<cmath>

int perimeter_triangle(int a, int b, int c) {
    return a + b + c;
}

",1,3,0.40065555572509765,code_expression_exchange:exchange_operators,1.0,0.0,"{'#include<iostream>\n    \n\n#include <cassert>\n\nint perimeter_triangle(int a, int b, int c) {\n    int perimeter = a + b + c;\n    return perimeter;\n}\n\n\n': [('#include<iostream>\n#include <cassert>\nint perimeter_triangle(int a, int b, int c) {\n    int perimeter = a + b + c;\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<cmath>\n\nint perimeter_triangle(int a, int b, int c) {\n    return a + b + c;\n}\n\n', 'exchange_operators')]}"
166,"#include <iostream>
#include <cassert>
#include <utility> // For std::pair
std::pair<int, int> answer(int L, int R) {
    if (2 * L <= R) {
        return std::make_pair(L, 2 * L);
//begin to write code
",203,"
#include <iostream>
#include <cassert>
#include <utility> // For std::pair

std::pair<int, int> answer(int L, int R) {
    if (2 * L <= R) {
        return std::make_pair(L, 2 * L);
    } else {
        return std::make_pair(-1, -1);
    }
}


","
using namespace std;
#include <iostream>
#include <cassert>
#include <utility> // For std::pair

std::pair<int, int> answer(int L, int R) {
    if (2 * L <= R) {
        return std::make_pair(L, 2 * L);
    } else {
        return std::make_pair(0, 0); // If L > R, return (0, 0) because the L and R cannot be paired
    }
}

","#include <iostream>
#include <cassert>
#include <utility> // For std::pair
std::pair<int, int> answer(int L, int R) {
    if (2 * L <= R) {
        return std::make_pair(L, 2 * L);
//begin to write code
","
#include <iostream>
#include <cassert>
#include <utility> // For std::pair

std::pair<int, int> answer(int L, int R) {
    if (2 * L <= R) {
        return std::make_pair(L, 2 * L);
    } else {
        return std::make_pair(-1, -1);
    }
}


","
#include <iostream>
#include <cassert>
#include <utility> // For std::pair
#include <cmath>   // For std::gcd

std::pair<int, int> answer(int L, int R) {
    if (2 * L <= R) {
        // Find the GCD of L and R
        int gcd = std::gcd(L, R);
        
        // Calculate the LCM using the formula LCM(a, b) = |a * b| / GCD(a, b)
        int lcm = std::abs(L * R) / gcd",1,3,0.48389981587727865,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n#include <utility> // For std::pair\n\nstd::pair<int, int> answer(int L, int R) {\n    if (2 * L <= R) {\n        return std::make_pair(L, 2 * L);\n    } else {\n        return std::make_pair(-1, -1);\n    }\n}\n\n\n': [('#include <iostream>\n#include <cassert>\n#include <utility> // For std::pair\nstd::pair<int, int> answer(int L, int R) {\n    if (2 * L <= R) {\n        return std::make_pair(L, 2 * L);\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n#include <utility> // For std::pair\n#include <cmath>   // For std::gcd\n\nstd::pair<int, int> answer(int L, int R) {\n    if (2 * L <= R) {\n        // Find the GCD of L and R\n        int gcd = std::gcd(L, R);\n        \n        // Calculate the LCM using the formula LCM(a, b) = |a * b| / GCD(a, b)\n        int lcm = std::abs(L * R) / gcd', 'equal_expression_transformation')]}"
167,"#include<iostream>
#include <string>
#include <vector>
#include <regex>
#include <cassert>
using namespace std;
string string_Literals(const vector<string>& patterns, const string& text) {
    for (const auto& pattern : patterns) {
        regex re_pattern(pattern);
        if (regex_search(text, re_pattern)) {
            return ""Matched!"";
//begin to write code
",366,"#include<iostream>
    
#include <string>
#include <vector>
#include <regex>
#include <cassert>

using namespace std;

string string_Literals(const vector<string>& patterns, const string& text) {
    for (const auto& pattern : patterns) {
        regex re_pattern(pattern);
        if (regex_search(text, re_pattern)) {
            return ""Matched!"";
        } else {
            return ""Not Matched!"";
        }
    }
    return ""Not Matched!"";
}","
#include<iostream>
#include <string>
#include <vector>
#include <regex>
#include <cassert>
using namespace std;

string string_Literals(const vector<string>& patterns, const string& text) {
    for (const auto& pattern : patterns) {
        regex re_pattern(pattern);
        if (regex_search(text, re_pattern)) {
            return ""Matched!"";
        }
    }
    return ""No matches found."";
}

",,,,-2,1,0.2563529054323832,code_expression_exchange:None,0.0,0.0,
168,"#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;
bool is_num_keith(int x) {
    vector<int> terms;
    int temp = x;
    int n = 0;
    while (temp > 0) {
        terms.push_back(temp % 10);
        temp = temp / 10;
        n++;
    }
    reverse(terms.begin(), terms.end());
    int next_term = 0;
    int i = n;
//begin to write code
",386,"#include<iostream>
    

#include <vector>
#include <algorithm>
#include <cassert>

using namespace std;

bool is_num_keith(int x) {
    vector<int> terms;
    int temp = x;
    int n = 0;
    while (temp > 0) {
        terms.push_back(temp % 10);
        temp = temp / 10;
        n++;
    }
    reverse(terms.begin(), terms.end());
    int next_term = 0;
    int i = n;
    while (next_term < x) {
        next_term = 0;
        for (int j = 1; j <= n; j++) {
            next_term += terms[i - j];
        }
        if (next_term > x) {
            break;
        }
        terms.push_back(next_term);
        i++;
    }
    return (next_term == x);
}


","
#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

bool is_num_keith(int x) {
    vector<int> terms;
    int temp = x;
    int n = 0;
    while (temp > 0) {
        terms.push_back(temp % 10);
        temp = temp / 10;
        n++;
    }
    reverse(terms.begin(), terms.end());
    int next_term = 0;
    int i = n;
    for (int j = 0; j < n - 1; j++) {
        next_term += terms[j];
    }
    return next_term == x;
}

",,,,-2,1,0.2342601537704468,code_expression_exchange:None,0.0,0.0,
169,"#include <cmath>
#include <cassert>
#include <iostream>
using namespace std;
double distance_lat_long(double slat, double slon, double elat, double elon) {
    double dist = 6371.01 * acos(sin(slat) * sin(elat) + cos(slat) * cos(elat) * cos(slon - elon));
//begin to write code
",278,"
#include <cmath>
#include <cassert>
#include <iostream>
using namespace std;


double distance_lat_long(double slat, double slon, double elat, double elon) {
    double dist = 6371.01 * acos(sin(slat) * sin(elat) + cos(slat) * cos(elat) * cos(slon - elon));
    return dist;
}","
#include <cmath>
#include <cassert>
#include <iostream>
using namespace std;

// Function to calculate distance between two points using latitude and longitude
double distance_lat_long(double slat, double slon, double elat, double elon) {
    double dist = 6371.01 * acos(sin(slat) * sin(elat) + cos(slat) * cos(elat) * cos(slon - elon));
    return dist;
}

",,,,-2,1,0.22326147556304932,code_expression_exchange:None,0.0,0.0,
170,"#include<cassert>
#include <iostream>
#include <string>
#include <vector>
std::string common_prefix_util(const std::string& str1, const std::string& str2) {
    std::string result;
    int n1 = str1.length();
    int n2 = str2.length();
    int i = 0;
    int j = 0;
    while (i < n1 && j < n2) {
        if (str1[i] != str2[j]) {
            break;
        }
        result += str1[i];
//begin to write code
",410,"#include<cassert>
#include <iostream>
#include <string>
#include <vector>

std::string common_prefix_util(const std::string& str1, const std::string& str2) {
    std::string result;
    int n1 = str1.length();
    int n2 = str2.length();
    int i = 0;
    int j = 0;
    while (i < n1 && j < n2) {
        if (str1[i] != str2[j]) {
            break;
        }
        result += str1[i];
        i++;
        j++;
    }
    return result;
}

std::string common_prefix(const std::vector<std::string>& arr, int n) {
    std::string prefix = arr[0];
    for (int i = 1; i < n; i++) {
        prefix = common_prefix_util(prefix, arr[i]);
    }
    return prefix;
}


","
#include<cassert>
#include <iostream>
#include <string>
#include <vector>
std::string common_prefix_util(const std::string& str1, const std::string& str2) {
    std::string result;
    int n1 = str1.length();
    int n2 = str2.length();
    int i = 0;
    int j = 0;
    while (i < n1 && j < n2) {
        if (str1[i]!= str2[j]) {
            break;
        }
        result += str1[i];
    }
    return result;
}

",,,,-2,1,0.2247613231341044,code_expression_exchange:None,0.0,0.0,
171,"#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>
#include <cctype> // For std::isupper, std::islower, std::isdigit
using namespace std;
tuple<vector<char>, vector<char>, vector<char>, vector<char>> find_character(const string& str) {
    vector<char> uppercase_characters;
    vector<char> lowercase_characters;
    vector<char> numerical_characters;
    vector<char> special_characters;
    for (char c : str) {
        if (isupper(c)) {
            uppercase_characters.push_back(c);
        } else if (islower(c)) {
//begin to write code
",566,"
#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>
#include <cctype> // For std::isupper, std::islower, std::isdigit

using namespace std;

tuple<vector<char>, vector<char>, vector<char>, vector<char>> find_character(const string& str) {
    vector<char> uppercase_characters;
    vector<char> lowercase_characters;
    vector<char> numerical_characters;
    vector<char> special_characters;

    for (char c : str) {
        if (isupper(c)) {
            uppercase_characters.push_back(c);
        } else if (islower(c)) {
            lowercase_characters.push_back(c);
        } else if (isdigit(c)) {
            numerical_characters.push_back(c);
        } else if (c == ',' || c == '.' || c == '!' || c == '?') {
            special_characters.push_back(c);
        }
    }

    return make_tuple(uppercase_characters, lowercase_characters, numerical_characters, special_characters);
}


","
#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>
#include <cctype> // For std::isupper, std::islower, std::isdigit
using namespace std;

tuple<vector<char>, vector<char>, vector<char>, vector<char>> find_character(const string& str) {
    vector<char> uppercase_characters;
    vector<char> lowercase_characters;
    vector<char> numerical_characters;
    vector<char> special_characters;
    for (char c : str) {
        if (std::isupper(c)) {
            uppercase_characters.push_back(c);
        } else if (std::islower(c)) {
            lowercase_characters.push_back(c);
        } else if (std::isdigit(c)) {
            numerical_characters.push_back(c);
        } else {
            special_characters.push_back(c);
        }
    }
    return {uppercase_characters, lowercase_characters, numerical_characters, special_characters};
}

","#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>
#include <cctype> // For std::isupper, std::islower, std::isdigit
using namespace std;
tuple<vector<char>, vector<char>, vector<char>, vector<char>> find_character(const string& str) {
    vector<char> uppercase_characters;
    vector<char> lowercase_characters;
    vector<char> numerical_characters;
    vector<char> special_characters;
    for (char c : str) {
        if (isupper(c)) {
            uppercase_characters.push_back(c);
        } else if (islower(c)) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>
#include <cctype> // For std::isupper, std::islower, std::isdigit

using namespace std;

tuple<vector<char>, vector<char>, vector<char>, vector<char>> find_character(const string& str) {
    vector<char> uppercase_characters;
    vector<char> lowercase_characters;
    vector<char> numerical_characters;
    vector<char> special_characters;

    for (char c : str) {
        if (isupper(c)) {
            uppercase_characters.push_back(c);
        } else if (islower(c)) {
            lowercase_characters.push_back(c);
        } else if (isdigit(c)) {
            numerical_characters.push_back(c);
        } else if (c == ',' || c == '.' || c == '!' || c == '?') {
            special_characters.push_back(c);
        }
    }

    return make_tuple(uppercase_characters, lowercase_characters, numerical_characters, special_characters);
}


","
#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>
#include <cctype> // For std::isupper, std::islower, std::isdigit
using namespace std;

tuple<vector<char>, vector<char>, vector<char>, vector<char>> find_character(const string& str) {
    vector<char> uppercase_characters;
    vector<char> lowercase_characters;
    vector<char> numerical_characters;
    vector<char> special_characters;
    
    // Regular expression to match uppercase letters
    regex upper_regex(""[A-Z]"");
    
    // Regular expression to match lowercase letters
    regex lower_regex(""[a-z]"");
    
    // Regular expression to match digits
    regex digit_regex(""[0-9]"");
    
    // Regular expression to match special characters
    regex special_regex(""[^A-Za-z0-9]"");
    
    // Iterate over each character in the string
    for (char c : str) {
        if (upper_regex.match(c)) {
            uppercase_characters.push_back(c);
        }",1,5,0.8803935805956523,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{""\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n#include <cctype> // For std::isupper, std::islower, std::isdigit\n\nusing namespace std;\n\ntuple<vector<char>, vector<char>, vector<char>, vector<char>> find_character(const string& str) {\n    vector<char> uppercase_characters;\n    vector<char> lowercase_characters;\n    vector<char> numerical_characters;\n    vector<char> special_characters;\n\n    for (char c : str) {\n        if (isupper(c)) {\n            uppercase_characters.push_back(c);\n        } else if (islower(c)) {\n            lowercase_characters.push_back(c);\n        } else if (isdigit(c)) {\n            numerical_characters.push_back(c);\n        } else if (c == ',' || c == '.' || c == '!' || c == '?') {\n            special_characters.push_back(c);\n        }\n    }\n\n    return make_tuple(uppercase_characters, lowercase_characters, numerical_characters, special_characters);\n}\n\n\n"": [('#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n#include <cctype> // For std::isupper, std::islower, std::isdigit\nusing namespace std;\ntuple<vector<char>, vector<char>, vector<char>, vector<char>> find_character(const string& str) {\n    vector<char> uppercase_characters;\n    vector<char> lowercase_characters;\n    vector<char> numerical_characters;\n    vector<char> special_characters;\n    for (char c : str) {\n        if (isupper(c)) {\n            uppercase_characters.push_back(c);\n        } else if (islower(c)) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n#include <cctype> // For std::isupper, std::islower, std::isdigit\nusing namespace std;\n\ntuple<vector<char>, vector<char>, vector<char>, vector<char>> find_character(const string& str) {\n    vector<char> uppercase_characters;\n    vector<char> lowercase_characters;\n    vector<char> numerical_characters;\n    vector<char> special_characters;\n\n    for (char c : str) {\n        if (std::isupper(c)) {\n            uppercase_characters.push_back(c);\n        } else if (std::islower(c)) {\n            lowercase_characters.push_back(c);\n        } else if (std::isdigit(c)) {\n            numerical_characters.push_back(c);\n        } else {\n            special_characters.push_back(c);\n        }\n    }\n\n    return {uppercase_characters, lowercase_characters, numerical_characters, special_characters};\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n#include <cctype> // For std::isupper, std::islower, std::isdigit\nusing namespace std;\ntuple<vector<char>, vector<char>, vector<char>, vector<char>> find_character(const string& str) {\n    vector<char> uppercase_characters;\n    vector<char> lowercase_characters;\n    vector<char> numerical_characters;\n    vector<char> special_characters;\n    for (char c : str) {\n        if (isupper(c)) {\n            uppercase_characters.push_back(c);\n        } else if (islower(c)) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n#include <cctype> // For std::isupper, std::islower, std::isdigit\nusing namespace std;\n\ntuple<vector<char>, vector<char>, vector<char>, vector<char>> find_character(const string& str) {\n    vector<char> uppercase_characters;\n    vector<char> lowercase_characters;\n    vector<char> numerical_characters;\n    vector<char> special_characters;\n    \n    // Regular expression to match uppercase letters\n    regex upper_regex(""[A-Z]"");\n    \n    // Regular expression to match lowercase letters\n    regex lower_regex(""[a-z]"");\n    \n    // Regular expression to match digits\n    regex digit_regex(""[0-9]"");\n    \n    // Regular expression to match special characters\n    regex special_regex(""[^A-Za-z0-9]"");\n    \n    // Iterate over each character in the string\n    for (char c : str) {\n        if (upper_regex.match(c)) {\n            uppercase_characters.push_back(c);\n        }', 'equal_expression_transformation')]}"
172,"#include <iostream>
#include <vector>
#include <cassert>
int count_pairs(const std::vector<int>& arr, int n, int k) {
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (abs(arr[i] - arr[j]) == k) {
//begin to write code
",280,"
#include <iostream>
#include <vector>
#include <cassert>

int count_pairs(const std::vector<int>& arr, int n, int k) {
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (abs(arr[i] - arr[j]) == k) {
                count++;
            }
        }
    }
    return count;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <cassert>

int count_pairs(const std::vector<int>& arr, int n, int k) {
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (abs(arr[i] - arr[j]) == k) {
                count++;
            }
        }
    }
    return count;
}

","#include <iostream>
#include <vector>
#include <cassert>
int count_pairs(const std::vector<int>& arr, int n, int k) {
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (abs(arr[i] - arr[j]) == k) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

int count_pairs(const std::vector<int>& arr, int n, int k) {
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (abs(arr[i] - arr[j]) == k) {
                count++;
            }
        }
    }
    return count;
}


","
#include <iostream>
#include <vector>
#include <cassert>
#include <unordered_set>

int count_pairs(const std::vector<int>& arr, int n, int k) {
    std::unordered_set<int> seen;
    int count = 0;

    for (int i = 0; i < n; i++) {
        int diff = arr[i] - k;
        if (seen.find(diff)!= seen.end()) {
            count++;
        }
        seen.insert(arr[i]);
    }

    return count;
}

",1,5,0.789643939336141,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_pairs(const std::vector<int>& arr, int n, int k) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (abs(arr[i] - arr[j]) == k) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nint count_pairs(const std::vector<int>& arr, int n, int k) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 1 + i; j < n; j++) {\n            if (k == abs(arr[i] - arr[j])) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_pairs(const std::vector<int>& arr, int n, int k) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (k == abs(arr[i] - arr[j])) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint count_pairs(const std::vector<int>& arr, int n, int k) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (abs(arr[i] - arr[j]) == k) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <unordered_set>\n\nint count_pairs(const std::vector<int>& arr, int n, int k) {\n    std::unordered_set<int> seen;\n    int count = 0;\n\n    for (int i = 0; i < n; i++) {\n        int diff = arr[i] - k;\n        if (seen.find(diff)!= seen.end()) {\n            count++;\n        }\n        seen.insert(arr[i]);\n    }\n\n    return count;\n}\n\n', 'exchange_operators')]}"
173,"#include <iostream>
#include <vector>
#include <cassert>
bool greater_specificnum(const std::vector<int>& list, int num) {
    for (int x : list) {
        if (x < num) return false;
//begin to write code
",205,"
#include <iostream>
#include <vector>
#include <cassert>

bool greater_specificnum(const std::vector<int>& list, int num) {
    for (int x : list) {
        if (x < num) return false;
    }
    return true;
}


","
#include <iostream>
#include <vector>
#include <cassert>

bool greater_specificnum(const std::vector<int>& list, int num) {
    for (int x : list) {
        if (x < num) return false;
    }
    return true;
}

","#include <iostream>
#include <vector>
#include <cassert>
bool greater_specificnum(const std::vector<long>& list, long num) {
    for (long x : list) {
        if (x < num) return 0;
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

bool greater_specificnum(const std::vector<long>& list, long num) {
    for (long x : list) {
        if (x < num) return 0;
    }
    return 1;
}


","
#include <iostream>
#include <vector>
#include <cassert>

bool greater_specificnum(const std::vector<long>& list, long num) {
    for (long x : list) {
        if (x < num) return 0;
    }
    return 1; // All elements are greater than the specified number
}

",-1,21,2.747151319185893,code_expression_exchange:exchange_operators,1.0,0.7714887150492988,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool greater_specificnum(const std::vector<long>& list, long num) {\n    for (long x : list) {\n        if (x < num) return 0;\n    }\n    return 1;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nbool greater_specificnum(const std::vector<int>& list, int num) {\n    for (int x : list) {\n        if (x < num) return 0;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool greater_specificnum(const std::vector<int>& list, int num) {\n    for (int x : list) {\n        if (x < num) return 0;\n    }\n    return 1;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool greater_specificnum(const std::vector<int>& list, int num) {\n    for (int x : list) {\n        if (x < num) return 0;\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool greater_specificnum(const std::vector<int>& list, int num) {\n    for (int x : list) {\n        if (x < num) return 0;\n    }\n    return 1;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool greater_specificnum(const std::vector<int>& list, int num) {\n    for (long x : list) {\n        if (x < num) return 0;\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool greater_specificnum(const std::vector<int>& list, int num) {\n    for (long x : list) {\n        if (x < num) return 0;\n    }\n    return true; // All numbers in the list are greater than the specified number\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool greater_specificnum(const std::vector<long>& list, int num) {\n    for (long x : list) {\n        if (x < num) return 0;\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool greater_specificnum(const std::vector<long>& list, int num) {\n    for (long x : list) {\n        if (x < num) return 0;\n    }\n    return 1;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool greater_specificnum(const std::vector<long>& list, long num) {\n    for (long x : list) {\n        if (x < num) return 0;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool greater_specificnum(const std::vector<long>& list, long num) {\n    for (long x : list) {\n        if (x < num) return 0;\n    }\n    return true;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool greater_specificnum(const std::vector<long>& list, long num) {\n    for (long x : list) {\n        if (x < num) return 0;\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool greater_specificnum(const std::vector<long>& list, long num) {\n    for (long x : list) {\n        if (x < num) return 0;\n    }\n    return 1;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool greater_specificnum(const std::vector<long>& list, long num) {\n    for (long x : list) {\n        if (x < num) return 0;\n//begin to write code\n', '\nusing namespace std;\n#include <vector>\n#include <cassert>\n\nbool greater_specificnum(const std::vector<long>& list, long num) {\n    for (long x : list) {\n        if (x < num) return 0;\n    }\n    return true;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool greater_specificnum(const std::vector<long>& list, long num) {\n    for (long x : list) {\n        if (x < num) return 0;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool greater_specificnum(const std::vector<long>& list, long num) {\n    for (long x : list) {\n        if (x < num) return 0;\n    }\n    return 1; // Return 1 if all elements in the list are greater than the specified number\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool greater_specificnum(const std::vector<long>& list, long num) {\n    for (long x : list) {\n        if (x < num) return 0;\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool greater_specificnum(const std::vector<long>& list, long num) {\n    for (long x : list) {\n        if (x < num) return 0;\n    }\n    return 1; // Return true if all elements are greater than num\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool greater_specificnum(const std::vector<long>& list, long num) {\n    for (long x : list) {\n        if (x < num) return 0;\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool greater_specificnum(const std::vector<long>& list, long num) {\n    for (long x : list) {\n        if (x < num) return 0;\n    }\n    return 1; // All elements are greater than the specified number\n}\n\n', 'exchange_operators')]}"
174,"#include <iostream>
#include <utility>
#include <cassert>
std::pair<double, double> parabola_focus(double a, double b, double c) {
    std::pair<double, double> focus = std::make_pair((-b / (2 * a)), ((4 * a * c - b * b + 1) / (4 * a)));
//begin to write code
",260,"
#include <iostream>
#include <utility>
#include <cassert>

std::pair<double, double> parabola_focus(double a, double b, double c) {
    std::pair<double, double> focus = std::make_pair((-b / (2 * a)), ((4 * a * c - b * b + 1) / (4 * a)));
    return focus;
}


","
#include <iostream>
#include <utility>
#include <cassert>

std::pair<double, double> parabola_focus(double a, double b, double c) {
    // Calculate the x-coordinate of the focus using the formula
    double x_focus = -b / (2 * a);
    
    // Calculate the y-coordinate of the focus using the formula
    double y_focus = (4 * a * c - b * b + 1) / (4 * a);
    
    return std::make_pair(x_focus, y_focus);
}

","#include <iostream>
#include <utility>
#include <cassert>
std::pair<double, double> parabola_focus(double a, double b, double c) {
    std::pair<double, double> focus = std::make_pair((-b / (2 * a)), ((4 * a * c - b * b + 1) / (4 * a)));
//begin to write code
","
#include <iostream>
#include <utility>
#include <cassert>

std::pair<double, double> parabola_focus(double a, double b, double c) {
    std::pair<double, double> focus = std::make_pair((-b / (2 * a)), ((4 * a * c - b * b + 1) / (4 * a)));
    return focus;
}


","
#include <iostream>
#include <utility>
#include <cassert>
#include <cmath>

std::pair<double, double> parabola_focus(double a, double b, double c) {
    // Calculate the x-coordinate of the focus
    double x_focus = -b / (2 * a);
    
    // Calculate the y-coordinate of the focus using the distance formula
    double y_focus = std::sqrt(4 * a * c - b * b + 1) / (4 * a);
    
    return std::make_pair(x_focus, y_focus);
}

",1,3,0.4990695397059123,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <utility>\n#include <cassert>\n\nstd::pair<double, double> parabola_focus(double a, double b, double c) {\n    std::pair<double, double> focus = std::make_pair((-b / (2 * a)), ((4 * a * c - b * b + 1) / (4 * a)));\n    return focus;\n}\n\n\n': [('#include <iostream>\n#include <utility>\n#include <cassert>\nstd::pair<double, double> parabola_focus(double a, double b, double c) {\n    std::pair<double, double> focus = std::make_pair((-b / (2 * a)), ((4 * a * c - b * b + 1) / (4 * a)));\n//begin to write code\n', '\n#include <iostream>\n#include <utility>\n#include <cassert>\n#include <cmath>\n\nstd::pair<double, double> parabola_focus(double a, double b, double c) {\n    // Calculate the x-coordinate of the focus\n    double x_focus = -b / (2 * a);\n    \n    // Calculate the y-coordinate of the focus using the distance formula\n    double y_focus = std::sqrt(4 * a * c - b * b + 1) / (4 * a);\n    \n    return std::make_pair(x_focus, y_focus);\n}\n\n', 'equal_expression_transformation')]}"
175,"#include <iostream>
#include <regex>
#include <cassert>
using namespace std;
string check_literals(string text, vector<string> patterns) {
    for (auto pattern : patterns) {
        if (regex_search(text, regex(pattern))) {
            return ""Matched!"";
        } else {
//begin to write code
",295,"#include <iostream>
#include <regex>
#include <cassert>
using namespace std;

string check_literals(string text, vector<string> patterns) {
    for (auto pattern : patterns) {
        if (regex_search(text, regex(pattern))) {
            return ""Matched!"";
        } else {
            return ""Not Matched!"";
        }
    }
    return ""Not Matched!"";
}","
#include <iostream>
#include <regex>
#include <cassert>
using namespace std;

string check_literals(string text, vector<string> patterns) {
    for (auto pattern : patterns) {
        if (regex_search(text, regex(pattern))) {
            return ""Matched!"";
        }
    }
    return ""No matches found."";
}

",,,,-2,1,0.2181352972984314,code_expression_exchange:None,0.0,0.0,
176,"#include <iostream>
#include <cassert>
using namespace std;
int longest_common_subsequence(const string &X, const string &Y, int m, int n) {
    if (m == 0 || n == 0) {
        return 0;
    } else if (X[m-1] == Y[n-1]) {
//begin to write code
",244,"
#include <iostream>
#include <cassert>
using namespace std;

int longest_common_subsequence(const string &X, const string &Y, int m, int n) {
    if (m == 0 || n == 0) {
        return 0;
    } else if (X[m-1] == Y[n-1]) {
        return 1 + longest_common_subsequence(X, Y, m-1, n-1);
    } else {
        return max(longest_common_subsequence(X, Y, m, n-1), longest_common_subsequence(X, Y, m-1, n));
    }
}


","
#include <iostream>
#include <cassert>
using namespace std;

int longest_common_subsequence(const string &X, const string &Y, int m, int n) {
    if (m == 0 || n == 0) {
        return 0;
    } else if (X[m-1] == Y[n-1]) {
        return 1 + longest_common_subsequence(X, Y, m-1, n-1);
    } else {
        return max(longest_common_subsequence(X, Y, m-1, n), longest_common_subsequence(X, Y, m, n-1));
    }
}

","#include <iostream>
#include <cassert>
using namespace std;
int longest_common_subsequence(const string &X, const string &Y, int m, int n) {
    if (0 == m || 0 == n) {
        return 0;
    } else if (Y[n-1] == X[m-1]) {
//begin to write code
","
#include <iostream>
#include <cassert>
using namespace std;

int longest_common_subsequence(const string &X, const string &Y, int m, int n) {
    if (0 == m || 0 == n) {
        return 0;
    } else if (Y[n-1] == X[m-1]) {
        return longest_common_subsequence(X, Y, m-1, n-1) + 1;
    } else {
        return max(longest_common_subsequence(X, Y, m, n-1), longest_common_subsequence(X, Y, m-1, n));
    }
}


","
**Created Answer**:
",1,3,0.4803270022074381,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nint longest_common_subsequence(const string &X, const string &Y, int m, int n) {\n    if (0 == m || 0 == n) {\n        return 0;\n    } else if (Y[n-1] == X[m-1]) {\n        return longest_common_subsequence(X, Y, m-1, n-1) + 1;\n    } else {\n        return max(longest_common_subsequence(X, Y, m, n-1), longest_common_subsequence(X, Y, m-1, n));\n    }\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nusing namespace std;\nint longest_common_subsequence(const string &X, const string &Y, int m, int n) {\n    if (0 == m || 0 == n) {\n        return 0;\n    } else if (Y[n-1] == X[m-1]) {\n//begin to write code\n', '\n**Created Answer**:\n', 'exchange_operators')]}"
177,"#include <iostream>
#include <cassert>
bool prod_Square(int n) {
    for (int i = 2; i <= n; ++i) {
        if (i * i < (n + 1)) {
            for (int j = 2; j <= n; ++j) {
                if ((i * i * j * j) == n) {
                    return true;
//begin to write code
",273,"
#include <iostream>
#include <cassert>

bool prod_Square(int n) {
    for (int i = 2; i <= n; ++i) {
        if (i * i < (n + 1)) {
            for (int j = 2; j <= n; ++j) {
                if ((i * i * j * j) == n) {
                    return true;
                }
            }
        }
    }
    return false;
}


","
#include <iostream>
#include <cassert>

bool prod_Square(int n) {
    for (int i = 2; i <= n; ++i) {
        if (i * i < (n + 1)) {
            for (int j = 2; j <= n; ++j) {
                if ((i * i * j * j) == n) {
                    return true;
                }
            }
        }
    }
    return false;
}

","#include <iostream>
#include <cassert>
bool prod_Square(int n) {
    for (int i = 2; i <= n; i = i + 1) {
        if (i * i < (n + 1)) {
            for (int j = 2; j <= n; j = j + 1) {
                if ((i * i * j * j) == n) {
                    return true;
//begin to write code
","
#include <iostream>
#include <cassert>

bool prod_Square(int n) {
    for (int i = 2; i <= n; i = i + 1) {
        if (i * i < (n + 1)) {
            for (int j = 2; j <= n; j = j + 1) {
                if ((i * i * j * j) == n) {
                    return true;
                }
            }
        }
    }
    return false;
}


","
#include <iostream>
#include <cassert>

bool prod_Square(int n) {
    // Check if n is less than or equal to 0
    if (n <= 0) {
        return false;
    }
    
    // Check if n is a perfect square
    int sqrt_n = static_cast<int>(std::sqrt(n));
    return sqrt_n * sqrt_n == n;
}

",1,3,0.5056250135103861,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nbool prod_Square(int n) {\n    for (int i = 2; i <= n; i = i + 1) {\n        if (i * i < (n + 1)) {\n            for (int j = 2; j <= n; j = j + 1) {\n                if ((i * i * j * j) == n) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nbool prod_Square(int n) {\n    for (int i = 2; i <= n; i = i + 1) {\n        if (i * i < (n + 1)) {\n            for (int j = 2; j <= n; j = j + 1) {\n                if ((i * i * j * j) == n) {\n                    return true;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nbool prod_Square(int n) {\n    // Check if n is less than or equal to 0\n    if (n <= 0) {\n        return false;\n    }\n    \n    // Check if n is a perfect square\n    int sqrt_n = static_cast<int>(std::sqrt(n));\n    return sqrt_n * sqrt_n == n;\n}\n\n', 'equal_expression_transformation')]}"
178,"#include <iostream>
#include <vector>
#include <cassert>
int first_Missing_Positive(std::vector<int> arr, int n) {
    int ptr = 0;
    for (int i = 0; i < n; ++i) {
        if (arr[i] == 1) {
            ptr = 1;
            break;
        }
    }
    if (ptr == 0) {
        return 1;
    }
    for (int i = 0; i < n; ++i) {
        if (arr[i] <= 0 || arr[i] > n) {
//begin to write code
",390,"
#include <iostream>
#include <vector>
#include <cassert>

int first_Missing_Positive(std::vector<int> arr, int n) {
    int ptr = 0;
    for (int i = 0; i < n; ++i) {
        if (arr[i] == 1) {
            ptr = 1;
            break;
        }
    }
    if (ptr == 0) {
        return 1;
    }
    for (int i = 0; i < n; ++i) {
        if (arr[i] <= 0 || arr[i] > n) {
            arr[i] = 1;
        }
    }
    for (int i = 0; i < n; ++i) {
        arr[(arr[i] - 1) % n] += n;
    }
    for (int i = 0; i < n; ++i) {
        if (arr[i] <= n) {
            return i + 1;
        }
    }
    return n + 1;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <cassert>

int first_Missing_Positive(std::vector<int> arr, int n) {
    int ptr = 0;
    for (int i = 0; i < n; ++i) {
        if (arr[i] == 1) {
            ptr = 1;
            break;
        }
    }
    if (ptr == 0) {
        return 1;
    }
    for (int i = 0; i < n; ++i) {
        if (arr[i] <= 0 || arr[i] > n) {
            continue;
        }
        if (arr[i] - 1!= arr[i]) {
            // Swap the elements to bring them into place
            arr[i] = arr[i] - 1;
        }
    }
    for (int i = 0; i < n; ++i) {
        if (arr[i]!= i + 1) {
            return i + 1;
        }
    }
    return n + 1;
}

",,,,-2,1,0.2340329845746358,code_expression_exchange:None,0.0,0.0,
179,"#include <iostream>
#include <cassert>
int count_Intgral_Points(int x1, int y1, int x2, int y2) {
//begin to write code
",120,"
#include <iostream>
#include <cassert>

int count_Intgral_Points(int x1, int y1, int x2, int y2) {
    return ((y2 - y1 - 1) * (x2 - x1 - 1));
}


","
#include <iostream>
#include <cassert>
#include <cmath> // For sqrt function

int count_Intgral_Points(int x1, int y1, int x2, int y2) {
    int count = 0;
    for (int i = x1; i <= x2; ++i) {
        for (int j = y1; j <= y2; ++j) {
            if (i == x1 || i == x2 || j == y1 || j == y2) {
                continue; // Skip points inside the square
            }
            count++;
        }
    }
    return count;
}

",,,,-2,1,0.2297539234161377,code_expression_exchange:None,0.0,0.0,
180,"#include<cassert>
#include <iostream>
#include <string>
bool check_monthnumber(std::string monthname3) {
    if (monthname3 == ""April"" || monthname3 == ""June"" || monthname3 == ""September"" || monthname3 == ""November"") {
        return true;
//begin to write code
",262,"#include<cassert>
#include <iostream>
#include <string>

bool check_monthnumber(std::string monthname3) {
    if (monthname3 == ""April"" || monthname3 == ""June"" || monthname3 == ""September"" || monthname3 == ""November"") {
        return true;
    } else {
        return false;
    }
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

bool check_monthnumber(std::string monthname3) {
    if (monthname3 == ""April"" || monthname3 == ""June"" || monthname3 == ""September"" || monthname3 == ""November"") {
        return true;
    } else {
        return false;
    }
}
",,,,-2,1,0.16904035409291585,code_expression_exchange:None,0.0,0.0,
181,"#include<cassert>
#include <iostream>
#include <string>
#include <cctype>
bool check_String(const std::string& str) {
    bool flag_l = false;
    bool flag_n = false;
    for (char i : str) {
        if (isalpha(i)) {
            flag_l = true;
//begin to write code
",268,"#include<cassert>
#include <iostream>
#include <string>
#include <cctype>

bool check_String(const std::string& str) {
    bool flag_l = false;
    bool flag_n = false;
    for (char i : str) {
        if (isalpha(i)) {
            flag_l = true;
        }
        if (isdigit(i)) {
            flag_n = true;
        }
    }
    return flag_l && flag_n;
}


","
#include<cassert>
#include <iostream>
#include <string>
#include <cctype>

bool check_String(const std::string& str) {
    bool flag_l = false;
    bool flag_n = false;
    for (char i : str) {
        if (std::isdigit(i)) {
            flag_n = true;
        } else if (std::isalpha(i)) {
            flag_l = true;
        }
    }
    return flag_l && flag_n;
}

","#include<cassert>
#include <iostream>
#include <string>
#include <cctype>
bool check_String(const std::string& str) {
    bool flag_l = 0;
    bool flag_n = 0;
    for (char i : str) {
        if (isalpha(i)) {
            flag_l = 1;
//begin to write code
","#include<cassert>
#include <iostream>
#include <string>
#include <cctype>

bool check_String(const std::string& str) {
    bool flag_l = 0;
    bool flag_n = 0;
    for (char i : str) {
        if (isalpha(i)) {
            flag_l = 1;
        }
        if (isdigit(i)) {
            flag_n = 1;
        }
    }
    return flag_l && flag_n;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

bool check_String(const std::string& str) {
    bool flag_l = 0;
    bool flag_n = 0;
    for (char i : str) {
        if (isalpha(i)) {
            flag_l = 1;
        } else if (isdigit(i)) {
            flag_n = 1;
        }
    }
    return flag_l && flag_n;
}

",1,7,0.9936707139015197,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<cassert>\n#include <iostream>\n#include <string>\n#include <cctype>\n\nbool check_String(const std::string& str) {\n    bool flag_l = 0;\n    bool flag_n = 0;\n    for (char i : str) {\n        if (isalpha(i)) {\n            flag_l = 1;\n        }\n        if (isdigit(i)) {\n            flag_n = 1;\n        }\n    }\n    return flag_l && flag_n;\n}\n\n\n': [('#include<cassert>\n#include <iostream>\n#include <string>\n#include <cctype>\nbool check_String(const std::string& str) {\n    bool flag_l = false;\n    bool flag_n = false;\n    for (char i : str) {\n        if (isalpha(i)) {\n            flag_l = true;\n//begin to write code\n', '\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <cctype>\n\nbool check_String(const std::string& str) {\n    bool flag_l = false;\n    bool flag_n = false;\n    for (char i : str) {\n        if (isalpha(i)) {\n            flag_l = true;\n        } else if (isdigit(i)) {\n            flag_n = true;\n        }\n    }\n    return flag_l && flag_n;\n}\n\n', 'more_universe_var_type'), ('#include<cassert>\n#include <iostream>\n#include <string>\n#include <cctype>\nbool check_String(const std::string& str) {\n    bool flag_l = 0;\n    bool flag_n = 0;\n    for (char i : str) {\n        if (isalpha(i)) {\n            flag_l = 1;\n//begin to write code\n', '\n#include<cassert>\n#include <iostream>\n#include <string>\n#include <cctype>\n\nbool check_String(const std::string& str) {\n    bool flag_l = 0;\n    bool flag_n = 0;\n    for (char i : str) {\n        if (std::isdigit(i)) {\n            flag_n = 1;\n        } else if (std::isalpha(i)) {\n            flag_l = 1;\n        }\n    }\n    return flag_l && flag_n;\n}\n\n', 'bool2int'), ('#include<cassert>\n#include <iostream>\n#include <string>\n#include <cctype>\nbool check_String(const std::string& str) {\n    bool flag_l = 0;\n    bool flag_n = 0;\n    for (char i : str) {\n        if (isalpha(i)) {\n            flag_l = 1;\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\nbool check_String(const std::string& str) {\n    bool flag_l = 0;\n    bool flag_n = 0;\n    for (char i : str) {\n        if (isalpha(i)) {\n            flag_l = 1;\n        } else if (isdigit(i)) {\n            flag_n = 1;\n        }\n    }\n    return flag_l && flag_n;\n}\n\n', 'more_universe_var_type')]}"
182,"#include <iostream>
#include <vector>
#include <set>
#include <cassert>
using namespace std;
vector<int> remove_tuple(const vector<int>& test_vec) {
  set<int> unique_elements(test_vec.begin(), test_vec.end());
//begin to write code
",233,"
#include <iostream>
#include <vector>
#include <set>
#include <cassert>
using namespace std;

vector<int> remove_tuple(const vector<int>& test_vec) {
  set<int> unique_elements(test_vec.begin(), test_vec.end());
  return vector<int>(unique_elements.begin(), unique_elements.end());
}


","
#include <iostream>
#include <vector>
#include <set>
#include <cassert>
using namespace std;

vector<int> remove_tuple(const vector<int>& test_vec) {
    // Use a set to store unique elements
    set<int> unique_elements(test_vec.begin(), test_vec.end());
    // Convert the set back to a vector
    return vector<int>(unique_elements.begin(), unique_elements.end());
}

","#include <iostream>
#include <vector>
#include <set>
#include <cassert>
using namespace std;
vector<int> remove_tuple(const vector<long>& test_vec) {
  set<long> unique_elements(test_vec.begin(), test_vec.end());
//begin to write code
","
#include <iostream>
#include <vector>
#include <set>
#include <cassert>
using namespace std;

vector<int> remove_tuple(const vector<long>& test_vec) {
  set<long> unique_elements(test_vec.begin(), test_vec.end());
  return vector<int>(unique_elements.begin(), unique_elements.end());
}


","
#include <iostream>
#include <vector>
#include <set>
#include <cassert>
using namespace std;

vector<int> remove_tuple(const vector<long>& test_vec) {
    // Use a set to store unique elements
    set<long> unique_elements(test_vec.begin(), test_vec.end());
    // Convert the set back to a vector
    return vector<int>(unique_elements.begin(), unique_elements.end());
}

",-1,21,2.757616603374481,code_expression_exchange:equal_expression_transformation,1.0,0.7244519117530228,"{'\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nvector<int> remove_tuple(const vector<long>& test_vec) {\n  set<long> unique_elements(test_vec.begin(), test_vec.end());\n  return vector<int>(unique_elements.begin(), unique_elements.end());\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\nvector<int> remove_tuple(const vector<int>& test_vec) {\n  set<int> unique_elements(test_vec.begin(), test_vec.end());\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nvector<int> remove_tuple(const vector<int>& test_vec) {\n    // Use a set to store unique elements\n    set<int> unique_elements(test_vec.begin(), test_vec.end());\n    // Convert the set back to a vector\n    vector<int> result(unique_elements.begin(), unique_elements.end());\n    return result;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\nvector<int> remove_tuple(const vector<int>& test_vec) {\n  set<int> unique_elements(test_vec.begin(), test_vec.end());\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nvector<int> remove_tuple(const vector<int>& test_vec) {\n    // Use a set to store unique elements\n    set<int> unique_elements(test_vec.begin(), test_vec.end());\n    \n    // Convert the set back to a vector\n    vector<int> result(unique_elements.begin(), unique_elements.end());\n    \n    return result;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\nvector<int> remove_tuple(const vector<long>& test_vec) {\n  set<int> unique_elements(test_vec.begin(), test_vec.end());\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nvector<int> remove_tuple(const vector<long>& test_vec) {\n    set<int> unique_elements(test_vec.begin(), test_vec.end());\n    return vector<int>(unique_elements.begin(), unique_elements.end());\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\nvector<int> remove_tuple(const vector<long>& test_vec) {\n  set<int> unique_elements(test_vec.begin(), test_vec.end());\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nvector<int> remove_tuple(const vector<long>& test_vec) {\n    // Use a set to store unique elements\n    set<int> unique_elements(test_vec.begin(), test_vec.end());\n    // Convert the set back to a vector\n    return vector<int>(unique_elements.begin(), unique_elements.end());\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\nvector<int> remove_tuple(const vector<long>& test_vec) {\n  set<int> unique_elements(test_vec.begin(), test_vec.end());\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nvector<int> remove_tuple(const vector<long>& test_vec) {\n    // Use a set to store unique elements\n    set<int> unique_elements(test_vec.begin(), test_vec.end());\n\n    // Convert the set back to a vector\n    vector<int> result(unique_elements.begin(), unique_elements.end());\n\n    return result;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\nvector<int> remove_tuple(const vector<long>& test_vec) {\n  set<long> unique_elements(test_vec.begin(), test_vec.end());\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nvector<int> remove_tuple(const vector<long>& test_vec) {\n    set<long> unique_elements(test_vec.begin(), test_vec.end());\n    vector<int> result(unique_elements.begin(), unique_elements.end());\n    return result;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\nvector<int> remove_tuple(const vector<long>& test_vec) {\n  set<long> unique_elements(test_vec.begin(), test_vec.end());\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nvector<int> remove_tuple(const vector<long>& test_vec) {\n    // Use a set to store unique elements\n    set<long> unique_elements(test_vec.begin(), test_vec.end());\n    // Convert the set back to a vector\n    return vector<int>(unique_elements.begin(), unique_elements.end());\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\nvector<int> remove_tuple(const vector<long>& test_vec) {\n  set<long> unique_elements(test_vec.begin(), test_vec.end());\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nvector<int> remove_tuple(const vector<long>& test_vec) {\n    // Use a set to store unique elements\n    set<long> unique_elements(test_vec.begin(), test_vec.end());\n    \n    // Convert the set back to a vector\n    vector<int> result(unique_elements.begin(), unique_elements.end());\n    \n    return result;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\nvector<int> remove_tuple(const vector<long>& test_vec) {\n  set<long> unique_elements(test_vec.begin(), test_vec.end());\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nvector<int> remove_tuple(const vector<long>& test_vec) {\n    // Use a set to store unique elements\n    set<long> unique_elements(test_vec.begin(), test_vec.end());\n    // Convert the set back to a vector\n    vector<int> result(unique_elements.begin(), unique_elements.end());\n    return result;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\nvector<int> remove_tuple(const vector<long>& test_vec) {\n  set<long> unique_elements(test_vec.begin(), test_vec.end());\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nvector<int> remove_tuple(const vector<long>& test_vec) {\n    // Use a set to store unique elements\n    set<long> unique_elements(test_vec.begin(), test_vec.end());\n    // Convert the set back to a vector\n    return vector<int>(unique_elements.begin(), unique_elements.end());\n}\n\n', 'equal_expression_transformation')]}"
183,"#include<cassert>
#include<iostream>
int octal_To_Decimal(int n) {  
    int num = n; 
    int dec_value = 0; 
    int base = 1; 
    int temp = num; 
    while (temp) { 
//begin to write code
",193,"#include<cassert>
#include<iostream>

int octal_To_Decimal(int n) {  
    int num = n; 
    int dec_value = 0; 
    int base = 1; 
    int temp = num; 
    while (temp) { 
        int last_digit = temp % 10; 
        temp = temp / 10; 
        dec_value += last_digit * base; 
        base = base * 8; 
    } 
    return dec_value; 
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

int octal_To_Decimal(int n) {
    int num = n;
    int dec_value = 0; 
    int base = 1; 
    int temp = num; 
    while (temp) { 
        dec_value += temp % base; 
        temp /= base; 
    }
    return dec_value;
}
",,,,-2,1,0.17472452720006307,code_expression_exchange:None,0.0,0.0,
184,"#include<iostream>
#include<vector>
#include<cassert>
int first(const std::vector<int>& arr, int x, int n) { 
    int low = 0;
    int high = n - 1;
    int res = -1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (arr[mid] > x) {
            high = mid - 1;
//begin to write code
",307,"
#include<iostream>
#include<vector>
#include<cassert>

int first(const std::vector<int>& arr, int x, int n) { 
    int low = 0;
    int high = n - 1;
    int res = -1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (arr[mid] > x) {
            high = mid - 1;
        } else if (arr[mid] < x) {
            low = mid + 1;
        } else {
            res = mid;
            high = mid - 1;
        }
    }
    return res;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>

#include<iostream>
#include<vector>
#include<cassert>

int first(const std::vector<int>& arr, int x, int n) {
    int low = 0;
    int high = n - 1;
    int res = -1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (arr[mid] > x) {
            high = mid - 1;
        } else {
            res = mid;
            low = mid + 1;
        }
    }
    return res;
}

",,,,-2,1,0.23980825344721476,code_expression_exchange:None,0.0,0.0,
185,"#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
vector<vector<int>> remove_tuples(vector<vector<int>> test_list, int K) {
    vector<vector<int>> res;
    for (auto ele : test_list) {
        if ((int)ele.size() != K) {
//begin to write code
",272,"
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

vector<vector<int>> remove_tuples(vector<vector<int>> test_list, int K) {
    vector<vector<int>> res;
    for (auto ele : test_list) {
        if ((int)ele.size() != K) {
            res.push_back(ele);
        }
    }
    return res;
}","#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

vector<vector<int>> remove_tuples(vector<vector<int>> test_list, int K) {
    vector<vector<int>> res;
    for (auto ele : test_list) {
        if ((int)ele.size()!= K) {
            res.push_back(ele);
        }
    }
    return res;
}
","#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
vector<vector<int>> remove_tuples(vector<vector<int>> test_list, int K) {
    vector<vector<int>> res;
    for (auto ele : test_list) {
        if (K != (int)ele.size()) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

vector<vector<int>> remove_tuples(vector<vector<int>> test_list, int K) {
    vector<vector<int>> res;
    for (auto ele : test_list) {
        if (K != (int)ele.size()) {
            res.push_back(ele);
        }
    }
    return res;
}","
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

vector<vector<int>> remove_tuples(vector<vector<int>> test_list, int K) {
    vector<vector<int>> res;
    for (auto ele : test_list) {
        if (K == (int)ele.size()) {
            res.push_back(ele);
        }
    }
    return res;
}

",1,3,0.44583605527877807,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<vector<int>> remove_tuples(vector<vector<int>> test_list, int K) {\n    vector<vector<int>> res;\n    for (auto ele : test_list) {\n        if (K != (int)ele.size()) {\n            res.push_back(ele);\n        }\n    }\n    return res;\n}': [('#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<vector<int>> remove_tuples(vector<vector<int>> test_list, int K) {\n    vector<vector<int>> res;\n    for (auto ele : test_list) {\n        if (K != (int)ele.size()) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<vector<int>> remove_tuples(vector<vector<int>> test_list, int K) {\n    vector<vector<int>> res;\n    for (auto ele : test_list) {\n        if (K == (int)ele.size()) {\n            res.push_back(ele);\n        }\n    }\n    return res;\n}\n\n', 'exchange_operators')]}"
186,"#include <iostream>
#include <vector>
#include <cmath>
#include <cassert>
using namespace std;
vector<int> find_exponentio(const vector<int>& test_vec1, const vector<int>& test_vec2) {
    vector<int> res;
    for (size_t i = 0; i < test_vec1.size(); ++i) {
//begin to write code
",280,"
#include <iostream>
#include <vector>
#include <cmath>
#include <cassert>

using namespace std;

vector<int> find_exponentio(const vector<int>& test_vec1, const vector<int>& test_vec2) {
    vector<int> res;
    for (size_t i = 0; i < test_vec1.size(); ++i) {
        res.push_back(pow(test_vec1[i], test_vec2[i]));
    }
    return res;
}


","
#include <iostream>
#include <vector>
#include <cmath>
#include <cassert>
using namespace std;

vector<int> find_exponentio(const vector<int>& test_vec1, const vector<int>& test_vec2) {
    vector<int> res;
    for (size_t i = 0; i < test_vec1.size(); ++i) {
        res.push_back(pow(test_vec1[i], test_vec2[i]));
    }
    return res;
}

","#include <iostream>
#include <vector>
#include <cmath>
#include <cassert>
using namespace std;
vector<int> find_exponentio(const vector<int>& test_vec1, const vector<int>& test_vec2) {
    vector<int> res;
    for (size_t i = 0; i < test_vec1.size(); ++i) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cmath>
#include <cassert>

using namespace std;

vector<int> find_exponentio(const vector<int>& test_vec1, const vector<int>& test_vec2) {
    vector<int> res;
    for (size_t i = 0; i < test_vec1.size(); ++i) {
        res.push_back(pow(test_vec1[i], test_vec2[i]));
    }
    return res;
}


","
#include <iostream>
#include <vector>
#include <cmath>
#include <cassert>
using namespace std;

vector<int> find_exponentio(const vector<int>& test_vec1, const vector<int>& test_vec2) {
    vector<int> res;
    for (size_t i = 0; i < test_vec1.size(); ++i) {
        // Calculate the power of each element in test_vec1 raised to the power of the corresponding element in test_vec2
        int result = 1;
        for (int j = 0; j < test_vec2.size(); ++j) {
            result *= test_vec1[i] * test_vec2[j];
        }
        res.push_back(result);
    }
    return res;
}

",1,3,0.508449649810791,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\nvector<int> find_exponentio(const vector<int>& test_vec1, const vector<int>& test_vec2) {\n    vector<int> res;\n    for (size_t i = 0; i < test_vec1.size(); ++i) {\n        res.push_back(pow(test_vec1[i], test_vec2[i]));\n    }\n    return res;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nvector<int> find_exponentio(const vector<int>& test_vec1, const vector<int>& test_vec2) {\n    vector<int> res;\n    for (size_t i = 0; i < test_vec1.size(); ++i) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nvector<int> find_exponentio(const vector<int>& test_vec1, const vector<int>& test_vec2) {\n    vector<int> res;\n    for (size_t i = 0; i < test_vec1.size(); ++i) {\n        // Calculate the power of each element in test_vec1 raised to the power of the corresponding element in test_vec2\n        int result = 1;\n        for (int j = 0; j < test_vec2.size(); ++j) {\n            result *= test_vec1[i] * test_vec2[j];\n        }\n        res.push_back(result);\n    }\n    return res;\n}\n\n', 'equal_expression_transformation')]}"
187,"#include <iostream>
#include <cmath>
#include <cassert>
double largest_triangle(double a, double b) {
    if (a < 0 || b < 0) {
        return -1;
//begin to write code
",169,"
#include <iostream>
#include <cmath>
#include <cassert>

double largest_triangle(double a, double b) {
    if (a < 0 || b < 0) {
        return -1;
    }
    double area = (3 * sqrt(3) * pow(a, 2)) / (4 * b);
    return area;
}


","
using namespace std;

#include <iostream>
#include <cmath>
#include <cassert>

double largest_triangle(double a, double b) {
    // Your implementation goes here
    // For this example, we will assume that the ellipse is centered at the origin with semi-major axis a and semi-minor axis b
    // The area of the triangle inscribed in the ellipse can be calculated using Heron's formula
    // The area of the triangle is given by 0.5 * a * b * sqrt(1 + (b/a)^2)
    // The largest triangle is the one with the maximum area
    // We will use the following formula to find the largest triangle
    // double max_area = 0;
    // for (int i = 1; i <= a; ++i) {
    //     for (int j = 1; j <= b; ++j) {
    //         double area = 0.5 * a * b * sqrt(1 + (b/a)^2);
    //         if (area > max_area) {
    //             max_area = area;
    //         }
    //     }
    // }
    // return max_area;
}

",,,,-2,1,0.23492331902186075,code_expression_exchange:None,0.0,0.0,
188,"#include <iostream>
#include <cassert>
int highest_Power_of_2(int n) {
    int res = 0;
    for (int i = n; i > 0; i--) {
        if ((i & (i - 1)) == 0) {
            res = i;
//begin to write code
",199,"
#include <iostream>
#include <cassert>

int highest_Power_of_2(int n) {
    int res = 0;
    for (int i = n; i > 0; i--) {
        if ((i & (i - 1)) == 0) {
            res = i;
            break;
        }
    }
    return res;
}


","
using namespace std;

#include <iostream>
#include <cassert>

int highest_Power_of_2(int n) {
    int res = 0;
    for (int i = n; i > 0; i--) {
        if ((i & (i - 1)) == 0) {
            res = i;
        }
    }
    return res;
}

",,,,-2,1,0.21527647972106934,code_expression_exchange:None,0.0,0.0,
189,"#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
std::vector<int> position_max(const std::vector<int>& list1) {
    int max_val = *std::max_element(list1.begin(), list1.end());
    std::vector<int> max_result;
    for (int i = 0; i < list1.size(); ++i) {
        if (list1[i] == max_val) {
//begin to write code
",341,"
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::vector<int> position_max(const std::vector<int>& list1) {
    int max_val = *std::max_element(list1.begin(), list1.end());
    std::vector<int> max_result;
    for (int i = 0; i < list1.size(); ++i) {
        if (list1[i] == max_val) {
            max_result.push_back(i);
        }
    }
    return max_result;
}


","
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::vector<int> position_max(const std::vector<int>& list1) {
    int max_val = *std::max_element(list1.begin(), list1.end());
    std::vector<int> max_result;
    for (int i = 0; i < list1.size(); ++i) {
        if (list1[i] == max_val) {
            max_result.push_back(i);
        }
    }
    return max_result;
}

void check_position_max() {
    assert(position_max({1, 2, 3, 2, 4}) == std::vector<int>({0, 2}));
    assert(position_max({10, 9, 8, 7, 6, 5, 4, 3, 2, 1}) == std::vector<int>({4, 7}));
    assert(position_max({}) == std::vector<int>());
    assert(position_max({-1, -2, -3, -4, -5}) == std::vector<int>({0}));
    std::cout << ""All tests passed successfully."" << std::endl;
}

","#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
std::vector<int> position_max(const std::vector<int>& list1) {
    int max_val = *std::max_element(list1.begin(), list1.end());
    std::vector<long> max_result;
    for (int i = 0; i < list1.size(); ++i) {
        if (max_val == list1[i]) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::vector<int> position_max(const std::vector<int>& list1) {
    int max_val = *std::max_element(list1.begin(), list1.end());
    std::vector<long> max_result;
    for (int i = 0; i < list1.size(); ++i) {
        if (max_val == list1[i]) {
            max_result.push_back(i);
        }
    }
    return max_result;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::vector<int> position_max(const std::vector<int>& list1) {
    int max_val = *std::max_element(list1.begin(), list1.end());
    std::vector<long> max_result;
    for (int i = 0; i < list1.size(); ++i) {
        if (max_val == list1[i]) {
            max_result.push_back(static_cast<long>(i));
        }
    }
    return max_result;
}

",1,5,0.7714040199915568,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> position_max(const std::vector<int>& list1) {\n    int max_val = *std::max_element(list1.begin(), list1.end());\n    std::vector<long> max_result;\n    for (int i = 0; i < list1.size(); ++i) {\n        if (max_val == list1[i]) {\n            max_result.push_back(i);\n        }\n    }\n    return max_result;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nstd::vector<int> position_max(const std::vector<int>& list1) {\n    int max_val = *std::max_element(list1.begin(), list1.end());\n    std::vector<int> max_result;\n    for (int i = 0; i < list1.size(); ++i) {\n        if (max_val == list1[i]) {\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nstd::vector<int> position_max(const std::vector<int>& list1) {\n    int max_val = *std::max_element(list1.begin(), list1.end());\n    std::vector<int> max_result;\n    for (int i = 0; i < list1.size(); ++i) {\n        if (max_val == list1[i]) {\n            max_result.push_back(i);\n        }\n    }\n    return max_result;\n}\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nstd::vector<int> position_max(const std::vector<int>& list1) {\n    int max_val = *std::max_element(list1.begin(), list1.end());\n    std::vector<long> max_result;\n    for (int i = 0; i < list1.size(); ++i) {\n        if (max_val == list1[i]) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> position_max(const std::vector<int>& list1) {\n    int max_val = *std::max_element(list1.begin(), list1.end());\n    std::vector<long> max_result;\n    for (int i = 0; i < list1.size(); ++i) {\n        if (max_val == list1[i]) {\n            max_result.push_back(static_cast<long>(i));\n        }\n    }\n    return max_result;\n}\n\n', 'more_universe_var_type')]}"
190,"#include <iostream>
#include <set>
#include <vector>
#include <cassert>
bool chkList(const std::vector<std::string>& lst) {
//begin to write code
",146,"
#include <iostream>
#include <set>
#include <vector>
#include <cassert>

bool chkList(const std::vector<std::string>& lst) {
    return std::set<std::string>(lst.begin(), lst.end()).size() == 1;
}


","
#include <iostream>
#include <set>
#include <vector>
#include <cassert>

bool chkList(const std::vector<std::string>& lst) {
    // Implement the logic to check if all elements in the list are the same
    // Example implementation: check if all strings in the list are equal
    return lst.size() == 0 || lst[0] == lst[lst.size() - 1];
}

","#include <iostream>
#include <set>
#include <vector>
#include <cassert>
bool chkList(const std::vector<std::string>& lst) {
//begin to write code
","
#include <iostream>
#include <set>
#include <vector>
#include <cassert>

bool chkList(const std::vector<std::string>& lst) {
    return std::set<std::string>(lst.begin(), lst.end()).size() == 1;
}


","
#include <iostream>
#include <set>
#include <vector>
#include <cassert>

bool chkList(const std::vector<std::string>& lst) {
    std::set<std::string> uniqueElements;
    
    for (const auto& str : lst) {
        uniqueElements.insert(str);
    }
    
    return uniqueElements.size() == lst.size();
}

",1,3,0.5164415200551351,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\n\nbool chkList(const std::vector<std::string>& lst) {\n    return std::set<std::string>(lst.begin(), lst.end()).size() == 1;\n}\n\n\n': [('#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\nbool chkList(const std::vector<std::string>& lst) {\n//begin to write code\n', '\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\n\nbool chkList(const std::vector<std::string>& lst) {\n    std::set<std::string> uniqueElements;\n    \n    for (const auto& str : lst) {\n        uniqueElements.insert(str);\n    }\n    \n    return uniqueElements.size() == lst.size();\n}\n\n', 'equal_expression_transformation')]}"
191,"#include<iostream>
#include <string>
#include <cassert>
std::string remove_even(std::string str1) {
    std::string str2 = """";
    for (int i = 1; i <= str1.length(); ++i) {
        if (i % 2 != 0) {
//begin to write code
",222,"#include<iostream>
    

#include <string>
#include <cassert>

std::string remove_even(std::string str1) {
    std::string str2 = """";
    for (int i = 1; i <= str1.length(); ++i) {
        if (i % 2 != 0) {
            str2 += str1[i - 1];
        }
    }
    return str2;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<assert.h>

std::string remove_even(std::string str1) {
    std::string str2 = """";
    for (int i = 1; i <= str1.length(); ++i) {
        if (i % 2!= 0) {
            str2 += str1[i];
        }
    }
    return str2;
}

void test_remove_even() {
    assert(remove_even("""") == """");
    assert(remove_even(""abcdef"") == ""bcdf"");
    assert(remove_even(""hello world"") == ""hllwrld"");
    assert(remove_even(""1234567890"") == ""1234567890"");
    assert(remove_even(""aabbccdd"") == ""abccdd"");
    cout << ""All tests passed!"" << endl;
}

",,,,-2,1,0.22288495302200317,code_expression_exchange:None,0.0,0.0,
192,"#include <iostream>
#include <cassert>
int hamming_Distance(int n1, int n2) {
    int x = n1 ^ n2;
    int setBits = 0;
    while (x > 0) {
//begin to write code
",162,"
#include <iostream>
#include <cassert>

int hamming_Distance(int n1, int n2) {
    int x = n1 ^ n2;
    int setBits = 0;
    while (x > 0) {
        setBits += x & 1;
        x >>= 1;
    }
    return setBits;
}


","
using namespace std;

#include <iostream>
#include <cassert>

int hamming_Distance(int n1, int n2) {
    int x = n1 ^ n2;
    int setBits = 0;
    while (x > 0) {
        // Find the least significant bit set to 1
        int bit = x & 1;
        if (bit == 1) {
            setBits++;
        }
        // Right shift x by 1 to check the next bit
        x >>= 1;
    }
    return setBits;
}

","#include <iostream>
#include <cassert>
int hamming_Distance(int n1, int n2) {
    int x = n2 ^ n1;
    int setBits = 0;
    while (x > 0) {
//begin to write code
","
#include <iostream>
#include <cassert>

int hamming_Distance(int n1, int n2) {
    int x = n2 ^ n1;
    int setBits = 0;
    while (x > 0) {
        setBits += 1 & x;
        x >>= 1;
    }
    return setBits;
}


","
#include <iostream>
#include <cassert>

int hamming_Distance(int n1, int n2) {
    // Convert integers to their binary representation
    std::string bin1 = std::bitset<32>(n1).to_string();
    std::string bin2 = std::bitset<32>(n2).to_string();

    // Find the length of the shorter binary string
    int minLength = std::min(bin1.length(), bin2.length());

    // Perform XOR operation on the binary strings
    for (int i = 0; i < minLength; ++i) {
        if (bin1[i]!= bin2[i]) {
            // Increment the set bits counter if there is a mismatch
            setBits++;
        }
    }

    return setBits;
}

",1,3,0.494637926419576,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nint hamming_Distance(int n1, int n2) {\n    int x = n2 ^ n1;\n    int setBits = 0;\n    while (x > 0) {\n        setBits += 1 & x;\n        x >>= 1;\n    }\n    return setBits;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint hamming_Distance(int n1, int n2) {\n    int x = n2 ^ n1;\n    int setBits = 0;\n    while (x > 0) {\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nint hamming_Distance(int n1, int n2) {\n    // Convert integers to their binary representation\n    std::string bin1 = std::bitset<32>(n1).to_string();\n    std::string bin2 = std::bitset<32>(n2).to_string();\n\n    // Find the length of the shorter binary string\n    int minLength = std::min(bin1.length(), bin2.length());\n\n    // Perform XOR operation on the binary strings\n    for (int i = 0; i < minLength; ++i) {\n        if (bin1[i]!= bin2[i]) {\n            // Increment the set bits counter if there is a mismatch\n            setBits++;\n        }\n    }\n\n    return setBits;\n}\n\n', 'exchange_operators')]}"
193,"#include<iostream>
#include<cassert>
int count(std::string s, char c) {
    int res = 0;
    for (int i = 0; i < s.size(); i++) {
        if (s[i] == c) {
//begin to write code
",177,"
#include<iostream>
#include<cassert>

int count(std::string s, char c) {
    int res = 0;
    for (int i = 0; i < s.size(); i++) {
        if (s[i] == c) {
            res += 1;
        }
    }
    return res;
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

int count(std::string s, char c) {
    int res = 0;
    for (int i = 0; i < s.size(); i++) {
        if (s[i] == c) {
            res++;
        }
    }
    return res;
}
",,,,-2,1,0.16874624888102213,code_expression_exchange:None,0.0,0.0,
194,"#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> inversion_elements(const std::vector<int>& test_vec) {
    std::vector<int> res;
    for (int num : test_vec) {
//begin to write code
",208,"
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> inversion_elements(const std::vector<int>& test_vec) {
    std::vector<int> res;
    for (int num : test_vec) {
        res.push_back(~num);
    }
    return res;
}


","
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> inversion_elements(const std::vector<int>& test_vec) {
    std::vector<int> res;
    for (int i = 0; i < test_vec.size(); ++i) {
        for (int j = i + 1; j < test_vec.size(); ++j) {
            if (test_vec[i] > test_vec[j]) {
                res.push_back(i);
                res.push_back(j);
            }
        }
    }
    return res;
}

void test_inversion_elements() {
    assert(inversion_elements({1, 2, 3, 4, 5}) == std::vector<int>({1, 4, 2, 3, 5}));
    assert(inversion_elements({5, 4, 3, 2, 1}) == std::vector<int>({1, 4, 2, 3, 5}));
    assert(inversion_elements({1, 2, 3, 4, 5, 6}) == std::vector<int>({1, 4, 2, 3, 5, 6}));
    assert(in",,,,-2,1,0.22809927066167196,code_expression_exchange:None,0.0,0.0,
195,"#include <iostream>
#include <vector>
#include <string>
#include <tuple>
#include <cassert>
std::vector<std::string> concatenate_elements(const std::vector<std::string>& test_vec) {
    std::vector<std::string> res;
    for (size_t i = 0; i < test_vec.size() - 1; ++i) {
//begin to write code
",293,"
#include <iostream>
#include <vector>
#include <string>
#include <tuple>
#include <cassert>

std::vector<std::string> concatenate_elements(const std::vector<std::string>& test_vec) {
    std::vector<std::string> res;
    for (size_t i = 0; i < test_vec.size() - 1; ++i) {
        res.push_back(test_vec[i] + test_vec[i + 1]);
    }
    return res;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <string>
#include <tuple>
#include <cassert>

std::vector<std::string> concatenate_elements(const std::vector<std::string>& test_vec) {
    std::vector<std::string> res;
    for (size_t i = 0; i < test_vec.size() - 1; ++i) {
        res.push_back(test_vec[i]);
        res.push_back(test_vec[i + 1]);
    }
    return res;
}

",,,,-2,1,0.23262310028076172,code_expression_exchange:None,0.0,0.0,
196,"#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
int find_longest_repeating_subseq(string str) {
    int n = str.length();
    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (str[i - 1] == str[j - 1] && i != j) {
                dp[i][j] = 1 + dp[i - 1][j - 1];
//begin to write code
",409,"
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

int find_longest_repeating_subseq(string str) {
    int n = str.length();
    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (str[i - 1] == str[j - 1] && i != j) {
                dp[i][j] = 1 + dp[i - 1][j - 1];
            } else {
                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
            }
        }
    }
    return dp[n][n];
}


","
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

int find_longest_repeating_subseq(string str) {
    int n = str.length();
    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (str[i - 1] == str[j - 1]) {
                dp[i][j] = 1 + dp[i - 1][j - 1];
                // If the current character matches the previous one, increment the count by 1
                if (i > 1 && str[i - 2] == str[j - 1]) {
                    dp[i][j] = max(dp[i][j], dp[i - 2][j - 1] + 1);
                }
            }
        }
    }
    return dp[n][n];
}

void test_find_longest_repeating_subseq() {
    assert(find_longest_repeating_subseq(""abc"") == 1);
    assert(find_longest_repeating_subseq",,,,-2,1,0.23732486963272095,code_expression_exchange:None,0.0,0.0,
197,"#include <iostream>
#include <regex>
#include <cassert>
using namespace std;
bool is_decimal(const string& num) {
    regex num_fetch(R""(^[0-9]+(\.[0-9]{1,2})?$)"");
//begin to write code
",187,"#include <iostream>
#include <regex>
#include <cassert>

using namespace std;

bool is_decimal(const string& num) {
    regex num_fetch(R""(^[0-9]+(\.[0-9]{1,2})?$)"");
    return regex_search(num, num_fetch);
}","
#include <iostream>
#include <regex>
#include <cassert>
using namespace std;

bool is_decimal(const string& num) {
    regex num_fetch(R""(^[0-9]+(\.[0-9]{1,2})?$)"");
    return regex_match(num, num_fetch);
}

","#include <iostream>
#include <regex>
#include <cassert>
using namespace std;
bool is_decimal(const string& num) {
    regex num_fetch(R""(^[0-9]+(\.[0-9]{1,2})?$)"");
//begin to write code
","#include <iostream>
#include <regex>
#include <cassert>

using namespace std;

bool is_decimal(const string& num) {
    regex num_fetch(R""(^[0-9]+(\.[0-9]{1,2})?$)"");
    return regex_search(num, num_fetch);
}","
#include <iostream>
#include <regex>
#include <cassert>
using namespace std;

bool is_decimal(const string& num) {
    // Use regex to match a decimal number with a precision of 2
    return regex_match(num, R""^(?:(?:\d+(\.\d{1,2})?)$"");
}

",1,7,1.2412280837694805,code_expression_exchange:bool2int,1.0,0.0,"{'#include <iostream>\n#include <regex>\n#include <cassert>\n\nusing namespace std;\n\nbool is_decimal(const string& num) {\n    regex num_fetch(R""(^[0-9]+(\\.[0-9]{1,2})?$)"");\n    return regex_search(num, num_fetch);\n}': [('#include <iostream>\n#include <regex>\n#include <cassert>\nusing namespace std;\nbool is_decimal(const string& num) {\n    regex num_fetch(R""(^[0-9]+(\\.[0-9]{1,2})?$)"");\n//begin to write code\n', '\n#include <iostream>\n#include <regex>\n#include <cassert>\nusing namespace std;\n\nbool is_decimal(const string& num) {\n    regex num_fetch(R""(^[0-9]+(\\.[0-9]{1,2})?$)"");\n    return regex_match(num, num_fetch);\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <regex>\n#include <cassert>\nusing namespace std;\nbool is_decimal(const string& num) {\n    regex num_fetch(R""(^[0-9]+(\\.[0-9]{1,2})?$)"");\n//begin to write code\n', '\n#include <iostream>\n#include <regex>\n#include <cassert>\nusing namespace std;\n\nbool is_decimal(const string& num) {\n    // Regular expression to match a decimal number with a precision of 2\n    regex num_fetch(R""(^[0-9]+(\\.[0-9]{1,2})?$)"");\n    \n    // Use regex_search to check if the string matches the pattern\n    return regex_search(num, num_fetch);\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <regex>\n#include <cassert>\nusing namespace std;\nbool is_decimal(const string& num) {\n    regex num_fetch(R""(^[0-9]+(\\.[0-9]{1,2})?$)"");\n//begin to write code\n', '\n#include <iostream>\n#include <regex>\n#include <cassert>\nusing namespace std;\n\nbool is_decimal(const string& num) {\n    // Use regex to match a decimal number with a precision of 2\n    return regex_match(num, R""^(?:(?:\\d+(\\.\\d{1,2})?)$"");\n}\n\n', 'bool2int')]}"
198,"#include <vector>
#include <algorithm>
#include <cassert>
#include <iostream>
using namespace std;
vector<int> heap_replace(vector<int> heap, int a) {
    make_heap(heap.begin(), heap.end(),greater<int>());
    pop_heap(heap.begin(), heap.end());
    heap.pop_back();
//begin to write code
",290,"#include <vector>
#include <algorithm>
#include <cassert>
#include <iostream>

using namespace std;

vector<int> heap_replace(vector<int> heap, int a) {
    make_heap(heap.begin(), heap.end(),greater<int>());
    pop_heap(heap.begin(), heap.end());
    heap.pop_back();
    heap.push_back(a);
    sort(heap.begin(),heap.end());
    return heap;
}","#include <vector>
#include <algorithm>
#include <cassert>
#include <iostream>
using namespace std;

vector<int> heap_replace(vector<int> heap, int a) {
    // Ensure the heap is valid
    if (heap.empty()) {
        return heap; // Return an empty vector if the heap is empty
    }
    
    // Create a copy of the heap
    vector<int> temp = heap;
    
    // Find the smallest element in the heap
    int min_element = temp.front();
    for (int i = 1; i < temp.size(); ++i) {
        if (temp[i] < min_element) {
            min_element = temp[i];
        }
    }
    
    // Remove the smallest element from the heap
    temp.erase(temp.begin());
    
    // Insert the new element into the heap
    temp.push_back(a);
    
    // Reconstruct the heap
    make_heap(temp.begin(), temp.end(), greater<int>());
    
    return temp;
}
",,,,-2,1,0.23014129797617594,code_expression_exchange:None,0.0,0.0,
199,"#include<iostream>
#include <regex>
#include <string>
#include <cassert>
using namespace std;
bool is_allowed_specific_char(string str) {
    regex get_char(""[^a-zA-Z0-9.]"");
//begin to write code
",197,"#include<iostream>
    
#include <regex>
#include <string>
#include <cassert>
using namespace std;

bool is_allowed_specific_char(string str) {
    regex get_char(""[^a-zA-Z0-9.]"");
    return !regex_search(str, get_char);
}","
#include <iostream>
#include <regex>
#include <string>
#include <cassert>

using namespace std;

bool is_allowed_specific_char(string str) {
    // Define the pattern to match only lowercase letters and digits
    regex pattern(""[a-z0-9]"");
    
    // Use regex_search to check if the entire string matches the pattern
    return regex_search(str, pattern);
}

","#include<iostream>
#include <regex>
#include <string>
#include <cassert>
using namespace std;
bool is_allowed_specific_char(string str) {
    regex get_char(""[^a-zA-Z0-9.]"");
//begin to write code
","#include<iostream>
    
#include <regex>
#include <string>
#include <cassert>
using namespace std;

bool is_allowed_specific_char(string str) {
    regex get_char(""[^a-zA-Z0-9.]"");
    return !regex_search(str, get_char);
}","
#include<iostream>
#include <regex>
#include <string>
#include <cassert>
using namespace std;

bool is_allowed_specific_char(string str) {
    // Define a regular expression pattern that matches any character that is not a letter or digit
    regex get_char(""[^a-zA-Z0-9]"");
    
    // Use the regex_search function to check if the entire string matches the pattern
    return regex_search(str, get_char);
}

",1,3,0.6040355205535889,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'#include<iostream>\n    \n#include <regex>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nbool is_allowed_specific_char(string str) {\n    regex get_char(""[^a-zA-Z0-9.]"");\n    return !regex_search(str, get_char);\n}': [('#include<iostream>\n#include <regex>\n#include <string>\n#include <cassert>\nusing namespace std;\nbool is_allowed_specific_char(string str) {\n    regex get_char(""[^a-zA-Z0-9.]"");\n//begin to write code\n', '\n#include<iostream>\n#include <regex>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nbool is_allowed_specific_char(string str) {\n    // Define a regular expression pattern that matches any character that is not a letter or digit\n    regex get_char(""[^a-zA-Z0-9]"");\n    \n    // Use the regex_search function to check if the entire string matches the pattern\n    return regex_search(str, get_char);\n}\n\n', 'equal_expression_transformation')]}"
200,"#include <iostream>
#include <cmath>
#include <cassert>
int count_Num(int n) {
    if (n == 1) {
        return 1;
//begin to write code
",137,"
#include <iostream>
#include <cmath>
#include <cassert>

int count_Num(int n) {
    if (n == 1) {
        return 1;
    }
    int count = pow(2, n - 2);
    return count;
}


","
using namespace std;

#include <iostream>
#include <cmath>
#include <cassert>

int count_Num(int n) {
    if (n == 1) {
        return 1;
    }
    int count = 0;
    for (int i = 0; i <= n; ++i) {
        if ((i >> 1) & 1) { // Check if the i-th bit is set
            count++;
        }
    }
    return count;
}

","#include <iostream>
#include <cmath>
#include <cassert>
int count_Num(int n) {
    if (1 == n) {
        return 1;
//begin to write code
","
#include <iostream>
#include <cmath>
#include <cassert>

int count_Num(int n) {
    if (1 == n) {
        return 1;
    }
    int count = pow(2, n - 2);
    return count;
}


","#include <iostream>
#include <cmath>
#include <cassert>

int count_Num(int n) {
    if (1 == n) {
        return 1;
    }
    int count = 0;
    for (int i = 0; i <= n; ++i) {
        if ((i & 1) == 1 && (i & 2) == 0) {
            ++count;
        }
    }
    return count;
}
",1,3,0.5169105728467306,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint count_Num(int n) {\n    if (1 == n) {\n        return 1;\n    }\n    int count = pow(2, n - 2);\n    return count;\n}\n\n\n': [('#include <iostream>\n#include <cmath>\n#include <cassert>\nint count_Num(int n) {\n    if (1 == n) {\n        return 1;\n//begin to write code\n', '#include <iostream>\n#include <cmath>\n#include <cassert>\n\nint count_Num(int n) {\n    if (1 == n) {\n        return 1;\n    }\n    int count = 0;\n    for (int i = 0; i <= n; ++i) {\n        if ((i & 1) == 1 && (i & 2) == 0) {\n            ++count;\n        }\n    }\n    return count;\n}\n', 'exchange_operators')]}"
201,"#include <iostream>
#include <cassert>
#include <cmath>
int fourth_Power_Sum(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
//begin to write code
",160,"
#include <iostream>
#include <cassert>
#include <cmath>

int fourth_Power_Sum(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += pow(i, 4);
    }
    return sum;
}


","
#include <iostream>
#include <cassert>
#include <cmath>
int fourth_Power_Sum(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += std::pow(i, 4);
    }
    return sum;
}

","#include <iostream>
#include <cassert>
#include <cmath>
int fourth_Power_Sum(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
//begin to write code
","
#include <iostream>
#include <cassert>
#include <cmath>

int fourth_Power_Sum(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += pow(i, 4);
    }
    return sum;
}


","
#include <iostream>
#include <cassert>

int factorial(int n) {
    if (n < 0) {
        throw std::invalid_argument(""Factorial is not defined for negative numbers."");
    }
    int result = 1;
    for (int i = 1; i <= n; ++i) {
        result *= i;
    }
    return result;
}

",1,3,0.49338651100794473,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n#include <cmath>\n\nint fourth_Power_Sum(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += pow(i, 4);\n    }\n    return sum;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\n#include <cmath>\nint fourth_Power_Sum(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nint factorial(int n) {\n    if (n < 0) {\n        throw std::invalid_argument(""Factorial is not defined for negative numbers."");\n    }\n    int result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n', 'bool2int')]}"
202,"#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>
std::tuple<std::string, std::string, std::string> concatenate_strings(const std::tuple<std::string, std::string, std::string>& test_tup1, const std::tuple<std::string, std::string, std::string>& test_tup2)
{
    std::tuple<std::string, std::string, std::string> res(
        std::get<0>(test_tup1) + std::get<0>(test_tup2),
//begin to write code
",420,"
#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>

std::tuple<std::string, std::string, std::string> concatenate_strings(const std::tuple<std::string, std::string, std::string>& test_tup1, const std::tuple<std::string, std::string, std::string>& test_tup2)
{
    std::tuple<std::string, std::string, std::string> res(
        std::get<0>(test_tup1) + std::get<0>(test_tup2),
        std::get<1>(test_tup1) + std::get<1>(test_tup2),
        std::get<2>(test_tup1) + std::get<2>(test_tup2)
    );
    return res;
}


","#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>
std::tuple<std::string, std::string, std::string> concatenate_strings(const std::tuple<std::string, std::string, std::string>& test_tup1, const std::tuple<std::string, std::string, std::string>& test_tup2)
{
    std::tuple<std::string, std::string, std::string> res(
        std::get<0>(test_tup1) + std::get<0>(test_tup2),
        std::get<1>(test_tup1) + std::get<1>(test_tup2),
        std::get<2>(test_tup1) + std::get<2>(test_tup2)
    );
    return res;
}
","#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>
std::tuple<std::string, std::string, std::string> concatenate_strings(const std::tuple<std::string, std::string, std::string>& test_tup1, const std::tuple<std::string, std::string, std::string>& test_tup2)
{
    std::tuple<std::string, std::string, std::string> res(
        std::get<0>(test_tup1) + std::get<0>(test_tup2),
//begin to write code
","
#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>

std::tuple<std::string, std::string, std::string> concatenate_strings(const std::tuple<std::string, std::string, std::string>& test_tup1, const std::tuple<std::string, std::string, std::string>& test_tup2)
{
    std::tuple<std::string, std::string, std::string> res(
        std::get<0>(test_tup1) + std::get<0>(test_tup2),
        std::get<1>(test_tup1) + std::get<1>(test_tup2),
        std::get<2>(test_tup1) + std::get<2>(test_tup2)
    );
    return res;
}


","
#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>
#include <string>

std::tuple<std::string, std::string, std::string> concatenate_strings(const std::tuple<std::string, std::string, std::string>& test_tup1, const std::tuple<std::string, std::string, std::string>& test_tup2)
{
    // Concatenate the first two strings
    std::string result = std::get<0>(test_tup1) + std::get<0>(test_tup2);

    // Concatenate the third string with the result
    result += std::get<2>(test_tup2);

    return result;
}

",1,3,0.48120861053466796,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<std::string, std::string, std::string> concatenate_strings(const std::tuple<std::string, std::string, std::string>& test_tup1, const std::tuple<std::string, std::string, std::string>& test_tup2)\n{\n    std::tuple<std::string, std::string, std::string> res(\n        std::get<0>(test_tup1) + std::get<0>(test_tup2),\n        std::get<1>(test_tup1) + std::get<1>(test_tup2),\n        std::get<2>(test_tup1) + std::get<2>(test_tup2)\n    );\n    return res;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<std::string, std::string, std::string> concatenate_strings(const std::tuple<std::string, std::string, std::string>& test_tup1, const std::tuple<std::string, std::string, std::string>& test_tup2)\n{\n    std::tuple<std::string, std::string, std::string> res(\n        std::get<0>(test_tup1) + std::get<0>(test_tup2),\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n#include <string>\n\nstd::tuple<std::string, std::string, std::string> concatenate_strings(const std::tuple<std::string, std::string, std::string>& test_tup1, const std::tuple<std::string, std::string, std::string>& test_tup2)\n{\n    // Concatenate the first two strings\n    std::string result = std::get<0>(test_tup1) + std::get<0>(test_tup2);\n\n    // Concatenate the third string with the result\n    result += std::get<2>(test_tup2);\n\n    return result;\n}\n\n', 'bool2int')]}"
203,"#include <cmath>
#include <cassert>
#include <iostream>
double degree_radian(double radian) {
    double degree = radian * (180.0 / M_PI);
//begin to write code
",161,"
#include <cmath>
#include <cassert>
#include <iostream>

double degree_radian(double radian) {
    double degree = radian * (180.0 / M_PI);
    return degree;
}


","
#include <cmath>
#include <cassert>
#include <iostream>

// Function to convert radians to degrees
double degree_radian(double radian) {
    return radian * (180.0 / M_PI);
}

","#include <cmath>
#include <cassert>
#include <iostream>
double degree_radian(double radian) {
    double degree = (180.0 / M_PI) * radian;
//begin to write code
","
#include <cmath>
#include <cassert>
#include <iostream>

double degree_radian(double radian) {
    double degree = (180.0 / M_PI) * radian;
    return degree;
}


","
#include <cmath>
#include <cassert>
#include <iostream>
#include <vector>

// Function to convert radians to degrees
double degree_radian(double radian) {
    return (180.0 / M_PI) * radian;
}

",-1,21,2.621992210547129,code_expression_exchange:bool2int,1.0,0.7607578508066901,"{'\n#include <cmath>\n#include <cassert>\n#include <iostream>\n\ndouble degree_radian(double radian) {\n    double degree = (180.0 / M_PI) * radian;\n    return degree;\n}\n\n\n': [('#include <cmath>\n#include <cassert>\n#include <iostream>\ndouble degree_radian(double radian) {\n    double degree = radian * (180.0 / M_PI);\n//begin to write code\n', '\nusing namespace std;\n#include <cmath>\n#include <cassert>\n#include <iostream>\n\ndouble degree_radian(double radian) {\n    return radian * (180.0 / M_PI);\n}\n\n', 'more_universe_var_type'), ('#include <cmath>\n#include <cassert>\n#include <iostream>\ndouble degree_radian(double radian) {\n    double degree = radian * (180.0 / M_PI);\n//begin to write code\n', '\nusing namespace std;\n#include <cmath>\n#include <cassert>\n#include <iostream>\n\ndouble degree_radian(double radian) {\n    double degree = radian * (180.0 / M_PI);\n    return degree;\n}\n\n', 'equal_expression_transformation'), ('#include <cmath>\n#include <cassert>\n#include <iostream>\ndouble degree_radian(double radian) {\n    double degree = (180.0 / M_PI) * radian;\n//begin to write code\n', '\nusing namespace std;\n\n#include <cmath>\n#include <cassert>\n#include <iostream>\n\ndouble degree_radian(double radian) {\n    return (180.0 / M_PI) * radian;\n}\n\n', 'exchange_operators'), ('#include <cmath>\n#include <cassert>\n#include <iostream>\ndouble degree_radian(double radian) {\n    double degree = (180.0 / M_PI) * radian;\n//begin to write code\n', '\nusing namespace std;\n#include <cmath>\n#include <cassert>\n#include <iostream>\n\ndouble degree_radian(double radian) {\n    return (180.0 / M_PI) * radian;\n}\n\n', 'equal_expression_transformation'), ('#include <cmath>\n#include <cassert>\n#include <iostream>\ndouble degree_radian(double radian) {\n    double degree = (180.0 / M_PI) * radian;\n//begin to write code\n', '\n#include <cmath>\n#include <cassert>\n#include <iostream>\n\ndouble degree_radian(double radian) {\n    return (180.0 / M_PI) * radian;\n}\n\n', 'equal_expression_transformation'), ('#include <cmath>\n#include <cassert>\n#include <iostream>\ndouble degree_radian(double radian) {\n    double degree = (180.0 / M_PI) * radian;\n//begin to write code\n', '\n#include <cmath>\n#include <cassert>\n#include <iostream>\n\nusing namespace std;\n\ndouble degree_radian(double radian) {\n    return (180.0 / M_PI) * radian;\n}\n\n', 'more_universe_var_type'), ('#include <cmath>\n#include <cassert>\n#include <iostream>\ndouble degree_radian(double radian) {\n    double degree = (180.0 / M_PI) * radian;\n//begin to write code\n', '\nusing namespace std;\n#include <cmath>\n#include <cassert>\n#include <iostream>\n\ndouble degree_radian(double radian) {\n    return (180.0 / M_PI) * radian;\n}\n\n', 'bool2int'), ('#include <cmath>\n#include <cassert>\n#include <iostream>\ndouble degree_radian(double radian) {\n    double degree = (180.0 / M_PI) * radian;\n//begin to write code\n', '\n#include <cmath>\n#include <cassert>\n#include <iostream>\ndouble degree_radian(double radian) {\n    return (180.0 / M_PI) * radian;\n}\n\n', 'bool2int'), ('#include <cmath>\n#include <cassert>\n#include <iostream>\ndouble degree_radian(double radian) {\n    double degree = (180.0 / M_PI) * radian;\n//begin to write code\n', '\n#include <cmath>\n#include <cassert>\n#include <iostream>\ndouble degree_radian(double radian) {\n    return (180.0 / M_PI) * radian;\n}\n\n', 'bool2int'), ('#include <cmath>\n#include <cassert>\n#include <iostream>\ndouble degree_radian(double radian) {\n    double degree = (180.0 / M_PI) * radian;\n//begin to write code\n', '\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <vector>\n\n// Function to convert radians to degrees\ndouble degree_radian(double radian) {\n    return (180.0 / M_PI) * radian;\n}\n\n', 'bool2int')]}"
204,"#include <iostream>
#include <vector>
#include <cassert>
#include <typeinfo>
using namespace std;
vector<int> decode_list(const vector<vector<int>>& alist) {
    vector<int> result;
    for (const auto& g : alist) {
        if (g.size() == 2) {
            for (int i = 0; i < g[0]; ++i) {
                result.push_back(g[1]);
//begin to write code
",352,"
#include <iostream>
#include <vector>
#include <cassert>
#include <typeinfo>
using namespace std;

vector<int> decode_list(const vector<vector<int>>& alist) {
    vector<int> result;
    for (const auto& g : alist) {
        if (g.size() == 2) {
            for (int i = 0; i < g[0]; ++i) {
                result.push_back(g[1]);
            }
        } else {
            result.push_back(g[0]);
        }
    }
    return result;
}


","#include <iostream>
#include <vector>
#include <cassert>
#include <typeinfo>
using namespace std;
vector<int> decode_list(const vector<vector<int>>& alist) {
    vector<int> result;
    for (const auto& g : alist) {
        if (g.size() == 2) {
            for (int i = 0; i < g[0]; ++i) {
                result.push_back(g[1]);
            }
        } else {
            // Handle non-run-length-encoded cases here
            // For example, if the list contains a single element, just add it to the result
            result.push_back(g[0]);
        }
    }
    return result;
}
","#include <iostream>
#include <vector>
#include <cassert>
#include <typeinfo>
using namespace std;
vector<int> decode_list(const vector<vector<int>>& alist) {
    vector<int> result;
    for (const auto& g : alist) {
        if (2 == g.size()) {
            for (int i = 0; i < g[0]; ++i) {
                result.push_back(g[1]);
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>
#include <typeinfo>
using namespace std;

vector<int> decode_list(const vector<vector<int>>& alist) {
    vector<int> result;
    for (const auto& g : alist) {
        if (2 == g.size()) {
            for (int i = 0; i < g[0]; ++i) {
                result.push_back(g[1]);
            }
        } else {
            result.push_back(g[0]);
        }
    }
    return result;
}


","#include <iostream>
#include <vector>
#include <cassert>
#include <typeinfo>
using namespace std;
vector<int> decode_list(const vector<vector<int>>& alist) {
    vector<int> result;
    for (const auto& g : alist) {
        if (2 == g.size()) {
            for (int i = 0; i < g[0]; ++i) {
                result.push_back(g[1]);
            }
        } else {
            // Handle non-run-length encoded data
            int current_number = g[0];
            while (!g.empty() && g.back() == current_number) {
                result.push_back(g.back());
                g.pop_back();
            }
        }
    }
    return result;
}
",1,3,0.45003278652826945,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <typeinfo>\nusing namespace std;\n\nvector<int> decode_list(const vector<vector<int>>& alist) {\n    vector<int> result;\n    for (const auto& g : alist) {\n        if (2 == g.size()) {\n            for (int i = 0; i < g[0]; ++i) {\n                result.push_back(g[1]);\n            }\n        } else {\n            result.push_back(g[0]);\n        }\n    }\n    return result;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <typeinfo>\nusing namespace std;\nvector<int> decode_list(const vector<vector<int>>& alist) {\n    vector<int> result;\n    for (const auto& g : alist) {\n        if (2 == g.size()) {\n            for (int i = 0; i < g[0]; ++i) {\n                result.push_back(g[1]);\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <cassert>\n#include <typeinfo>\nusing namespace std;\nvector<int> decode_list(const vector<vector<int>>& alist) {\n    vector<int> result;\n    for (const auto& g : alist) {\n        if (2 == g.size()) {\n            for (int i = 0; i < g[0]; ++i) {\n                result.push_back(g[1]);\n            }\n        } else {\n            // Handle non-run-length encoded data\n            int current_number = g[0];\n            while (!g.empty() && g.back() == current_number) {\n                result.push_back(g.back());\n                g.pop_back();\n            }\n        }\n    }\n    return result;\n}\n', 'exchange_operators')]}"
205,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
template<typename T>
bool check_subset_list(std::vector<std::vector<T>> list1, std::vector<std::vector<T>> list2) {
    bool exist = true;
    for (const auto& sublist : list2) {
        for (const auto& item : sublist) {
            bool found = false;
            for (const auto& l : list1) {
                if (std::find(l.begin(), l.end(), item) != l.end()) {
                    found = true;
                    break;
//begin to write code
",526,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>

template<typename T>
bool check_subset_list(std::vector<std::vector<T>> list1, std::vector<std::vector<T>> list2) {
    bool exist = true;
    for (const auto& sublist : list2) {
        for (const auto& item : sublist) {
            bool found = false;
            for (const auto& l : list1) {
                if (std::find(l.begin(), l.end(), item) != l.end()) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                exist = false;
                break;
            }
        }
        if (!exist) break;
    }
    return exist;
}


","
#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>

template<typename T>
bool check_subset_list(std::vector<std::vector<T>> list1, std::vector<std::vector<T>> list2) {
    std::set<std::vector<T>> set1(list1.begin(), list1.end());
    for (const auto& sublist : list2) {
        std::set<std::vector<T>> set2(sublist.begin(), sublist.end());
        if (!set1.find(set2.begin(), set2.end())) {
            return false;
        }
    }
    return true;
}

",,,,-2,1,0.2312373161315918,code_expression_exchange:None,0.0,0.0,
206,"#include<cassert>
#include<iostream>
#include<string>
#include<unordered_map>
using namespace std;
char first_Repeated_Char(string str) 
{
    unordered_map<char, int> h;
    for (char ch : str) {
        if (h.find(ch) != h.end()) { 
            return ch;
//begin to write code
",280,"#include<cassert>
#include<iostream>
#include<string>
#include<unordered_map>
using namespace std;

char first_Repeated_Char(string str) 
{
    unordered_map<char, int> h;
    for (char ch : str) {
        if (h.find(ch) != h.end()) { 
            return ch;
        } else { 
            h[ch] = 0;
        }
    }
    return '\0';
}


","
#include<cassert>
#include<iostream>
#include<string>
#include<unordered_map>
using namespace std;

char first_Repeated_Char(string str) 
{
    unordered_map<char, int> h;
    for (char ch : str) {
        h[ch]++;
        if (h[ch] > 1) {
            return ch;
        }
    }
    return '#'; // Return a special character if no repeated character is found
}

",,,,-2,1,0.21286410888036092,code_expression_exchange:None,0.0,0.0,
207,"#include <iostream>
#include <algorithm>
#include <numeric>
#include <cassert>
using namespace std;
int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
//begin to write code
",246,"#include <iostream>
#include <algorithm>
#include <numeric>
#include <cassert>

using namespace std;

int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}


int min_Operations(int A, int B) {
    if (A > B) {
        swap(A, B);
    }
    B = B / gcd(A, B);
    return B - 1;
}","using namespace std;
int gcd(int a, int b) {
    while (b!= 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int minOperationsToMakeEqual(int num1, int num2) {
    return abs(num1 - num2);
}
",,,,-2,1,0.1657867908477783,code_expression_exchange:None,0.0,0.0,
208,"#include <iostream>
#include <vector>
#include <algorithm>
#include <tuple>
#include <cassert>
std::tuple<std::vector<int>> extract_min_max(std::vector<int> test_vec, int K) {
    std::vector<int> res;
    std::sort(test_vec.begin(), test_vec.end());
    for (int idx = 0; idx < test_vec.size(); ++idx) {
        if (idx < K || idx >= test_vec.size() - K) {
//begin to write code
",380,"
#include <iostream>
#include <vector>
#include <algorithm>
#include <tuple>
#include <cassert>

std::tuple<std::vector<int>> extract_min_max(std::vector<int> test_vec, int K) {
    std::vector<int> res;
    std::sort(test_vec.begin(), test_vec.end());
    for (int idx = 0; idx < test_vec.size(); ++idx) {
        if (idx < K || idx >= test_vec.size() - K) {
            res.push_back(test_vec[idx]);
        }
    }
    return std::make_tuple(res);
}


","
#include <iostream>
#include <vector>
#include <algorithm>
#include <tuple>
#include <cassert>

std::tuple<std::vector<int>> extract_min_max(std::vector<int> test_vec, int K) {
    std::vector<int> res;
    std::sort(test_vec.begin(), test_vec.end());
    for (int idx = 0; idx < test_vec.size(); ++idx) {
        if (idx < K || idx >= test_vec.size() - K) {
            res.push_back(test_vec[idx]);
        }
    }
    return res;
}

","#include <iostream>
#include <vector>
#include <algorithm>
#include <tuple>
#include <cassert>
std::tuple<std::vector<int>> extract_min_max(std::vector<int> test_vec, long K) {
    std::vector<int> res;
    std::sort(test_vec.begin(), test_vec.end());
    for (int idx = 0; idx < test_vec.size(); idx = idx + 1) {
        if (idx < K || idx >= test_vec.size() - K) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <algorithm>
#include <tuple>
#include <cassert>

std::tuple<std::vector<int>> extract_min_max(std::vector<int> test_vec, long K) {
    std::vector<int> res;
    std::sort(test_vec.begin(), test_vec.end());
    for (int idx = 0; idx < test_vec.size(); idx = idx + 1) {
        if (idx < K || idx >= test_vec.size() - K) {
            res.push_back(test_vec[idx]);
        }
    }
    return std::make_tuple(res);
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <algorithm>
#include <tuple>
#include <cassert>

std::tuple<std::vector<int>> extract_min_max(std::vector<int> test_vec, long K) {
    std::vector<int> res;
    std::sort(test_vec.begin(), test_vec.end());
    for (int idx = 0; idx < test_vec.size(); idx = idx + 1) {
        if (idx < K || idx >= test_vec.size() - K) {
            res.push_back(test_vec[idx]);
        }
    }
    return res;
}

void test_extract_min_max() {
    assert(extract_min_max({1, 2, 3, 4, 5}, 3).first == std::vector<int>({1, 2}));
    assert(extract_min_max({-1, -2, -3, -4, -5}, 3).first == std::vector<int>({-1, -2}));
    assert(extract_min_max({10, 20, 30, 40, 50}, 5).first == std::vector<int>({10, 20, ",1,7,1.0548167069753012,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<std::vector<int>> extract_min_max(std::vector<int> test_vec, long K) {\n    std::vector<int> res;\n    std::sort(test_vec.begin(), test_vec.end());\n    for (int idx = 0; idx < test_vec.size(); idx = idx + 1) {\n        if (idx < K || idx >= test_vec.size() - K) {\n            res.push_back(test_vec[idx]);\n        }\n    }\n    return std::make_tuple(res);\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <cassert>\nstd::tuple<std::vector<int>> extract_min_max(std::vector<int> test_vec, long K) {\n    std::vector<int> res;\n    std::sort(test_vec.begin(), test_vec.end());\n    for (int idx = 0; idx < test_vec.size(); ++idx) {\n        if (idx < K || idx >= test_vec.size() - K) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<std::vector<int>> extract_min_max(std::vector<int> test_vec, long K) {\n    std::vector<int> res;\n    std::sort(test_vec.begin(), test_vec.end());\n    for (int idx = 0; idx < test_vec.size(); ++idx) {\n        if (idx < K || idx >= test_vec.size() - K) {\n            res.push_back(test_vec[idx]);\n        }\n    }\n    return res;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <cassert>\nstd::tuple<std::vector<int>> extract_min_max(std::vector<int> test_vec, long K) {\n    std::vector<int> res;\n    std::sort(test_vec.begin(), test_vec.end());\n    for (int idx = 0; idx < test_vec.size(); idx = idx + 1) {\n        if (idx < K || idx >= test_vec.size() - K) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<std::vector<int>> extract_min_max(std::vector<int> test_vec, long K) {\n    std::vector<int> res;\n    std::sort(test_vec.begin(), test_vec.end());\n    for (int idx = 0; idx < test_vec.size(); idx = idx + 1) {\n        if (idx < K || idx >= test_vec.size() - K) {\n            res.push_back(test_vec[idx]);\n        }\n    }\n    return res;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <cassert>\nstd::tuple<std::vector<int>> extract_min_max(std::vector<int> test_vec, long K) {\n    std::vector<int> res;\n    std::sort(test_vec.begin(), test_vec.end());\n    for (int idx = 0; idx < test_vec.size(); idx = idx + 1) {\n        if (idx < K || idx >= test_vec.size() - K) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<std::vector<int>> extract_min_max(std::vector<int> test_vec, long K) {\n    std::vector<int> res;\n    std::sort(test_vec.begin(), test_vec.end());\n    for (int idx = 0; idx < test_vec.size(); idx = idx + 1) {\n        if (idx < K || idx >= test_vec.size() - K) {\n            res.push_back(test_vec[idx]);\n        }\n    }\n    return res;\n}\n\nvoid test_extract_min_max() {\n    assert(extract_min_max({1, 2, 3, 4, 5}, 3).first == std::vector<int>({1, 2}));\n    assert(extract_min_max({-1, -2, -3, -4, -5}, 3).first == std::vector<int>({-1, -2}));\n    assert(extract_min_max({10, 20, 30, 40, 50}, 5).first == std::vector<int>({10, 20, ', 'equal_expression_transformation')]}"
209,"#include <iostream>
#include <string>
#include <regex>
#include <cassert>
std::string replace_max_specialchar(const std::string& text, int n) {
    std::regex pattern(""[ ,.]"");
    std::string result;
    int count = 0;
    for (auto it = text.begin(); it != text.end(); ++it) {
        if (std::regex_match(std::string(1, *it), pattern) && count < n) {
            result += ':';
//begin to write code
",403,"#include <iostream>
#include <string>
#include <regex>
#include <cassert>

std::string replace_max_specialchar(const std::string& text, int n) {
    std::regex pattern(""[ ,.]"");
    std::string result;
    int count = 0;

    for (auto it = text.begin(); it != text.end(); ++it) {
        if (std::regex_match(std::string(1, *it), pattern) && count < n) {
            result += ':';
            ++count;
        } else {
            result += *it;
        }
    }

    return result;
}","
using namespace std;
#include <iostream>
#include <string>
#include <regex>
#include <cassert>

std::string replace_max_specialchar(const std::string& text, int n) {
    std::regex pattern(""[,.]"");
    std::string result;
    int count = 0;
    for (auto it = text.begin(); it!= text.end(); ++it) {
        if (std::regex_match(std::string(1, *it), pattern) && count < n) {
            result += ':';
        } else if (*it =='') {
            ++count;
        } else if (*it == ',') {
            ++count;
        } else if (*it == '.') {
            ++count;
        }
    }
    return result;
}

",,,,-2,1,0.2432788133621216,code_expression_exchange:None,0.0,0.0,
210,"#include<cassert>
#include <iostream>
#include <vector>
int first_even(const std::vector<int>& nums) {
    for (int num : nums) {
        if (num % 2 == 0) {
            return num;
//begin to write code
",204,"#include<cassert>
#include <iostream>
#include <vector>

int first_even(const std::vector<int>& nums) {
    for (int num : nums) {
        if (num % 2 == 0) {
            return num;
        }
    }
    return -1;
}


","using namespace std;

#include<cassert>
#include <iostream>
#include <vector>

int first_even(const std::vector<int>& nums) {
    for (int num : nums) {
        if (num % 2 == 0) {
            return num;
        }
    }
    // Return -1 if no even number is found
    return -1;
}
","#include<cassert>
#include <iostream>
#include <vector>
long first_even(const std::vector<long>& nums) {
    for (long num : nums) {
        if (0 == num % 2) {
            return num;
//begin to write code
","#include<cassert>
#include <iostream>
#include <vector>

long first_even(const std::vector<long>& nums) {
    for (long num : nums) {
        if (0 == num % 2) {
            return num;
        }
    }
    return -1;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

long first_even(const std::vector<long>& nums) {
    for (long num : nums) {
        if (0 == num % 2) {
            return num;
        }
    }
    return -1; // Return -1 if no even number is found
}

",1,9,1.2044339378674824,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<cassert>\n#include <iostream>\n#include <vector>\n\nlong first_even(const std::vector<long>& nums) {\n    for (long num : nums) {\n        if (0 == num % 2) {\n            return num;\n        }\n    }\n    return -1;\n}\n\n\n': [('#include<cassert>\n#include <iostream>\n#include <vector>\nlong first_even(const std::vector<int>& nums) {\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            return num;\n//begin to write code\n', 'using namespace std;\n\n#include<cassert>\n#include <iostream>\n#include <vector>\n\nlong first_even(const std::vector<int>& nums) {\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            return num;\n        }\n    }\n    // This line will never be reached since we loop through the vector\n    // but we include it just to ensure the function works correctly\n    return -1; // or throw an exception, depending on your requirements\n}\n', 'more_universe_var_type'), ('#include<cassert>\n#include <iostream>\n#include <vector>\nlong first_even(const std::vector<long>& nums) {\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            return num;\n//begin to write code\n', '\n#include<cassert>\n#include <iostream>\n#include <vector>\n\nlong first_even(const std::vector<long>& nums) {\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            return num;\n        }\n    }\n    // If no even number is found, return -1 or throw an exception based on your requirements\n    return -1; // or throw an exception\n}\n\n', 'more_universe_var_type'), ('#include<cassert>\n#include <iostream>\n#include <vector>\nlong first_even(const std::vector<long>& nums) {\n    for (int num : nums) {\n        if (0 == num % 2) {\n            return num;\n//begin to write code\n', '\n#include <cassert>\n#include <iostream>\n#include <vector>\n\nlong first_even(const std::vector<long>& nums) {\n    for (int num : nums) {\n        if (0 == num % 2) {\n            return num;\n        }\n    }\n    return -1; // Return -1 if no even number is found\n}\n\n', 'exchange_operators'), ('#include<cassert>\n#include <iostream>\n#include <vector>\nlong first_even(const std::vector<long>& nums) {\n    for (long num : nums) {\n        if (0 == num % 2) {\n            return num;\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\nlong first_even(const std::vector<long>& nums) {\n    for (long num : nums) {\n        if (0 == num % 2) {\n            return num;\n        }\n    }\n    return -1; // Return -1 if no even number is found\n}\n\n', 'more_universe_var_type')]}"
211,"#include <iostream>
#include <tuple>
#include <type_traits>
#include <cassert>
using namespace std;
// Helper template to check if all types in a tuple are the same
template <typename... Ts>
struct are_all_same;
template <typename T, typename U, typename... Ts>
struct are_all_same<T, U, Ts...> {
    static constexpr bool value = is_same<T, U>::value && are_all_same<U, Ts...>::value;
};
//begin to write code
",411,"#include <iostream>
#include <tuple>
#include <type_traits>
#include <cassert>

using namespace std;
// Helper template to check if all types in a tuple are the same
template <typename... Ts>
struct are_all_same;

template <typename T, typename U, typename... Ts>
struct are_all_same<T, U, Ts...> {
    static constexpr bool value = is_same<T, U>::value && are_all_same<U, Ts...>::value;
};

template <typename T>
struct are_all_same<T> : true_type {};

// Function to check if all elements in a tuple have the same data type
template <typename... Ts>
bool check_type(const tuple<Ts...>&) {
    return are_all_same<Ts...>::value;
}
","
#include <iostream>
#include <tuple>
#include <type_traits>
#include <cassert>

// Helper template to check if all types in a tuple are the same
template <typename... Ts>
struct are_all_same;
template <typename T, typename U, typename... Ts>
struct are_all_same<T, U, Ts...> {
    static constexpr bool value = is_same<T, U>::value && are_all_same<U, Ts...>::value;
};
//begin to write code

",,,,-2,1,0.21159443060557048,code_expression_exchange:None,0.0,0.0,
212,"#include<iostream>
#include <vector>
#include <cassert>
using namespace std;
int binary_search(const vector<int>& arr, int low, int high, int x) {
    if (high >= low) {
        int mid = (low + high) / 2;
        if ((mid == 0 || x > arr[mid - 1]) && (arr[mid] == x))
            return mid;
        else if (x > arr[mid])
            return binary_search(arr, mid + 1, high, x);
        else
            return binary_search(arr, low, mid - 1, x);
    }
//begin to write code
",478,"#include<iostream>
    

#include <vector>
#include <cassert>
using namespace std;

int binary_search(const vector<int>& arr, int low, int high, int x) {
    if (high >= low) {
        int mid = (low + high) / 2;
        if ((mid == 0 || x > arr[mid - 1]) && (arr[mid] == x))
            return mid;
        else if (x > arr[mid])
            return binary_search(arr, mid + 1, high, x);
        else
            return binary_search(arr, low, mid - 1, x);
    }
    return -1;
}
bool is_majority(const vector<int>& arr, int n, int x) {
    int i = binary_search(arr, 0, n-1, x);
    if (i == -1)
        return false;
    if ((i + n/2) <= (n -1) && arr[i + n/2] == x)
        return true;
    else
        return false;
}


","
#include<iostream>
#include <vector>
#include <cassert>
using namespace std;

int binary_search(const vector<int>& arr, int low, int high, int x) {
    if (high >= low) {
        int mid = (low + high) / 2;
        if ((mid == 0 || x > arr[mid - 1]) && (arr[mid] == x))
            return mid;
        else if (x > arr[mid])
            return binary_search(arr, mid + 1, high, x);
        else
            return binary_search(arr, low, mid - 1, x);
    }
    return -1; // Return -1 if the element is not found
}

int majority_element(vector<int>& nums) {
    int n = nums.size();
    int count = 0;
    int candidate = nums[0];

    for (int num : nums) {
        if (num == candidate) {
            count++;
        } else if (count > n / 2) {
            return candidate;
        } else if (num > candidate) {
            count = 1;
            candidate = num;
        } else {
            count--;
        }
    }

    return candidate;
}
",,,,-2,1,0.23901374340057374,code_expression_exchange:None,0.0,0.0,
213,"#include <iostream>
#include <cassert>
int count_Set_Bits(int n) {
    int count = 0;
    while (n) {
        count += n & 1;
//begin to write code
",148,"
#include <iostream>
#include <cassert>

int count_Set_Bits(int n) {
    int count = 0;
    while (n) {
        count += n & 1;
        n >>= 1;
    }
    return count;
}


","
using namespace std;
#include <iostream>
#include <cassert>

int count_Set_Bits(int n) {
    int count = 0;
    while (n) {
        count += n & 1;
        n >>= 1; // Right shift n by 1 bit
    }
    return count;
}

","#include <iostream>
#include <cassert>
int count_Set_Bits(int n) {
    int count = 0;
    while (n) {
        count += 1 & n;
//begin to write code
","
#include <iostream>
#include <cassert>

int count_Set_Bits(int n) {
    int count = 0;
    while (n) {
        count += 1 & n;
        n >>= 1;
    }
    return count;
}


","
using namespace std;

#include <iostream>
#include <cassert>

int count_Set_Bits(int n) {
    int count = 0;
    while (n) {
        count += 1 & n;
    }
    return count;
}

void test_count_Set_Bits() {
    assert(count_Set_Bits(0) == 0);
    assert(count_Set_Bits(1) == 1);
    assert(count_Set_Bits(2) == 1);
    assert(count_Set_Bits(3) == 2);
    assert(count_Set_Bits(4) == 3);
    assert(count_Set_Bits(5) == 4);
    cout << ""All tests passed successfully."" << endl;
}

",1,3,1.4516319712003072,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nint count_Set_Bits(int n) {\n    int count = 0;\n    while (n) {\n        count += 1 & n;\n        n >>= 1;\n    }\n    return count;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint count_Set_Bits(int n) {\n    int count = 0;\n    while (n) {\n        count += 1 & n;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint count_Set_Bits(int n) {\n    int count = 0;\n    while (n) {\n        count += 1 & n;\n    }\n    return count;\n}\n\nvoid test_count_Set_Bits() {\n    assert(count_Set_Bits(0) == 0);\n    assert(count_Set_Bits(1) == 1);\n    assert(count_Set_Bits(2) == 1);\n    assert(count_Set_Bits(3) == 2);\n    assert(count_Set_Bits(4) == 3);\n    assert(count_Set_Bits(5) == 4);\n    cout << ""All tests passed successfully."" << endl;\n}\n\n', 'exchange_operators')]}"
214,"#include <iostream>
#include <vector>
#include <cassert>
int find_Min(std::vector<int>& arr, int low, int high) {
    while (low < high) {
        int mid = low + (high - low) / 2;   
        if (arr[mid] == arr[high]) {
            high -= 1; 
        } else if (arr[mid] > arr[high]) {
//begin to write code
",310,"
#include <iostream>
#include <vector>
#include <cassert>

int find_Min(std::vector<int>& arr, int low, int high) {
    while (low < high) {
        int mid = low + (high - low) / 2;   
        if (arr[mid] == arr[high]) {
            high -= 1; 
        } else if (arr[mid] > arr[high]) {
            low = mid + 1; 
        } else {
            high = mid; 
        }
    }
    return arr[high];
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

int find_Min(std::vector<int>& arr, int low, int high) {
    while (low < high) {
        int mid = low + (high - low) / 2;   
        if (arr[mid] == arr[high]) {
            high -= 1; 
        } else if (arr[mid] > arr[high]) {
            // Find the minimum in the right half
            return find_Min(arr, mid + 1, high);
        } else {
            // Find the minimum in the left half
            return find_Min(arr, low, mid - 1);
        }
    }
    // If the loop completes without finding a minimum, return the first element
    return arr[0];
}

","#include <iostream>
#include <vector>
#include <cassert>
int find_Min(std::vector<int>& arr, int low, long high) {
    while (low < high) {
        int mid = low + (high - low) / 2;   
        if (arr[mid] == arr[high]) {
            high -= 1; 
        } else if (arr[mid] > arr[high]) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

int find_Min(std::vector<int>& arr, int low, long high) {
    while (low < high) {
        int mid = low + (high - low) / 2;   
        if (arr[mid] == arr[high]) {
            high -= 1; 
        } else if (arr[mid] > arr[high]) {
            low = mid + 1; 
        } else {
            high = mid; 
        }
    }
    return arr[high];
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

int find_Min(std::vector<int>& arr, int low, long high) {
    while (low < high) {
        int mid = low + (high - low) / 2;   
        if (arr[mid] == arr[high]) {
            high -= 1; 
        } else if (arr[mid] > arr[high]) {
            return arr[mid]; // Return the first occurrence of the minimum value
        }
    }
    return arr[high]; // Return the last occurrence of the minimum value
}

",1,3,2.5084054470062256,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_Min(std::vector<int>& arr, int low, long high) {\n    while (low < high) {\n        int mid = low + (high - low) / 2;   \n        if (arr[mid] == arr[high]) {\n            high -= 1; \n        } else if (arr[mid] > arr[high]) {\n            low = mid + 1; \n        } else {\n            high = mid; \n        }\n    }\n    return arr[high];\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nint find_Min(std::vector<int>& arr, int low, long high) {\n    while (low < high) {\n        int mid = low + (high - low) / 2;   \n        if (arr[mid] == arr[high]) {\n            high -= 1; \n        } else if (arr[mid] > arr[high]) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_Min(std::vector<int>& arr, int low, long high) {\n    while (low < high) {\n        int mid = low + (high - low) / 2;   \n        if (arr[mid] == arr[high]) {\n            high -= 1; \n        } else if (arr[mid] > arr[high]) {\n            return arr[mid]; // Return the first occurrence of the minimum value\n        }\n    }\n    return arr[high]; // Return the last occurrence of the minimum value\n}\n\n', 'more_universe_var_type')]}"
215,"#include <iostream>
#include <string>
#include <cassert>
std::string odd_values_string(const std::string& str) {
  std::string result = """"; 
  for (int i = 0; i < str.length(); ++i) {
    if (i % 2 == 0) {
//begin to write code
",228,"
#include <iostream>
#include <string>
#include <cassert>

std::string odd_values_string(const std::string& str) {
  std::string result = """"; 
  for (int i = 0; i < str.length(); ++i) {
    if (i % 2 == 0) {
      result += str[i];
    }
  }
  return result;
}


","
#include <iostream>
#include <string>
#include <cassert>

std::string odd_values_string(const std::string& str) {
    std::string result = """";
    for (int i = 0; i < str.length(); ++i) {
        if (i % 2 == 0) {
            result += str[i];
        }
    }
    return result;
}

","#include <iostream>
#include <string>
#include <cassert>
std::string odd_values_string(const std::string& str) {
  std::string result = """"; 
  for (long i = 0; i < str.length(); i = i + 1) {
    if (i % 2 == 0) {
//begin to write code
","
#include <iostream>
#include <string>
#include <cassert>

std::string odd_values_string(const std::string& str) {
  std::string result = """"; 
  for (long i = 0; i < str.length(); i = i + 1) {
    if (i % 2 == 0) {
      result = result + (str[i]);
    }
  }
  return result;
}


","
#include <iostream>
#include <string>
#include <cassert>

std::string odd_values_string(const std::string& str) {
  std::string result = """";
  for (long i = 0; i < str.length(); i += 2) {
    if (str[i] % 2 == 0) {
      result += str[i];
    }
  }
  return result;
}

",1,13,1.8306890408198038,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string odd_values_string(const std::string& str) {\n  std::string result = """"; \n  for (long i = 0; i < str.length(); i = i + 1) {\n    if (i % 2 == 0) {\n      result = result + (str[i]);\n    }\n  }\n  return result;\n}\n\n\n': [('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string odd_values_string(const std::string& str) {\n  std::string result = """"; \n  for (int i = 0; i < str.length(); i = i + 1) {\n    if (i % 2 == 0) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string odd_values_string(const std::string& str) {\n  std::string result = """";\n  for (int i = 0; i < str.length(); i += 2) {\n    result += str[i];\n  }\n  return result;\n}\n\nvoid test_odd_values_string() {\n  assert(odd_values_string("""") == """");\n  assert(odd_values_string(""abcdef"") == ""ab"");\n  assert(odd_values_string(""hello world!"") == ""hll wrld!"");\n  assert(odd_values_string(""1234567890"") == """");\n  cout << ""All test cases passed!"" << endl;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string odd_values_string(const std::string& str) {\n  std::string result = """"; \n  for (int i = 0; i < str.length(); i = i + 1) {\n    if (i % 2 == 0) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string odd_values_string(const std::string& str) {\n  std::string result = """"; \n  for (int i = 0; i < str.length(); i += 2) {\n    result += str[i];\n  }\n  return result;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string odd_values_string(const std::string& str) {\n  std::string result = """"; \n  for (long i = 0; i < str.length(); i = i + 1) {\n    if (i % 2 == 0) {\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string odd_values_string(const std::string& str) {\n    std::string result = """"; \n    for (long i = 0; i < str.length(); i += 2) { // Iterate over even indices\n        result += str[i]; \n    }\n    return result;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string odd_values_string(const std::string& str) {\n  std::string result = """"; \n  for (long i = 0; i < str.length(); i = i + 1) {\n    if (i % 2 == 0) {\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string odd_values_string(const std::string& str) {\n  std::string result = """";\n  for (long i = 0; i < str.length(); i += 2) {\n    result += str[i];\n  }\n  return result;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string odd_values_string(const std::string& str) {\n  std::string result = """"; \n  for (long i = 0; i < str.length(); i = i + 1) {\n    if (i % 2 == 0) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string odd_values_string(const std::string& str) {\n  std::string result = """";\n  for (long i = 0; i < str.length(); i += 2) {\n    result += str[i];\n  }\n  return result;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <string>\n#include <cassert>\nstd::string odd_values_string(const std::string& str) {\n  std::string result = """"; \n  for (long i = 0; i < str.length(); i = i + 1) {\n    if (i % 2 == 0) {\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string odd_values_string(const std::string& str) {\n  std::string result = """";\n  for (long i = 0; i < str.length(); i += 2) {\n    if (str[i] % 2 == 0) {\n      result += str[i];\n    }\n  }\n  return result;\n}\n\n', 'equal_expression_transformation')]}"
216,"#include <iostream>
#include <cassert>
int min_of_three(int a, int b, int c) {
    int smallest;
    if (a <= b && a <= c) {
        smallest = a;
    } else if (b <= a && b <= c) {
//begin to write code
",204,"
#include <iostream>
#include <cassert>

int min_of_three(int a, int b, int c) {
    int smallest;
    if (a <= b && a <= c) {
        smallest = a;
    } else if (b <= a && b <= c) {
        smallest = b;
    } else {
        smallest = c;
    }
    return smallest;
}


","
using namespace std;
#include <iostream>
#include <cassert>

int min_of_three(int a, int b, int c) {
    return min(a, min(b, c));
}

","#include <iostream>
#include <cassert>
long min_of_three(long a, int b, int c) {
    long smallest;
    if (a <= b && a <= c) {
        smallest = a;
    } else if (b <= a && b <= c) {
//begin to write code
","
#include <iostream>
#include <cassert>

long min_of_three(long a, int b, int c) {
    long smallest;
    if (a <= b && a <= c) {
        smallest = a;
    } else if (b <= a && b <= c) {
        smallest = b;
    } else {
        smallest = c;
    }
    return smallest;
}


","
using namespace std;
#include <iostream>

long min_of_three(long a, int b, int c) {
    if (a <= b && a <= c) {
        return a;
    } else if (b <= a && b <= c) {
        return b;
    } else {
        return c;
    }
}

",1,17,2.175385562578837,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nlong min_of_three(long a, int b, int c) {\n    long smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n        smallest = b;\n    } else {\n        smallest = c;\n    }\n    return smallest;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint min_of_three(int a, int b, int c) {\n    int smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nint min_of_three(int a, int b, int c) {\n    int smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n        smallest = b;\n    } else {\n        smallest = c;\n    }\n    return smallest;\n}\n\n// Test cases\nvoid test_min_of_three() {\n    assert(min_of_three(5, 3, 7) == 3);\n    assert(min_of_three(10, 10, 10) == 10);\n    assert(min_of_three(-1, -2, -3) == -3);\n    assert(min_of_three(0, 0, 0) == 0);\n    std::cout << ""All test cases passed!"" << std::endl;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cassert>\nint min_of_three(int a, int b, int c) {\n    long smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <cassert>\n\nint min_of_three(int a, int b, int c) {\n    long smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n        smallest = b;\n    } else {\n        smallest = c;\n    }\n    return smallest;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nint min_of_three(int a, int b, int c) {\n    long smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <cassert>\n\nint min_of_three(int a, int b, int c) {\n    long smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n        smallest = b;\n    } else {\n        smallest = c;\n    }\n    return smallest;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cassert>\nlong min_of_three(int a, int b, int c) {\n    long smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nlong min_of_three(int a, int b, int c) {\n    long smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n        smallest = b;\n    } else {\n        smallest = c;\n    }\n    return smallest;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nlong min_of_three(int a, int b, int c) {\n    long smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nlong min_of_three(int a, int b, int c) {\n    long smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n        smallest = b;\n    } else {\n        smallest = c;\n    }\n    return smallest;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cassert>\nlong min_of_three(int a, int b, int c) {\n    long smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nlong min_of_three(int a, int b, int c) {\n    long smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n        smallest = b;\n    } else {\n        smallest = c;\n    }\n    return smallest;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cassert>\nlong min_of_three(int a, int b, int c) {\n    long smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <cassert>\n\nlong min_of_three(int a, int b, int c) {\n    long smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n        smallest = b;\n    } else {\n        smallest = c;\n    }\n    return smallest;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cassert>\nlong min_of_three(long a, int b, int c) {\n    long smallest;\n    if (a <= b && a <= c) {\n        smallest = a;\n    } else if (b <= a && b <= c) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n\nlong min_of_three(long a, int b, int c) {\n    if (a <= b && a <= c) {\n        return a;\n    } else if (b <= a && b <= c) {\n        return b;\n    } else {\n        return c;\n    }\n}\n\n', 'more_universe_var_type')]}"
217,"#include<iostream>
#include <cassert>
using namespace std;
bool all_Bits_Set_In_The_Given_Range(int n, int l, int r) {
    int num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1));
//begin to write code
",196,"#include<iostream>
    

#include <cassert>

using namespace std;

bool all_Bits_Set_In_The_Given_Range(int n, int l, int r) {
    int num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1));
    int new_num = n & num;
    return new_num == 0;
}


","
#include<iostream>
#include <cassert>
using namespace std;

bool all_Bits_Set_In_The_Given_Range(int n, int l, int r) {
    // Start with the entire range from 0 to 32
    int num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1));

    // Iterate through each bit position from l to r
    for (int i = l; i <= r; ++i) {
        // Check if the current bit is set
        if ((num >> i) & 1) {
            return false; // If any bit is set, return false
        }
    }

    // If all bits are unset, return true
    return true;
}

",,,,-2,1,0.23898370265960694,code_expression_exchange:None,0.0,0.0,
218,"#include <vector>
#include <cassert>
#include <iostream>
std::vector<int> re_arrange_array(std::vector<int>& arr, int n) {
    int j = 0;
    for (int i = 0; i < n; i++) {
        if (arr[i] < 0) {
            int temp = arr[i];
            arr[i] = arr[j];
//begin to write code
",280,"
#include <vector>
#include <cassert>
#include <iostream>

std::vector<int> re_arrange_array(std::vector<int>& arr, int n) {
    int j = 0;
    for (int i = 0; i < n; i++) {
        if (arr[i] < 0) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            j++;
        }
    }
    return arr;
}


","
using namespace std;

#include <vector>
#include <cassert>
#include <iostream>

std::vector<int> re_arrange_array(std::vector<int>& arr, int n) {
    int j = 0;
    for (int i = 0; i < n; i++) {
        if (arr[i] < 0) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j++] = temp;
        }
    }
    return arr;
}

","#include <vector>
#include <cassert>
#include <iostream>
std::vector<int> re_arrange_array(std::vector<int>& arr, int n) {
    int j = 0;
    for (int i = 0; i < n; i = i + 1) {
        if (arr[i] < 0) {
            int temp = arr[i];
            arr[i] = arr[j];
//begin to write code
","
#include <vector>
#include <cassert>
#include <iostream>

std::vector<int> re_arrange_array(std::vector<int>& arr, int n) {
    int j = 0;
    for (int i = 0; i < n; i = i + 1) {
        if (arr[i] < 0) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            j = j + 1;
        }
    }
    return arr;
}


","
#include <vector>
#include <cassert>
#include <iostream>
std::vector<int> re_arrange_array(std::vector<int>& arr, int n) {
    int j = 0;
    for (int i = 0; i < n; i = i + 1) {
        if (arr[i] < 0) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            j++;
        }
    }
    return arr;
}

void test_re_arrange_array() {
    std::vector<int> test1 = {3, -1, 2, -4, 5};
    std::vector<int> expected1 = {-4, -1, 3, 2, 5};
    assert(re_arrange_array(test1, test1.size()) == expected1);

    std::vector<int> test2 = {-1, -2, -3, -4, -5};
    std::vector<int> expected2 = {-5, -2, -3, -4, -1};
    assert(re_arrange_array(test2, test2.size()) == expected2);

    std::vector<int>",1,3,0.5088852405548095,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <vector>\n#include <cassert>\n#include <iostream>\n\nstd::vector<int> re_arrange_array(std::vector<int>& arr, int n) {\n    int j = 0;\n    for (int i = 0; i < n; i = i + 1) {\n        if (arr[i] < 0) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            j = j + 1;\n        }\n    }\n    return arr;\n}\n\n\n': [('#include <vector>\n#include <cassert>\n#include <iostream>\nstd::vector<int> re_arrange_array(std::vector<int>& arr, int n) {\n    int j = 0;\n    for (int i = 0; i < n; i = i + 1) {\n        if (arr[i] < 0) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n//begin to write code\n', '\n#include <vector>\n#include <cassert>\n#include <iostream>\nstd::vector<int> re_arrange_array(std::vector<int>& arr, int n) {\n    int j = 0;\n    for (int i = 0; i < n; i = i + 1) {\n        if (arr[i] < 0) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            j++;\n        }\n    }\n    return arr;\n}\n\nvoid test_re_arrange_array() {\n    std::vector<int> test1 = {3, -1, 2, -4, 5};\n    std::vector<int> expected1 = {-4, -1, 3, 2, 5};\n    assert(re_arrange_array(test1, test1.size()) == expected1);\n\n    std::vector<int> test2 = {-1, -2, -3, -4, -5};\n    std::vector<int> expected2 = {-5, -2, -3, -4, -1};\n    assert(re_arrange_array(test2, test2.size()) == expected2);\n\n    std::vector<int>', 'equal_expression_transformation')]}"
219,"#include <iostream>
#include <string>
#include <cassert>
std::string replace_blank(std::string str1, char ch) {
    for (size_t i = 0; i < str1.length(); i++) {
        if (str1[i] == ' ') {
            str1[i] = ch;
//begin to write code
",239,"
#include <iostream>
#include <string>
#include <cassert>

std::string replace_blank(std::string str1, char ch) {
    for (size_t i = 0; i < str1.length(); i++) {
        if (str1[i] == ' ') {
            str1[i] = ch;
        }
    }
    return str1;
}


","
using namespace std;
#include <iostream>
#include <string>
#include <cassert>

std::string replace_blank(std::string str1, char ch) {
    for (size_t i = 0; i < str1.length(); i++) {
        if (str1[i] =='') {
            str1[i] = ch;
        }
    }
    return str1;
}

",,,,-2,1,0.19739749828974407,code_expression_exchange:None,0.0,0.0,
220,"#include<iostream>
#include <vector>
#include <cassert>
#include <algorithm>
using namespace std;
int max_sum(vector<vector<int>> tri, int n) {
    if (n > 1) {
        tri[1][1] = tri[1][1] + tri[0][0];
        tri[1][0] = tri[1][0] + tri[0][0];
    }
    for (int i = 2; i < n; i++) {
        tri[i][0] = tri[i][0] + tri[i - 1][0];
        tri[i][i] = tri[i][i] + tri[i - 1][i - 1];
        for (int j = 1; j < i; j++) {
//begin to write code
",445,"#include<iostream>
    
#include <vector>
#include <cassert>
#include <algorithm>
using namespace std;

int max_sum(vector<vector<int>> tri, int n) {
    if (n > 1) {
        tri[1][1] = tri[1][1] + tri[0][0];
        tri[1][0] = tri[1][0] + tri[0][0];
    }
    for (int i = 2; i < n; i++) {
        tri[i][0] = tri[i][0] + tri[i - 1][0];
        tri[i][i] = tri[i][i] + tri[i - 1][i - 1];
        for (int j = 1; j < i; j++) {
            if (tri[i][j] + tri[i - 1][j - 1] >= tri[i][j] + tri[i - 1][j]) {
                tri[i][j] = tri[i][j] + tri[i - 1][j - 1];
            } else {
                tri[i][j] = tri[i][j] + tri[i - 1][j];
            }
        }
    }
    return *max_element(tri[n - 1].begin(), tri[n - 1].end());
}","
#include<iostream>
#include <vector>
#include <cassert>
#include <algorithm>
using namespace std;

int max_sum(vector<vector<int>> tri, int n) {
    if (n > 1) {
        tri[1][1] = tri[1][1] + tri[0][0];
        tri[1][0] = tri[1][0] + tri[0][0];
    }
    for (int i = 2; i < n; i++) {
        tri[i][0] = tri[i][0] + tri[i - 1][0];
        tri[i][i] = tri[i][i] + tri[i - 1][i - 1];
        for (int j = 1; j < i; j++) {
            tri[i][j] = max(tri[i - 1][j], tri[i - 1][j - 1]) + tri[i][j];
        }
    }
    return tri[n - 1][n - 1];
}

",,,,-2,1,0.24188604354858398,code_expression_exchange:None,0.0,0.0,
221,"#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
#include <functional>
using namespace std;
vector<int> larg_nnum(vector<int> list1, int n) {
    sort(list1.begin(), list1.end(), greater<int>());
//begin to write code
",246,"#include<iostream>
    

#include <vector>
#include <algorithm>
#include <cassert>
#include <functional>
using namespace std;

vector<int> larg_nnum(vector<int> list1, int n) {
    sort(list1.begin(), list1.end(), greater<int>());
    vector<int> largest(list1.begin(), list1.begin() + n);
    return largest;
}","
#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
#include <functional>
using namespace std;

vector<int> larg_nnum(vector<int> list1, int n) {
    // Sort the vector in descending order
    sort(list1.rbegin(), list1.rend());
    
    // Return the first n elements
    return list1.begin(), list1.begin() + n;
}

",,,,-2,1,0.20926884412765503,code_expression_exchange:None,0.0,0.0,
222,"#include<iostream>
#include <cassert>
#include <cmath>
double lateralsurface_cylinder(double r, double h) {
    double lateralsurface = 2 * 3.1415 * r * h;
//begin to write code
",178,"#include<iostream>
    

#include <cassert>
#include <cmath>

double lateralsurface_cylinder(double r, double h) {
    double lateralsurface = 2 * 3.1415 * r * h;
    return lateralsurface;
}


","
#include<iostream>
#include <cassert>
#include <cmath>

using namespace std;

// Function to calculate the lateral surface area of a cylinder
double lateralsurface_cylinder(double r, double h) {
    double lateralsurface = 2 * 3.1415 * r * h;
    return lateralsurface;
}

",,,,-2,1,0.20753807624181111,code_expression_exchange:None,0.0,0.0,
223,"#include<iostream>
#include <cassert>
int volume_cube(int l) {
    int volume = l * l * l;
//begin to write code
",113,"#include<iostream>
    

#include <cassert>

int volume_cube(int l) {
    int volume = l * l * l;
    return volume;
}


","
using namespace std;

#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>

#include<iostream>
#include <cassert>
int volume_cube(int l) {
    int volume = l * l * l;
    return volume;
}

","#include<iostream>
#include <cassert>
int volume_cube(long l) {
    int volume = l * l * l;
//begin to write code
","#include<iostream>
    

#include <cassert>

int volume_cube(long l) {
    int volume = l * l * l;
    return volume;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<cmath> // For pow function

int volume_cube(long l) {
    int volume = l * l * l;
    return volume;
}

",1,7,0.9049055536588033,code_expression_exchange:bool2int,1.0,0.0,"{'#include<iostream>\n    \n\n#include <cassert>\n\nint volume_cube(long l) {\n    int volume = l * l * l;\n    return volume;\n}\n\n\n': [('#include<iostream>\n#include <cassert>\nint volume_cube(long l) {\n    int volume = l * l * l;\n//begin to write code\n', '\n#include<iostream>\n#include <cassert>\n\nint volume_cube(long l) {\n    return l * l * l;\n}\n\n', 'more_universe_var_type'), ('#include<iostream>\n#include <cassert>\nint volume_cube(long l) {\n    int volume = l * l * l;\n//begin to write code\n', '\nusing namespace std;\n\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<assert.h>\n\nint volume_cube(long l) {\n    int volume = l * l * l;\n    return volume;\n}\n\n', 'equal_expression_transformation'), ('#include<iostream>\n#include <cassert>\nint volume_cube(long l) {\n    int volume = l * l * l;\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<cmath> // For pow function\n\nint volume_cube(long l) {\n    int volume = l * l * l;\n    return volume;\n}\n\n', 'bool2int')]}"
224,"#include <iostream>
#include <cassert>
int even_bit_set_number(int n) {
    int count = 0;
    int res = 0;
    int temp = n;
    while (temp > 0) {
        if (count % 2 == 1) {
//begin to write code
",201,"
#include <iostream>
#include <cassert>

int even_bit_set_number(int n) {
    int count = 0;
    int res = 0;
    int temp = n;
    
    while (temp > 0) {
        if (count % 2 == 1) {
            res |= (1 << count);
        }
        count++;
        temp >>= 1;
    }
    
    return (n | res);
}


","
#include <iostream>
#include <cassert>

int even_bit_set_number(int n) {
    int count = 0;
    int res = 0;
    int temp = n;
    while (temp > 0) {
        if (count % 2 == 1) {
            res |= (1 << count);
        }
        count++;
        temp >>= 1;
    }
    return res;
}

",,,,-2,1,0.241566801071167,code_expression_exchange:None,0.0,0.0,
225,"#include <iostream>
#include <cassert>
int No_of_Triangle(int N, int K) {
    if (N < K) {
        return -1;
    } else {
        int Tri_up = 0;
//begin to write code
",169,"
#include <iostream>
#include <cassert>

int No_of_Triangle(int N, int K) {
    if (N < K) {
        return -1;
    } else {
        int Tri_up = 0;
        Tri_up = ((N - K + 1) * (N - K + 2)) / 2;
        int Tri_down = 0;
        Tri_down = ((N - 2 * K + 1) * (N - 2 * K + 2)) / 2;
        return Tri_up + Tri_down;
    }
}


","
#include <iostream>
#include <cassert>
#include <cmath>

int No_of_Triangle(int N, int K) {
    if (N < K) {
        return -1;
    } else {
        // Calculate the number of equilateral triangles that can be formed
        // using the formula N * (N - 1) / 6
        return N * (N - 1) / 6;
    }
}

",,,,-2,1,0.2246291438738505,code_expression_exchange:None,0.0,0.0,
226,"#include <iostream>
#include <vector>
#include <map>
#include <algorithm>
#include <cassert>
using namespace std;
map<pair<int, int>, int> check_occurences(vector<pair<int, int>> test_list) {
    map<pair<int, int>, int> res;
    for (auto &p : test_list) {
        if (p.first > p.second)
//begin to write code
",312,"
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>
#include <cassert>

using namespace std;

map<pair<int, int>, int> check_occurences(vector<pair<int, int>> test_list) {
    map<pair<int, int>, int> res;
    for (auto &p : test_list) {
        if (p.first > p.second)
            swap(p.first, p.second);
        res[{p.first, p.second}]++;
    }
    return res;
}


","
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>
#include <cassert>
using namespace std;

map<pair<int, int>, int> check_occurences(vector<pair<int, int>> test_list) {
    map<pair<int, int>, int> res;
    for (auto &p : test_list) {
        if (p.first > p.second)
            // Begin to write code
            ++res[p];
    }
    return res;
}

",,,,-2,1,0.21800698836644491,code_expression_exchange:None,0.0,0.0,
227,"#include <iostream>
#include <string>
#include <cassert>
int number_of_substrings(std::string str) {
    int str_len = str.length();
//begin to write code
",155,"
#include <iostream>
#include <string>
#include <cassert>

int number_of_substrings(std::string str) {
    int str_len = str.length();
    return (str_len * (str_len + 1)) / 2;
}


","
using namespace std;
#include <iostream>
#include <string>
#include <cassert>

int number_of_substrings(std::string str) {
    int str_len = str.length();
    int count = 0;
    for (int i = 0; i < str_len; ++i) {
        for (int j = i + 1; j < str_len; ++j) {
            if (!str.empty()) {
                ++count;
            }
        }
    }
    return count;
}

",,,,-2,1,0.20974935293197633,code_expression_exchange:None,0.0,0.0,
228,"#include<iostream>
#include <vector>
#include <cassert>
using namespace std;
int get_total_number_of_sequences(int m, int n) {
    vector<vector<int>> T(m+1, vector<int>(n+1, 0));
    for(int i = 0; i <= m; ++i) {
        for(int j = 0; j <= n; ++j) {
            if(i == 0 || j == 0) {
                T[i][j] = 0;
            } else if(i < j) {
                T[i][j] = 0;
//begin to write code
",398,"#include<iostream>
    

#include <vector>
#include <cassert>

using namespace std;

int get_total_number_of_sequences(int m, int n) {
    vector<vector<int>> T(m+1, vector<int>(n+1, 0));
    for(int i = 0; i <= m; ++i) {
        for(int j = 0; j <= n; ++j) {
            if(i == 0 || j == 0) {
                T[i][j] = 0;
            } else if(i < j) {
                T[i][j] = 0;
            } else if(j == 1) {
                T[i][j] = i;
            } else {
                T[i][j] = T[i-1][j] + T[i/2][j-1];
            }
        }
    }
    return T[m][n];
}


","
#include<iostream>
#include <vector>
#include <cassert>
using namespace std;

int get_total_number_of_sequences(int m, int n) {
    vector<vector<int>> T(m+1, vector<int>(n+1, 0));
    for(int i = 0; i <= m; ++i) {
        for(int j = 0; j <= n; ++j) {
            if(i == 0 || j == 0) {
                T[i][j] = 0;
            } else if(i < j) {
                T[i][j] = 0;
            } else if(i >= j && i < 2 * j) {
                T[i][j] = 1;
            }
        }
    }
    return T[m][n];
}

",,,,-2,1,0.2339765191078186,code_expression_exchange:None,0.0,0.0,
229,"#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
template<typename T>
vector<T> replace_list(vector<T> list1, vector<T> list2) {
    list1.pop_back();
//begin to write code
",202,"#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

template<typename T>
vector<T> replace_list(vector<T> list1, vector<T> list2) {
    list1.pop_back();
    list1.insert(list1.end(), list2.begin(), list2.end());
    return list1;
}","
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

template<typename T>
vector<T> replace_list(vector<T> list1, vector<T> list2) {
    // Copy the elements from list2 to list1
    list1.insert(list1.end(), list2.begin(), list2.end());
    return list1;
}

",,,,-2,1,0.22746726274490356,code_expression_exchange:None,0.0,0.0,
230,"#include<cassert>
#include <iostream>
#include <vector>
std::vector<std::vector<std::vector<char>>> array_3d(int m, int n, int o) {
    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));
    return result;
}
bool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {
    if (a.size() != b.size()) return false;
    for (size_t i = 0; i < a.size(); ++i) {
        if (a[i].size() != b[i].size()) return false;
//begin to write code
",568,"#include<cassert>
#include <iostream>
#include <vector>

std::vector<std::vector<std::vector<char>>> array_3d(int m, int n, int o) {
    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));
    return result;
}

bool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {
    if (a.size() != b.size()) return false;
    for (size_t i = 0; i < a.size(); ++i) {
        if (a[i].size() != b[i].size()) return false;
        for (size_t j = 0; j < a[i].size(); ++j) {
            if (a[i][j].size() != b[i][j].size()) return false;
            for (size_t k = 0; k < a[i][j].size(); ++k) {
                if (a[i][j][k] != b[i][j][k]) return false;
            }
        }
    }
    return true;
}


","
#include <cassert>
#include <iostream>
#include <vector>
std::vector<std::vector<std::vector<char>>> array_3d(int m, int n, int o) {
    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));
    return result;
}

bool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {
    if (a.size()!= b.size()) return false;
    for (size_t i = 0; i < a.size(); ++i) {
        if (a[i].size()!= b[i].size()) return false;
        for (size_t j = 0; j < a[i].size(); ++j) {
            if (a[i][j]!= b[i][j]) return false;
        }
    }
    return true;
}

","#include<cassert>
#include <iostream>
#include <vector>
std::vector<std::vector<std::vector<char>>> array_3d(long m, long n, long o) {
    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));
    return result;
}
bool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {
    if (b.size() != a.size()) return 0;
    for (size_t i = 0; i < a.size(); ++i) {
        if (b[i].size() != a[i].size()) return 0;
//begin to write code
","#include<cassert>
#include <iostream>
#include <vector>

std::vector<std::vector<std::vector<char>>> array_3d(long m, long n, long o) {
    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));
    return result;
}

bool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {
    if (b.size() != a.size()) return 0;
    for (size_t i = 0; i < a.size(); ++i) {
        if (b[i].size() != a[i].size()) return 0;
        for (size_t j = 0; j < a[i].size(); ++j) {
            if (b[i][j].size() != a[i][j].size()) return 0;
            for (size_t k = 0; k < a[i][j].size(); ++k) {
                if (b[i][j][k] != a[i][j][k]) return 0;
            }
        }
    }
    return 1;
}


","#include <cassert>
#include <iostream>
#include <vector>
std::vector<std::vector<std::vector<char>>> array_3d(long m, long n, long o) {
    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));
    return result;
}

bool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {
    if (b.size()!= a.size()) return 0;
    for (size_t i = 0; i < a.size(); ++i) {
        if (b[i].size()!= a[i].size()) return 0;
        for (size_t j = 0; j < a[i].size(); ++j) {
            if (b[i][j]!= a[i][j]) return 0;
        }
    }
    return true;
}
",-1,21,3.278005917867025,code_expression_exchange:more_universe_var_type,1.0,0.8041467860888782,"{""#include<cassert>\n#include <iostream>\n#include <vector>\n\nstd::vector<std::vector<std::vector<char>>> array_3d(long m, long n, long o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\n\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (b.size() != a.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (b[i].size() != a[i].size()) return 0;\n        for (size_t j = 0; j < a[i].size(); ++j) {\n            if (b[i][j].size() != a[i][j].size()) return 0;\n            for (size_t k = 0; k < a[i][j].size(); ++k) {\n                if (b[i][j][k] != a[i][j][k]) return 0;\n            }\n        }\n    }\n    return 1;\n}\n\n\n"": [(""#include<cassert>\n#include <iostream>\n#include <vector>\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, int n, int o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (a.size() != b.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i].size() != b[i].size()) return 0;\n//begin to write code\n"", ""\n#include <cassert>\n#include <iostream>\n#include <vector>\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, int n, int o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\n\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (a.size()!= b.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i].size()!= b[i].size()) return 0;\n        for (size_t j = 0; j < a[i].size(); ++j) {\n            if (a[i][j]!= b[i][j]) return 0;\n        }\n    }\n    return true;\n}\n\n"", 'bool2int'), (""#include<cassert>\n#include <iostream>\n#include <vector>\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, int n, int o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (a.size() != b.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i].size() != b[i].size()) return 0;\n//begin to write code\n"", ""\n#include <cassert>\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, int n, int o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\n\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (a.size()!= b.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i].size()!= b[i].size()) return 0;\n        for (size_t j = 0; j < a[i].size(); ++j) {\n            if (a[i][j]!= b[i][j]) return 0;\n        }\n    }\n    return 1;\n}\n\n"", 'equal_expression_transformation'), (""#include<cassert>\n#include <iostream>\n#include <vector>\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, int n, int o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (b.size() != a.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (b[i].size() != a[i].size()) return 0;\n//begin to write code\n"", ""#include<cassert>\n#include <iostream>\n#include <vector>\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, int n, int o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\n\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (b.size()!= a.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (b[i].size()!= a[i].size()) return 0;\n        for (size_t j = 0; j < b[i].size(); ++j) {\n            if (b[i][j]!= a[i][j]) return 0;\n        }\n    }\n    return true;\n}\n"", 'exchange_operators'), (""#include<cassert>\n#include <iostream>\n#include <vector>\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, int n, long o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (b.size() != a.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (b[i].size() != a[i].size()) return 0;\n//begin to write code\n"", ""\n#include <cassert>\n#include <iostream>\n#include <vector>\n#include <string>\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, int n, long o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\n\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (b.size()!= a.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (b[i].size()!= a[i].size()) return 0;\n        for (size_t j = 0; j < a[i].size(); ++j) {\n            if (b[i][j]!= a[i][j]) return 0;\n        }\n    }\n    return 1;\n}\n\n"", 'more_universe_var_type'), (""#include<cassert>\n#include <iostream>\n#include <vector>\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, long n, long o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (b.size() != a.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (b[i].size() != a[i].size()) return 0;\n//begin to write code\n"", ""\n#include <cassert>\n#include <iostream>\n#include <vector>\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, long n, long o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\n\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (b.size()!= a.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (b[i].size()!= a[i].size()) return 0;\n        for (size_t j = 0; j < a[i].size(); ++j) {\n            if (b[i][j]!= a[i][j]) return 0;\n        }\n    }\n    return true;\n}\n\n"", 'more_universe_var_type'), (""#include<cassert>\n#include <iostream>\n#include <vector>\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, long n, long o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (b.size() != a.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (b[i].size() != a[i].size()) return 0;\n//begin to write code\n"", ""#include<cassert>\n#include <iostream>\n#include <vector>\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, long n, long o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\n\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (b.size()!= a.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (b[i].size()!= a[i].size()) return 0;\n        for (size_t j = 0; j < b[i].size(); ++j) {\n            if (b[i][j]!= a[i][j]) return 0;\n        }\n    }\n    return true;\n}\n"", 'bool2int'), (""#include<cassert>\n#include <iostream>\n#include <vector>\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, long n, long o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (b.size() != a.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (b[i].size() != a[i].size()) return 0;\n//begin to write code\n"", ""#include<cassert>\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, long n, long o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\n\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (b.size()!= a.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (b[i].size()!= a[i].size()) return 0;\n        for (size_t j = 0; j < b[i].size(); ++j) {\n            if (b[i][j]!= a[i][j]) return 0;\n        }\n    }\n    return 1;\n}\n"", 'bool2int'), (""#include<cassert>\n#include <iostream>\n#include <vector>\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, long n, long o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (b.size() != a.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (b[i].size() != a[i].size()) return 0;\n//begin to write code\n"", ""\n#include <cassert>\n#include <iostream>\n#include <vector>\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, long n, long o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\n\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (b.size()!= a.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (b[i].size()!= a[i].size()) return 0;\n        for (size_t j = 0; j < a[i].size(); ++j) {\n            if (b[i][j]!= a[i][j]) return 0;\n        }\n    }\n    return true;\n}\n\n"", 'equal_expression_transformation'), (""#include<cassert>\n#include <iostream>\n#include <vector>\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, long n, long o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (b.size() != a.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (b[i].size() != a[i].size()) return 0;\n//begin to write code\n"", ""#include<cassert>\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::vector<std::vector<char>>> array_3d(int m, long n, long o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\n\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (b.size()!= a.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (b[i].size()!= a[i].size()) return 0;\n        for (size_t j = 0; j < a[i].size(); ++j) {\n            if (b[i][j]!= a[i][j]) return 0;\n        }\n    }\n    return true;\n}\n"", 'equal_expression_transformation'), (""#include<cassert>\n#include <iostream>\n#include <vector>\nstd::vector<std::vector<std::vector<char>>> array_3d(long m, long n, long o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (b.size() != a.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (b[i].size() != a[i].size()) return 0;\n//begin to write code\n"", ""#include <cassert>\n#include <iostream>\n#include <vector>\nstd::vector<std::vector<std::vector<char>>> array_3d(long m, long n, long o) {\n    std::vector<std::vector<std::vector<char>>> result(o, std::vector<std::vector<char>>(n, std::vector<char>(m, '*')));\n    return result;\n}\n\nbool compare_arrays(const std::vector<std::vector<std::vector<char>>> &a, const std::vector<std::vector<std::vector<char>>> &b) {\n    if (b.size()!= a.size()) return 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (b[i].size()!= a[i].size()) return 0;\n        for (size_t j = 0; j < a[i].size(); ++j) {\n            if (b[i][j]!= a[i][j]) return 0;\n        }\n    }\n    return true;\n}\n"", 'more_universe_var_type')]}"
231,"#include <iostream>
#include <string>
#include <cassert>
//
int count_charac(const std::string& str1) {
    int total = 0;
    for (char i : str1) {
//begin to write code
",175,"
#include <iostream>
#include <string>
#include <cassert>

//
int count_charac(const std::string& str1) {
    int total = 0;
    for (char i : str1) {
        total += 1;
    }
    return total;
}


","
using namespace std;

#include <iostream>
#include <string>
#include <cassert>

//
int count_charac(const std::string& str1) {
    int total = 0;
    for (char i : str1) {
        total += 1; // Increment total by 1 for each character
    }
    return total;
}

// Test cases
void test_count_charac() {
    assert(count_charac("""") == 0);
    assert(count_charac(""hello"") == 5);
    assert(count_charac(""world"") == 6);
    cout << ""All test cases passed!"" << endl;
}

","#include <iostream>
#include <string>
#include <cassert>
//
int count_charac(const std::string& str1) {
    long total = 0;
    for (char i : str1) {
//begin to write code
","
#include <iostream>
#include <string>
#include <cassert>

//
int count_charac(const std::string& str1) {
    long total = 0;
    for (char i : str1) {
        total += 1;
    }
    return total;
}


","
using namespace std;
#include <iostream>
#include <string>
#include <cassert>

//
int count_charac(const std::string& str1) {
    long total = 0;
    for (char i : str1) {
        total += i;
    }
    return total;
}

",1,3,0.45251301924387616,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <string>\n#include <cassert>\n\n//\nint count_charac(const std::string& str1) {\n    long total = 0;\n    for (char i : str1) {\n        total += 1;\n    }\n    return total;\n}\n\n\n': [('#include <iostream>\n#include <string>\n#include <cassert>\n//\nint count_charac(const std::string& str1) {\n    long total = 0;\n    for (char i : str1) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <cassert>\n\n//\nint count_charac(const std::string& str1) {\n    long total = 0;\n    for (char i : str1) {\n        total += i;\n    }\n    return total;\n}\n\n', 'more_universe_var_type')]}"
232,"#include <iostream>
#include <vector>
#include <unordered_map>
#include <set>
#include <cassert>
using namespace std;
template <typename T>
vector<pair<T, pair<vector<string>, int>>> sort_on_occurence(vector<pair<T, string>> const lst) {
    unordered_map<T, vector<string>> counter;
    for (const auto& item : lst) {
        counter[item.first].push_back(item.second);
    }
    vector<pair<T, pair<vector<string>, int>>> result;
    for (const auto& entry : counter) {
        set<string> unique_strings(entry.second.begin(), entry.second.end());
        result.emplace_back(entry.first, make_pair(vector<string>(unique_strings.begin(), unique_strings.end()), entry.second.size()));
    }
    return result;
}
template <typename T>
bool compare_results(const vector<pair<T, pair<vector<string>, int>>>& result, const vector<pair<T, pair<vector<string>, int>>>& expected) {
    if (result.size() != expected.size()) return false;
    set<T> result_first_elements;
    set<T> expected_first_elements;
    for (const auto& res_entry : result) {
        result_first_elements.insert(res_entry.first);
//begin to write code
",1122,"#include <iostream>
#include <vector>
#include <unordered_map>
#include <set>
#include <cassert>

using namespace std;


template <typename T>
vector<pair<T, pair<vector<string>, int>>> sort_on_occurence(vector<pair<T, string>> const lst) {
    unordered_map<T, vector<string>> counter;

    for (const auto& item : lst) {
        counter[item.first].push_back(item.second);
    }

    vector<pair<T, pair<vector<string>, int>>> result;
    for (const auto& entry : counter) {
        set<string> unique_strings(entry.second.begin(), entry.second.end());
        result.emplace_back(entry.first, make_pair(vector<string>(unique_strings.begin(), unique_strings.end()), entry.second.size()));
    }
    return result;
}

template <typename T>
bool compare_results(const vector<pair<T, pair<vector<string>, int>>>& result, const vector<pair<T, pair<vector<string>, int>>>& expected) {
    if (result.size() != expected.size()) return false;
    set<T> result_first_elements;
    set<T> expected_first_elements;

    for (const auto& res_entry : result) {
        result_first_elements.insert(res_entry.first);
    }

    for (const auto& exp_entry : expected) {
        expected_first_elements.insert(exp_entry.first);
    }

    if (result_first_elements != expected_first_elements) return false;

    for (const auto& res_entry : result) {
        bool found = false;
        for (const auto& exp_entry : expected) {
            if (res_entry.first == exp_entry.first) {
                if (res_entry.second.second != exp_entry.second.second) return false;

                set<string> res_set(res_entry.second.first.begin(), res_entry.second.first.end());
                set<string> exp_set(exp_entry.second.first.begin(), exp_entry.second.first.end());

                if (res_set != exp_set) return false;

                found = true;
                break;
            }
        }
        if (!found) return false;
    }

    return true;
}","
#include <iostream>
#include <vector>
#include <unordered_map>
#include <set>
#include <cassert>
using namespace std;

template <typename T>
vector<pair<T, pair<vector<string>, int>>> sort_on_occurence(vector<pair<T, string>> const lst) {
    unordered_map<T, vector<string>> counter;
    for (const auto& item : lst) {
        counter[item.first].push_back(item.second);
    }
    vector<pair<T, pair<vector<string>, int>>> result;
    for (const auto& entry : counter) {
        set<string> unique_strings(entry.second.begin(), entry.second.end());
        result.emplace_back(entry.first, make_pair(vector<string>(unique_strings.begin(), unique_strings.end()), entry.second.size()));
    }
    return result;
}

template <typename T>
bool compare_results(const vector<pair<T, pair<vector<string>, int>>>& result, const vector<pair<T, pair<vector<string>, int>>& expected) {
    if (result.size()!= expected.size()) return false;
    set<T> result_first_elements;
    set<T> expected_first_elements;
    for (const auto& res_entry : result) {
        result_first_elements.insert(res_entry.first);
        expected_first_elements.insert(res_entry",,,,-2,1,0.23483432133992513,code_expression_exchange:None,0.0,0.0,
233,"#include<iostream>
#include <cmath>
#include <cassert>
int next_Perfect_Square(int N) {
    int nextN = std::floor(std::sqrt(N)) + 1;
//begin to write code
",156,"#include<iostream>
    

#include <cmath>
#include <cassert>

int next_Perfect_Square(int N) {
    int nextN = std::floor(std::sqrt(N)) + 1;
    return nextN * nextN;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<cmath>
#include<assert.h>

int next_Perfect_Square(int N) {
    int nextN = std::floor(std::sqrt(N)) + 1;
    return nextN;
}

",,,,-2,1,0.24335019985834758,code_expression_exchange:None,0.0,0.0,
234,"#include<iostream>
#include <vector>
#include <climits>
#include <cassert>
using namespace std;
int max_sum(vector<int> arr, int n) {
    vector<int> MSIBS = arr;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (arr[i] > arr[j] && MSIBS[i] < MSIBS[j] + arr[i]) {
                MSIBS[i] = MSIBS[j] + arr[i];
            }
        }
    }
    vector<int> MSDBS = arr;
    for (int i = 1; i <= n; ++i) {
//begin to write code
",464,"#include<iostream>
    

#include <vector>
#include <climits>
#include <cassert>
using namespace std;

int max_sum(vector<int> arr, int n) {
    vector<int> MSIBS = arr;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (arr[i] > arr[j] && MSIBS[i] < MSIBS[j] + arr[i]) {
                MSIBS[i] = MSIBS[j] + arr[i];
            }
        }
    }

    vector<int> MSDBS = arr;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j < i; ++j) {
            if (arr[n-i] > arr[n-j] && MSDBS[n-i] < MSDBS[n-j] + arr[n-i]) {
                MSDBS[n-i] = MSDBS[n-j] + arr[n-i];
            }
        }
    }

    int max_sum = INT_MIN;
    for (int i = 0; i < n; ++i) {
        max_sum = max(max_sum, MSIBS[i] + MSDBS[i] - arr[i]);
    }

    return max_sum;
}


","
#include<iostream>
#include <vector>
#include <climits>
#include <cassert>
using namespace std;

int max_sum(vector<int> arr, int n) {
    vector<int> MSIBS = arr;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (arr[i] > arr[j] && MSIBS[i] < MSIBS[j] + arr[i]) {
                MSIBS[i] = MSIBS[j] + arr[i];
            }
        }
    }
    vector<int> MSDBS = arr;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= i; ++j) {
            if (arr[i] > arr[j] && MSDBS[j] < MSDBS[i] + arr[j]) {
                MSDBS[j] = MSDBS[i] + arr[j];
            }
        }
    }
    return *max_element(MSIBS.begin(), MSIBS.end());
}

",,,,-2,1,0.24026862780253092,code_expression_exchange:None,0.0,0.0,
235,"#include <iostream>
#include <cmath>
#include <cassert>
double babylonian_squareroot(double number) {
    if (number == 0) {
        return 0;
    }
    double g = number / 2.0;
    double g2 = g + 1;
//begin to write code
",223,"
#include <iostream>
#include <cmath>
#include <cassert>

double babylonian_squareroot(double number) {
    if (number == 0) {
        return 0;
    }
    double g = number / 2.0;
    double g2 = g + 1;
    while (fabs(g - g2) > 1e-9) {
        double n = number / g;
        g2 = g;
        g = (g + n) / 2;
    }
    return g;
}


","
using namespace std;
#include <cmath>
#include <cassert>

double babylonian_squareroot(double number) {
    if (number == 0) {
        return 0;
    }
    double g = number / 2.0;
    double g2 = g + 1;
    while (g2 - g > 0.0001) { // Use a small epsilon to avoid floating-point precision issues
        g = g2;
        g2 = g + 1;
    }
    return g;
}

",,,,-2,1,1.2194310069084167,code_expression_exchange:None,0.0,0.0,
236,"#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
int lps(string str) {
    int n = str.size();
    vector<vector<int>> L(n, vector<int>(n, 0));
    for (int i = 0; i < n; i++)
        L[i][i] = 1;
    for (int cl = 2; cl <= n; cl++) {
        for (int i = 0; i < n - cl + 1; i++) {
            int j = i + cl - 1;
            if (str[i] == str[j] && cl == 2)
//begin to write code
",410,"
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

int lps(string str) {
    int n = str.size();
    vector<vector<int>> L(n, vector<int>(n, 0));
    for (int i = 0; i < n; i++)
        L[i][i] = 1;
    for (int cl = 2; cl <= n; cl++) {
        for (int i = 0; i < n - cl + 1; i++) {
            int j = i + cl - 1;
            if (str[i] == str[j] && cl == 2)
                L[i][j] = 2;
            else if (str[i] == str[j])
                L[i][j] = L[i + 1][j - 1] + 2;
            else
                L[i][j] = max(L[i][j - 1], L[i + 1][j]);
        }
    }
    return L[0][n - 1];
}


","
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

int lps(string str) {
    int n = str.size();
    vector<vector<int>> L(n, vector<int>(n, 0));
    for (int i = 0; i < n; i++)
        L[i][i] = 1;
    for (int cl = 2; cl <= n; cl++) {
        for (int i = 0; i < n - cl + 1; i++) {
            int j = i + cl - 1;
            if (str[i] == str[j] && cl == 2) {
                L[i][j] = 2;
            } else if (str[i] == str[j]) {
                L[i][j] = L[i + 1][j - 1] + 2;
            } else {
                L[i][j] = max(L[i + 1][j], L[i][j - 1]);
            }
        }
    }
    return L[0][n - 1];
}

void test_lps() {
    assert(lps(""a"") == 1);
    assert(lps(""",,,,-2,1,0.2316644787788391,code_expression_exchange:None,0.0,0.0,
237,"#include <iostream>
#include <cassert>
#include <cmath>
// Function definition
double harmonic_sum(int n) {
    if (n < 2) {
        return 1;
//begin to write code
",165,"
#include <iostream>
#include <cassert>
#include <cmath>

// Function definition
double harmonic_sum(int n) {
    if (n < 2) {
        return 1;
    } else {
        return 1.0 / n + harmonic_sum(n - 1);
    }
}


","
using namespace std;
#include <iostream>
#include <cassert>
#include <cmath>

// Function definition
double harmonic_sum(int n) {
    if (n < 2) {
        return 1;
    }
    double sum = 0.0;
    for (int i = 1; i <= n; ++i) {
        sum += 1.0 / i;
    }
    return sum;
}

// Test function to verify the correctness of the harmonic_sum function
void test_harmonic_sum() {
    assert(harmonic_sum(1) == 1.0);
    assert(harmonic_sum(2) == 1.5);
    assert(harmonic_sum(3) == 1.6666666666666667);
    assert(harmonic_sum(4) == 2.0);
    cout << ""All test cases passed!"" << endl;
}

",,,,-2,1,0.2798159599304199,code_expression_exchange:None,0.0,0.0,
238,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
std::vector<int> intersection_array(const std::vector<int>& array_nums1, const std::vector<int>& array_nums2) {
    std::vector<int> result;
    std::copy_if(array_nums2.begin(), array_nums2.end(), std::back_inserter(result),
//begin to write code
",325,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> intersection_array(const std::vector<int>& array_nums1, const std::vector<int>& array_nums2) {
    std::vector<int> result;
    std::copy_if(array_nums2.begin(), array_nums2.end(), std::back_inserter(result),
                 [&array_nums1](int num) { return std::find(array_nums1.begin(), array_nums1.end(), num) != array_nums1.end(); });
    return result;
}


","
using namespace std;

#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
std::vector<int> intersection_array(const std::vector<int>& array_nums1, const std::vector<int>& array_nums2) {
    std::vector<int> result;
    std::copy_if(array_nums2.begin(), array_nums2.end(), std::back_inserter(result),
        [&array_nums1](int num) {
            return std::find(array_nums1.begin(), array_nums1.end(), num)!= array_nums1.end();
        });
    return result;
}

","#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
std::vector<int> intersection_array(const std::vector<int>& array_nums1, const std::vector<int>& array_nums2) {
    std::vector<int> result;
    std::copy_if(array_nums2.begin(), array_nums2.end(), std::back_inserter(result),
//begin to write code
","#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> intersection_array(const std::vector<int>& array_nums1, const std::vector<int>& array_nums2) {
    std::vector<int> result;
    std::copy_if(array_nums2.begin(), array_nums2.end(), std::back_inserter(result),
                 [&array_nums1](int num) { return array_nums1.end() != std::find(array_nums1.begin(), array_nums1.end(), num); });
    return result;
}


","#include <cassert>
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> intersection_array(const std::vector<int>& array_nums1, const std::vector<int>& array_nums2) {
    std::vector<int> result;
    std::copy_if(array_nums2.begin(), array_nums2.end(), std::back_inserter(result),
        [](int num1, int num2) { return num1 == num2; });
    return result;
}
",1,3,0.5090200781822205,code_expression_exchange:exchange_operators,1.0,0.0,"{'#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> intersection_array(const std::vector<int>& array_nums1, const std::vector<int>& array_nums2) {\n    std::vector<int> result;\n    std::copy_if(array_nums2.begin(), array_nums2.end(), std::back_inserter(result),\n                 [&array_nums1](int num) { return array_nums1.end() != std::find(array_nums1.begin(), array_nums1.end(), num); });\n    return result;\n}\n\n\n': [('#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nstd::vector<int> intersection_array(const std::vector<int>& array_nums1, const std::vector<int>& array_nums2) {\n    std::vector<int> result;\n    std::copy_if(array_nums2.begin(), array_nums2.end(), std::back_inserter(result),\n//begin to write code\n', '#include <cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> intersection_array(const std::vector<int>& array_nums1, const std::vector<int>& array_nums2) {\n    std::vector<int> result;\n    std::copy_if(array_nums2.begin(), array_nums2.end(), std::back_inserter(result),\n        [](int num1, int num2) { return num1 == num2; });\n    return result;\n}\n', 'exchange_operators')]}"
239,"#include <iostream>
#include <vector>
#include <cassert>
int count_X(const std::vector<int>& tup, int x) {
    int count = 0;
    for (int ele : tup) {
        if (ele == x) {
//begin to write code
",198,"
#include <iostream>
#include <vector>
#include <cassert>

int count_X(const std::vector<int>& tup, int x) {
    int count = 0;
    for (int ele : tup) {
        if (ele == x) {
            count++;
        }
    }
    return count;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

int count_X(const std::vector<int>& tup, int x) {
    int count = 0;
    for (int ele : tup) {
        if (ele == x) {
            count++;
        }
    }
    return count;
}

","#include <iostream>
#include <vector>
#include <cassert>
int count_X(const std::vector<long>& tup, int x) {
    long count = 0;
    for (int ele : tup) {
        if (x == ele) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

int count_X(const std::vector<long>& tup, int x) {
    long count = 0;
    for (int ele : tup) {
        if (x == ele) {
            count = count + 1;
        }
    }
    return count;
}


","
#include <iostream>
#include <vector>
#include <cassert>

int count_X(const std::vector<long>& tup, int x) {
    long count = 0;
    for (int ele : tup) {
        if (x == ele) {
            count++;
        }
    }
    return count;
}

",1,9,1.299854532877604,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_X(const std::vector<long>& tup, int x) {\n    long count = 0;\n    for (int ele : tup) {\n        if (x == ele) {\n            count = count + 1;\n        }\n    }\n    return count;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nint count_X(const std::vector<int>& tup, int x) {\n    long count = 0;\n    for (int ele : tup) {\n        if (ele == x) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_X(const std::vector<int>& tup, int x) {\n    long count = 0;\n    for (int ele : tup) {\n        if (ele == x) {\n            count++;\n        }\n    }\n    return count;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint count_X(const std::vector<int>& tup, int x) {\n    long count = 0;\n    for (int ele : tup) {\n        if (x == ele) {\n//begin to write code\n', '\nusing namespace std;\n#include <vector>\n#include <cassert>\n\nint count_X(const std::vector<int>& tup, int x) {\n    long count = 0;\n    for (int ele : tup) {\n        if (x == ele) {\n            count++;\n        }\n    }\n    return count;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint count_X(const std::vector<int>& tup, int x) {\n    long count = 0;\n    for (int ele : tup) {\n        if (x == ele) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_X(const std::vector<int>& tup, int x) {\n    long count = 0;\n    for (int ele : tup) {\n        if (x == ele) {\n            count++;\n        }\n    }\n    return count;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint count_X(const std::vector<long>& tup, int x) {\n    long count = 0;\n    for (int ele : tup) {\n        if (x == ele) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_X(const std::vector<long>& tup, int x) {\n    long count = 0;\n    for (int ele : tup) {\n        if (x == ele) {\n            count++;\n        }\n    }\n    return count;\n}\n\n', 'more_universe_var_type')]}"
240,"#include <iostream>
#include <vector>
#include <string>
#include <cassert>
std::vector<std::string> insert_element(std::vector<std::string> list, std::string element) {
    std::vector<std::string> new_list;
    for (auto &elt : list) {
        new_list.push_back(element);
//begin to write code
",296,"
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

std::vector<std::string> insert_element(std::vector<std::string> list, std::string element) {
    std::vector<std::string> new_list;
    for (auto &elt : list) {
        new_list.push_back(element);
        new_list.push_back(elt);
    }
    return new_list;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <string>
#include <cassert>

std::vector<std::string> insert_element(std::vector<std::string> list, std::string element) {
    std::vector<std::string> new_list;
    for (auto &elt : list) {
        new_list.push_back(element);
    }
    return new_list;
}

",,,,-2,1,0.2725452224413554,code_expression_exchange:None,0.0,0.0,
241,"#include <iostream>
#include <cmath>
#include <complex>
#include <cassert>
std::pair<double, double> convert(std::complex<double> numbers) {
    auto result = std::polar(numbers);
//begin to write code
",202,"
#include <iostream>
#include <cmath>
#include <complex>
#include <cassert>

std::pair<double, double> convert(std::complex<double> numbers) {
    auto result = std::polar(numbers);
    return std::make_pair(std::abs(numbers), std::arg(numbers));
}


","
#include <iostream>
#include <cmath>
#include <complex>
#include <cassert>

std::pair<double, double> convert(std::complex<double> numbers) {
    auto result = std::polar(numbers);
    return result;
}

",,,,-2,1,0.26908904711405435,code_expression_exchange:None,0.0,0.0,
242,"#include <vector>
#include <iostream>
#include <memory>
#include <cassert>
using namespace std;
class Base {
public:
    virtual ~Base() = default;
    virtual bool isInteger() const = 0;
};
class DerivedInt : public Base {
public:
    DerivedInt(int value) : value(value) {}
    bool isInteger() const override {
        return true;
    }
private:
    int value;
};
class DerivedDouble : public Base {
public:
    DerivedDouble(double value) : value(value) {}
    bool isInteger() const override {
        return false;
    }
//begin to write code
",550,"#include <vector>
#include <iostream>
#include <memory>
#include <cassert>

using namespace std;

class Base {
public:
    virtual ~Base() = default;
    virtual bool isInteger() const = 0;
};

class DerivedInt : public Base {
public:
    DerivedInt(int value) : value(value) {}
    bool isInteger() const override {
        return true;
    }
private:
    int value;
};

class DerivedDouble : public Base {
public:
    DerivedDouble(double value) : value(value) {}
    bool isInteger() const override {
        return false;
    }
private:
    double value;
};

class DerivedString : public Base {
public:
    DerivedString(const string& value) : value(value) {}
    bool isInteger() const override {
        return false;
    }
private:
    string value;
};

int count_integer(const vector<unique_ptr<Base>>& list1) {
    int ctr = 0;
    for (const auto& elem : list1) {
        if (elem->isInteger()) {
            ctr += 1;
        }
    }
    return ctr;
}","#include <vector>
#include <iostream>
#include <memory>
#include <cassert>
using namespace std;

class Base {
public:
    virtual ~Base() = default;
    virtual bool isInteger() const = 0;
};

class DerivedInt : public Base {
public:
    DerivedInt(int value) : value(value) {}
    bool isInteger() const override {
        return true;
    }
private:
    int value;
};

class DerivedDouble : public Base {
public:
    DerivedDouble(double value) : value(value) {}
    bool isInteger() const override {
        return false;
    }
};

// Complete code
",,,,-2,1,0.2179944356282552,code_expression_exchange:None,0.0,0.0,
243,"#include <iostream>
#include <regex>
#include <string>
#include <vector>
#include <cassert>
using namespace std;
vector<string> words_ae(const string& text) {
    regex re(""[ae]\\\w+"");
    vector<string> result;
    auto words_begin = sregex_iterator(text.begin(), text.end(), re);
    auto words_end = sregex_iterator();
//begin to write code
",345,"#include <iostream>
#include <regex>
#include <string>
#include <vector>
#include <cassert>

using namespace std;

vector<string> words_ae(const string& text) {
    regex re(""[ae]\\\w+"");
    vector<string> result;
    auto words_begin = sregex_iterator(text.begin(), text.end(), re);
    auto words_end = sregex_iterator();
    
    for (sregex_iterator i = words_begin; i != words_end; ++i) {
        result.push_back((*i).str());
    }
    
    return result;
}","
#include <iostream>
#include <regex>
#include <string>
#include <vector>
#include <cassert>
using namespace std;

vector<string> words_ae(const string& text) {
    regex re(""[ae]\\\w+"");
    vector<string> result;
    auto words_begin = sregex_iterator(text.begin(), text.end(), re);
    auto words_end = sregex_iterator();
    for (sregex_iterator word_begin = words_begin; word_begin!= words_end; ++word_begin) {
        string word = *word_begin;
        if (word.length() >= 2 && word[0] == 'a' || word[0] == 'e') {
            result.push_back(word);
        }
    }
    return result;
}

",,,,-2,1,0.2822349985440572,code_expression_exchange:None,0.0,0.0,
244,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
std::vector<std::vector<std::string>> combinations_colors(const std::vector<std::string>& l, int n) {
    std::vector<std::vector<std::string>> result;
    std::vector<int> indices(n, 0);
    int size = l.size();
    while (true) {
        // Add current combination
        std::vector<std::string> current;
        for (int i = 0; i < n; ++i) {
            current.push_back(l[indices[i]]);
        }
        result.push_back(current);
        // Generate next combination
        int next = n - 1;
        while (next >= 0 && indices[next] == size - 1) {
            --next;
        }
        if (next < 0) {
            break;
//begin to write code
",730,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<std::vector<std::string>> combinations_colors(const std::vector<std::string>& l, int n) {
    std::vector<std::vector<std::string>> result;
    std::vector<int> indices(n, 0);
    int size = l.size();

    while (true) {
        // Add current combination
        std::vector<std::string> current;
        for (int i = 0; i < n; ++i) {
            current.push_back(l[indices[i]]);
        }
        result.push_back(current);

        // Generate next combination
        int next = n - 1;
        while (next >= 0 && indices[next] == size - 1) {
            --next;
        }

        if (next < 0) {
            break;
        }

        int val = indices[next] + 1;
        for (int i = next; i < n; ++i) {
            indices[i] = val;
        }
    }

    return result;
}

bool compare_vectors(const std::vector<std::string>& v1, const std::vector<std::string>& v2) {
    if (v1.size() != v2.size()) {
        return false;
    }
    for (size_t i = 0; i < v1.size(); ++i) {
        if (v1[i] != v2[i]) {
            return false;
        }
    }
    return true;
}


","
#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
std::vector<std::vector<std::string>> combinations_colors(const std::vector<std::string>& l, int n) {
    std::vector<std::vector<std::string>> result;
    std::vector<int> indices(n, 0);
    int size = l.size();
    while (true) {
        // Add current combination
        std::vector<std::string> current;
        for (int i = 0; i < n; ++i) {
            current.push_back(l[indices[i]]);
        }
        result.push_back(current);
        // Generate next combination
        int next = n - 1;
        while (next >= 0 && indices[next] == size - 1) {
            --next;
        }
        if (next < 0) {
            break;
        }
        // Generate all possible combinations with repetitions
        std::vector<std::vector<std::string>> combinations;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j <= indices[i]; ++j) {
                combinations.push_back(current);
            }
       ",,,,-2,1,0.2740786751111349,code_expression_exchange:None,0.0,0.0,
245,"#include <iostream>
#include <cassert>
int count_Primes_nums(int n) {
    int ctr = 0;
    for (int num = 0; num < n; ++num) {
        if (num <= 1) {
            continue;
        }
        bool is_prime = true;
        for (int i = 2; i < num; ++i) {
            if (num % i == 0) {
//begin to write code
",307,"
#include <iostream>
#include <cassert>

int count_Primes_nums(int n) {
    int ctr = 0;
    for (int num = 0; num < n; ++num) {
        if (num <= 1) {
            continue;
        }
        bool is_prime = true;
        for (int i = 2; i < num; ++i) {
            if (num % i == 0) {
                is_prime = false;
                break;
            }
        }
        if (is_prime) {
            ctr++;
        }
    }
    return ctr;
}


","
using namespace std;
#include <iostream>
#include <cassert>

int count_Primes_nums(int n) {
    int ctr = 0;
    for (int num = 0; num < n; ++num) {
        if (num <= 1) {
            continue;
        }
        bool is_prime = true;
        for (int i = 2; i * i <= num; ++i) {
            if (num % i == 0) {
                is_prime = false;
                break;
            }
        }
        if (is_prime) {
            ++ctr;
        }
    }
    return ctr;
}

","#include <iostream>
#include <cassert>
int count_Primes_nums(int n) {
    long ctr = 0;
    for (int num = 0; num < n; ++num) {
        if (num <= 1) {
            continue;
        }
        bool is_prime = true;
        for (int i = 2; i < num; ++i) {
            if (num % i == 0) {
//begin to write code
","
#include <iostream>
#include <cassert>

int count_Primes_nums(int n) {
    long ctr = 0;
    for (int num = 0; num < n; ++num) {
        if (num <= 1) {
            continue;
        }
        bool is_prime = true;
        for (int i = 2; i < num; ++i) {
            if (num % i == 0) {
                is_prime = false;
                break;
            }
        }
        if (is_prime) {
            ctr++;
        }
    }
    return ctr;
}


","
#include <iostream>
#include <cassert>

int gcd(int a, int b) {
    while (b!= 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

",1,3,0.5630730032920838,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nint count_Primes_nums(int n) {\n    long ctr = 0;\n    for (int num = 0; num < n; ++num) {\n        if (num <= 1) {\n            continue;\n        }\n        bool is_prime = true;\n        for (int i = 2; i < num; ++i) {\n            if (num % i == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            ctr++;\n        }\n    }\n    return ctr;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint count_Primes_nums(int n) {\n    long ctr = 0;\n    for (int num = 0; num < n; ++num) {\n        if (num <= 1) {\n            continue;\n        }\n        bool is_prime = true;\n        for (int i = 2; i < num; ++i) {\n            if (num % i == 0) {\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nint gcd(int a, int b) {\n    while (b!= 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n', 'more_universe_var_type')]}"
246,"#include<iostream>
#include <utility>
#include <cassert>
std::pair<int, int> swap_numbers(int a, int b) {
    int temp = a;
    a = b;
//begin to write code
",157,"#include<iostream>
    

#include <utility>
#include <cassert>

std::pair<int, int> swap_numbers(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    return {a, b};
}


","
using namespace std;
#include <utility>
#include <cassert>

std::pair<int, int> swap_numbers(int a, int b) {
    int temp = a;
    a = b;
    return {b, a};
}

",,,,-2,1,0.22491076787312825,code_expression_exchange:None,0.0,0.0,
247,"#include<iostream>
#include <vector>
#include <cassert>
int count_odd(const std::vector<int>& array_nums) {
    int count = 0;
    for (int num : array_nums) {
        if (num % 2 != 0) {
//begin to write code
",210,"#include<iostream>
    

#include <vector>
#include <cassert>

int count_odd(const std::vector<int>& array_nums) {
    int count = 0;
    for (int num : array_nums) {
        if (num % 2 != 0) {
            count++;
        }
    }
    return count;
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<assert.h>

int count_odd(const std::vector<int>& array_nums) {
    int count = 0;
    for (int num : array_nums) {
        if (num % 2!= 0) {
            ++count;
        }
    }
    return count;
}
","#include<iostream>
#include <vector>
#include <cassert>
long count_odd(const std::vector<int>& array_nums) {
    int count = 0;
    for (int num : array_nums) {
        if (0 != num % 2) {
//begin to write code
","#include<iostream>
    

#include <vector>
#include <cassert>

long count_odd(const std::vector<int>& array_nums) {
    int count = 0;
    for (int num : array_nums) {
        if (0 != num % 2) {
            count = count + 1;
        }
    }
    return count;
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

int max_value(const std::vector<int>& vec) {
    return *std::max_element(vec.begin(), vec.end());
}
",1,7,1.0541529774665832,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\n\nlong count_odd(const std::vector<int>& array_nums) {\n    int count = 0;\n    for (int num : array_nums) {\n        if (0 != num % 2) {\n            count = count + 1;\n        }\n    }\n    return count;\n}\n\n\n': [('#include<iostream>\n#include <vector>\n#include <cassert>\nint count_odd(const std::vector<int>& array_nums) {\n    int count = 0;\n    for (int num : array_nums) {\n        if (0 != num % 2) {\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<assert.h>\n\nint count_odd(const std::vector<int>& array_nums) {\n    int count = 0;\n    for (int num : array_nums) {\n        if (num % 2!= 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include <vector>\n#include <cassert>\nlong count_odd(const std::vector<int>& array_nums) {\n    int count = 0;\n    for (int num : array_nums) {\n        if (0 != num % 2) {\n//begin to write code\n', 'using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n\n#include<iostream>\n#include <vector>\n#include <cassert>\nlong count_odd(const std::vector<int>& array_nums) {\n    int count = 0;\n    for (int num : array_nums) {\n        if (0!= num % 2) {\n            count++;\n        }\n    }\n    return count;\n}\n', 'more_universe_var_type'), ('#include<iostream>\n#include <vector>\n#include <cassert>\nlong count_odd(const std::vector<int>& array_nums) {\n    int count = 0;\n    for (int num : array_nums) {\n        if (0 != num % 2) {\n//begin to write code\n', 'using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\nint max_value(const std::vector<int>& vec) {\n    return *std::max_element(vec.begin(), vec.end());\n}\n', 'equal_expression_transformation')]}"
248,"#include<iostream>
#include <vector>
#include <tuple>
#include <algorithm>
#include <cassert>
using namespace std;
vector<tuple<int, int>> maximize_elements(const vector<tuple<int, int>>& test_tup1, const vector<tuple<int, int>>& test_tup2) {
    vector<tuple<int, int>> res;
    for(size_t i = 0; i < test_tup1.size(); ++i) {
        int first = max(get<0>(test_tup1[i]), get<0>(test_tup2[i]));
//begin to write code
",418,"#include<iostream>
    
#include <vector>
#include <tuple>
#include <algorithm>
#include <cassert>

using namespace std;

vector<tuple<int, int>> maximize_elements(const vector<tuple<int, int>>& test_tup1, const vector<tuple<int, int>>& test_tup2) {
    vector<tuple<int, int>> res;
    for(size_t i = 0; i < test_tup1.size(); ++i) {
        int first = max(get<0>(test_tup1[i]), get<0>(test_tup2[i]));
        int second = max(get<1>(test_tup1[i]), get<1>(test_tup2[i]));
        res.push_back(make_tuple(first, second));
    }
    return res;
}","
#include<iostream>
#include <vector>
#include <tuple>
#include <algorithm>
#include <cassert>
using namespace std;

vector<tuple<int, int>> maximize_elements(const vector<tuple<int, int>>& test_tup1, const vector<tuple<int, int>>& test_tup2) {
    vector<tuple<int, int>> res;
    for(size_t i = 0; i < test_tup1.size(); ++i) {
        int first = max(get<0>(test_tup1[i]), get<0>(test_tup2[i]));
        int second = max(get<1>(test_tup1[i]), get<1>(test_tup2[i]));
        res.push_back({first, second});
    }
    return res;
}

","#include<iostream>
#include <vector>
#include <tuple>
#include <algorithm>
#include <cassert>
using namespace std;
vector<tuple<int, int>> maximize_elements(const vector<tuple<int, int>>& test_tup1, const vector<tuple<int, long>>& test_tup2) {
    vector<tuple<int, int>> res;
    for(size_t i = 0; i < test_tup1.size(); ++i) {
        int first = max(get<0>(test_tup1[i]), get<0>(test_tup2[i]));
//begin to write code
","#include<iostream>
    
#include <vector>
#include <tuple>
#include <algorithm>
#include <cassert>

using namespace std;

vector<tuple<int, int>> maximize_elements(const vector<tuple<int, int>>& test_tup1, const vector<tuple<int, long>>& test_tup2) {
    vector<tuple<int, int>> res;
    for(size_t i = 0; i < test_tup1.size(); ++i) {
        int first = max(get<0>(test_tup1[i]), get<0>(test_tup2[i]));
        int second = max(get<1>(test_tup1[i]), get<1>(test_tup2[i]));
        res.push_back(make_tuple(first, second));
    }
    return res;
}","#include<iostream>
#include <vector>
#include <tuple>
#include <algorithm>
#include <cassert>
using namespace std;

vector<tuple<int, int>> maximize_elements(const vector<tuple<int, int>>& test_tup1, const vector<tuple<int, long>>& test_tup2) {
    vector<tuple<int, int>> res;
    for(size_t i = 0; i < test_tup1.size(); ++i) {
        int first = max(get<0>(test_tup1[i]), get<0>(test_tup2[i]));
        int second = max(get<1>(test_tup1[i]), get<1>(test_tup2[i]));
        res.push_back(make_tuple(first, second));
    }
    return res;
}
",1,3,0.4970220446586609,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<iostream>\n    \n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nvector<tuple<int, int>> maximize_elements(const vector<tuple<int, int>>& test_tup1, const vector<tuple<int, long>>& test_tup2) {\n    vector<tuple<int, int>> res;\n    for(size_t i = 0; i < test_tup1.size(); ++i) {\n        int first = max(get<0>(test_tup1[i]), get<0>(test_tup2[i]));\n        int second = max(get<1>(test_tup1[i]), get<1>(test_tup2[i]));\n        res.push_back(make_tuple(first, second));\n    }\n    return res;\n}': [('#include<iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nvector<tuple<int, int>> maximize_elements(const vector<tuple<int, int>>& test_tup1, const vector<tuple<int, long>>& test_tup2) {\n    vector<tuple<int, int>> res;\n    for(size_t i = 0; i < test_tup1.size(); ++i) {\n        int first = max(get<0>(test_tup1[i]), get<0>(test_tup2[i]));\n//begin to write code\n', '#include<iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<tuple<int, int>> maximize_elements(const vector<tuple<int, int>>& test_tup1, const vector<tuple<int, long>>& test_tup2) {\n    vector<tuple<int, int>> res;\n    for(size_t i = 0; i < test_tup1.size(); ++i) {\n        int first = max(get<0>(test_tup1[i]), get<0>(test_tup2[i]));\n        int second = max(get<1>(test_tup1[i]), get<1>(test_tup2[i]));\n        res.push_back(make_tuple(first, second));\n    }\n    return res;\n}\n', 'more_universe_var_type')]}"
249,"#include <iostream>
#include <cassert>
int newman_prime(int n) {
    if (n == 0 || n == 1) {
        return 1;
//begin to write code
",133,"
#include <iostream>
#include <cassert>

int newman_prime(int n) {
    if (n == 0 || n == 1) {
        return 1;
    }
    return 2 * newman_prime(n - 1) + newman_prime(n - 2);
}


","
#include <iostream>
#include <cassert>

int newman_prime(int n) {
    // Base case: 2 is the only even prime number
    if (n <= 2) {
        return 2;
    }

    // Initialize the first three numbers of the sequence
    int a = 2, b = 3, c = 5;

    // Generate the sequence up to the nth newman-shanks-williams prime number
    while (true) {
        int next = a + b + c;
        if (next > n) {
            break;
        }
        if (is_prime(next)) {
            return next;
        }
        a = b;
",,,,-2,1,0.23645225365956624,code_expression_exchange:None,0.0,0.0,
250,"#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>
std::tuple<int, int, int, int> division_elements(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {
  return std::make_tuple(
    std::get<0>(test_tup1) / std::get<0>(test_tup2),
//begin to write code
",324,"
#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>

std::tuple<int, int, int, int> division_elements(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {
  return std::make_tuple(
    std::get<0>(test_tup1) / std::get<0>(test_tup2),
    std::get<1>(test_tup1) / std::get<1>(test_tup2),
    std::get<2>(test_tup1) / std::get<2>(test_tup2),
    std::get<3>(test_tup1) / std::get<3>(test_tup2));
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>

std::tuple<int, int, int, int> division_elements(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {
  return std::make_tuple(
    std::get<0>(test_tup1) / std::get<0>(test_tup2),
    std::get<1>(test_tup1) / std::get<1>(test_tup2),
    std::get<2>(test_tup1) / std::get<2>(test_tup2),
    std::get<3>(test_tup1) / std::get<3>(test_tup2)
  );
}

","#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>
std::tuple<int, int, int, int> division_elements(const std::tuple<int, long, long, int>& test_tup1, const std::tuple<int, int, long, long>& test_tup2) {
  return std::make_tuple(
    std::get<0>(test_tup1) / std::get<0>(test_tup2),
//begin to write code
","
#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>

std::tuple<int, int, int, int> division_elements(const std::tuple<int, long, long, int>& test_tup1, const std::tuple<int, int, long, long>& test_tup2) {
  return std::make_tuple(
    std::get<0>(test_tup1) / std::get<0>(test_tup2),
    std::get<1>(test_tup1) / std::get<1>(test_tup2),
    std::get<2>(test_tup1) / std::get<2>(test_tup2),
    std::get<3>(test_tup1) / std::get<3>(test_tup2));
}


","
#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>

std::tuple<int, int, int, int> division_elements(const std::tuple<int, long, long, int>& test_tup1, const std::tuple<int, int, long, long>& test_tup2) {
  return std::make_tuple(
    std::get<0>(test_tup1) / std::get<0>(test_tup2),
    std::get<1>(test_tup1) / std::get<1>(test_tup2),
    std::get<2>(test_tup1) / std::get<2>(test_tup2),
    std::get<3>(test_tup1) / std::get<3>(test_tup2)
  );
}

",-1,21,2.966622559229533,code_expression_exchange:more_universe_var_type,1.0,0.7734586291369088,"{'\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, long, long, int>& test_tup1, const std::tuple<int, int, long, long>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n    std::get<1>(test_tup1) / std::get<1>(test_tup2),\n    std::get<2>(test_tup1) / std::get<2>(test_tup2),\n    std::get<3>(test_tup1) / std::get<3>(test_tup2));\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n    std::get<1>(test_tup1) / std::get<1>(test_tup2),\n    std::get<2>(test_tup1) / std::get<2>(test_tup2),\n    std::get<3>(test_tup1) / std::get<3>(test_tup2)\n  );\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n    std::get<1>(test_tup1) / std::get<1>(test_tup2),\n    std::get<2>(test_tup1) / std::get<2>(test_tup2),\n    std::get<3>(test_tup1) / std::get<3>(test_tup2)\n  );\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, long>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, long>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n    std::get<1>(test_tup1) / std::get<1>(test_tup2),\n    std::get<2>(test_tup1) / std::get<2>(test_tup2),\n    std::get<3>(test_tup1) / std::get<3>(test_tup2)\n  );\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, long>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, long>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n    std::get<1>(test_tup1) / std::get<1>(test_tup2),\n    std::get<2>(test_tup1) / std::get<2>(test_tup2),\n    std::get<3>(test_tup1) / std::get<3>(test_tup2)\n  );\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, long, int>& test_tup1, const std::tuple<int, int, int, long>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, long, int>& test_tup1, const std::tuple<int, int, int, long>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n    std::get<1>(test_tup1) / std::get<1>(test_tup2),\n    std::get<2>(test_tup1) / std::get<2>(test_tup2),\n    std::get<3>(test_tup1) / std::get<3>(test_tup2)\n  );\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, long, int>& test_tup1, const std::tuple<int, int, int, long>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, long, int>& test_tup1, const std::tuple<int, int, int, long>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n    std::get<1>(test_tup1) / std::get<1>(test_tup2),\n    std::get<2>(test_tup1) / std::get<2>(test_tup2),\n    std::get<3>(test_tup1) / std::get<3>(test_tup2)\n  );\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, long, int>& test_tup1, const std::tuple<int, int, int, long>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, long, int>& test_tup1, const std::tuple<int, int, int, long>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n    std::get<1>(test_tup1) / std::get<1>(test_tup2),\n    std::get<2>(test_tup1) / std::get<2>(test_tup2),\n    std::get<3>(test_tup1) / std::get<3>(test_tup2)\n  );\n}\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, long, int>& test_tup1, const std::tuple<int, int, long, long>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, long, int>& test_tup1, const std::tuple<int, int, long, long>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n    std::get<1>(test_tup1) / std::get<1>(test_tup2),\n    std::get<2>(test_tup1) / std::get<2>(test_tup2),\n    std::get<3>(test_tup1) / std::get<3>(test_tup2)\n  );\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, long, int>& test_tup1, const std::tuple<int, int, long, long>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, int, long, int>& test_tup1, const std::tuple<int, int, long, long>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n    std::get<1>(test_tup1) / std::get<1>(test_tup2),\n    std::get<2>(test_tup1) / std::get<2>(test_tup2),\n    std::get<3>(test_tup1) / std::get<3>(test_tup2)\n  );\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, long, long, int>& test_tup1, const std::tuple<int, int, long, long>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, int, int> division_elements(const std::tuple<int, long, long, int>& test_tup1, const std::tuple<int, int, long, long>& test_tup2) {\n  return std::make_tuple(\n    std::get<0>(test_tup1) / std::get<0>(test_tup2),\n    std::get<1>(test_tup1) / std::get<1>(test_tup2),\n    std::get<2>(test_tup1) / std::get<2>(test_tup2),\n    std::get<3>(test_tup1) / std::get<3>(test_tup2)\n  );\n}\n\n', 'more_universe_var_type')]}"
251,"#include<iostream>
#include <vector>
#include <cassert>
#include <utility>
template<typename T>
std::pair<std::vector<T>, std::vector<T>> split_two_parts(const std::vector<T>& list1, int L) {
    std::vector<T> first_part(list1.begin(), list1.begin() + L);
//begin to write code
",279,"#include<iostream>
    

#include <vector>
#include <cassert>
#include <utility>

template<typename T>
std::pair<std::vector<T>, std::vector<T>> split_two_parts(const std::vector<T>& list1, int L) {
    std::vector<T> first_part(list1.begin(), list1.begin() + L);
    std::vector<T> second_part(list1.begin() + L, list1.end());
    return {first_part, second_part};
}


","
#include<iostream>
#include <vector>
#include <cassert>
#include <utility>
template<typename T>
std::pair<std::vector<T>, std::vector<T>> split_two_parts(const std::vector<T>& list1, int L) {
    std::vector<T> first_part(list1.begin(), list1.begin() + L);
    std::vector<T> second_part(list1.begin() + L, list1.end());
    return {first_part, second_part};
}

","#include<iostream>
#include <vector>
#include <cassert>
#include <utility>
template<typename T>
std::pair<std::vector<T>, std::vector<T>> split_two_parts(const std::vector<T>& list1, int L) {
    std::vector<T> first_part(list1.begin(), list1.begin() + L);
//begin to write code
","#include<iostream>
    

#include <vector>
#include <cassert>
#include <utility>

template<typename T>
std::pair<std::vector<T>, std::vector<T>> split_two_parts(const std::vector<T>& list1, int L) {
    std::vector<T> first_part(list1.begin(), list1.begin() + L);
    std::vector<T> second_part(list1.begin() + L, list1.end());
    return {first_part, second_part};
}


","
#include <iostream>
#include <vector>
#include <cassert>
#include <utility>

template<typename T>
std::pair<std::vector<T>, std::vector<T>> split_two_parts(const std::vector<T>& list1, int L) {
    // Ensure the list is not empty
    assert(!list1.empty());

    // Calculate the number of elements in the first part
    int first_part_size = list1.size() - L;

    // Create two vectors, one for the first part and one for the second part
    std::vector<T> first_part_list(first_part_size);
    std::vector<T> second_part_list(list1.begin() + L, list1.end());

    return {first_part_list, second_part_list};
}

",1,5,0.7927633086840312,code_expression_exchange:bool2int,1.0,0.0,"{'#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\n#include <utility>\n\ntemplate<typename T>\nstd::pair<std::vector<T>, std::vector<T>> split_two_parts(const std::vector<T>& list1, int L) {\n    std::vector<T> first_part(list1.begin(), list1.begin() + L);\n    std::vector<T> second_part(list1.begin() + L, list1.end());\n    return {first_part, second_part};\n}\n\n\n': [('#include<iostream>\n#include <vector>\n#include <cassert>\n#include <utility>\ntemplate<typename T>\nstd::pair<std::vector<T>, std::vector<T>> split_two_parts(const std::vector<T>& list1, int L) {\n    std::vector<T> first_part(list1.begin(), list1.begin() + L);\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <cassert>\n#include <utility>\n\ntemplate<typename T>\nstd::pair<std::vector<T>, std::vector<T>> split_two_parts(const std::vector<T>& list1, int L) {\n    std::vector<T> first_part(list1.begin(), list1.begin() + L);\n    std::vector<T> second_part(list1.begin() + L, list1.end());\n    return {first_part, second_part};\n}\n\n', 'bool2int'), ('#include<iostream>\n#include <vector>\n#include <cassert>\n#include <utility>\ntemplate<typename T>\nstd::pair<std::vector<T>, std::vector<T>> split_two_parts(const std::vector<T>& list1, int L) {\n    std::vector<T> first_part(list1.begin(), list1.begin() + L);\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <utility>\n\ntemplate<typename T>\nstd::pair<std::vector<T>, std::vector<T>> split_two_parts(const std::vector<T>& list1, int L) {\n    // Ensure the list is not empty\n    assert(!list1.empty());\n\n    // Calculate the number of elements in the first part\n    int first_part_size = list1.size() - L;\n\n    // Create two vectors, one for the first part and one for the second part\n    std::vector<T> first_part_list(first_part_size);\n    std::vector<T> second_part_list(list1.begin() + L, list1.end());\n\n    return {first_part_list, second_part_list};\n}\n\n', 'bool2int')]}"
252,"#include <iostream>
#include <unordered_map>
#include <cassert>
std::unordered_map<std::string, int> merge_dict(std::unordered_map<std::string, int> d1, std::unordered_map<std::string, int> d2) {
    std::unordered_map<std::string, int> d = d1;
    for (const auto& pair : d2) {
//begin to write code
",301,"
#include <iostream>
#include <unordered_map>
#include <cassert>

std::unordered_map<std::string, int> merge_dict(std::unordered_map<std::string, int> d1, std::unordered_map<std::string, int> d2) {
    std::unordered_map<std::string, int> d = d1;
    for (const auto& pair : d2) {
        d[pair.first] = pair.second;
    }
    return d;
}


","
#include <iostream>
#include <unordered_map>
#include <cassert>

std::unordered_map<std::string, int> merge_dict(std::unordered_map<std::string, int> d1, std::unordered_map<std::string, int> d2) {
    std::unordered_map<std::string, int> d = d1;
    for (const auto& pair : d2) {
        d[pair.first] += pair.second;
    }
    return d;
}

",,,,-2,1,0.24528520504633586,code_expression_exchange:None,0.0,0.0,
253,"#include<cassert>
#include <iostream>
#include <cstdlib>
double dog_age(double h_age) {
    if (h_age < 0) {
        exit(EXIT_FAILURE);
    } else if (h_age <= 2) {
//begin to write code
",188,"#include<cassert>
#include <iostream>
#include <cstdlib>

double dog_age(double h_age) {
    if (h_age < 0) {
        exit(EXIT_FAILURE);
    } else if (h_age <= 2) {
        return h_age * 10.5;
    } else {
        return 21 + (h_age - 2) * 4;
    }
}


","
#include <cmath>
#include <cassert>
#include <iostream>
#include <cstdlib>

double dog_age(double h_age) {
    if (h_age < 0) {
        exit(EXIT_FAILURE);
    } else if (h_age <= 2) {
        return 10.5 * h_age;
    } else {
        return 24.5 * std::pow(h_age / 2, 2);
    }
}

",,,,-2,1,0.2370355486869812,code_expression_exchange:None,0.0,0.0,
254,"#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
template <typename T>
vector<vector<T>> list_split(vector<T> S, int step) {
    vector<vector<T>> result(step);
    for (int i = 0; i < step; ++i) {
        for (int j = i; j < S.size(); j += step) {
//begin to write code
",300,"
#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

template <typename T>
vector<vector<T>> list_split(vector<T> S, int step) {
    vector<vector<T>> result(step);
    for (int i = 0; i < step; ++i) {
        for (int j = i; j < S.size(); j += step) {
            result[i].push_back(S[j]);
        }
    }
    return result;
}


","
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

template <typename T>
vector<vector<T>> list_split(vector<T> S, int step) {
    vector<vector<T>> result(step);
    for (int i = 0; i < step; ++i) {
        for (int j = i; j < S.size(); j += step) {
            result[i].push_back(S[j]);
        }
    }
    return result;
}

","#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
template <typename T>
vector<vector<T>> list_split(vector<T> S, int step) {
    vector<vector<T>> result(step);
    for (long i = 0; i < step; i = i + 1) {
        for (int j = i; j < S.size(); j = j + (step)) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

template <typename T>
vector<vector<T>> list_split(vector<T> S, int step) {
    vector<vector<T>> result(step);
    for (long i = 0; i < step; i = i + 1) {
        for (int j = i; j < S.size(); j = j + (step)) {
            result[i].push_back(S[j]);
        }
    }
    return result;
}


","
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

template <typename T>
vector<vector<T>> list_split(vector<T> S, int step) {
    vector<vector<T>> result(step);
    for (long i = 0; i < step; i = i + 1) {
        for (int j = i; j < S.size(); j = j + (step)) {
            result[i].push_back(S[j]);
        }
    }
    return result;
}

void check() {
    assert(list_split({}, 1).empty());
    assert(list_split({1}, 1).size() == 1);
    assert(list_split({1, 2, 3, 4, 5}, 2).size() == 3);
    assert(list_split({1, 2, 3, 4, 5}, 3).size() == 2);
    assert(list_split({1, 2, 3, 4, 5}, 4).size() == 1);
    cout << ""All tests passed!"" << endl;
}

",1,9,1.369882833957672,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\ntemplate <typename T>\nvector<vector<T>> list_split(vector<T> S, int step) {\n    vector<vector<T>> result(step);\n    for (long i = 0; i < step; i = i + 1) {\n        for (int j = i; j < S.size(); j = j + (step)) {\n            result[i].push_back(S[j]);\n        }\n    }\n    return result;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\ntemplate <typename T>\nvector<vector<T>> list_split(vector<T> S, int step) {\n    vector<vector<T>> result(step);\n    for (int i = 0; i < step; i = i + 1) {\n        for (int j = i; j < S.size(); j = j + (step)) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\ntemplate <typename T>\nvector<vector<T>> list_split(vector<T> S, int step) {\n    vector<vector<T>> result(step);\n    for (int i = 0; i < step; i++) {\n        for (int j = i; j < S.size(); j = j + step) {\n            result[i].push_back(S[j]);\n        }\n    }\n    return result;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\ntemplate <typename T>\nvector<vector<T>> list_split(vector<T> S, int step) {\n    vector<vector<T>> result(step);\n    for (int i = 0; i < step; i = i + 1) {\n        for (int j = i; j < S.size(); j = j + (step)) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\ntemplate <typename T>\nvector<vector<T>> list_split(vector<T> S, int step) {\n    vector<vector<T>> result(step);\n    for (int i = 0; i < step; i++) {\n        for (int j = i; j < S.size(); j = j + (step)) {\n            result[i].push_back(S[j]);\n        }\n    }\n    return result;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\ntemplate <typename T>\nvector<vector<T>> list_split(vector<T> S, int step) {\n    vector<vector<T>> result(step);\n    for (int i = 0; i < step; i = i + 1) {\n        for (int j = i; j < S.size(); j = j + (step)) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\ntemplate <typename T>\nvector<vector<T>> list_split(vector<T> S, int step) {\n    vector<vector<T>> result(step);\n    for (int i = 0; i < step; i++) {\n        for (int j = i; j < S.size(); j += step) {\n            result[i].push_back(S[j]);\n        }\n    }\n    return result;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\ntemplate <typename T>\nvector<vector<T>> list_split(vector<T> S, int step) {\n    vector<vector<T>> result(step);\n    for (long i = 0; i < step; i = i + 1) {\n        for (int j = i; j < S.size(); j = j + (step)) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\ntemplate <typename T>\nvector<vector<T>> list_split(vector<T> S, int step) {\n    vector<vector<T>> result(step);\n    for (long i = 0; i < step; i = i + 1) {\n        for (int j = i; j < S.size(); j = j + (step)) {\n            result[i].push_back(S[j]);\n        }\n    }\n    return result;\n}\n\nvoid check() {\n    assert(list_split({}, 1).empty());\n    assert(list_split({1}, 1).size() == 1);\n    assert(list_split({1, 2, 3, 4, 5}, 2).size() == 3);\n    assert(list_split({1, 2, 3, 4, 5}, 3).size() == 2);\n    assert(list_split({1, 2, 3, 4, 5}, 4).size() == 1);\n    cout << ""All tests passed!"" << endl;\n}\n\n', 'more_universe_var_type')]}"
255,"#include<iostream>
#include <cassert>
int lateralsurface_cube(int l) {
    int LSA = 4 * (l * l);
//begin to write code
",120,"#include<iostream>
    

#include <cassert>

int lateralsurface_cube(int l) {
    int LSA = 4 * (l * l);
    return LSA;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<cmath>
#include<assert.h>

int lateralsurface_cube(int l) {
    int LSA = 4 * (l * l);
    return LSA;
}

","#include<iostream>
#include <cassert>
int lateralsurface_cube(long l) {
    long LSA = 4 * (l * l);
//begin to write code
","#include<iostream>
    

#include <cassert>

int lateralsurface_cube(long l) {
    long LSA = 4 * (l * l);
    return LSA;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<stdlib.h>
#include<algorithm>
#include<stdio",1,5,0.7326739827791849,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<iostream>\n    \n\n#include <cassert>\n\nint lateralsurface_cube(long l) {\n    long LSA = 4 * (l * l);\n    return LSA;\n}\n\n\n': [('#include<iostream>\n#include <cassert>\nint lateralsurface_cube(int l) {\n    long LSA = 4 * (l * l);\n//begin to write code\n', 'using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<assert.h>\n\nint lateralsurface_cube(int l) {\n    long LSA = 4 * (l * l);\n    return LSA;\n}\n', 'more_universe_var_type'), ('#include<iostream>\n#include <cassert>\nint lateralsurface_cube(long l) {\n    long LSA = 4 * (l * l);\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio', 'more_universe_var_type')]}"
256,"#include <iostream>
#include <cassert>
// 
int square_Sum(int n) {
//begin to write code
",93,"
#include <iostream>
#include <cassert>

// 
int square_Sum(int n) {
    return n * (4 * n * n - 1) / 3;
}


","
#include <iostream>
#include <cassert>

// 
int square_Sum(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i += 2) {
        sum += i * i;
    }
    return sum;
}

// 
void test_square_Sum() {
    assert(square_Sum(1) == 1);
    assert(square_Sum(2) == 10);
    assert(square_Sum(3) == 35);
    assert(square_Sum(4) == 100);
    std::cout << ""All tests passed!"" << std::endl;
}

",,,,-2,1,0.2039330999056498,code_expression_exchange:None,0.0,0.0,
257,"#include <iostream>
#include <cassert>
// Function Definition
int find_star_num(int n) {
//begin to write code
",111,"
#include <iostream>
#include <cassert>

// Function Definition
int find_star_num(int n) {
    return (6 * n * (n - 1) + 1);
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

int find_star_num(int n) {
    // Your implementation goes here
    return 0; // Placeholder, replace with actual implementation
}

",,,,-2,1,0.2141723394393921,code_expression_exchange:None,0.0,0.0,
258,"#include <iostream>
#include <cassert>
int ascii_value(char k) {
//begin to write code
",87,"
#include <iostream>
#include <cassert>

int ascii_value(char k) {
  return int(k);
}


","
#include <iostream>
#include <cassert>

int ascii_value(char k) {
    return static_cast<int>(k);
}

","#include <iostream>
#include <cassert>
long ascii_value(char k) {
//begin to write code
","
#include <iostream>
#include <cassert>

long ascii_value(char k) {
  return int(k);
}


","
using namespace std;
#include <iostream>

long ascii_value(char k) {
    return static_cast<long>(k);
}

",1,11,1.6704437335332234,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nlong ascii_value(char k) {\n  return int(k);\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint ascii_value(char k) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <cassert>\n\nint ascii_value(char k) {\n    return static_cast<int>(k);\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cassert>\nint ascii_value(char k) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <cassert>\n\nint ascii_value(char k) {\n    return static_cast<int>(k);\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cassert>\nint ascii_value(char k) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <cassert>\n\nint ascii_value(char k) {\n    return static_cast<int>(k);\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cassert>\nlong ascii_value(char k) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <cassert>\n\nlong ascii_value(char k) {\n    return static_cast<long>(k);\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nlong ascii_value(char k) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n\nlong ascii_value(char k) {\n    return static_cast<long>(k);\n}\n\n', 'exchange_operators')]}"
259,"#include <iostream>
#include <cassert>
#include <vector>
int sum_even_and_even_index(const std::vector<int>& arr, int n) {
    int sum = 0;
    for (int i = 0; i < n; i += 2) {
        if (arr[i] % 2 == 0) {
//begin to write code
",230,"
#include <iostream>
#include <cassert>
#include <vector>

int sum_even_and_even_index(const std::vector<int>& arr, int n) {
    int sum = 0;
    for (int i = 0; i < n; i += 2) {
        if (arr[i] % 2 == 0) {
            sum += arr[i];
        }
    }
    return sum;
}


","#include <iostream>
#include <cassert>
#include <vector>
int sum_even_and_even_index(const std::vector<int>& arr, int n) {
    int sum = 0;
    for (int i = 0; i < n; i += 2) {
        if (arr[i] % 2 == 0) {
            sum += arr[i];
        }
    }
    return sum;
}
","#include <iostream>
#include <cassert>
#include <vector>
int sum_even_and_even_index(const std::vector<int>& arr, int n) {
    long sum = 0;
    for (int i = 0; i < n; i = i + (2)) {
        if (arr[i] % 2 == 0) {
//begin to write code
","
#include <iostream>
#include <cassert>
#include <vector>

int sum_even_and_even_index(const std::vector<int>& arr, int n) {
    long sum = 0;
    for (int i = 0; i < n; i = i + (2)) {
        if (arr[i] % 2 == 0) {
            sum = sum + (arr[i]);
        }
    }
    return sum;
}


","
#include <iostream>
#include <cassert>
#include <vector>

int sum_even_and_even_index(const std::vector<int>& arr, int n) {
    long sum = 0;
    for (int i = 0; i < n; i = i + (2)) {
        if (arr[i] % 2 == 0) {
            sum += arr[i];
        }
    }
    return sum;
}

// Test cases
void test_sum_even_and_even_index() {
    assert(sum_even_and_even_index({1, 2, 3, 4, 5}, 5) == 6);
    assert(sum_even_and_even_index({10, 21, 32, 43, 54}, 5) == 90);
    assert(sum_even_and_even_index({100, 200, 300, 400, 500}, 5) == 2000);
    assert(sum_even_and_even_index({}, 0) == 0);
    assert(sum_even_and_even_index({1, 3, 5, 7, 9}, 5) == 0",1,9,1.3644319454828897,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n#include <vector>\n\nint sum_even_and_even_index(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (int i = 0; i < n; i = i + (2)) {\n        if (arr[i] % 2 == 0) {\n            sum = sum + (arr[i]);\n        }\n    }\n    return sum;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\n#include <vector>\nint sum_even_and_even_index(const std::vector<int>& arr, int n) {\n    int sum = 0;\n    for (int i = 0; i < n; i = i + (2)) {\n        if (arr[i] % 2 == 0) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <cassert>\n#include <vector>\n\nint sum_even_and_even_index(const std::vector<int>& arr, int n) {\n    int sum = 0;\n    for (int i = 0; i < n; i = i + (2)) {\n        if (arr[i] % 2 == 0) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cassert>\n#include <vector>\nint sum_even_and_even_index(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (int i = 0; i < n; i = i + (2)) {\n        if (arr[i] % 2 == 0) {\n//begin to write code\n', '#include <iostream>\n#include <cassert>\n#include <vector>\nint sum_even_and_even_index(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (int i = 0; i < n; i = i + (2)) {\n        if (arr[i] % 2 == 0) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\n#include <vector>\nint sum_even_and_even_index(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (int i = 0; i < n; i = i + (2)) {\n        if (arr[i] % 2 == 0) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n\nint sum_even_and_even_index(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (int i = 0; i < n; i = i + (2)) {\n        if (arr[i] % 2 == 0) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cassert>\n#include <vector>\nint sum_even_and_even_index(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (int i = 0; i < n; i = i + (2)) {\n        if (arr[i] % 2 == 0) {\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n#include <vector>\n\nint sum_even_and_even_index(const std::vector<int>& arr, int n) {\n    long sum = 0;\n    for (int i = 0; i < n; i = i + (2)) {\n        if (arr[i] % 2 == 0) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n\n// Test cases\nvoid test_sum_even_and_even_index() {\n    assert(sum_even_and_even_index({1, 2, 3, 4, 5}, 5) == 6);\n    assert(sum_even_and_even_index({10, 21, 32, 43, 54}, 5) == 90);\n    assert(sum_even_and_even_index({100, 200, 300, 400, 500}, 5) == 2000);\n    assert(sum_even_and_even_index({}, 0) == 0);\n    assert(sum_even_and_even_index({1, 3, 5, 7, 9}, 5) == 0', 'equal_expression_transformation')]}"
260,"#include <iostream>
#include <cassert>
// 
int even_Power_Sum(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
//begin to write code
",149,"
#include <iostream>
#include <cassert>

// 
int even_Power_Sum(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        int j = 2 * i;
        sum += j * j * j * j * j;
    }
    return sum;
}


","
#include <iostream>
#include <cassert>

// 
int even_Power_Sum(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        if (i % 2 == 0) {
            sum += static_cast<int>(std::pow(i, 5));
        }
    }
    return sum;
}

",,,,-2,1,0.2410004258155823,code_expression_exchange:None,0.0,0.0,
261,"#include<iostream>
#include <vector>
#include <tuple>
#include <cassert>
using namespace std;
vector<int> rear_extract(vector<tuple<int, string, int>> test_list) {
    vector<int> res;
    for (auto& lis : test_list) {
//begin to write code
",241,"#include<iostream>
    
#include <vector>
#include <tuple>
#include <cassert>

using namespace std;

vector<int> rear_extract(vector<tuple<int, string, int>> test_list) {
    vector<int> res;
    for (auto& lis : test_list) {
        res.push_back(get<2>(lis));
    }
    return res;
}","#include<iostream>
#include <vector>
#include <tuple>
#include <cassert>
using namespace std;

vector<int> rear_extract(vector<tuple<int, string, int>> test_list) {
    vector<int> res;
    for (auto& lis : test_list) {
        if (lis.size() == 3) { // Ensure we only process tuples with exactly three elements
            res.push_back(lis[2]); // Extract the third element from the tuple
        }
    }
    return res;
}
",,,,-2,1,0.19617465337117512,code_expression_exchange:None,0.0,0.0,
262,"#include <iostream>
#include <tuple>
#include <cassert>
std::tuple<int, int, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {
    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),
//begin to write code
",289,"
#include <iostream>
#include <tuple>
#include <cassert>

std::tuple<int, int, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {
    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),
                           std::get<1>(test_tup1) - std::get<1>(test_tup2),
                           std::get<2>(test_tup1) - std::get<2>(test_tup2));
}


","#include <iostream>
#include <tuple>
#include <cassert>
std::tuple<int, int, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {
    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),
                         std::get<1>(test_tup1) - std::get<1>(test_tup2),
                         std::get<2>(test_tup1) - std::get<2>(test_tup2));
}
","#include <iostream>
#include <tuple>
#include <cassert>
std::tuple<long, long, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<long, int, int>& test_tup2) {
    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),
//begin to write code
","
#include <iostream>
#include <tuple>
#include <cassert>

std::tuple<long, long, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<long, int, int>& test_tup2) {
    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),
                           std::get<1>(test_tup1) - std::get<1>(test_tup2),
                           std::get<2>(test_tup1) - std::get<2>(test_tup2));
}


","
#include <iostream>
#include <tuple>
#include <cassert>

std::tuple<long, long, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<long, int, int>& test_tup2) {
    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),
        std::get<1>(test_tup1) - std::get<1>(test_tup2),
        std::get<2>(test_tup1) - std::get<2>(test_tup2));
}

",-1,21,3.1636722246805826,code_expression_exchange:equal_expression_transformation,1.0,0.7740692070837936,"{'\n#include <iostream>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<long, long, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<long, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n                           std::get<1>(test_tup1) - std::get<1>(test_tup2),\n                           std::get<2>(test_tup1) - std::get<2>(test_tup2));\n}\n\n\n': [('#include <iostream>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n        std::get<1>(test_tup1) - std::get<1>(test_tup2),\n        std::get<2>(test_tup1) - std::get<2>(test_tup2));\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <tuple>\n#include <cassert>\nstd::tuple<long, int, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n//begin to write code\n', '\n#include <iostream>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<long, int, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n                           std::get<1>(test_tup1) - std::get<1>(test_tup2),\n                           std::get<2>(test_tup1) - std::get<2>(test_tup2));\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <tuple>\n#include <cassert>\nstd::tuple<long, int, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n//begin to write code\n', '\n#include <iostream>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<long, int, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n                            std::get<1>(test_tup1) - std::get<1>(test_tup2),\n                            std::get<2>(test_tup1) - std::get<2>(test_tup2));\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <tuple>\n#include <cassert>\nstd::tuple<long, int, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n//begin to write code\n', '\n#include <iostream>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<long, int, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n                           std::get<1>(test_tup1) - std::get<1>(test_tup2),\n                           std::get<2>(test_tup1) - std::get<2>(test_tup2));\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <tuple>\n#include <cassert>\nstd::tuple<long, long, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n//begin to write code\n', '\n#include <iostream>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<long, long, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n                           std::get<1>(test_tup1) - std::get<1>(test_tup2),\n                           std::get<2>(test_tup1) - std::get<2>(test_tup2));\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <tuple>\n#include <cassert>\nstd::tuple<long, long, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n//begin to write code\n', '\n#include <iostream>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<long, long, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n                         std::get<1>(test_tup1) - std::get<1>(test_tup2),\n                         std::get<2>(test_tup1) - std::get<2>(test_tup2));\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <tuple>\n#include <cassert>\nstd::tuple<long, long, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n//begin to write code\n', '\n#include <iostream>\n#include <tuple>\n#include <cassert>\n#include <algorithm>\n\nstd::tuple<long, long, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<int, int, int>& test_tup2) {\n    // Extract elements from the tuples\n    auto [x1, y1, z1] = test_tup1;\n    auto [x2, y2, z2] = test_tup2;\n\n    // Perform subtraction\n    long result_x = x1 - x2;\n    long result_y = y1 - y2;\n    long result_z = z1 - z2;\n\n    // Return the result as a tuple\n    return std::make_tuple(result_x, result_y, result_z);\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <tuple>\n#include <cassert>\nstd::tuple<long, long, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<long, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n//begin to write code\n', '\n#include <iostream>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<long, long, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<long, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n                         std::get<1>(test_tup1) - std::get<1>(test_tup2),\n                         std::get<2>(test_tup1) - std::get<2>(test_tup2));\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <tuple>\n#include <cassert>\nstd::tuple<long, long, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<long, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n//begin to write code\n', '#include <iostream>\n#include <tuple>\n#include <cassert>\nstd::tuple<long, long, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<long, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n                         std::get<1>(test_tup1) - std::get<1>(test_tup2),\n                         std::get<2>(test_tup1) - std::get<2>(test_tup2));\n}\n', 'exchange_operators'), ('#include <iostream>\n#include <tuple>\n#include <cassert>\nstd::tuple<long, long, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<long, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n//begin to write code\n', '\n#include <iostream>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<long, long, int> substract_elements(const std::tuple<int, int, int>& test_tup1, const std::tuple<long, int, int>& test_tup2) {\n    return std::make_tuple(std::get<0>(test_tup1) - std::get<0>(test_tup2),\n        std::get<1>(test_tup1) - std::get<1>(test_tup2),\n        std::get<2>(test_tup1) - std::get<2>(test_tup2));\n}\n\n', 'equal_expression_transformation')]}"
263,"#include<cassert>
#include <iostream>
int even_binomial_Coeff_Sum(int n) {
//begin to write code
",97,"#include<cassert>
#include <iostream>

int even_binomial_Coeff_Sum(int n) {
    return (1 << (n - 1));
}


","
#include <cassert>
#include <iostream>

int even_binomial_Coeff_Sum(int n) {
    if (n < 0) {
        throw std::invalid_argument(""Input must be non-negative."");
    }

    int sum = 0;
    for (int i = 0; i < n; i += 2) {
        sum += C(2 * i, i);
    }

    return sum;
}

",,,,-2,1,0.2329978386561076,code_expression_exchange:None,0.0,0.0,
264,"#include<cassert>
#include <iostream>
#include <vector>
#include <cmath> // for ceil
using namespace std;
int get_Position(vector<int>& a, int n, int m) {
    for (int i = 0; i < n; ++i) {
        a[i] = (a[i] / m + (a[i] % m != 0));
    }
    int result = -1, maxx = -1;
    for (int i = n - 1; i >= 0; --i) {
//begin to write code
",333,"#include<cassert>
#include <iostream>
#include <vector>
#include <cmath> // for ceil
using namespace std;

int get_Position(vector<int>& a, int n, int m) {
    for (int i = 0; i < n; ++i) {
        a[i] = (a[i] / m + (a[i] % m != 0));
    }
    int result = -1, maxx = -1;
    for (int i = n - 1; i >= 0; --i) {
        if (maxx < a[i]) {
            maxx = a[i];
            result = i;
        }
    }
    return result + 1;
}


","#include<cassert>
#include <iostream>
#include <vector>
#include <cmath> // for ceil
using namespace std;

int get_Position(vector<int>& a, int n, int m) {
    for (int i = 0; i < n; ++i) {
        a[i] = (a[i] / m + (a[i] % m!= 0));
    }
    int result = -1, maxx = -1;
    for (int i = n - 1; i >= 0; --i) {
        if (a[i] == maxx) {
            result = i;
        } else if (a[i] > maxx) {
            maxx = a[i];
            result = i;
        }
    }
    return result;
}
",,,,-2,1,0.2082882563273112,code_expression_exchange:None,0.0,0.0,
265,"#include <iostream>
#include <cassert>
#include <cmath>
double volume_cylinder(double r, double h) {
    double volume = 3.1415 * r * r * h;
//begin to write code
",163,"
#include <iostream>
#include <cassert>
#include <cmath>

double volume_cylinder(double r, double h) {
    double volume = 3.1415 * r * r * h;
    return volume;
}


","
using namespace std;
#include <iostream>
#include <cassert>
#include <cmath>

double volume_cylinder(double r, double h) {
    double volume = 3.1415 * r * r * h;
    return volume;
}

",,,,-2,1,0.19962904453277588,code_expression_exchange:None,0.0,0.0,
266,"#include<iostream>
#include <map>
#include <string>
#include <cassert>
using namespace std;
map<string, int> dict_filter(const map<string, int>& input_dict, int n) {
    map<string, int> result;
    for (auto const& pair : input_dict) {
        if (pair.second >= n) {
//begin to write code
",291,"#include<iostream>
    

#include <map>
#include <string>
#include <cassert>

using namespace std;

map<string, int> dict_filter(const map<string, int>& input_dict, int n) {
    map<string, int> result;
    for (auto const& pair : input_dict) {
        if (pair.second >= n) {
            result[pair.first] = pair.second;
        }
    }
    return result;
}


","
#include <iostream>
#include <map>
#include <string>
#include <cassert>
using namespace std;

map<string, int> dict_filter(const map<string, int>& input_dict, int n) {
    map<string, int> result;
    for (auto const& pair : input_dict) {
        if (pair.second >= n) {
            result[pair.first] = pair.second;
        }
    }
    return result;
}

","#include<iostream>
#include <map>
#include <string>
#include <cassert>
using namespace std;
map<string, int> dict_filter(const map<string, long>& input_dict, int n) {
    map<string, int> result;
    for (auto const& pair : input_dict) {
        if (pair.second >= n) {
//begin to write code
","#include<iostream>
    

#include <map>
#include <string>
#include <cassert>

using namespace std;

map<string, int> dict_filter(const map<string, long>& input_dict, int n) {
    map<string, int> result;
    for (auto const& pair : input_dict) {
        if (pair.second >= n) {
            result[pair.first] = pair.second;
        }
    }
    return result;
}


","
#include<iostream>
#include <map>
#include <string>
#include <cassert>
using namespace std;

map<string, int> dict_filter(const map<string, long>& input_dict, int n) {
    map<string, int> result;
    for (auto const& pair : input_dict) {
        if (pair.second >= n) {
            result[pair.first] = pair.second;
        }
    }
    return result;
}

",1,3,0.4907056212425232,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<iostream>\n    \n\n#include <map>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nmap<string, int> dict_filter(const map<string, long>& input_dict, int n) {\n    map<string, int> result;\n    for (auto const& pair : input_dict) {\n        if (pair.second >= n) {\n            result[pair.first] = pair.second;\n        }\n    }\n    return result;\n}\n\n\n': [('#include<iostream>\n#include <map>\n#include <string>\n#include <cassert>\nusing namespace std;\nmap<string, int> dict_filter(const map<string, long>& input_dict, int n) {\n    map<string, int> result;\n    for (auto const& pair : input_dict) {\n        if (pair.second >= n) {\n//begin to write code\n', '\n#include<iostream>\n#include <map>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nmap<string, int> dict_filter(const map<string, long>& input_dict, int n) {\n    map<string, int> result;\n    for (auto const& pair : input_dict) {\n        if (pair.second >= n) {\n            result[pair.first] = pair.second;\n        }\n    }\n    return result;\n}\n\n', 'more_universe_var_type')]}"
267,"#include <iostream>
#include <tuple>
#include <vector>
#include <cassert>
#include <type_traits>
using namespace std;
template <size_t Index, typename Tuple>
int count_first_elements_helper(const Tuple& t, true_type) {
    return 0;
}
template <size_t Index, typename Tuple>
int count_first_elements_helper(const Tuple& t, false_type) {
//begin to write code
",359,"#include <iostream>
#include <tuple>
#include <vector>
#include <cassert>
#include <type_traits>

using namespace std;

template <size_t Index, typename Tuple>
int count_first_elements_helper(const Tuple& t, true_type) {
    return 0;
}

template <size_t Index, typename Tuple>
int count_first_elements_helper(const Tuple& t, false_type) {
    return 1 + count_first_elements_helper<Index + 1>(t, is_same<typename decay<typename tuple_element<Index + 1, Tuple>::type>::type, vector<int>>());
}
template <typename... Args>
int count_first_elements(const tuple<Args...>& t) {
    return count_first_elements_helper<0>(t, is_same<typename decay<typename tuple_element<0, tuple<Args...>>::type>::type, vector<int>>());
}","
#include <iostream>
#include <tuple>
#include <vector>
#include <cassert>
#include <type_traits>
using namespace std;
template <size_t Index, typename Tuple>
int count_first_elements_helper(const Tuple& t, true_type) {
    return 0;
}
template <size_t Index, typename Tuple>
int count_first_elements_helper(const Tuple& t, false_type) {
    if (t.index() == Index) {
        return 1;
    }
    return count_first_elements_helper(t.sub_tuple(), true_type()) + count_first_elements_helper(t.sub_tuple(), false_type());
}

int count_first_elements(const tuple<int, int>& t) {
    return count_first_elements_helper(t, true_type());
}

",,,,-2,1,0.21055975755055745,code_expression_exchange:None,0.0,0.0,
268,"#include<iostream>
#include <cassert>
//
int is_num_decagonal(int n) {
//begin to write code
",97,"#include<iostream>
    

#include <cassert>

//
int is_num_decagonal(int n) {
    return 4 * n * n - 3 * n;
}


","
#include<iostream>
#include <cassert>

//
int is_num_decagonal(int n) {
    return n * (n + 1) / 6;
}

",,,,-2,1,0.2291171113650004,code_expression_exchange:None,0.0,0.0,
269,"#include <iostream>
#include <vector>
#include <cassert>
bool sequential_search(const std::vector<int>& dlist, int item, int& pos) {
    pos = 0;
    while (pos < dlist.size()) {
        if (dlist[pos] == item) {
            return true;
//begin to write code
",260,"
#include <iostream>
#include <vector>
#include <cassert>

bool sequential_search(const std::vector<int>& dlist, int item, int& pos) {
    pos = 0;
    while (pos < dlist.size()) {
        if (dlist[pos] == item) {
            return true;
        }
        pos++;
    }
    return false;
}


","#include <iostream>
#include <vector>
#include <cassert>

bool sequential_search(const std::vector<int>& dlist, int item, int& pos) {
    pos = 0;
    while (pos < dlist.size()) {
        if (dlist[pos] == item) {
            return true;
        }
        pos++;
    }
    return false;
}
","#include <iostream>
#include <vector>
#include <cassert>
bool sequential_search(const std::vector<int>& dlist, int item, int& pos) {
    pos = 0;
    while (pos < dlist.size()) {
        if (item == dlist[pos]) {
            return true;
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

bool sequential_search(const std::vector<int>& dlist, int item, int& pos) {
    pos = 0;
    while (pos < dlist.size()) {
        if (item == dlist[pos]) {
            return true;
        }
        pos++;
    }
    return false;
}


","
**Created Answer**:
",1,3,0.4455602010091146,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool sequential_search(const std::vector<int>& dlist, int item, int& pos) {\n    pos = 0;\n    while (pos < dlist.size()) {\n        if (item == dlist[pos]) {\n            return true;\n        }\n        pos++;\n    }\n    return false;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nbool sequential_search(const std::vector<int>& dlist, int item, int& pos) {\n    pos = 0;\n    while (pos < dlist.size()) {\n        if (item == dlist[pos]) {\n            return true;\n//begin to write code\n', '\n**Created Answer**:\n', 'exchange_operators')]}"
270,"#include <iostream>
#include <vector>
#include <set>
#include <cassert>
bool all_unique(const std::vector<int>& test_list) {
    std::set<int> unique_elements(test_list.begin(), test_list.end());
    if (test_list.size() > unique_elements.size()) {
//begin to write code
",271,"
#include <iostream>
#include <vector>
#include <set>
#include <cassert>

bool all_unique(const std::vector<int>& test_list) {
    std::set<int> unique_elements(test_list.begin(), test_list.end());
    if (test_list.size() > unique_elements.size()) {
        return false;
    }
    return true;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <set>
#include <cassert>

bool all_unique(const std::vector<int>& test_list) {
    std::set<int> unique_elements(test_list.begin(), test_list.end());
    return test_list.size() == unique_elements.size();
}

","#include <iostream>
#include <vector>
#include <set>
#include <cassert>
bool all_unique(const std::vector<long>& test_list) {
    std::set<long> unique_elements(test_list.begin(), test_list.end());
    if (test_list.size() > unique_elements.size()) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <set>
#include <cassert>

bool all_unique(const std::vector<long>& test_list) {
    std::set<long> unique_elements(test_list.begin(), test_list.end());
    if (test_list.size() > unique_elements.size()) {
        return 0;
    }
    return 1;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <set>
#include <cassert>

bool all_unique(const std::vector<long>& test_list) {
    std::set<long> unique_elements(test_list.begin(), test_list.end());
    return unique_elements.size() == test_list.size();
}

",-1,21,3.0835344990094504,code_expression_exchange:exchange_operators,1.0,0.6382702513756817,"{'\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool all_unique(const std::vector<long>& test_list) {\n    std::set<long> unique_elements(test_list.begin(), test_list.end());\n    if (test_list.size() > unique_elements.size()) {\n        return 0;\n    }\n    return 1;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool all_unique(const std::vector<int>& test_list) {\n    std::set<int> unique_elements(test_list.begin(), test_list.end());\n    if (test_list.size() > unique_elements.size()) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool all_unique(const std::vector<int>& test_list) {\n    std::set<int> unique_elements(test_list.begin(), test_list.end());\n    return test_list.size() == unique_elements.size();\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool all_unique(const std::vector<int>& test_list) {\n    std::set<int> unique_elements(test_list.begin(), test_list.end());\n    if (test_list.size() > unique_elements.size()) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool all_unique(const std::vector<int>& test_list) {\n    std::set<int> unique_elements(test_list.begin(), test_list.end());\n    return test_list.size() == unique_elements.size();\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool all_unique(const std::vector<int>& test_list) {\n    std::set<int> unique_elements(test_list.begin(), test_list.end());\n    if (test_list.size() > unique_elements.size()) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool all_unique(const std::vector<int>& test_list) {\n    std::set<int> unique_elements(test_list.begin(), test_list.end());\n    return test_list.size() == unique_elements.size();\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool all_unique(const std::vector<int>& test_list) {\n    std::set<long> unique_elements(test_list.begin(), test_list.end());\n    if (test_list.size() > unique_elements.size()) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool all_unique(const std::vector<int>& test_list) {\n    std::set<long> unique_elements(test_list.begin(), test_list.end());\n    return unique_elements.size() == test_list.size();\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool all_unique(const std::vector<long>& test_list) {\n    std::set<long> unique_elements(test_list.begin(), test_list.end());\n    if (test_list.size() > unique_elements.size()) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool all_unique(const std::vector<long>& test_list) {\n    std::set<long> unique_elements(test_list.begin(), test_list.end());\n    return unique_elements.size() == test_list.size();\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool all_unique(const std::vector<long>& test_list) {\n    std::set<long> unique_elements(test_list.begin(), test_list.end());\n    if (test_list.size() > unique_elements.size()) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool all_unique(const std::vector<long>& test_list) {\n    std::set<long> unique_elements(test_list.begin(), test_list.end());\n    return unique_elements.size() == test_list.size();\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool all_unique(const std::vector<long>& test_list) {\n    std::set<long> unique_elements(test_list.begin(), test_list.end());\n    if (test_list.size() > unique_elements.size()) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool all_unique(const std::vector<long>& test_list) {\n    std::set<long> unique_elements(test_list.begin(), test_list.end());\n    return test_list.size() == unique_elements.size();\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool all_unique(const std::vector<long>& test_list) {\n    std::set<long> unique_elements(test_list.begin(), test_list.end());\n    if (test_list.size() > unique_elements.size()) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool all_unique(const std::vector<long>& test_list) {\n    std::set<long> unique_elements(test_list.begin(), test_list.end());\n    return unique_elements.size() == test_list.size();\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool all_unique(const std::vector<long>& test_list) {\n    std::set<long> unique_elements(test_list.begin(), test_list.end());\n    if (test_list.size() > unique_elements.size()) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool all_unique(const std::vector<long>& test_list) {\n    std::set<long> unique_elements(test_list.begin(), test_list.end());\n    return unique_elements.size() == test_list.size();\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\nbool all_unique(const std::vector<long>& test_list) {\n    std::set<long> unique_elements(test_list.begin(), test_list.end());\n    if (test_list.size() > unique_elements.size()) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nbool all_unique(const std::vector<long>& test_list) {\n    std::set<long> unique_elements(test_list.begin(), test_list.end());\n    return unique_elements.size() == test_list.size();\n}\n\n', 'exchange_operators')]}"
271,"#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> sub_list(const std::vector<int>& nums1, const std::vector<int>& nums2) {
    std::vector<int> result;
    for (size_t i = 0; i < nums1.size(); ++i) {
//begin to write code
",246,"
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> sub_list(const std::vector<int>& nums1, const std::vector<int>& nums2) {
    std::vector<int> result;
    for (size_t i = 0; i < nums1.size(); ++i) {
        result.push_back(nums1[i] - nums2[i]);
    }
    return result;
}


","
#include <iostream>
#include <vector>
#include <cassert>
#include <map>

std::vector<int> sub_list(const std::vector<int>& nums1, const std::vector<int>& nums2) {
    std::map<int, int> num_map;
    for (int num : nums1) {
        num_map[num]++;
    }
    for (int num : nums2) {
        if (num_map.find(num)!= num_map.end()) {
            num_map[num]--;
            if (num_map[num] == 0) {
                num_map.erase(num);
            }
        } else {
            continue;
        }
    }
    std::vector<int> result;
    for (const auto& pair : num_map) {
        result.push_back(pair.first);
    }
    return result;
}

",,,,-2,1,0.2471482475598653,code_expression_exchange:None,0.0,0.0,
272,"#include <iostream>
#include <cassert>
bool validate(int n) {
    for (int i = 0; i < 10; i++) {
        int temp = n;
        int count = 0;
        while (temp) {
            if (temp % 10 == i) {
                count++;
            }
//begin to write code
",260,"
#include <iostream>
#include <cassert>

bool validate(int n) {
    for (int i = 0; i < 10; i++) {
        int temp = n;
        int count = 0;
        while (temp) {
            if (temp % 10 == i) {
                count++;
            }
            if (count > i) {
                return false;
            }
            temp /= 10;
        }
    }
    return true;
}


","
using namespace std;

#include <iostream>
#include <cassert>

bool validate(int n) {
    for (int i = 0; i < 10; i++) {
        int temp = n;
        int count = 0;
        while (temp) {
            if (temp % 10 == i) {
                count++;
            }
            if (count > i) {
                return false;
            }
            temp /= 10;
        }
    }
    return true;
}

","#include <iostream>
#include <cassert>
bool validate(int n) {
    for (int i = 0; i < 10; i++) {
        int temp = n;
        int count = 0;
        while (temp) {
            if (temp % 10 == i) {
                count++;
            }
//begin to write code
","
#include <iostream>
#include <cassert>

bool validate(int n) {
    for (int i = 0; i < 10; i++) {
        int temp = n;
        int count = 0;
        while (temp) {
            if (temp % 10 == i) {
                count++;
            }
            if (count > i) {
                return 0;
            }
            temp /= 10;
        }
    }
    return 1;
}


","
#include <iostream>
#include <cassert>

bool validate(int n) {
    // Iterate through each digit in the number
    for (int i = 0; i < 10; i++) {
        int temp = n;
        int count = 0;
        while (temp) {
            // Check if the current digit matches the current index
            if (temp % 10 == i) {
                count++;
            }
            // Remove the current digit from the number
            temp /= 10;
        }
        // If the count is greater than or equal to the digit itself, return false
        if (count >= i) {
            return false;
        }
    }
    // If all digits meet the condition, return true
    return true;
}

",1,3,1.5840601245562236,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nbool validate(int n) {\n    for (int i = 0; i < 10; i++) {\n        int temp = n;\n        int count = 0;\n        while (temp) {\n            if (temp % 10 == i) {\n                count++;\n            }\n            if (count > i) {\n                return 0;\n            }\n            temp /= 10;\n        }\n    }\n    return 1;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nbool validate(int n) {\n    for (int i = 0; i < 10; i++) {\n        int temp = n;\n        int count = 0;\n        while (temp) {\n            if (temp % 10 == i) {\n                count++;\n            }\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nbool validate(int n) {\n    // Iterate through each digit in the number\n    for (int i = 0; i < 10; i++) {\n        int temp = n;\n        int count = 0;\n        while (temp) {\n            // Check if the current digit matches the current index\n            if (temp % 10 == i) {\n                count++;\n            }\n            // Remove the current digit from the number\n            temp /= 10;\n        }\n        // If the count is greater than or equal to the digit itself, return false\n        if (count >= i) {\n            return false;\n        }\n    }\n    // If all digits meet the condition, return true\n    return true;\n}\n\n', 'bool2int')]}"
273,"#include <iostream>
#include <vector>
#include <string>
#include <cassert>
template <typename T>
bool check_element(const std::vector<T>& list, const T& element) {
    for (const T& item : list) {
        if (item != element) {
//begin to write code
",250,"
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

template <typename T>
bool check_element(const std::vector<T>& list, const T& element) {
    for (const T& item : list) {
        if (item != element) {
            return false;
        }
    }
    return true;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

template <typename T>
bool check_element(const std::vector<T>& list, const T& element) {
    for (const T& item : list) {
        if (item!= element) {
            return false;
        }
    }
    return true;
}

","#include <iostream>
#include <vector>
#include <string>
#include <cassert>
template <typename T>
bool check_element(const std::vector<T>& list, const T& element) {
    for (const T& item : list) {
        if (element != item) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

template <typename T>
bool check_element(const std::vector<T>& list, const T& element) {
    for (const T& item : list) {
        if (element != item) {
            return 0;
        }
    }
    return 1;
}


","
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

template <typename T>
bool check_element(const std::vector<T>& list, const T& element) {
    for (const T& item : list) {
        if (element!= item) {
            return false;
        }
    }
    return true;
}

",-1,21,2.9884748021761576,code_expression_exchange:exchange_operators,1.0,0.8011591282830677,"{'\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (element != item) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (item != element) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (item!= element) {\n            return false;\n        }\n    }\n    return true;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (item != element) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (item!= element) {\n            return false;\n        }\n    }\n    return true;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (item != element) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (item!= element) {\n            return false;\n        }\n    }\n    return true;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (element != item) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (element!= item) {\n            return false;\n        }\n    }\n    return true;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (element != item) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (item!= element) {\n            return false;\n        }\n    }\n    return true;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (element != item) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (element!= item) {\n            return false;\n        }\n    }\n    return true;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (element != item) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (element!= item) {\n            return false;\n        }\n    }\n    return true;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (element != item) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (element!= item) {\n            return false;\n        }\n    }\n    return true;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (item != element) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <optional>\n\n// Function to check if all items in a vector are equal to a given string\ntemplate <typename T>\nstd::optional<bool> check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (item!= element) {\n            return false;\n        }\n    }\n    return true;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (element != item) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\ntemplate <typename T>\nbool check_element(const std::vector<T>& list, const T& element) {\n    for (const T& item : list) {\n        if (element!= item) {\n            return false;\n        }\n    }\n    return true;\n}\n\n', 'exchange_operators')]}"
274,"#include <iostream>
#include <regex>
#include <cassert>
using namespace std;
string text_match_two_three(const string& text) {
    regex pattern(""ab{2,3}"");
    if (regex_search(text, pattern)) {
        return ""Found a match!"";
//begin to write code
",251,"#include <iostream>
#include <regex>
#include <cassert>

using namespace std;

string text_match_two_three(const string& text) {
    regex pattern(""ab{2,3}"");
    if (regex_search(text, pattern)) {
        return ""Found a match!"";
    } else {
        return ""Not matched!"";
    }
}","
#include <iostream>
#include <regex>
#include <cassert>
using namespace std;

string text_match_two_three(const string& text) {
    regex pattern(""ab{2,3}"");
    if (regex_search(text, pattern)) {
        return ""Found a match!"";
    }
    return ""No match found."";
}

",,,,-2,1,0.2945484121640523,code_expression_exchange:None,0.0,0.0,
275,"#include<iostream>
#include <vector>
#include <cassert>
using namespace std;
int max_sub_array_sum_repeated(vector<int> a, int n, int k) {
    int max_so_far = -2147483648;
    int max_ending_here = 0;
    for (int i = 0; i < n * k; ++i) {
        max_ending_here = max_ending_here + a[i % n];
        if (max_so_far < max_ending_here) {
            max_so_far = max_ending_here;
//begin to write code
",402,"#include<iostream>
    

#include <vector>
#include <cassert>

using namespace std;

int max_sub_array_sum_repeated(vector<int> a, int n, int k) {
    int max_so_far = -2147483648;
    int max_ending_here = 0;
    for (int i = 0; i < n * k; ++i) {
        max_ending_here = max_ending_here + a[i % n];
        if (max_so_far < max_ending_here) {
            max_so_far = max_ending_here;
        }
        if (max_ending_here < 0) {
            max_ending_here = 0;
        }
    }
    return max_so_far;
}


","
#include<iostream>
#include <vector>
#include <cassert>
using namespace std;

int max_sub_array_sum_repeated(vector<int> a, int n, int k) {
    int max_so_far = -2147483648;
    int max_ending_here = 0;
    for (int i = 0; i < n * k; ++i) {
        max_ending_here = max_ending_here + a[i % n];
        if (max_so_far < max_ending_here) {
            max_so_far = max_ending_here;
        }
    }
    return max_so_far;
}

",,,,-2,1,0.24015130201975504,code_expression_exchange:None,0.0,0.0,
276,"#include<iostream>
#include <cassert>
int square_Sum(int n) {
//begin to write code
",84,"#include<iostream>
    

#include <cassert>

int square_Sum(int n) {
    return int(2*n*(n+1)*(2*n+1)/3);
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>

int square_Sum(int n) {
    int sum = 0;
    for (int i = 2; i <= n; i += 2) {
        sum += i * i;
    }
    return sum;
}

void test_square_Sum() {
    assert(square_Sum(0) == 0);
    assert(square_Sum(1) == 1);
    assert(square_Sum(2) == 6);
    assert(square_Sum(3) == 18);
    cout << ""All test cases passed successfully."" << endl;
}

",,,,-2,1,0.1975255489349365,code_expression_exchange:None,0.0,0.0,
277,"#include <iostream>
#include <vector>
#include <cassert>
int modular_inverse(const std::vector<int>& arr, int N, int P) {
    int current_element = 0;
    for (int i = 0; i < N; ++i) {
        if ((arr[i] * arr[i]) % P == 1) {
//begin to write code
",249,"
#include <iostream>
#include <vector>
#include <cassert>

int modular_inverse(const std::vector<int>& arr, int N, int P) {
    int current_element = 0;
    for (int i = 0; i < N; ++i) {
        if ((arr[i] * arr[i]) % P == 1) {
            current_element++;
        }
    }
    return current_element;
}


","
#include <iostream>
#include <vector>
#include <cassert>

int modular_inverse(const std::vector<int>& arr, int N, int P) {
    int current_element = 0;
    for (int i = 0; i < N; ++i) {
        if ((arr[i] * arr[i]) % P == 1) {
            current_element = arr[i];
            break;
        }
    }
    return current_element;
}

",,,,-2,1,0.24317325353622438,code_expression_exchange:None,0.0,0.0,
278,"#include<iostream>
#include <cassert>
using namespace std;
int odd_Days(int N) {
    int hund1 = N / 100;
    int hund4 = N / 400;
    int leap = N >> 2;
    int ordd = N - leap;
    if (hund1) {
        ordd += hund1;
        leap -= hund1;
//begin to write code
",264,"#include<iostream>
    

#include <cassert>

using namespace std;

int odd_Days(int N) {
    int hund1 = N / 100;
    int hund4 = N / 400;
    int leap = N >> 2;
    int ordd = N - leap;
    if (hund1) {
        ordd += hund1;
        leap -= hund1;
    }
    if (hund4) {
        ordd -= hund4;
        leap += hund4;
    }
    int days = ordd + leap * 2;
    int odd = days % 7;
    return odd;
}


","
#include<iostream>
#include <cassert>
using namespace std;

int odd_Days(int N) {
    int hund1 = N / 100;
    int hund4 = N / 400;
    int leap = N >> 2;
    int ordd = N - leap;
    if (hund1) {
        ordd += hund1;
        leap -= hund1;
    }
    if (leap % 4 == 0 && leap % 100!= 0) {
        ordd += 1;
    }
    if (leap % 400 == 0) {
        ordd += 1;
    }
    return ordd;
}

",,,,-2,1,0.23543011744817097,code_expression_exchange:None,0.0,0.0,
279,"#include <iostream>
#include <vector>
#include <cassert>
#include <algorithm>
std::pair<int, std::vector<int>> max_length(const std::vector<std::vector<int>>& list1) {
    int max_length = 0;
    std::vector<int> max_list;
    for (const auto& x : list1) {
        if (x.size() > max_length) {
//begin to write code
",316,"
#include <iostream>
#include <vector>
#include <cassert>
#include <algorithm>

std::pair<int, std::vector<int>> max_length(const std::vector<std::vector<int>>& list1) {
    int max_length = 0;
    std::vector<int> max_list;
    for (const auto& x : list1) {
        if (x.size() > max_length) {
            max_length = x.size();
            max_list = x;
        }
    }
    return {max_length, max_list};
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>
#include <algorithm>

std::pair<int, std::vector<int>> max_length(const std::vector<std::vector<int>>& list1) {
    int max_length = 0;
    std::vector<int> max_list;
    for (const auto& x : list1) {
        if (x.size() > max_length) {
            max_length = x.size();
            max_list = x;
        }
    }
    return {max_length, max_list};
}

","#include <iostream>
#include <vector>
#include <cassert>
#include <algorithm>
std::pair<int, std::vector<int>> max_length(const std::vector<std::vector<long>>& list1) {
    int max_length = 0;
    std::vector<int> max_list;
    for (const auto& x : list1) {
        if (x.size() > max_length) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>
#include <algorithm>

std::pair<int, std::vector<int>> max_length(const std::vector<std::vector<long>>& list1) {
    int max_length = 0;
    std::vector<int> max_list;
    for (const auto& x : list1) {
        if (x.size() > max_length) {
            max_length = x.size();
            max_list = x;
        }
    }
    return {max_length, max_list};
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <cassert>
#include <algorithm>

std::pair<int, std::vector<int>> max_length(const std::vector<std::vector<long>>& list1) {
    int max_length = 0;
    std::vector<int> max_list;
    for (const auto& x : list1) {
        if (x.size() > max_length) {
            max_length = x.size();
            max_list = x;
        }
    }
    return {max_length, max_list};
}

",1,3,0.5805892904599508,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nstd::pair<int, std::vector<int>> max_length(const std::vector<std::vector<long>>& list1) {\n    int max_length = 0;\n    std::vector<int> max_list;\n    for (const auto& x : list1) {\n        if (x.size() > max_length) {\n            max_length = x.size();\n            max_list = x;\n        }\n    }\n    return {max_length, max_list};\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nstd::pair<int, std::vector<int>> max_length(const std::vector<std::vector<long>>& list1) {\n    int max_length = 0;\n    std::vector<int> max_list;\n    for (const auto& x : list1) {\n        if (x.size() > max_length) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nstd::pair<int, std::vector<int>> max_length(const std::vector<std::vector<long>>& list1) {\n    int max_length = 0;\n    std::vector<int> max_list;\n    for (const auto& x : list1) {\n        if (x.size() > max_length) {\n            max_length = x.size();\n            max_list = x;\n        }\n    }\n    return {max_length, max_list};\n}\n\n', 'more_universe_var_type')]}"
280,"#include<cassert>
#include <iostream>
#include <vector>
using namespace std;
int count_no_of_ways(int n, int k) {
    vector<int> dp(n + 1, 0);
    const int mod = 1000000007;
    dp[1] = k;
    dp[2] = k * k;
//begin to write code
",232,"#include<cassert>
#include <iostream>
#include <vector>
using namespace std;

int count_no_of_ways(int n, int k) {
    vector<int> dp(n + 1, 0);
    const int mod = 1000000007;
    dp[1] = k;
    dp[2] = k * k;
    for (int i = 3; i <= n; ++i) {
        dp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod;
    }
    return dp[n];
}


","#include<cassert>
#include <iostream>
#include <vector>
using namespace std;

int count_no_of_ways(int n, int k) {
    vector<int> dp(n + 1, 0);
    const int mod = 1000000007;
    dp[1] = k;
    dp[2] = k * k;
    
    // Fill the dp array
    for (int i = 3; i <= n; ++i) {
        dp[i] = (dp[i - 1] + dp[i - 2]) % mod;
    }
    
    return dp[n];
}
",,,,-2,1,0.20061877171198528,code_expression_exchange:None,0.0,0.0,
281,"#include <iostream>
#include <cassert>
int find(int n, int m) {
    int q = n / m;
//begin to write code
",105,"
#include <iostream>
#include <cassert>

int find(int n, int m) {
    int q = n / m;
    return q;
}


","
#include <iostream>
#include <cassert>

int find(int n, int m) {
    int q = n / m;
    return q;
}

// Test cases
void test_find() {
    assert(find(10, 2) == 5);
    assert(find(7, 3) == 2);
    assert(find(8, 2) == 4);
    assert(find(0, 5) == 0);
    assert(find(5, 0) == 0);
    std::cout << ""All test cases passed successfully."" << std::endl;
}

","#include <iostream>
#include <cassert>
long find(long n, long m) {
    long q = n / m;
//begin to write code
","
#include <iostream>
#include <cassert>

long find(long n, long m) {
    long q = n / m;
    return q;
}


","#include <iostream>
#include <cassert>
long find(long n, long m) {
    long q = n / m;
    return q;
}
",-1,21,2.5703314503033954,code_expression_exchange:bool2int,1.0,0.7681400703190022,"{'\n#include <iostream>\n#include <cassert>\n\nlong find(long n, long m) {\n    long q = n / m;\n    return q;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nlong find(int n, int m) {\n    int q = n / m;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nlong find(int n, int m) {\n    int q = n / m;\n    return q;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nlong find(int n, int m) {\n    int q = n / m;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nlong find(int n, int m) {\n    return n / m;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cassert>\nlong find(int n, int m) {\n    int q = n / m;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nlong find(int n, int m) {\n    int q = n / m;\n    return q;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cassert>\nlong find(int n, int m) {\n    int q = n / m;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nlong find(int n, int m) {\n    int q = n / m;\n    return q;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cassert>\nlong find(int n, int m) {\n    int q = n / m;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nlong find(int n, int m) {\n    return n / m;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cassert>\nlong find(long n, int m) {\n    int q = n / m;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <cassert>\n\nlong find(long n, int m) {\n    int q = n / m;\n    return q;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nlong find(long n, int m) {\n    long q = n / m;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nlong find(long n, int m) {\n    long q = n / m;\n    return q;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nlong find(long n, long m) {\n    long q = n / m;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nlong find(long n, long m) {\n    long q = n / m;\n    return q;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nlong find(long n, long m) {\n    long q = n / m;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nlong find(long n, long m) {\n    long q = n / m;\n    return q;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cassert>\nlong find(long n, long m) {\n    long q = n / m;\n//begin to write code\n', '#include <iostream>\n#include <cassert>\nlong find(long n, long m) {\n    long q = n / m;\n    return q;\n}\n', 'bool2int')]}"
282,"#include <iostream>
#include <cmath>
#include <cassert>
double otherside_rightangle(double w, double h) {
    double s = std::sqrt((w * w) + (h * h));
//begin to write code
",173,"
#include <iostream>
#include <cmath>
#include <cassert>

double otherside_rightangle(double w, double h) {
    double s = std::sqrt((w * w) + (h * h));
    return s;
}


","using namespace std;
#include <cmath>
#include <cassert>

double otherside_rightangle(double w, double h) {
    double s = sqrt((w * w) + (h * h));
    return s;
}
","#include <iostream>
#include <cmath>
#include <cassert>
double otherside_rightangle(double w, double h) {
    double s = std::sqrt((w * w) + (h * h));
//begin to write code
","
#include <iostream>
#include <cmath>
#include <cassert>

double otherside_rightangle(double w, double h) {
    double s = std::sqrt((w * w) + (h * h));
    return s;
}


","
using namespace std;
#include <cmath>
#include <cassert>

double otherside_rightangle(double w, double h) {
    double s = std::sqrt((w * w) + (h * h));
    return s - w - h;
}

",1,3,0.39932361443837483,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble otherside_rightangle(double w, double h) {\n    double s = std::sqrt((w * w) + (h * h));\n    return s;\n}\n\n\n': [('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble otherside_rightangle(double w, double h) {\n    double s = std::sqrt((w * w) + (h * h));\n//begin to write code\n', '\nusing namespace std;\n#include <cmath>\n#include <cassert>\n\ndouble otherside_rightangle(double w, double h) {\n    double s = std::sqrt((w * w) + (h * h));\n    return s - w - h;\n}\n\n', 'exchange_operators')]}"
283,"#include<iostream>
#include <vector>
#include <string>
#include <cassert>
#include <algorithm>
#include <limits>
using namespace std;
int max_val(const vector<int>& listval) {
//begin to write code
",198,"#include<iostream>
    

#include <vector>
#include <string>
#include <cassert>
#include <algorithm>
#include <limits>

using namespace std;

int max_val(const vector<int>& listval) {
    return *max_element(listval.begin(), listval.end());
}


","
#include<iostream>
#include <vector>
#include <string>
#include <cassert>
#include <limits>
using namespace std;

int max_val(const vector<int>& listval) {
    if (listval.empty()) {
        return INT_MIN; // Return INT_MIN if the list is empty
    }
    int max_value = listval[0];
    for (int i = 1; i < listval.size(); ++i) {
        if (listval[i] > max_value) {
            max_value = listval[i];
        }
    }
    return max_value;
}

","#include<iostream>
#include <vector>
#include <string>
#include <cassert>
#include <algorithm>
#include <limits>
using namespace std;
int max_val(const vector<int>& listval) {
//begin to write code
","#include<iostream>
    

#include <vector>
#include <string>
#include <cassert>
#include <algorithm>
#include <limits>

using namespace std;

int max_val(const vector<int>& listval) {
    return *max_element(listval.begin(), listval.end());
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<limits>
#include<iostream>

int max_val(const vector<int>& listval) {
    if (listval.empty()) {
        throw invalid_argument(""The list cannot be empty"");
    }
    int max_val = listval[0];
    for (size_t i = 1; i < listval.size(); ++i) {
        if (listval[i] > max_val) {
            max_val = listval[i];
        }
    }
    return max_val;
}
",1,3,0.5247316320737203,code_expression_exchange:exchange_operators,1.0,0.0,"{'#include<iostream>\n    \n\n#include <vector>\n#include <string>\n#include <cassert>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nint max_val(const vector<int>& listval) {\n    return *max_element(listval.begin(), listval.end());\n}\n\n\n': [('#include<iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <algorithm>\n#include <limits>\nusing namespace std;\nint max_val(const vector<int>& listval) {\n//begin to write code\n', 'using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<limits>\n#include<iostream>\n\nint max_val(const vector<int>& listval) {\n    if (listval.empty()) {\n        throw invalid_argument(""The list cannot be empty"");\n    }\n    int max_val = listval[0];\n    for (size_t i = 1; i < listval.size(); ++i) {\n        if (listval[i] > max_val) {\n            max_val = listval[i];\n        }\n    }\n    return max_val;\n}\n', 'exchange_operators')]}"
284,"#include<cassert>
#include <iostream>
#include <vector>
#include <numeric>
int sum_div(int number) {
    std::vector<int> divisors = {1};
    for (int i = 2; i < number; ++i) {
        if (number % i == 0) {
//begin to write code
",230,"#include<cassert>
#include <iostream>
#include <vector>
#include <numeric>

int sum_div(int number) {
    std::vector<int> divisors = {1};
    for (int i = 2; i < number; ++i) {
        if (number % i == 0) {
            divisors.push_back(i);
        }
    }
    return std::accumulate(divisors.begin(), divisors.end(), 0);
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<cassert>
#include <iostream>
#include <vector>
#include <numeric>
int sum_div(int number) {
    std::vector<int> divisors = {1};
    for (int i = 2; i < number; ++i) {
        if (number % i == 0) {
            divisors.push_back(i);
        }
    }
    return std::accumulate(divisors.begin(), divisors.end(), 0);
}

","#include<cassert>
#include <iostream>
#include <vector>
#include <numeric>
int sum_div(int number) {
    std::vector<int> divisors = {1};
    for (int i = 2; i < number; ++i) {
        if (0 == number % i) {
//begin to write code
","#include<cassert>
#include <iostream>
#include <vector>
#include <numeric>

int sum_div(int number) {
    std::vector<int> divisors = {1};
    for (int i = 2; i < number; ++i) {
        if (0 == number % i) {
            divisors.push_back(i);
        }
    }
    return std::accumulate(divisors.begin(), divisors.end(), 0);
}


","
#include <iostream>
#include <vector>
#include <numeric>

int sum_div(int number) {
    std::vector<int> divisors;
    for (int i = 1; i <= number; ++i) {
        if (number % i == 0) {
            divisors.push_back(i);
        }
    }
    return std::accumulate(divisors.begin(), divisors.end(), 0);
}

",1,3,0.4801165660222371,code_expression_exchange:exchange_operators,1.0,0.0,"{'#include<cassert>\n#include <iostream>\n#include <vector>\n#include <numeric>\n\nint sum_div(int number) {\n    std::vector<int> divisors = {1};\n    for (int i = 2; i < number; ++i) {\n        if (0 == number % i) {\n            divisors.push_back(i);\n        }\n    }\n    return std::accumulate(divisors.begin(), divisors.end(), 0);\n}\n\n\n': [('#include<cassert>\n#include <iostream>\n#include <vector>\n#include <numeric>\nint sum_div(int number) {\n    std::vector<int> divisors = {1};\n    for (int i = 2; i < number; ++i) {\n        if (0 == number % i) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <numeric>\n\nint sum_div(int number) {\n    std::vector<int> divisors;\n    for (int i = 1; i <= number; ++i) {\n        if (number % i == 0) {\n            divisors.push_back(i);\n        }\n    }\n    return std::accumulate(divisors.begin(), divisors.end(), 0);\n}\n\n', 'exchange_operators')]}"
285,"#include<cassert>
#include <iostream>
#include <vector>
using namespace std;
int get_Inv_Count(vector<int> arr, int n) {
    int inv_count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (arr[i] > arr[j]) {
//begin to write code
",277,"#include<cassert>
#include <iostream>
#include <vector>
using namespace std;

int get_Inv_Count(vector<int> arr, int n) {
    int inv_count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (arr[i] > arr[j]) {
                inv_count++;
            }
        }
    }
    return inv_count;
}


","#include <cassert>
#include <iostream>
#include <vector>
using namespace std;

int get_Inv_Count(vector<int> arr, int n) {
    int inv_count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (arr[i] > arr[j]) {
                inv_count++;
            }
        }
    }
    return inv_count;
}
","#include<cassert>
#include <iostream>
#include <vector>
using namespace std;
int get_Inv_Count(vector<int> arr, int n) {
    int inv_count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (arr[i] > arr[j]) {
//begin to write code
","#include<cassert>
#include <iostream>
#include <vector>
using namespace std;

int get_Inv_Count(vector<int> arr, int n) {
    int inv_count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (arr[i] > arr[j]) {
                inv_count++;
            }
        }
    }
    return inv_count;
}


","#include <algorithm>
#include <vector>
using namespace std;

int get_Inv_Count(vector<int> arr, int n) {
    int inv_count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (arr[i] > arr[j]) {
                inv_count++;
            }
        }
    }
    return inv_count;
}
",1,3,0.41773622035980223,code_expression_exchange:bool2int,1.0,0.0,"{'#include<cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_Inv_Count(vector<int> arr, int n) {\n    int inv_count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (arr[i] > arr[j]) {\n                inv_count++;\n            }\n        }\n    }\n    return inv_count;\n}\n\n\n': [('#include<cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\nint get_Inv_Count(vector<int> arr, int n) {\n    int inv_count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (arr[i] > arr[j]) {\n//begin to write code\n', '#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint get_Inv_Count(vector<int> arr, int n) {\n    int inv_count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (arr[i] > arr[j]) {\n                inv_count++;\n            }\n        }\n    }\n    return inv_count;\n}\n', 'bool2int')]}"
286,"#include <vector>
#include <iostream>
#include <cassert>
using namespace std;
class Variant {
public:
    virtual ~Variant() = default;
    virtual bool is_int() const = 0;
    virtual bool is_vector() const = 0;
    virtual int get_int() const = 0;
    virtual const vector<Variant*>& get_vector() const = 0;
};
class IntVariant : public Variant {
public:
    IntVariant(int value) : value(value) {}
    bool is_int() const override { return true; }
    bool is_vector() const override { return false; }
    int get_int() const override { return value; }
    const vector<Variant*>& get_vector() const override { throw runtime_error(""Not a vector""); }
private:
    int value;
};
class VectorVariant : public Variant {
public:
    VectorVariant(const vector<Variant*>& value) : value(value) {}
    bool is_int() const override { return false; }
    bool is_vector() const override { return true; }
    int get_int() const override { throw runtime_error(""Not an int""); }
    const vector<Variant*>& get_vector() const override { return value; }
private:
    vector<Variant*> value;
};
void flatten_list(const vector<Variant*>& list1, vector<int>& result_list) {
    for (const auto& element : list1) {
//begin to write code
",1223,"#include <vector>
#include <iostream>
#include <cassert>

using namespace std;

class Variant {
public:
    virtual ~Variant() = default;
    virtual bool is_int() const = 0;
    virtual bool is_vector() const = 0;
    virtual int get_int() const = 0;
    virtual const vector<Variant*>& get_vector() const = 0;
};

class IntVariant : public Variant {
public:
    IntVariant(int value) : value(value) {}
    bool is_int() const override { return true; }
    bool is_vector() const override { return false; }
    int get_int() const override { return value; }
    const vector<Variant*>& get_vector() const override { throw runtime_error(""Not a vector""); }
private:
    int value;
};

class VectorVariant : public Variant {
public:
    VectorVariant(const vector<Variant*>& value) : value(value) {}
    bool is_int() const override { return false; }
    bool is_vector() const override { return true; }
    int get_int() const override { throw runtime_error(""Not an int""); }
    const vector<Variant*>& get_vector() const override { return value; }
private:
    vector<Variant*> value;
};

void flatten_list(const vector<Variant*>& list1, vector<int>& result_list) {
    for (const auto& element : list1) {
        if (element->is_int()) {
            result_list.push_back(element->get_int());
        } else if (element->is_vector()) {
            flatten_list(element->get_vector(), result_list);
        }
    }
}


vector<int> flatten_list(const vector<Variant*>& list1) {
    vector<int> result_list;
    flatten_list(list1, result_list);
    return result_list;
}


vector<Variant*> create_variant_list(const vector<vector<int>>& input) {
    vector<Variant*> result;
    for (const auto& vec : input) {
        if(vec.size()==1)
        {
            result.push_back(new IntVariant(vec[0]));
        }
        else
        {
            vector<Variant*> tmp;
            for(auto v:vec)
            {
                tmp.push_back(new IntVariant(v));
            }
            result.push_back(new VectorVariant(tmp));
        }
    }
    return result;
}","
#include <vector>
#include <iostream>
#include <cassert>
using namespace std;

class Variant {
public:
    virtual ~Variant() = default;
    virtual bool is_int() const = 0;
    virtual bool is_vector() const = 0;
    virtual int get_int() const = 0;
    virtual const vector<Variant*>& get_vector() const = 0;
};
class IntVariant : public Variant {
public:
    IntVariant(int value) : value(value) {}
    bool is_int() const override { return true; }
    bool is_vector() const override { return false; }
    int get_int() const override { return value; }
    const vector<Variant*>& get_vector() const override { throw runtime_error(""Not a vector""); }
private:
    int value;
};
class VectorVariant : public Variant {
public:
    VectorVariant(const vector<Variant*>& value) : value(value) {}
    bool is_int() const override { return false; }
    bool is_vector() const override { return true; }
    int get_int() const override { throw runtime_error(""Not an int""); }
    const vector<Variant*>& get_vector() const override { return value; }
private:
    vector<Variant",,,,-2,1,0.23566438754399618,code_expression_exchange:None,0.0,0.0,
287,"#include<iostream>
#include <vector>
#include <cassert>
#include <algorithm>
#include <string>
using namespace std;
template<typename T>
vector<vector<T>> intersection_nested_lists(const vector<T>& l1, const vector<vector<T>>& l2) {
    vector<vector<T>> result;
    for (const auto& lst : l2) {
        vector<T> temp;
        for (const auto& n : lst) {
            if (find(l1.begin(), l1.end(), n) != l1.end()) {
//begin to write code
",439,"#include<iostream>
    

#include <vector>
#include <cassert>
#include <algorithm>
#include <string>

using namespace std;

template<typename T>
vector<vector<T>> intersection_nested_lists(const vector<T>& l1, const vector<vector<T>>& l2) {
    vector<vector<T>> result;
    for (const auto& lst : l2) {
        vector<T> temp;
        for (const auto& n : lst) {
            if (find(l1.begin(), l1.end(), n) != l1.end()) {
                temp.push_back(n);
            }
        }
        result.push_back(temp);
    }
    return result;
}","
#include<iostream>
#include <vector>
#include <cassert>
#include <algorithm>
#include <string>
using namespace std;

template<typename T>
vector<vector<T>> intersection_nested_lists(const vector<T>& l1, const vector<vector<T>>& l2) {
    vector<vector<T>> result;
    for (const auto& lst : l2) {
        vector<T> temp;
        for (const auto& n : lst) {
            if (find(l1.begin(), l1.end(), n)!= l1.end()) {
                temp.push_back(n);
            }
        }
        result.push_back(temp);
    }
    return result;
}

","#include<iostream>
#include <vector>
#include <cassert>
#include <algorithm>
#include <string>
using namespace std;
template<typename T>
vector<vector<T>> intersection_nested_lists(const vector<T>& l1, const vector<vector<T>>& l2) {
    vector<vector<T>> result;
    for (const auto& lst : l2) {
        vector<T> temp;
        for (const auto& n : lst) {
            if (l1.end() != find(l1.begin(), l1.end(), n)) {
//begin to write code
","#include<iostream>
    

#include <vector>
#include <cassert>
#include <algorithm>
#include <string>

using namespace std;

template<typename T>
vector<vector<T>> intersection_nested_lists(const vector<T>& l1, const vector<vector<T>>& l2) {
    vector<vector<T>> result;
    for (const auto& lst : l2) {
        vector<T> temp;
        for (const auto& n : lst) {
            if (l1.end() != find(l1.begin(), l1.end(), n)) {
                temp.push_back(n);
            }
        }
        result.push_back(temp);
    }
    return result;
}","
#include<iostream>
#include <vector>
#include <cassert>
#include <algorithm>
#include <string>
using namespace std;

template<typename T>
vector<vector<T>> intersection_nested_lists(const vector<T>& l1, const vector<vector<T>>& l2) {
    vector<vector<T>> result;
    for (const auto& lst : l2) {
        vector<T> temp;
        for (const auto& n : lst) {
            if (l1.end()!= find(l1.begin(), l1.end(), n)) {
                temp.push_back(n);
            }
        }
        if (!temp.empty()) {
            result.push_back(temp);
        }
    }
    return result;
}

",1,3,0.526105789343516,code_expression_exchange:exchange_operators,1.0,0.0,"{'#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\ntemplate<typename T>\nvector<vector<T>> intersection_nested_lists(const vector<T>& l1, const vector<vector<T>>& l2) {\n    vector<vector<T>> result;\n    for (const auto& lst : l2) {\n        vector<T> temp;\n        for (const auto& n : lst) {\n            if (l1.end() != find(l1.begin(), l1.end(), n)) {\n                temp.push_back(n);\n            }\n        }\n        result.push_back(temp);\n    }\n    return result;\n}': [('#include<iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <string>\nusing namespace std;\ntemplate<typename T>\nvector<vector<T>> intersection_nested_lists(const vector<T>& l1, const vector<vector<T>>& l2) {\n    vector<vector<T>> result;\n    for (const auto& lst : l2) {\n        vector<T> temp;\n        for (const auto& n : lst) {\n            if (l1.end() != find(l1.begin(), l1.end(), n)) {\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\ntemplate<typename T>\nvector<vector<T>> intersection_nested_lists(const vector<T>& l1, const vector<vector<T>>& l2) {\n    vector<vector<T>> result;\n    for (const auto& lst : l2) {\n        vector<T> temp;\n        for (const auto& n : lst) {\n            if (l1.end()!= find(l1.begin(), l1.end(), n)) {\n                temp.push_back(n);\n            }\n        }\n        if (!temp.empty()) {\n            result.push_back(temp);\n        }\n    }\n    return result;\n}\n\n', 'exchange_operators')]}"
288,"#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <cassert>
using namespace std;
pair<string, int> max_aggregate(const vector<pair<string, int>>& stdata) {
    map<string, int> temp;
    for (const auto& item : stdata) {
        temp[item.first] += item.second;
    }
    pair<string, int> max_item = *temp.begin();
    for (const auto& item : temp) {
        if (item.second > max_item.second) {
//begin to write code
",449,"#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <cassert>

using namespace std;

pair<string, int> max_aggregate(const vector<pair<string, int>>& stdata) {
    map<string, int> temp;
    for (const auto& item : stdata) {
        temp[item.first] += item.second;
    }
    pair<string, int> max_item = *temp.begin();
    for (const auto& item : temp) {
        if (item.second > max_item.second) {
            max_item = item;
        }
    }
    return max_item;
}

bool compare(pair<string,int> r1,pair<string,int>r2)
{
    return r1.first == r2.first && r1.second == r2.second;
}","#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <cassert>
using namespace std;

pair<string, int> max_aggregate(const vector<pair<string, int>>& stdata) {
    map<string, int> temp;
    for (const auto& item : stdata) {
        temp[item.first] += item.second;
    }
    pair<string, int> max_item = *temp.begin();
    for (const auto& item : temp) {
        if (item.second > max_item.second) {
            max_item = item;
        }
    }
    return max_item;
}
",,,,-2,1,0.1895013411839803,code_expression_exchange:None,0.0,0.0,
289,"#include <iostream>
#include <cassert>
double count_binary_seq(int n) {
    double nCr = 1;
    double res = 1;
    for(int r = 1; r <= n; ++r) {
//begin to write code
",168,"
#include <iostream>
#include <cassert>

double count_binary_seq(int n) {
    double nCr = 1;
    double res = 1;
    for(int r = 1; r <= n; ++r) {
        nCr = (nCr * (n + 1 - r)) / r;
        res += nCr * nCr;
    }
    return res;
}


","
#include <iostream>
#include <cassert>
#include <vector>

int count_binary_seq(int n) {
    if (n == 0 || n == 1) return 1;

    std::vector<int> dp(n + 1);
    dp[0] = 1;
    dp[1] = 2;

    for (int i = 2; i <= n; ++i) {
        for (int j = 1; j <= i; ++j) {
            dp[i] += dp[j - 1] * dp[i - j];
        }
    }

    return dp[n];
}

void test_count_binary_seq() {
    assert(count_binary_seq(1) == 1);
    assert(count_binary_seq(2) == 2);
    assert(count_binary_seq(3) == 4);
    assert(count_binary_seq(4) == 8);
    assert(count_binary_seq(5) == 16);
    assert(count_binary_seq(6) == 32);
    assert(count_binary_seq(7) == 64);
    assert(count_binary_seq(8) == 128);
    assert(count_binary_seq(9) == 256",,,,-2,1,0.23337618509928384,code_expression_exchange:None,0.0,0.0,
290,"#include <iostream>
#include <unordered_map>
#include <cassert>
using namespace std;
class Variant {
public:
    virtual ~Variant() = default;
};
class IntVariant : public Variant {
public:
    IntVariant(int value) : value(value) {}
    int get_int() const {
        return this->value;
    }
private:
    int value;
};
class MapVariant : public Variant {
public:
    MapVariant(const std::unordered_map<char, Variant*>& map) : map(map) {}
    const std::unordered_map<char, Variant*>& get_map() const {
        return this->map;
    }
private:
//begin to write code
",568,"#include <iostream>
#include <unordered_map>
#include <cassert>

using namespace std;

class Variant {
public:
    virtual ~Variant() = default;
};

class IntVariant : public Variant {
public:
    IntVariant(int value) : value(value) {}
    int get_int() const {
        return this->value;
    }
private:
    int value;
};

class MapVariant : public Variant {
public:
    MapVariant(const std::unordered_map<char, Variant*>& map) : map(map) {}
    const std::unordered_map<char, Variant*>& get_map() const {
        return this->map;
    }
private:
    std::unordered_map<char, Variant*> map;
};

int dict_depth(const Variant* variant) {
    if (variant == nullptr) {
        return 0;
    }

    if (const IntVariant* intVariant = dynamic_cast<const IntVariant*>(variant)) {
        return 0;
    } else if (const MapVariant* mapVariant = dynamic_cast<const MapVariant*>(variant)) {
        int max_depth = 0;
        const auto& map = mapVariant->get_map();
        for (const auto& pair : map) {
            int onedepth = dict_depth(pair.second);
            if (onedepth > max_depth) {
                max_depth = onedepth;
            }
        }
        return max_depth + 1;
    }
    return 0;
}","
#include <iostream>
#include <unordered_map>
#include <cassert>
using namespace std;

class Variant {
public:
    virtual ~Variant() = default;
};

class IntVariant : public Variant {
public:
    IntVariant(int value) : value(value) {}
    int get_int() const {
        return this->value;
    }
private:
    int value;
};

class MapVariant : public Variant {
public:
    MapVariant(const std::unordered_map<char, Variant*>& map) : map(map) {}
    const std::unordered_map<char, Variant*>& get_map() const {
        return this->map;
    }
private:
    unordered_map<char, Variant*> map;
};

int find_depth(const Variant* root) {
    if (root == nullptr) {
        return 0;
    }
    int max_depth = 0;
    for (const auto& child : root->get_map()) {
        max_depth = max(max_depth, find_depth(child.second));
    }
    return 1 + max_depth;
}

",,,,-2,1,0.23544357617696127,code_expression_exchange:None,0.0,0.0,
291,"#include <iostream>
#include <cassert>
// 
int set_Bit_Number(int n) {
    if (n == 0) {
        return 0;
    }
    int msb = 0;
//begin to write code
",156,"
#include <iostream>
#include <cassert>

// 
int set_Bit_Number(int n) {
    if (n == 0) {
        return 0;
    }
    int msb = 0;
    n = n / 2;
    while (n > 0) {
        n = n / 2;
        msb++;
    }
    return (1 << msb);
}


","
using namespace std;
#include <iostream>
#include <cassert>

// 
int set_Bit_Number(int n) {
    if (n == 0) {
        return 0;
    }
    int msb = 0;
    while (n > 0) {
        if (n & 1) {
            msb++;
        }
        n >>= 1;
    }
    return msb;
}

",,,,-2,1,0.23858426809310912,code_expression_exchange:None,0.0,0.0,
292,"#include<iostream>
#include <limits>
#include <algorithm>
#include <cassert>
using namespace std;
bool solve(int a[], int n) {
    int mx = numeric_limits<int>::min();
    for (int j = 1; j < n; j++) {
        if (mx > a[j]) {
            return false;
//begin to write code
",275,"#include<iostream>
    

#include <limits>
#include <algorithm>
#include <cassert>
using namespace std;

bool solve(int a[], int n) {
    int mx = numeric_limits<int>::min();
    for (int j = 1; j < n; j++) {
        if (mx > a[j]) {
            return false;
        }
        mx = max(mx, a[j - 1]);
    }
    return true;
}


","
#include<iostream>
#include <limits>
#include <algorithm>
#include <cassert>
using namespace std;

bool solve(int a[], int n) {
    int mx = numeric_limits<int>::min();
    for (int j = 1; j < n; j++) {
        if (mx > a[j]) {
            return false;
        }
    }
    int inversions = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (a[i] > a[j]) {
                inversions++;
            }
        }
    }
    return inversions % 2 == 0;
}

",,,,-2,1,0.22614653507868449,code_expression_exchange:None,0.0,0.0,
293,"#include <iostream>
#include <vector>
#include <cassert>
int find_Element(const std::vector<int>& arr, const std::vector<std::pair<int, int>>& ranges, int rotations, int index) {
    for (int i = rotations - 1; i >= 0; --i) {
        int left = ranges[i].first;
        int right = ranges[i].second;
        if (left <= index && right >= index) {
            if (index == left) {
                index = right;
//begin to write code
",433,"
#include <iostream>
#include <vector>
#include <cassert>

int find_Element(const std::vector<int>& arr, const std::vector<std::pair<int, int>>& ranges, int rotations, int index) {
    for (int i = rotations - 1; i >= 0; --i) {
        int left = ranges[i].first;
        int right = ranges[i].second;
        if (left <= index && right >= index) {
            if (index == left) {
                index = right;
            } else {
                index = index - 1;
            }
        }
    }
    return arr[index];
}


","
#include <iostream>
#include <vector>
#include <cassert>

int find_Element(const std::vector<int>& arr, const std::vector<std::pair<int, int>>& ranges, int rotations, int index) {
    for (int i = rotations - 1; i >= 0; --i) {
        int left = ranges[i].first;
        int right = ranges[i].second;
        if (left <= index && right >= index) {
            if (index == left) {
                index = right;
                return arr[index];
            }
            // Perform a rotation to find the element at the rotated index
            int temp = arr[index];
            arr[index] = arr[left];
            arr[left] = temp;
        }
    }
    return -1; // Element not found
}

",,,,-2,1,0.2364373763402303,code_expression_exchange:None,0.0,0.0,
294,"#include <iostream>
#include <regex>
#include <cassert>
using namespace std;
pair<string, string> start_withp(vector<string> words) {
    regex pattern(""(P\\\w+)\\\W(P\\\w+)"");
    for (const auto &w : words) {
        smatch match;
        if (regex_search(w, match, pattern)) {
            return {match[1], match[2]};
        }
//begin to write code
",353,"#include <iostream>
#include <regex>
#include <cassert>

using namespace std;

pair<string, string> start_withp(vector<string> words) {
    regex pattern(""(P\\\w+)\\\W(P\\\w+)"");
    for (const auto &w : words) {
        smatch match;
        if (regex_search(w, match, pattern)) {
            return {match[1], match[2]};
        }
    }
    return {};
}

bool compare(pair<string,string> r1,pair<string,string> r2)
{
    return r1.first == r2.first && r1.second == r2.second;
}","
#include <iostream>
#include <regex>
#include <cassert>
using namespace std;

pair<string, string> start_withp(vector<string> words) {
    regex pattern(""(P\\\w+)\\\W(P\\\w+)"");
    for (const auto &w : words) {
        smatch match;
        if (regex_search(w, match, pattern)) {
            return {match[1], match[2]};
        }
    }
    return {"""", """"};
}

",,,,-2,1,0.28753333489100136,code_expression_exchange:None,0.0,0.0,
295,"#include<iostream>
#include <vector>
#include <cassert>
using namespace std;
int max_sum_increasing_subseq(vector<int> a, int n, int index, int k) {
    vector<vector<int>> dp(n, vector<int>(n, 0));
    for (int i = 0; i < n; ++i) {
        if (a[i] > a[0]) {
            dp[0][i] = a[i] + a[0];
        } else {
            dp[0][i] = a[i];
        }
    }
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (a[j] > a[i] && j > i) {
//begin to write code
",492,"#include<iostream>
    

#include <vector>
#include <cassert>
using namespace std;

int max_sum_increasing_subseq(vector<int> a, int n, int index, int k) {
    vector<vector<int>> dp(n, vector<int>(n, 0));
    for (int i = 0; i < n; ++i) {
        if (a[i] > a[0]) {
            dp[0][i] = a[i] + a[0];
        } else {
            dp[0][i] = a[i];
        }
    }
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (a[j] > a[i] && j > i) {
                if (dp[i - 1][i] + a[j] > dp[i - 1][j]) {
                    dp[i][j] = dp[i - 1][i] + a[j];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[index][k];
}


","
#include<iostream>
#include <vector>
#include <cassert>
using namespace std;

int max_sum_increasing_subseq(vector<int> a, int n, int index, int k) {
    vector<vector<int>> dp(n, vector<int>(n, 0));
    for (int i = 0; i < n; ++i) {
        if (a[i] > a[0]) {
            dp[0][i] = a[i] + a[0];
        } else {
            dp[0][i] = a[i];
        }
    }
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (a[j] > a[i] && j > i) {
                dp[i][j] = max(dp[i][j], dp[i - 1][j]);
            }
        }
    }
    return dp[n - 1][k];
}

",,,,-2,1,0.2841602206230164,code_expression_exchange:None,0.0,0.0,
296,"#include <iostream>
#include <tuple>
#include <vector>
#include <cassert>
std::tuple<std::string, int, std::vector<int>, bool> colon_tuplex(std::tuple<std::string, int, std::vector<int>, bool> tuplex, int m, int n) {
    std::tuple<std::string, int, std::vector<int>, bool> tuplex_colon = tuplex;
//begin to write code
",319,"
#include <iostream>
#include <tuple>
#include <vector>
#include <cassert>

std::tuple<std::string, int, std::vector<int>, bool> colon_tuplex(std::tuple<std::string, int, std::vector<int>, bool> tuplex, int m, int n) {
    std::tuple<std::string, int, std::vector<int>, bool> tuplex_colon = tuplex;
    std::get<2>(tuplex_colon).push_back(n);
    return tuplex_colon;
}


","
#include <iostream>
#include <tuple>
#include <vector>
#include <cassert>

std::tuple<std::string, int, std::vector<int>, bool> colon_tuplex(std::tuple<std::string, int, std::vector<int>, bool> tuplex, int m, int n) {
    std::tuple<std::string, int, std::vector<int>, bool> tuplex_colon = tuplex;
    return std::make_tuple(tuplex_colon, std::make_tuple(m, n));
}

",,,,-2,1,0.23221672773361207,code_expression_exchange:None,0.0,0.0,
297,"#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
std::vector<int> large_product(const std::vector<int>& nums1, const std::vector<int>& nums2, int N) {
    std::vector<int> products;
    for (int x : nums1) {
        for (int y : nums2) {
            products.push_back(x * y);
//begin to write code
",328,"
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::vector<int> large_product(const std::vector<int>& nums1, const std::vector<int>& nums2, int N) {
    std::vector<int> products;
    for (int x : nums1) {
        for (int y : nums2) {
            products.push_back(x * y);
        }
    }
    std::sort(products.begin(), products.end(), std::greater<int>());
    std::vector<int> result(products.begin(), products.begin() + N);
    return result;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::vector<int> large_product(const std::vector<int>& nums1, const std::vector<int>& nums2, int N) {
    std::vector<int> products;
    for (int x : nums1) {
        for (int y : nums2) {
            products.push_back(x * y);
        }
    }
    std::sort(products.begin(), products.end(), greater<int>());
    return products;
}

void test_large_product() {
    assert(large_product({1, 2, 3}, {4, 5, 6}, 3) == std::vector<int>({12, 24, 36}));
    assert(large_product({-1, -2, -3}, {-4, -5, -6}, 3) == std::vector<int>({-12, -24, -36}));
    assert(large_product({0, 0, 0}, {0, 0, 0}, 3) == std::vector<int>({0, 0, 0}));
    assert(large_product({10",,,,-2,1,0.23400004307428995,code_expression_exchange:None,0.0,0.0,
298,"#include<iostream>
#include <cassert>
//
int maximum(int a, int b) {
    if (a >= b) {
        return a;
//begin to write code
",131,"#include<iostream>
    

#include <cassert>

//
int maximum(int a, int b) {
    if (a >= b) {
        return a;
    } else {
        return b;
    }
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>

#include<iostream>
#include <cassert>

int maximum(int a, int b) {
    if (a >= b) {
        return a;
    } else {
        return b;
    }
}
","#include<iostream>
#include <cassert>
//
int maximum(int a, int b) {
    if (a >= b) {
        return a;
//begin to write code
","#include<iostream>
    

#include <cassert>

//
int maximum(int a, int b) {
    if (a >= b) {
        return a;
    } else {
        return b;
    }
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

int maximum(int a, int b) {
    if (a >= b) {
        return a;
    } else {
        return b;
    }
}

",1,5,0.6256376743316651,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'#include<iostream>\n    \n\n#include <cassert>\n\n//\nint maximum(int a, int b) {\n    if (a >= b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n\n': [('#include<iostream>\n#include <cassert>\n//\nint maximum(int a, int b) {\n    if (a >= b) {\n        return a;\n//begin to write code\n', '#include<iostream>\n#include <cassert>\n//\nint maximum(int a, int b) {\n    if (a >= b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n', 'bool2int'), ('#include<iostream>\n#include <cassert>\n//\nint maximum(int a, int b) {\n    if (a >= b) {\n        return a;\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\nint maximum(int a, int b) {\n    if (a >= b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n', 'equal_expression_transformation')]}"
299,"#include<iostream>
#include <string>
#include <cassert>
#include <vector>
#include <cctype>
using namespace std;
vector<char> string_to_tuple(const string &str1) {
    vector<char> ret;
    for(char v:str1)
    {   
        if(!isspace(v))
//begin to write code
",262,"#include<iostream>
    
#include <string>
#include <cassert>
#include <vector>
#include <cctype>
using namespace std;

vector<char> string_to_tuple(const string &str1) {
    vector<char> ret;
    for(char v:str1)
    {   
        if(!isspace(v))
        {
            ret.push_back(v);
        }
        
    }
    return ret;
}","#include<iostream>
#include <string>
#include <cassert>
#include <vector>
#include <cctype>
using namespace std;

vector<char> string_to_tuple(const string &str1) {
    vector<char> ret;
    for(char v:str1)
    {   
        if(!isspace(v))
            ret.push_back(v);
    }
    return ret;
}
","#include<iostream>
#include <string>
#include <cassert>
#include <vector>
#include <cctype>
using namespace std;
vector<char> string_to_tuple(const string &str1) {
    vector<char> ret;
    for(char v:str1)
    {   
        if(!isspace(v))
//begin to write code
","#include<iostream>
    
#include <string>
#include <cassert>
#include <vector>
#include <cctype>
using namespace std;

vector<char> string_to_tuple(const string &str1) {
    vector<char> ret;
    for(char v:str1)
    {   
        if(!isspace(v))
        {
            ret.push_back(v);
        }
        
    }
    return ret;
}","
#include<iostream>
#include <string>
#include <cassert>
#include <vector>
#include <cctype>
using namespace std;

vector<char> string_to_tuple(const string &str1) {
    vector<char> ret;
    for(char v:str1)
    {
        if(!isspace(v))
            ret.push_back(v);
    }
    return ret;
}

",-1,21,2.594332989056905,code_expression_exchange:exchange_operators,1.0,0.8911091239186382,"{'#include<iostream>\n    \n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {   \n        if(!isspace(v))\n        {\n            ret.push_back(v);\n        }\n        \n    }\n    return ret;\n}': [('#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {   \n        if(!isspace(v))\n//begin to write code\n', '\n#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {   \n        if(!isspace(v))\n            ret.push_back(v);\n    }\n    return ret;\n}\n\n', 'bool2int'), ('#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {   \n        if(!isspace(v))\n//begin to write code\n', '\n#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1) {\n        if(!isspace(v)) {\n            ret.push_back(v);\n        }\n    }\n    return ret;\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {   \n        if(!isspace(v))\n//begin to write code\n', '#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1) {\n        if(!isspace(v)) {\n            ret.push_back(v);\n        }\n    }\n    return ret;\n}\n', 'more_universe_var_type'), ('#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {   \n        if(!isspace(v))\n//begin to write code\n', '\n#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {\n        if(!isspace(v))\n            ret.push_back(v);\n    }\n    return ret;\n}\n\n', 'bool2int'), ('#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {   \n        if(!isspace(v))\n//begin to write code\n', '\n#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {\n        if(!isspace(v))\n            ret.push_back(v);\n    }\n    return ret;\n}\n\n', 'bool2int'), ('#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {   \n        if(!isspace(v))\n//begin to write code\n', '#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {   \n        if(!isspace(v))\n            ret.push_back(v);\n    }\n    return ret;\n}\n', 'more_universe_var_type'), ('#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {   \n        if(!isspace(v))\n//begin to write code\n', '#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {   \n        if(!isspace(v))\n            ret.push_back(v);\n    }\n    return ret;\n}\n', 'equal_expression_transformation'), ('#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {   \n        if(!isspace(v))\n//begin to write code\n', '#include <iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1) {\n        if(!isspace(v)) {\n            ret.push_back(v);\n        }\n    }\n    return ret;\n}\n', 'equal_expression_transformation'), ('#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {   \n        if(!isspace(v))\n//begin to write code\n', '\n#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {   \n        if(!isspace(v))\n            ret.push_back(v);\n    }\n    return ret;\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {   \n        if(!isspace(v))\n//begin to write code\n', '\n#include<iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\nvector<char> string_to_tuple(const string &str1) {\n    vector<char> ret;\n    for(char v:str1)\n    {\n        if(!isspace(v))\n            ret.push_back(v);\n    }\n    return ret;\n}\n\n', 'exchange_operators')]}"
300,"#include<cassert>
#include<iostream>
int set_left_most_unset_bit(int n) {
    if (!(n & (n + 1))) {
        return n;
    }
    int pos = 0, temp = n, count = 0;
    while (temp) {
        if (!(temp & 1)) {
//begin to write code
",230,"#include<cassert>
#include<iostream>

int set_left_most_unset_bit(int n) {
    if (!(n & (n + 1))) {
        return n;
    }
    int pos = 0, temp = n, count = 0;
    while (temp) {
        if (!(temp & 1)) {
            pos = count;
        }
        count++;
        temp >>= 1;
    }
    return (n | (1 << pos));
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<cassert>

int set_left_most_unset_bit(int n) {
    // Set the leftmost unset bit
    // Start from the least significant bit and move to the right until you find the first set bit
    for (int i = 31; i >= 0; --i) {
        if (!(n & (1 << i))) {
            // Set the bit at position i
            n |= (1 << i);
            break;
        }
    }
    return n;
}

",,,,-2,1,0.23581037918726602,code_expression_exchange:None,0.0,0.0,
301,"#include <iostream>
#include <cmath>
#include <cassert>
double volume_cone(double r, double h) {
    double volume = (1.0/3) * M_PI * r * r * h;
//begin to write code
",167,"
#include <iostream>
#include <cmath>
#include <cassert>

double volume_cone(double r, double h) {
    double volume = (1.0/3) * M_PI * r * r * h;
    return volume;
}


","
#include <iostream>
#include <cmath>
#include <cassert>

double volume_cone(double r, double h) {
    double volume = (1.0/3) * M_PI * r * r * h;
    return volume;
}

",,,,-2,1,0.2119726022084554,code_expression_exchange:None,0.0,0.0,
302,"#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> pos_nos(const std::vector<int>& list1) {
    std::vector<int> result;
    for (int num : list1) {
        if (num >= 0) {
//begin to write code
",218,"
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> pos_nos(const std::vector<int>& list1) {
    std::vector<int> result;
    for (int num : list1) {
        if (num >= 0) {
            result.push_back(num);
        }
    }
    return result;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> pos_nos(const std::vector<int>& list1) {
    std::vector<int> result;
    for (int num : list1) {
        if (num >= 0) {
            result.push_back(num);
        }
    }
    return result;
}

void check() {
    assert(pos_nos({-1, -2, -3}) == std::vector<int>{-1, -2, -3});
    assert(pos_nos({0, 1, 2, 3}) == std::vector<int>{0, 1, 2, 3});
    assert(pos_nos({-5, -6, -7}) == std::vector<int>{-5, -6, -7});
    cout << ""All tests passed successfully."" << endl;
}

",,,,-2,1,0.2159773906071981,code_expression_exchange:None,0.0,0.0,
303,"#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;
int max_sum_rectangular_grid(vector<vector<int>>& grid, int n) {
    int incl = max(grid[0][0], grid[1][0]);
    int excl = 0;
    for (int i = 1; i < n; ++i) {
        int excl_new = max(excl, incl);
//begin to write code
",322,"
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

int max_sum_rectangular_grid(vector<vector<int>>& grid, int n) {
    int incl = max(grid[0][0], grid[1][0]);
    int excl = 0;
    for (int i = 1; i < n; ++i) {
        int excl_new = max(excl, incl);
        incl = excl + max(grid[0][i], grid[1][i]);
        excl = excl_new;
    }
    return max(excl, incl);
}


","#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

int max_sum_rectangular_grid(vector<vector<int>>& grid, int n) {
    int incl = max(grid[0][0], grid[1][0]);
    int excl = 0;
    for (int i = 1; i < n; ++i) {
        int excl_new = max(excl, incl);
        incl = max(incl + grid[i][0], excl);
    }
    return excl;
}
",,,,-2,1,0.19149877230326334,code_expression_exchange:None,0.0,0.0,
304,"#include <iostream>
#include <string>
#include <cassert>
std::string find_Max_Len_Even(const std::string& str) {
    int n = str.length();
    int i = 0;
    int currlen = 0;
    int maxlen = 0;
    int st = -1;
    while (i < n) {
        if (str[i] == ' ') {
            if (currlen % 2 == 0) {
                if (maxlen < currlen) {
                    maxlen = currlen;
                    st = i - currlen;
                }
            }
            currlen = 0;
//begin to write code
",492,"
#include <iostream>
#include <string>
#include <cassert>

std::string find_Max_Len_Even(const std::string& str) {
    int n = str.length();
    int i = 0;
    int currlen = 0;
    int maxlen = 0;
    int st = -1;

    while (i < n) {
        if (str[i] == ' ') {
            if (currlen % 2 == 0) {
                if (maxlen < currlen) {
                    maxlen = currlen;
                    st = i - currlen;
                }
            }
            currlen = 0;
        } else {
            currlen += 1;
        }
        i += 1;
    }

    if (currlen % 2 == 0) {
        if (maxlen < currlen) {
            maxlen = currlen;
            st = i - currlen;
        }
    }
    
    if (st == -1) {
        return ""-1"";
    }

    return str.substr(st, maxlen);
}


","
using namespace std;

#include <iostream>
#include <string>
#include <cassert>

std::string find_Max_Len_Even(const std::string& str) {
    int n = str.length();
    int i = 0;
    int currlen = 0;
    int maxlen = 0;
    int st = -1;
    while (i < n) {
        if (str[i] =='') {
            if (currlen % 2 == 0) {
                if (maxlen < currlen) {
                    maxlen = currlen;
                    st = i - currlen;
                }
            }
            currlen = 0;
        } else {
            currlen++;
        }
    }
    return str.substr(st, maxlen);
}

",,,,-2,1,0.23234949509302774,code_expression_exchange:None,0.0,0.0,
305,"#include <iostream>
#include <vector>
#include <cassert>
int find_last_occurrence(const std::vector<int>& A, int x) {
    int left = 0;
    int right = A.size() - 1;
    int result = -1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (x == A[mid]) {
            result = mid;
//begin to write code
",328,"
#include <iostream>
#include <vector>
#include <cassert>

int find_last_occurrence(const std::vector<int>& A, int x) {
    int left = 0;
    int right = A.size() - 1;
    int result = -1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (x == A[mid]) {
            result = mid;
            left = mid + 1;
        } else if (x < A[mid]) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return result;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <cassert>

int find_last_occurrence(const std::vector<int>& A, int x) {
    int left = 0;
    int right = A.size() - 1;
    int result = -1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (x == A[mid]) {
            result = mid;
        } else if (x < A[mid]) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return result;
}

void test_find_last_occurrence() {
    assert(find_last_occurrence({1, 2, 2, 2, 2, 2}, 2) == 4);
    assert(find_last_occurrence({1, 2, 3, 4, 5}, 3) == 2);
    assert(find_last_occurrence({1, 2, 3, 4, 5, 6}, 6) == 5);
    assert(find_last_occurrence({1, 2, 3, 4,",,,,-2,1,0.23300318717956542,code_expression_exchange:None,0.0,0.0,
306,"#include <iostream>
#include <vector>
#include <string>
#include <cassert>
// 
class Element {
public:
    virtual ~Element() = default;
    virtual Element* clone() const = 0;
    virtual void print() const = 0;
    virtual bool isSameType(const Element& other) const = 0;
    virtual bool isInt() const = 0;
    virtual bool isChar() const = 0;
    virtual int getIntValue() const = 0;
    virtual char getCharValue() const = 0;
};
//  char 
class CharElement : public Element {
public:
    CharElement(char value) : value_(value) {}
    Element* clone() const override {
        return new CharElement(*this);
    }
    void print() const override {
        std::cout << ""Char: "" << value_ << std::endl;
    }
    bool isSameType(const Element& other) const override {
        return other.isChar();
    }
    bool isInt() const override { return false; }
    bool isChar() const override { return true; }
    int getIntValue() const override {
         return 0; 
    }
    char getCharValue() const override { return value_; }
private:
    char value_;
};
//  int 
class IntElement : public Element {
public:
    IntElement(int value) : value_(value) {}
    Element* clone() const override {
        return new IntElement(*this);
    }
    void print() const override {
        std::cout << ""Int: "" << value_ << std::endl;
    }
    bool isSameType(const Element& other) const override {
        return other.isInt();
    }
    bool isInt() const override { return true; }
    bool isChar() const override { return false; }
    int getIntValue() const override { return value_; }
    char getCharValue() const override { 
//begin to write code
",1665,"#include <iostream>
#include <vector>
#include <string>
#include <cassert>

// 
class Element {
public:
    virtual ~Element() = default;
    virtual Element* clone() const = 0;
    virtual void print() const = 0;
    virtual bool isSameType(const Element& other) const = 0;
    virtual bool isInt() const = 0;
    virtual bool isChar() const = 0;
    virtual int getIntValue() const = 0;
    virtual char getCharValue() const = 0;
};

//  char 
class CharElement : public Element {
public:
    CharElement(char value) : value_(value) {}
    Element* clone() const override {
        return new CharElement(*this);
    }
    void print() const override {
        std::cout << ""Char: "" << value_ << std::endl;
    }
    bool isSameType(const Element& other) const override {
        return other.isChar();
    }
    bool isInt() const override { return false; }
    bool isChar() const override { return true; }
    int getIntValue() const override {
         return 0; 
    }
    char getCharValue() const override { return value_; }
private:
    char value_;
};

//  int 
class IntElement : public Element {
public:
    IntElement(int value) : value_(value) {}
    Element* clone() const override {
        return new IntElement(*this);
    }
    void print() const override {
        std::cout << ""Int: "" << value_ << std::endl;
    }
    bool isSameType(const Element& other) const override {
        return other.isInt();
    }
    bool isInt() const override { return true; }
    bool isChar() const override { return false; }
    int getIntValue() const override { return value_; }
    char getCharValue() const override { 
       return 0; 
   }
private:
    int value_;
};

//  vector
std::vector<Element*> modified_encode(const std::vector<Element*>& elements) {
    std::vector<Element*> result;
    size_t i = 0;
    while (i < elements.size()) {
        size_t count = 1;
        while (i + count < elements.size() && elements[i]->isSameType(*elements[i + count]) &&
               ((elements[i]->isInt() && elements[i]->getIntValue() == elements[i + count]->getIntValue()) ||
                (elements[i]->isChar() && elements[i]->getCharValue() == elements[i + count]->getCharValue()))) {
            ++count;
        }
        if (count > 1) {
            if (elements[i]->isInt()) {
                result.push_back(new IntElement(count));
                result.push_back(new IntElement(elements[i]->getIntValue()));
            } else if (elements[i]->isChar()) {
                result.push_back(new IntElement(count));
                result.push_back(new CharElement(elements[i]->getCharValue()));
            }
        } else {
            result.push_back(elements[i]->clone());
        }
        i += count;
    }
    return result;
}

//  vector
bool compareVectors(const std::vector<Element*>& vec1, const std::vector<Element*>& vec2) {
    if (vec1.size() != vec2.size()) return false;
    for (size_t i = 0; i < vec1.size(); ++i) {
        if (vec1[i]->isInt() && vec2[i]->isInt()) {
            if (vec1[i]->getIntValue() != vec2[i]->getIntValue()) return false;
        } else if (vec1[i]->isChar() && vec2[i]->isChar()) {
            if (vec1[i]->getCharValue() != vec2[i]->getCharValue()) return false;
        } else {
            return false;
        }
    }
    return true;
}

//  vector
void printVector(const std::vector<Element*>& vec) {
    for (const auto& element : vec) {
        element->print();
    }
}","
using namespace std;
#include <iostream>
#include <vector>
#include <string>
#include <cassert>
#include <unordered_map>

// 
class Element {
public:
    virtual ~Element() = default;
    virtual Element* clone() const = 0;
    virtual void print() const = 0;
    virtual bool isSameType(const Element& other) const = 0;
    virtual bool isInt() const = 0;
    virtual bool isChar() const = 0;
    virtual int getIntValue() const = 0;
    virtual char getCharValue() const = 0;
};

//  char 
class CharElement : public Element {
public:
    CharElement(char value) : value_(value) {}
    Element* clone() const override {
        return new CharElement(*this);
    }
    void print() const override {
        std::cout << ""Char: "" << value_ << std::endl;
    }
    bool isSameType(const Element& other) const override {
        return other.isChar();
    }
    bool isInt() const override { return false; }
    bool isChar() const override { return true; }
   ",,,,-2,1,0.2324184497197469,code_expression_exchange:None,0.0,0.0,
307,"#include<cassert>
#include <iostream>
#include <algorithm>
using namespace std;
int max_volume(int s) {
    int maxvalue = 0;
    for(int i = 1; i < s; ++i) {
        for(int j = 1; j < s; ++j) {
            int k = s - i - j;
//begin to write code
",249,"#include<cassert>
#include <iostream>
#include <algorithm>
using namespace std;

int max_volume(int s) {
    int maxvalue = 0;
    for(int i = 1; i < s; ++i) {
        for(int j = 1; j < s; ++j) {
            int k = s - i - j;
            maxvalue = max(maxvalue, i * j * k);
        }
    }
    return maxvalue;
}


","
#include <cassert>
#include <iostream>
#include <algorithm>
using namespace std;

int max_volume(int s) {
    int maxvalue = 0;
    for(int i = 1; i < s; ++i) {
        for(int j = 1; j < s; ++j) {
            int k = s - i - j;
            if(k > 0 && k < s) {
                int temp = i * j * k;
                if(temp > maxvalue) {
                    maxvalue = temp;
                }
            }
        }
    }
    return maxvalue;
}

","#include<cassert>
#include <iostream>
#include <algorithm>
using namespace std;
int max_volume(int s) {
    int maxvalue = 0;
    for(int i = 1; i < s; ++i) {
        for(int j = 1; j < s; ++j) {
            int k = s - i - j;
//begin to write code
","#include<cassert>
#include <iostream>
#include <algorithm>
using namespace std;

int max_volume(int s) {
    int maxvalue = 0;
    for(int i = 1; i < s; ++i) {
        for(int j = 1; j < s; ++j) {
            int k = s - i - j;
            maxvalue = max(maxvalue, i * j * k);
        }
    }
    return maxvalue;
}


","#include <iostream>
#include <algorithm>
using namespace std;

int max_volume(int s) {
    int maxvalue = 0;
    for(int i = 1; i < s; ++i) {
        for(int j = 1; j < s; ++j) {
            int k = s - i - j;
            if(k > 0 && k * k * k > maxvalue) {
                maxvalue = k * k * k;
            }
        }
    }
    return maxvalue;
}
",1,3,0.42242031494776405,code_expression_exchange:bool2int,1.0,0.0,"{'#include<cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint max_volume(int s) {\n    int maxvalue = 0;\n    for(int i = 1; i < s; ++i) {\n        for(int j = 1; j < s; ++j) {\n            int k = s - i - j;\n            maxvalue = max(maxvalue, i * j * k);\n        }\n    }\n    return maxvalue;\n}\n\n\n': [('#include<cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint max_volume(int s) {\n    int maxvalue = 0;\n    for(int i = 1; i < s; ++i) {\n        for(int j = 1; j < s; ++j) {\n            int k = s - i - j;\n//begin to write code\n', '#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint max_volume(int s) {\n    int maxvalue = 0;\n    for(int i = 1; i < s; ++i) {\n        for(int j = 1; j < s; ++j) {\n            int k = s - i - j;\n            if(k > 0 && k * k * k > maxvalue) {\n                maxvalue = k * k * k;\n            }\n        }\n    }\n    return maxvalue;\n}\n', 'bool2int')]}"
308,"#include <iostream>
#include <regex>
#include <vector>
#include <cassert>
using namespace std;
vector<string> find_long_word(const string& text) {
    regex word_regex(R""(\b\w{5}\b)"");
    vector<string> words;
    auto words_begin = sregex_iterator(text.begin(), text.end(), word_regex);
    auto words_end = sregex_iterator();
//begin to write code
",351,"#include <iostream>
#include <regex>
#include <vector>
#include <cassert>
using namespace std;

vector<string> find_long_word(const string& text) {
    regex word_regex(R""(\b\w{5}\b)"");
    vector<string> words;
    auto words_begin = sregex_iterator(text.begin(), text.end(), word_regex);
    auto words_end = sregex_iterator();
    for (sregex_iterator i = words_begin; i != words_end; ++i) {
        words.push_back((*i).str());
    }
    return words;
}","
#include <iostream>
#include <regex>
#include <vector>
#include <cassert>
using namespace std;

vector<string> find_long_word(const string& text) {
    regex word_regex(R""(\b\w{5}\b)"");
    vector<string> words;
    auto words_begin = sregex_iterator(text.begin(), text.end(), word_regex);
    auto words_end = sregex_iterator();
    for (auto it = words_begin; it!= words_end; ++it) {
        words.push_back(it->str());
    }
    return words;
}

","#include <iostream>
#include <regex>
#include <vector>
#include <cassert>
using namespace std;
vector<string> find_long_word(const string& text) {
    regex word_regex(R""(\b\w{5}\b)"");
    vector<string> words;
    auto words_begin = sregex_iterator(text.begin(), text.end(), word_regex);
    auto words_end = sregex_iterator();
//begin to write code
","#include <iostream>
#include <regex>
#include <vector>
#include <cassert>
using namespace std;

vector<string> find_long_word(const string& text) {
    regex word_regex(R""(\b\w{5}\b)"");
    vector<string> words;
    auto words_begin = sregex_iterator(text.begin(), text.end(), word_regex);
    auto words_end = sregex_iterator();
    for (sregex_iterator i = words_begin; words_end != i; ++i) {
        words.push_back((*i).str());
    }
    return words;
}","
#include <iostream>
#include <regex>
#include <vector>
#include <cassert>
using namespace std;
vector<string> find_long_word(const string& text) {
    regex word_regex(R""(\b\w{5}\b)"");
    vector<string> words;
    auto words_begin = sregex_iterator(text.begin(), text.end(), word_regex);
    auto words_end = sregex_iterator();
    for (auto it = words_begin; it!= words_end; ++it) {
        words.push_back(*it);
    }
    return words;
}

",1,3,0.5666741132736206,code_expression_exchange:exchange_operators,1.0,0.0,"{'#include <iostream>\n#include <regex>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<string> find_long_word(const string& text) {\n    regex word_regex(R""(\\b\\w{5}\\b)"");\n    vector<string> words;\n    auto words_begin = sregex_iterator(text.begin(), text.end(), word_regex);\n    auto words_end = sregex_iterator();\n    for (sregex_iterator i = words_begin; words_end != i; ++i) {\n        words.push_back((*i).str());\n    }\n    return words;\n}': [('#include <iostream>\n#include <regex>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<string> find_long_word(const string& text) {\n    regex word_regex(R""(\\b\\w{5}\\b)"");\n    vector<string> words;\n    auto words_begin = sregex_iterator(text.begin(), text.end(), word_regex);\n    auto words_end = sregex_iterator();\n//begin to write code\n', '\n#include <iostream>\n#include <regex>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<string> find_long_word(const string& text) {\n    regex word_regex(R""(\\b\\w{5}\\b)"");\n    vector<string> words;\n    auto words_begin = sregex_iterator(text.begin(), text.end(), word_regex);\n    auto words_end = sregex_iterator();\n    for (auto it = words_begin; it!= words_end; ++it) {\n        words.push_back(*it);\n    }\n    return words;\n}\n\n', 'exchange_operators')]}"
309,"#include <iostream>
#include <cassert>
int sum_difference(int n) {
    int sumofsquares = 0;
    int squareofsum = 0;
    for (int num = 1; num <= n; num++) {
        sumofsquares += num * num;
//begin to write code
",216,"
#include <iostream>
#include <cassert>

int sum_difference(int n) {
    int sumofsquares = 0;
    int squareofsum = 0;
    for (int num = 1; num <= n; num++) {
        sumofsquares += num * num;
        squareofsum += num;
    }
    squareofsum = squareofsum * squareofsum;
    return squareofsum - sumofsquares;
}


","
using namespace std;
#include <iostream>

int sum_difference(int n) {
    int sumofsquares = 0;
    int squareofsum = 0;
    for (int num = 1; num <= n; num++) {
        sumofsquares += num * num;
        squareofsum += num * num;
    }
    return squareofsum - sumofsquares;
}

",,,,-2,1,0.18454176982243856,code_expression_exchange:None,0.0,0.0,
310,"#include <iostream>
#include <string>
#include <cassert>
std::string find_demlo(const std::string& s) {
    int l = s.size();
    std::string res = """";
    for (int i = 1; i <= l; ++i) {
        res += std::to_string(i);
//begin to write code
",243,"
#include <iostream>
#include <string>
#include <cassert>

std::string find_demlo(const std::string& s) {
    int l = s.size();
    std::string res = """";
    for (int i = 1; i <= l; ++i) {
        res += std::to_string(i);
    }
    for (int i = l-1; i > 0; --i) {
        res += std::to_string(i);
    }
    return res;
}


","#include <iostream>
#include <string>
#include <cassert>
std::string find_demlo(const std::string& s) {
    int l = s.size();
    std::string res = """";
    for (int i = 1; i <= l; ++i) {
        res += std::to_string(i);
    }
    return res;
}
",,,,-2,1,0.17346070607503256,code_expression_exchange:None,0.0,0.0,
311,"#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
std::vector<int> position_min(const std::vector<int>& list1) {
    int min_val = *std::min_element(list1.begin(), list1.end());
    std::vector<int> min_result;
    for (int i = 0; i < list1.size(); i++) {
        if (list1[i] == min_val) {
//begin to write code
",341,"
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::vector<int> position_min(const std::vector<int>& list1) {
    int min_val = *std::min_element(list1.begin(), list1.end());
    std::vector<int> min_result;
    for (int i = 0; i < list1.size(); i++) {
        if (list1[i] == min_val) {
            min_result.push_back(i);
        }
    }
    return min_result;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::vector<int> position_min(const std::vector<int>& list1) {
    int min_val = *std::min_element(list1.begin(), list1.end());
    std::vector<int> min_result;
    for (int i = 0; i < list1.size(); i++) {
        if (list1[i] == min_val) {
            min_result.push_back(i);
        }
    }
    return min_result;
}

","#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
std::vector<long> position_min(const std::vector<int>& list1) {
    int min_val = *std::min_element(list1.begin(), list1.end());
    std::vector<int> min_result;
    for (int i = 0; i < list1.size(); i++) {
        if (list1[i] == min_val) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::vector<long> position_min(const std::vector<int>& list1) {
    int min_val = *std::min_element(list1.begin(), list1.end());
    std::vector<int> min_result;
    for (int i = 0; i < list1.size(); i++) {
        if (list1[i] == min_val) {
            min_result.push_back(i);
        }
    }
    return min_result;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::vector<long> position_min(const std::vector<int>& list1) {
    int min_val = *std::min_element(list1.begin(), list1.end());
    std::vector<long> min_result;
    for (int i = 0; i < list1.size(); i++) {
        if (list1[i] == min_val) {
            min_result.push_back(i);
        }
    }
    return min_result;
}

",1,3,0.48614423274993895,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<long> position_min(const std::vector<int>& list1) {\n    int min_val = *std::min_element(list1.begin(), list1.end());\n    std::vector<int> min_result;\n    for (int i = 0; i < list1.size(); i++) {\n        if (list1[i] == min_val) {\n            min_result.push_back(i);\n        }\n    }\n    return min_result;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nstd::vector<long> position_min(const std::vector<int>& list1) {\n    int min_val = *std::min_element(list1.begin(), list1.end());\n    std::vector<int> min_result;\n    for (int i = 0; i < list1.size(); i++) {\n        if (list1[i] == min_val) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<long> position_min(const std::vector<int>& list1) {\n    int min_val = *std::min_element(list1.begin(), list1.end());\n    std::vector<long> min_result;\n    for (int i = 0; i < list1.size(); i++) {\n        if (list1[i] == min_val) {\n            min_result.push_back(i);\n        }\n    }\n    return min_result;\n}\n\n', 'more_universe_var_type')]}"
312,"#include <iostream>
#include <vector>
#include <cassert>
void right_rotate(std::vector<int>& arr, int n, int out_of_place, int cur) {
    int temp = arr[cur];
    for (int i = cur; i > out_of_place; --i) {
        arr[i] = arr[i - 1];
    }
    arr[out_of_place] = temp;
}
std::vector<int> re_arrange(std::vector<int>& arr, int n) {
    int out_of_place = -1;
    for (int index = 0; index < n; ++index) {
        if (out_of_place >= 0) {
            if ((arr[index] >= 0 && arr[out_of_place] < 0) ||
                (arr[index] < 0 && arr[out_of_place] >= 0)) {
                right_rotate(arr, n, out_of_place, index);
                if (index - out_of_place > 2) {
//begin to write code
",692,"
#include <iostream>
#include <vector>
#include <cassert>

void right_rotate(std::vector<int>& arr, int n, int out_of_place, int cur) {
    int temp = arr[cur];
    for (int i = cur; i > out_of_place; --i) {
        arr[i] = arr[i - 1];
    }
    arr[out_of_place] = temp;
}

std::vector<int> re_arrange(std::vector<int>& arr, int n) {
    int out_of_place = -1;
    for (int index = 0; index < n; ++index) {
        if (out_of_place >= 0) {
            if ((arr[index] >= 0 && arr[out_of_place] < 0) ||
                (arr[index] < 0 && arr[out_of_place] >= 0)) {
                right_rotate(arr, n, out_of_place, index);
                if (index - out_of_place > 2) {
                    out_of_place += 2;
                } else {
                    out_of_place = -1;
                }
            }
        }
        if (out_of_place == -1) {
            if ((arr[index] >= 0 && index % 2 == 0) ||
                (arr[index] < 0 && index % 2 == 1)) {
                out_of_place = index;
            }
        }
    }
    return arr;
}


","
#include <iostream>
#include <vector>
#include <cassert>

void right_rotate(std::vector<int>& arr, int n, int out_of_place, int cur) {
    int temp = arr[cur];
    for (int i = cur; i > out_of_place; --i) {
        arr[i] = arr[i - 1];
    }
    arr[out_of_place] = temp;
}

std::vector<int> re_arrange(std::vector<int>& arr, int n) {
    int out_of_place = -1;
    for (int index = 0; index < n; ++index) {
        if (out_of_place >= 0) {
            if ((arr[index] >= 0 && arr[out_of_place] < 0) ||
                (arr[index] < 0 && arr[out_of_place] >= 0)) {
                right_rotate(arr, n, out_of_place, index);
                if (index - out_of_place > 2) {
                    //begin to write code
                }
            }
        }
    }
    return arr;
}

",,,,-2,1,0.24097281694412231,code_expression_exchange:None,0.0,0.0,
313,"#include <iostream>
#include <vector>
#include <cassert>
std::pair<int, int> sum_of_alternates(const std::vector<int>& test_vector) {
    int sum1 = 0;
    int sum2 = 0;
    for (size_t idx = 0; idx < test_vector.size(); ++idx) {
        if (idx % 2 == 1) {
            sum1 += test_vector[idx];
//begin to write code
",318,"
#include <iostream>
#include <vector>
#include <cassert>

std::pair<int, int> sum_of_alternates(const std::vector<int>& test_vector) {
    int sum1 = 0;
    int sum2 = 0;
    for (size_t idx = 0; idx < test_vector.size(); ++idx) {
        if (idx % 2 == 1) {
            sum1 += test_vector[idx];
        } else {
            sum2 += test_vector[idx];
        }
    }
    return {sum1, sum2};
}


","
#include <iostream>
#include <vector>
#include <cassert>
#include <utility>

std::pair<int, int> sum_of_alternates(const std::vector<int>& test_vector) {
    int sum1 = 0;
    int sum2 = 0;
    for (size_t idx = 0; idx < test_vector.size(); ++idx) {
        if (idx % 2 == 1) {
            sum1 += test_vector[idx];
        } else {
            sum2 += test_vector[idx];
        }
    }
    return {sum1, sum2};
}

","#include <iostream>
#include <vector>
#include <cassert>
std::pair<int, long> sum_of_alternates(const std::vector<int>& test_vector) {
    int sum1 = 0;
    int sum2 = 0;
    for (size_t idx = 0; idx < test_vector.size(); ++idx) {
        if (1 == idx % 2) {
            sum1 += test_vector[idx];
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

std::pair<int, long> sum_of_alternates(const std::vector<int>& test_vector) {
    int sum1 = 0;
    int sum2 = 0;
    for (size_t idx = 0; idx < test_vector.size(); ++idx) {
        if (1 == idx % 2) {
            sum1 += test_vector[idx];
        } else {
            sum2 += test_vector[idx];
        }
    }
    return {sum1, sum2};
}


","
#include <iostream>
#include <vector>
#include <cassert>

std::pair<int, long> sum_of_alternates(const std::vector<int>& test_vector) {
    int sum1 = 0;
    int sum2 = 0;
    for (size_t idx = 0; idx < test_vector.size(); ++idx) {
        if (idx % 2 == 0) {
            sum1 += test_vector[idx];
        } else {
            sum2 += test_vector[idx];
        }
    }
    return {sum1, sum2};
}

",1,5,0.7884833137194316,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::pair<int, long> sum_of_alternates(const std::vector<int>& test_vector) {\n    int sum1 = 0;\n    int sum2 = 0;\n    for (size_t idx = 0; idx < test_vector.size(); ++idx) {\n        if (1 == idx % 2) {\n            sum1 += test_vector[idx];\n        } else {\n            sum2 += test_vector[idx];\n        }\n    }\n    return {sum1, sum2};\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nstd::pair<int, int> sum_of_alternates(const std::vector<int>& test_vector) {\n    int sum1 = 0;\n    int sum2 = 0;\n    for (size_t idx = 0; idx < test_vector.size(); ++idx) {\n        if (1 == idx % 2) {\n            sum1 += test_vector[idx];\n//begin to write code\n', '\nusing namespace std;\n#include <vector>\n#include <cassert>\n\nstd::pair<int, int> sum_of_alternates(const std::vector<int>& test_vector) {\n    int sum1 = 0;\n    int sum2 = 0;\n    for (size_t idx = 0; idx < test_vector.size(); ++idx) {\n        if (1 == idx % 2) {\n            sum1 += test_vector[idx];\n        } else {\n            sum2 += test_vector[idx];\n        }\n    }\n    return {sum1, sum2};\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nstd::pair<int, long> sum_of_alternates(const std::vector<int>& test_vector) {\n    int sum1 = 0;\n    int sum2 = 0;\n    for (size_t idx = 0; idx < test_vector.size(); ++idx) {\n        if (1 == idx % 2) {\n            sum1 += test_vector[idx];\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::pair<int, long> sum_of_alternates(const std::vector<int>& test_vector) {\n    int sum1 = 0;\n    int sum2 = 0;\n    for (size_t idx = 0; idx < test_vector.size(); ++idx) {\n        if (idx % 2 == 0) {\n            sum1 += test_vector[idx];\n        } else {\n            sum2 += test_vector[idx];\n        }\n    }\n    return {sum1, sum2};\n}\n\n', 'more_universe_var_type')]}"
314,"#include <iostream>
#include <cmath>
#include <algorithm>
#include <cassert>
int get_Min_Squares(int n) {
    if (n <= 3) {
        return n;
    }
    int res = n;
    for (int x = 1; x <= n; ++x) {
        int temp = x * x;
//begin to write code
",248,"
#include <iostream>
#include <cmath>
#include <algorithm>
#include <cassert>

int get_Min_Squares(int n) {
    if (n <= 3) {
        return n;
    }
    int res = n;
    for (int x = 1; x <= n; ++x) {
        int temp = x * x;
        if (temp > n) {
            break;
        } else {
            res = std::min(res, 1 + get_Min_Squares(n - temp));
        }
    }
    return res;
}


","
#include <iostream>
#include <cmath>
#include <algorithm>
#include <cassert>
#include <vector>

int get_Min_Squares(int n) {
    if (n <= 3) {
        return n;
    }
    int res = n;
    for (int x = 1; x <= n; ++x) {
        int temp = x * x;
        //begin to write code
        if (temp == n) {
            return x;
        }
    }
    return res;
}

",,,,-2,1,0.2400856653849284,code_expression_exchange:None,0.0,0.0,
315,"#include <iostream>
#include <sstream>
#include <unordered_map>
#include <cassert>
#include <vector>
using namespace std;
string most_occurrences(vector<string> test_list) {
    unordered_map<string, int> temp;
    for (auto& sub : test_list) {
        stringstream ss(sub);
        string wrd;
        while (ss >> wrd) {
            temp[wrd]++;
        }
    }
//begin to write code
",386,"#include <iostream>
#include <sstream>
#include <unordered_map>
#include <cassert>
#include <vector>
using namespace std;

string most_occurrences(vector<string> test_list) {
    unordered_map<string, int> temp;
    for (auto& sub : test_list) {
        stringstream ss(sub);
        string wrd;
        while (ss >> wrd) {
            temp[wrd]++;
        }
    }
    string res = """";
    int max_count = 0;
    for (auto& pair : temp) {
        if (pair.second > max_count) {
            max_count = pair.second;
            res = pair.first;
        }
    }
    return res;
}","
#include <iostream>
#include <sstream>
#include <unordered_map>
#include <cassert>
#include <vector>
using namespace std;

string most_occurrences(vector<string> test_list) {
    unordered_map<string, int> temp;
    for (auto& sub : test_list) {
        stringstream ss(sub);
        string wrd;
        while (ss >> wrd) {
            temp[wrd]++;
        }
    }

    string result = """";
    int max_count = 0;
    for (const auto& pair : temp) {
        if (pair.second > max_count) {
            max_count = pair.second;
            result = pair.first;
        }
    }

    return result;
}

",,,,-2,1,0.2179414709409078,code_expression_exchange:None,0.0,0.0,
316,"#include<cassert>
#include <iostream>
#include <assert.h>
bool check_isosceles(int x, int y, int z) {
    if (x == y || y == z || z == x) {
        return true;
//begin to write code
",183,"#include<cassert>
#include <iostream>
#include <assert.h>

bool check_isosceles(int x, int y, int z) {
    if (x == y || y == z || z == x) {
        return true;
    } else {
        return false;
    }
}


","
using namespace std;

#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

bool check_isosceles(int x, int y, int z) {
    if (x == y || y == z || z == x) {
        return true;
    }
    return false;
}

",,,,-2,1,0.20355572700500488,code_expression_exchange:None,0.0,0.0,
317,"#include<iostream>
#include <vector>
#include <cassert>
using namespace std;
vector<int> rotate_left(vector<int> list1, int m, int n) {
    vector<int> result;
    result.insert(result.end(), list1.begin() + m, list1.end());
//begin to write code
",247,"#include<iostream>
    

#include <vector>
#include <cassert>

using namespace std;

vector<int> rotate_left(vector<int> list1, int m, int n) {
    vector<int> result;
    result.insert(result.end(), list1.begin() + m, list1.end());
    result.insert(result.end(), list1.begin(), list1.begin() + n);
    return result;
}


","
#include<iostream>
#include <vector>
#include <cassert>
using namespace std;

vector<int> rotate_left(vector<int> list1, int m, int n) {
    // Rotate the list by m items to the left direction
    if (m == 0) return list1; // No rotation needed if m is 0

    // Calculate the effective number of rotations needed
    int effective_m = m % list1.size();

    // Perform the rotation
    vector<int> result(list1.size());
    for (int i = 0; i < effective_m; ++i) {
        result[i] = list1[(i + effective_m) % list1.size()];
    }
    for (int i = effective_m; i < list1.size(); ++i) {
        result[i] = list1[(i - effective_m) % list1.size()];
    }

    return result;
}

",,,,-2,1,0.2491116444269816,code_expression_exchange:None,0.0,0.0,
318,"#include<iostream>
#include<vector>
#include<cassert>
int neg_count(const std::vector<int>& list) {
    int neg_count = 0;
    for (int num : list) {
        if (num <= 0) {
//begin to write code
",196,"
#include<iostream>
#include<vector>
#include<cassert>

int neg_count(const std::vector<int>& list) {
    int neg_count = 0;
    for (int num : list) {
        if (num <= 0) {
            neg_count += 1;
        }
    }
    return neg_count;
}


","
using namespace std;

#include<iostream>
#include<vector>
#include<cassert>

int neg_count(const std::vector<int>& list) {
    int neg_count = 0;
    for (int num : list) {
        if (num <= 0) {
            neg_count++;
        }
    }
    return neg_count;
}

","#include<iostream>
#include<vector>
#include<cassert>
long neg_count(const std::vector<long>& list) {
    long neg_count = 0;
    for (long num : list) {
        if (num <= 0) {
//begin to write code
","
#include<iostream>
#include<vector>
#include<cassert>

long neg_count(const std::vector<long>& list) {
    long neg_count = 0;
    for (long num : list) {
        if (num <= 0) {
            neg_count += 1;
        }
    }
    return neg_count;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

long neg_count(const std::vector<long>& list) {
    long neg_count = 0;
    for (long num : list) {
        if (num <= 0) {
            neg_count++;
        }
    }
    return neg_count;
}

",1,17,2.245713182290395,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include<iostream>\n#include<vector>\n#include<cassert>\n\nlong neg_count(const std::vector<long>& list) {\n    long neg_count = 0;\n    for (long num : list) {\n        if (num <= 0) {\n            neg_count += 1;\n        }\n    }\n    return neg_count;\n}\n\n\n': [('#include<iostream>\n#include<vector>\n#include<cassert>\nint neg_count(const std::vector<int>& list) {\n    int neg_count = 0;\n    for (long num : list) {\n        if (num <= 0) {\n//begin to write code\n', 'using namespace std;\n#include<vector>\n#include<cassert>\n\nint neg_count(const std::vector<int>& list) {\n    int neg_count = 0;\n    for (long num : list) {\n        if (num <= 0) {\n            neg_count++;\n        }\n    }\n    return neg_count;\n}\n', 'more_universe_var_type'), ('#include<iostream>\n#include<vector>\n#include<cassert>\nint neg_count(const std::vector<long>& list) {\n    int neg_count = 0;\n    for (long num : list) {\n        if (num <= 0) {\n//begin to write code\n', '\nusing namespace std;\n#include<vector>\n#include<cassert>\n\nint neg_count(const std::vector<long>& list) {\n    int neg_count = 0;\n    for (long num : list) {\n        if (num <= 0) {\n            ++neg_count;\n        }\n    }\n    return neg_count;\n}\n\n', 'more_universe_var_type'), ('#include<iostream>\n#include<vector>\n#include<cassert>\nint neg_count(const std::vector<long>& list) {\n    int neg_count = 0;\n    for (long num : list) {\n        if (num <= 0) {\n//begin to write code\n', 'using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n\n#include<iostream>\n#include<vector>\n#include<cassert>\nint neg_count(const std::vector<long>& list) {\n    int neg_count = 0;\n    for (long num : list) {\n        if (num <= 0) {\n            neg_count++;\n        }\n    }\n    return neg_count;\n}\n', 'exchange_operators'), ('#include<iostream>\n#include<vector>\n#include<cassert>\nint neg_count(const std::vector<long>& list) {\n    long neg_count = 0;\n    for (long num : list) {\n        if (num <= 0) {\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<assert.h>\n\nint neg_count(const std::vector<long>& list) {\n    long neg_count = 0;\n    for (long num : list) {\n        if (num <= 0) {\n            ++neg_count;\n        }\n    }\n    return neg_count;\n}\n\n', 'more_universe_var_type'), ('#include<iostream>\n#include<vector>\n#include<cassert>\nlong neg_count(const std::vector<long>& list) {\n    long neg_count = 0;\n    for (long num : list) {\n        if (num <= 0) {\n//begin to write code\n', 'using namespace std;\n#include<vector>\n#include<cassert>\n\nlong neg_count(const std::vector<long>& list) {\n    long neg_count = 0;\n    for (long num : list) {\n        if (num <= 0) {\n            ++neg_count;\n        }\n    }\n    return neg_count;\n}\n', 'more_universe_var_type'), ('#include<iostream>\n#include<vector>\n#include<cassert>\nlong neg_count(const std::vector<long>& list) {\n    long neg_count = 0;\n    for (long num : list) {\n        if (num <= 0) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong neg_count(const std::vector<long>& list) {\n    long neg_count = 0;\n    for (long num : list) {\n        if (num <= 0) {\n            ++neg_count;\n        }\n    }\n    return neg_count;\n}\n\n', 'more_universe_var_type'), ('#include<iostream>\n#include<vector>\n#include<cassert>\nlong neg_count(const std::vector<long>& list) {\n    long neg_count = 0;\n    for (long num : list) {\n        if (num <= 0) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong neg_count(const std::vector<long>& list) {\n    long neg_count = 0;\n    for (long num : list) {\n        if (num <= 0) {\n            ++neg_count;\n        }\n    }\n    return neg_count;\n}\n\n', 'more_universe_var_type'), ('#include<iostream>\n#include<vector>\n#include<cassert>\nlong neg_count(const std::vector<long>& list) {\n    long neg_count = 0;\n    for (long num : list) {\n        if (num <= 0) {\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\nlong neg_count(const std::vector<long>& list) {\n    long neg_count = 0;\n    for (long num : list) {\n        if (num <= 0) {\n            neg_count++;\n        }\n    }\n    return neg_count;\n}\n\n', 'bool2int')]}"
319,"#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <cassert>
using namespace std;
vector<string> find_char(const string& text) {
    regex word_regex(R""(\b\w{3,5}\b)"");
    auto words_begin = sregex_iterator(text.begin(), text.end(), word_regex);
    auto words_end = sregex_iterator();
    vector<string> matches;
//begin to write code
",368,"#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <cassert>
using namespace std;

vector<string> find_char(const string& text) {
    regex word_regex(R""(\b\w{3,5}\b)"");
    auto words_begin = sregex_iterator(text.begin(), text.end(), word_regex);
    auto words_end = sregex_iterator();

    vector<string> matches;
    for (sregex_iterator i = words_begin; i != words_end; ++i) {
        matches.push_back((*i).str());
    }
    return matches;
}","
#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <cassert>
using namespace std;

vector<string> find_char(const string& text) {
    regex word_regex(R""(\b\w{3,5}\b)"");
    auto words_begin = sregex_iterator(text.begin(), text.end(), word_regex);
    auto words_end = sregex_iterator();
    vector<string> matches;
    for (auto word_it = words_begin; word_it!= words_end; ++word_it) {
        string word = *word_it;
        if (word.length() == 3 && word.length() == 4 && word.length() == 5) {
            matches.push_back(word);
        }
    }
    return matches;
}

",,,,-2,1,0.2300924857457479,code_expression_exchange:None,0.0,0.0,
320,"#include<cassert>
#include <iostream>
int count_unset_bits(int n) {
    int count = 0;
    int x = 1;
    while(x < n + 1) {
        if ((x & n) == 0) {
//begin to write code
",175,"#include<cassert>
#include <iostream>

int count_unset_bits(int n) {
    int count = 0;
    int x = 1;
    while(x < n + 1) {
        if ((x & n) == 0) {
            count += 1;
        }
        x = x << 1;
    }
    return count;
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<cassert>

int count_unset_bits(int n) {
    int count = 0;
    int x = 1;
    while(x < n + 1) {
        if ((x & n) == 0) {
            count++;
        }
        x <<= 1; // Move left by 1 bit
    }
    return count;
}
","#include<cassert>
#include <iostream>
int count_unset_bits(long n) {
    int count = 0;
    int x = 1;
    while(x < n + 1) {
        if ((x & n) == 0) {
//begin to write code
","#include<cassert>
#include <iostream>

int count_unset_bits(long n) {
    int count = 0;
    int x = 1;
    while(x < n + 1) {
        if ((x & n) == 0) {
            count += 1;
        }
        x = x << 1;
    }
    return count;
}


","
#include <iostream>

using namespace std;

int count_unset_bits(long n) {
    int count = 0;
    int x = 1;
    while (x < n + 1) {
        if ((x & n) == 0) {
            count++;
        }
        x <<= 1; // Move to the next bit
    }
    return count;
}

",1,3,0.44800129731496174,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<cassert>\n#include <iostream>\n\nint count_unset_bits(long n) {\n    int count = 0;\n    int x = 1;\n    while(x < n + 1) {\n        if ((x & n) == 0) {\n            count += 1;\n        }\n        x = x << 1;\n    }\n    return count;\n}\n\n\n': [('#include<cassert>\n#include <iostream>\nint count_unset_bits(long n) {\n    int count = 0;\n    int x = 1;\n    while(x < n + 1) {\n        if ((x & n) == 0) {\n//begin to write code\n', '\n#include <iostream>\n\nusing namespace std;\n\nint count_unset_bits(long n) {\n    int count = 0;\n    int x = 1;\n    while (x < n + 1) {\n        if ((x & n) == 0) {\n            count++;\n        }\n        x <<= 1; // Move to the next bit\n    }\n    return count;\n}\n\n', 'more_universe_var_type')]}"
321,"#include <iostream>
#include <map>
#include <cassert>
std::map<char, int> char_frequency(std::string str1) {
    std::map<char, int> dict;
    for (char n : str1) {
        if (dict.find(n) != dict.end()) {
            dict[n] += 1;
//begin to write code
",255,"
#include <iostream>
#include <map>
#include <cassert>

std::map<char, int> char_frequency(std::string str1) {
    std::map<char, int> dict;
    for (char n : str1) {
        if (dict.find(n) != dict.end()) {
            dict[n] += 1;
        } else {
            dict[n] = 1;
        }
    }
    return dict;
}


","
#include <iostream>
#include <map>
#include <cassert>
std::map<char, int> char_frequency(std::string str1) {
    std::map<char, int> dict;
    for (char n : str1) {
        dict[n]++;
    }
    return dict;
}

","#include <iostream>
#include <map>
#include <cassert>
std::map<char, long> char_frequency(std::string str1) {
    std::map<char, int> dict;
    for (char n : str1) {
        if (dict.find(n) != dict.end()) {
            dict[n] = dict[n] + (1);
//begin to write code
","
#include <iostream>
#include <map>
#include <cassert>

std::map<char, long> char_frequency(std::string str1) {
    std::map<char, int> dict;
    for (char n : str1) {
        if (dict.find(n) != dict.end()) {
            dict[n] = dict[n] + (1);
        } else {
            dict[n] = 1;
        }
    }
    return dict;
}


","
#include <iostream>
#include <map>
#include <cassert>

std::map<char, long> char_frequency(std::string str1) {
    std::map<char, int> dict;
    for (char n : str1) {
        dict[n]++;
    }
    return dict;
}

",1,7,1.0080623825391133,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <map>\n#include <cassert>\n\nstd::map<char, long> char_frequency(std::string str1) {\n    std::map<char, int> dict;\n    for (char n : str1) {\n        if (dict.find(n) != dict.end()) {\n            dict[n] = dict[n] + (1);\n        } else {\n            dict[n] = 1;\n        }\n    }\n    return dict;\n}\n\n\n': [('#include <iostream>\n#include <map>\n#include <cassert>\nstd::map<char, int> char_frequency(std::string str1) {\n    std::map<char, int> dict;\n    for (char n : str1) {\n        if (dict.find(n) != dict.end()) {\n            dict[n] = dict[n] + (1);\n//begin to write code\n', '#include <iostream>\n#include <map>\n#include <cassert>\nstd::map<char, int> char_frequency(std::string str1) {\n    std::map<char, int> dict;\n    for (char n : str1) {\n        dict[n]++;\n    }\n    return dict;\n}\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <map>\n#include <cassert>\nstd::map<char, int> char_frequency(std::string str1) {\n    std::map<char, int> dict;\n    for (char n : str1) {\n        if (dict.find(n) != dict.end()) {\n            dict[n] = dict[n] + (1);\n//begin to write code\n', '\n#include <iostream>\n#include <map>\n#include <cassert>\n\nstd::map<char, int> char_frequency(std::string str1) {\n    std::map<char, int> dict;\n    for (char n : str1) {\n        dict[n]++;\n    }\n    return dict;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <map>\n#include <cassert>\nstd::map<char, long> char_frequency(std::string str1) {\n    std::map<char, int> dict;\n    for (char n : str1) {\n        if (dict.find(n) != dict.end()) {\n            dict[n] = dict[n] + (1);\n//begin to write code\n', '\n#include <iostream>\n#include <map>\n#include <cassert>\n\nstd::map<char, long> char_frequency(std::string str1) {\n    std::map<char, int> dict;\n    for (char n : str1) {\n        dict[n]++;\n    }\n    return dict;\n}\n\n', 'more_universe_var_type')]}"
322,"#include<iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;
// Sorting function based on the second element of the pairs
void Sort(vector<pair<string, int>>& sub_li) {
    sort(sub_li.begin(), sub_li.end(), [](const pair<string, int>& a, const pair<string, int>& b) {
//begin to write code
",346,"#include<iostream>
    

#include <vector>
#include <string>
#include <algorithm>
#include <cassert>

using namespace std;

// Sorting function based on the second element of the pairs
void Sort(vector<pair<string, int>>& sub_li) {
    sort(sub_li.begin(), sub_li.end(), [](const pair<string, int>& a, const pair<string, int>& b) {
        return a.second < b.second;
    });
}


","
#include<iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;

// Function to sort a list according to the second element of the pairs
void Sort(vector<pair<string, int>>& sub_li) {
    sort(sub_li.begin(), sub_li.end(), [](const pair<string, int>& a, const pair<string, int>& b) {
        return a.second < b.second; // Sort by the second element
    });
}

","#include<iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;
// Sorting function based on the second element of the pairs
void Sort(vector<pair<string, long>>& sub_li) {
    sort(sub_li.begin(), sub_li.end(), [](const pair<string, long>& a, const pair<string, int>& b) {
//begin to write code
","#include<iostream>
    

#include <vector>
#include <string>
#include <algorithm>
#include <cassert>

using namespace std;

// Sorting function based on the second element of the pairs
void Sort(vector<pair<string, long>>& sub_li) {
    sort(sub_li.begin(), sub_li.end(), [](const pair<string, long>& a, const pair<string, int>& b) {
        return a.second < b.second;
    });
}


","
#include<iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;

// Sorting function based on the second element of the pairs
void Sort(vector<pair<string, long>>& sub_li) {
    sort(sub_li.begin(), sub_li.end(), [](const pair<string, long>& a, const pair<string, int>& b) {
        return a.second < b.second; // Sort by second element in descending order
    });
}

",1,5,0.7601171294848125,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<iostream>\n    \n\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\n// Sorting function based on the second element of the pairs\nvoid Sort(vector<pair<string, long>>& sub_li) {\n    sort(sub_li.begin(), sub_li.end(), [](const pair<string, long>& a, const pair<string, int>& b) {\n        return a.second < b.second;\n    });\n}\n\n\n': [('#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n// Sorting function based on the second element of the pairs\nvoid Sort(vector<pair<string, int>>& sub_li) {\n    sort(sub_li.begin(), sub_li.end(), [](const pair<string, long>& a, const pair<string, int>& b) {\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\n// Function to sort a list according to the second element in sublist\nvoid Sort(vector<pair<string, int>>& sub_li) {\n    sort(sub_li.begin(), sub_li.end(), [](const pair<string, long>& a, const pair<string, int>& b) {\n        return a.second < b.second;\n    });\n}\n\n', 'more_universe_var_type'), ('#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n// Sorting function based on the second element of the pairs\nvoid Sort(vector<pair<string, long>>& sub_li) {\n    sort(sub_li.begin(), sub_li.end(), [](const pair<string, long>& a, const pair<string, int>& b) {\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\n// Sorting function based on the second element of the pairs\nvoid Sort(vector<pair<string, long>>& sub_li) {\n    sort(sub_li.begin(), sub_li.end(), [](const pair<string, long>& a, const pair<string, int>& b) {\n        return a.second < b.second; // Sort by second element in descending order\n    });\n}\n\n', 'more_universe_var_type')]}"
323,"#include <iostream>
#include <cassert>
bool check_Validity(int a, int b, int c) {
    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {
        return false;
//begin to write code
",182,"
#include <iostream>
#include <cassert>

bool check_Validity(int a, int b, int c) {
    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {
        return false;
    } else {
        return true;
    }
}


","
#include <iostream>
#include <cassert>

bool check_Validity(int a, int b, int c) {
    // Check if any two sides are less than the third side
    if (a + b <= c || a + c <= b || b + c <= a) {
        return false;
    }
    return true;
}

","#include <iostream>
#include <cassert>
bool check_Validity(int a, int b, int c) {
    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {
        return false;
//begin to write code
","
#include <iostream>
#include <cassert>

bool check_Validity(int a, int b, int c) {
    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {
        return false;
    } else {
        return true;
    }
}


","
#include <iostream>
#include <cassert>

bool check_Validity(int a, int b, int c) {
    // Check if any two sides are less than or equal to the third side
    if (a <= b || a <= c || b <= c) {
        return false;
    }
    return true;
}

",1,3,0.4933903137842814,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nbool check_Validity(int a, int b, int c) {\n    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nbool check_Validity(int a, int b, int c) {\n    if ((a + b <= c) || (a + c <= b) || (b + c <= a)) {\n        return false;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nbool check_Validity(int a, int b, int c) {\n    // Check if any two sides are less than or equal to the third side\n    if (a <= b || a <= c || b <= c) {\n        return false;\n    }\n    return true;\n}\n\n', 'exchange_operators')]}"
324,"#include <iostream>
#include <cassert>
int ap_sum(int a, int n, int d) {
    int total = (n * (2 * a + (n - 1) * d)) / 2;
//begin to write code
",144,"
#include <iostream>
#include <cassert>

int ap_sum(int a, int n, int d) {
    int total = (n * (2 * a + (n - 1) * d)) / 2;
    return total;
}


","
using namespace std;
#include <iostream>
#include <cassert>

int ap_sum(int a, int n, int d) {
    int total = (n * (2 * a + (n - 1) * d)) / 2;
    return total;
}

","#include <iostream>
#include <cassert>
int ap_sum(int a, int n, int d) {
    int total = (n * (2 * a + (n - 1) * d)) / 2;
//begin to write code
","
#include <iostream>
#include <cassert>

int ap_sum(int a, int n, int d) {
    int total = (n * (2 * a + (n - 1) * d)) / 2;
    return total;
}


","
**Created Answer**:
",1,3,0.4664197643597921,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nint ap_sum(int a, int n, int d) {\n    int total = (n * (2 * a + (n - 1) * d)) / 2;\n    return total;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint ap_sum(int a, int n, int d) {\n    int total = (n * (2 * a + (n - 1) * d)) / 2;\n//begin to write code\n', '\n**Created Answer**:\n', 'equal_expression_transformation')]}"
325,"#include <iostream>
#include <string>
#include <cassert>
bool check_monthnum(std::string monthname1) {
    if (monthname1 == ""February"") {
        return true;
//begin to write code
",182,"
#include <iostream>
#include <string>
#include <cassert>

bool check_monthnum(std::string monthname1) {
    if (monthname1 == ""February"") {
        return true;
    } else {
        return false;
    }
}


","
using namespace std;
#include <iostream>
#include <string>
#include <cassert>

bool check_monthnum(std::string monthname1) {
    // Check if the month name is ""February""
    if (monthname1 == ""February"") {
        return true;
    }
    // Add more logic to check if the month name contains 28 days
    // For example, check if the length of the month name is exactly 3 and the last character is 't'
    // This is a basic check and may need additional logic depending on your specific requirements
    return false; // Placeholder, replace with actual logic
}

","#include <iostream>
#include <string>
#include <cassert>
bool check_monthnum(std::string monthname1) {
    if (monthname1 == ""February"") {
        return 1;
//begin to write code
","
#include <iostream>
#include <string>
#include <cassert>

bool check_monthnum(std::string monthname1) {
    if (monthname1 == ""February"") {
        return 1;
    } else {
        return 0;
    }
}


","
#include <iostream>
#include <string>
#include <cassert>

bool check_monthnum(std::string monthname1) {
    if (monthname1 == ""February"") {
        return 1;
    } else if (monthname1 == ""April"" || monthname1 == ""June"" || monthname1 == ""September"" || monthname1 == ""November"") {
        return 0;
    } else {
        return 1; // Assuming all other months have 31 days
    }
}

",1,3,0.5223598043123882,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include <iostream>\n#include <string>\n#include <cassert>\n\nbool check_monthnum(std::string monthname1) {\n    if (monthname1 == ""February"") {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n\n': [('#include <iostream>\n#include <string>\n#include <cassert>\nbool check_monthnum(std::string monthname1) {\n    if (monthname1 == ""February"") {\n        return 1;\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n\nbool check_monthnum(std::string monthname1) {\n    if (monthname1 == ""February"") {\n        return 1;\n    } else if (monthname1 == ""April"" || monthname1 == ""June"" || monthname1 == ""September"" || monthname1 == ""November"") {\n        return 0;\n    } else {\n        return 1; // Assuming all other months have 31 days\n    }\n}\n\n', 'bool2int')]}"
326,"#include <iostream>
#include <regex>
#include <cassert>
using namespace std;
string text_match_word(string text) {
    regex pattern(""\\\w+\\\S*$"");
    if (regex_search(text, pattern)) {
        return ""Found a match!"";
//begin to write code
",243,"#include <iostream>
#include <regex>
#include <cassert>

using namespace std;

string text_match_word(string text) {
    regex pattern(""\\\w+\\\S*$"");
    if (regex_search(text, pattern)) {
        return ""Found a match!"";
    } else {
        return ""Not matched!"";
    }
}","
#include <iostream>
#include <regex>
#include <cassert>
using namespace std;

string text_match_word(string text) {
    regex pattern(""\\\w+\\\S*$"");
    if (regex_search(text, pattern)) {
        return ""Found a match!"";
    }
    return ""No match found."";
}

",,,,-2,1,0.2162257671356201,code_expression_exchange:None,0.0,0.0,
327,"#include <iostream>
#include <string>
#include <cassert>
bool check_Equality(const std::string& s) {
    return s.front() == s.back();
}
int count_Substring_With_Equal_Ends(const std::string& s) {
    int result = 0;
    int n = s.length();
    for (int i = 0; i < n; ++i) {
//begin to write code
",297,"
#include <iostream>
#include <string>
#include <cassert>

bool check_Equality(const std::string& s) {
    return s.front() == s.back();
}

int count_Substring_With_Equal_Ends(const std::string& s) {
    int result = 0;
    int n = s.length();
    for (int i = 0; i < n; ++i) {
        for (int j = 1; j <= n - i; ++j) {
            if (check_Equality(s.substr(i, j))) {
                result++;
            }
        }
    }
    return result;
}


","
#include <iostream>
#include <string>
#include <cassert>

bool check_Equality(const std::string& s) {
    return s.front() == s.back();
}

int count_Substring_With_Equal_Ends(const std::string& s) {
    int result = 0;
    int n = s.length();
    for (int i = 0; i < n; ++i) {
        if (check_Equality(s.substr(i))) {
            ++result;
        }
    }
    return result;
}

",,,,-2,1,0.23632577657699586,code_expression_exchange:None,0.0,0.0,
328,"#include<iostream>
#include <cassert>
// 
int find_Divisor(int x, int y) {
    if (x == y) {
//begin to write code
",119,"#include<iostream>
    

#include <cassert>

// 
int find_Divisor(int x, int y) {
    if (x == y) {
        return y;
    }
    return 2;
}


","
#include<iostream>
#include <cassert>

// 
int find_Divisor(int x, int y) {
    if (x == y) {
        return 0; // xy0
    }
    for (int i = 1; i <= y / i; ++i) {
        if (y % i == 0) {
            return i; // yii
        }
    }
    return -1; // divisor-1
}

",,,,-2,1,0.2311111052831014,code_expression_exchange:None,0.0,0.0,
329,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
// Function definition
int sum_three_smallest_nums(std::vector<int> lst) {
    std::vector<int> positive_nums;
    for (int x : lst) {
        if (x > 0) {
            positive_nums.push_back(x);
        }
//begin to write code
",324,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

// Function definition
int sum_three_smallest_nums(std::vector<int> lst) {
    std::vector<int> positive_nums;
    for (int x : lst) {
        if (x > 0) {
            positive_nums.push_back(x);
        }
    }
    std::sort(positive_nums.begin(), positive_nums.end());
    if (positive_nums.size() < 3) {
        return std::accumulate(positive_nums.begin(), positive_nums.end(), 0);
    }
    return std::accumulate(positive_nums.begin(), positive_nums.begin() + 3, 0);
}


","
using namespace std;

#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

// Function definition
int sum_three_smallest_nums(std::vector<int> lst) {
    // Sort the vector in ascending order
    sort(lst.begin(), lst.end());
    
    // Initialize the sum to 0
    int sum = 0;
    
    // Iterate through the sorted vector and add the smallest three numbers
    for (size_t i = 0; i < 3; ++i) {
        sum += lst[i];
    }
    
    return sum;
}

// Main function to test the sum_three_smallest_nums function
",,,,-2,1,0.24717719554901124,code_expression_exchange:None,0.0,0.0,
330,"#include<iostream>
#include <set>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;
vector<int> set_to_tuple(const set<int>& s) {
    vector<int> t(s.begin(), s.end());
//begin to write code
",220,"#include<iostream>
    

#include <set>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

vector<int> set_to_tuple(const set<int>& s) {
    vector<int> t(s.begin(), s.end());
    sort(t.begin(), t.end());
    return t;
}


","#include<iostream>
#include <set>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

vector<int> set_to_tuple(const set<int>& s) {
    vector<int> t(s.begin(), s.end());
    sort(t.begin(), t.end());
    return t;
}
","#include<iostream>
#include <set>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;
vector<int> set_to_tuple(const set<int>& s) {
    vector<long> t(s.begin(), s.end());
//begin to write code
","#include<iostream>
    

#include <set>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

vector<int> set_to_tuple(const set<int>& s) {
    vector<long> t(s.begin(), s.end());
    sort(t.begin(), t.end());
    return t;
}


","#include <iostream>
#include <set>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

vector<int> set_to_tuple(const set<int>& s) {
    vector<long> t(s.begin(), s.end());
    sort(t.begin(), t.end());
    return t;
}
",1,5,0.6613605539004008,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<iostream>\n    \n\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<int> set_to_tuple(const set<int>& s) {\n    vector<long> t(s.begin(), s.end());\n    sort(t.begin(), t.end());\n    return t;\n}\n\n\n': [('#include<iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nvector<int> set_to_tuple(const set<int>& s) {\n    vector<int> t(s.begin(), s.end());\n//begin to write code\n', '\n#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<int> set_to_tuple(const set<int>& s) {\n    vector<int> t(s.begin(), s.end());\n    return t;\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nvector<int> set_to_tuple(const set<int>& s) {\n    vector<long> t(s.begin(), s.end());\n//begin to write code\n', '#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<int> set_to_tuple(const set<int>& s) {\n    vector<long> t(s.begin(), s.end());\n    sort(t.begin(), t.end());\n    return t;\n}\n', 'more_universe_var_type')]}"
331,"#include <iostream>
#include <vector>
#include <queue>
#include <limits>
#include <cassert>
using namespace std;
class Node {
public:
    int value;
    int list_num;
    int index;
    Node(int value, int list_num, int index) : value(value), list_num(list_num), index(index) {}
    bool operator<(const Node& other) const {
        return value > other.value; // Use greater to simulate min heap in priority queue
    }
};
pair<int, int> find_minimum_range(vector<vector<int>>& lists) {
    int high = numeric_limits<int>::min();
    pair<int, int> p = make_pair(0, numeric_limits<int>::max());
    priority_queue<Node> pq;
    for (int i = 0; i < lists.size(); ++i) {
        pq.push(Node(lists[i][0], i, 0));
        high = max(high, lists[i][0]);
//begin to write code
",773,"
#include <iostream>
#include <vector>
#include <queue>
#include <limits>
#include <cassert>

using namespace std;

class Node {
public:
    int value;
    int list_num;
    int index;

    Node(int value, int list_num, int index) : value(value), list_num(list_num), index(index) {}

    bool operator<(const Node& other) const {
        return value > other.value; // Use greater to simulate min heap in priority queue
    }
};

pair<int, int> find_minimum_range(vector<vector<int>>& lists) {
    int high = numeric_limits<int>::min();
    pair<int, int> p = make_pair(0, numeric_limits<int>::max());
    priority_queue<Node> pq;

    for (int i = 0; i < lists.size(); ++i) {
        pq.push(Node(lists[i][0], i, 0));
        high = max(high, lists[i][0]);
    }

    while (!pq.empty()) {
        Node top = pq.top();
        pq.pop();
        int low = top.value;
        int i = top.list_num;
        int j = top.index;

        if (high - low < p.second - p.first) {
            p = make_pair(low, high);
        }
        
        if (j == lists[i].size() - 1) {
            return p;
        }

        pq.push(Node(lists[i][j + 1], i, j + 1));
        high = max(high, lists[i][j + 1]);
    }

    return p;
}


","
#include <iostream>
#include <vector>
#include <queue>
#include <limits>
#include <cassert>
using namespace std;
class Node {
public:
    int value;
    int list_num;
    int index;
    Node(int value, int list_num, int index) : value(value), list_num(list_num), index(index) {}
    bool operator<(const Node& other) const {
        return value > other.value; // Use greater to simulate min heap in priority queue
    }
};
pair<int, int> find_minimum_range(vector<vector<int>>& lists) {
    int high = numeric_limits<int>::min();
    pair<int, int> p = make_pair(0, numeric_limits<int>::max());
    priority_queue<Node> pq;
    for (int i = 0; i < lists.size(); ++i) {
        pq.push(Node(lists[i][0], i, 0));
        high = max(high, lists[i][0]);
    }
    while (!pq.empty()) {
        Node current = pq.top();
        pq.pop();
        if (current.index >= p.second) {
            continue;
        }
        p.second = current.index + 1;
        if (current.list_num > p.first)",,,,-2,1,0.23622652689615886,code_expression_exchange:None,0.0,0.0,
332,"#include <iostream>
#include <cctype>
#include <cassert>
std::pair<int, int> dig_let(const std::string& s) {
    int d = 0, l = 0;
    for (char c : s) {
        if (isdigit(c)) {
            d++;
//begin to write code
",219,"
#include <iostream>
#include <cctype>
#include <cassert>

std::pair<int, int> dig_let(const std::string& s) {
    int d = 0, l = 0;
    for (char c : s) {
        if (isdigit(c)) {
            d++;
        } else if (isalpha(c)) {
            l++;
        }
    }
    return std::make_pair(l, d);
}


","
#include <iostream>
#include <cctype>
#include <cassert>
#include <utility>

std::pair<int, int> dig_let(const std::string& s) {
    int d = 0, l = 0;
    for (char c : s) {
        if (isdigit(c)) {
            d++;
        } else if (isalpha(c)) {
            l++;
        }
    }
    return {d, l};
}

",,,,-2,1,0.24244696696599324,code_expression_exchange:None,0.0,0.0,
333,"#include<iostream>
#include <cmath>
#include <cassert>
int count_Odd_Squares(int n, int m) {
//begin to write code
",115,"#include<iostream>
    

#include <cmath>
#include <cassert>

int count_Odd_Squares(int n, int m) {
    return int(std::sqrt(m)) - int(std::sqrt(n-1));
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<cmath>
#include<assert.h>

int count_Odd_Squares(int n, int m) {
    int count = 0;
    for (int i = n; i <= m; ++i) {
        if (i % 2!= 0) {
            count++;
        }
    }
    return count;
}

",,,,-2,1,0.21237100760142008,code_expression_exchange:None,0.0,0.0,
334,"#include<iostream>
#include <vector>
#include <cassert>
using namespace std;
vector<int> diff_consecutivenums(const vector<int>& nums) {
    vector<int> result;
    for (int i = 1; i < nums.size(); i++) {
//begin to write code
",227,"#include<iostream>
    

#include <vector>
#include <cassert>
using namespace std;

vector<int> diff_consecutivenums(const vector<int>& nums) {
    vector<int> result;
    for (int i = 1; i < nums.size(); i++) {
        result.push_back(nums[i] - nums[i-1]);
    }
    return result;
}


","
#include<iostream>
#include <vector>
#include <cassert>
using namespace std;

vector<int> diff_consecutivenums(const vector<int>& nums) {
    vector<int> result;
    for (int i = 1; i < nums.size(); i++) {
        int difference = nums[i] - nums[i-1];
        result.push_back(difference);
    }
    return result;
}

","#include<iostream>
#include <vector>
#include <cassert>
using namespace std;
vector<int> diff_consecutivenums(const vector<long>& nums) {
    vector<long> result;
    for (int i = 1; i < nums.size(); i++) {
//begin to write code
","#include<iostream>
    

#include <vector>
#include <cassert>
using namespace std;

vector<int> diff_consecutivenums(const vector<long>& nums) {
    vector<long> result;
    for (int i = 1; i < nums.size(); i++) {
        result.push_back(nums[i] - nums[i-1]);
    }
    return result;
}


","
#include<iostream>
#include <vector>
#include <cassert>
using namespace std;

vector<long> diff_consecutivenums(const vector<long>& nums) {
    vector<long> result;
    for (int i = 1; i < nums.size(); i++) {
        result.push_back(nums[i] - nums[i - 1]);
    }
    return result;
}

",1,5,0.7398431579271952,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<int> diff_consecutivenums(const vector<long>& nums) {\n    vector<long> result;\n    for (int i = 1; i < nums.size(); i++) {\n        result.push_back(nums[i] - nums[i-1]);\n    }\n    return result;\n}\n\n\n': [('#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<int> diff_consecutivenums(const vector<long>& nums) {\n    vector<int> result;\n    for (int i = 1; i < nums.size(); i++) {\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<int> diff_consecutivenums(const vector<long>& nums) {\n    vector<int> result;\n    for (int i = 1; i < nums.size(); i++) {\n        int diff = nums[i] - nums[i - 1];\n        result.push_back(diff);\n    }\n    return result;\n}\n\n', 'more_universe_var_type'), ('#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<int> diff_consecutivenums(const vector<long>& nums) {\n    vector<long> result;\n    for (int i = 1; i < nums.size(); i++) {\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<long> diff_consecutivenums(const vector<long>& nums) {\n    vector<long> result;\n    for (int i = 1; i < nums.size(); i++) {\n        result.push_back(nums[i] - nums[i - 1]);\n    }\n    return result;\n}\n\n', 'more_universe_var_type')]}"
335,"#include <iostream>
#include <cassert>
int zigzag(int n, int k) {
    if (n == 0 && k == 0) {
        return 1;
    }
//begin to write code
",140,"
#include <iostream>
#include <cassert>

int zigzag(int n, int k) {
    if (n == 0 && k == 0) {
        return 1;
    }
    if (k == 0) {
        return 0;
    }
    return zigzag(n, k - 1) + zigzag(n - 1, n - k);
}


","
#include <iostream>
#include <cassert>

int zigzag(int n, int k) {
    if (n == 0 && k == 0) {
        return 1;
    }
    // Your code here
    return 0; // Placeholder for the return value
}

",,,,-2,1,0.24114670356114706,code_expression_exchange:None,0.0,0.0,
336,"#include <iostream>
#include <cassert>
int count_Squares(int m, int n) {
    if (n < m) {
        int temp = m;
        m = n;
//begin to write code
",149,"
#include <iostream>
#include <cassert>

int count_Squares(int m, int n) {
    if (n < m) {
        int temp = m;
        m = n;
        n = temp;
    }
    return n * (n + 1) * (3 * m - n + 1) / 6;
}


","
using namespace std;

#include <iostream>
#include <cassert>

int count_Squares(int m, int n) {
    if (n < m) {
        int temp = m;
        m = n;
    }
    int count = 0;
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (i * i + j * j == n * n) {
                count++;
            }
        }
    }
    return count;
}

",,,,-2,1,0.216256848971049,code_expression_exchange:None,0.0,0.0,
337,"#include <iostream>
#include <cassert>
int bin_coff(int n, int r) {
    int val = 1;
    if (r > (n - r)) {
        r = n - r;
    }
    for (int i = 0; i < r; ++i) {
        val *= (n - i);
        val /= (i + 1);
//begin to write code
",237,"
#include <iostream>
#include <cassert>

int bin_coff(int n, int r) {
    int val = 1;
    if (r > (n - r)) {
        r = n - r;
    }
    for (int i = 0; i < r; ++i) {
        val *= (n - i);
        val /= (i + 1);
    }
    return val;
}

int find_ways(int M) {
    int n = M / 2;
    int a = bin_coff(2 * n, n);
    int b = a / (n + 1);
    return b;
}


","
#include <iostream>
#include <cassert>
int bin_coff(int n, int r) {
    int val = 1;
    if (r > (n - r)) {
        r = n - r;
    }
    for (int i = 0; i < r; ++i) {
        val *= (n - i);
        val /= (i + 1);
    }
    return val;
}

// Test cases
void test_bin_coff() {
    assert(bin_coff(5, 3) == 6); // Example case
    assert(bin_coff(7, 4) == 50); // Example case
    assert(bin_coff(8, 5) == 324); // Example case
    assert(bin_coff(9, 6) == 2160); // Example case
    std::cout << ""All test cases passed successfully."" << std::endl;
}

",,,,-2,1,0.23306655486424763,code_expression_exchange:None,0.0,0.0,
338,"#include <string>
#include <set>
#include <iostream>
#include <cassert>
std::string check(const std::string& string) {
    std::set<char> p(string.begin(), string.end());
    std::set<char> s = {'0', '1'};
    if (s == p || p == std::set<char>{'0'} || p == std::set<char>{'1'}) {
//begin to write code
",302,"
#include <string>
#include <set>
#include <iostream>
#include <cassert>

std::string check(const std::string& string) {
    std::set<char> p(string.begin(), string.end());
    std::set<char> s = {'0', '1'};
    if (s == p || p == std::set<char>{'0'} || p == std::set<char>{'1'}) {
        return ""Yes"";
    } else {
        return ""No"";
    }
}


","
#include <string>
#include <set>
#include <iostream>
#include <cassert>

std::string check(const std::string& string) {
    std::set<char> p(string.begin(), string.end());
    std::set<char> s = {'0', '1'};
    if (s == p || p == std::set<char>{'0'} || p == std::set<char>{'1'}) {
        return ""Binary string"";
    } else {
        return ""Not a binary string"";
    }
}

",,,,-2,1,0.2374775489171346,code_expression_exchange:None,0.0,0.0,
339,"#include <iostream>
#include <string>
#include <vector>
#include <cassert>
int minimum_Length(std::string s) {
    int maxOcc = 0;
    int n = s.length();
    std::vector<int> arr(26, 0);
    for (int i = 0; i < n; i++) {
        arr[s[i] - 'a']++;
    }
//begin to write code
",277,"
#include <iostream>
#include <string>
#include <vector>
#include <cassert>

int minimum_Length(std::string s) {
    int maxOcc = 0;
    int n = s.length();
    std::vector<int> arr(26, 0);
    for (int i = 0; i < n; i++) {
        arr[s[i] - 'a']++;
    }
    for (int i = 0; i < 26; i++) {
        if (arr[i] > maxOcc) {
            maxOcc = arr[i];
        }
    }
    return n - maxOcc;
}


","using namespace std;
#include <iostream>
#include <string>
#include <vector>
#include <cassert>

int minimum_Length(std::string s) {
    int maxOcc = 0;
    int n = s.length();
    std::vector<int> arr(26, 0);
    for (int i = 0; i < n; i++) {
        arr[s[i] - 'a']++;
    }

    for (int i = 0; i < 26; i++) {
        if (arr[i] > maxOcc) {
            maxOcc = arr[i];
        }
    }

    return n - maxOcc;
}
","#include <iostream>
#include <string>
#include <vector>
#include <cassert>
int minimum_Length(std::string s) {
    int maxOcc = 0;
    int n = s.length();
    std::vector<int> arr(26, 0);
    for (int i = 0; i < n; i++) {
        arr[s[i] - 'a']++;
    }
//begin to write code
","
#include <iostream>
#include <string>
#include <vector>
#include <cassert>

int minimum_Length(std::string s) {
    int maxOcc = 0;
    int n = s.length();
    std::vector<int> arr(26, 0);
    for (int i = 0; i < n; i++) {
        arr[s[i] - 'a']++;
    }
    for (int i = 0; i < 26; i++) {
        if (arr[i] > maxOcc) {
            maxOcc = arr[i];
        }
    }
    return n - maxOcc;
}


","
using namespace std;
#include <iostream>
#include <string>
#include <vector>
#include <cassert>

int minimum_Length(std::string s) {
    int maxOcc = 0;
    int n = s.length();
    std::vector<int> arr(26, 0);
    for (int i = 0; i < n; i++) {
        arr[s[i] - 'a']++;
    }
    int count = 0;
    for (int i = 0; i < 26; i++) {
        if (arr[i] > maxOcc) {
            maxOcc = arr[i];
            count = 1;
        } else if (arr[i] == maxOcc) {
            count++;
        }
    }
    return n - count;
}

",1,3,0.463560152053833,code_expression_exchange:bool2int,1.0,0.0,"{""\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\nint minimum_Length(std::string s) {\n    int maxOcc = 0;\n    int n = s.length();\n    std::vector<int> arr(26, 0);\n    for (int i = 0; i < n; i++) {\n        arr[s[i] - 'a']++;\n    }\n    for (int i = 0; i < 26; i++) {\n        if (arr[i] > maxOcc) {\n            maxOcc = arr[i];\n        }\n    }\n    return n - maxOcc;\n}\n\n\n"": [(""#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\nint minimum_Length(std::string s) {\n    int maxOcc = 0;\n    int n = s.length();\n    std::vector<int> arr(26, 0);\n    for (int i = 0; i < n; i++) {\n        arr[s[i] - 'a']++;\n    }\n//begin to write code\n"", ""\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\nint minimum_Length(std::string s) {\n    int maxOcc = 0;\n    int n = s.length();\n    std::vector<int> arr(26, 0);\n    for (int i = 0; i < n; i++) {\n        arr[s[i] - 'a']++;\n    }\n    int count = 0;\n    for (int i = 0; i < 26; i++) {\n        if (arr[i] > maxOcc) {\n            maxOcc = arr[i];\n            count = 1;\n        } else if (arr[i] == maxOcc) {\n            count++;\n        }\n    }\n    return n - count;\n}\n\n"", 'bool2int')]}"
340,"#include <iostream>
#include <vector>
#include <map>
#include <cassert>
int first_Element(const std::vector<int>& arr, int n, int k) {
    std::map<int, int> count_map;
    for (int i = 0; i < n; ++i) {
        if (count_map.find(arr[i]) != count_map.end()) {
            count_map[arr[i]] += 1;
        } else {
            count_map[arr[i]] = 1;
        }
//begin to write code
",380,"
#include <iostream>
#include <vector>
#include <map>
#include <cassert>

int first_Element(const std::vector<int>& arr, int n, int k) {
    std::map<int, int> count_map;
    for (int i = 0; i < n; ++i) {
        if (count_map.find(arr[i]) != count_map.end()) {
            count_map[arr[i]] += 1;
        } else {
            count_map[arr[i]] = 1;
        }
    }
    for (int i = 0; i < n; ++i) {
        if (count_map[arr[i]] == k) {
            return arr[i];
        }
    }
    return -1;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <map>
#include <cassert>

int first_Element(const std::vector<int>& arr, int n, int k) {
    std::map<int, int> count_map;
    for (int i = 0; i < n; ++i) {
        if (count_map.find(arr[i])!= count_map.end()) {
            count_map[arr[i]] += 1;
        } else {
            count_map[arr[i]] = 1;
        }
    }
    int result;
    for (const auto& pair : count_map) {
        if (pair.second == k) {
            result = pair.first;
            break;
        }
    }
    return result;
}

","#include <iostream>
#include <vector>
#include <map>
#include <cassert>
long first_Element(const std::vector<long>& arr, int n, int k) {
    std::map<long, long> count_map;
    for (int i = 0; i < n; i = 1 + i) {
        if (count_map.find(arr[i]) != count_map.end()) {
            count_map[arr[i]] = (1) + count_map[arr[i]];
        } else {
            count_map[arr[i]] = 1;
        }
//begin to write code
","
#include <iostream>
#include <vector>
#include <map>
#include <cassert>

long first_Element(const std::vector<long>& arr, int n, int k) {
    std::map<long, long> count_map;
    for (int i = 0; i < n; i = 1 + i) {
        if (count_map.find(arr[i]) != count_map.end()) {
            count_map[arr[i]] = (1) + count_map[arr[i]];
        } else {
            count_map[arr[i]] = 1;
        }
    }
    for (long i = 0; i < n; i = 1 + i) {
        if (count_map[arr[i]] == k) {
            return arr[i];
        }
    }
    return -1;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <map>
#include <cassert>

long first_Element(const std::vector<long>& arr, int n, int k) {
    std::map<long, long> count_map;
    for (int i = 0; i < n; i = 1 + i) {
        if (count_map.find(arr[i])!= count_map.end()) {
            count_map[arr[i]] = (1) + count_map[arr[i]];
        } else {
            count_map[arr[i]] = 1;
        }
    }
    return *count_map.begin();
}

",1,21,2.9615127722422283,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nlong first_Element(const std::vector<long>& arr, int n, int k) {\n    std::map<long, long> count_map;\n    for (int i = 0; i < n; i = 1 + i) {\n        if (count_map.find(arr[i]) != count_map.end()) {\n            count_map[arr[i]] = (1) + count_map[arr[i]];\n        } else {\n            count_map[arr[i]] = 1;\n        }\n    }\n    for (long i = 0; i < n; i = 1 + i) {\n        if (count_map[arr[i]] == k) {\n            return arr[i];\n        }\n    }\n    return -1;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nint first_Element(const std::vector<int>& arr, int n, int k) {\n    std::map<int, int> count_map;\n    for (int i = 0; i < n; ++i) {\n        if (count_map.find(arr[i]) != count_map.end()) {\n            count_map[arr[i]] += 1;\n        } else {\n            count_map[arr[i]] = 1;\n        }\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nint first_Element(const std::vector<int>& arr, int n, int k) {\n    std::map<int, int> count_map;\n\n    // Count the occurrences of each element\n    for (int i = 0; i < n; ++i) {\n        count_map[arr[i]]++;\n    }\n\n    // Find the first element that appears exactly k times\n    for (const auto& pair : count_map) {\n        if (pair.second == k) {\n            return pair.first;\n        }\n    }\n\n    // If no element appears k times, return -1 or throw an exception\n    return -1; // or throw an exception\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nlong first_Element(const std::vector<int>& arr, int n, int k) {\n    std::map<int, int> count_map;\n    for (int i = 0; i < n; ++i) {\n        if (count_map.find(arr[i]) != count_map.end()) {\n            count_map[arr[i]] += 1;\n        } else {\n            count_map[arr[i]] = 1;\n        }\n//begin to write code\n', 'using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nlong first_Element(const std::vector<int>& arr, int n, int k) {\n    std::map<int, int> count_map;\n    for (int i = 0; i < n; ++i) {\n        if (count_map.find(arr[i])!= count_map.end()) {\n            count_map[arr[i]] += 1;\n        } else {\n            count_map[arr[i]] = 1;\n        }\n    }\n\n    // Find the first element that occurs k times\n    for (const auto& pair : count_map) {\n        if (pair.second == k) {\n            return pair.first;\n        }\n    }\n\n    // If no element occurs k times, return -1 (or throw an exception, etc.)\n    return -1;\n}\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nlong first_Element(const std::vector<int>& arr, int n, int k) {\n    std::map<int, int> count_map;\n    for (int i = 0; i < n; ++i) {\n        if (count_map.end() != count_map.find(arr[i])) {\n            count_map[arr[i]] += 1;\n        } else {\n            count_map[arr[i]] = 1;\n        }\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nlong first_Element(const std::vector<int>& arr, int n, int k) {\n    std::map<int, int> count_map;\n    for (int i = 0; i < n; ++i) {\n        if (count_map.end()!= count_map.find(arr[i])) {\n            count_map[arr[i]] += 1;\n        } else {\n            count_map[arr[i]] = 1;\n        }\n    }\n\n    long result = -1;\n    for (const auto& pair : count_map) {\n        if (pair.second == k) {\n            result = pair.first;\n            break;\n        }\n    }\n\n    return result;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nlong first_Element(const std::vector<int>& arr, int n, int k) {\n    std::map<int, int> count_map;\n    for (int i = 0; i < n; i = i + 1) {\n        if (count_map.end() != count_map.find(arr[i])) {\n            count_map[arr[i]] = count_map[arr[i]] + (1);\n        } else {\n            count_map[arr[i]] = 1;\n        }\n//begin to write code\n', 'using namespace std;\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nlong first_Element(const std::vector<int>& arr, int n, int k) {\n    std::map<int, int> count_map;\n    for (int i = 0; i < n; i = i + 1) {\n        if (count_map.end()!= count_map.find(arr[i])) {\n            count_map[arr[i]] = count_map[arr[i]] + (1);\n        } else {\n            count_map[arr[i]] = 1;\n        }\n    }\n    for (const auto& pair : count_map) {\n        if (pair.second == k) {\n            return pair.first;\n        }\n    }\n    return -1; // Return -1 if no element occurs k times\n}\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nlong first_Element(const std::vector<int>& arr, int n, int k) {\n    std::map<int, int> count_map;\n    for (int i = 0; i < n; i = i + 1) {\n        if (count_map.end() != count_map.find(arr[i])) {\n            count_map[arr[i]] = count_map[arr[i]] + (1);\n        } else {\n            count_map[arr[i]] = 1;\n        }\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nlong first_Element(const std::vector<int>& arr, int n, int k) {\n    std::map<int, int> count_map;\n    for (int i = 0; i < n; i = i + 1) {\n        if (count_map.end()!= count_map.find(arr[i])) {\n            count_map[arr[i]] = count_map[arr[i]] + (1);\n        } else {\n            count_map[arr[i]] = 1;\n        }\n    }\n\n    long result = -1;\n    for (const auto& pair : count_map) {\n        if (pair.second == k) {\n            result = pair.first;\n            break;\n        }\n    }\n\n    return result;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nlong first_Element(const std::vector<int>& arr, int n, int k) {\n    std::map<long, int> count_map;\n    for (int i = 0; i < n; i = i + 1) {\n        if (count_map.end() != count_map.find(arr[i])) {\n            count_map[arr[i]] = count_map[arr[i]] + (1);\n        } else {\n            count_map[arr[i]] = 1;\n        }\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nlong first_Element(const std::vector<int>& arr, int n, int k) {\n    std::map<long, int> count_map;\n    for (int i = 0; i < n; i = i + 1) {\n        if (count_map.end()!= count_map.find(arr[i])) {\n            count_map[arr[i]] = count_map[arr[i]] + (1);\n        } else {\n            count_map[arr[i]] = 1;\n        }\n    }\n\n    long result = 0;\n    for (const auto& pair : count_map) {\n        if (pair.second == k) {\n            result = pair.first;\n            break;\n        }\n    }\n\n    return result;\n}\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nlong first_Element(const std::vector<int>& arr, int n, int k) {\n    std::map<long, int> count_map;\n    for (int i = 0; i < n; i = i + 1) {\n        if (count_map.end() != count_map.find(arr[i])) {\n            count_map[arr[i]] = count_map[arr[i]] + (1);\n        } else {\n            count_map[arr[i]] = 1;\n        }\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nlong first_Element(const std::vector<int>& arr, int n, int k) {\n    std::map<long, int> count_map;\n    for (int i = 0; i < n; i = i + 1) {\n        if (count_map.end()!= count_map.find(arr[i])) {\n            count_map[arr[i]] = count_map[arr[i]] + (1);\n        } else {\n            count_map[arr[i]] = 1;\n        }\n    }\n\n    long result = -1;\n    for (const auto& pair : count_map) {\n        if (pair.second == k) {\n            result = pair.first;\n            break;\n        }\n    }\n\n    return result;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nlong first_Element(const std::vector<long>& arr, int n, int k) {\n    std::map<long, int> count_map;\n    for (int i = 0; i < n; i = i + 1) {\n        if (count_map.end() != count_map.find(arr[i])) {\n            count_map[arr[i]] = count_map[arr[i]] + (1);\n        } else {\n            count_map[arr[i]] = 1;\n        }\n//begin to write code\n', 'using namespace std;\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nlong first_Element(const std::vector<long>& arr, int n, int k) {\n    std::map<long, int> count_map;\n    for (int i = 0; i < n; i = i + 1) {\n        if (count_map.end()!= count_map.find(arr[i])) {\n            count_map[arr[i]] = count_map[arr[i]] + (1);\n        } else {\n            count_map[arr[i]] = 1;\n        }\n    }\n\n    long result = -1;\n    for (const auto& pair : count_map) {\n        if (pair.second == k) {\n            result = pair.first;\n            break;\n        }\n    }\n\n    return result;\n}\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nlong first_Element(const std::vector<long>& arr, int n, int k) {\n    std::map<long, long> count_map;\n    for (int i = 0; i < n; i = i + 1) {\n        if (count_map.end() != count_map.find(arr[i])) {\n            count_map[arr[i]] = count_map[arr[i]] + (1);\n        } else {\n            count_map[arr[i]] = 1;\n        }\n//begin to write code\n', 'using namespace std;\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nlong first_Element(const std::vector<long>& arr, int n, int k) {\n    std::map<long, long> count_map;\n    for (int i = 0; i < n; i = i + 1) {\n        if (count_map.end()!= count_map.find(arr[i])) {\n            count_map[arr[i]] = count_map[arr[i]] + (1);\n        } else {\n            count_map[arr[i]] = 1;\n        }\n    }\n\n    long result = -1;\n    for (const auto& pair : count_map) {\n        if (pair.second == k) {\n            result = pair.first;\n            break;\n        }\n    }\n\n    return result;\n}\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nlong first_Element(const std::vector<long>& arr, int n, int k) {\n    std::map<long, long> count_map;\n    for (int i = 0; i < n; i = 1 + i) {\n        if (count_map.find(arr[i]) != count_map.end()) {\n            count_map[arr[i]] = (1) + count_map[arr[i]];\n        } else {\n            count_map[arr[i]] = 1;\n        }\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\n\nlong first_Element(const std::vector<long>& arr, int n, int k) {\n    std::map<long, long> count_map;\n    for (int i = 0; i < n; i = 1 + i) {\n        if (count_map.find(arr[i])!= count_map.end()) {\n            count_map[arr[i]] = (1) + count_map[arr[i]];\n        } else {\n            count_map[arr[i]] = 1;\n        }\n    }\n    return *count_map.begin();\n}\n\n', 'exchange_operators')]}"
341,"#include <iostream>
#include <string>
#include <cassert>
bool unique_Characters(std::string str) {
    for (int i = 0; i < str.length(); i++) {
        for (int j = i + 1; j < str.length(); j++) {
            if (str[i] == str[j]) {
                return false;
//begin to write code
",285,"
#include <iostream>
#include <string>
#include <cassert>

bool unique_Characters(std::string str) {
    for (int i = 0; i < str.length(); i++) {
        for (int j = i + 1; j < str.length(); j++) {
            if (str[i] == str[j]) {
                return false;
            }
        }
    }
    return true;
}


","
#include <iostream>
#include <string>
#include <cassert>

bool unique_Characters(std::string str) {
    std::unordered_set<char> seenChars;
    for (char ch : str) {
        if (seenChars.find(ch)!= seenChars.end()) {
            return false;
        }
        seenChars.insert(ch);
    }
    return true;
}

",,,,-2,1,0.2345022201538086,code_expression_exchange:None,0.0,0.0,
342,"#include <iostream>
#include <vector>
#include <cassert>
std::vector<std::vector<int>> remove_column(std::vector<std::vector<int>>& list1, int n) {
    for (auto& row : list1) {
        row.erase(row.begin() + n);
//begin to write code
",236,"
#include <iostream>
#include <vector>
#include <cassert>

std::vector<std::vector<int>> remove_column(std::vector<std::vector<int>>& list1, int n) {
    for (auto& row : list1) {
        row.erase(row.begin() + n);
    }
    return list1;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

std::vector<std::vector<int>> remove_column(std::vector<std::vector<int>>& list1, int n) {
    for (auto& row : list1) {
        row.erase(row.begin() + n);
    }
    return list1;
}

","#include <iostream>
#include <vector>
#include <cassert>
std::vector<std::vector<int>> remove_column(std::vector<std::vector<int>>& list1, int n) {
    for (auto& row : list1) {
        row.erase(row.begin() + n);
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

std::vector<std::vector<int>> remove_column(std::vector<std::vector<int>>& list1, int n) {
    for (auto& row : list1) {
        row.erase(row.begin() + n);
    }
    return list1;
}


","
#include <iostream>
#include <vector>
#include <cassert>
std::vector<std::vector<int>> remove_column(std::vector<std::vector<int>>& list1, int n) {
    std::vector<std::vector<int>> result;
    for (int i = 0; i < list1.size(); ++i) {
        std::vector<int> temp = list1[i];
        temp.erase(temp.begin() + n);
        result.push_back(temp);
    }
    return result;
}

// Test cases
void test_remove_column() {
    assert(remove_column({}, 0) == std::vector<std::vector<int>>{}); // Empty list
    assert(remove_column({{1}, {2}}, 0) == std::vector<std::vector<int>>{{1}, {2}}); // Single-element list
    assert(remove_column({{1, 2, 3}, {4, 5, 6}}, 1) == std::vector<std::vector<int>>{{2, 3}, {4, 5, 6}}); // Two-element list
    assert(remove_column({{1, 2, 3}, {4, 5, 6}, {",1,3,0.5153841853141785,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<std::vector<int>> remove_column(std::vector<std::vector<int>>& list1, int n) {\n    for (auto& row : list1) {\n        row.erase(row.begin() + n);\n    }\n    return list1;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<std::vector<int>> remove_column(std::vector<std::vector<int>>& list1, int n) {\n    for (auto& row : list1) {\n        row.erase(row.begin() + n);\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<std::vector<int>> remove_column(std::vector<std::vector<int>>& list1, int n) {\n    std::vector<std::vector<int>> result;\n    for (int i = 0; i < list1.size(); ++i) {\n        std::vector<int> temp = list1[i];\n        temp.erase(temp.begin() + n);\n        result.push_back(temp);\n    }\n    return result;\n}\n\n// Test cases\nvoid test_remove_column() {\n    assert(remove_column({}, 0) == std::vector<std::vector<int>>{}); // Empty list\n    assert(remove_column({{1}, {2}}, 0) == std::vector<std::vector<int>>{{1}, {2}}); // Single-element list\n    assert(remove_column({{1, 2, 3}, {4, 5, 6}}, 1) == std::vector<std::vector<int>>{{2, 3}, {4, 5, 6}}); // Two-element list\n    assert(remove_column({{1, 2, 3}, {4, 5, 6}, {', 'bool2int')]}"
343,"#include<iostream>
#include<cassert>
//
int tn_ap(int a, int n, int d) {
//begin to write code
",99,"
#include<iostream>
#include<cassert>

//
int tn_ap(int a, int n, int d) {
    int tn = a + (n - 1) * d;
    return tn;
}


","
#include<iostream>
#include<cassert>

//
int tn_ap(int a, int n, int d) {
    return a + (n - 1) * d;
}

//
void test_tn_ap() {
    assert(tn_ap(1, 5, 2) == 9);
    assert(tn_ap(3, 7, 3) == 16);
    assert(tn_ap(10, 15, 4) == 40);
    std::cout << ""All test cases passed successfully."" << std::endl;
}

","#include<iostream>
#include<cassert>
//
int tn_ap(int a, int n, int d) {
//begin to write code
","
#include<iostream>
#include<cassert>

//
int tn_ap(int a, int n, int d) {
    int tn = a + (n - 1) * d;
    return tn;
}


","
using namespace std;

#include<iostream>
#include<cassert>

//
int tn_ap(int a, int n, int d) {
    // Your implementation goes here
    return 0; // Placeholder, replace with actual logic
}

",1,5,0.764505676428477,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include<iostream>\n#include<cassert>\n\n//\nint tn_ap(int a, int n, int d) {\n    int tn = a + (n - 1) * d;\n    return tn;\n}\n\n\n': [('#include<iostream>\n#include<cassert>\n//\nint tn_ap(int a, int n, int d) {\n//begin to write code\n', '\n#include<iostream>\n#include<cassert>\n\n// Function to find t-nth term of arithmetic progression\nint tn_ap(int a, int n, int d) {\n    if (n <= 0) {\n        throw std::invalid_argument(""n must be a positive integer."");\n    }\n    return a + (n - 1) * d;\n}\n\n// Test cases to verify the correctness of the function\nvoid test_tn_ap() {\n    assert(tn_ap(1, 5, 2) == 1);\n    assert(tn_ap(3, 4, 3) == 7);\n    assert(tn_ap(5, 6, 4) == 15);\n    assert(tn_ap(1, 10, 2) == 21);\n    assert(tn_ap(0, 0, 1) == 0);\n    assert(tn_ap(2, 1, 2) == 3);\n    std::cout << ""All test cases passed successfully."" << std::endl;\n}\n\n', 'equal_expression_transformation'), ('#include<iostream>\n#include<cassert>\n//\nint tn_ap(int a, int n, int d) {\n//begin to write code\n', '\nusing namespace std;\n\n#include<iostream>\n#include<cassert>\n\n//\nint tn_ap(int a, int n, int d) {\n    // Your implementation goes here\n    return 0; // Placeholder, replace with actual logic\n}\n\n', 'equal_expression_transformation')]}"
344,"#include <iostream>
#include <cassert>
int count_Rectangles(int radius) {
    int rectangles = 0;
    int diameter = 2 * radius;
    int diameterSquare = diameter * diameter;
    for (int a = 1; a < 2 * radius; a++) {
        for (int b = 1; b < 2 * radius; b++) {
            int diagnalLengthSquare = (a * a + b * b);
//begin to write code
",342,"
#include <iostream>
#include <cassert>

int count_Rectangles(int radius) {
    int rectangles = 0;
    int diameter = 2 * radius;
    int diameterSquare = diameter * diameter;
    for (int a = 1; a < 2 * radius; a++) {
        for (int b = 1; b < 2 * radius; b++) {
            int diagnalLengthSquare = (a * a + b * b);
            if (diagnalLengthSquare <= diameterSquare) {
                rectangles += 1;
            }
        }
    }
    return rectangles;
}


","
#include <iostream>
#include <cassert>

int count_Rectangles(int radius) {
    int rectangles = 0;
    int diameter = 2 * radius;
    int diameterSquare = diameter * diameter;
    for (int a = 1; a < 2 * radius; a++) {
        for (int b = 1; b < 2 * radius; b++) {
            int diagnalLengthSquare = (a * a + b * b);
            if (diagonalLengthSquare <= diameterSquare) {
                rectangles++;
            }
        }
    }
    return rectangles;
}

",,,,-2,1,0.2068641225496928,code_expression_exchange:None,0.0,0.0,
345,"#include<iostream>
#include <cassert>
//
int find_angle(int a, int b) {
//begin to write code
",98,"#include<iostream>
    

#include <cassert>

//
int find_angle(int a, int b) {
    int c = 180 - (a + b);
    return c;
}


","
using namespace std;

#include<iostream>
#include <cassert>

//
int find_angle(int a, int b) {
    // Calculate the sum of the angles
    int sum = a + b;
    // Calculate the third angle using the formula: 180 degrees - (sum of the angles)
    int third_angle = 180 - sum;
    return third_angle;
}

// Test cases
void test_find_angle() {
    assert(find_angle(30, 60) == 90);
    assert(find_angle(45, 45) == 90);
    assert(find_angle(10, 10) == 180);
    cout << ""All test cases passed successfully."" << endl;
}

","#include<iostream>
#include <cassert>
//
int find_angle(int a, int b) {
//begin to write code
","#include<iostream>
    

#include <cassert>

//
int find_angle(int a, int b) {
    int c = 180 - (a + b);
    return c;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<assert.h>

// Function to find the third angle of a triangle using two angles
int find_angle(int a, int b) {
    // Check if any of the angles are zero
    if (a == 0 || b == 0 || a + b == 0) {
        throw invalid_argument(""One of the angles cannot be zero."");
    }
    
    // Calculate the sum of the angles
    int sum = a + b;
    
    // Calculate the third angle using the formula: 180 - (sum - 2*base)
    int third_angle = 180 - (sum - 2 * a);
    
    return third_angle;
}

",1,3,0.5064378658930461,code_expression_exchange:exchange_operators,1.0,0.0,"{'#include<iostream>\n    \n\n#include <cassert>\n\n//\nint find_angle(int a, int b) {\n    int c = 180 - (a + b);\n    return c;\n}\n\n\n': [('#include<iostream>\n#include <cassert>\n//\nint find_angle(int a, int b) {\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<assert.h>\n\n// Function to find the third angle of a triangle using two angles\nint find_angle(int a, int b) {\n    // Check if any of the angles are zero\n    if (a == 0 || b == 0 || a + b == 0) {\n        throw invalid_argument(""One of the angles cannot be zero."");\n    }\n    \n    // Calculate the sum of the angles\n    int sum = a + b;\n    \n    // Calculate the third angle using the formula: 180 - (sum - 2*base)\n    int third_angle = 180 - (sum - 2 * a);\n    \n    return third_angle;\n}\n\n', 'exchange_operators')]}"
346,"#include <iostream>
#include <vector>
#include <cassert>
#include <algorithm>
int find_max(const std::vector<std::vector<int>>& test_list) {
    int res = 0;
    for (const auto& sublist : test_list) {
        for (int num : sublist) {
//begin to write code
",258,"
#include <iostream>
#include <vector>
#include <cassert>
#include <algorithm>

int find_max(const std::vector<std::vector<int>>& test_list) {
    int res = 0;
    for (const auto& sublist : test_list) {
        for (int num : sublist) {
            res = std::max(res, num);
        }
    }
    return res;
}


","using namespace std;
#include <iostream>
#include <vector>
#include <cassert>
#include <algorithm>

int find_max(const std::vector<std::vector<int>>& test_list) {
    int res = 0;
    for (const auto& sublist : test_list) {
        for (int num : sublist) {
            if (num > res) {
                res = num;
            }
        }
    }
    return res;
}
","#include <iostream>
#include <vector>
#include <cassert>
#include <algorithm>
long find_max(const std::vector<std::vector<long>>& test_list) {
    long res = 0;
    for (const auto& sublist : test_list) {
        for (long num : sublist) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>
#include <algorithm>

long find_max(const std::vector<std::vector<long>>& test_list) {
    long res = 0;
    for (const auto& sublist : test_list) {
        for (long num : sublist) {
            res = std::max(res, num);
        }
    }
    return res;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <cassert>
#include <algorithm>

long find_max(const std::vector<std::vector<long>>& test_list) {
    long res = 0;
    for (const auto& sublist : test_list) {
        for (long num : sublist) {
            if (num > res) {
                res = num;
            }
        }
    }
    return res;
}

",-1,21,3.115622103214264,code_expression_exchange:equal_expression_transformation,1.0,0.6608994922580366,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nlong find_max(const std::vector<std::vector<long>>& test_list) {\n    long res = 0;\n    for (const auto& sublist : test_list) {\n        for (long num : sublist) {\n            res = std::max(res, num);\n        }\n    }\n    return res;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nint find_max(const std::vector<std::vector<int>>& test_list) {\n    int res = 0;\n    for (const auto& sublist : test_list) {\n        for (int num : sublist) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nint find_max(const std::vector<std::vector<int>>& test_list) {\n    if (test_list.empty()) {\n        throw invalid_argument(""The list cannot be empty."");\n    }\n\n    int res = test_list[0][0];\n    for (const auto& sublist : test_list) {\n        for (int num : sublist) {\n            if (num > res) {\n                res = num;\n            }\n        }\n    }\n    return res;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nlong find_max(const std::vector<std::vector<int>>& test_list) {\n    int res = 0;\n    for (const auto& sublist : test_list) {\n        for (int num : sublist) {\n//begin to write code\n', 'using namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nlong find_max(const std::vector<std::vector<int>>& test_list) {\n    if (test_list.empty()) {\n        return 0; // Return 0 if the list is empty\n    }\n\n    int max_element = test_list[0][0];\n    for (const auto& sublist : test_list) {\n        for (int num : sublist) {\n            if (num > max_element) {\n                max_element = num;\n            }\n        }\n    }\n\n    return max_element;\n}\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nlong find_max(const std::vector<std::vector<long>>& test_list) {\n    int res = 0;\n    for (const auto& sublist : test_list) {\n        for (int num : sublist) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nlong find_max(const std::vector<std::vector<long>>& test_list) {\n    if (test_list.empty()) {\n        throw std::invalid_argument(""The list cannot be empty."");\n    }\n\n    long max_value = test_list[0][0];\n    for (const auto& sublist : test_list) {\n        for (int num : sublist) {\n            if (num > max_value) {\n                max_value = num;\n            }\n        }\n    }\n    return max_value;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nlong find_max(const std::vector<std::vector<long>>& test_list) {\n    int res = 0;\n    for (const auto& sublist : test_list) {\n        for (long num : sublist) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nlong find_max(const std::vector<std::vector<long>>& test_list) {\n    long res = 0;\n    for (const auto& sublist : test_list) {\n        for (long num : sublist) {\n            if (num > res) {\n                res = num;\n            }\n        }\n    }\n    return res;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nlong find_max(const std::vector<std::vector<long>>& test_list) {\n    int res = 0;\n    for (const auto& sublist : test_list) {\n        for (long num : sublist) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nusing namespace std;\n\nlong find_max(const vector<std::vector<long>>& test_list) {\n    long res = 0;\n    for (const auto& sublist : test_list) {\n        for (long num : sublist) {\n            if (num > res) {\n                res = num;\n            }\n        }\n    }\n    return res;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nlong find_max(const std::vector<std::vector<long>>& test_list) {\n    int res = 0;\n    for (const auto& sublist : test_list) {\n        for (long num : sublist) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nlong find_max(const std::vector<std::vector<long>>& test_list) {\n    long res = 0;\n    for (const auto& sublist : test_list) {\n        for (long num : sublist) {\n            if (num > res) {\n                res = num;\n            }\n        }\n    }\n    return res;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nlong find_max(const std::vector<std::vector<long>>& test_list) {\n    long res = 0;\n    for (const auto& sublist : test_list) {\n        for (long num : sublist) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nlong find_max(const std::vector<std::vector<long>>& test_list) {\n    if (test_list.empty()) {\n        throw invalid_argument(""The list is empty."");\n    }\n\n    long max_value = test_list[0][0];\n    for (const auto& sublist : test_list) {\n        for (long num : sublist) {\n            if (num > max_value) {\n                max_value = num;\n            }\n        }\n    }\n    return max_value;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nlong find_max(const std::vector<std::vector<long>>& test_list) {\n    long res = 0;\n    for (const auto& sublist : test_list) {\n        for (long num : sublist) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nlong find_max(const std::vector<std::vector<long>>& test_list) {\n    long res = 0;\n    for (const auto& sublist : test_list) {\n        for (long num : sublist) {\n            if (num > res) {\n                res = num;\n            }\n        }\n    }\n    return res;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nlong find_max(const std::vector<std::vector<long>>& test_list) {\n    long res = 0;\n    for (const auto& sublist : test_list) {\n        for (long num : sublist) {\n//begin to write code\n', 'using namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nlong find_max(const std::vector<std::vector<long>>& test_list) {\n    long res = 0;\n    for (const auto& sublist : test_list) {\n        for (long num : sublist) {\n            if (num > res) {\n                res = num;\n            }\n        }\n    }\n    return res;\n}\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nlong find_max(const std::vector<std::vector<long>>& test_list) {\n    long res = 0;\n    for (const auto& sublist : test_list) {\n        for (long num : sublist) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nlong find_max(const std::vector<std::vector<long>>& test_list) {\n    long res = 0;\n    for (const auto& sublist : test_list) {\n        for (long num : sublist) {\n            if (num > res) {\n                res = num;\n            }\n        }\n    }\n    return res;\n}\n\n', 'equal_expression_transformation')]}"
347,"#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> moddiv_list(const std::vector<int>& nums1, const std::vector<int>& nums2) {
    std::vector<int> result;
    for (size_t i = 0; i < nums1.size(); ++i) {
//begin to write code
",249,"
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> moddiv_list(const std::vector<int>& nums1, const std::vector<int>& nums2) {
    std::vector<int> result;
    for (size_t i = 0; i < nums1.size(); ++i) {
        result.push_back(nums1[i] % nums2[i]);
    }
    return result;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> moddiv_list(const std::vector<int>& nums1, const std::vector<int>& nums2) {
    std::vector<int> result;
    for (size_t i = 0; i < nums1.size(); ++i) {
        result.push_back(nums1[i] % nums2[i]);
    }
    return result;
}

","#include <iostream>
#include <vector>
#include <cassert>
std::vector<long> moddiv_list(const std::vector<int>& nums1, const std::vector<int>& nums2) {
    std::vector<int> result;
    for (size_t i = 0; i < nums1.size(); ++i) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

std::vector<long> moddiv_list(const std::vector<int>& nums1, const std::vector<int>& nums2) {
    std::vector<int> result;
    for (size_t i = 0; i < nums1.size(); ++i) {
        result.push_back(nums1[i] % nums2[i]);
    }
    return result;
}


","
#include <iostream>
#include <vector>
#include <cassert>

std::vector<long> moddiv_list(const std::vector<int>& nums1, const std::vector<int>& nums2) {
    std::vector<long> result;
    for (size_t i = 0; i < nums1.size(); ++i) {
        result.push_back(nums1[i] % nums2[i]);
    }
    return result;
}

",1,5,0.7768784681955974,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<long> moddiv_list(const std::vector<int>& nums1, const std::vector<int>& nums2) {\n    std::vector<int> result;\n    for (size_t i = 0; i < nums1.size(); ++i) {\n        result.push_back(nums1[i] % nums2[i]);\n    }\n    return result;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> moddiv_list(const std::vector<int>& nums1, const std::vector<int>& nums2) {\n    std::vector<int> result;\n    for (size_t i = 0; i < nums1.size(); ++i) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <map>\n\nstd::vector<int> moddiv_list(const std::vector<int>& nums1, const std::vector<int>& nums2) {\n    std::vector<int> result;\n    for (size_t i = 0; i < nums1.size(); ++i) {\n        int remainder = nums1[i] % nums2[i];\n        result.push_back(remainder);\n    }\n    return result;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<long> moddiv_list(const std::vector<int>& nums1, const std::vector<int>& nums2) {\n    std::vector<int> result;\n    for (size_t i = 0; i < nums1.size(); ++i) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<long> moddiv_list(const std::vector<int>& nums1, const std::vector<int>& nums2) {\n    std::vector<long> result;\n    for (size_t i = 0; i < nums1.size(); ++i) {\n        result.push_back(nums1[i] % nums2[i]);\n    }\n    return result;\n}\n\n', 'more_universe_var_type')]}"
348,"#include<iostream>
#include<string>
#include<cassert>
std::string Check_Solution(int a, int b, int c) {
    if (2 * b * b == 9 * a * c) {
        return ""Yes"";
//begin to write code
",182,"
#include<iostream>
#include<string>
#include<cassert>

std::string Check_Solution(int a, int b, int c) {
    if (2 * b * b == 9 * a * c) {
        return ""Yes"";
    } else {
        return ""No"";
    }
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<cmath>
#include<numeric>

std::string Check_Solution(int a, int b, int c) {
    if (2 * b * b == 9 * a * c) {
        return ""Yes"";
    } else {
        return ""No"";
    }
}
",,,,-2,1,0.18370449145634968,code_expression_exchange:None,0.0,0.0,
349,"#include <iostream>
#include <cmath>
#include <cassert>
long long get_carol(int n) {
    long long result = pow(2, n) - 1;
//begin to write code
",145,"
#include <iostream>
#include <cmath>
#include <cassert>

long long get_carol(int n) {
    long long result = pow(2, n) - 1;
    return result * result - 2;
}


","
using namespace std;
#include <iostream>
#include <cmath>
#include <cassert>

long long get_carol(int n) {
    return pow(2, n) - 1;
}

",,,,-2,1,0.2091944972674052,code_expression_exchange:None,0.0,0.0,
350,"#include<iostream>
#include <vector>
#include <cassert>
#include <string>
using namespace std;
template<typename T>
vector<T> remove_empty(vector<T> list1) {
    vector<T> result;
    for (auto& item : list1) {
//begin to write code
",233,"#include<iostream>
    

#include <vector>
#include <cassert>
#include <string>
using namespace std;

template<typename T>
vector<T> remove_empty(vector<T> list1) {
    vector<T> result;
    for (auto& item : list1) {
        if (!item.empty()) result.push_back(item);
    }
    return result;
}


","
#include<iostream>
#include <vector>
#include <cassert>
#include <string>
using namespace std;

template<typename T>
vector<T> remove_empty(vector<T> list1) {
    vector<T> result;
    for (auto& item : list1) {
        if (!item.empty()) {
            result.push_back(item);
        }
    }
    return result;
}

","#include<iostream>
#include <vector>
#include <cassert>
#include <string>
using namespace std;
template<typename T>
vector<T> remove_empty(vector<T> list1) {
    vector<T> result;
    for (auto& item : list1) {
//begin to write code
","#include<iostream>
    

#include <vector>
#include <cassert>
#include <string>
using namespace std;

template<typename T>
vector<T> remove_empty(vector<T> list1) {
    vector<T> result;
    for (auto& item : list1) {
        if (!item.empty()) result.push_back(item);
    }
    return result;
}


","
#include<iostream>
#include <vector>
#include <cassert>
#include <string>
using namespace std;
template<typename T>
vector<T> remove_empty(vector<T> list1) {
    vector<T> result;
    for (auto& item : list1) {
        if (!item.empty()) {
            result.push_back(item);
        }
    }
    return result;
}

",-1,21,3.027742036183675,code_expression_exchange:exchange_operators,1.0,0.9075686145426503,"{'#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\n\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n        if (!item.empty()) result.push_back(item);\n    }\n    return result;\n}\n\n\n': [('#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\n\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n        if (!item.empty()) {\n            result.push_back(item);\n        }\n    }\n    return result;\n}\n\n', 'bool2int'), ('#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\n\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n        if (!item.empty()) {\n            result.push_back(item);\n        }\n    }\n    return result;\n}\n\n', 'equal_expression_transformation'), ('#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\n\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n        if (!item.empty()) {\n            result.push_back(item);\n        }\n    }\n    return result;\n}\n\n', 'bool2int'), ('#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n        if (!item.empty()) {\n            result.push_back(item);\n        }\n    }\n    return result;\n}\n\n', 'more_universe_var_type'), ('#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\n\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n        if (!item.empty()) {\n            result.push_back(item);\n        }\n    }\n    return result;\n}\n\n', 'equal_expression_transformation'), ('#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n//begin to write code\n', '#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n        if (!item.empty()) {\n            result.push_back(item);\n        }\n    }\n    return result;\n}\n', 'exchange_operators'), ('#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n        if (!item.empty()) {\n            result.push_back(item);\n        }\n    }\n    return result;\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\n\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n        if (!item.empty()) {\n            result.push_back(item);\n        }\n    }\n    return result;\n}\n\n', 'bool2int'), ('#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\n\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n        if (!item.empty()) {\n            result.push_back(item);\n        }\n    }\n    return result;\n}\n\n', 'bool2int'), ('#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\ntemplate<typename T>\nvector<T> remove_empty(vector<T> list1) {\n    vector<T> result;\n    for (auto& item : list1) {\n        if (!item.empty()) {\n            result.push_back(item);\n        }\n    }\n    return result;\n}\n\n', 'exchange_operators')]}"
351,"#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;
int max_occurrences(vector<int> nums) {
    int max_val = 0;
    int result = nums[0];
    for (int i : nums) {
        int occu = count(nums.begin(), nums.end(), i);
        if (occu > max_val) {
//begin to write code
",318,"
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

int max_occurrences(vector<int> nums) {
    int max_val = 0;
    int result = nums[0];
    for (int i : nums) {
        int occu = count(nums.begin(), nums.end(), i);
        if (occu > max_val) {
            max_val = occu;
            result = i;
        }
    }
    return result;
}


","
using namespace std;

int max_occurrences(vector<int> nums) {
    int max_val = 0;
    int result = nums[0];
    for (int i : nums) {
        int occu = count(nums.begin(), nums.end(), i);
        if (occu > max_val) {
            max_val = occu;
            result = i;
        }
    }
    return result;
}

",,,,-2,1,0.22751003901163738,code_expression_exchange:None,0.0,0.0,
352,"#include<iostream>
#include <vector>
#include <tuple>
#include <cassert>
using namespace std;
vector<tuple<int, int, int>> add_K_element(vector<tuple<int, int, int>> test_list, int K) {
    vector<tuple<int, int, int>> res;
    for (auto &sub : test_list) {
        int a, b, c;
//begin to write code
",301,"#include<iostream>
    
#include <vector>
#include <tuple>
#include <cassert>

using namespace std;

vector<tuple<int, int, int>> add_K_element(vector<tuple<int, int, int>> test_list, int K) {
    vector<tuple<int, int, int>> res;
    for (auto &sub : test_list) {
        int a, b, c;
        tie(a, b, c) = sub;
        res.push_back(make_tuple(a + K, b + K, c + K));
    }
    return res;
}","
#include<iostream>
#include <vector>
#include <tuple>
#include <cassert>
using namespace std;

vector<tuple<int, int, int>> add_K_element(vector<tuple<int, int, int>> test_list, int K) {
    vector<tuple<int, int, int>> res;
    for (auto &sub : test_list) {
        res.push_back(add_K(sub, K));
    }
    return res;
}

// Helper function to add K elements to a tuple
tuple<int, int, int> add_K(const tuple<int, int, int>& sub, int K) {
    auto [a, b, c] = sub;
    return {a + K, b + K, c + K};
}

",,,,-2,1,0.27020867268244425,code_expression_exchange:None,0.0,0.0,
353,"#include<iostream>
#include <string>
#include <cassert>
using namespace std;
char make_flip(char ch) {
    return ch == '0' ? '1' : '0';
}
int get_flip_with_starting_charcter(string str, char expected) {
    int flip_count = 0;
    for (int i = 0; i < str.length(); i++) {
        if (str[i] != expected) {
            flip_count++;
//begin to write code
",355,"#include<iostream>
    

#include <string>
#include <cassert>
using namespace std;

char make_flip(char ch) {
    return ch == '0' ? '1' : '0';
}

int get_flip_with_starting_charcter(string str, char expected) {
    int flip_count = 0;
    for (int i = 0; i < str.length(); i++) {
        if (str[i] != expected) {
            flip_count++;
        }
        expected = make_flip(expected);
    }
    return flip_count;
}

int min_flip_to_make_string_alternate(string str) {
    return min(get_flip_with_starting_charcter(str, '0'), get_flip_with_starting_charcter(str, '1'));
}


","
#include<iostream>
#include <string>
#include <cassert>
using namespace std;

char make_flip(char ch) {
    return ch == '0'? '1' : '0';
}

int get_flip_with_starting_charcter(string str, char expected) {
    int flip_count = 0;
    for (int i = 0; i < str.length(); i++) {
        if (str[i]!= expected) {
            flip_count++;
        }
    }
    return flip_count;
}

",,,,-2,1,0.2620525042215983,code_expression_exchange:None,0.0,0.0,
354,"#include <iostream>
#include <cassert>
int count_Digit(int n) {
    int count = 0;
    while (n != 0) {
        n /= 10;
//begin to write code
",143,"
#include <iostream>
#include <cassert>

int count_Digit(int n) {
    int count = 0;
    while (n != 0) {
        n /= 10;
        count += 1;
    }
    return count;
}


","
using namespace std;

#include <iostream>
#include <cassert>

int count_Digit(int n) {
    int count = 0;
    while (n!= 0) {
        n /= 10;
        count++;
    }
    return count;
}

","#include <iostream>
#include <cassert>
int count_Digit(int n) {
    int count = 0;
    while (n != 0) {
        n = n / (10);
//begin to write code
","
#include <iostream>
#include <cassert>

int count_Digit(int n) {
    int count = 0;
    while (n != 0) {
        n = n / (10);
        count = count + (1);
    }
    return count;
}


","
using namespace std;
#include <iostream>

int count_Digit(int n) {
    int count = 0;
    while (n!= 0) {
        n /= 10;
        count++;
    }
    return count;
}

",1,5,0.742209013303121,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nint count_Digit(int n) {\n    int count = 0;\n    while (n != 0) {\n        n = n / (10);\n        count = count + (1);\n    }\n    return count;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint count_Digit(int n) {\n    int count = 0;\n    while (n != 0) {\n        n = n / (10);\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint count_Digit(int n) {\n    int count = 0;\n    while (n!= 0) {\n        n = n / (10);\n        count++;\n    }\n    return count;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cassert>\nint count_Digit(int n) {\n    int count = 0;\n    while (n != 0) {\n        n = n / (10);\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n\nint count_Digit(int n) {\n    int count = 0;\n    while (n!= 0) {\n        n /= 10;\n        count++;\n    }\n    return count;\n}\n\n', 'bool2int')]}"
355,"#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
#include <climits>
using namespace std;
int adjacent_num_product(const vector<int>& list_nums) {
    int max_product = INT_MIN;
    for (size_t i = 0; i < list_nums.size() - 1; ++i) {
//begin to write code
",283,"#include<iostream>
    

#include <vector>
#include <algorithm>
#include <cassert>
#include <climits>

using namespace std;

int adjacent_num_product(const vector<int>& list_nums) {
    int max_product = INT_MIN;
    for (size_t i = 0; i < list_nums.size() - 1; ++i) {
        max_product = max(max_product, list_nums[i] * list_nums[i + 1]);
    }
    return max_product;
}


","#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
#include <climits>
using namespace std;

int adjacent_num_product(const vector<int>& list_nums) {
    if (list_nums.size() < 2) {
        throw invalid_argument(""List must contain at least two elements."");
    }

    int max_product = INT_MIN;
    for (size_t i = 0; i < list_nums.size() - 1; ++i) {
        int current_product = list_nums[i] * list_nums[i + 1];
        if (current_product > max_product) {
            max_product = current_product;
        }
    }

    return max_product;
}
","#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
#include <climits>
using namespace std;
int adjacent_num_product(const vector<long>& list_nums) {
    int max_product = INT_MIN;
    for (size_t i = 0; i < list_nums.size() - 1; ++i) {
//begin to write code
","#include<iostream>
    

#include <vector>
#include <algorithm>
#include <cassert>
#include <climits>

using namespace std;

int adjacent_num_product(const vector<long>& list_nums) {
    int max_product = INT_MIN;
    for (size_t i = 0; i < list_nums.size() - 1; ++i) {
        max_product = max(max_product, list_nums[1 + i] * list_nums[i]);
    }
    return max_product;
}


","#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
#include <climits>
using namespace std;

int adjacent_num_product(const vector<long>& list_nums) {
    if (list_nums.size() < 2) {
        return 0; // Return 0 if there are fewer than two elements
    }

    int max_product = INT_MIN;
    long left = list_nums[0];
    long right = list_nums[list_nums.size() - 1];

    for (size_t i = 1; i < list_nums.size() - 1; ++i) {
        long current_product = left * right;
        if (current_product > max_product) {
            max_product = current_product;
        }
        if (left > right) {
            left = right;
        } else {
            right = left;
        }
    }

    return max_product;
}
",1,7,1.007640826702118,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<iostream>\n    \n\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\nint adjacent_num_product(const vector<long>& list_nums) {\n    int max_product = INT_MIN;\n    for (size_t i = 0; i < list_nums.size() - 1; ++i) {\n        max_product = max(max_product, list_nums[1 + i] * list_nums[i]);\n    }\n    return max_product;\n}\n\n\n': [('#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <climits>\nusing namespace std;\nint adjacent_num_product(const vector<int>& list_nums) {\n    int max_product = INT_MIN;\n    for (size_t i = 0; i < list_nums.size() - 1; ++i) {\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <climits>\nusing namespace std;\n\nint adjacent_num_product(const vector<int>& list_nums) {\n    if (list_nums.size() < 2) {\n        return 0; // Return 0 if there are less than two numbers\n    }\n\n    int max_product = list_nums[0] * list_nums[1];\n    for (size_t i = 2; i < list_nums.size(); ++i) {\n        int current_product = list_nums[i] * list_nums[i - 1];\n        if (current_product > max_product) {\n            max_product = current_product;\n        }\n    }\n\n    return max_product;\n}\n\n', 'bool2int'), ('#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <climits>\nusing namespace std;\nint adjacent_num_product(const vector<int>& list_nums) {\n    int max_product = INT_MIN;\n    for (size_t i = 0; i < list_nums.size() - 1; ++i) {\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <climits>\nusing namespace std;\n\nint adjacent_num_product(const vector<int>& list_nums) {\n    if (list_nums.size() < 2) {\n        return 0;\n    }\n\n    int max_product = list_nums[0] * list_nums[1];\n    for (size_t i = 1; i < list_nums.size() - 1; ++i) {\n        int current_product = list_nums[i] * list_nums[i + 1];\n        if (current_product > max_product) {\n            max_product = current_product;\n        }\n    }\n\n    return max_product;\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <climits>\nusing namespace std;\nint adjacent_num_product(const vector<long>& list_nums) {\n    int max_product = INT_MIN;\n    for (size_t i = 0; i < list_nums.size() - 1; ++i) {\n//begin to write code\n', '#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <climits>\nusing namespace std;\n\nint adjacent_num_product(const vector<long>& list_nums) {\n    if (list_nums.size() < 2) {\n        return 0; // Return 0 if there are fewer than two elements\n    }\n\n    int max_product = INT_MIN;\n    long left = list_nums[0];\n    long right = list_nums[list_nums.size() - 1];\n\n    for (size_t i = 1; i < list_nums.size() - 1; ++i) {\n        long current_product = left * right;\n        if (current_product > max_product) {\n            max_product = current_product;\n        }\n        if (left > right) {\n            left = right;\n        } else {\n            right = left;\n        }\n    }\n\n    return max_product;\n}\n', 'more_universe_var_type')]}"
356,"#include <iostream>
#include <cmath>
#include <cassert>
using namespace std;
class Node {
public:
    int data;
    Node* left;
    Node* right;
    Node(int value) : data(value), left(nullptr), right(nullptr) {}
};
int get_height(Node* root) {
    if (root == nullptr) {
        return 0;
    }
    return max(get_height(root->left), get_height(root->right)) + 1;
//begin to write code
",387,"
#include <iostream>
#include <cmath>
#include <cassert>

using namespace std;

class Node {
public:
    int data;
    Node* left;
    Node* right;

    Node(int value) : data(value), left(nullptr), right(nullptr) {}
};

int get_height(Node* root) {
    if (root == nullptr) {
        return 0;
    }
    return max(get_height(root->left), get_height(root->right)) + 1;
}

bool is_tree_balanced(Node* root) {
    if (root == nullptr) {
        return true;
    }

    int lh = get_height(root->left);
    int rh = get_height(root->right);

    if (abs(lh - rh) <= 1 && is_tree_balanced(root->left) && is_tree_balanced(root->right)) {
        return true;
    }
    return false;
}


","
#include <iostream>
#include <cmath>
#include <cassert>
using namespace std;

class Node {
public:
    int data;
    Node* left;
    Node* right;
    Node(int value) : data(value), left(nullptr), right(nullptr) {}
};

int get_height(Node* root) {
    if (root == nullptr) {
        return 0;
    }
    return max(get_height(root->left), get_height(root->right)) + 1;
}

bool is_balanced(Node* root) {
    if (root == nullptr) {
        return true;
    }
    int left_height = get_height(root->left);
    int right_height = get_height(root->right);
    return abs(left_height - right_height) <= 1;
}

","#include <iostream>
#include <cmath>
#include <cassert>
using namespace std;
class Node {
public:
    int data;
    Node* left;
    Node* right;
    Node(long value) : data(value), left(nullptr), right(nullptr) {}
};
long get_height(Node* root) {
    if (nullptr == root) {
        return 0;
    }
    return 1 + max(get_height(root->left), get_height(root->right));
//begin to write code
","
#include <iostream>
#include <cmath>
#include <cassert>

using namespace std;

class Node {
public:
    int data;
    Node* left;
    Node* right;

    Node(long value) : data(value), left(nullptr), right(nullptr) {}
};

long get_height(Node* root) {
    if (nullptr == root) {
        return 0;
    }
    return 1 + max(get_height(root->left), get_height(root->right));
}

bool is_tree_balanced(Node* root) {
    if (nullptr == root) {
        return 1;
    }

    int lh = get_height(root->left);
    int rh = get_height(root->right);

    if (abs(lh - rh) <= 1 && is_tree_balanced(root->left) && is_tree_balanced(root->right)) {
        return 1;
    }
    return 0;
}


","
**Created Answer**:
",1,17,2.387571612993876,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n\n    Node(long value) : data(value), left(nullptr), right(nullptr) {}\n};\n\nlong get_height(Node* root) {\n    if (nullptr == root) {\n        return 0;\n    }\n    return 1 + max(get_height(root->left), get_height(root->right));\n}\n\nbool is_tree_balanced(Node* root) {\n    if (nullptr == root) {\n        return 1;\n    }\n\n    int lh = get_height(root->left);\n    int rh = get_height(root->right);\n\n    if (abs(lh - rh) <= 1 && is_tree_balanced(root->left) && is_tree_balanced(root->right)) {\n        return 1;\n    }\n    return 0;\n}\n\n\n': [('#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int value) : data(value), left(nullptr), right(nullptr) {}\n};\nint get_height(Node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return max(get_height(root->left), get_height(root->right)) + 1;\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int value) : data(value), left(nullptr), right(nullptr) {}\n};\n\nint get_height(Node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return max(get_height(root->left), get_height(root->right)) + 1;\n}\n\nbool is_balanced(Node* root) {\n    if (root == nullptr) {\n        return true;\n    }\n    int left_height = get_height(root->left);\n    int right_height = get_height(root->right);\n\n    if (abs(left_height - right_height) > 1) {\n        return false;\n    }\n\n    return is_balanced(root->left) && is_balanced(root->right);\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int value) : data(value), left(nullptr), right(nullptr) {}\n};\nint get_height(Node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return max(get_height(root->left), get_height(root->right)) + 1;\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int value) : data(value), left(nullptr), right(nullptr) {}\n};\n\nint get_height(Node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return max(get_height(root->left), get_height(root->right)) + 1;\n}\n\nbool is_balanced(Node* root) {\n    if (root == nullptr) {\n        return true;\n    }\n    int left_height = get_height(root->left);\n    int right_height = get_height(root->right);\n    return abs(left_height - right_height) <= 1 && is_balanced(root->left) && is_balanced(root->right);\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int value) : data(value), left(nullptr), right(nullptr) {}\n};\nlong get_height(Node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return max(get_height(root->left), get_height(root->right)) + 1;\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int value) : data(value), left(nullptr), right(nullptr) {}\n};\n\nlong get_height(Node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return max(get_height(root->left), get_height(root->right)) + 1;\n}\n\nbool is_balanced(Node* root) {\n    if (root == nullptr) {\n        return true;\n    }\n\n    long left_height = get_height(root->left);\n    long right_height = get_height(root->right);\n\n    if (abs(left_height - right_height) > 1) {\n        return false;\n    }\n\n    return is_balanced(root->left) && is_balanced(root->right);\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(long value) : data(value), left(nullptr), right(nullptr) {}\n};\nlong get_height(Node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return max(get_height(root->left), get_height(root->right)) + 1;\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(long value) : data(value), left(nullptr), right(nullptr) {}\n};\n\nlong get_height(Node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return max(get_height(root->left), get_height(root->right)) + 1;\n}\n\nbool is_balanced(Node* root) {\n    if (root == nullptr) {\n        return true;\n    }\n\n    long left_height = get_height(root->left);\n    long right_height = get_height(root->right);\n\n    if (abs(left_height - right_height) > 1) {\n        return false;\n    }\n\n    return is_balanced(root->left) && is_balanced(root->right);\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(long value) : data(value), left(nullptr), right(nullptr) {}\n};\nlong get_height(Node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return max(get_height(root->left), get_height(root->right)) + 1;\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(long value) : data(value), left(nullptr), right(nullptr) {}\n};\n\nlong get_height(Node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return max(get_height(root->left), get_height(root->right)) + 1;\n}\n\nbool is_balanced(Node* root) {\n    if (root == nullptr) {\n        return true;\n    }\n\n    long left_height = get_height(root->left);\n    long right_height = get_height(root->right);\n\n    // Check if the height difference between the left and right subtrees is less than or equal to 1\n    if (abs(left_height - right_height) > 1) {\n        return false;\n    }\n\n    // Recursively check the balance of the left and right subtrees\n    return is_balanced(root->left) && is_balanced(root->right);\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(long value) : data(value), left(nullptr), right(nullptr) {}\n};\nlong get_height(Node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return max(get_height(root->left), get_height(root->right)) + 1;\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(long value) : data(value), left(nullptr), right(nullptr) {}\n};\n\nlong get_height(Node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return max(get_height(root->left), get_height(root->right)) + 1;\n}\n\nbool is_balanced(Node* root) {\n    if (root == nullptr) {\n        return true;\n    }\n    long left_height = get_height(root->left);\n    long right_height = get_height(root->right);\n\n    // Check if the height difference between the left and right subtrees is less than 2\n    return abs(left_height - right_height) <= 1;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(long value) : data(value), left(nullptr), right(nullptr) {}\n};\nlong get_height(Node* root) {\n    if (nullptr == root) {\n        return 0;\n    }\n    return 1 + max(get_height(root->left), get_height(root->right));\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(long value) : data(value), left(nullptr), right(nullptr) {}\n};\n\nlong get_height(Node* root) {\n    if (nullptr == root) {\n        return 0;\n    }\n    return 1 + max(get_height(root->left), get_height(root->right));\n}\n\nbool is_balanced(Node* root) {\n    if (nullptr == root) {\n        return true;\n    }\n    long left_height = get_height(root->left);\n    long right_height = get_height(root->right);\n\n    if (abs(left_height - right_height) > 1) {\n        return false;\n    }\n\n    return is_balanced(root->left) && is_balanced(root->right);\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(long value) : data(value), left(nullptr), right(nullptr) {}\n};\nlong get_height(Node* root) {\n    if (nullptr == root) {\n        return 0;\n    }\n    return 1 + max(get_height(root->left), get_height(root->right));\n//begin to write code\n', '\n**Created Answer**:\n', 'bool2int')]}"
357,"#include<iostream>
#include <vector>
#include <tuple>
#include <cassert>
using namespace std;
vector<tuple<int, int>> repeat_tuples(tuple<int, int> test_tup, int N) {
    vector<tuple<int, int>> res(N, test_tup);
//begin to write code
",235,"#include<iostream>
    

#include <vector>
#include <tuple>
#include <cassert>

using namespace std;

vector<tuple<int, int>> repeat_tuples(tuple<int, int> test_tup, int N) {
    vector<tuple<int, int>> res(N, test_tup);
    return res;
}


","
#include<iostream>
#include <vector>
#include <tuple>
#include <cassert>
using namespace std;

vector<tuple<int, int>> repeat_tuples(tuple<int, int> test_tup, int N) {
    vector<tuple<int, int>> res(N, test_tup);
    return res;
}

",,,,-2,1,0.1762300451596578,code_expression_exchange:None,0.0,0.0,
358,"#include <iostream>
#include <cassert>
int lateralsurface_cuboid(int l, int w, int h) {
    int LSA = 2 * h * (l + w);
//begin to write code
",141,"
#include <iostream>
#include <cassert>

int lateralsurface_cuboid(int l, int w, int h) {
    int LSA = 2 * h * (l + w);
    return LSA;
}


","
#include <iostream>
#include <cassert>
#include <cmath>

int lateralsurface_cuboid(int l, int w, int h) {
    int LSA = 2 * h * (l + w);
    return LSA;
}

","#include <iostream>
#include <cassert>
int lateralsurface_cuboid(long l, int w, long h) {
    int LSA = (l + w) * h * 2;
//begin to write code
","
#include <iostream>
#include <cassert>

int lateralsurface_cuboid(long l, int w, long h) {
    int LSA = (l + w) * h * 2;
    return LSA;
}


","
using namespace std;
#include <iostream>

int lateralsurface_cuboid(long l, int w, long h) {
    int LSA = (l + w) * h * 2;
    return LSA;
}

",1,9,1.2384739875793458,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nint lateralsurface_cuboid(long l, int w, long h) {\n    int LSA = (l + w) * h * 2;\n    return LSA;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint lateralsurface_cuboid(long l, int w, int h) {\n    int LSA = 2 * h * (l + w);\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nint lateralsurface_cuboid(long l, int w, int h) {\n    // Calculate the lateral surface area\n    int LSA = 2 * h * (l + w);\n    \n    // Return the calculated lateral surface area\n    return LSA;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nint lateralsurface_cuboid(long l, int w, long h) {\n    int LSA = 2 * h * (l + w);\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\nint lateralsurface_cuboid(long l, int w, long h) {\n    int LSA = 2 * h * (l + w);\n    return LSA;\n}\n\n// Test cases\nvoid test_lateralsurface_cuboid() {\n    assert(lateralsurface_cuboid(2, 3, 4) == 28);\n    assert(lateralsurface_cuboid(5, 6, 7) == 94);\n    assert(lateralsurface_cuboid(0, 0, 0) == 0);\n    std::cout << ""All test cases passed!"" << std::endl;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nint lateralsurface_cuboid(long l, int w, long h) {\n    int LSA = (l + w) * h * 2;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nint lateralsurface_cuboid(long l, int w, long h) {\n    // Calculate the lateral surface area\n    int LSA = (l + w) * h * 2;\n    return LSA;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cassert>\nint lateralsurface_cuboid(long l, int w, long h) {\n    int LSA = (l + w) * h * 2;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n\nint lateralsurface_cuboid(long l, int w, long h) {\n    int LSA = (l + w) * h * 2;\n    return LSA;\n}\n\n', 'bool2int')]}"
359,"#include<iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;
vector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {
    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {
        return stof(a.second) > stof(b.second);
//begin to write code
",369,"#include<iostream>
    

#include <vector>
#include <string>
#include <algorithm>
#include <cassert>

using namespace std;

vector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {
    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {
        return stof(a.second) > stof(b.second);
    });
    return items;
}


","
#include<iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;

vector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {
    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {
        return stof(a.second) > stof(b.second);
    });
    return items;
}

","#include<iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;
vector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {
    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {
        return stof(a.second) > stof(b.second);
//begin to write code
","#include<iostream>
    

#include <vector>
#include <string>
#include <algorithm>
#include <cassert>

using namespace std;

vector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {
    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {
        return stof(a.second) > stof(b.second);
    });
    return items;
}


","#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;

vector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {
    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {
        return stof(a.second) > stof(b.second);
    });
    return items;
}
",-1,21,2.77508198817571,code_expression_exchange:more_universe_var_type,1.0,0.8195563164380016,"{'#include<iostream>\n    \n\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n    });\n    return items;\n}\n\n\n': [('#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n//begin to write code\n', '#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n    });\n    return items;\n}\n', 'exchange_operators'), ('#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n    });\n    return items;\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n//begin to write code\n', '#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n    });\n    return items;\n}\n', 'more_universe_var_type'), ('#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n    });\n    return items;\n}\n\n', 'equal_expression_transformation'), ('#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n    });\n    return items;\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n    });\n    return items;\n}\n\n', 'bool2int'), ('#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n    });\n    return items;\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n    });\n    return items;\n}\n\n', 'more_universe_var_type'), ('#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n    });\n    return items;\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<pair<string, string>> float_sort(vector<pair<string, string>>& items) {\n    sort(items.begin(), items.end(), [](const pair<string, string>& a, const pair<string, string>& b) {\n        return stof(a.second) > stof(b.second);\n    });\n    return items;\n}\n', 'more_universe_var_type')]}"
360,"#include <iostream>
#include <vector>
#include <cassert>
int smallest_missing(const std::vector<int>& A, int left_element, int right_element) {
    if (left_element > right_element) {
        return left_element;
    }
    int mid = left_element + (right_element - left_element) / 2;
//begin to write code
",306,"
#include <iostream>
#include <vector>
#include <cassert>

int smallest_missing(const std::vector<int>& A, int left_element, int right_element) {
    if (left_element > right_element) {
        return left_element;
    }
    int mid = left_element + (right_element - left_element) / 2;
    if (A[mid] == mid) {
        return smallest_missing(A, mid + 1, right_element);
    } else {
        return smallest_missing(A, left_element, mid - 1);
    }
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <cassert>

int smallest_missing(const std::vector<int>& A, int left_element, int right_element) {
    if (left_element > right_element) {
        return left_element;
    }
    int mid = left_element + (right_element - left_element) / 2;
    int count = 0;
    for (int num : A) {
        if (num <= mid) {
            count++;
        } else {
            break;
        }
    }
    return mid + 1 + count;
}

",,,,-2,1,0.24031450351079306,code_expression_exchange:None,0.0,0.0,
361,"#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;
vector<int> heap_assending(vector<int> nums) {
    make_heap(nums.begin(), nums.end());
//begin to write code
",208,"#include<iostream>
    
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

vector<int> heap_assending(vector<int> nums) {
    make_heap(nums.begin(), nums.end());
    sort_heap(nums.begin(), nums.end());
    return nums;
}","
#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

vector<int> heap_assending(vector<int> nums) {
    make_heap(nums.begin(), nums.end());
    for (int i = nums.size() - 1; i >= 0; --i) {
        swap(nums[i], nums[0]);
        make_heap(nums.begin(), nums.end());
    }
    return nums;
}

",,,,-2,1,0.2369184136390686,code_expression_exchange:None,0.0,0.0,
362,"#include<cassert>
#include<iostream>
#include<assert.h>
//
int volume_cuboid(int l, int w, int h) {
//begin to write code
",126,"#include<cassert>
#include<iostream>
#include<assert.h>

//
int volume_cuboid(int l, int w, int h) {
    return l * w * h;
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<cassert>
#include<iostream>
#include<assert.h>
int volume_cuboid(int l, int w, int h) {
    return l * w * h;
}
","#include<cassert>
#include<iostream>
#include<assert.h>
//
int volume_cuboid(int l, int w, int h) {
//begin to write code
","#include<cassert>
#include<iostream>
#include<assert.h>

//
int volume_cuboid(int l, int w, int h) {
    return l * w * h;
}


","
#include <iostream>

using namespace std;

// Function to calculate the volume of a cuboid
int volume_cuboid(int l, int w, int h) {
    return l * w * h;
}

",1,5,0.6276174306869506,code_expression_exchange:bool2int,1.0,0.0,"{'#include<cassert>\n#include<iostream>\n#include<assert.h>\n\n//\nint volume_cuboid(int l, int w, int h) {\n    return l * w * h;\n}\n\n\n': [('#include<cassert>\n#include<iostream>\n#include<assert.h>\n//\nint volume_cuboid(int l, int w, int h) {\n//begin to write code\n', '\nusing namespace std;\n\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<cassert>\n\nint volume_cuboid(int l, int w, int h) {\n    return l * w * h;\n}\n\n', 'equal_expression_transformation'), ('#include<cassert>\n#include<iostream>\n#include<assert.h>\n//\nint volume_cuboid(int l, int w, int h) {\n//begin to write code\n', '\n#include <iostream>\n\nusing namespace std;\n\n// Function to calculate the volume of a cuboid\nint volume_cuboid(int l, int w, int h) {\n    return l * w * h;\n}\n\n', 'bool2int')]}"
363,"#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;
vector<string> permute_string(string str) {
    if (str.length() == 0) {
        return vector<string> {""""};
    }
    vector<string> prev_list = permute_string(str.substr(1));
    vector<string> next_list;
    for (int i = 0; i < prev_list.size(); i++) {
        for (size_t j = 0; j <= str.length() - 1; j++) {
//begin to write code
",452,"
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>

using namespace std;

vector<string> permute_string(string str) {
    if (str.length() == 0) {
        return vector<string> {""""};
    }
    vector<string> prev_list = permute_string(str.substr(1));
    vector<string> next_list;
    for (int i = 0; i < prev_list.size(); i++) {
        for (size_t j = 0; j <= str.length() - 1; j++) {
            string new_str = prev_list[i].substr(0, j) + str[0] + prev_list[i].substr(j);
            if (find(next_list.begin(), next_list.end(), new_str) == next_list.end()) {
                next_list.push_back(new_str);
            }
        }
    }
    return next_list;
}


","
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;

vector<string> permute_string(string str) {
    if (str.length() == 0) {
        return vector<string> {""""};
    }
    vector<string> prev_list = permute_string(str.substr(1));
    vector<string> next_list;
    for (int i = 0; i < prev_list.size(); i++) {
        for (size_t j = 0; j <= str.length() - 1; j++) {
            next_list.push_back(prev_list[i] + str[j]);
        }
    }
    return next_list;
}

",,,,-2,1,0.23977306683858235,code_expression_exchange:None,0.0,0.0,
364,"#include <iostream>
#include <cassert>
int round_num(int n, int m) {
    int a = (n / m) * m;
//begin to write code
",116,"
#include <iostream>
#include <cassert>

int round_num(int n, int m) {
    int a = (n / m) * m;
    int b = a + m;
    return (n - a > b - n ? b : a);
}


","
#include <iostream>
#include <cassert>

int round_num(int n, int m) {
    return (n + m - 1) / m * m;
}

// Test cases
void test_round_num() {
    assert(round_num(10, 5) == 15);
    assert(round_num(15, 5) == 20);
    assert(round_num(20, 5) == 25);
    assert(round_num(25, 5) == 30);
    assert(round_num(30, 5) == 35);
    assert(round_num(35, 5) == 40);
    assert(round_num(40, 5) == 45);
    assert(round_num(45, 5) == 50);
    assert(round_num(50, 5) == 55);
    assert(round_num(55, 5) == 60);
    assert(round_num(60, 5) == 65);
    assert(round_num(65, 5) == 70);
    assert(round_num(70, 5) == ",,,,-2,1,0.23182803392410278,code_expression_exchange:None,0.0,0.0,
365,"#include <iostream>
#include <vector>
#include <set>
#include <tuple>
#include <cassert>
#include <typeinfo>
#include <string>
#include <stdexcept>
using namespace std;
class Element {
public:
    virtual ~Element() = default;
    virtual bool is_int() const = 0;
    virtual bool is_string() const = 0;
    virtual int get_int() const = 0;
    virtual string get_string() const = 0;
};
//  IntElement
class IntElement : public Element {
public:
    IntElement(int value) : value_(value) {}
    bool is_int() const override {
        return true;
    }
    bool is_string() const override {
        return false;
    }
    int get_int() const override {
        return value_;
    }
    string get_string() const override {
        throw runtime_error(""Not a string"");
    }
private:
    int value_;
};
//  StringElement
class StringElement : public Element {
public:
    StringElement(const string& value) : value_(value) {}
    bool is_int() const override {
        return false;
    }
    bool is_string() const override {
        return true;
    }
    int get_int() const override {
        throw runtime_error(""Not an integer"");
    }
    string get_string() const override {
        return value_;
    }
private:
    string value_;
};
struct ElementComparator {
    bool operator()(const Element* lhs, const Element* rhs) const {
        if (lhs->is_int() && rhs->is_int()) {
            return lhs->get_int() < rhs->get_int();
        } else if (lhs->is_string() && rhs->is_string()) {
//begin to write code
",1523,"#include <iostream>
#include <vector>
#include <set>
#include <tuple>
#include <cassert>
#include <typeinfo>
#include <string>
#include <stdexcept>

using namespace std;

class Element {
public:
    virtual ~Element() = default;
    virtual bool is_int() const = 0;
    virtual bool is_string() const = 0;
    virtual int get_int() const = 0;
    virtual string get_string() const = 0;
};

//  IntElement
class IntElement : public Element {
public:
    IntElement(int value) : value_(value) {}
    bool is_int() const override {
        return true;
    }
    bool is_string() const override {
        return false;
    }
    int get_int() const override {
        return value_;
    }
    string get_string() const override {
        throw runtime_error(""Not a string"");
    }
private:
    int value_;
};

//  StringElement
class StringElement : public Element {
public:
    StringElement(const string& value) : value_(value) {}
    bool is_int() const override {
        return false;
    }
    bool is_string() const override {
        return true;
    }
    int get_int() const override {
        throw runtime_error(""Not an integer"");
    }
    string get_string() const override {
        return value_;
    }
private:
    string value_;
};

struct ElementComparator {
    bool operator()(const Element* lhs, const Element* rhs) const {
        if (lhs->is_int() && rhs->is_int()) {
            return lhs->get_int() < rhs->get_int();
        } else if (lhs->is_string() && rhs->is_string()) {
            return lhs->get_string() < rhs->get_string();
        }
        return false;
    }
};

vector<Element*> remove_replica(const vector<Element*>& test_tup) {
    vector<Element*> res;
    set<Element*, ElementComparator> check;
    for (auto& item : test_tup) {
        if (item->is_int()) {
            IntElement temp(item->get_int());
            if (check.find(&temp) != check.end()) {
                res.push_back(new StringElement(""MSP""));
            } else {
                Element* new_elem = new IntElement(item->get_int());
                res.push_back(new_elem);
                check.insert(new_elem);
            }
        } else if (item->is_string()) {
            StringElement temp(item->get_string());
            if (check.find(&temp) != check.end()) {
                res.push_back(new StringElement(""MSP""));
            } else {
                Element* new_elem = new StringElement(item->get_string());
                res.push_back(new_elem);
                check.insert(new_elem);
            }
        }
    }
    return res;
}

bool compare(const vector<Element*>& r1, const vector<Element*>& r2) {
    if (r1.size() != r2.size()) {
        return false;
    }
    for (size_t i = 0; i < r1.size(); i++) {
        if (r1[i]->is_int() != r2[i]->is_int()) {
            return false;
        }
        if (r1[i]->is_int()) {
            if (r1[i]->get_int() != r2[i]->get_int()) {
                return false;
            }
        } else {
            if (r1[i]->get_string() != r2[i]->get_string()) {
                return false;
            }
        }
    }
    return true;
}","
#include <iostream>
#include <vector>
#include <set>
#include <tuple>
#include <cassert>
#include <typeinfo>
#include <string>
#include <stdexcept>
using namespace std;

class Element {
public:
    virtual ~Element() = default;
    virtual bool is_int() const = 0;
    virtual bool is_string() const = 0;
    virtual int get_int() const = 0;
    virtual string get_string() const = 0;
};

//  IntElement
class IntElement : public Element {
public:
    IntElement(int value) : value_(value) {}
    bool is_int() const override {
        return true;
    }
    bool is_string() const override {
        return false;
    }
    int get_int() const override {
        return value_;
    }
    string get_string() const override {
        throw runtime_error(""Not a string"");
    }
private:
    int value_;
};

//  StringElement
class StringElement : public Element {
public:
    String",,,,-2,1,0.23378443320592243,code_expression_exchange:None,0.0,0.0,
366,"#include<cassert>
#include <iostream>
#include <string>
#include <algorithm>
std::string remove_Char(std::string s, char c) {
    s.erase(std::remove(s.begin(), s.end(), c), s.end());
//begin to write code
",206,"#include<cassert>
#include <iostream>
#include <string>
#include <algorithm>

std::string remove_Char(std::string s, char c) {
    s.erase(std::remove(s.begin(), s.end(), c), s.end());
    return s;
}


","#include <cassert>
#include <iostream>
#include <string>
#include <algorithm>

std::string remove_Char(std::string s, char c) {
    std::string result = s;
    std::remove_if(result.begin(), result.end(), [c](char ch) { return ch == c; });
    return result;
}
",,,,-2,1,0.17257341941197712,code_expression_exchange:None,0.0,0.0,
367,"#include <vector>
#include <cassert>
#include <iostream>
std::vector<int> move_first(std::vector<int> test_list) {
    if (!test_list.empty()) {
        int last = test_list.back();
        test_list.pop_back();
//begin to write code
",234,"
#include <vector>
#include <cassert>
#include <iostream>

std::vector<int> move_first(std::vector<int> test_list) {
    if (!test_list.empty()) {
        int last = test_list.back();
        test_list.pop_back();
        test_list.insert(test_list.begin(), last);
    }
    return test_list;
}


","
using namespace std;
#include <vector>
#include <cassert>
#include <iostream>

std::vector<int> move_first(std::vector<int> test_list) {
    if (!test_list.empty()) {
        int last = test_list.back();
        test_list.pop_back();
        test_list.insert(test_list.begin(), last);
        return test_list;
    }
    return test_list; // Return an empty list if the input list is empty
}

","#include <vector>
#include <cassert>
#include <iostream>
std::vector<int> move_first(std::vector<int> test_list) {
    if (!test_list.empty()) {
        int last = test_list.back();
        test_list.pop_back();
//begin to write code
","
#include <vector>
#include <cassert>
#include <iostream>

std::vector<int> move_first(std::vector<int> test_list) {
    if (!test_list.empty()) {
        int last = test_list.back();
        test_list.pop_back();
        test_list.insert(test_list.begin(), last);
    }
    return test_list;
}


","
using namespace std;
#include <vector>
#include <cassert>

std::vector<int> move_first(std::vector<int> test_list) {
    if (!test_list.empty()) {
        int last = test_list.back();
        test_list.pop_back();
        test_list.insert(0, last);
    }
    return test_list;
}

",1,3,0.49665716886520384,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <vector>\n#include <cassert>\n#include <iostream>\n\nstd::vector<int> move_first(std::vector<int> test_list) {\n    if (!test_list.empty()) {\n        int last = test_list.back();\n        test_list.pop_back();\n        test_list.insert(test_list.begin(), last);\n    }\n    return test_list;\n}\n\n\n': [('#include <vector>\n#include <cassert>\n#include <iostream>\nstd::vector<int> move_first(std::vector<int> test_list) {\n    if (!test_list.empty()) {\n        int last = test_list.back();\n        test_list.pop_back();\n//begin to write code\n', '\nusing namespace std;\n#include <vector>\n#include <cassert>\n\nstd::vector<int> move_first(std::vector<int> test_list) {\n    if (!test_list.empty()) {\n        int last = test_list.back();\n        test_list.pop_back();\n        test_list.insert(0, last);\n    }\n    return test_list;\n}\n\n', 'exchange_operators')]}"
368,"#include<cassert>
#include<iostream>
#include<assert.h>
int surfacearea_cuboid(int l, int w, int h) {
    int SA = 2 * (l * w + l * h + w * h);
//begin to write code
",166,"#include<cassert>
#include<iostream>
#include<assert.h>

int surfacearea_cuboid(int l, int w, int h) {
    int SA = 2 * (l * w + l * h + w * h);
    return SA;
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<cassert>
#include<iostream>
#include<assert.h>

int surfacearea_cuboid(int l, int w, int h) {
    return 2 * (l * w + l * h + w * h);
}
","#include<cassert>
#include<iostream>
#include<assert.h>
int surfacearea_cuboid(long l, int w, int h) {
    int SA = 2 * (l * w + l * h + w * h);
//begin to write code
","#include<cassert>
#include<iostream>
#include<assert.h>

int surfacearea_cuboid(long l, int w, int h) {
    int SA = 2 * (l * w + l * h + w * h);
    return SA;
}


","Complete code (including all the content of the code I provided and the code you generated)
",1,3,0.4068310062090556,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<cassert>\n#include<iostream>\n#include<assert.h>\n\nint surfacearea_cuboid(long l, int w, int h) {\n    int SA = 2 * (l * w + l * h + w * h);\n    return SA;\n}\n\n\n': [('#include<cassert>\n#include<iostream>\n#include<assert.h>\nint surfacearea_cuboid(long l, int w, int h) {\n    int SA = 2 * (l * w + l * h + w * h);\n//begin to write code\n', 'Complete code (including all the content of the code I provided and the code you generated)\n', 'more_universe_var_type')]}"
369,"#include<iostream>
#include <vector>
#include <cassert>
using namespace std;
vector<vector<int>> multi_list(int rownum, int colnum) {
    vector<vector<int>> multi_list(rownum, vector<int>(colnum, 0));
    for (int row = 0; row < rownum; ++row) {
        for (int col = 0; col < colnum; ++col) {
//begin to write code
",318,"#include<iostream>
    

#include <vector>
#include <cassert>

using namespace std;

vector<vector<int>> multi_list(int rownum, int colnum) {
    vector<vector<int>> multi_list(rownum, vector<int>(colnum, 0));
    for (int row = 0; row < rownum; ++row) {
        for (int col = 0; col < colnum; ++col) {
            multi_list[row][col] = row * col;
        }
    }
    return multi_list;
}


","
#include<iostream>
#include <vector>
#include <cassert>
using namespace std;

vector<vector<int>> multi_list(int rownum, int colnum) {
    vector<vector<int>> multi_list(rownum, vector<int>(colnum, 0));
    for (int row = 0; row < rownum; ++row) {
        for (int col = 0; col < colnum; ++col) {
            // Your code here
        }
    }
    return multi_list;
}

",,,,-2,1,0.23586099942525227,code_expression_exchange:None,0.0,0.0,
370,"#include<iostream>
#include <vector>
#include <tuple>
#include <algorithm>
#include <cassert>
using namespace std;
typedef tuple<string, int, int> TupleType;
// Function to sort a vector of tuples based on the specified index within the inner tuples
vector<TupleType> index_on_inner_list(vector<TupleType> list_data, int index_no) {
    sort(list_data.begin(), list_data.end(), [index_no](const TupleType &a, const TupleType &b) {
        if (index_no == 0) return get<0>(a) < get<0>(b);
//begin to write code
",510,"#include<iostream>
    

#include <vector>
#include <tuple>
#include <algorithm>
#include <cassert>

using namespace std;

typedef tuple<string, int, int> TupleType;

// Function to sort a vector of tuples based on the specified index within the inner tuples
vector<TupleType> index_on_inner_list(vector<TupleType> list_data, int index_no) {
    sort(list_data.begin(), list_data.end(), [index_no](const TupleType &a, const TupleType &b) {
        if (index_no == 0) return get<0>(a) < get<0>(b);
        else if (index_no == 1) return get<1>(a) < get<1>(b);
        else return get<2>(a) < get<2>(b);
    });
    return list_data;
}


","
#include<iostream>
#include <vector>
#include <tuple>
#include <algorithm>
#include <cassert>
using namespace std;
typedef tuple<string, int, int> TupleType;

// Function to sort a vector of tuples based on the specified index within the inner tuples
vector<TupleType> index_on_inner_list(vector<TupleType> list_data, int index_no) {
    sort(list_data.begin(), list_data.end(), [&](const TupleType &a, const TupleType &b) {
        if (index_no == 0) return get<0>(a) < get<0>(b);
        // Compare the elements at the specified index within the inner tuples
        return get<1>(a) < get<1>(b);
    });
    return list_data;
}

",,,,-2,1,0.2454277515411377,code_expression_exchange:None,0.0,0.0,
371,"#include<iostream>
#include <vector>
#include <cassert>
using namespace std;
int find_rotation_count(const vector<int>& A) {
    int left = 0, right = A.size() - 1;
    while (left <= right) {
        if (A[left] <= A[right]) {
            return left;
        }
        int mid = (left + right) / 2;
        int next = (mid + 1) % A.size();
        int prev = (mid - 1 + A.size()) % A.size();
//begin to write code
",416,"#include<iostream>
    

#include <vector>
#include <cassert>
using namespace std;

int find_rotation_count(const vector<int>& A) {
    int left = 0, right = A.size() - 1;
    while (left <= right) {
        if (A[left] <= A[right]) {
            return left;
        }
        int mid = (left + right) / 2;
        int next = (mid + 1) % A.size();
        int prev = (mid - 1 + A.size()) % A.size();
        if (A[mid] <= A[next] && A[mid] <= A[prev]) {
            return mid;
        } else if (A[mid] <= A[right]) {
            right = mid - 1;
        } else if (A[mid] >= A[left]) {
            left = mid + 1;
        }
    }
    return -1;
}


","
#include<iostream>
#include <vector>
#include <cassert>
using namespace std;

int find_rotation_count(const vector<int>& A) {
    int left = 0, right = A.size() - 1;
    while (left <= right) {
        if (A[left] <= A[right]) {
            return left;
        }
        int mid = (left + right) / 2;
        int next = (mid + 1) % A.size();
        int prev = (mid - 1 + A.size()) % A.size();
        
        // Check if the middle element is greater than the next element
        if (A[mid] > A[next]) {
            // If the middle element is greater than the previous element, then there are no rotations
            if (A[mid] > A[prev]) {
                return -1; // No rotation
            }
            // Otherwise, the middle element is less than the previous element, so we need to find the rotation point
            right = mid - 1;
        } else {
            // If the middle element is less than the next element, then there are no rotations
            if (A[mid] < A[next]) {
                return -1;",,,,-2,1,0.23244441747665406,code_expression_exchange:None,0.0,0.0,
372,"#include <iostream>
#include <cassert>
int even_bit_toggle_number(int n) {
    int res = 0, count = 0, temp = n;
    while(temp > 0) {
        if (count % 2 == 0) {
            res = res | (1 << count);
//begin to write code
",225,"
#include <iostream>
#include <cassert>

int even_bit_toggle_number(int n) {
    int res = 0, count = 0, temp = n;
    while(temp > 0) {
        if (count % 2 == 0) {
            res = res | (1 << count);
        }
        count++;
        temp >>= 1;
    }
    return n ^ res;
}


","
using namespace std;
#include <iostream>
#include <cassert>

int even_bit_toggle_number(int n) {
    int res = 0, count = 0, temp = n;
    while(temp > 0) {
        if (count % 2 == 0) {
            res = res | (1 << count);
        }
        temp >>= 1; // Shift right by 1 bit
        count++;
    }
    return res;
}

void test_even_bit_toggle_number() {
    assert(even_bit_toggle_number(0) == 0);
    assert(even_bit_toggle_number(1) == 1);
    assert(even_bit_toggle_number(2) == 3);
    assert(even_bit_toggle_number(3) == 7);
    assert(even_bit_toggle_number(4) == 15);
    assert(even_bit_toggle_number(5) == 31);
    cout << ""All test cases passed!"" << endl;
}

",,,,-2,1,0.24294761816660562,code_expression_exchange:None,0.0,0.0,
373,"#include <iostream>
#include <vector>
#include <cassert>
int frequency_Of_Smallest(int n, std::vector<int> arr) {
    int mn = arr[0];
    int freq = 1;
    for (int i = 1; i < n; i++) {
        if (arr[i] < mn) {
            mn = arr[i];
//begin to write code
",261,"
#include <iostream>
#include <vector>
#include <cassert>

int frequency_Of_Smallest(int n, std::vector<int> arr) {
    int mn = arr[0];
    int freq = 1;
    for (int i = 1; i < n; i++) {
        if (arr[i] < mn) {
            mn = arr[i];
            freq = 1;
        } else if (arr[i] == mn) {
            freq++;
        }
    }
    return freq;
}


","#include <iostream>
#include <vector>
#include <cassert>
int frequency_Of_Smallest(int n, std::vector<int> arr) {
    if (n == 0) {
        return 0;
    }
    int mn = arr[0];
    int freq = 1;
    for (int i = 1; i < n; i++) {
        if (arr[i] < mn) {
            mn = arr[i];
            freq = 1;
        } else if (arr[i] == mn) {
            freq++;
        }
    }
    return freq;
}
","#include <iostream>
#include <vector>
#include <cassert>
int frequency_Of_Smallest(int n, std::vector<int> arr) {
    long mn = arr[0];
    int freq = 1;
    for (int i = 1; i < n; i++) {
        if (arr[i] < mn) {
            mn = arr[i];
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

int frequency_Of_Smallest(int n, std::vector<int> arr) {
    long mn = arr[0];
    int freq = 1;
    for (int i = 1; i < n; i++) {
        if (arr[i] < mn) {
            mn = arr[i];
            freq = 1;
        } else if (arr[i] == mn) {
            freq++;
        }
    }
    return freq;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

int frequency_Of_Smallest(int n, std::vector<int> arr) {
    long mn = arr[0];
    int freq = 1;
    for (int i = 1; i < n; i++) {
        if (arr[i] < mn) {
            mn = arr[i];
            freq = 1;
        } else if (arr[i] == mn) {
            freq++;
        }
    }
    return freq;
}

void test_frequency_Of_Smallest() {
    assert(frequency_Of_Smallest(5, {3, 3, 3, 3, 3}) == 5);
    assert(frequency_Of_Smallest(4, {1, 2, 3, 4}) == 1);
    assert(frequency_Of_Smallest(1, {1}) == 1);
    assert(frequency_Of_Smallest(6, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == 5);
    cout << ""All tests passed successfully.""",1,3,0.45776609182357786,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint frequency_Of_Smallest(int n, std::vector<int> arr) {\n    long mn = arr[0];\n    int freq = 1;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < mn) {\n            mn = arr[i];\n            freq = 1;\n        } else if (arr[i] == mn) {\n            freq++;\n        }\n    }\n    return freq;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nint frequency_Of_Smallest(int n, std::vector<int> arr) {\n    long mn = arr[0];\n    int freq = 1;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < mn) {\n            mn = arr[i];\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint frequency_Of_Smallest(int n, std::vector<int> arr) {\n    long mn = arr[0];\n    int freq = 1;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < mn) {\n            mn = arr[i];\n            freq = 1;\n        } else if (arr[i] == mn) {\n            freq++;\n        }\n    }\n    return freq;\n}\n\nvoid test_frequency_Of_Smallest() {\n    assert(frequency_Of_Smallest(5, {3, 3, 3, 3, 3}) == 5);\n    assert(frequency_Of_Smallest(4, {1, 2, 3, 4}) == 1);\n    assert(frequency_Of_Smallest(1, {1}) == 1);\n    assert(frequency_Of_Smallest(6, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == 5);\n    cout << ""All tests passed successfully.""', 'more_universe_var_type')]}"
374,"#include <iostream>
#include <cassert>
// 
int get_perrin(int n) {
    if (n == 0) {
        return 3;
    }
    if (n == 1) {
//begin to write code
",153,"
#include <iostream>
#include <cassert>

// 
int get_perrin(int n) {
    if (n == 0) {
        return 3;
    }
    if (n == 1) {
        return 0;
    }
    if (n == 2) {
        return 2;
    }
    return get_perrin(n - 2) + get_perrin(n - 3);
}


","
#include <iostream>
#include <cassert>

// 
int get_perrin(int n) {
    if (n == 0) {
        return 3;
    }
    if (n == 1) {
        return 6;
    }
    return 7 + get_perrin(n - 1) + get_perrin(n - 2);
}

// 
void test_get_perrin() {
    assert(get_perrin(0) == 3);
    assert(get_perrin(1) == 6);
    assert(get_perrin(2) == 7);
    std::cout << ""All tests passed successfully."" << std::endl;
}

",,,,-2,1,0.22807250022888184,code_expression_exchange:None,0.0,0.0,
375,"#include <iostream>
#include <string>
#include <cassert>
int swap_count(const std::string& s) {
    const char* chars = s.c_str();
    int count_left = 0;
    int count_right = 0;
    int swap = 0;
    int imbalance = 0; 
    for (size_t i = 0; i < s.length(); i++) {
        if (chars[i] == '[') {
            count_left += 1;
            if (imbalance > 0) {
//begin to write code
",383,"
#include <iostream>
#include <string>
#include <cassert>

int swap_count(const std::string& s) {
    const char* chars = s.c_str();
    int count_left = 0;
    int count_right = 0;
    int swap = 0;
    int imbalance = 0; 
    for (size_t i = 0; i < s.length(); i++) {
        if (chars[i] == '[') {
            count_left += 1;
            if (imbalance > 0) {
                swap += imbalance;
                imbalance -= 1;
            }
        } else if (chars[i] == ']') {
            count_right += 1;
            imbalance = count_right - count_left;
        }
    }
    return swap;
}


","
using namespace std;
#include <iostream>
#include <string>
#include <cassert>

int swap_count(const std::string& s) {
    const char* chars = s.c_str();
    int count_left = 0;
    int count_right = 0;
    int swap = 0;
    int imbalance = 0; 
    for (size_t i = 0; i < s.length(); i++) {
        if (chars[i] == '[') {
            count_left += 1;
            if (imbalance > 0) {
                // Calculate the number of swaps needed to balance the left bracket
                int swaps_needed = count_left - imbalance;
                // Update the imbalance
                imbalance -= swaps_needed;
                // Add the swaps to the total swap count
                swap += swaps_needed;
            } else {
                // If there's no imbalance, we can directly add the number of swaps needed
                swap += count_left;
            }
        } else if (chars[i] == ']') {
            count_right += 1;
            // If there's an imbalance, we need to calculate the number of swaps needed to balance the right bracket
            int swaps_needed = count_right - imbalance;
           ",,,,-2,1,0.23462324539820353,code_expression_exchange:None,0.0,0.0,
376,"#include<cassert>
#include <iostream>
#include <string>
std::string even_or_odd(const std::string& N) {
    int l = N.length();
    char last_char = N[l - 1];
    if (last_char == '0' || last_char == '2' ||
        last_char == '4' || last_char == '6' ||
        last_char == '8' || last_char == 'A' ||
//begin to write code
",325,"#include<cassert>
#include <iostream>
#include <string>

std::string even_or_odd(const std::string& N) {
    int l = N.length();
    char last_char = N[l - 1];
    if (last_char == '0' || last_char == '2' ||
        last_char == '4' || last_char == '6' ||
        last_char == '8' || last_char == 'A' ||
        last_char == 'C' || last_char == 'E') {
        return ""Even"";
    } else {
        return ""Odd"";
    }
}


","#include<cassert>
#include <iostream>
#include <string>
std::string even_or_odd(const std::string& N) {
    int l = N.length();
    char last_char = N[l - 1];
    if (last_char == '0' || last_char == '2' ||
        last_char == '4' || last_char == '6' ||
        last_char == '8' || last_char == 'A' ||
        last_char == 'C' || last_char == 'E' ||
        last_char == 'G' || last_char == 'I' ||
        last_char == 'K' || last_char == 'M' ||
        last_char == 'N' || last_char == 'P' ||
        last_char == 'Q' || last_char == 'R' ||
        last_char == 'S' || last_char == 'T' ||
        last_char == 'U' || last_char == 'V' ||
        last_char == 'W' || last_char == 'X' ||
        last_char == 'Y' || last_char == 'Z') {
        return ""Even"";
    } else {
        return ""Odd"";
    }
}
","#include<cassert>
#include <iostream>
#include <string>
std::string even_or_odd(const std::string& N) {
    int l = N.length();
    char last_char = N[l - 1];
    if (last_char == '0' || last_char == '2' ||
        last_char == '4' || last_char == '6' ||
        last_char == '8' || last_char == 'A' ||
//begin to write code
","#include<cassert>
#include <iostream>
#include <string>

std::string even_or_odd(const std::string& N) {
    int l = N.length();
    char last_char = N[l - 1];
    if (last_char == '0' || last_char == '2' ||
        last_char == '4' || last_char == '6' ||
        last_char == '8' || last_char == 'A' ||
        last_char == 'C' || last_char == 'E') {
        return ""Even"";
    } else {
        return ""Odd"";
    }
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<cassert>

std::string even_or_odd(const std::string& N) {
    int l = N.length();
    char last_char = N[l - 1];
    if (last_char == '0' || last_char == '2' ||
        last_char == '4' || last_char == '6' ||
        last_char == '8' || last_char == 'A' ||
        last_char == 'C' || last_char == 'E' ||
        last_char == 'G' || last_char == 'I' ||
        last_char == 'K' || last_char == 'M' ||
        last_char == 'N' || last_char == 'P' ||
        last_char == 'Q' || last_char == 'R' ||
        last_char == 'S' || last_char == 'T' ||
        last_char == 'U' || last_char == 'V' ||
        last_char == 'W' || last_char == 'X' ||
        last_char == 'Y' || last_char == 'Z') {
            return ""Even"";
        }",1,3,0.5000738143920899,code_expression_exchange:bool2int,1.0,0.0,"{'#include<cassert>\n#include <iostream>\n#include <string>\n\nstd::string even_or_odd(const std::string& N) {\n    int l = N.length();\n    char last_char = N[l - 1];\n    if (last_char == \'0\' || last_char == \'2\' ||\n        last_char == \'4\' || last_char == \'6\' ||\n        last_char == \'8\' || last_char == \'A\' ||\n        last_char == \'C\' || last_char == \'E\') {\n        return ""Even"";\n    } else {\n        return ""Odd"";\n    }\n}\n\n\n': [(""#include<cassert>\n#include <iostream>\n#include <string>\nstd::string even_or_odd(const std::string& N) {\n    int l = N.length();\n    char last_char = N[l - 1];\n    if (last_char == '0' || last_char == '2' ||\n        last_char == '4' || last_char == '6' ||\n        last_char == '8' || last_char == 'A' ||\n//begin to write code\n"", '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<cassert>\n\nstd::string even_or_odd(const std::string& N) {\n    int l = N.length();\n    char last_char = N[l - 1];\n    if (last_char == \'0\' || last_char == \'2\' ||\n        last_char == \'4\' || last_char == \'6\' ||\n        last_char == \'8\' || last_char == \'A\' ||\n        last_char == \'C\' || last_char == \'E\' ||\n        last_char == \'G\' || last_char == \'I\' ||\n        last_char == \'K\' || last_char == \'M\' ||\n        last_char == \'N\' || last_char == \'P\' ||\n        last_char == \'Q\' || last_char == \'R\' ||\n        last_char == \'S\' || last_char == \'T\' ||\n        last_char == \'U\' || last_char == \'V\' ||\n        last_char == \'W\' || last_char == \'X\' ||\n        last_char == \'Y\' || last_char == \'Z\') {\n            return ""Even"";\n        }', 'bool2int')]}"
377,"#include<cassert>
#include <iostream>
// 
int highest_Power_of_2(int n) {
    int res = 0;
    for (int i = n; i > 0; i--) {
        if ((i & (i - 1)) == 0) {
//begin to write code
",185,"#include<cassert>
#include <iostream>

// 
int highest_Power_of_2(int n) {
    int res = 0;
    for (int i = n; i > 0; i--) {
        if ((i & (i - 1)) == 0) {
            res = i;
            break;
        }
    }
    return res;
}


","
#include <cassert>
#include <iostream>

// 
int highest_Power_of_2(int n) {
    int res = 0;
    for (int i = n; i > 0; i--) {
        if ((i & (i - 1)) == 0) {
            res = std::max(res, i);
        }
    }
    return res;
}

","#include<cassert>
#include <iostream>
// 
int highest_Power_of_2(int n) {
    int res = 0;
    for (long i = n; i > 0; i--) {
        if ((i & (i - 1)) == 0) {
//begin to write code
","#include<cassert>
#include <iostream>

// 
int highest_Power_of_2(int n) {
    int res = 0;
    for (long i = n; i > 0; i--) {
        if ((i & (i - 1)) == 0) {
            res = i;
            break;
        }
    }
    return res;
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<cassert>
#include <iostream>
int highest_Power_of_2(int n) {
    int res = 0;
    for (long i = n; i > 0; i--) {
        if ((i & (i - 1)) == 0) {
            res = max(res, i);
        }
    }
    return res;
}
",1,3,0.4710334340731303,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<cassert>\n#include <iostream>\n\n// \nint highest_Power_of_2(int n) {\n    int res = 0;\n    for (long i = n; i > 0; i--) {\n        if ((i & (i - 1)) == 0) {\n            res = i;\n            break;\n        }\n    }\n    return res;\n}\n\n\n': [('#include<cassert>\n#include <iostream>\n// \nint highest_Power_of_2(int n) {\n    int res = 0;\n    for (long i = n; i > 0; i--) {\n        if ((i & (i - 1)) == 0) {\n//begin to write code\n', 'using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<cassert>\n#include <iostream>\nint highest_Power_of_2(int n) {\n    int res = 0;\n    for (long i = n; i > 0; i--) {\n        if ((i & (i - 1)) == 0) {\n            res = max(res, i);\n        }\n    }\n    return res;\n}\n', 'more_universe_var_type')]}"
378,"#include <iostream>
#include <cassert>
//
int find_lucas(int n) {
    if (n == 0) {
        return 2;
    }
//begin to write code
",134,"
#include <iostream>
#include <cassert>

//
int find_lucas(int n) {
    if (n == 0) {
        return 2;
    }
    if (n == 1) {
        return 1;
    }
    return find_lucas(n - 1) + find_lucas(n - 2);
}


","
using namespace std;
#include <iostream>
#include <cassert>

//
int find_lucas(int n) {
    if (n == 0) {
        return 2;
    }
    // BEGIN TO WRITE CODE
    int a = 2, b = 1, c;
    for (int i = 2; i <= n; ++i) {
        c = a + b;
        a = b;
        b = c;
    }
    // END TO WRITE CODE
    return c;
}

","#include <iostream>
#include <cassert>
//
int find_lucas(int n) {
    if (n == 0) {
        return 2;
    }
//begin to write code
","
#include <iostream>
#include <cassert>

//
int find_lucas(int n) {
    if (n == 0) {
        return 2;
    }
    if (n == 1) {
        return 1;
    }
    return find_lucas(n - 1) + find_lucas(n - 2);
}


","
#include <iostream>
#include <cassert>

//
int find_lucas(int n) {
    if (n == 0) {
        return 2;
    }
    // Your code here
    return 0; // Placeholder return value
}

// Test cases
void test_find_lucas() {
    assert(find_lucas(0) == 2);
    assert(find_lucas(1) == 1);
    assert(find_lucas(2) == 3);
    assert(find_lucas(3) == 5);
    assert(find_lucas(4) == 8);
    std::cout << ""All test cases passed!"" << std::endl;
}

",1,3,0.524825660387675,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\n//\nint find_lucas(int n) {\n    if (n == 0) {\n        return 2;\n    }\n    if (n == 1) {\n        return 1;\n    }\n    return find_lucas(n - 1) + find_lucas(n - 2);\n}\n\n\n': [('#include <iostream>\n#include <cassert>\n//\nint find_lucas(int n) {\n    if (n == 0) {\n        return 2;\n    }\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\n//\nint find_lucas(int n) {\n    if (n == 0) {\n        return 2;\n    }\n    // Your code here\n    return 0; // Placeholder return value\n}\n\n// Test cases\nvoid test_find_lucas() {\n    assert(find_lucas(0) == 2);\n    assert(find_lucas(1) == 1);\n    assert(find_lucas(2) == 3);\n    assert(find_lucas(3) == 5);\n    assert(find_lucas(4) == 8);\n    std::cout << ""All test cases passed!"" << std::endl;\n}\n\n', 'equal_expression_transformation')]}"
379,"#include <iostream>
#include <vector>
#include <string>
#include <cassert>
template <typename T>
std::vector<std::string> add_string(const std::vector<T>& list, const std::string& format) {
    std::vector<std::string> result;
    for (const auto& item : list) {
//begin to write code
",285,"
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

template <typename T>
std::vector<std::string> add_string(const std::vector<T>& list, const std::string& format) {
    std::vector<std::string> result;
    for (const auto& item : list) {
        result.push_back(format + std::to_string(item));
    }
    return result;
}


","
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

template <typename T>
std::vector<std::string> add_string(const std::vector<T>& list, const std::string& format) {
    std::vector<std::string> result;
    for (const auto& item : list) {
        result.push_back(format + item);
    }
    return result;
}

",,,,-2,1,0.22524603605270385,code_expression_exchange:None,0.0,0.0,
380,"#include <iostream>
#include <vector>
#include <map>
#include <string>
#include <cassert>
std::vector<std::map<std::string, std::map<std::string, int>>> convert_list_dictionary(const std::vector<std::string> &l1, const std::vector<std::string> &l2, const std::vector<int> &l3) {
    std::vector<std::map<std::string, std::map<std::string, int>>> result;
    for (size_t i = 0; i < l1.size(); ++i) {
//begin to write code
",421,"
#include <iostream>
#include <vector>
#include <map>
#include <string>
#include <cassert>

std::vector<std::map<std::string, std::map<std::string, int>>> convert_list_dictionary(const std::vector<std::string> &l1, const std::vector<std::string> &l2, const std::vector<int> &l3) {
    std::vector<std::map<std::string, std::map<std::string, int>>> result;
    for (size_t i = 0; i < l1.size(); ++i) {
        result.push_back({{l1[i], {{l2[i], l3[i]}}}});
    }
    return result;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <map>
#include <string>
#include <cassert>

std::vector<std::map<std::string, std::map<std::string, int>>> convert_list_dictionary(const std::vector<std::string> &l1, const std::vector<std::string> &l2, const std::vector<int> &l3) {
    std::vector<std::map<std::string, std::map<std::string, int>>> result;
    for (size_t i = 0; i < l1.size(); ++i) {
        // Initialize a new map to hold the nested dictionary for each list item
        std::map<std::string, std::map<std::string, int>> sub_map;
        
        // Iterate over the second list to populate the nested dictionary
        for (size_t j = 0; j < l2.size(); ++j) {
            // Check if the current list item matches the key in the second list
            if (l1[i] == l2[j]) {
                // Add the third list item to the nested dictionary
                sub_map[l2[j]] = l3[j];
            }
       ",,,,-2,1,0.23316872517267864,code_expression_exchange:None,0.0,0.0,
381,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
int get_max_sum(int n) {
    std::vector<int> res;
    res.push_back(0);
    res.push_back(1);
//begin to write code
",194,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>

int get_max_sum(int n) {
    std::vector<int> res;
    res.push_back(0);
    res.push_back(1);

    for (int i = 2; i <= n; ++i) {
        res.push_back(std::max(i, res[i / 2] + res[i / 3] + res[i / 4] + res[i / 5]));
    }

    return res[n];
}


","
using namespace std;

#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>

int get_max_sum(int n) {
    std::vector<int> res;
    res.push_back(0);
    res.push_back(1);

    // Function to calculate the maximum sum of the subarray ending at index i
    int max_subarray_sum(int i, vector<int>& dp) {
        if (i == 0) return dp[0];
        if (i == 1) return dp[1];

        int left_max = dp[i - 1];
        int right_max = dp[i - 2];
        int include_current = dp[i] + left_max + right_max;

        return max(include_current, max_subarray_sum(i - 2, dp));
    }

    // Initialize the DP array
    for (int i = 0; i <= n; ++i) {
        dp.push_back(-1);
    }

    // Fill the DP array
    for (int i = 1; i <= n; ++i) {
        dp[i] = max_subarray_sum(i, dp);
    }

    // Return the maximum sum
    return dp[n];
}

",,,,-2,1,0.234828515847524,code_expression_exchange:None,0.0,0.0,
382,"#include <vector>
#include <iostream>
#include <cassert>
std::pair<int, std::vector<int>> max_length_list(const std::vector<std::vector<int>>& input_list) {
    int max_length = 0;
    std::vector<int> max_list;
    for (const auto& vec : input_list) {
        if (vec.size() > max_length) {
//begin to write code
",314,"
#include <vector>
#include <iostream>
#include <cassert>

std::pair<int, std::vector<int>> max_length_list(const std::vector<std::vector<int>>& input_list) {
    int max_length = 0;
    std::vector<int> max_list;
    for (const auto& vec : input_list) {
        if (vec.size() > max_length) {
            max_length = vec.size();
            max_list = vec;
        }
    }
    return {max_length, max_list};
}


","
using namespace std;
#include <vector>
#include <iostream>
#include <cassert>

std::pair<int, std::vector<int>> max_length_list(const std::vector<std::vector<int>>& input_list) {
    int max_length = 0;
    std::vector<int> max_list;
    for (const auto& vec : input_list) {
        if (vec.size() > max_length) {
            max_length = vec.size();
            max_list = vec;
        }
    }
    return {max_length, max_list};
}

","#include <vector>
#include <iostream>
#include <cassert>
std::pair<long, std::vector<int>> max_length_list(const std::vector<std::vector<int>>& input_list) {
    int max_length = 0;
    std::vector<int> max_list;
    for (const auto& vec : input_list) {
        if (vec.size() > max_length) {
//begin to write code
","
#include <vector>
#include <iostream>
#include <cassert>

std::pair<long, std::vector<int>> max_length_list(const std::vector<std::vector<int>>& input_list) {
    int max_length = 0;
    std::vector<int> max_list;
    for (const auto& vec : input_list) {
        if (vec.size() > max_length) {
            max_length = vec.size();
            max_list = vec;
        }
    }
    return {max_length, max_list};
}


","
using namespace std;

#include <vector>
#include <iostream>
#include <cassert>

std::pair<long, std::vector<int>> max_length_list(const std::vector<std::vector<int>>& input_list) {
    int max_length = 0;
    std::vector<int> max_list;
    for (const auto& vec : input_list) {
        if (vec.size() > max_length) {
            max_length = vec.size();
            max_list = vec;
        }
    }
    return {max_length, max_list};
}

",1,3,0.49158592224121095,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <vector>\n#include <iostream>\n#include <cassert>\n\nstd::pair<long, std::vector<int>> max_length_list(const std::vector<std::vector<int>>& input_list) {\n    int max_length = 0;\n    std::vector<int> max_list;\n    for (const auto& vec : input_list) {\n        if (vec.size() > max_length) {\n            max_length = vec.size();\n            max_list = vec;\n        }\n    }\n    return {max_length, max_list};\n}\n\n\n': [('#include <vector>\n#include <iostream>\n#include <cassert>\nstd::pair<long, std::vector<int>> max_length_list(const std::vector<std::vector<int>>& input_list) {\n    int max_length = 0;\n    std::vector<int> max_list;\n    for (const auto& vec : input_list) {\n        if (vec.size() > max_length) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n\nstd::pair<long, std::vector<int>> max_length_list(const std::vector<std::vector<int>>& input_list) {\n    int max_length = 0;\n    std::vector<int> max_list;\n    for (const auto& vec : input_list) {\n        if (vec.size() > max_length) {\n            max_length = vec.size();\n            max_list = vec;\n        }\n    }\n    return {max_length, max_list};\n}\n\n', 'more_universe_var_type')]}"
383,"#include <iostream>
#include <set>
#include <vector>
#include <cassert>
bool check_distinct(std::vector<int> test_vec) {
    bool res = true;
    std::set<int> temp;
    for (int ele : test_vec) {
        if (temp.find(ele) != temp.end()) {
            res = false;
//begin to write code
",288,"
#include <iostream>
#include <set>
#include <vector>
#include <cassert>

bool check_distinct(std::vector<int> test_vec) {
    bool res = true;
    std::set<int> temp;
    for (int ele : test_vec) {
        if (temp.find(ele) != temp.end()) {
            res = false;
            break;
        }
        temp.insert(ele);
    }
    return res;
}


","
using namespace std;
#include <iostream>
#include <set>
#include <vector>
#include <cassert>

bool check_distinct(std::vector<int> test_vec) {
    // Using set to store unique elements
    std::set<int> temp(test_vec.begin(), test_vec.end());
    // Check if the size of the set is equal to the size of the vector
    return temp.size() == test_vec.size();
}

","#include <iostream>
#include <set>
#include <vector>
#include <cassert>
bool check_distinct(std::vector<int> test_vec) {
    bool res = true;
    std::set<int> temp;
    for (long ele : test_vec) {
        if (temp.find(ele) != temp.end()) {
            res = false;
//begin to write code
","
#include <iostream>
#include <set>
#include <vector>
#include <cassert>

bool check_distinct(std::vector<int> test_vec) {
    bool res = true;
    std::set<int> temp;
    for (long ele : test_vec) {
        if (temp.find(ele) != temp.end()) {
            res = false;
            break;
        }
        temp.insert(ele);
    }
    return res;
}


","#include <iostream>
#include <set>
#include <vector>
#include <cassert>

bool check_distinct(std::vector<int> test_vec1, std::vector<int> test_vec2) {
    // Create sets from the vectors
    std::set<int> set1(test_vec1);
    std::set<int> set2(test_vec2);

    // Compare the sizes of the sets
    return set1.size()!= set2.size();
}
",1,11,1.5265974958737691,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\n\nbool check_distinct(std::vector<int> test_vec) {\n    bool res = true;\n    std::set<int> temp;\n    for (long ele : test_vec) {\n        if (temp.find(ele) != temp.end()) {\n            res = false;\n            break;\n        }\n        temp.insert(ele);\n    }\n    return res;\n}\n\n\n': [('#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\nbool check_distinct(std::vector<int> test_vec) {\n    bool res = true;\n    std::set<int> temp;\n    for (long ele : test_vec) {\n        if (temp.find(ele) != temp.end()) {\n            res = false;\n//begin to write code\n', '#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\n\nbool check_distinct(std::vector<int> test_vec) {\n    std::set<int> temp;\n    for (long ele : test_vec) {\n        if (temp.find(ele)!= temp.end()) {\n            return false; // If duplicate element is found, return false\n        }\n        temp.insert(ele); // Insert the element into the set\n    }\n    return true; // If no duplicates are found, return true\n}\n', 'more_universe_var_type'), ('#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\nbool check_distinct(std::vector<int> test_vec) {\n    bool res = true;\n    std::set<int> temp;\n    for (long ele : test_vec) {\n        if (temp.end() != temp.find(ele)) {\n            res = false;\n//begin to write code\n', '\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\n\nbool check_distinct(std::vector<int> test_vec) {\n    std::set<int> temp;\n    for (long ele : test_vec) {\n        if (temp.end()!= temp.find(ele)) {\n            return false;\n        }\n        temp.insert(ele);\n    }\n    return true;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\nbool check_distinct(std::vector<int> test_vec) {\n    bool res = true;\n    std::set<int> temp;\n    for (long ele : test_vec) {\n        if (temp.find(ele) != temp.end()) {\n            res = false;\n//begin to write code\n', '\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\n\nbool check_distinct(std::vector<int> test_vec) {\n    std::set<int> temp;\n    for (long ele : test_vec) {\n        if (temp.find(ele)!= temp.end()) {\n            return false;\n        }\n        temp.insert(ele);\n    }\n    return true;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\nbool check_distinct(std::vector<int> test_vec) {\n    bool res = true;\n    std::set<int> temp;\n    for (long ele : test_vec) {\n        if (temp.find(ele) != temp.end()) {\n            res = false;\n//begin to write code\n', '#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\n\nbool check_distinct(std::vector<int> test_vec) {\n    bool res = true;\n    std::set<int> temp;\n    for (long ele : test_vec) {\n        if (temp.find(ele)!= temp.end()) {\n            res = false;\n        } else {\n            temp.insert(ele);\n        }\n    }\n    return res;\n}\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\nbool check_distinct(std::vector<int> test_vec) {\n    bool res = true;\n    std::set<int> temp;\n    for (long ele : test_vec) {\n        if (temp.find(ele) != temp.end()) {\n            res = false;\n//begin to write code\n', '#include <iostream>\n#include <set>\n#include <vector>\n#include <cassert>\n\nbool check_distinct(std::vector<int> test_vec1, std::vector<int> test_vec2) {\n    // Create sets from the vectors\n    std::set<int> set1(test_vec1);\n    std::set<int> set2(test_vec2);\n\n    // Compare the sizes of the sets\n    return set1.size()!= set2.size();\n}\n', 'equal_expression_transformation')]}"
384,"#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <cassert>
char first_non_repeating_character(const std::string& str1) {
    std::vector<char> char_order;
    std::map<char, int> ctr;
    for (char c : str1) {
        if (ctr.find(c) != ctr.end()) {
            ctr[c] += 1;
        } else {
            ctr[c] = 1;
            char_order.push_back(c);
//begin to write code
",406,"
#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <cassert>

char first_non_repeating_character(const std::string& str1) {
    std::vector<char> char_order;
    std::map<char, int> ctr;
    for (char c : str1) {
        if (ctr.find(c) != ctr.end()) {
            ctr[c] += 1;
        } else {
            ctr[c] = 1;
            char_order.push_back(c);
        }
    }
    for (char c : char_order) {
        if (ctr[c] == 1) {
            return c;
        }
    }
    return '\0'; // using '\0' to denote no non-repeating character found, similar to None in Python
}


","
using namespace std;
#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <cassert>

char first_non_repeating_character(const std::string& str1) {
    std::vector<char> char_order;
    std::map<char, int> ctr;
    for (char c : str1) {
        if (ctr.find(c)!= ctr.end()) {
            ctr[c] += 1;
        } else {
            ctr[c] = 1;
            char_order.push_back(c);
        }
    }
    for (char c : char_order) {
        if (ctr[c] == 1) {
            return c;
        }
    }
    return '\0'; // Return null character if no non-repeating character is found
}

","#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <cassert>
char first_non_repeating_character(const std::string& str1) {
    std::vector<char> char_order;
    std::map<char, long> ctr;
    for (char c : str1) {
        if (ctr.find(c) != ctr.end()) {
            ctr[c] += 1;
        } else {
            ctr[c] = 1;
            char_order.push_back(c);
//begin to write code
","
#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <cassert>

char first_non_repeating_character(const std::string& str1) {
    std::vector<char> char_order;
    std::map<char, long> ctr;
    for (char c : str1) {
        if (ctr.find(c) != ctr.end()) {
            ctr[c] += 1;
        } else {
            ctr[c] = 1;
            char_order.push_back(c);
        }
    }
    for (char c : char_order) {
        if (ctr[c] == 1) {
            return c;
        }
    }
    return '\0'; // using '\0' to denote no non-repeating character found, similar to None in Python
}


","
using namespace std;

#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <cassert>

char first_non_repeating_character(const std::string& str1) {
    std::vector<char> char_order;
    std::map<char, long> ctr;
    for (char c : str1) {
        if (ctr.find(c)!= ctr.end()) {
            ctr[c] += 1;
        } else {
            ctr[c] = 1;
            char_order.push_back(c);
        }
    }

    // Find the first character that appears only once
    for (char c : char_order) {
        if (ctr[c] == 1) {
            return c;
        }
    }

    // If no non-repeating character is found, return 'n'
    return 'n';
}

",1,3,0.5220072944959004,code_expression_exchange:more_universe_var_type,1.0,0.0,"{""\n#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <cassert>\n\nchar first_non_repeating_character(const std::string& str1) {\n    std::vector<char> char_order;\n    std::map<char, long> ctr;\n    for (char c : str1) {\n        if (ctr.find(c) != ctr.end()) {\n            ctr[c] += 1;\n        } else {\n            ctr[c] = 1;\n            char_order.push_back(c);\n        }\n    }\n    for (char c : char_order) {\n        if (ctr[c] == 1) {\n            return c;\n        }\n    }\n    return '\\0'; // using '\\0' to denote no non-repeating character found, similar to None in Python\n}\n\n\n"": [('#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <cassert>\nchar first_non_repeating_character(const std::string& str1) {\n    std::vector<char> char_order;\n    std::map<char, long> ctr;\n    for (char c : str1) {\n        if (ctr.find(c) != ctr.end()) {\n            ctr[c] += 1;\n        } else {\n            ctr[c] = 1;\n            char_order.push_back(c);\n//begin to write code\n', ""\nusing namespace std;\n\n#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <cassert>\n\nchar first_non_repeating_character(const std::string& str1) {\n    std::vector<char> char_order;\n    std::map<char, long> ctr;\n    for (char c : str1) {\n        if (ctr.find(c)!= ctr.end()) {\n            ctr[c] += 1;\n        } else {\n            ctr[c] = 1;\n            char_order.push_back(c);\n        }\n    }\n\n    // Find the first character that appears only once\n    for (char c : char_order) {\n        if (ctr[c] == 1) {\n            return c;\n        }\n    }\n\n    // If no non-repeating character is found, return 'n'\n    return 'n';\n}\n\n"", 'more_universe_var_type')]}"
385,"#include <iostream>
#include <regex>
#include <cassert>
using namespace std;
string check_char(string str) {
    int p1 = 0;
    int p2 = str.size() -1 ;
    if(str[p1] == str[p2])
//begin to write code
",203,"#include <iostream>
#include <regex>
#include <cassert>
using namespace std;

string check_char(string str) {
    int p1 = 0;
    int p2 = str.size() -1 ;
    if(str[p1] == str[p2])
    {
        return ""Valid"";
    }
    return ""Invalid"";
}","
#include <iostream>
#include <regex>
#include <cassert>
using namespace std;

bool check_char(string str) {
    // Check if the first and last characters of the string are the same
    return str[0] == str[str.size() - 1];
}

",,,,-2,1,0.24157766501108804,code_expression_exchange:None,0.0,0.0,
386,"#include <iostream>
#include <cassert>
int median_numbers(int a, int b, int c) {
    int median;
    if (a > b) {
        if (a < c) {
            median = a;
        } else if (b > c) {
            median = b;
        } else {
            median = c;
        }
//begin to write code
",284,"
#include <iostream>
#include <cassert>

int median_numbers(int a, int b, int c) {
    int median;
    if (a > b) {
        if (a < c) {
            median = a;
        } else if (b > c) {
            median = b;
        } else {
            median = c;
        }
    } else {
        if (a > c) {
            median = a;
        } else if (b < c) {
            median = b;
        } else {
            median = c;
        }
    }
    return median;
}


","
using namespace std;

#include <iostream>
#include <cassert>

int median_numbers(int a, int b, int c) {
    // Ensure a is the smallest number
    if (a > b) {
        swap(a, b);
    }
    if (a > c) {
        swap(a, c);
    }
    if (b > c) {
        swap(b, c);
    }

    // Calculate the median
    int mid = a + b + c - 2 * a;
    return mid;
}

",,,,-2,1,0.23576441208521526,code_expression_exchange:None,0.0,0.0,
387,"#include <iostream>
#include <vector>
#include <string>
#include <cassert>
#include <cctype>
using namespace std;
int sum_of_digits(vector<int> nums) {
    int result = 0;
    for (int n : nums) {
        string numStr = to_string(n);
        for (char c : numStr) {
            if (isdigit(c)) {
//begin to write code
",319,"
#include <iostream>
#include <vector>
#include <string>
#include <cassert>
#include <cctype>

using namespace std;

int sum_of_digits(vector<int> nums) {
    int result = 0;
    for (int n : nums) {
        string numStr = to_string(n);
        for (char c : numStr) {
            if (isdigit(c)) {
                result += c - '0';
            }
        }
    }
    return result;
}


","
#include <iostream>
#include <vector>
#include <string>
#include <cassert>
#include <cctype>
using namespace std;

int sum_of_digits(vector<int> nums) {
    int result = 0;
    for (int n : nums) {
        string numStr = to_string(n);
        for (char c : numStr) {
            if (isdigit(c)) {
                result += c - '0'; // Convert character to integer and add to result
            }
        }
    }
    return result;
}

","#include <iostream>
#include <vector>
#include <string>
#include <cassert>
#include <cctype>
using namespace std;
int sum_of_digits(vector<int> nums) {
    int result = 0;
    for (int n : nums) {
        string numStr = to_string(n);
        for (char c : numStr) {
            if (isdigit(c)) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <string>
#include <cassert>
#include <cctype>

using namespace std;

int sum_of_digits(vector<int> nums) {
    int result = 0;
    for (int n : nums) {
        string numStr = to_string(n);
        for (char c : numStr) {
            if (isdigit(c)) {
                result += c - '0';
            }
        }
    }
    return result;
}


","
#include <iostream>
#include <vector>
#include <string>
#include <cassert>
#include <cctype>
using namespace std;

int sum_of_digits(vector<int> nums) {
    int result = 0;
    for (int n : nums) {
        string numStr = to_string(n);
        for (char c : numStr) {
            if (isdigit(c)) {
                // Calculate the sum of digits
                int digitSum = 0;
                while (c!= '\0') {
                    digitSum += c - '0';
                    c = to_char(c - '0');
                }
                result += digitSum;
            }
        }
    }
    return result;
}

void test_sum_of_digits() {
    assert(sum_of_digits({123, 456, 789}) == 27); // 1+2+3 + 4+5+6 + 7+8+9 = 36
    assert(sum_of_digits({111, 222, 333}) == 66); // 1+1+1 + 2+2+2 + 3+3+3 = 20
",1,3,0.49659566084543866,code_expression_exchange:bool2int,1.0,0.0,"{""\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <cctype>\n\nusing namespace std;\n\nint sum_of_digits(vector<int> nums) {\n    int result = 0;\n    for (int n : nums) {\n        string numStr = to_string(n);\n        for (char c : numStr) {\n            if (isdigit(c)) {\n                result += c - '0';\n            }\n        }\n    }\n    return result;\n}\n\n\n"": [('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <cctype>\nusing namespace std;\nint sum_of_digits(vector<int> nums) {\n    int result = 0;\n    for (int n : nums) {\n        string numStr = to_string(n);\n        for (char c : numStr) {\n            if (isdigit(c)) {\n//begin to write code\n', ""\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <cctype>\nusing namespace std;\n\nint sum_of_digits(vector<int> nums) {\n    int result = 0;\n    for (int n : nums) {\n        string numStr = to_string(n);\n        for (char c : numStr) {\n            if (isdigit(c)) {\n                // Calculate the sum of digits\n                int digitSum = 0;\n                while (c!= '\\0') {\n                    digitSum += c - '0';\n                    c = to_char(c - '0');\n                }\n                result += digitSum;\n            }\n        }\n    }\n    return result;\n}\n\nvoid test_sum_of_digits() {\n    assert(sum_of_digits({123, 456, 789}) == 27); // 1+2+3 + 4+5+6 + 7+8+9 = 36\n    assert(sum_of_digits({111, 222, 333}) == 66); // 1+1+1 + 2+2+2 + 3+3+3 = 20\n"", 'bool2int')]}"
388,"#include <iostream>
#include <vector>
#include <cassert>
#include <tuple>
std::tuple<int, int, int, int> bitwise_xor(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {
    return std::make_tuple(
        std::get<0>(test_tup1) ^ std::get<0>(test_tup2),
        std::get<1>(test_tup1) ^ std::get<1>(test_tup2),
//begin to write code
",381,"
#include <iostream>
#include <vector>
#include <cassert>
#include <tuple>

std::tuple<int, int, int, int> bitwise_xor(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {
    return std::make_tuple(
        std::get<0>(test_tup1) ^ std::get<0>(test_tup2),
        std::get<1>(test_tup1) ^ std::get<1>(test_tup2),
        std::get<2>(test_tup1) ^ std::get<2>(test_tup2),
        std::get<3>(test_tup1) ^ std::get<3>(test_tup2)
    );
}


","
#include <iostream>
#include <vector>
#include <cassert>
#include <tuple>
std::tuple<int, int, int, int> bitwise_xor(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {
    return std::make_tuple(
        std::get<0>(test_tup1) ^ std::get<0>(test_tup2),
        std::get<1>(test_tup1) ^ std::get<1>(test_tup2),
        std::get<2>(test_tup1) ^ std::get<2>(test_tup2),
        std::get<3>(test_tup1) ^ std::get<3>(test_tup2)
    );
}

","#include <iostream>
#include <vector>
#include <cassert>
#include <tuple>
std::tuple<long, long, int, int> bitwise_xor(const std::tuple<int, int, int, long>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {
    return std::make_tuple(
        std::get<0>(test_tup2) ^ std::get<0>(test_tup1),
        std::get<1>(test_tup2) ^ std::get<1>(test_tup1),
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>
#include <tuple>

std::tuple<long, long, int, int> bitwise_xor(const std::tuple<int, int, int, long>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {
    return std::make_tuple(
        std::get<0>(test_tup2) ^ std::get<0>(test_tup1),
        std::get<1>(test_tup2) ^ std::get<1>(test_tup1),
        std::get<2>(test_tup2) ^ std::get<2>(test_tup1),
        std::get<3>(test_tup2) ^ std::get<3>(test_tup1)
    );
}


","
#include <iostream>
#include <vector>
#include <cassert>
#include <tuple>
#include <algorithm>

std::tuple<long, long, int, int> bitwise_xor(const std::tuple<int, int, int, long>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {
    // Extract the first two elements of each tuple
    int x1 = std::get<0>(test_tup1);
    int y1 = std::get<1>(test_tup1);
    int z1 = std::get<2>(test_tup1);
    int w1 = std::get<3>(test_tup1);

    int x2 = std::get<0>(test_tup2);
    int y2 = std::get<1>(test_tup2);
    int z2 = std::get<2>(test_tup2);
    int w2 = std::get<3>(test_tup2);

    // Perform bitwise XOR on the first two elements
    int result_x = x1 ^ x2;
    int result_y = y1 ^ y2;
    int result_z = z1 ^ z",1,15,2.1082523425420123,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <tuple>\n\nstd::tuple<long, long, int, int> bitwise_xor(const std::tuple<int, int, int, long>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) ^ std::get<0>(test_tup1),\n        std::get<1>(test_tup2) ^ std::get<1>(test_tup1),\n        std::get<2>(test_tup2) ^ std::get<2>(test_tup1),\n        std::get<3>(test_tup2) ^ std::get<3>(test_tup1)\n    );\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <tuple>\nstd::tuple<int, int, int, int> bitwise_xor(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup1) ^ std::get<0>(test_tup2),\n        std::get<1>(test_tup1) ^ std::get<1>(test_tup2),\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <cassert>\n#include <tuple>\nstd::tuple<int, int, int, int> bitwise_xor(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup1) ^ std::get<0>(test_tup2),\n        std::get<1>(test_tup1) ^ std::get<1>(test_tup2),\n        std::get<2>(test_tup1) ^ std::get<2>(test_tup2),\n        std::get<3>(test_tup1) ^ std::get<3>(test_tup2)\n    );\n}\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <tuple>\nstd::tuple<int, int, int, int> bitwise_xor(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) ^ std::get<0>(test_tup1),\n        std::get<1>(test_tup2) ^ std::get<1>(test_tup1),\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <tuple>\n#include <algorithm>\n\nstd::tuple<int, int, int, int> bitwise_xor(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) ^ std::get<0>(test_tup1),\n        std::get<1>(test_tup2) ^ std::get<1>(test_tup1),\n        std::get<2>(test_tup2) ^ std::get<2>(test_tup1),\n        std::get<3>(test_tup2) ^ std::get<3>(test_tup1)\n    );\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <tuple>\nstd::tuple<int, int, int, int> bitwise_xor(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) ^ std::get<0>(test_tup1),\n        std::get<1>(test_tup2) ^ std::get<1>(test_tup1),\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <tuple>\n\nstd::tuple<int, int, int, int> bitwise_xor(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) ^ std::get<0>(test_tup1),\n        std::get<1>(test_tup2) ^ std::get<1>(test_tup1),\n        std::get<2>(test_tup2) ^ std::get<2>(test_tup1),\n        std::get<3>(test_tup2) ^ std::get<3>(test_tup1)\n    );\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <tuple>\nstd::tuple<int, long, int, int> bitwise_xor(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) ^ std::get<0>(test_tup1),\n        std::get<1>(test_tup2) ^ std::get<1>(test_tup1),\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <tuple>\n\nstd::tuple<int, long, int, int> bitwise_xor(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) ^ std::get<0>(test_tup1),\n        std::get<1>(test_tup2) ^ std::get<1>(test_tup1),\n        std::get<2>(test_tup2) ^ std::get<2>(test_tup1),\n        std::get<3>(test_tup2) ^ std::get<3>(test_tup1)\n    );\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <tuple>\nstd::tuple<int, long, int, int> bitwise_xor(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) ^ std::get<0>(test_tup1),\n        std::get<1>(test_tup2) ^ std::get<1>(test_tup1),\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <tuple>\n#include <algorithm>\n\nstd::tuple<int, long, int, int> bitwise_xor(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    // Perform the bitwise XOR operation across the given tuples\n    return std::make_tuple(\n        std::get<0>(test_tup2) ^ std::get<0>(test_tup1),\n        std::get<1>(test_tup2) ^ std::get<1>(test_tup1),\n        std::get<2>(test_tup2) ^ std::get<2>(test_tup1),\n        std::get<3>(test_tup2) ^ std::get<3>(test_tup1)\n    );\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <tuple>\nstd::tuple<int, long, int, int> bitwise_xor(const std::tuple<int, int, int, long>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) ^ std::get<0>(test_tup1),\n        std::get<1>(test_tup2) ^ std::get<1>(test_tup1),\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <tuple>\n\nstd::tuple<int, long, int, int> bitwise_xor(const std::tuple<int, int, int, long>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) ^ std::get<0>(test_tup1),\n        std::get<1>(test_tup2) ^ std::get<1>(test_tup1),\n        std::get<2>(test_tup2) ^ std::get<2>(test_tup1),\n        std::get<3>(test_tup2) ^ std::get<3>(test_tup1)\n    );\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <tuple>\nstd::tuple<long, long, int, int> bitwise_xor(const std::tuple<int, int, int, long>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) ^ std::get<0>(test_tup1),\n        std::get<1>(test_tup2) ^ std::get<1>(test_tup1),\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <tuple>\n#include <algorithm>\n\nstd::tuple<long, long, int, int> bitwise_xor(const std::tuple<int, int, int, long>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    // Extract the first two elements of each tuple\n    int x1 = std::get<0>(test_tup1);\n    int y1 = std::get<1>(test_tup1);\n    int z1 = std::get<2>(test_tup1);\n    int w1 = std::get<3>(test_tup1);\n\n    int x2 = std::get<0>(test_tup2);\n    int y2 = std::get<1>(test_tup2);\n    int z2 = std::get<2>(test_tup2);\n    int w2 = std::get<3>(test_tup2);\n\n    // Perform bitwise XOR on the first two elements\n    int result_x = x1 ^ x2;\n    int result_y = y1 ^ y2;\n    int result_z = z1 ^ z', 'more_universe_var_type')]}"
389,"#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
#include <cassert>
int extract_freq(const std::vector<std::pair<int, int>>& test_list) {
    std::set<std::pair<int, int>> unique_tuples;
    for (const auto& sub : test_list) {
        if (sub.first <= sub.second) {
            unique_tuples.insert(sub);
//begin to write code
",352,"
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
#include <cassert>

int extract_freq(const std::vector<std::pair<int, int>>& test_list) {
    std::set<std::pair<int, int>> unique_tuples;
    for (const auto& sub : test_list) {
        if (sub.first <= sub.second) {
            unique_tuples.insert(sub);
        } else {
            unique_tuples.insert({sub.second, sub.first});
        }
    }
    return unique_tuples.size();
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
#include <cassert>

int extract_freq(const std::vector<std::pair<int, int>>& test_list) {
    std::set<std::pair<int, int>> unique_tuples;
    for (const auto& sub : test_list) {
        if (sub.first <= sub.second) {
            unique_tuples.insert(sub);
        }
    }

    // Use a map to count the frequency of each unique tuple
    std::map<std::pair<int, int>, int> freq_map;
    for (const auto& sub : unique_tuples) {
        ++freq_map[sub];
    }

    return freq_map.size();
}

",,,,-2,1,0.24974008003870646,code_expression_exchange:None,0.0,0.0,
390,"#include<iostream>
#include <tuple>
#include <cassert>
using namespace std;
tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> add_nested_tuples(
    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> test_tup1,
    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> test_tup2) 
{
    tuple<int, int> res1 = make_tuple(get<0>(get<0>(test_tup1)) + get<0>(get<0>(test_tup2)), get<1>(get<0>(test_tup1)) + get<1>(get<0>(test_tup2)));
//begin to write code
",521,"#include<iostream>
    

#include <tuple>
#include <cassert>

using namespace std;

tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> add_nested_tuples(
    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> test_tup1,
    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> test_tup2) 
{
    tuple<int, int> res1 = make_tuple(get<0>(get<0>(test_tup1)) + get<0>(get<0>(test_tup2)), get<1>(get<0>(test_tup1)) + get<1>(get<0>(test_tup2)));
    tuple<int, int> res2 = make_tuple(get<0>(get<1>(test_tup1)) + get<0>(get<1>(test_tup2)), get<1>(get<1>(test_tup1)) + get<1>(get<1>(test_tup2)));
    tuple<int, int> res3 = make_tuple(get<0>(get<2>(test_tup1)) + get<0>(get<2>(test_tup2)), get<1>(get<2>(test_tup1)) + get<1>(get<2>(test_tup2)));
    tuple<int, int> res4 = make_tuple(get<0>(get<3>(test_tup1)) + get<0>(get<3>(test_tup2)), get<1>(get<3>(test_tup1)) + get<1>(get<3>(test_tup2)));

    return make_tuple(res1, res2, res3, res4);
}


","
#include<iostream>
#include <tuple>
#include <cassert>
using namespace std;

tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> add_nested_tuples(
    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> test_tup1,
    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> test_tup2) 
{
    tuple<int, int> res1 = make_tuple(get<0>(get<0>(test_tup1)) + get<0>(get<0>(test_tup2)), get<1>(get<0>(test_tup1)) + get<1>(get<0>(test_tup2)));
    return res1;
}

",,,,-2,1,0.23472406466801962,code_expression_exchange:None,0.0,0.0,
391,"#include<iostream>
#include <vector>
#include <cassert>
int ncr_modp(int n, int r, int p) {
    std::vector<int> C(r + 1, 0);
    C[0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = std::min(i, r); j > 0; --j) {
//begin to write code
",248,"#include<iostream>
    

#include <vector>
#include <cassert>

int ncr_modp(int n, int r, int p) {
    std::vector<int> C(r + 1, 0);
    C[0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = std::min(i, r); j > 0; --j) {
            C[j] = (C[j] + C[j - 1]) % p;
        }
    }
    return C[r];
}


","
#include<iostream>
#include <vector>
#include <cassert>

int ncr_modp(int n, int r, int p) {
    std::vector<int> C(r + 1, 0);
    C[0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = std::min(i, r); j > 0; --j) {
            C[j] = (C[j] * (i - j)) % p;
        }
    }
    return C[r];
}

",,,,-2,1,0.23762699762980144,code_expression_exchange:None,0.0,0.0,
392,"#include<iostream>
#include <regex>
#include <cassert>
#include <string>
using namespace std;
bool is_valid_URL(string url) {
    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\+~#?&//=]{2,256}\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\+~#?&//=]*)"");
    if (url.empty()) {
//begin to write code
",294,"#include<iostream>
    
#include <regex>
#include <cassert>
#include <string>

using namespace std;

bool is_valid_URL(string url) {
    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\+~#?&//=]{2,256}\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\+~#?&//=]*)"");

    if (url.empty()) {
        return false;
    }

    return regex_search(url, pattern);
}","
#include<iostream>
#include <regex>
#include <cassert>
#include <string>
using namespace std;

bool is_valid_URL(string url) {
    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\+~#?&//=]{2,256}\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\+~#?&//=]*)"");
    return regex_match(url, pattern);
}

","#include<iostream>
#include <regex>
#include <cassert>
#include <string>
using namespace std;
bool is_valid_URL(string url) {
    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\+~#?&//=]{2,256}\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\+~#?&//=]*)"");
    if (url.empty()) {
//begin to write code
","#include<iostream>
    
#include <regex>
#include <cassert>
#include <string>

using namespace std;

bool is_valid_URL(string url) {
    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\+~#?&//=]{2,256}\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\+~#?&//=]*)"");

    if (url.empty()) {
        return 0;
    }

    return regex_search(url, pattern);
}","
#include<iostream>
#include <regex>
#include <cassert>
#include <string>
using namespace std;

bool is_valid_URL(string url) {
    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\+~#?&//=]{2,256}\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\+~#?&//=]*)"");
    return regex_match(url, pattern);
}

",-1,21,3.62211754322052,code_expression_exchange:bool2int,1.0,0.6960985897129364,"{'#include<iostream>\n    \n#include <regex>\n#include <cassert>\n#include <string>\n\nusing namespace std;\n\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n\n    if (url.empty()) {\n        return 0;\n    }\n\n    return regex_search(url, pattern);\n}': [('#include<iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    if (url.empty()) {\n//begin to write code\n', '\n#include<iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\n\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    return regex_match(url, pattern);\n}\n\n', 'equal_expression_transformation'), ('#include<iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    if (url.empty()) {\n//begin to write code\n', '\n#include<iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\n\nbool is_valid_URL(string url) {\n    // Regular expression to match a URL\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    return regex_match(url, pattern);\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    if (url.empty()) {\n//begin to write code\n', '\n#include<iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\n\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    return regex_match(url, pattern);\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    if (url.empty()) {\n//begin to write code\n', '\n#include<iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\n\nbool is_valid_URL(string url) {\n    // Use regex to match the URL pattern\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    return regex_match(url, pattern);\n}\n\n', 'more_universe_var_type'), ('#include<iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    if (url.empty()) {\n//begin to write code\n', '\n#include <iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\n\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    return regex_match(url, pattern);\n}\n\n', 'equal_expression_transformation'), ('#include<iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    if (url.empty()) {\n//begin to write code\n', '\n#include <iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\n\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    return regex_match(url, pattern);\n}\n\n', 'bool2int'), ('#include<iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    if (url.empty()) {\n//begin to write code\n', '\n#include <iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\n\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    return regex_match(url, pattern);\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    if (url.empty()) {\n//begin to write code\n', '\n#include<iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    return regex_match(url, pattern);\n}\n\n', 'bool2int'), ('#include<iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    if (url.empty()) {\n//begin to write code\n', '\n#include <iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\n\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    return regex_match(url, pattern);\n}\n\n', 'equal_expression_transformation'), ('#include<iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    if (url.empty()) {\n//begin to write code\n', '\n#include<iostream>\n#include <regex>\n#include <cassert>\n#include <string>\nusing namespace std;\n\nbool is_valid_URL(string url) {\n    regex pattern(""((http|https)://)(www.)?[a-zA-Z0-9@:%._\\\\+~#?&//=]{2,256}\\\\.[a-z]{2,6}([-a-zA-Z0-9@:%._\\\\+~#?&//=]*)"");\n    return regex_match(url, pattern);\n}\n\n', 'bool2int')]}"
393,"#include<iostream>
#include<cassert>
#include <assert.h>
//
int minimum(int a, int b) {
    if (a <= b) {
        return a;
//begin to write code
",150,"#include<iostream>
    
#include<cassert>
#include <assert.h>

//
int minimum(int a, int b) {
    if (a <= b) {
        return a;
    } else {
        return b;
    }
}


","
#include<iostream>
#include<cassert>
#include <cassert>

//
int minimum(int a, int b) {
    if (a <= b) {
        return a;
    } else {
        return b;
    }
}

","#include<iostream>
#include<cassert>
#include <assert.h>
//
int minimum(long a, int b) {
    if (a <= b) {
        return a;
//begin to write code
","#include<iostream>
    
#include<cassert>
#include <assert.h>

//
int minimum(long a, int b) {
    if (a <= b) {
        return a;
    } else {
        return b;
    }
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include",1,5,0.6797560811042785,code_expression_exchange:bool2int,1.0,0.0,"{'#include<iostream>\n    \n#include<cassert>\n#include <assert.h>\n\n//\nint minimum(long a, int b) {\n    if (a <= b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n\n': [('#include<iostream>\n#include<cassert>\n#include <assert.h>\n//\nint minimum(long a, int b) {\n    if (a <= b) {\n        return a;\n//begin to write code\n', '\n#include<iostream>\n#include<cassert>\n#include <cassert>\n\nint minimum(long a, int b) {\n    if (a <= b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n', 'more_universe_var_type'), ('#include<iostream>\n#include<cassert>\n#include <assert.h>\n//\nint minimum(long a, int b) {\n    if (a <= b) {\n        return a;\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include', 'bool2int')]}"
394,"#include <iostream>
#include <tuple>
#include <type_traits>
#include <cstddef>
#include <cassert>
using namespace std;
using MyTuple = tuple<char, int, char, char, char, char, char, char, char, char>;
template<typename T, size_t I = 0>
bool check_tuplex(const MyTuple& t, const T& value) {
    if constexpr (I == tuple_size<MyTuple>::value) {
        return false;
//begin to write code
",387,"#include <iostream>
#include <tuple>
#include <type_traits>
#include <cstddef>
#include <cassert>

using namespace std;

using MyTuple = tuple<char, int, char, char, char, char, char, char, char, char>;

template<typename T, size_t I = 0>
bool check_tuplex(const MyTuple& t, const T& value) {
    if constexpr (I == tuple_size<MyTuple>::value) {
        return false;
    } else {
        return get<I>(t) == value || check_tuplex<T, I + 1>(t, value);
    }
}","
#include <iostream>
#include <tuple>
#include <type_traits>
#include <cstddef>
#include <cassert>

using namespace std;
using MyTuple = tuple<char, int, char, char, char, char, char, char, char, char>;

template<typename T, size_t I = 0>
bool check_tuplex(const MyTuple& t, const T& value) {
    if constexpr (I == tuple_size<MyTuple>::value) {
        return false;
    } else if (t[I] == value) {
        return true;
    } else {
        return check_tuplex(t, value, I + 1);
    }
}

",,,,-2,1,0.234777029355367,code_expression_exchange:None,0.0,0.0,
395,"#include<cassert>
#include <iostream>
#include <string>
std::string find_Parity(unsigned int x) {
    unsigned int y = x ^ (x >> 1);
    y = y ^ (y >> 2);
    y = y ^ (y >> 4);
    y = y ^ (y >> 8);
//begin to write code
",221,"#include<cassert>
#include <iostream>
#include <string>

std::string find_Parity(unsigned int x) {
    unsigned int y = x ^ (x >> 1);
    y = y ^ (y >> 2);
    y = y ^ (y >> 4);
    y = y ^ (y >> 8);
    y = y ^ (y >> 16);
    if (y & 1) {
        return ""Odd Parity"";
    }
    return ""Even Parity"";
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

std::string find_Parity(unsigned int x) {
    unsigned int y = x ^ (x >> 1);
    y = y ^ (y >> 2);
    y = y ^ (y >> 4);
    y = y ^ (y >> 8);
    return y & 1? ""Even"" : ""Odd"";
}

",,,,-2,1,0.2339175224304199,code_expression_exchange:None,0.0,0.0,
396,"#include<iostream>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;
int rearrange_bigger(int n) {
    string nums = to_string(n);
    for (int i = nums.size() - 2; i >= 0; --i) {
        if (nums[i] < nums[i+1]) {
            string z = nums.substr(i);
            char y = *min_element(z.begin() + 1, z.end(), [first = z[0]](char a, char b) { return a > first && (b > first ? a < b : true); });
            z.erase(remove(z.begin(), z.end(), y), z.end());
//begin to write code
",509,"#include<iostream>
    

#include <string>
#include <algorithm>
#include <cassert>

using namespace std;

int rearrange_bigger(int n) {
    string nums = to_string(n);
    for (int i = nums.size() - 2; i >= 0; --i) {
        if (nums[i] < nums[i+1]) {
            string z = nums.substr(i);
            char y = *min_element(z.begin() + 1, z.end(), [first = z[0]](char a, char b) { return a > first && (b > first ? a < b : true); });
            z.erase(remove(z.begin(), z.end(), y), z.end());
            sort(z.begin(), z.end());
            nums = nums.substr(0, i) + y + z;
            return stoi(nums);
        }
    }
    return false;
}


","
#include<iostream>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;

int rearrange_bigger(int n) {
    string nums = to_string(n);
    for (int i = nums.size() - 2; i >= 0; --i) {
        if (nums[i] < nums[i+1]) {
            string z = nums.substr(i);
            char y = *min_element(z.begin() + 1, z.end(), [first = z[0]](char a, char b) { return a > first && (b > first? a < b : true); });
            z.erase(remove(z.begin(), z.end(), y), z.end());
            swap(nums[i], nums[z.size() - 1]);
            sort(nums.begin() + i + 1, nums.end());
            return stoi(nums);
        }
    }
    return n; // If no bigger number is found, return the original number
}

",,,,-2,1,0.24321367343266806,code_expression_exchange:None,0.0,0.0,
397,"#include <vector>
#include <queue>
#include <cassert>
#include <iostream>
using namespace std;
vector<vector<int>> k_smallest_pairs(vector<int>& nums1, vector<int>& nums2, int k) {
    auto comp = [&](const pair<int, int>& a, const pair<int, int>& b) {
        if(nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second])
        {
            return true;
        }
        else if(nums1[a.first] + nums2[a.second] == nums1[b.first] + nums2[b.second])
        {
            return nums1[a.first] > nums1[b.first];
        }
        else
        {
            return false;
        }
    };
//begin to write code
",624,"#include <vector>
#include <queue>
#include <cassert>
#include <iostream>

using namespace std;

vector<vector<int>> k_smallest_pairs(vector<int>& nums1, vector<int>& nums2, int k) {
    auto comp = [&](const pair<int, int>& a, const pair<int, int>& b) {
        if(nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second])
        {
            return true;
        }
        else if(nums1[a.first] + nums2[a.second] == nums1[b.first] + nums2[b.second])
        {
            return nums1[a.first] > nums1[b.first];
        }
        else
        {
            return false;
        }
    };
    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> pq(comp);
    vector<vector<int>> pairs;

    if (nums1.empty() || nums2.empty() || k <= 0) return pairs;
    
    for (int i = 0; i < min((int)nums1.size(), k); ++i) {
        pq.push({i, 0});
    }

    while (k-- > 0 && !pq.empty()) {
        auto cur = pq.top();
        pq.pop();
        pairs.push_back({nums1[cur.first], nums2[cur.second]});
        if (cur.second + 1 < nums2.size()) {
            pq.push({cur.first, cur.second + 1});
        }
    }
    return pairs;
}","
#include <vector>
#include <queue>
#include <cassert>
#include <iostream>
using namespace std;

vector<vector<int>> k_smallest_pairs(vector<int>& nums1, vector<int>& nums2, int k) {
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    
    // Add all elements from nums1 to the priority queue
    for (int num : nums1) {
        pq.push({num, 0});
    }
    
    // Add all elements from nums2 to the priority queue
    for (int num : nums2) {
        pq.push({num, 1});
    }
    
    vector<vector<int>> result;
    while (!pq.empty() && result.size() < k) {
        auto [num1, index1] = pq.top();
        pq.pop();
        
        // Check if the current pair is valid
        if (index1 == 0 || (index1 == 1 && num1 <= num2)) {
            result.push_back({num1, num2});
        }
        
        // If there are no more elements left in nums1, add the remaining elements from nums2 to the priority queue
       ",,,,-2,1,0.231825053691864,code_expression_exchange:None,0.0,0.0,
398,"#include<cassert>
#include <iostream>
#include <vector>
#include <limits>
#include <cstdlib> // for abs()
int min_product_tuple(const std::vector<std::pair<int, int>>& list1) {
    int result_min = std::numeric_limits<int>::max();
    for (const auto& p : list1) {
        int product = std::abs(p.first * p.second);
        if (product < result_min) {
//begin to write code
",375,"#include<cassert>
#include <iostream>
#include <vector>
#include <limits>
#include <cstdlib> // for abs()

int min_product_tuple(const std::vector<std::pair<int, int>>& list1) {
    int result_min = std::numeric_limits<int>::max();
    for (const auto& p : list1) {
        int product = std::abs(p.first * p.second);
        if (product < result_min) {
            result_min = product;
        }
    }
    return result_min;
}


","using namespace std;
#include<stdlib.h> // for abs()
#include<algorithm> // for sort()
#include<stdio.h> // for printf()
#include<vector>
#include<string>
#include<iostream>

#include<cassert>
#include <iostream>
#include <vector>
#include <limits>
#include <cstdlib> // for abs()

int min_product_tuple(const std::vector<std::pair<int, int>>& list1) {
    int result_min = std::numeric_limits<int>::max();
    for (const auto& p : list1) {
        int product = std::abs(p.first * p.second);
        if (product < result_min) {
            result_min = product;
        }
    }
    return result_min;
}
","#include<cassert>
#include <iostream>
#include <vector>
#include <limits>
#include <cstdlib> // for abs()
long min_product_tuple(const std::vector<std::pair<int, int>>& list1) {
    int result_min = std::numeric_limits<long>::max();
    for (const auto& p : list1) {
        int product = std::abs(p.first * p.second);
        if (product < result_min) {
//begin to write code
","#include<cassert>
#include <iostream>
#include <vector>
#include <limits>
#include <cstdlib> // for abs()

long min_product_tuple(const std::vector<std::pair<int, int>>& list1) {
    int result_min = std::numeric_limits<long>::max();
    for (const auto& p : list1) {
        int product = std::abs(p.first * p.second);
        if (product < result_min) {
            result_min = product;
        }
    }
    return result_min;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<cassert>

long min_product_tuple(const std::vector<std::pair<int, int>>& list1) {
    int result_min = std::numeric_limits<long>::max();
    for (const auto& p : list1) {
        int product = std::abs(p.first * p.second);
        if (product < result_min) {
            result_min = product;
        }
    }
    return result_min;
}

",1,11,1.4510928829511007,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<cassert>\n#include <iostream>\n#include <vector>\n#include <limits>\n#include <cstdlib> // for abs()\n\nlong min_product_tuple(const std::vector<std::pair<int, int>>& list1) {\n    int result_min = std::numeric_limits<long>::max();\n    for (const auto& p : list1) {\n        int product = std::abs(p.first * p.second);\n        if (product < result_min) {\n            result_min = product;\n        }\n    }\n    return result_min;\n}\n\n\n': [('#include<cassert>\n#include <iostream>\n#include <vector>\n#include <limits>\n#include <cstdlib> // for abs()\nint min_product_tuple(const std::vector<std::pair<int, int>>& list1) {\n    int result_min = std::numeric_limits<int>::max();\n    for (const auto& p : list1) {\n        int product = std::abs(p.first * p.second);\n        if (product < result_min) {\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<cassert>\n\nint min_product_tuple(const std::vector<std::pair<int, int>>& list1) {\n    int result_min = std::numeric_limits<int>::max();\n    for (const auto& p : list1) {\n        int product = std::abs(p.first * p.second);\n        if (product < result_min) {\n            result_min = product;\n        }\n    }\n    return result_min;\n}\n\n', 'equal_expression_transformation'), ('#include<cassert>\n#include <iostream>\n#include <vector>\n#include <limits>\n#include <cstdlib> // for abs()\nint min_product_tuple(const std::vector<std::pair<int, int>>& list1) {\n    int result_min = std::numeric_limits<int>::max();\n    for (const auto& p : list1) {\n        int product = std::abs(p.first * p.second);\n        if (product < result_min) {\n//begin to write code\n', 'using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<cassert>\n\nint min_product_tuple(const std::vector<std::pair<int, int>>& list1) {\n    int result_min = std::numeric_limits<int>::max();\n    for (const auto& p : list1) {\n        int product = std::abs(p.first * p.second);\n        if (product < result_min) {\n            result_min = product;\n        }\n    }\n    return result_min;\n}\n', 'bool2int'), ('#include<cassert>\n#include <iostream>\n#include <vector>\n#include <limits>\n#include <cstdlib> // for abs()\nint min_product_tuple(const std::vector<std::pair<int, int>>& list1) {\n    int result_min = std::numeric_limits<int>::max();\n    for (const auto& p : list1) {\n        int product = std::abs(p.first * p.second);\n        if (product < result_min) {\n//begin to write code\n', '\n#include <cassert>\n#include <iostream>\n#include <vector>\n#include <limits>\n#include <cstdlib> // for abs()\nint min_product_tuple(const std::vector<std::pair<int, int>>& list1) {\n    int result_min = std::numeric_limits<int>::max();\n    for (const auto& p : list1) {\n        int product = std::abs(p.first * p.second);\n        if (product < result_min) {\n            result_min = product;\n        }\n    }\n    return result_min;\n}\n\n', 'bool2int'), ('#include<cassert>\n#include <iostream>\n#include <vector>\n#include <limits>\n#include <cstdlib> // for abs()\nlong min_product_tuple(const std::vector<std::pair<int, int>>& list1) {\n    int result_min = std::numeric_limits<int>::max();\n    for (const auto& p : list1) {\n        int product = std::abs(p.first * p.second);\n        if (product < result_min) {\n//begin to write code\n', '\n#include<cassert>\n#include <iostream>\n#include <vector>\n#include <limits>\n#include <cstdlib> // for abs()\n\nlong min_product_tuple(const std::vector<std::pair<int, int>>& list1) {\n    int result_min = std::numeric_limits<int>::max();\n    for (const auto& p : list1) {\n        int product = std::abs(p.first * p.second);\n        if (product < result_min) {\n            result_min = product;\n        }\n    }\n    return result_min;\n}\n\n', 'more_universe_var_type'), ('#include<cassert>\n#include <iostream>\n#include <vector>\n#include <limits>\n#include <cstdlib> // for abs()\nlong min_product_tuple(const std::vector<std::pair<int, int>>& list1) {\n    int result_min = std::numeric_limits<long>::max();\n    for (const auto& p : list1) {\n        int product = std::abs(p.first * p.second);\n        if (product < result_min) {\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<cassert>\n\nlong min_product_tuple(const std::vector<std::pair<int, int>>& list1) {\n    int result_min = std::numeric_limits<long>::max();\n    for (const auto& p : list1) {\n        int product = std::abs(p.first * p.second);\n        if (product < result_min) {\n            result_min = product;\n        }\n    }\n    return result_min;\n}\n\n', 'more_universe_var_type')]}"
399,"#include <iostream>
#include <vector>
#include <limits>
#include <typeinfo>
#include <cassert>
using namespace std;
int min_val(const vector<int>& listval) {
    int min_val = numeric_limits<int>::max();
    for (int value : listval) {
        if (value < min_val) {
//begin to write code
",289,"
#include <iostream>
#include <vector>
#include <limits>
#include <typeinfo>
#include <cassert>

using namespace std;

int min_val(const vector<int>& listval) {
    int min_val = numeric_limits<int>::max();
    for (int value : listval) {
        if (value < min_val) {
            min_val = value;
        }
    }
    return min_val;
}


","
#include <iostream>
#include <vector>
#include <limits>
#include <typeinfo>
#include <cassert>
using namespace std;

int min_val(const vector<int>& listval) {
    int min_val = numeric_limits<int>::max();
    for (int value : listval) {
        if (value < min_val) {
            min_val = value;
        }
    }
    return min_val;
}

","#include <iostream>
#include <vector>
#include <limits>
#include <typeinfo>
#include <cassert>
using namespace std;
int min_val(const vector<int>& listval) {
    int min_val = numeric_limits<long>::max();
    for (int value : listval) {
        if (value < min_val) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <limits>
#include <typeinfo>
#include <cassert>

using namespace std;

int min_val(const vector<int>& listval) {
    int min_val = numeric_limits<long>::max();
    for (int value : listval) {
        if (value < min_val) {
            min_val = value;
        }
    }
    return min_val;
}


","
#include <iostream>
#include <vector>
#include <limits>
#include <typeinfo>
#include <cassert>
using namespace std;

int min_val(const vector<int>& listval) {
    int min_val = numeric_limits<long>::max();
    for (int value : listval) {
        if (value < min_val) {
            min_val = value;
        }
    }
    return min_val;
}

",1,3,0.45332401196161903,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <limits>\n#include <typeinfo>\n#include <cassert>\n\nusing namespace std;\n\nint min_val(const vector<int>& listval) {\n    int min_val = numeric_limits<long>::max();\n    for (int value : listval) {\n        if (value < min_val) {\n            min_val = value;\n        }\n    }\n    return min_val;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <limits>\n#include <typeinfo>\n#include <cassert>\nusing namespace std;\nint min_val(const vector<int>& listval) {\n    int min_val = numeric_limits<long>::max();\n    for (int value : listval) {\n        if (value < min_val) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <limits>\n#include <typeinfo>\n#include <cassert>\nusing namespace std;\n\nint min_val(const vector<int>& listval) {\n    int min_val = numeric_limits<long>::max();\n    for (int value : listval) {\n        if (value < min_val) {\n            min_val = value;\n        }\n    }\n    return min_val;\n}\n\n', 'more_universe_var_type')]}"
400,"#include <iostream>
#include <sstream>
#include <cctype>
#include <cassert>
std::string snake_to_camel(const std::string& word) {
    std::istringstream stream(word);
    std::string part;
    std::string result;
    while (std::getline(stream, part, '_')) {
        if (!part.empty()) {
//begin to write code
",310,"
#include <iostream>
#include <sstream>
#include <cctype>
#include <cassert>

std::string snake_to_camel(const std::string& word) {
    std::istringstream stream(word);
    std::string part;
    std::string result;

    while (std::getline(stream, part, '_')) {
        if (!part.empty()) {
            part[0] = std::toupper(part[0]);
            result += part;
        }
    }

    return result;
}


","
using namespace std;
#include <iostream>
#include <sstream>
#include <cctype>
#include <cassert>

std::string snake_to_camel(const std::string& word) {
    std::istringstream stream(word);
    std::string part;
    std::string result;
    while (std::getline(stream, part, '_')) {
        if (!part.empty()) {
            // Convert the first letter to uppercase and the rest to lowercase
            result += toupper(part[0]);
            for (size_t i = 1; i < part.length(); ++i) {
                result += tolower(part[i]);
            }
        }
    }
    return result;
}

","#include <iostream>
#include <sstream>
#include <cctype>
#include <cassert>
std::string snake_to_camel(const std::string& word) {
    std::istringstream stream(word);
    std::string part;
    std::string result;
    while (std::getline(stream, part, '_')) {
        if (!part.empty()) {
//begin to write code
","
#include <iostream>
#include <sstream>
#include <cctype>
#include <cassert>

std::string snake_to_camel(const std::string& word) {
    std::istringstream stream(word);
    std::string part;
    std::string result;

    while (std::getline(stream, part, '_')) {
        if (!part.empty()) {
            part[0] = std::toupper(part[0]);
            result = result + (part);
        }
    }

    return result;
}


","
#include <iostream>
#include <sstream>
#include <cctype>
#include <cassert>
std::string snake_to_camel(const std::string& word) {
    std::istringstream stream(word);
    std::string part;
    std::string result;
    while (std::getline(stream, part, '_')) {
        if (!part.empty()) {
            // Convert the first character to lowercase and capitalize the rest
            result += std::tolower(part[0]);
            for (size_t i = 1; i < part.length(); ++i) {
                result += std::toupper(part[i]);
            }
        }
    }
    return result;
}

",1,3,0.5162746429443359,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{""\n#include <iostream>\n#include <sstream>\n#include <cctype>\n#include <cassert>\n\nstd::string snake_to_camel(const std::string& word) {\n    std::istringstream stream(word);\n    std::string part;\n    std::string result;\n\n    while (std::getline(stream, part, '_')) {\n        if (!part.empty()) {\n            part[0] = std::toupper(part[0]);\n            result = result + (part);\n        }\n    }\n\n    return result;\n}\n\n\n"": [(""#include <iostream>\n#include <sstream>\n#include <cctype>\n#include <cassert>\nstd::string snake_to_camel(const std::string& word) {\n    std::istringstream stream(word);\n    std::string part;\n    std::string result;\n    while (std::getline(stream, part, '_')) {\n        if (!part.empty()) {\n//begin to write code\n"", ""\n#include <iostream>\n#include <sstream>\n#include <cctype>\n#include <cassert>\nstd::string snake_to_camel(const std::string& word) {\n    std::istringstream stream(word);\n    std::string part;\n    std::string result;\n    while (std::getline(stream, part, '_')) {\n        if (!part.empty()) {\n            // Convert the first character to lowercase and capitalize the rest\n            result += std::tolower(part[0]);\n            for (size_t i = 1; i < part.length(); ++i) {\n                result += std::toupper(part[i]);\n            }\n        }\n    }\n    return result;\n}\n\n"", 'equal_expression_transformation')]}"
401,"#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> remove_odd(std::vector<int> l) {
    auto it = l.begin();
    while (it != l.end()) {
        if (*it % 2 != 0) {
            it = l.erase(it);
//begin to write code
",240,"
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> remove_odd(std::vector<int> l) {
    auto it = l.begin();
    while (it != l.end()) {
        if (*it % 2 != 0) {
            it = l.erase(it);
        } else {
            ++it;
        }
    }
    return l;
}


","
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> remove_odd(std::vector<int> l) {
    std::vector<int> result;
    for (int num : l) {
        if (num % 2 == 0) {
            result.push_back(num);
        }
    }
    return result;
}

","#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> remove_odd(std::vector<int> l) {
    auto it = l.begin();
    while (it != l.end()) {
        if (*it % 2 != 0) {
            it = l.erase(it);
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> remove_odd(std::vector<int> l) {
    auto it = l.begin();
    while (it != l.end()) {
        if (*it % 2 != 0) {
            it = l.erase(it);
        } else {
            ++it;
        }
    }
    return l;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> remove_odd(std::vector<int> l) {
    auto it = l.begin();
    while (it!= l.end()) {
        if (*it % 2!= 0) {
            it = l.erase(it);
        }
    }
    return l;
}

",1,3,1.4746490557988485,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> remove_odd(std::vector<int> l) {\n    auto it = l.begin();\n    while (it != l.end()) {\n        if (*it % 2 != 0) {\n            it = l.erase(it);\n        } else {\n            ++it;\n        }\n    }\n    return l;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> remove_odd(std::vector<int> l) {\n    auto it = l.begin();\n    while (it != l.end()) {\n        if (*it % 2 != 0) {\n            it = l.erase(it);\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> remove_odd(std::vector<int> l) {\n    auto it = l.begin();\n    while (it!= l.end()) {\n        if (*it % 2!= 0) {\n            it = l.erase(it);\n        }\n    }\n    return l;\n}\n\n', 'bool2int')]}"
402,"#include<iostream>
#include <vector>
#include <tuple>
#include <cassert>
#include <string>
using namespace std;
template<typename T, size_t N>
struct TupleElement {
    using type = typename tuple_element<N, tuple<T, int, int>>::type;
};
template<typename T, size_t N>
vector<typename TupleElement<T, N>::type> extract_nth_element(const vector<tuple<T, int, int>>& list1) {
//begin to write code
",396,"#include<iostream>
    
#include <vector>
#include <tuple>
#include <cassert>
#include <string>

using namespace std;

template<typename T, size_t N>
struct TupleElement {
    using type = typename tuple_element<N, tuple<T, int, int>>::type;
};

template<typename T, size_t N>
vector<typename TupleElement<T, N>::type> extract_nth_element(const vector<tuple<T, int, int>>& list1) {
    vector<typename TupleElement<T, N>::type> result;
    for (const auto& item : list1) {
        result.push_back(get<N>(item));
    }
    return result;
}","
#include<iostream>
#include <vector>
#include <tuple>
#include <cassert>
#include <string>
using namespace std;

template<typename T, size_t N>
struct TupleElement {
    using type = typename tuple_element<N, tuple<T, int, int>>::type;
};

template<typename T, size_t N>
vector<typename TupleElement<T, N>::type> extract_nth_element(const vector<tuple<T, int, int>>& list1) {
    vector<typename TupleElement<T, N>::type> result;
    for (size_t i = 0; i < list1.size(); ++i) {
        if (i == N) {
            result.push_back(tuple_element<N, tuple<T, int, int>>::type(list1[i]));
        }
    }
    return result;
}

",,,,-2,1,0.23932801882425944,code_expression_exchange:None,0.0,0.0,
403,"#include <iostream>
#include <vector>
#include <cassert>
bool overlapping(const std::vector<int>& list1, const std::vector<int>& list2) {
    int c = list1.size();
    int d = list2.size();
    for (int i = 0; i < c; i++) {
        for (int j = 0; j < d; j++) {
            if (list1[i] == list2[j]) {
//begin to write code
",324,"
#include <iostream>
#include <vector>
#include <cassert>

bool overlapping(const std::vector<int>& list1, const std::vector<int>& list2) {
    int c = list1.size();
    int d = list2.size();
    for (int i = 0; i < c; i++) {
        for (int j = 0; j < d; j++) {
            if (list1[i] == list2[j]) {
                return true;
            }
        }
    }
    return false;
}


","
#include <iostream>
#include <vector>
#include <cassert>

bool overlapping(const std::vector<int>& list1, const std::vector<int>& list2) {
    int c = list1.size();
    int d = list2.size();
    for (int i = 0; i < c; i++) {
        for (int j = 0; j < d; j++) {
            if (list1[i] == list2[j]) {
                return true;
            }
        }
    }
    return false;
}

","#include <iostream>
#include <vector>
#include <cassert>
bool overlapping(const std::vector<int>& list1, const std::vector<int>& list2) {
    int c = list1.size();
    int d = list2.size();
    for (int i = 0; i < c; i++) {
        for (int j = 0; j < d; j++) {
            if (list1[i] == list2[j]) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

bool overlapping(const std::vector<int>& list1, const std::vector<int>& list2) {
    int c = list1.size();
    int d = list2.size();
    for (int i = 0; i < c; i++) {
        for (int j = 0; j < d; j++) {
            if (list1[i] == list2[j]) {
                return 1;
            }
        }
    }
    return 0;
}


","


",1,3,0.4440572261810303,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool overlapping(const std::vector<int>& list1, const std::vector<int>& list2) {\n    int c = list1.size();\n    int d = list2.size();\n    for (int i = 0; i < c; i++) {\n        for (int j = 0; j < d; j++) {\n            if (list1[i] == list2[j]) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nbool overlapping(const std::vector<int>& list1, const std::vector<int>& list2) {\n    int c = list1.size();\n    int d = list2.size();\n    for (int i = 0; i < c; i++) {\n        for (int j = 0; j < d; j++) {\n            if (list1[i] == list2[j]) {\n//begin to write code\n', '\n\n\n', 'bool2int')]}"
404,"#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
pair<int, int> max_Product(const vector<int>& arr) {
    int arr_len = arr.size();
    if (arr_len < 2) {
        throw ""No pairs exists"";
    }
    int x = arr[0];
    int y = arr[1];
    for (int i = 0; i < arr_len; i++) {
//begin to write code
",325,"
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

pair<int, int> max_Product(const vector<int>& arr) {
    int arr_len = arr.size();
    if (arr_len < 2) {
        throw ""No pairs exists"";
    }
    int x = arr[0];
    int y = arr[1];
    for (int i = 0; i < arr_len; i++) {
        for (int j = i + 1; j < arr_len; j++) {
            if (arr[i] * arr[j] > x * y) {
                x = arr[i];
                y = arr[j];
            }
        }
    }
    return make_pair(x, y);
}


","
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

pair<int, int> max_Product(const vector<int>& arr) {
    int arr_len = arr.size();
    if (arr_len < 2) {
        throw ""No pairs exists"";
    }
    int x = arr[0];
    int y = arr[1];
    for (int i = 0; i < arr_len; i++) {
        // Your code here
    }
    return {x, y};
}

",,,,-2,1,0.2152196725209554,code_expression_exchange:None,0.0,0.0,
405,"#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
int breakSum(int n) {
    vector<int> dp(n + 1, 0);
    dp[0] = 0;
    dp[1] = 1;
//begin to write code
",182,"
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

int breakSum(int n) {
    vector<int> dp(n + 1, 0);
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; ++i) {
        dp[i] = max(dp[i / 2] + dp[i / 3] + dp[i / 4], i);
    }
    return dp[n];
}


","using namespace std;
#include <vector>
#include <cassert>

int breakSum(int n) {
    vector<int> dp(n + 1, 0);
    dp[0] = 0;
    dp[1] = 1;

    // Helper function to find the maximum sum
    int maxSum(vector<int>& arr, int i, int j) {
        if (i == j) return arr[i];
        int leftMax = maxSum(arr, i, j - 1);
        int rightMax = maxSum(arr, i + 1, j);
        return max(leftMax, rightMax) + arr[i];
    }

    // Recursive function to find the maximum sum
    int breakSumRecursive(int n) {
        if (n <= 2) return n;
        return max(maxSumRecursive(n / 3), maxSumRecursive(n / 2));
    }

    // Main function to find the maximum sum
    int breakSumMain(int n) {
        return breakSumRecursive(n);
    }

    return breakSumMain(n);
}
",,,,-2,1,0.22666088342666627,code_expression_exchange:None,0.0,0.0,
406,"#include <vector>
#include <tuple>
#include <map>
#include <cassert>
#include <iostream>
using namespace std;
vector<tuple<char, string>> group_tuples(vector<tuple<char, char>> input) {
    map<char, vector<char>> out;
    for (auto& elem : input) {
        char key = get<0>(elem);
        char value = get<1>(elem);
        out[key].push_back(value);
    }
//begin to write code
",381,"#include <vector>
#include <tuple>
#include <map>
#include <cassert>
#include <iostream>
using namespace std;

vector<tuple<char, string>> group_tuples(vector<tuple<char, char>> input) {
    map<char, vector<char>> out;
    for (auto& elem : input) {
        char key = get<0>(elem);
        char value = get<1>(elem);
        out[key].push_back(value);
    }
    
    vector<tuple<char, string>> result;
    for (auto& pair : out) {
        string values(pair.second.begin(), pair.second.end());
        result.emplace_back(make_tuple(pair.first, values));
    }
    
    return result;
}","
#include <vector>
#include <tuple>
#include <map>
#include <cassert>
#include <iostream>
using namespace std;

vector<tuple<char, string>> group_tuples(vector<tuple<char, char>> input) {
    map<char, vector<char>> out;
    for (auto& elem : input) {
        char key = get<0>(elem);
        char value = get<1>(elem);
        out[key].push_back(value);
    }
    return out;
}

",,,,-2,1,0.23807142972946166,code_expression_exchange:None,0.0,0.0,
407,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
template<typename T>
std::vector<T> Find_Max(std::vector<std::vector<T>> lst) {
    return *std::max_element(lst.begin(), lst.end(), [](const std::vector<T>& a, const std::vector<T>& b){
//begin to write code
",286,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>

template<typename T>
std::vector<T> Find_Max(std::vector<std::vector<T>> lst) {
    return *std::max_element(lst.begin(), lst.end(), [](const std::vector<T>& a, const std::vector<T>& b){
        return a.size() < b.size();
    });
}


","#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
#include <limits>

template<typename T>
std::vector<T> Find_Max(std::vector<std::vector<T>> lst) {
    if (lst.empty()) {
        return {};
    }

    std::vector<T> max_length_sublist;
    T current_max = lst[0][0];

    for (const auto& row : lst) {
        for (const auto& element : row) {
            if (element > current_max) {
                current_max = element;
            }
        }

        if (current_max > max_length_sublist.back()) {
            max_length_sublist.clear();
            max_length_sublist.push_back(current_max);
        } else if (current_max == max_length_sublist.back()) {
            max_length_sublist.push_back(current_max);
        }
    }

    return max_length_sublist;
}
",,,,-2,1,0.22039865255355834,code_expression_exchange:None,0.0,0.0,
408,"#include<cassert>
#include <iostream>
#include <vector>
#include <cmath>
#include <numeric>
int round_and_sum(const std::vector<double>& list1) {
    int length = list1.size();
    int rounded_sum = std::accumulate(list1.begin(), list1.end(), 0, [](int acc, double val) {
//begin to write code
",294,"#include<cassert>
#include <iostream>
#include <vector>
#include <cmath>
#include <numeric>

int round_and_sum(const std::vector<double>& list1) {
    int length = list1.size();
    int rounded_sum = std::accumulate(list1.begin(), list1.end(), 0, [](int acc, double val) {
        return acc + std::round(val);
    }) * length;
    return rounded_sum;
}


","
#include<cassert>
#include <iostream>
#include <vector>
#include <cmath>
#include <numeric>
#include <algorithm>

int round_and_sum(const std::vector<double>& list1) {
    int length = list1.size();
    int rounded_sum = std::accumulate(list1.begin(), list1.end(), 0, [](int acc, double val) {
        // Round the number to the nearest integer
        double rounded = static_cast<int>(val + 0.5);
        // Multiply the rounded value by the length of the list
        return rounded * length;
    });
    return rounded_sum;
}

",,,,-2,1,0.20893826484680175,code_expression_exchange:None,0.0,0.0,
409,"#include<cassert>
#include<iostream>
//
int cube_Sum(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
//begin to write code
",140,"#include<cassert>
#include<iostream>

//
int cube_Sum(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += (2*i)*(2*i)*(2*i);
    }
    return sum;
}


","
#include<cassert>
#include<iostream>
using namespace std;

//
int cube_Sum(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i += 2) { // Start from 1 and increment by 2 to get even numbers
        sum += i * i * i;
    }
    return sum;
}

",,,,-2,1,0.20476170778274536,code_expression_exchange:None,0.0,0.0,
410,"#include <iostream>
#include <string>
#include <cassert>
#include <sstream>
#include <tuple>
using namespace std;
// Helper function to concatenate elements of the tuple
template<size_t Index, typename... Args>
void concatenate_tuple_helper(ostringstream& oss, const string& delim, const tuple<Args...>& test_tup) {
    if (Index != 0) {
        oss << delim;
    }
    oss << get<Index>(test_tup);
}
// Recursive function to iterate over the tuple
template<size_t Index, typename... Args>
void iterate_tuple(ostringstream& oss, const string& delim, const tuple<Args...>& test_tup) {
    if constexpr (Index == sizeof...(Args)) {
        return;
//begin to write code
",668,"#include <iostream>
#include <string>
#include <cassert>
#include <sstream>
#include <tuple>
using namespace std;

// Helper function to concatenate elements of the tuple
template<size_t Index, typename... Args>
void concatenate_tuple_helper(ostringstream& oss, const string& delim, const tuple<Args...>& test_tup) {
    if (Index != 0) {
        oss << delim;
    }
    oss << get<Index>(test_tup);
}

// Recursive function to iterate over the tuple
template<size_t Index, typename... Args>
void iterate_tuple(ostringstream& oss, const string& delim, const tuple<Args...>& test_tup) {
    if constexpr (Index == sizeof...(Args)) {
        return;
    } else {
        concatenate_tuple_helper<Index>(oss, delim, test_tup);
        iterate_tuple<Index + 1>(oss, delim, test_tup);
    }
}

// Main function to concatenate tuple elements
template<typename... Args>
string concatenate_tuple(const tuple<Args...>& test_tup) {
    ostringstream oss;
    string delim = ""-"";
    iterate_tuple<0>(oss, delim, test_tup);
    return oss.str();
}","
#include <iostream>
#include <string>
#include <cassert>
#include <sstream>
#include <tuple>
using namespace std;

// Helper function to concatenate elements of the tuple
template<size_t Index, typename... Args>
void concatenate_tuple_helper(ostringstream& oss, const string& delim, const tuple<Args...>& test_tup) {
    if (Index!= 0) {
        oss << delim;
    }
    oss << get<Index>(test_tup);
}
// Recursive function to iterate over the tuple
template<size_t Index, typename... Args>
void iterate_tuple(ostringstream& oss, const string& delim, const tuple<Args...>& test_tup) {
    if constexpr (Index == sizeof...(Args)) {
        return;
    } else {
        iterate_tuple(oss, delim, get<Index+1>(test_tup));
    }
}

// Function to concatenate each element of the tuple by the delimiter
string concatenate_tuple(const tuple<>()& test_tup, const string& delim) {
    ostringstream oss;
    concatenate_tuple_helper(oss, delim, test_tup);
    return oss.str();
}

",,,,-2,1,0.27132338285446167,code_expression_exchange:None,0.0,0.0,
411,"#include <iostream>
#include <cmath>
#include <cassert>
double find_Average_Of_Cube(int n) {
    double sum = 0;
    for (int i = 1; i <= n; ++i) {
//begin to write code
",170,"
#include <iostream>
#include <cmath>
#include <cassert>

double find_Average_Of_Cube(int n) {
    double sum = 0;
    for (int i = 1; i <= n; ++i) {
        sum += i * i * i;
    }
    return round(sum / n * 1000000) / 1000000;
}


","
#include <iostream>
#include <cmath>
#include <cassert>

double find_Average_Of_Cube(int n) {
    double sum = 0;
    for (int i = 1; i <= n; ++i) {
        sum += std::pow(i, 3);
    }
    return sum / n;
}

","#include <iostream>
#include <cmath>
#include <cassert>
double find_Average_Of_Cube(long n) {
    double sum = 0;
    for (long i = 1; i <= n; i = 1 + i) {
//begin to write code
","
#include <iostream>
#include <cmath>
#include <cassert>

double find_Average_Of_Cube(long n) {
    double sum = 0;
    for (long i = 1; i <= n; i = 1 + i) {
        sum = sum + (i * i * i);
    }
    return round(1000000 * sum / n) / 1000000;
}


","
#include <iostream>
#include <cmath>
#include <cassert>

using namespace std;

double find_Average_Of_Cube(long n) {
    double sum = 0;
    for (long i = 1; i <= n; i = 1 + i) {
        sum += pow(i, 3);
    }
    return sum / n;
}

",-1,21,2.836151202519735,code_expression_exchange:exchange_operators,1.0,0.7266942289523802,"{'\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble find_Average_Of_Cube(long n) {\n    double sum = 0;\n    for (long i = 1; i <= n; i = 1 + i) {\n        sum = sum + (i * i * i);\n    }\n    return round(1000000 * sum / n) / 1000000;\n}\n\n\n': [('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble find_Average_Of_Cube(int n) {\n    double sum = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble find_Average_Of_Cube(int n) {\n    double sum = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n        sum += std::pow(i, 3);\n    }\n    return sum / n;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble find_Average_Of_Cube(int n) {\n    double sum = 0;\n    for (int i = 1; i <= n; i = 1 + i) {\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble find_Average_Of_Cube(int n) {\n    double sum = 0;\n    for (int i = 1; i <= n; i = 1 + i) {\n        sum += std::pow(i, 3);\n    }\n    return sum / n;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble find_Average_Of_Cube(int n) {\n    double sum = 0;\n    for (int i = 1; i <= n; i = 1 + i) {\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble find_Average_Of_Cube(int n) {\n    double sum = 0;\n    for (int i = 1; i <= n; i = 1 + i) {\n        sum += i * i * i;\n    }\n    return sum / n;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble find_Average_Of_Cube(int n) {\n    double sum = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ndouble find_Average_Of_Cube(int n) {\n    double sum = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n        sum += pow(i, 3);\n    }\n    return sum / n;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble find_Average_Of_Cube(int n) {\n    double sum = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble find_Average_Of_Cube(int n) {\n    if (n <= 0) {\n        throw std::invalid_argument(""Input must be a positive integer."");\n    }\n\n    double sum_of_cubes = 0.0;\n    for (int i = 1; i <= n; ++i) {\n        sum_of_cubes += i * i * i;\n    }\n\n    return sum_of_cubes / n;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble find_Average_Of_Cube(long n) {\n    double sum = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble find_Average_Of_Cube(long n) {\n    double sum = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n        sum += std::pow(i, 3);\n    }\n    return sum / n;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble find_Average_Of_Cube(long n) {\n    double sum = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ndouble find_Average_Of_Cube(long n) {\n    double sum = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n        sum += pow(i, 3);\n    }\n    return sum / n;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble find_Average_Of_Cube(long n) {\n    double sum = 0;\n    for (long i = 1; i <= n; i = i + 1) {\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble find_Average_Of_Cube(long n) {\n    double sum = 0;\n    for (long i = 1; i <= n; i = i + 1) {\n        sum += std::pow(i, 3);\n    }\n    return sum / n;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble find_Average_Of_Cube(long n) {\n    double sum = 0;\n    for (long i = 1; i <= n; i = i + 1) {\n//begin to write code\n', '\nusing namespace std;\n#include <cmath>\n#include <cassert>\n\ndouble find_Average_Of_Cube(long n) {\n    double sum = 0;\n    for (long i = 1; i <= n; i = i + 1) {\n        sum += pow(i, 3);\n    }\n    return sum / n;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble find_Average_Of_Cube(long n) {\n    double sum = 0;\n    for (long i = 1; i <= n; i = 1 + i) {\n//begin to write code\n', '\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ndouble find_Average_Of_Cube(long n) {\n    double sum = 0;\n    for (long i = 1; i <= n; i = 1 + i) {\n        sum += pow(i, 3);\n    }\n    return sum / n;\n}\n\n', 'exchange_operators')]}"
412,"#include <iostream>
#include <vector>
#include <cassert>
#include <algorithm>
using namespace std;
int get_maxgold(vector<vector<int>> gold, int m, int n) {
    vector<vector<int>> goldTable(m, vector<int>(n, 0));   
    for (int col = n-1; col >= 0; col--) { 
        for (int row = 0; row < m; row++) { 
            int right = (col == n-1) ? 0 : goldTable[row][col+1];
            int right_up = (row == 0 || col == n-1) ? 0 : goldTable[row-1][col+1];
            int right_down = (row == m-1 || col == n-1) ? 0 : goldTable[row+1][col+1];
            goldTable[row][col] = gold[row][col] + max({right, right_up, right_down});
//begin to write code
",651,"
#include <iostream>
#include <vector>
#include <cassert>
#include <algorithm>
using namespace std;

int get_maxgold(vector<vector<int>> gold, int m, int n) {
    vector<vector<int>> goldTable(m, vector<int>(n, 0));   
    for (int col = n-1; col >= 0; col--) { 
        for (int row = 0; row < m; row++) { 
            int right = (col == n-1) ? 0 : goldTable[row][col+1];
            int right_up = (row == 0 || col == n-1) ? 0 : goldTable[row-1][col+1];
            int right_down = (row == m-1 || col == n-1) ? 0 : goldTable[row+1][col+1];
            goldTable[row][col] = gold[row][col] + max({right, right_up, right_down});
        }
    }
    int res = goldTable[0][0];
    for (int i = 1; i < m; i++) {
        res = max(res, goldTable[i][0]);
    }
    return res;
}


","
#include <iostream>
#include <vector>
#include <cassert>
#include <algorithm>
using namespace std;

int get_maxgold(vector<vector<int>> gold, int m, int n) {
    vector<vector<int>> goldTable(m, vector<int>(n, 0));   
    for (int col = n-1; col >= 0; col--) { 
        for (int row = 0; row < m; row++) { 
            int right = (col == n-1)? 0 : goldTable[row][col+1];
            int right_up = (row == 0 || col == n-1)? 0 : goldTable[row-1][col+1];
            int right_down = (row == m-1 || col == n-1)? 0 : goldTable[row+1][col+1];
            goldTable[row][col] = gold[row][col] + max({right, right_up, right_down});
        }
    }
    return goldTable[m-1][n-1];
}

",,,,-2,1,0.24268106619517008,code_expression_exchange:None,0.0,0.0,
413,"#include <iostream>
#include <vector>
#include <string>
#include <cassert>
std::vector<char> extract_rear(std::vector<std::string> test_tuple) {
    std::vector<char> res;
    for (const std::string& sub : test_tuple) {
//begin to write code
",242,"
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

std::vector<char> extract_rear(std::vector<std::string> test_tuple) {
    std::vector<char> res;
    for (const std::string& sub : test_tuple) {
        res.push_back(sub[sub.length() - 1]);
    }
    return res;
}


","
#include <iostream>
#include <vector>
#include <string>
#include <cassert>
#include <algorithm>

std::vector<char> extract_rear(std::vector<std::string> test_tuple) {
    std::vector<char> res;
    for (const std::string& sub : test_tuple) {
        // Assuming the last character of the string is the rear index
        char rear_index = sub.back();
        res.push_back(rear_index);
    }
    return res;
}

","#include <iostream>
#include <vector>
#include <string>
#include <cassert>
std::vector<char> extract_rear(std::vector<std::string> test_tuple) {
    std::vector<char> res;
    for (const std::string& sub : test_tuple) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

std::vector<char> extract_rear(std::vector<std::string> test_tuple) {
    std::vector<char> res;
    for (const std::string& sub : test_tuple) {
        res.push_back(sub[sub.length() - 1]);
    }
    return res;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

std::vector<char> extract_rear(std::vector<std::string> test_tuple) {
    std::vector<char> res;
    for (const std::string& sub : test_tuple) {
        if (!sub.empty()) {
            res.push_back(sub.back());
        }
    }
    return res;
}

",-1,21,2.95694850285848,code_expression_exchange:equal_expression_transformation,1.0,0.8698207342325515,"{'\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n        res.push_back(sub[sub.length() - 1]);\n    }\n    return res;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n        res.push_back(sub.back());\n    }\n    return res;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n        // Extract the last character of the substring\n        char last_char = sub.back();\n        // Append the last character to the result vector\n        res.push_back(last_char);\n    }\n    return res;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <algorithm>\n\nstd::vector<char> extract_rear(const std::vector<std::string>& test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n        if (!sub.empty()) {\n            res.push_back(sub.back());\n        }\n    }\n    return res;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nstd::vector<char> extract_rear(const std::vector<std::string>& test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n        res.push_back(sub.back());\n    }\n    return res;\n}\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n        if (!sub.empty()) {\n            res.push_back(sub.back());\n        }\n    }\n    return res;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <algorithm>\n\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n        // Extract the last character of the substring\n        char last_char = sub.back();\n        // Append the last character to the result vector\n        res.push_back(last_char);\n    }\n    return res;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n        // Extract the last character of the substring\n        char last_char = sub.back();\n        // Append the last character to the result vector\n        res.push_back(last_char);\n    }\n    return res;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nstd::vector<char> extract_rear(const std::vector<std::string>& test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n        res.push_back(sub.back());\n    }\n    return res;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n        // Extract the last character of the string\n        char last_char = sub.back();\n        res.push_back(last_char);\n    }\n    return res;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nstd::vector<char> extract_rear(std::vector<std::string> test_tuple) {\n    std::vector<char> res;\n    for (const std::string& sub : test_tuple) {\n        if (!sub.empty()) {\n            res.push_back(sub.back());\n        }\n    }\n    return res;\n}\n\n', 'equal_expression_transformation')]}"
414,"#include<iostream>
#include<vector>
#include<cassert>
template<typename T>
int count_element_in_list(const std::vector<std::vector<T>>& list1, T x) {
    int ctr = 0;
    for (const auto& sublist : list1) {
        for (const auto& element : sublist) {
            if (element == x) {
//begin to write code
",307,"
#include<iostream>
#include<vector>
#include<cassert>

template<typename T>
int count_element_in_list(const std::vector<std::vector<T>>& list1, T x) {
    int ctr = 0;
    for (const auto& sublist : list1) {
        for (const auto& element : sublist) {
            if (element == x) {
                ctr++;
                break;
            }
        }
    }
    return ctr;
}


","
#include <iostream>
#include <vector>
#include <cassert>

template<typename T>
int count_element_in_list(const std::vector<std::vector<T>>& list1, T x) {
    int ctr = 0;
    for (const auto& sublist : list1) {
        for (const auto& element : sublist) {
            if (element == x) {
                ctr++;
            }
        }
    }
    return ctr;
}

","#include<iostream>
#include<vector>
#include<cassert>
template<typename T>
long count_element_in_list(const std::vector<std::vector<T>>& list1, T x) {
    int ctr = 0;
    for (const auto& sublist : list1) {
        for (const auto& element : sublist) {
            if (x == element) {
//begin to write code
","
#include<iostream>
#include<vector>
#include<cassert>

template<typename T>
long count_element_in_list(const std::vector<std::vector<T>>& list1, T x) {
    int ctr = 0;
    for (const auto& sublist : list1) {
        for (const auto& element : sublist) {
            if (x == element) {
                ctr++;
                break;
            }
        }
    }
    return ctr;
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

template<typename T>
long count_element_in_list(const std::vector<std::vector<T>>& list1, T x) {
    int ctr = 0;
    for (const auto& sublist : list1) {
        for (const auto& element : sublist) {
            if (x == element) {
                ctr++;
            }
        }
    }
    return ctr;
}
",1,7,1.0612297574679057,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include<iostream>\n#include<vector>\n#include<cassert>\n\ntemplate<typename T>\nlong count_element_in_list(const std::vector<std::vector<T>>& list1, T x) {\n    int ctr = 0;\n    for (const auto& sublist : list1) {\n        for (const auto& element : sublist) {\n            if (x == element) {\n                ctr++;\n                break;\n            }\n        }\n    }\n    return ctr;\n}\n\n\n': [('#include<iostream>\n#include<vector>\n#include<cassert>\ntemplate<typename T>\nint count_element_in_list(const std::vector<std::vector<T>>& list1, T x) {\n    int ctr = 0;\n    for (const auto& sublist : list1) {\n        for (const auto& element : sublist) {\n            if (element == x) {\n//begin to write code\n', '\n#include<iostream>\n#include<vector>\n#include<cassert>\n\ntemplate<typename T>\nint count_element_in_list(const std::vector<std::vector<T>>& list1, T x) {\n    int ctr = 0;\n    for (const auto& sublist : list1) {\n        for (const auto& element : sublist) {\n            if (element == x) {\n                ctr++;\n            }\n        }\n    }\n    return ctr;\n}\n\n', 'bool2int'), ('#include<iostream>\n#include<vector>\n#include<cassert>\ntemplate<typename T>\nint count_element_in_list(const std::vector<std::vector<T>>& list1, T x) {\n    int ctr = 0;\n    for (const auto& sublist : list1) {\n        for (const auto& element : sublist) {\n            if (x == element) {\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\n#include<assert.h>\n\ntemplate<typename T>\nint count_element_in_list(const std::vector<std::vector<T>>& list1, T x) {\n    int ctr = 0;\n    for (const auto& sublist : list1) {\n        for (const auto& element : sublist) {\n            if (element == x) {\n                ctr++;\n            }\n        }\n    }\n    return ctr;\n}\n\n', 'exchange_operators'), ('#include<iostream>\n#include<vector>\n#include<cassert>\ntemplate<typename T>\nlong count_element_in_list(const std::vector<std::vector<T>>& list1, T x) {\n    int ctr = 0;\n    for (const auto& sublist : list1) {\n        for (const auto& element : sublist) {\n            if (x == element) {\n//begin to write code\n', 'using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\ntemplate<typename T>\nlong count_element_in_list(const std::vector<std::vector<T>>& list1, T x) {\n    int ctr = 0;\n    for (const auto& sublist : list1) {\n        for (const auto& element : sublist) {\n            if (x == element) {\n                ctr++;\n            }\n        }\n    }\n    return ctr;\n}\n', 'more_universe_var_type')]}"
415,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
std::vector<int> filter_oddnumbers(const std::vector<int>& nums) {
    std::vector<int> odd_nums;
    std::copy_if(nums.begin(), nums.end(), std::back_inserter(odd_nums), [](int x){ 
//begin to write code
",282,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> filter_oddnumbers(const std::vector<int>& nums) {
    std::vector<int> odd_nums;
    std::copy_if(nums.begin(), nums.end(), std::back_inserter(odd_nums), [](int x){ 
    return x % 2 != 0; 
    });
    return odd_nums;
}


","
#include <cassert>
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>

std::vector<int> filter_oddnumbers(const std::vector<int>& nums) {
    std::vector<int> odd_nums;
    std::copy_if(nums.begin(), nums.end(), std::back_inserter(odd_nums), [](int x){ 
        return x % 2!= 0; // Check if the number is odd
    });
    return odd_nums;
}

","#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
std::vector<long> filter_oddnumbers(const std::vector<int>& nums) {
    std::vector<int> odd_nums;
    std::copy_if(nums.begin(), nums.end(), std::back_inserter(odd_nums), [](int x){ 
//begin to write code
","#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<long> filter_oddnumbers(const std::vector<int>& nums) {
    std::vector<int> odd_nums;
    std::copy_if(nums.begin(), nums.end(), std::back_inserter(odd_nums), [](int x){ 
    return x % 2 != 0; 
    });
    return odd_nums;
}


","#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>

std::vector<long> filter_oddnumbers(const std::vector<int>& nums) {
    std::vector<int> odd_nums;
    std::copy_if(nums.begin(), nums.end(), std::back_inserter(odd_nums), [](int x){
        return x % 2!= 0;
    });
    return odd_nums;
}
",1,3,0.47388595740000405,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<long> filter_oddnumbers(const std::vector<int>& nums) {\n    std::vector<int> odd_nums;\n    std::copy_if(nums.begin(), nums.end(), std::back_inserter(odd_nums), [](int x){ \n    return x % 2 != 0; \n    });\n    return odd_nums;\n}\n\n\n': [('#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nstd::vector<long> filter_oddnumbers(const std::vector<int>& nums) {\n    std::vector<int> odd_nums;\n    std::copy_if(nums.begin(), nums.end(), std::back_inserter(odd_nums), [](int x){ \n//begin to write code\n', '#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nstd::vector<long> filter_oddnumbers(const std::vector<int>& nums) {\n    std::vector<int> odd_nums;\n    std::copy_if(nums.begin(), nums.end(), std::back_inserter(odd_nums), [](int x){\n        return x % 2!= 0;\n    });\n    return odd_nums;\n}\n', 'more_universe_var_type')]}"
416,"#include <iostream>
#include <string>
#include <regex>
#include <cassert>
using namespace std;
string change_date_format(const string &dt) {
    regex pattern(R""((\d{4})-(\d{1,2})-(\d{1,2}))"");
//begin to write code
",216,"#include <iostream>
#include <string>
#include <regex>
#include <cassert>

using namespace std;

string change_date_format(const string &dt) {
    regex pattern(R""((\d{4})-(\d{1,2})-(\d{1,2}))"");
    return regex_replace(dt, pattern, ""$3-$2-$1"");
}","
#include <iostream>
#include <string>
#include <regex>
#include <cassert>
using namespace std;

string change_date_format(const string &dt) {
    // Use regex to match the date format ""yyyy-MM-dd""
    regex pattern(R""((\d{4})-(\d{1,2})-(\d{1,2}))"");
    
    // If the date matches, extract the year, month, and day
    if (regex_match(dt, pattern)) {
        int year = stoi(match[1]);
        int month = stoi(match[2]);
        int day = stoi(match[3]);
        
        // Format the date as ""dd-mm-yyyy""
        return to_string(day) + ""-"" + to_string(month) + ""-"" + to_string(year);
    }
    
    // If no match is found, return an empty string
    return """";
}

",,,,-2,1,0.2406761686007182,code_expression_exchange:None,0.0,0.0,
417,"#include <iostream>
#include <vector>
#include <cassert>
void shell_sort(std::vector<int>& my_list) {
    int gap = my_list.size() / 2;
    while (gap > 0) {
        for (int i = gap; i < my_list.size(); i++) {
            int current_item = my_list[i];
            int j = i;
            while (j >= gap && my_list[j - gap] > current_item) {
//begin to write code
",365,"
#include <iostream>
#include <vector>
#include <cassert>

void shell_sort(std::vector<int>& my_list) {
    int gap = my_list.size() / 2;
    while (gap > 0) {
        for (int i = gap; i < my_list.size(); i++) {
            int current_item = my_list[i];
            int j = i;
            while (j >= gap && my_list[j - gap] > current_item) {
                my_list[j] = my_list[j - gap];
                j -= gap;
            }
            my_list[j] = current_item;
        }
        gap /= 2;
    }
}


","
#include <iostream>
#include <vector>
#include <cassert>

// Function to perform shell sort on a vector
void shell_sort(std::vector<int>& my_list) {
    int gap = my_list.size() / 2;
    while (gap > 0) {
        for (int i = gap; i < my_list.size(); i++) {
            int current_item = my_list[i];
            int j = i;
            while (j >= gap && my_list[j - gap] > current_item) {
                std::swap(my_list[j], my_list[j - gap]);
                j -= gap;
            }
        }
        gap /= 2;
    }
}

// Test function to verify the correctness of the shell_sort function
void test_shell_sort() {
    assert(shell_sort({}) == std::vector<int>());
    assert(shell_sort({3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5}) == std::vector<int>({1, 1, 2, 3, 3, 4, 5, 5, 6, 6, 9}));
    assert(shell_sort({7",,,,-2,1,0.2312007745107015,code_expression_exchange:None,0.0,0.0,
418,"#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>
std::tuple<int, int, int, int> and_tuples(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {
    return std::make_tuple(
        std::get<0>(test_tup1) & std::get<0>(test_tup2),
        std::get<1>(test_tup1) & std::get<1>(test_tup2),
//begin to write code
",380,"
#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>

std::tuple<int, int, int, int> and_tuples(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {
    return std::make_tuple(
        std::get<0>(test_tup1) & std::get<0>(test_tup2),
        std::get<1>(test_tup1) & std::get<1>(test_tup2),
        std::get<2>(test_tup1) & std::get<2>(test_tup2),
        std::get<3>(test_tup1) & std::get<3>(test_tup2)
    );
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>

std::tuple<int, int, int, int> and_tuples(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {
    return std::make_tuple(
        std::get<0>(test_tup1) & std::get<0>(test_tup2),
        std::get<1>(test_tup1) & std::get<1>(test_tup2),
        std::get<2>(test_tup1) & std::get<2>(test_tup2),
        std::get<3>(test_tup1) & std::get<3>(test_tup2)
    );
}

","#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>
std::tuple<int, int, long, int> and_tuples(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {
    return std::make_tuple(
        std::get<0>(test_tup2) & std::get<0>(test_tup1),
        std::get<1>(test_tup2) & std::get<1>(test_tup1),
//begin to write code
","
#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>

std::tuple<int, int, long, int> and_tuples(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {
    return std::make_tuple(
        std::get<0>(test_tup2) & std::get<0>(test_tup1),
        std::get<1>(test_tup2) & std::get<1>(test_tup1),
        std::get<2>(test_tup2) & std::get<2>(test_tup1),
        std::get<3>(test_tup2) & std::get<3>(test_tup1)
    );
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <tuple>
#include <cassert>

std::tuple<int, int, long, int> and_tuples(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {
    return std::make_tuple(
        std::get<0>(test_tup2) & std::get<0>(test_tup1),
        std::get<1>(test_tup2) & std::get<1>(test_tup1),
        //begin to write code
    );
}

",1,7,1.0243089119593303,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, long, int> and_tuples(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) & std::get<0>(test_tup1),\n        std::get<1>(test_tup2) & std::get<1>(test_tup1),\n        std::get<2>(test_tup2) & std::get<2>(test_tup1),\n        std::get<3>(test_tup2) & std::get<3>(test_tup1)\n    );\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, int, int> and_tuples(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) & std::get<0>(test_tup1),\n        std::get<1>(test_tup2) & std::get<1>(test_tup1),\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, int, int> and_tuples(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) & std::get<0>(test_tup1),\n        std::get<1>(test_tup2) & std::get<1>(test_tup1),\n        std::get<2>(test_tup2) & std::get<2>(test_tup1),\n        std::get<3>(test_tup2) & std::get<3>(test_tup1)\n    );\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, long, int> and_tuples(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) & std::get<0>(test_tup1),\n        std::get<1>(test_tup2) & std::get<1>(test_tup1),\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, long, int> and_tuples(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) & std::get<0>(test_tup1),\n        std::get<1>(test_tup2) & std::get<1>(test_tup1),\n        std::get<2>(test_tup2) & std::get<2>(test_tup1),\n        std::get<3>(test_tup2) & std::get<3>(test_tup1)\n    );\n}\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nstd::tuple<int, int, long, int> and_tuples(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) & std::get<0>(test_tup1),\n        std::get<1>(test_tup2) & std::get<1>(test_tup1),\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\nstd::tuple<int, int, long, int> and_tuples(const std::tuple<int, int, int, int>& test_tup1, const std::tuple<int, int, int, int>& test_tup2) {\n    return std::make_tuple(\n        std::get<0>(test_tup2) & std::get<0>(test_tup1),\n        std::get<1>(test_tup2) & std::get<1>(test_tup1),\n        //begin to write code\n    );\n}\n\n', 'bool2int')]}"
419,"#include <iostream>
#include <cassert>
int parabola_directrix(int a, int b, int c) {
    int directrix = c - ((b * b) + 1) * 4 * a;
//begin to write code
",154,"
#include <iostream>
#include <cassert>

int parabola_directrix(int a, int b, int c) {
    int directrix = c - ((b * b) + 1) * 4 * a;
    return directrix;
}


","
using namespace std;

#include <iostream>
#include <cassert>

int parabola_directrix(int a, int b, int c) {
    int directrix = c - ((b * b) + 1) * 4 * a;
    return directrix;
}

","#include <iostream>
#include <cassert>
int parabola_directrix(int a, int b, int c) {
    int directrix = c - ((b * b) + 1) * 4 * a;
//begin to write code
","
#include <iostream>
#include <cassert>

int parabola_directrix(int a, int b, int c) {
    int directrix = c - ((b * b) + 1) * 4 * a;
    return directrix;
}


","
using namespace std;
#include <iostream>
#include <cassert>

int parabola_directrix(int a, int b, int c) {
    // Directrix of a parabola given by the equation ax^2 + bx + c = 0
    return -(b * b - 4 * a * c);
}

",1,3,0.5185436169306438,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nint parabola_directrix(int a, int b, int c) {\n    int directrix = c - ((b * b) + 1) * 4 * a;\n    return directrix;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint parabola_directrix(int a, int b, int c) {\n    int directrix = c - ((b * b) + 1) * 4 * a;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <cassert>\n\nint parabola_directrix(int a, int b, int c) {\n    // Directrix of a parabola given by the equation ax^2 + bx + c = 0\n    return -(b * b - 4 * a * c);\n}\n\n', 'bool2int')]}"
420,"#include <iostream>
#include <vector>
#include <cassert>
template <typename T>
bool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {
    for (const auto& x : list1) {
        for (const auto& y : list2) {
            if (x == y) {
//begin to write code
",279,"
#include <iostream>
#include <vector>
#include <cassert>

template <typename T>
bool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {
    for (const auto& x : list1) {
        for (const auto& y : list2) {
            if (x == y) {
                return true;
            }
        }
    }
    return false;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

template <typename T>
bool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {
    for (const auto& x : list1) {
        for (const auto& y : list2) {
            if (x == y) {
                return true;
            }
        }
    }
    return false;
}

","#include <iostream>
#include <vector>
#include <cassert>
template <typename T>
bool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {
    for (const auto& x : list1) {
        for (const auto& y : list2) {
            if (y == x) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

template <typename T>
bool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {
    for (const auto& x : list1) {
        for (const auto& y : list2) {
            if (y == x) {
                return 1;
            }
        }
    }
    return 0;
}


","
#include <iostream>
#include <vector>
#include <cassert>
#include <unordered_set>

template <typename T>
bool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {
    // Use an unordered set to store elements from list2
    std::unordered_set<T> set2(list2.begin(), list2.end());

    // Iterate over each element in list1
    for (const auto& x : list1) {
        // Check if the current element is in the set2
        if (set2.find(x)!= set2.end()) {
            return true;
        }
    }

    // If no common element is found, return false
    return false;
}

",-1,21,3.1437410434087116,code_expression_exchange:bool2int,1.0,0.6932778131565509,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <unordered_set>\n\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    std::unordered_set<T> set1(list1.begin(), list1.end());\n    for (const auto& x : list2) {\n        if (set1.find(x)!= set1.end()) {\n            return true;\n        }\n    }\n    return false;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    for (const auto& x : list1) {\n        for (const auto& y : list2) {\n            if (y == x) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <unordered_set>\n\ntemplate <typename T>\nbool common_element(const std::vector<T>& list1, const std::vector<T>& list2) {\n    // Use an unordered set to store elements from list2\n    std::unordered_set<T> set2(list2.begin(), list2.end());\n\n    // Iterate over each element in list1\n    for (const auto& x : list1) {\n        // Check if the current element is in the set2\n        if (set2.find(x)!= set2.end()) {\n            return true;\n        }\n    }\n\n    // If no common element is found, return false\n    return false;\n}\n\n', 'bool2int')]}"
421,"#include <iostream>
#include <cassert>
double median_trapezium(double base1, double base2, double height) {
    double median = 0.5 * (base1 + base2);
//begin to write code
",173,"
#include <iostream>
#include <cassert>

double median_trapezium(double base1, double base2, double height) {
    double median = 0.5 * (base1 + base2);
    return median;
}


","
#include <iostream>
#include <cassert>

double median_trapezium(double base1, double base2, double height) {
    double median = 0.5 * (base1 + base2);
    return median;
}

","#include <iostream>
#include <cassert>
double median_trapezium(double base1, double base2, double height) {
    double median = (base1 + base2) * 0.5;
//begin to write code
","
#include <iostream>
#include <cassert>

double median_trapezium(double base1, double base2, double height) {
    double median = (base1 + base2) * 0.5;
    return median;
}


","
#include <iostream>
#include <cassert>
#include <vector>

using namespace std;

double median_trapezium(double base1, double base2, double height) {
    // Sort the base lengths to find the median
    sort(base1, base2);
    double median = (base1 + base2) / 2.0;
    return median;
}

",1,3,0.4778898318608602,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\ndouble median_trapezium(double base1, double base2, double height) {\n    double median = (base1 + base2) * 0.5;\n    return median;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\ndouble median_trapezium(double base1, double base2, double height) {\n    double median = (base1 + base2) * 0.5;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n#include <vector>\n\nusing namespace std;\n\ndouble median_trapezium(double base1, double base2, double height) {\n    // Sort the base lengths to find the median\n    sort(base1, base2);\n    double median = (base1 + base2) / 2.0;\n    return median;\n}\n\n', 'exchange_operators')]}"
422,"#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
std::string check_greater(std::vector<int> arr, int number) {
    std::sort(arr.begin(), arr.end());
    if (number > arr.back()) {
        return ""Yes, the entered number is greater than those in the array"";
//begin to write code
",309,"
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::string check_greater(std::vector<int> arr, int number) {
    std::sort(arr.begin(), arr.end());
    if (number > arr.back()) {
        return ""Yes, the entered number is greater than those in the array"";
    } else {
        return ""No, entered number is less than those in the array"";
    }
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::string check_greater(std::vector<int> arr, int number) {
    std::sort(arr.begin(), arr.end());
    if (number > arr.back()) {
        return ""Yes, the entered number is greater than those in the array"";
    } else {
        return ""No, the entered number is not greater than those in the array"";
    }
}

",,,,-2,1,0.20619152386983236,code_expression_exchange:None,0.0,0.0,
423,"#include <iostream>
#include <regex>
#include <cassert>
using namespace std;
string text_match_one(string text) {
    regex pattern(""ab+?"");
    if (regex_search(text, pattern)) {
        return ""Found a match!"";
//begin to write code
",235,"#include <iostream>
#include <regex>
#include <cassert>

using namespace std;

string text_match_one(string text) {
    regex pattern(""ab+?"");
    if (regex_search(text, pattern)) {
        return ""Found a match!"";
    } else {
        return ""Not matched!"";
    }
}","
#include <iostream>
#include <regex>
#include <cassert>
using namespace std;

string text_match_one(string text) {
    regex pattern(""ab+"");
    if (regex_search(text, pattern)) {
        return ""Found a match!"";
    }
    return ""No match found."";
}

",,,,-2,1,0.24894034067789714,code_expression_exchange:None,0.0,0.0,
424,"#include <iostream>
#include <cassert>
int last_Digit(int n) {
//begin to write code
",85,"
#include <iostream>
#include <cassert>

int last_Digit(int n) {
    return n % 10;
}


","
#include <iostream>
#include <cassert>

int last_Digit(int n) {
    // Get the absolute value of the number
    int abs_n = std::abs(n);
    
    // Return the last digit of the absolute value
    return abs_n % 10;
}

","#include <iostream>
#include <cassert>
int last_Digit(int n) {
//begin to write code
","
#include <iostream>
#include <cassert>

int last_Digit(int n) {
    return n % 10;
}


","
using namespace std;
#include <iostream>

int last_Digit(int n) {
    // Return the last digit of the number
    return abs(n) % 10;
}

",1,7,0.9771936813990275,code_expression_exchange:bool2int,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nint last_Digit(int n) {\n    return n % 10;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint last_Digit(int n) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <cassert>\n\nint last_Digit(int n) {\n    // Find the last digit of the number using the modulus operator\n    return n % 10;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cassert>\nint last_Digit(int n) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint last_Digit(int n) {\n    // Find the last digit of the number\n    int last_digit = n % 10;\n    return last_digit;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cassert>\nint last_Digit(int n) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n\nint last_Digit(int n) {\n    // Return the last digit of the number\n    return abs(n) % 10;\n}\n\n', 'bool2int')]}"
425,"#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> neg_nos(const std::vector<int>& list1) {
    std::vector<int> negatives;
    for (int num : list1) {
        if (num < 0) {
//begin to write code
",220,"
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> neg_nos(const std::vector<int>& list1) {
    std::vector<int> negatives;
    for (int num : list1) {
        if (num < 0) {
            negatives.push_back(num);
        }
    }
    return negatives;
}


","
#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> neg_nos(const std::vector<int>& list1) {
    std::vector<int> negatives;
    for (int num : list1) {
        if (num < 0) {
            negatives.push_back(num);
        }
    }
    return negatives;
}

// Test cases
void test_neg_nos() {
    assert(neg_nos({1, -2, 3, -4}) == std::vector<int>({1, -2, 3}));
    assert(neg_nos({-5, -6, -7}) == std::vector<int>({5, 6, 7}));
    assert(neg_nos({0, -1, -2}) == std::vector<int>({0, -1, -2}));
    assert(neg_nos({-8, -9, -10}) == std::vector<int>({8, 9, 10}));
    std::cout << ""All test cases passed successfully."" << std::endl;
}

","#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> neg_nos(const std::vector<int>& list1) {
    std::vector<int> negatives;
    for (int num : list1) {
        if (num < 0) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> neg_nos(const std::vector<int>& list1) {
    std::vector<int> negatives;
    for (int num : list1) {
        if (num < 0) {
            negatives.push_back(num);
        }
    }
    return negatives;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> neg_nos(const std::vector<int>& list1) {
    std::vector<int> negatives;
    for (int num : list1) {
        if (num < 0) {
            negatives.push_back(num);
        }
    }
    return negatives;
}

void test_neg_nos() {
    assert(neg_nos({1, -2, 3, -4}) == {-2, -4});
    assert(neg_nos({0, -1, -2, -3}) == {-1, -2, -3});
    assert(neg_nos({-5, -6, -7, -8}) == {-5, -6, -7, -8});
    cout << ""All tests passed successfully."" << endl;
}

",1,3,0.498279861609141,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> neg_nos(const std::vector<int>& list1) {\n    std::vector<int> negatives;\n    for (int num : list1) {\n        if (num < 0) {\n            negatives.push_back(num);\n        }\n    }\n    return negatives;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> neg_nos(const std::vector<int>& list1) {\n    std::vector<int> negatives;\n    for (int num : list1) {\n        if (num < 0) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> neg_nos(const std::vector<int>& list1) {\n    std::vector<int> negatives;\n    for (int num : list1) {\n        if (num < 0) {\n            negatives.push_back(num);\n        }\n    }\n    return negatives;\n}\n\nvoid test_neg_nos() {\n    assert(neg_nos({1, -2, 3, -4}) == {-2, -4});\n    assert(neg_nos({0, -1, -2, -3}) == {-1, -2, -3});\n    assert(neg_nos({-5, -6, -7, -8}) == {-5, -6, -7, -8});\n    cout << ""All tests passed successfully."" << endl;\n}\n\n', 'exchange_operators')]}"
426,"#include <iostream>
#include <string>
#include <cassert>
std::string remove_odd(const std::string& str1) {
    std::string str2;
    for (int i = 1; i <= str1.length(); ++i) {
        if (i % 2 == 0) {
//begin to write code
",224,"
#include <iostream>
#include <string>
#include <cassert>

std::string remove_odd(const std::string& str1) {
    std::string str2;
    for (int i = 1; i <= str1.length(); ++i) {
        if (i % 2 == 0) {
            str2 += str1[i - 1];
        }
    }
    return str2;
}


","
using namespace std;
#include <iostream>
#include <string>
#include <cassert>

std::string remove_odd(const std::string& str1) {
    std::string str2;
    for (int i = 1; i <= str1.length(); ++i) {
        if (i % 2 == 0) {
            str2 += str1[i];
        }
    }
    return str2;
}

void test_remove_odd() {
    assert(remove_odd("""") == """");
    assert(remove_odd(""ab"") == ""ab"");
    assert(remove_odd(""abc"") == ""abc"");
    assert(remove_odd(""abcdefg"") == ""aceg"");
    cout << ""All tests passed!"" << endl;
}

",,,,-2,1,0.2063697059949239,code_expression_exchange:None,0.0,0.0,
427,"#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
int count_bidirectional(vector<pair<int, int>> test_list) {
    int res = 0;
    for (size_t idx = 0; idx < test_list.size(); ++idx) {
        for (size_t iidx = idx + 1; iidx < test_list.size(); ++iidx) {
            if (test_list[iidx].first == test_list[idx].second && test_list[idx].second == test_list[iidx].first) {
//begin to write code
",422,"#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

int count_bidirectional(vector<pair<int, int>> test_list) {
    int res = 0;
    for (size_t idx = 0; idx < test_list.size(); ++idx) {
        for (size_t iidx = idx + 1; iidx < test_list.size(); ++iidx) {
            if (test_list[iidx].first == test_list[idx].second && test_list[idx].second == test_list[iidx].first) {
                res += 1;
            }
        }
    }
    return res;
}","#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

int count_bidirectional(vector<pair<int, int>> test_list) {
    int res = 0;
    for (size_t idx = 0; idx < test_list.size(); ++idx) {
        for (size_t iidx = idx + 1; iidx < test_list.size(); ++iidx) {
            if (test_list[iidx].first == test_list[idx].second && test_list[idx].second == test_list[iidx].first) {
                ++res;
            }
        }
    }
    return res;
}
","#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
int count_bidirectional(vector<pair<long, int>> test_list) {
    int res = 0;
    for (size_t idx = 0; idx < test_list.size(); ++idx) {
        for (size_t iidx = 1 + idx; iidx < test_list.size(); ++iidx) {
            if (test_list[idx].second == test_list[iidx].first && test_list[iidx].first == test_list[idx].second) {
//begin to write code
","#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

int count_bidirectional(vector<pair<long, int>> test_list) {
    int res = 0;
    for (size_t idx = 0; idx < test_list.size(); ++idx) {
        for (size_t iidx = 1 + idx; iidx < test_list.size(); ++iidx) {
            if (test_list[idx].second == test_list[iidx].first && test_list[iidx].first == test_list[idx].second) {
                res = res + (1);
            }
        }
    }
    return res;
}","
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

int count_bidirectional(vector<pair<long, int>> test_list) {
    int res = 0;
    for (size_t idx = 0; idx < test_list.size(); ++idx) {
        for (size_t iidx = 1 + idx; iidx < test_list.size(); ++iidx) {
            if (test_list[idx].second == test_list[iidx].first && test_list[iidx].first == test_list[idx].second) {
                ++res;
            }
        }
    }
    return res;
}

",1,11,1.487296720345815,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint count_bidirectional(vector<pair<long, int>> test_list) {\n    int res = 0;\n    for (size_t idx = 0; idx < test_list.size(); ++idx) {\n        for (size_t iidx = 1 + idx; iidx < test_list.size(); ++iidx) {\n            if (test_list[idx].second == test_list[iidx].first && test_list[iidx].first == test_list[idx].second) {\n                res = res + (1);\n            }\n        }\n    }\n    return res;\n}': [('#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nint count_bidirectional(vector<pair<int, int>> test_list) {\n    int res = 0;\n    for (size_t idx = 0; idx < test_list.size(); ++idx) {\n        for (size_t iidx = idx + 1; iidx < test_list.size(); ++iidx) {\n            if (test_list[iidx].first == test_list[idx].second && test_list[idx].second == test_list[iidx].first) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint count_bidirectional(vector<pair<int, int>> test_list) {\n    int res = 0;\n    for (size_t idx = 0; idx < test_list.size(); ++idx) {\n        for (size_t iidx = idx + 1; iidx < test_list.size(); ++iidx) {\n            if (test_list[iidx].first == test_list[idx].second && test_list[idx].second == test_list[iidx].first) {\n                ++res;\n            }\n        }\n    }\n    return res;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nint count_bidirectional(vector<pair<int, int>> test_list) {\n    int res = 0;\n    for (size_t idx = 0; idx < test_list.size(); ++idx) {\n        for (size_t iidx = 1 + idx; iidx < test_list.size(); ++iidx) {\n            if (test_list[idx].second == test_list[iidx].first && test_list[iidx].first == test_list[idx].second) {\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint count_bidirectional(vector<pair<int, int>> test_list) {\n    int res = 0;\n    for (size_t idx = 0; idx < test_list.size(); ++idx) {\n        for (size_t iidx = 1 + idx; iidx < test_list.size(); ++iidx) {\n            if (test_list[idx].second == test_list[iidx].first && test_list[iidx].first == test_list[idx].second) {\n                ++res;\n            }\n        }\n    }\n    return res;\n}\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nint count_bidirectional(vector<pair<int, int>> test_list) {\n    int res = 0;\n    for (size_t idx = 0; idx < test_list.size(); ++idx) {\n        for (size_t iidx = 1 + idx; iidx < test_list.size(); ++iidx) {\n            if (test_list[idx].second == test_list[iidx].first && test_list[iidx].first == test_list[idx].second) {\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint count_bidirectional(vector<pair<int, int>> test_list) {\n    int res = 0;\n    for (size_t idx = 0; idx < test_list.size(); ++idx) {\n        for (size_t iidx = 1 + idx; iidx < test_list.size(); ++iidx) {\n            if (test_list[idx].second == test_list[iidx].first && test_list[iidx].first == test_list[idx].second) {\n                ++res;\n            }\n        }\n    }\n    return res;\n}\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nint count_bidirectional(vector<pair<int, int>> test_list) {\n    int res = 0;\n    for (size_t idx = 0; idx < test_list.size(); ++idx) {\n        for (size_t iidx = 1 + idx; iidx < test_list.size(); ++iidx) {\n            if (test_list[idx].second == test_list[iidx].first && test_list[iidx].first == test_list[idx].second) {\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint count_bidirectional(vector<pair<int, int>> test_list) {\n    int res = 0;\n    for (size_t idx = 0; idx < test_list.size(); ++idx) {\n        for (size_t iidx = 1 + idx; iidx < test_list.size(); ++iidx) {\n            if (test_list[idx].second == test_list[iidx].first && test_list[iidx].first == test_list[idx].second) {\n                ++res;\n            }\n        }\n    }\n    return res;\n}\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nint count_bidirectional(vector<pair<long, int>> test_list) {\n    int res = 0;\n    for (size_t idx = 0; idx < test_list.size(); ++idx) {\n        for (size_t iidx = 1 + idx; iidx < test_list.size(); ++iidx) {\n            if (test_list[idx].second == test_list[iidx].first && test_list[iidx].first == test_list[idx].second) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint count_bidirectional(vector<pair<long, int>> test_list) {\n    int res = 0;\n    for (size_t idx = 0; idx < test_list.size(); ++idx) {\n        for (size_t iidx = 1 + idx; iidx < test_list.size(); ++iidx) {\n            if (test_list[idx].second == test_list[iidx].first && test_list[iidx].first == test_list[idx].second) {\n                ++res;\n            }\n        }\n    }\n    return res;\n}\n\n', 'more_universe_var_type')]}"
428,"#include<cassert>
#include <iostream>
#include <vector>
#include <string>
#include <sstream>
int multiple_to_single(const std::vector<int>& L) {
    std::stringstream ss;
    for (int num : L) {
        ss << num;
//begin to write code
",236,"#include<cassert>
#include <iostream>
#include <vector>
#include <string>
#include <sstream>

int multiple_to_single(const std::vector<int>& L) {
    std::stringstream ss;
    for (int num : L) {
        ss << num;
    }
    int x;
    ss >> x;
    return x;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

int multiple_to_single(const std::vector<int>& L) {
    std::stringstream ss;
    for (int num : L) {
        ss << num;
    }
    return stoi(ss.str());
}

",,,,-2,1,0.2045110781987508,code_expression_exchange:None,0.0,0.0,
429,"#include <iostream>
#include <regex>
#include <tuple>
#include <cassert>
using namespace std;
tuple<int, int, string> find_adverb_position(const string& text) {
    regex pattern(""\\w+ly"");
    smatch match;
    if (regex_search(text, match, pattern)) {
//begin to write code
",276,"
#include <iostream>
#include <regex>
#include <tuple>
#include <cassert>
using namespace std;

tuple<int, int, string> find_adverb_position(const string& text) {
    regex pattern(""\\w+ly"");
    smatch match;
    if (regex_search(text, match, pattern)) {
        return {match.position(0), match.position(0) + match.length(0), match.str(0)};
    }
    return {-1, -1, """"}; // if no adverb found
}


","
#include <iostream>
#include <regex>
#include <tuple>
#include <cassert>
using namespace std;

tuple<int, int, string> find_adverb_position(const string& text) {
    regex pattern(""\\w+ly"");
    smatch match;
    if (regex_search(text, match, pattern)) {
        return {match.position(0), match.position(1), match.str(0)};
    }
    return {-1, -1, """"};
}

",,,,-2,1,0.24069857199986774,code_expression_exchange:None,0.0,0.0,
430,"#include<iostream>
#include <cassert>
//
int surfacearea_cube(int l) {
//begin to write code
",97,"#include<iostream>
    

#include <cassert>

//
int surfacearea_cube(int l) {
    int surfacearea = 6 * l * l;
    return surfacearea;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

int surfacearea_cube(int l) {
    // Calculate the surface area of a cube
    return 6 * l * l;
}

",,,,-2,1,0.1858432133992513,code_expression_exchange:None,0.0,0.0,
431,"#include<iostream>
#include <vector>
#include <cassert>
#include <cmath>
using namespace std;
double positive_count(vector<int> nums) {
    int n = nums.size();
    int n1 = 0;
    for (int x : nums) {
        if (x > 0) {
//begin to write code
",245,"#include<iostream>
    

#include <vector>
#include <cassert>
#include <cmath>
using namespace std;

double positive_count(vector<int> nums) {
    int n = nums.size();
    int n1 = 0;
    for (int x : nums) {
        if (x > 0) {
            n1 += 1;
        }
    }
    return round(n1 * 100.0 / n) / 100.0;
}


","
#include<iostream>
#include <vector>
#include <cassert>
#include <cmath>
using namespace std;

double positive_count(vector<int> nums) {
    int n = nums.size();
    int n1 = 0;
    for (int x : nums) {
        if (x > 0) {
            n1++;
        }
    }
    return (double)n1 / n;
}

void check() {
    assert(positive_count({1, 2, 3, 4, 5}) == 2.0);
    assert(positive_count({-1, -2, -3, -4, -5}) == 0.0);
    assert(positive_count({0, 0, 0, 0, 0}) == 0.0);
    assert(positive_count({10, 20, 30, 40, 50}) == 2.0);
    cout << ""All tests passed successfully."" << endl;
}

",,,,-2,1,0.23514773845672607,code_expression_exchange:None,0.0,0.0,
432,"#include <iostream>
#include <vector>
#include <cassert>
int largest_neg(std::vector<int> list1) {
    int max = list1[0];
    for (int x : list1) {
        if (x < max) {
//begin to write code
",194,"
#include <iostream>
#include <vector>
#include <cassert>

int largest_neg(std::vector<int> list1) {
    int max = list1[0];
    for (int x : list1) {
        if (x < max) {
            max = x;
        }
    }
    return max;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

int largest_neg(std::vector<int> list1) {
    int max = list1[0];
    for (int x : list1) {
        if (x < max) {
            max = x;
        }
    }
    return max;
}

","#include <iostream>
#include <vector>
#include <cassert>
int largest_neg(std::vector<long> list1) {
    long max = list1[0];
    for (long x : list1) {
        if (x < max) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

int largest_neg(std::vector<long> list1) {
    long max = list1[0];
    for (long x : list1) {
        if (x < max) {
            max = x;
        }
    }
    return max;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

int largest_neg(std::vector<long> list1) {
    long max = list1[0];
    for (long x : list1) {
        if (x < max) {
            max = x;
        }
    }
    return max;
}

",-1,21,2.6335232535998028,code_expression_exchange:bool2int,1.0,0.8404734569789811,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint largest_neg(std::vector<long> list1) {\n    long max = list1[0];\n    for (long x : list1) {\n        if (x < max) {\n            max = x;\n        }\n    }\n    return max;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nint largest_neg(std::vector<long> list1) {\n    int max = list1[0];\n    for (int x : list1) {\n        if (x < max) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint largest_neg(std::vector<long> list1) {\n    int max = list1[0];\n    for (int x : list1) {\n        if (x < max) {\n            max = x;\n        }\n    }\n    return max;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint largest_neg(std::vector<long> list1) {\n    int max = list1[0];\n    for (int x : list1) {\n        if (x < max) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint largest_neg(std::vector<long> list1) {\n    int max = list1[0];\n    for (int x : list1) {\n        if (x < max) {\n            max = x;\n        }\n    }\n    return max;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint largest_neg(std::vector<long> list1) {\n    int max = list1[0];\n    for (int x : list1) {\n        if (x < max) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint largest_neg(std::vector<long> list1) {\n    int max = list1[0];\n    for (int x : list1) {\n        if (x < max) {\n            max = x;\n        }\n    }\n    return max;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint largest_neg(std::vector<long> list1) {\n    long max = list1[0];\n    for (int x : list1) {\n        if (x < max) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint largest_neg(std::vector<long> list1) {\n    long max = list1[0];\n    for (int x : list1) {\n        if (x < max) {\n            max = x;\n        }\n    }\n    return max;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint largest_neg(std::vector<long> list1) {\n    long max = list1[0];\n    for (int x : list1) {\n        if (x < max) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint largest_neg(std::vector<long> list1) {\n    long max = list1[0];\n    for (int x : list1) {\n        if (x < max) {\n            max = x;\n        }\n    }\n    return max;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint largest_neg(std::vector<long> list1) {\n    long max = list1[0];\n    for (long x : list1) {\n        if (x < max) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint largest_neg(std::vector<long> list1) {\n    long max = list1[0];\n    for (long x : list1) {\n        if (x < max) {\n            max = x;\n        }\n    }\n    return max;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint largest_neg(std::vector<long> list1) {\n    long max = list1[0];\n    for (long x : list1) {\n        if (x < max) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint largest_neg(std::vector<long> list1) {\n    long max = list1[0];\n    for (long x : list1) {\n        if (x < max) {\n            max = x;\n        }\n    }\n    return max;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint largest_neg(std::vector<long> list1) {\n    long max = list1[0];\n    for (long x : list1) {\n        if (x < max) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint largest_neg(std::vector<long> list1) {\n    long max = list1[0];\n    for (long x : list1) {\n        if (x < max) {\n            max = x;\n        }\n    }\n    return max;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint largest_neg(std::vector<long> list1) {\n    long max = list1[0];\n    for (long x : list1) {\n        if (x < max) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint largest_neg(std::vector<long> list1) {\n    long max = list1[0];\n    for (long x : list1) {\n        if (x < max) {\n            max = x;\n        }\n    }\n    return max;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint largest_neg(std::vector<long> list1) {\n    long max = list1[0];\n    for (long x : list1) {\n        if (x < max) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint largest_neg(std::vector<long> list1) {\n    long max = list1[0];\n    for (long x : list1) {\n        if (x < max) {\n            max = x;\n        }\n    }\n    return max;\n}\n\n', 'bool2int')]}"
433,"#include <iostream>
#include <vector>
#include <cassert>
#include <string>
#include <sstream>
using namespace std;
vector<vector<int>> trim_tuple(const vector<vector<int>>& test_list, int K) {
    vector<vector<int>> res;
    for (const auto& ele : test_list) {
        vector<int> tmp;
        for(int i = K ;i <= ele.size() - K - 1; i++)
        {
//begin to write code
",372,"#include <iostream>
#include <vector>
#include <cassert>
#include <string>
#include <sstream>

using namespace std;

vector<vector<int>> trim_tuple(const vector<vector<int>>& test_list, int K) {
    vector<vector<int>> res;
    for (const auto& ele : test_list) {
        vector<int> tmp;
        for(int i = K ;i <= ele.size() - K - 1; i++)
        {
            tmp.push_back(ele[i]);
        }
        res.push_back(tmp);
    }
    return res;
}","
#include <iostream>
#include <vector>
#include <cassert>
#include <string>
#include <sstream>
using namespace std;

vector<vector<int>> trim_tuple(const vector<vector<int>>& test_list, int K) {
    vector<vector<int>> res;
    for (const auto& ele : test_list) {
        vector<int> tmp;
        for (int i = K; i <= ele.size() - K - 1; i++) {
            tmp.push_back(ele[i]);
        }
        res.push_back(tmp);
    }
    return res;
}

","#include <iostream>
#include <vector>
#include <cassert>
#include <string>
#include <sstream>
using namespace std;
vector<vector<int>> trim_tuple(const vector<vector<int>>& test_list, int K) {
    vector<vector<int>> res;
    for (const auto& ele : test_list) {
        vector<long> tmp;
        for(int i = K ;i <= ele.size() - K - 1; i++)
        {
//begin to write code
","#include <iostream>
#include <vector>
#include <cassert>
#include <string>
#include <sstream>

using namespace std;

vector<vector<int>> trim_tuple(const vector<vector<int>>& test_list, int K) {
    vector<vector<int>> res;
    for (const auto& ele : test_list) {
        vector<long> tmp;
        for(int i = K ;i <= ele.size() - K - 1; i++)
        {
            tmp.push_back(ele[i]);
        }
        res.push_back(tmp);
    }
    return res;
}","
**Created Answer**:
",1,5,0.8634012659390767,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include <iostream>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<vector<int>> trim_tuple(const vector<vector<int>>& test_list, int K) {\n    vector<vector<int>> res;\n    for (const auto& ele : test_list) {\n        vector<long> tmp;\n        for(int i = K ;i <= ele.size() - K - 1; i++)\n        {\n            tmp.push_back(ele[i]);\n        }\n        res.push_back(tmp);\n    }\n    return res;\n}': [('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <sstream>\nusing namespace std;\nvector<vector<int>> trim_tuple(const vector<vector<int>>& test_list, int K) {\n    vector<vector<int>> res;\n    for (const auto& ele : test_list) {\n        vector<int> tmp;\n        for(int i = K ;i <= ele.size() - K - 1; i++)\n        {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<vector<int>> trim_tuple(const vector<vector<int>>& test_list, int K) {\n    vector<vector<int>> res;\n    for (const auto& ele : test_list) {\n        vector<int> tmp;\n        for (int i = K; i <= ele.size() - K - 1; i++) {\n            tmp.push_back(ele[i]);\n        }\n        res.push_back(tmp);\n    }\n    return res;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <sstream>\nusing namespace std;\nvector<vector<int>> trim_tuple(const vector<vector<int>>& test_list, int K) {\n    vector<vector<int>> res;\n    for (const auto& ele : test_list) {\n        vector<long> tmp;\n        for(int i = K ;i <= ele.size() - K - 1; i++)\n        {\n//begin to write code\n', '\n**Created Answer**:\n', 'more_universe_var_type')]}"
434,"#include<iostream>
#include <cassert>
#include <tuple>
#include <vector>
using namespace std;
// Helper function to perform index-wise multiplication
template<size_t I>
tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> index_multiplication_helper(
    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup1,
    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup2,
    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> res)
{
    auto tup1 = get<I - 1>(test_tup1);
    auto tup2 = get<I - 1>(test_tup2);
    get<I - 1>(res) = make_tuple(get<0>(tup1) * get<0>(tup2), get<1>(tup1) * get<1>(tup2));
    return index_multiplication_helper<I - 1>(test_tup1, test_tup2, res);
}
// Base case for the recursion
template<>
//begin to write code
",859,"#include<iostream>
    
#include <cassert>
#include <tuple>
#include <vector>
using namespace std;

// Helper function to perform index-wise multiplication
template<size_t I>
tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> index_multiplication_helper(
    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup1,
    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup2,
    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> res)
{
    auto tup1 = get<I - 1>(test_tup1);
    auto tup2 = get<I - 1>(test_tup2);
    get<I - 1>(res) = make_tuple(get<0>(tup1) * get<0>(tup2), get<1>(tup1) * get<1>(tup2));
    return index_multiplication_helper<I - 1>(test_tup1, test_tup2, res);
}

// Base case for the recursion
template<>
tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> index_multiplication_helper<0>(
    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup1,
    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup2,
    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> res)
{
    return res;
}

// Main function to perform index-wise multiplication
tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> index_multiplication(
    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup1,
    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup2)
{
    return index_multiplication_helper<4>(test_tup1, test_tup2, tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>());
}","
#include<iostream>
#include <cassert>
#include <tuple>
#include <vector>
using namespace std;

// Helper function to perform index-wise multiplication
template<size_t I>
tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> index_multiplication_helper(
    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup1,
    const tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>>& test_tup2,
    tuple<tuple<int, int>, tuple<int, int>, tuple<int, int>, tuple<int, int>> res)
{
    auto tup1 = get<I - 1>(test_tup1);
    auto tup2 = get<I - 1>(test_tup2);
    get<I - 1>(res) = make_tuple(get<0>(tup1) * get<0>(tup2), get<1>(tup1) * get<1>(tup2));
    return index_multiplication_helper<I - 1>(test_tup1, test_tup2, res);
}

// Base case",,,,-2,1,0.274789023399353,code_expression_exchange:None,0.0,0.0,
435,"#include <iostream>
#include <vector>
#include <cassert>
int count_Occurrence(const std::vector<char>& tup, const std::vector<char>& lst) {
    int count = 0;
    for (char item : tup) {
        for (char elem : lst) {
            if (item == elem) {
                count++;
//begin to write code
",298,"
#include <iostream>
#include <vector>
#include <cassert>

int count_Occurrence(const std::vector<char>& tup, const std::vector<char>& lst) {
    int count = 0;
    for (char item : tup) {
        for (char elem : lst) {
            if (item == elem) {
                count++;
                break;
            }
        }
    }
    return count;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <cassert>

int count_Occurrence(const std::vector<char>& tup, const std::vector<char>& lst) {
    int count = 0;
    for (char item : tup) {
        for (char elem : lst) {
            if (item == elem) {
                count++;
            }
        }
    }
    return count;
}

","#include <iostream>
#include <vector>
#include <cassert>
long count_Occurrence(const std::vector<char>& tup, const std::vector<char>& lst) {
    long count = 0;
    for (char item : tup) {
        for (char elem : lst) {
            if (item == elem) {
                count++;
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

long count_Occurrence(const std::vector<char>& tup, const std::vector<char>& lst) {
    long count = 0;
    for (char item : tup) {
        for (char elem : lst) {
            if (item == elem) {
                count++;
                break;
            }
        }
    }
    return count;
}


","
#include <iostream>
#include <string>
#include <unordered_map>
#include <cassert>

long count_characters(const std::string& str) {
    std::unordered_map<char, int> char_count;
    for (char ch : str) {
        char_count[ch]++;
    }
    return char_count.size();
}

",1,7,1.0974033713340758,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong count_Occurrence(const std::vector<char>& tup, const std::vector<char>& lst) {\n    long count = 0;\n    for (char item : tup) {\n        for (char elem : lst) {\n            if (item == elem) {\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nint count_Occurrence(const std::vector<char>& tup, const std::vector<char>& lst) {\n    long count = 0;\n    for (char item : tup) {\n        for (char elem : lst) {\n            if (item == elem) {\n                count++;\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <cassert>\n\nint count_Occurrence(const std::vector<char>& tup, const std::vector<char>& lst) {\n    long count = 0;\n    for (char item : tup) {\n        for (char elem : lst) {\n            if (item == elem) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong count_Occurrence(const std::vector<char>& tup, const std::vector<char>& lst) {\n    long count = 0;\n    for (char item : tup) {\n        for (char elem : lst) {\n            if (item == elem) {\n                count++;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong count_Occurrence(const std::vector<char>& tup, const std::vector<char>& lst) {\n    long count = 0;\n    for (char item : tup) {\n        for (char elem : lst) {\n            if (item == elem) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong count_Occurrence(const std::vector<char>& tup, const std::vector<char>& lst) {\n    long count = 0;\n    for (char item : tup) {\n        for (char elem : lst) {\n            if (item == elem) {\n                count++;\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nlong count_characters(const std::string& str) {\n    std::unordered_map<char, int> char_count;\n    for (char ch : str) {\n        char_count[ch]++;\n    }\n    return char_count.size();\n}\n\n', 'more_universe_var_type')]}"
436,"#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
vector<int> cube_nums(const vector<int>& nums) {
    vector<int> cube_nums;
    for (int num : nums) {
//begin to write code
",203,"
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

vector<int> cube_nums(const vector<int>& nums) {
    vector<int> cube_nums;
    for (int num : nums) {
        cube_nums.push_back(num * num * num);
    }
    return cube_nums;
}


","
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

vector<int> cube_nums(const vector<int>& nums) {
    vector<int> cube_nums;
    for (int num : nums) {
        cube_nums.push_back(num * num * num);
    }
    return cube_nums;
}

","#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
vector<int> cube_nums(const vector<int>& nums) {
    vector<long> cube_nums;
    for (int num : nums) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

vector<int> cube_nums(const vector<int>& nums) {
    vector<long> cube_nums;
    for (int num : nums) {
        cube_nums.push_back(num * num * num);
    }
    return cube_nums;
}


","
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

vector<long> cube_nums(const vector<int>& nums) {
    vector<long> cube_nums;
    for (int num : nums) {
        cube_nums.push_back(num * num * num);
    }
    return cube_nums;
}

",1,3,0.5315254767735799,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<int> cube_nums(const vector<int>& nums) {\n    vector<long> cube_nums;\n    for (int num : nums) {\n        cube_nums.push_back(num * num * num);\n    }\n    return cube_nums;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nvector<int> cube_nums(const vector<int>& nums) {\n    vector<long> cube_nums;\n    for (int num : nums) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nvector<long> cube_nums(const vector<int>& nums) {\n    vector<long> cube_nums;\n    for (int num : nums) {\n        cube_nums.push_back(num * num * num);\n    }\n    return cube_nums;\n}\n\n', 'more_universe_var_type')]}"
437,"#include <iostream>
#include <cassert>
int cal_sum(int n) {
    int a = 3;
    int b = 0;
    int c = 2;
    if (n == 0) {
        return 3;
    }
    if (n == 1) {
        return 3;
    }
    if (n == 2) {
        return 5;
//begin to write code
",247,"
#include <iostream>
#include <cassert>

int cal_sum(int n) {
    int a = 3;
    int b = 0;
    int c = 2;
    if (n == 0) {
        return 3;
    }
    if (n == 1) {
        return 3;
    }
    if (n == 2) {
        return 5;
    }
    int sum = 5;
    while (n > 2) {
        int d = a + b;
        sum += d;
        a = b;
        b = c;
        c = d;
        n--;
    }
    return sum;
}


","
#include <iostream>
#include <cassert>

int cal_sum(int n) {
    int a = 3;
    int b = 0;
    int c = 2;
    if (n == 0) {
        return 3;
    }
    if (n == 1) {
        return 3;
    }
    if (n == 2) {
        return 5;
    }

    // Calculate the sum using the formula for the sum of Perrin numbers
    int sum = a + b + c;
    return sum;
}

",,,,-2,1,0.2403058369954427,code_expression_exchange:None,0.0,0.0,
438,"#include<cassert>
#include <iostream>
using namespace std;
string check_Triangle(int x1, int y1, int x2, int y2, int x3, int y3) {
    int a = (x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));
    if (a == 0) {
        return ""No"";
//begin to write code
",240,"#include<cassert>
#include <iostream>
using namespace std;

string check_Triangle(int x1, int y1, int x2, int y2, int x3, int y3) {
    int a = (x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));
    if (a == 0) {
        return ""No"";
    } else {
        return ""Yes"";
    }
}


","
#include <cmath>
#include <iostream>
using namespace std;

string check_Triangle(int x1, int y1, int x2, int y2, int x3, int y3) {
    int a = (x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));
    if (a == 0) {
        return ""No"";
    }
    double side1 = sqrt(x1*x1 + y1*y1);
    double side2 = sqrt(x2*x2 + y2*y2);
    double side3 = sqrt(x3*x3 + y3*y3);
    
    if (side1 + side2 <= side3 || side1 + side3 <= side2 || side2 + side3 <= side1) {
        return ""No"";
    }
    
    return ""Yes"";
}

",,,,-2,1,0.268441112836202,code_expression_exchange:None,0.0,0.0,
439,"#include <iostream>
#include <vector>
#include <string>
#include <cassert>
std::vector<std::string> extract_string(std::vector<std::string> vec, int l) {
    std::vector<std::string> result;
    for (auto& str : vec) {
        if (str.length() == l) {
//begin to write code
",274,"
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

std::vector<std::string> extract_string(std::vector<std::string> vec, int l) {
    std::vector<std::string> result;
    for (auto& str : vec) {
        if (str.length() == l) {
            result.push_back(str);
        }
    }
    return result;
}


","
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

std::vector<std::string> extract_string(std::vector<std::string> vec, int l) {
    std::vector<std::string> result;
    for (int i = 0; i < vec.size(); ++i) {
        if (vec[i].length() == l) {
            result.push_back(vec[i]);
        }
    }
    return result;
}

","#include <iostream>
#include <vector>
#include <string>
#include <cassert>
std::vector<std::string> extract_string(std::vector<std::string> vec, long l) {
    std::vector<std::string> result;
    for (auto& str : vec) {
        if (l == str.length()) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

std::vector<std::string> extract_string(std::vector<std::string> vec, long l) {
    std::vector<std::string> result;
    for (auto& str : vec) {
        if (l == str.length()) {
            result.push_back(str);
        }
    }
    return result;
}


","---




",1,5,0.7437875469525655,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nstd::vector<std::string> extract_string(std::vector<std::string> vec, long l) {\n    std::vector<std::string> result;\n    for (auto& str : vec) {\n        if (l == str.length()) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nstd::vector<std::string> extract_string(std::vector<std::string> vec, long l) {\n    std::vector<std::string> result;\n    for (auto& str : vec) {\n        if (str.length() == l) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nstd::vector<std::string> extract_string(std::vector<std::string> vec, long l) {\n    std::vector<std::string> result;\n    for (auto& str : vec) {\n        if (str.length() == l) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\nstd::vector<std::string> extract_string(std::vector<std::string> vec, long l) {\n    std::vector<std::string> result;\n    for (auto& str : vec) {\n        if (l == str.length()) {\n//begin to write code\n', '---\n\n\n\n\n', 'exchange_operators')]}"
440,"#include <iostream>
#include <regex>
#include <cassert>
using namespace std;
string remove_whitespaces(string text1) {
    regex pattern(""\\s+"");
//begin to write code
",168,"
#include <iostream>
#include <regex>
#include <cassert>
using namespace std;

string remove_whitespaces(string text1) {
    regex pattern(""\\s+"");
    return regex_replace(text1, pattern, """");
}


","
#include <iostream>
#include <regex>
#include <cassert>
using namespace std;
string remove_whitespaces(string text1) {
    regex pattern(""\\s+"");
    return text1.erase(std::remove_if(text1.begin(), text1.end(), [](unsigned char c) { return isspace(c); }), text1.end());
}
",,,,-2,1,0.2260040322939555,code_expression_exchange:None,0.0,0.0,
441,"#include <iostream>
#include <cassert>
int loss_amount(int actual_cost, int sale_amount) {
    if(sale_amount > actual_cost) {
        return sale_amount - actual_cost;
//begin to write code
",191,"
#include <iostream>
#include <cassert>

int loss_amount(int actual_cost, int sale_amount) {
    if(sale_amount > actual_cost) {
        return sale_amount - actual_cost;
    } else {
        return -1; // use -1 to represent None
    }
}


","
using namespace std;

#include <iostream>
#include <cassert>

int loss_amount(int actual_cost, int sale_amount) {
    if(sale_amount > actual_cost) {
        return sale_amount - actual_cost;
    } else {
        return 0;
    }
}

",,,,-2,1,0.19095655679702758,code_expression_exchange:None,0.0,0.0,
442,"#include <iostream>
#include <cmath>
#include <cassert>
int sumofFactors(int n) {
    if (n % 2 != 0) {
        return 0;
    }
    int res = 1;
    for (int i = 2; i <= static_cast<int>(std::sqrt(n)) + 1; ++i) {
        int count = 0;
        int curr_sum = 1;
        int curr_term = 1;
        while (n % i == 0) {
            count++;
            n = n / i;
//begin to write code
",384,"
#include <iostream>
#include <cmath>
#include <cassert>

int sumofFactors(int n) {
    if (n % 2 != 0) {
        return 0;
    }
    int res = 1;
    for (int i = 2; i <= static_cast<int>(std::sqrt(n)) + 1; ++i) {
        int count = 0;
        int curr_sum = 1;
        int curr_term = 1;
        while (n % i == 0) {
            count++;
            n = n / i;
            if (i == 2 && count == 1) {
                curr_sum = 0;
            }
            curr_term = curr_term * i;
            curr_sum = curr_sum + curr_term;
        }
        res = res * curr_sum;
    }
    if (n >= 2) {
        res = res * (1 + n);
    }
    return res;
}


","
#include <iostream>
#include <cmath>
#include <cassert>

int sumofFactors(int n) {
    if (n % 2!= 0) {
        return 0;
    }
    int res = 1;
    for (int i = 2; i <= static_cast<int>(std::sqrt(n)) + 1; ++i) {
        int count = 0;
        int curr_sum = 1;
        int curr_term = 1;
        while (n % i == 0) {
            count++;
            n = n / i;
            curr_sum += curr_term;
            curr_term *= i;
        }
        if (count % 2 == 1) {
            curr_sum += curr_term;
        }
        res += curr_sum;
    }
    return res;
}

",,,,-2,1,0.24409202337265015,code_expression_exchange:None,0.0,0.0,
443,"#include <iostream>
#include <regex>
#include <cassert>
using namespace std;
string text_match_wordz(string text){
    regex pattern(""\\w*z.\\w*"");
    if (regex_search(text, pattern)) {
        return ""Found a match!"";
//begin to write code
",242,"
#include <iostream>
#include <regex>
#include <cassert>

using namespace std;

string text_match_wordz(string text){
    regex pattern(""\\w*z.\\w*"");
    if (regex_search(text, pattern)) {
        return ""Found a match!"";
    } else {
        return ""Not matched!"";
    }
}


","
#include <iostream>
#include <regex>
#include <cassert>
using namespace std;

string text_match_wordz(string text) {
    regex pattern(""\\w*z.\\w*"");
    if (regex_search(text, pattern)) {
        return ""Found a match!"";
    }
    return ""No match found."";
}

",,,,-2,1,0.2366856296857198,code_expression_exchange:None,0.0,0.0,
444,"#include <iostream>
#include <cassert>
bool check_monthnumb_number(int monthnum2) {
    if (monthnum2 == 1 || monthnum2 == 3 || monthnum2 == 5 || monthnum2 == 7 || monthnum2 == 8 || monthnum2 == 10 || monthnum2 == 12) {
        return true;
//begin to write code
",263,"
#include <iostream>
#include <cassert>

bool check_monthnumb_number(int monthnum2) {
    if (monthnum2 == 1 || monthnum2 == 3 || monthnum2 == 5 || monthnum2 == 7 || monthnum2 == 8 || monthnum2 == 10 || monthnum2 == 12) {
        return true;
    } else {
        return false;
    }
}


","
using namespace std;
#include <iostream>
#include <cassert>

bool check_monthnumb_number(int monthnum2) {
    // Check if the month number is between 1 and 12
    if (monthnum2 < 1 || monthnum2 > 12) {
        return false;
    }
    // Check if the month has 31 days
    return (monthnum2 == 1 || monthnum2 == 3 || monthnum2 == 5 || monthnum2 == 7 || monthnum2 == 8 || monthnum2 == 10 || monthnum2 == 12);
}

","#include <iostream>
#include <cassert>
bool check_monthnumb_number(long monthnum2) {
    if (1 == monthnum2 || 3 == monthnum2 || 5 == monthnum2 || 7 == monthnum2 || 8 == monthnum2 || 10 == monthnum2 || 12 == monthnum2) {
        return true;
//begin to write code
","
#include <iostream>
#include <cassert>

bool check_monthnumb_number(long monthnum2) {
    if (1 == monthnum2 || 3 == monthnum2 || 5 == monthnum2 || 7 == monthnum2 || 8 == monthnum2 || 10 == monthnum2 || 12 == monthnum2) {
        return true;
    } else {
        return false;
    }
}


","I apologize, but I'm not able to assist with that request.",1,5,0.9026978929837545,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nbool check_monthnumb_number(long monthnum2) {\n    if (1 == monthnum2 || 3 == monthnum2 || 5 == monthnum2 || 7 == monthnum2 || 8 == monthnum2 || 10 == monthnum2 || 12 == monthnum2) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nbool check_monthnumb_number(int monthnum2) {\n    if (1 == monthnum2 || 3 == monthnum2 || 5 == monthnum2 || 7 == monthnum2 || 8 == monthnum2 || 10 == monthnum2 || 12 == monthnum2) {\n        return true;\n//begin to write code\n', '#include <iostream>\n#include <cassert>\nbool check_monthnumb_number(int monthnum2) {\n    if (1 == monthnum2 || 3 == monthnum2 || 5 == monthnum2 || 7 == monthnum2 || 8 == monthnum2 || 10 == monthnum2 || 12 == monthnum2) {\n        return true;\n    }\n    return false;\n}\n', 'exchange_operators'), ('#include <iostream>\n#include <cassert>\nbool check_monthnumb_number(long monthnum2) {\n    if (1 == monthnum2 || 3 == monthnum2 || 5 == monthnum2 || 7 == monthnum2 || 8 == monthnum2 || 10 == monthnum2 || 12 == monthnum2) {\n        return true;\n//begin to write code\n', ""I apologize, but I'm not able to assist with that request."", 'more_universe_var_type')]}"
445,"#include<iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;
vector<string> reverse_string_list(vector<string> stringlist) {
    for (string& s : stringlist) {
        reverse(s.begin(), s.end());
//begin to write code
",274,"#include<iostream>
    

#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;

vector<string> reverse_string_list(vector<string> stringlist) {
    for (string& s : stringlist) {
        reverse(s.begin(), s.end());
    }
    return stringlist;
}


","
#include<iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;

vector<string> reverse_string_list(vector<string> stringlist) {
    for (string& s : stringlist) {
        reverse(s.begin(), s.end());
    }
    return stringlist;
}

","#include<iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;
vector<string> reverse_string_list(vector<string> stringlist) {
    for (string& s : stringlist) {
        reverse(s.begin(), s.end());
//begin to write code
","#include<iostream>
    

#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;

vector<string> reverse_string_list(vector<string> stringlist) {
    for (string& s : stringlist) {
        reverse(s.begin(), s.end());
    }
    return stringlist;
}


","#include<iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>
using namespace std;

vector<string> reverse_string_list(vector<string> stringlist) {
    vector<string> reversed_list;
    for (string& s : stringlist) {
        reversed_list.push_back(s);
    }
    reverse(reversed_list.begin(), reversed_list.end());
    return reversed_list;
}
",1,5,0.6895831147829692,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<iostream>\n    \n\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<string> reverse_string_list(vector<string> stringlist) {\n    for (string& s : stringlist) {\n        reverse(s.begin(), s.end());\n    }\n    return stringlist;\n}\n\n\n': [('#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nvector<string> reverse_string_list(vector<string> stringlist) {\n    for (string& s : stringlist) {\n        reverse(s.begin(), s.end());\n//begin to write code\n', '\n#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nvector<string> reverse_string_list(vector<string> stringlist) {\n    for (string& s : stringlist) {\n        reverse(s.begin(), s.end());\n    }\n    return stringlist;\n}\n\n', 'bool2int'), ('#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nvector<string> reverse_string_list(vector<string> stringlist) {\n    for (string& s : stringlist) {\n        reverse(s.begin(), s.end());\n//begin to write code\n', '#include<iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nvector<string> reverse_string_list(vector<string> stringlist) {\n    vector<string> reversed_list;\n    for (string& s : stringlist) {\n        reversed_list.push_back(s);\n    }\n    reverse(reversed_list.begin(), reversed_list.end());\n    return reversed_list;\n}\n', 'more_universe_var_type')]}"
446,"#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
template <typename T>
std::vector<T> Find_Min(const std::vector<std::vector<T>>& lst) {
//begin to write code
",188,"
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

template <typename T>
std::vector<T> Find_Min(const std::vector<std::vector<T>>& lst) {
    return *std::min_element(lst.begin(), lst.end());
}


","using namespace std;
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

template <typename T>
std::vector<T> Find_Min(const std::vector<std::vector<T>>& lst) {
    if (lst.empty()) {
        return {};
    }

    int min_length = lst[0].size();
    std::vector<T> result;

    for (const auto& sub_list : lst) {
        if (sub_list.size() < min_length) {
            min_length = sub_list.size();
            result = sub_list;
        }
    }

    return result;
}
",,,,-2,1,0.19451870520909628,code_expression_exchange:None,0.0,0.0,
447,"#include<iostream>
#include <cassert>
//
int rectangle_area(int l, int b) {
//begin to write code
",102,"#include<iostream>
    

#include <cassert>

//
int rectangle_area(int l, int b) {
    int area = l * b;
    return area;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

#include<assert.h>

// Function to calculate the area of a rectangle
int rectangle_area(int l, int b) {
    return l * b;
}

","#include<iostream>
#include <cassert>
//
long rectangle_area(long l, long b) {
//begin to write code
","#include<iostream>
    

#include <cassert>

//
long rectangle_area(long l, long b) {
    long area = l * b;
    return area;
}


","using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>

long rectangle_area(long l, long b) {
    return l * b;
}
",1,9,1.206511676311493,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<iostream>\n    \n\n#include <cassert>\n\n//\nlong rectangle_area(long l, long b) {\n    long area = l * b;\n    return area;\n}\n\n\n': [('#include<iostream>\n#include <cassert>\n//\nint rectangle_area(int l, long b) {\n//begin to write code\n', '\n#include<iostream>\n#include <cassert>\n//\nint rectangle_area(int l, long b) {\n    return l * b;\n}\n\n', 'more_universe_var_type'), ('#include<iostream>\n#include <cassert>\n//\nint rectangle_area(int l, long b) {\n//begin to write code\n', '\n#include<iostream>\n#include <cassert>\nusing namespace std;\n\n// Function to calculate the area of a rectangle\nint rectangle_area(int l, long b) {\n    return l * b;\n}\n\n// Test function to verify the correctness of the rectangle_area function\nvoid test_rectangle_area() {\n    assert(rectangle_area(5, 10) == 50);\n    assert(rectangle_area(7, 3) == 21);\n    assert(rectangle_area(0, 5) == 0);\n    assert(rectangle_area(2, -1) == -2);\n    cout << ""All test cases passed successfully."" << endl;\n}\n\n', 'more_universe_var_type'), ('#include<iostream>\n#include <cassert>\n//\nlong rectangle_area(int l, long b) {\n//begin to write code\n', '\n#include<iostream>\n#include <cassert>\nusing namespace std;\n\n// Function definition\nlong rectangle_area(int l, long b) {\n    return l * b;\n}\n\n', 'more_universe_var_type'), ('#include<iostream>\n#include <cassert>\n//\nlong rectangle_area(long l, long b) {\n//begin to write code\n', 'using namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<iostream>\n\nlong rectangle_area(long l, long b) {\n    return l * b;\n}\n', 'more_universe_var_type')]}"
448,"#include <iostream>
#include <string>
#include <regex>
#include <cassert>
using namespace std;
string remove_uppercase(string str1) {
    regex upper(""[A-Z]"");
//begin to write code
",182,"
#include <iostream>
#include <string>
#include <regex>
#include <cassert>

using namespace std;

string remove_uppercase(string str1) {
    regex upper(""[A-Z]"");
    return regex_replace(str1, upper, """");
}


","
#include <iostream>
#include <string>
#include <regex>
#include <cassert>
using namespace std;

string remove_uppercase(string str1) {
    return regex_replace(str1, ""[A-Z]"", """");
}

",,,,-2,1,0.20532716115315755,code_expression_exchange:None,0.0,0.0,
449,"#include<iostream>
#include <vector>
#include <cassert>
std::vector<int> Extract(const std::vector<std::vector<int>>& lst) {
    std::vector<int> result;
    for (auto& item : lst) {
//begin to write code
",205,"#include<iostream>
    

#include <vector>
#include <cassert>

std::vector<int> Extract(const std::vector<std::vector<int>>& lst) {
    std::vector<int> result;
    for (auto& item : lst) {
        result.push_back(item[0]);
    }
    return result;
}


","
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> Extract(const std::vector<std::vector<int>>& lst) {
    std::vector<int> result;
    for (const auto& item : lst) {
        result.push_back(item[0]);
    }
    return result;
}

","#include<iostream>
#include <vector>
#include <cassert>
std::vector<int> Extract(const std::vector<std::vector<int>>& lst) {
    std::vector<long> result;
    for (auto& item : lst) {
//begin to write code
","#include<iostream>
    

#include <vector>
#include <cassert>

std::vector<int> Extract(const std::vector<std::vector<int>>& lst) {
    std::vector<long> result;
    for (auto& item : lst) {
        result.push_back(item[0]);
    }
    return result;
}


","
using namespace std;

#include<iostream>
#include <vector>
#include <cassert>

std::vector<int> Extract(const std::vector<std::vector<int>>& lst) {
    std::vector<long> result;
    for (auto& item : lst) {
        if (!item.empty()) {
            result.push_back(static_cast<int>(item[0]));
        }
    }
    return result;
}

",1,5,0.7279174566268921,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<iostream>\n    \n\n#include <vector>\n#include <cassert>\n\nstd::vector<int> Extract(const std::vector<std::vector<int>>& lst) {\n    std::vector<long> result;\n    for (auto& item : lst) {\n        result.push_back(item[0]);\n    }\n    return result;\n}\n\n\n': [('#include<iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> Extract(const std::vector<std::vector<int>>& lst) {\n    std::vector<int> result;\n    for (auto& item : lst) {\n//begin to write code\n', '#include<iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> Extract(const std::vector<std::vector<int>>& lst) {\n    std::vector<int> result;\n    for (const auto& sublist : lst) {\n        result.push_back(sublist.front());\n    }\n    return result;\n}\n', 'equal_expression_transformation'), ('#include<iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> Extract(const std::vector<std::vector<int>>& lst) {\n    std::vector<long> result;\n    for (auto& item : lst) {\n//begin to write code\n', '\nusing namespace std;\n\n#include<iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> Extract(const std::vector<std::vector<int>>& lst) {\n    std::vector<long> result;\n    for (auto& item : lst) {\n        if (!item.empty()) {\n            result.push_back(static_cast<int>(item[0]));\n        }\n    }\n    return result;\n}\n\n', 'more_universe_var_type')]}"
450,"#include<iostream>
#include <string>
#include <cassert>
using namespace std;
int upper_ctr(string str) {
    int upper_ctr = 0;
    for (int i = 0; i < str.length(); i++) {
//begin to write code
",195,"#include<iostream>
    

#include <string>
#include <cassert>
using namespace std;

int upper_ctr(string str) {
    int upper_ctr = 0;
    for (int i = 0; i < str.length(); i++) {
        if (str[i] >= 'A' && str[i] <= 'Z') upper_ctr += 1;
    }
    return upper_ctr;
}


","using namespace std;

int upper_ctr(string str) {
    int upper_ctr = 0;
    for (int i = 0; i < str.length(); i++) {
        if (str[i] >= 'A' && str[i] <= 'Z') {
            upper_ctr++;
        }
    }
    return upper_ctr;
}
",,,,-2,1,0.17786518335342408,code_expression_exchange:None,0.0,0.0,
451,"#include<iostream>
#include <vector>
#include <string>
#include <cassert>
using namespace std;
vector<vector<string>> combinations_list(vector<string> list1) {
    if (list1.empty()) {
        return {{}};
    }
    vector<vector<string>> result;
    vector<string> rest(list1.begin() + 1, list1.end());
//begin to write code
",326,"#include<iostream>
    

#include <vector>
#include <string>
#include <cassert>

using namespace std;

vector<vector<string>> combinations_list(vector<string> list1) {
    if (list1.empty()) {
        return {{}};
    }
    vector<vector<string>> result;
    vector<string> rest(list1.begin() + 1, list1.end());
    for (auto &el : combinations_list(rest)) {
        result.push_back(el);
        el.push_back(list1[0]);
        result.push_back(el);
    }
    return result;
}


","
#include<iostream>
#include <vector>
#include <string>
#include <cassert>
using namespace std;

vector<vector<string>> combinations_list(vector<string> list1) {
    if (list1.empty()) {
        return {{}};
    }
    vector<vector<string>> result;
    vector<string> rest(list1.begin() + 1, list1.end());
    // Your code here
    for (int i = 0; i < rest.size(); ++i) {
        for (int j = 0; j < result.size(); ++j) {
            result.push_back({rest[i]} + result[j]);
        }
    }
    return result;
}

",,,,-2,1,0.27254052956899005,code_expression_exchange:None,0.0,0.0,
452,"#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;
int max_subarray_product(vector<int> arr) {
    int n = arr.size();
    int max_ending_here = 1;
    int min_ending_here = 1;
    int max_so_far = 0;
    bool flag = false;
    for (int i = 0; i < n; i++) {
        if (arr[i] > 0) {
            max_ending_here = max_ending_here * arr[i];
            min_ending_here = min(min_ending_here * arr[i], 1);
            flag = true;
        } else if (arr[i] == 0) {
            max_ending_here = 1;
            min_ending_here = 1;
//begin to write code
",598,"#include<iostream>
    

#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

int max_subarray_product(vector<int> arr) {
    int n = arr.size();
    int max_ending_here = 1;
    int min_ending_here = 1;
    int max_so_far = 0;
    bool flag = false;
    
    for (int i = 0; i < n; i++) {
        if (arr[i] > 0) {
            max_ending_here = max_ending_here * arr[i];
            min_ending_here = min(min_ending_here * arr[i], 1);
            flag = true;
        } else if (arr[i] == 0) {
            max_ending_here = 1;
            min_ending_here = 1;
        } else {
            int temp = max_ending_here;
            max_ending_here = max(min_ending_here * arr[i], 1);
            min_ending_here = temp * arr[i];
        }
        if (max_so_far < max_ending_here) {
            max_so_far = max_ending_here;
        }
    }
    
    if (!flag && max_so_far == 0) {
        return 0;
    }
    return max_so_far;
}


","
#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

int max_subarray_product(vector<int> arr) {
    int n = arr.size();
    int max_ending_here = 1;
    int min_ending_here = 1;
    int max_so_far = 0;
    bool flag = false;
    
    for (int i = 0; i < n; i++) {
        if (arr[i] > 0) {
            max_ending_here = max(max_ending_here * arr[i], arr[i]);
            min_ending_here = min(min_ending_here * arr[i], 1);
            flag = true;
        } else if (arr[i] == 0) {
            max_ending_here = 1;
            min_ending_here = 1;
            max_so_far = max(max_so_far, max_ending_here);
        } else {
            // If the current element is negative, swap max_ending_here and min_ending_here
            int temp = max_ending_here;
            max_ending_here = min_ending_here;
            min_ending_here = temp;
            // Update max_so_far if necessary
           ",,,,-2,1,0.27983620166778567,code_expression_exchange:None,0.0,0.0,
453,"#include<cassert>
#include <iostream>
#include <map>
#include <string>
bool check_value(std::map<std::string, int> dict, int n) {
    for (const auto& kv : dict) {
        if (kv.second != n) {
            return false;
//begin to write code
",242,"#include<cassert>
#include <iostream>
#include <map>
#include <string>

bool check_value(std::map<std::string, int> dict, int n) {
    for (const auto& kv : dict) {
        if (kv.second != n) {
            return false;
        }
    }
    return true;
}


","#include <cassert>
#include <iostream>
#include <map>
#include <string>

bool check_value(std::map<std::string, int> dict, int n) {
    for (const auto& kv : dict) {
        if (kv.second!= n) {
            return false;
        }
    }
    return true;
}
","#include<cassert>
#include <iostream>
#include <map>
#include <string>
bool check_value(std::map<std::string, int> dict, long n) {
    for (const auto& kv : dict) {
        if (kv.second != n) {
            return false;
//begin to write code
","#include<cassert>
#include <iostream>
#include <map>
#include <string>

bool check_value(std::map<std::string, int> dict, long n) {
    for (const auto& kv : dict) {
        if (kv.second != n) {
            return false;
        }
    }
    return true;
}


","#include<cassert>
#include <iostream>
#include <map>
#include <vector>
bool check_values(const std::vector<int>& numbers, int n) {
    for (int num : numbers) {
        if (num!= n) {
            return false;
        }
    }
    return true;
}
",1,3,0.4090026537577311,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'#include<cassert>\n#include <iostream>\n#include <map>\n#include <string>\n\nbool check_value(std::map<std::string, int> dict, long n) {\n    for (const auto& kv : dict) {\n        if (kv.second != n) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n': [('#include<cassert>\n#include <iostream>\n#include <map>\n#include <string>\nbool check_value(std::map<std::string, int> dict, long n) {\n    for (const auto& kv : dict) {\n        if (kv.second != n) {\n            return false;\n//begin to write code\n', '#include<cassert>\n#include <iostream>\n#include <map>\n#include <vector>\nbool check_values(const std::vector<int>& numbers, int n) {\n    for (int num : numbers) {\n        if (num!= n) {\n            return false;\n        }\n    }\n    return true;\n}\n', 'more_universe_var_type')]}"
454,"#include <iostream>
#include <map>
#include <cassert>
std::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {
    std::map<std::string, std::string> filtered;
    for(auto const& element : dict1) {
        if(element.second != """") {
//begin to write code
",289,"
#include <iostream>
#include <map>
#include <cassert>

std::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {
    std::map<std::string, std::string> filtered;
    for(auto const& element : dict1) {
        if(element.second != """") {
            filtered[element.first] = element.second;
        }
    }
    return filtered;
}


","
using namespace std;
#include <iostream>
#include <map>
#include <cassert>

std::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {
    std::map<std::string, std::string> filtered;
    for(auto const& element : dict1) {
        if(element.second!= """") {
            filtered[element.first] = element.second;
        }
    }
    return filtered;
}

","#include <iostream>
#include <map>
#include <cassert>
std::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {
    std::map<std::string, std::string> filtered;
    for(auto const& element : dict1) {
        if(element.second != """") {
//begin to write code
","
#include <iostream>
#include <map>
#include <cassert>

std::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {
    std::map<std::string, std::string> filtered;
    for(auto const& element : dict1) {
        if(element.second != """") {
            filtered[element.first] = element.second;
        }
    }
    return filtered;
}


","#include <iostream>
#include <vector>
#include <unordered_set>
#include <cassert>
std::vector<std::string> remove_duplicates(const std::vector<std::string>& input_list) {
    std::unordered_set<std::string> seen;
    std::vector<std::string> result;
    for(const auto& item : input_list) {
        if(seen.find(item) == seen.end()) {
            seen.insert(item);
            result.push_back(item);
        }
    }
    return result;
}
",1,19,2.773272434870402,code_expression_exchange:exchange_operators,1.0,0.0,"{'\n#include <iostream>\n#include <map>\n#include <cassert>\n\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(element.second != """") {\n            filtered[element.first] = element.second;\n        }\n    }\n    return filtered;\n}\n\n\n': [('#include <iostream>\n#include <map>\n#include <cassert>\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(element.second != """") {\n//begin to write code\n', '\n#include <iostream>\n#include <map>\n#include <cassert>\n\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(!element.second.empty()) {\n            filtered[element.first] = element.second;\n        }\n    }\n    return filtered;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <map>\n#include <cassert>\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(element.second != """") {\n//begin to write code\n', '\n#include <iostream>\n#include <map>\n#include <cassert>\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(element.second!= """") {\n            filtered[element.first] = element.second;\n        }\n    }\n    return filtered;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <map>\n#include <cassert>\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(element.second != """") {\n//begin to write code\n', '\n#include <iostream>\n#include <map>\n#include <cassert>\n\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(element.second!= """") {\n            filtered[element.first] = element.second;\n        }\n    }\n    return filtered;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <map>\n#include <cassert>\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(element.second != """") {\n//begin to write code\n', '#include <iostream>\n#include <map>\n#include <cassert>\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(element.second!= """") {\n            filtered[element.first] = element.second;\n        }\n    }\n    return filtered;\n}\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <map>\n#include <cassert>\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(element.second != """") {\n//begin to write code\n', '\n#include <iostream>\n#include <map>\n#include <cassert>\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(!element.second.empty()) {\n            filtered[element.first] = element.second;\n        }\n    }\n    return filtered;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <map>\n#include <cassert>\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(element.second != """") {\n//begin to write code\n', '\n#include <iostream>\n#include <map>\n#include <cassert>\n\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(!element.second.empty()) {\n            filtered[element.first] = element.second;\n        }\n    }\n    return filtered;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <map>\n#include <cassert>\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(element.second != """") {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <map>\n#include <cassert>\n\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(element.second!= """") {\n            filtered[element.first] = element.second;\n        }\n    }\n    return filtered;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <map>\n#include <cassert>\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if("""" != element.second) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <map>\n#include <cassert>\n\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(!element.second.empty()) {\n            filtered[element.first] = element.second;\n        }\n    }\n    return filtered;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <map>\n#include <cassert>\nstd::map<std::string, std::string> drop_empty(std::map<std::string, std::string> dict1) {\n    std::map<std::string, std::string> filtered;\n    for(auto const& element : dict1) {\n        if(element.second != """") {\n//begin to write code\n', '#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <cassert>\nstd::vector<std::string> remove_duplicates(const std::vector<std::string>& input_list) {\n    std::unordered_set<std::string> seen;\n    std::vector<std::string> result;\n    for(const auto& item : input_list) {\n        if(seen.find(item) == seen.end()) {\n            seen.insert(item);\n            result.push_back(item);\n        }\n    }\n    return result;\n}\n', 'exchange_operators')]}"
455,"#include <iostream>
#include <vector>
#include <cassert>
int find_peak_util(const std::vector<int>& arr, int low, int high, int n) {
    int mid = low + (high - low) / 2;
    if ((mid == 0 || arr[mid - 1] <= arr[mid]) &&
        (mid == n - 1 || arr[mid + 1] <= arr[mid])) {
        return mid;
    } else if (mid > 0 && arr[mid - 1] > arr[mid]) {
        return find_peak_util(arr, low, mid - 1, n);
//begin to write code
",423,"
#include <iostream>
#include <vector>
#include <cassert>

int find_peak_util(const std::vector<int>& arr, int low, int high, int n) {
    int mid = low + (high - low) / 2;
    if ((mid == 0 || arr[mid - 1] <= arr[mid]) &&
        (mid == n - 1 || arr[mid + 1] <= arr[mid])) {
        return mid;
    } else if (mid > 0 && arr[mid - 1] > arr[mid]) {
        return find_peak_util(arr, low, mid - 1, n);
    } else {
        return find_peak_util(arr, mid + 1, high, n);
    }
}

int find_peak(const std::vector<int>& arr, int n) {
    return find_peak_util(arr, 0, n - 1, n);
}


","using namespace std;
#include <vector>
#include <cassert>

int find_peak_util(const std::vector<int>& arr, int low, int high, int n) {
    int mid = low + (high - low) / 2;
    if ((mid == 0 || arr[mid - 1] <= arr[mid]) &&
        (mid == n - 1 || arr[mid + 1] <= arr[mid])) {
        return mid;
    } else if (mid > 0 && arr[mid - 1] > arr[mid]) {
        return find_peak_util(arr, low, mid - 1, n);
    } else {
        return find_peak_util(arr, mid + 1, high, n);
    }
}

int find_peak(std::vector<int>& arr) {
    return find_peak_util(arr, 0, arr.size() - 1, arr.size());
}
",,,,-2,1,0.21403863827387493,code_expression_exchange:None,0.0,0.0,
456,"#include <iostream>
#include <cassert>
int decimal_to_Octal(int deciNum) {
    int octalNum = 0;
    int countval = 1;
    int remainder;
    while (deciNum != 0) {
        remainder = deciNum % 8;
//begin to write code
",220,"
#include <iostream>
#include <cassert>

int decimal_to_Octal(int deciNum) {
    int octalNum = 0;
    int countval = 1;
    int remainder;

    while (deciNum != 0) {
        remainder = deciNum % 8;
        octalNum += remainder * countval;
        countval *= 10;
        deciNum /= 8;
    }

    return octalNum;
}


","
#include <iostream>
#include <cassert>

int decimal_to_Octal(int deciNum) {
    int octalNum = 0;
    int countval = 1;
    int remainder;
    while (deciNum!= 0) {
        remainder = deciNum % 8;
        octalNum += remainder * countval;
        countval *= 8;
    }
    return octalNum;
}

",,,,-2,1,1.236668340365092,code_expression_exchange:None,0.0,0.0,
457,"#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;
int max_product(vector<int> arr, int n) {
    vector<int> mpis(n, 0);
    for (int i = 0; i < n; ++i) {
        mpis[i] = arr[i];
    }
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
//begin to write code
",328,"#include<iostream>
    

#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

int max_product(vector<int> arr, int n) {
    vector<int> mpis(n, 0);
    for (int i = 0; i < n; ++i) {
        mpis[i] = arr[i];
    }
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (arr[i] > arr[j] && mpis[i] < mpis[j] * arr[i]) {
                mpis[i] = mpis[j] * arr[i];
            }
        }
    }
    return *max_element(mpis.begin(), mpis.end());
}


","
#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

int max_product(vector<int> arr, int n) {
    vector<int> mpis(n, 0);
    for (int i = 0; i < n; ++i) {
        mpis[i] = arr[i];
    }
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (arr[i] > arr[j]) {
                mpis[i] = max(mpis[i], arr[i] * mpis[j]);
            }
        }
    }
    return mpis[n - 1];
}

",,,,-2,1,0.23982675472895304,code_expression_exchange:None,0.0,0.0,
458,"#include<iostream>
#include <vector>
#include <cassert>
using namespace std;
int max_profit(vector<int> price, int k) {
    int n = price.size();
    vector<vector<int>> final_profit(k + 1, vector<int>(n, 0));
    for (int i = 0; i <= k; i++) {
        for (int j = 0; j < n; j++) {
            if (i == 0 || j == 0) {
                final_profit[i][j] = 0;
            } else {
                int max_so_far = 0;
                for (int x = 0; x < j; x++) {
//begin to write code
",484,"#include<iostream>
    

#include <vector>
#include <cassert>
using namespace std;

int max_profit(vector<int> price, int k) {
    int n = price.size();
    vector<vector<int>> final_profit(k + 1, vector<int>(n, 0));
    
    for (int i = 0; i <= k; i++) {
        for (int j = 0; j < n; j++) {
            if (i == 0 || j == 0) {
                final_profit[i][j] = 0;
            } else {
                int max_so_far = 0;
                for (int x = 0; x < j; x++) {
                    int curr_price = price[j] - price[x] + final_profit[i-1][x];
                    if (max_so_far < curr_price) {
                        max_so_far = curr_price;
                    }
                }
                final_profit[i][j] = max(final_profit[i][j-1], max_so_far);
            }
        }
    }
    return final_profit[k][n-1];
}


","


",,,,-2,1,0.13230820894241332,code_expression_exchange:None,0.0,0.0,
459,"#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> add_pairwise(const std::vector<int>& test_vec) {
    std::vector<int> res;
    for (size_t i = 0; i < test_vec.size() - 1; ++i) {
//begin to write code
",226,"
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> add_pairwise(const std::vector<int>& test_vec) {
    std::vector<int> res;
    for (size_t i = 0; i < test_vec.size() - 1; ++i) {
        res.push_back(test_vec[i] + test_vec[i + 1]);
    }
    return res;
}


","
#include <iostream>
#include <vector>
#include <cassert>
#include <algorithm>

std::vector<int> add_pairwise(const std::vector<int>& test_vec) {
    std::vector<int> res;
    for (size_t i = 0; i < test_vec.size() - 1; ++i) {
        res.push_back(test_vec[i] + test_vec[i + 1]);
    }
    return res;
}

","#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> add_pairwise(const std::vector<int>& test_vec) {
    std::vector<long> res;
    for (size_t i = 0; i < test_vec.size() - 1; ++i) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> add_pairwise(const std::vector<int>& test_vec) {
    std::vector<long> res;
    for (size_t i = 0; i < test_vec.size() - 1; ++i) {
        res.push_back(test_vec[i] + test_vec[i + 1]);
    }
    return res;
}


","
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> add_pairwise(const std::vector<int>& test_vec) {
    std::vector<long> res;
    for (size_t i = 0; i < test_vec.size() - 1; ++i) {
        long sum = test_vec[i] + test_vec[i + 1];
        res.push_back(sum);
    }
    return res;
}

",1,5,0.7755851944287618,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> add_pairwise(const std::vector<int>& test_vec) {\n    std::vector<long> res;\n    for (size_t i = 0; i < test_vec.size() - 1; ++i) {\n        res.push_back(test_vec[i] + test_vec[i + 1]);\n    }\n    return res;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> add_pairwise(const std::vector<int>& test_vec) {\n    std::vector<int> res;\n    for (size_t i = 0; i < test_vec.size() - 1; ++i) {\n//begin to write code\n', '\nusing namespace std;\n#include <vector>\n#include <cassert>\n\nstd::vector<int> add_pairwise(const std::vector<int>& test_vec) {\n    std::vector<int> res;\n    for (size_t i = 0; i < test_vec.size() - 1; ++i) {\n        res.push_back(test_vec[i] + test_vec[i + 1]);\n    }\n    return res;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> add_pairwise(const std::vector<int>& test_vec) {\n    std::vector<long> res;\n    for (size_t i = 0; i < test_vec.size() - 1; ++i) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> add_pairwise(const std::vector<int>& test_vec) {\n    std::vector<long> res;\n    for (size_t i = 0; i < test_vec.size() - 1; ++i) {\n        long sum = test_vec[i] + test_vec[i + 1];\n        res.push_back(sum);\n    }\n    return res;\n}\n\n', 'more_universe_var_type')]}"
460,"#include <iostream>
#include <vector>
#include <cassert>
int find_remainder(std::vector<int> arr, int lens, int n) {
    int mul = 1;
    for (int i = 0; i < lens; i++) {
//begin to write code
",193,"
#include <iostream>
#include <vector>
#include <cassert>

int find_remainder(std::vector<int> arr, int lens, int n) {
    int mul = 1;
    for (int i = 0; i < lens; i++) {
        mul = (mul * (arr[i] % n)) % n;
    }
    return mul % n;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

int find_remainder(std::vector<int> arr, int lens, int n) {
    int mul = 1;
    for (int i = 0; i < lens; i++) {
        mul = (mul * arr[i]) % n;
    }
    return mul;
}

","#include <iostream>
#include <vector>
#include <cassert>
long find_remainder(std::vector<long> arr, long lens, long n) {
    int mul = 1;
    for (int i = 0; i < lens; i = 1 + i) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

long find_remainder(std::vector<long> arr, long lens, long n) {
    int mul = 1;
    for (int i = 0; i < lens; i = 1 + i) {
        mul = ((arr[i] % n) * mul) % n;
    }
    return mul % n;
}


","
#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

long find_remainder(std::vector<long> arr, long lens, long n) {
    long mul = 1;
    for (int i = 0; i < lens; i = 1 + i) {
        mul *= arr[i];
    }
    return mul % n;
}

",-1,21,2.733550445238749,code_expression_exchange:bool2int,1.0,0.7422989752682083,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong find_remainder(std::vector<long> arr, long lens, long n) {\n    int mul = 1;\n    for (int i = 0; i < lens; i = 1 + i) {\n        mul = ((arr[i] % n) * mul) % n;\n    }\n    return mul % n;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nint find_remainder(std::vector<int> arr, int lens, int n) {\n    int mul = 1;\n    for (int i = 0; i < lens; i = i + 1) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_remainder(std::vector<int> arr, int lens, int n) {\n    int mul = 1;\n    for (int i = 0; i < lens; i = i + 1) {\n        mul *= arr[i];\n    }\n    return mul % n;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nint find_remainder(std::vector<long> arr, int lens, int n) {\n    int mul = 1;\n    for (int i = 0; i < lens; i = i + 1) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint find_remainder(std::vector<long> arr, int lens, int n) {\n    int mul = 1;\n    for (int i = 0; i < lens; i = i + 1) {\n        mul *= arr[i];\n    }\n    return mul % n;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong find_remainder(std::vector<long> arr, int lens, int n) {\n    int mul = 1;\n    for (int i = 0; i < lens; i = i + 1) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nlong find_remainder(std::vector<long> arr, int lens, int n) {\n    long mul = 1;\n    for (int i = 0; i < lens; i = i + 1) {\n        mul *= arr[i];\n    }\n    return mul % n;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong find_remainder(std::vector<long> arr, int lens, int n) {\n    int mul = 1;\n    for (int i = 0; i < lens; i = i + 1) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong find_remainder(std::vector<long> arr, int lens, int n) {\n    long mul = 1;\n    for (int i = 0; i < lens; i = i + 1) {\n        mul *= arr[i];\n    }\n    return mul % n;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong find_remainder(std::vector<long> arr, int lens, int n) {\n    int mul = 1;\n    for (int i = 0; i < lens; i = i + 1) {\n//begin to write code\n', 'using namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong find_remainder(std::vector<long> arr, int lens, int n) {\n    long mul = 1;\n    for (int i = 0; i < lens; i = i + 1) {\n        mul *= arr[i];\n    }\n    return mul % n;\n}\n', 'bool2int'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong find_remainder(std::vector<long> arr, int lens, int n) {\n    int mul = 1;\n    for (int i = 0; i < lens; i = 1 + i) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong find_remainder(std::vector<long> arr, int lens, int n) {\n    long result = 1;\n    for (int i = 0; i < lens; i = 1 + i) {\n        result = (result * arr[i]) % n;\n    }\n    return result;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong find_remainder(std::vector<long> arr, int lens, long n) {\n    int mul = 1;\n    for (int i = 0; i < lens; i = 1 + i) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong find_remainder(std::vector<long> arr, int lens, long n) {\n    int mul = 1;\n    for (int i = 0; i < lens; i = 1 + i) {\n        mul *= arr[i];\n    }\n    return mul % n;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong find_remainder(std::vector<long> arr, long lens, long n) {\n    int mul = 1;\n    for (int i = 0; i < lens; i = 1 + i) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong find_remainder(std::vector<long> arr, long lens, long n) {\n    long mul = 1;\n    for (int i = 0; i < lens; i = 1 + i) {\n        mul *= arr[i];\n    }\n    return mul % n;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong find_remainder(std::vector<long> arr, long lens, long n) {\n    int mul = 1;\n    for (int i = 0; i < lens; i = 1 + i) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong find_remainder(std::vector<long> arr, long lens, long n) {\n    long mul = 1;\n    for (int i = 0; i < lens; i = 1 + i) {\n        mul *= arr[i];\n    }\n    return mul % n;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nlong find_remainder(std::vector<long> arr, long lens, long n) {\n    int mul = 1;\n    for (int i = 0; i < lens; i = 1 + i) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nlong find_remainder(std::vector<long> arr, long lens, long n) {\n    long mul = 1;\n    for (int i = 0; i < lens; i = 1 + i) {\n        mul *= arr[i];\n    }\n    return mul % n;\n}\n\n', 'bool2int')]}"
461,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
bool check_Consecutive(std::vector<int> l) {
    std::sort(l.begin(), l.end());
    for (int i = 1; i < l.size(); ++i) {
        if (l[i] != l[i - 1] + 1) {
//begin to write code
",256,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>

bool check_Consecutive(std::vector<int> l) {
    std::sort(l.begin(), l.end());
    for (int i = 1; i < l.size(); ++i) {
        if (l[i] != l[i - 1] + 1) {
            return false;
        }
    }
    return true;
}


","#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>

bool check_Consecutive(std::vector<int> l) {
    std::sort(l.begin(), l.end());
    for (int i = 1; i < l.size(); ++i) {
        if (l[i]!= l[i - 1] + 1) {
            return false;
        }
    }
    return true;
}
","#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
bool check_Consecutive(std::vector<int> l) {
    std::sort(l.begin(), l.end());
    for (int i = 1; i < l.size(); ++i) {
        if (l[i - 1] + 1 != l[i]) {
//begin to write code
","#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>

bool check_Consecutive(std::vector<int> l) {
    std::sort(l.begin(), l.end());
    for (int i = 1; i < l.size(); ++i) {
        if (l[i - 1] + 1 != l[i]) {
            return false;
        }
    }
    return true;
}


","---




",1,3,0.3748560587565104,code_expression_exchange:exchange_operators,1.0,0.0,"{'#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nbool check_Consecutive(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 1; i < l.size(); ++i) {\n        if (l[i - 1] + 1 != l[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n': [('#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nbool check_Consecutive(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 1; i < l.size(); ++i) {\n        if (l[i - 1] + 1 != l[i]) {\n//begin to write code\n', '---\n\n\n\n\n', 'exchange_operators')]}"
462,"#include <iostream>
#include <set>
#include <vector>
#include <algorithm>
#include <cassert>
std::set<std::pair<int, int>> tuple_intersection(const std::vector<std::pair<int, int>>& test_list1, const std::vector<std::pair<int, int>>& test_list2) {
    std::set<std::pair<int, int>> set1, set2;
    for (auto& ele : test_list1) {
        set1.insert({std::min(ele.first, ele.second), std::max(ele.first, ele.second)});
    }
    for (auto& ele : test_list2) {
//begin to write code
",481,"
#include <iostream>
#include <set>
#include <vector>
#include <algorithm>
#include <cassert>

std::set<std::pair<int, int>> tuple_intersection(const std::vector<std::pair<int, int>>& test_list1, const std::vector<std::pair<int, int>>& test_list2) {
    std::set<std::pair<int, int>> set1, set2;
    for (auto& ele : test_list1) {
        set1.insert({std::min(ele.first, ele.second), std::max(ele.first, ele.second)});
    }
    for (auto& ele : test_list2) {
        set2.insert({std::min(ele.first, ele.second), std::max(ele.first, ele.second)});
    }

    std::set<std::pair<int, int>> res;
    std::set_intersection(set1.begin(), set1.end(), set2.begin(), set2.end(), std::inserter(res, res.begin()));
    return res;
}


","
#include <iostream>
#include <set>
#include <vector>
#include <algorithm>
#include <cassert>
std::set<std::pair<int, int>> tuple_intersection(const std::vector<std::pair<int, int>>& test_list1, const std::vector<std::pair<int, int>>& test_list2) {
    std::set<std::pair<int, int>> set1, set2;
    for (auto& ele : test_list1) {
        set1.insert({std::min(ele.first, ele.second), std::max(ele.first, ele.second)});
    }
    for (auto& ele : test_list2) {
        if (set1.find(ele)!= set1.end()) {
            set2.insert({std::min(ele.first, ele.second), std::max(ele.first, ele.second)});
        }
    }
    return set2;
}

",,,,-2,1,0.24727315505345662,code_expression_exchange:None,0.0,0.0,
463,"#include <iostream>
#include <string>
#include <cassert>
std::string replace_char(std::string str1, char ch, char newch) {
    for (size_t i = 0; i < str1.length(); ++i) {
        if (str1[i] == ch) {
            str1[i] = newch;
//begin to write code
",252,"
#include <iostream>
#include <string>
#include <cassert>

std::string replace_char(std::string str1, char ch, char newch) {
    for (size_t i = 0; i < str1.length(); ++i) {
        if (str1[i] == ch) {
            str1[i] = newch;
        }
    }
    return str1;
}


","
#include <iostream>
#include <string>
#include <cassert>

std::string replace_char(std::string str1, char ch, char newch) {
    std::string result;
    for (char ch : str1) {
        if (ch == ch) {
            result += newch;
        } else {
            result += ch;
        }
    }
    return result;
}

",,,,-2,1,0.23994051615397136,code_expression_exchange:None,0.0,0.0,
464,"#include <iostream>
#include <vector>
#include <map>
#include <algorithm>
#include <cassert>
bool compare(const std::pair<std::string, int> &a, const std::pair<std::string, int> &b) {
    return a.second > b.second;
}
std::vector<std::pair<std::string, int>> sort_counter(std::map<std::string, int> dict1) {
//begin to write code
",330,"
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>
#include <cassert>

bool compare(const std::pair<std::string, int> &a, const std::pair<std::string, int> &b) {
    return a.second > b.second;
}

std::vector<std::pair<std::string, int>> sort_counter(std::map<std::string, int> dict1) {
    std::vector<std::pair<std::string, int>> sorted_vec(dict1.begin(), dict1.end());
    std::sort(sorted_vec.begin(), sorted_vec.end(), compare);
    return sorted_vec;
}


","
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>
#include <cassert>

bool compare(const std::pair<std::string, int> &a, const std::pair<std::string, int> &b) {
    return a.second > b.second;
}

std::vector<std::pair<std::string, int>> sort_counter(std::map<std::string, int> dict1) {
    // Sort the map based on the second element of each pair
    std::vector<std::pair<std::string, int>> sorted_dict = dict1.begin();
    std::sort(sorted_dict.begin(), sorted_dict.end(), compare);
    return sorted_dict;
}

",,,,-2,1,0.2334890842437744,code_expression_exchange:None,0.0,0.0,
465,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
int big_sum(const std::vector<int>& nums) {
    int sum = *max_element(nums.begin(), nums.end()) + *min_element(nums.begin(), nums.end());
//begin to write code
",238,"#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>

int big_sum(const std::vector<int>& nums) {
    int sum = *max_element(nums.begin(), nums.end()) + *min_element(nums.begin(), nums.end());
    return sum;
}


","
#include <cassert>
#include <iostream>
#include <vector>
#include <algorithm>

int big_sum(const std::vector<int>& nums) {
    if (nums.empty()) {
        throw std::invalid_argument(""The vector cannot be empty."");
    }

    int max_value = *std::max_element(nums.begin(), nums.end());
    int min_value = *std::min_element(nums.begin(), nums.end());

    return max_value + min_value;
}

","#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>
int big_sum(const std::vector<int>& nums) {
    int sum = *max_element(nums.begin(), nums.end()) + *min_element(nums.begin(), nums.end());
//begin to write code
","#include<cassert>
#include <iostream>
#include <vector>
#include <algorithm>

int big_sum(const std::vector<int>& nums) {
    int sum = *max_element(nums.begin(), nums.end()) + *min_element(nums.begin(), nums.end());
    return sum;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>

int big_sum(const std::vector<int>& nums) {
    if (nums.empty()) {
        throw invalid_argument(""The input vector cannot be empty."");
    }
    
    int max_value = *max_element(nums.begin(), nums.end());
    int min_value = *min_element(nums.begin(), nums.end());
    
    return max_value + min_value;
}

",1,3,0.4668658892313639,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint big_sum(const std::vector<int>& nums) {\n    int sum = *max_element(nums.begin(), nums.end()) + *min_element(nums.begin(), nums.end());\n    return sum;\n}\n\n\n': [('#include<cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nint big_sum(const std::vector<int>& nums) {\n    int sum = *max_element(nums.begin(), nums.end()) + *min_element(nums.begin(), nums.end());\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n\nint big_sum(const std::vector<int>& nums) {\n    if (nums.empty()) {\n        throw invalid_argument(""The input vector cannot be empty."");\n    }\n    \n    int max_value = *max_element(nums.begin(), nums.end());\n    int min_value = *min_element(nums.begin(), nums.end());\n    \n    return max_value + min_value;\n}\n\n', 'equal_expression_transformation')]}"
466,"#include <iostream>
#include <string>
#include <cassert>
#include <algorithm>
std::string is_lower(const std::string& str) {
    std::string lower_str = str;
    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),
//begin to write code
",254,"
#include <iostream>
#include <string>
#include <cassert>
#include <algorithm>

std::string is_lower(const std::string& str) {
    std::string lower_str = str;
    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),
                   [](unsigned char c) { return std::tolower(c); });
    return lower_str;
}


","
using namespace std;
#include <iostream>
#include <string>
#include <cassert>
#include <algorithm>

std::string is_lower(const std::string& str) {
    std::string lower_str = str;
    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),
        [](unsigned char c) { return std::tolower(c); });
    return lower_str;
}

","#include <iostream>
#include <string>
#include <cassert>
#include <algorithm>
std::string is_lower(const std::string& str) {
    std::string lower_str = str;
    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),
//begin to write code
","
#include <iostream>
#include <string>
#include <cassert>
#include <algorithm>

std::string is_lower(const std::string& str) {
    std::string lower_str = str;
    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),
                   [](unsigned char c) { return std::tolower(c); });
    return lower_str;
}


","
using namespace std;

#include <iostream>
#include <string>
#include <cassert>
#include <algorithm>

std::string is_lower(const std::string& str) {
    std::string lower_str = str;
    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),
        [](unsigned char c){ return std::tolower(c); });
    return lower_str;
}

",-1,21,2.7895639220873516,code_expression_exchange:bool2int,1.0,0.9145214946191481,"{'\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\n\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n                   [](unsigned char c) { return std::tolower(c); });\n    return lower_str;\n}\n\n\n': [('#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\n\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n        [](unsigned char ch) { return std::tolower(ch); });\n    return lower_str;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n//begin to write code\n', '#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n        [](unsigned char ch) { return std::tolower(ch); });\n    return lower_str;\n}\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\n\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n                  [](unsigned char c) {\n                      return std::tolower(c);\n                  });\n    return lower_str;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\n\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n        [](unsigned char c) {\n            return std::tolower(c);\n        });\n    return lower_str;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n        [](unsigned char c){ return std::tolower(c); });\n    return lower_str;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\n\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n        [](unsigned char c){ return std::tolower(c); });\n    return lower_str;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\n\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n        [](unsigned char ch) {\n            return std::tolower(ch);\n        });\n    return lower_str;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\n\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n        [](unsigned char c){ return std::tolower(c); });\n    return lower_str;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\n\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n        [](unsigned char c){ return std::tolower(c); });\n    return lower_str;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <algorithm>\n\nstd::string is_lower(const std::string& str) {\n    std::string lower_str = str;\n    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(),\n        [](unsigned char c){ return std::tolower(c); });\n    return lower_str;\n}\n\n', 'bool2int')]}"
467,"#include <iostream>
#include <cassert>
using namespace std;
string remove_lowercase(const string& str1) {
    string res;
    for(char v:str1)
    {
        if(!(v<='z' && v>='a'))
//begin to write code
",203,"#include <iostream>
#include <cassert>

using namespace std;

string remove_lowercase(const string& str1) {
    string res;
    for(char v:str1)
    {
        if(!(v<='z' && v>='a'))
        {
            res += v;
        }
    }
    return res;
}","
#include <iostream>
#include <cassert>
using namespace std;

string remove_lowercase(const string& str1) {
    string res;
    for(char v:str1)
    {
        if(!(v<='z' && v>='a'))
            res += v;
    }
    return res;
}

","#include <iostream>
#include <cassert>
using namespace std;
string remove_lowercase(const string& str1) {
    string res;
    for(char v:str1)
    {
        if(!(v<='z' && v>='a'))
//begin to write code
","#include <iostream>
#include <cassert>

using namespace std;

string remove_lowercase(const string& str1) {
    string res;
    for(char v:str1)
    {
        if(!(v<='z' && v>='a'))
        {
            res += v;
        }
    }
    return res;
}","
#include <iostream>
#include <cassert>
using namespace std;

string remove_lowercase(const string& str1) {
    string res;
    for(char v:str1)
    {
        if(v<='z' && v>='a')
            res += v;
    }
    return res;
}

",1,5,0.7138672431310018,code_expression_exchange:exchange_operators,1.0,0.0,"{""#include <iostream>\n#include <cassert>\n\nusing namespace std;\n\nstring remove_lowercase(const string& str1) {\n    string res;\n    for(char v:str1)\n    {\n        if(!(v<='z' && v>='a'))\n        {\n            res += v;\n        }\n    }\n    return res;\n}"": [(""#include <iostream>\n#include <cassert>\nusing namespace std;\nstring remove_lowercase(const string& str1) {\n    string res;\n    for(char v:str1)\n    {\n        if(!(v<='z' && v>='a'))\n//begin to write code\n"", ""\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nstring remove_lowercase(const string& str1) {\n    string res;\n    for(char v:str1)\n    {\n        if(!(v<='z' && v>='a'))\n            res += v;\n    }\n    return res;\n}\n\n"", 'bool2int'), (""#include <iostream>\n#include <cassert>\nusing namespace std;\nstring remove_lowercase(const string& str1) {\n    string res;\n    for(char v:str1)\n    {\n        if(!(v<='z' && v>='a'))\n//begin to write code\n"", ""\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nstring remove_lowercase(const string& str1) {\n    string res;\n    for(char v:str1)\n    {\n        if(v<='z' && v>='a')\n            res += v;\n    }\n    return res;\n}\n\n"", 'exchange_operators')]}"
468,"#include <iostream>
#include <cassert>
int first_Digit(int n) {
    while (n >= 10) {
        n = n / 10;
//begin to write code
",128,"
#include <iostream>
#include <cassert>

int first_Digit(int n) {
    while (n >= 10) {
        n = n / 10;
    }
    return n;
}


","
using namespace std;

#include <iostream>
#include <cassert>

int first_Digit(int n) {
    while (n >= 10) {
        n = n / 10;
    }
    return n;
}

","#include <iostream>
#include <cassert>
int first_Digit(long n) {
    while (n >= 10) {
        n = n / 10;
//begin to write code
","
#include <iostream>
#include <cassert>

int first_Digit(long n) {
    while (n >= 10) {
        n = n / 10;
    }
    return n;
}


","
using namespace std;

#include <iostream>
#include <cassert>

int first_Digit(long n) {
    // Start with the last digit
    int last_digit = n % 10;
    return last_digit;
}

",1,5,0.7831032355626424,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nint first_Digit(long n) {\n    while (n >= 10) {\n        n = n / 10;\n    }\n    return n;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint first_Digit(long n) {\n    while (n >= 10) {\n        n = n / 10;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint first_Digit(long n) {\n    while (n >= 10) {\n        n = n / 10;\n    }\n    return n;\n}\n\nvoid test_first_Digit() {\n    assert(first_Digit(123456789) == 1);\n    assert(first_Digit(0) == 0);\n    assert(first_Digit(987654321) == 1);\n    assert(first_Digit(-123456789) == -1);\n    cout << ""All tests passed successfully."" << endl;\n}\n\n', 'more_universe_var_type'), ('#include <iostream>\n#include <cassert>\nint first_Digit(long n) {\n    while (n >= 10) {\n        n = n / 10;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint first_Digit(long n) {\n    // Start with the last digit\n    int last_digit = n % 10;\n    return last_digit;\n}\n\n', 'equal_expression_transformation')]}"
469,"#include <iostream>
#include <cassert>
char get_max_occuring_char(const std::string &str1) {
    const int ASCII_SIZE = 256;
    int ctr[ASCII_SIZE] = {0};
    int max = -1;
    char ch = '\0';
    for (char c : str1) {
        ctr[c]++;
    }
//begin to write code
",266,"
#include <iostream>
#include <cassert>

char get_max_occuring_char(const std::string &str1) {
    const int ASCII_SIZE = 256;
    int ctr[ASCII_SIZE] = {0};
    int max = -1;
    char ch = '\0';
    for (char c : str1) {
        ctr[c]++;
    }
    for (char c : str1) {
        if (max < ctr[c]) {
            max = ctr[c];
            ch = c;
        }
    }
    return ch;
}


","
#include <iostream>
#include <cassert>
#include <string>
#include <unordered_map>
#include <cctype>

char get_max_occuring_char(const std::string &str1) {
    if (str1.empty()) {
        return '\0'; // Return null if the string is empty
    }

    std::unordered_map<char, int> char_count;
    for (char c : str1) {
        if (std::isalpha(c)) { // Check if the character is an alphabet
            char_count[c]++;
        }
    }

    int max_count = 0;
    char max_char = '\0';

    for (const auto& pair : char_count) {
        if (pair.second > max_count) {
            max_count = pair.second;
            max_char = pair.first;
        }
    }

    return max_char;
}

",,,,-2,1,0.27956289052963257,code_expression_exchange:None,0.0,0.0,
470,"#include <iostream>
#include <vector>
#include <cassert>
bool is_subset_sum(const std::vector<int>& set, int n, int sum) {
    if (sum == 0) return true;
    if (n == 0) return false;
//begin to write code
",206,"
#include <iostream>
#include <vector>
#include <cassert>

bool is_subset_sum(const std::vector<int>& set, int n, int sum) {
    if (sum == 0) return true;
    if (n == 0) return false;
    if (set[n - 1] > sum) return is_subset_sum(set, n - 1, sum);
    return is_subset_sum(set, n-1, sum) || is_subset_sum(set, n-1, sum-set[n-1]);
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <cassert>

bool is_subset_sum(const std::vector<int>& set, int n, int sum) {
    if (sum == 0) return true;
    if (n == 0) return false;

    // Helper function to check if a subarray exists with sum equal to the given sum
    bool has_subset = has_subset_helper(set, n - 1, sum);
    return has_subset || is_subset_sum(set, n, sum - set[n - 1]);
}

// Helper function to check if a subarray exists with sum equal to the given sum
bool has_subset_helper(const std::vector<int>& set, int i, int sum) {
    if (i < 0) return false; // Base case: if index is out of bounds, no solution exists
    if (sum == 0) return true; // Base case: if sum is zero, a valid subset exists
    return has_subset_helper(set, i - 1, sum) || has_subset_helper(set, i - 1, sum - set[i]);
}

",,,,-2,1,0.2358330210049947,code_expression_exchange:None,0.0,0.0,
471,"#include<iostream>
#include <string>
#include <cctype>
#include <cassert>
#include <regex>
using namespace std;
string match(const string& text) {
    regex pattern(""[A-Z]+[a-z]+$"");
    if(text.empty())
    {
        return ""No"";
    }
//begin to write code
",259,"#include<iostream>
    
#include <string>
#include <cctype>
#include <cassert>
#include <regex>
using namespace std;

string match(const string& text) {
    regex pattern(""[A-Z]+[a-z]+$"");
    if(text.empty())
    {
        return ""No"";
    }

    if(regex_search(text,pattern))
    {
        return ""Yes"";
    }
    return ""No"";
}","
#include<iostream>
#include <string>
#include <cctype>
#include <cassert>
#include <regex>
using namespace std;

string match(const string& text) {
    regex pattern(""[A-Z]+[a-z]+$"");
    if(text.empty())
    {
        return ""No"";
    }
    return regex_search(text, pattern);
}

",,,,-2,1,0.21499952872594197,code_expression_exchange:None,0.0,0.0,
472,"#include <iostream>
#include <cassert>
using namespace std;
int first_Factorial_Divisible_Number(int x) {
    int i = 1;
    int fact = 1;
    for (i = 1; i <= x; ++i) {
        fact *= i;
//begin to write code
",211,"
#include <iostream>
#include <cassert>

using namespace std;

int first_Factorial_Divisible_Number(int x) {
    int i = 1;
    int fact = 1;
    for (i = 1; i <= x; ++i) {
        fact *= i;
        if (fact % x == 0) {
            break;
        }
    }
    return i;
}


","
#include <iostream>
#include <cassert>
using namespace std;

int first_Factorial_Divisible_Number(int x) {
    int i = 1;
    int fact = 1;
    for (i = 1; i <= x; ++i) {
        fact *= i;
        if (fact % x == 0) {
            return i;
        }
    }
    return -1; // Return -1 if no such number exists
}

","#include <iostream>
#include <cassert>
using namespace std;
long first_Factorial_Divisible_Number(int x) {
    int i = 1;
    int fact = 1;
    for (i = 1; i <= x; ++i) {
        fact *= i;
//begin to write code
","
#include <iostream>
#include <cassert>

using namespace std;

long first_Factorial_Divisible_Number(int x) {
    int i = 1;
    int fact = 1;
    for (i = 1; i <= x; ++i) {
        fact *= i;
        if (fact % x == 0) {
            break;
        }
    }
    return i;
}


","using namespace std;

long first_Factorial_Divisible_Number(int x) {
    long result = 1;
    for (int i = 1; i <= x; ++i) {
        result *= i;
    }
    if (result % x == 0) {
        return result;
    } else {
        return -1; // or any other appropriate value if the condition is not met
    }
}
",1,3,0.4461914976437887,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nusing namespace std;\n\nlong first_Factorial_Divisible_Number(int x) {\n    int i = 1;\n    int fact = 1;\n    for (i = 1; i <= x; ++i) {\n        fact *= i;\n        if (fact % x == 0) {\n            break;\n        }\n    }\n    return i;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nusing namespace std;\nlong first_Factorial_Divisible_Number(int x) {\n    int i = 1;\n    int fact = 1;\n    for (i = 1; i <= x; ++i) {\n        fact *= i;\n//begin to write code\n', 'using namespace std;\n\nlong first_Factorial_Divisible_Number(int x) {\n    long result = 1;\n    for (int i = 1; i <= x; ++i) {\n        result *= i;\n    }\n    if (result % x == 0) {\n        return result;\n    } else {\n        return -1; // or any other appropriate value if the condition is not met\n    }\n}\n', 'more_universe_var_type')]}"
473,"#include <vector>
#include <string>
#include <algorithm>
#include <unordered_map>
#include <cassert>
#include <utility> // for std::pair
#include <iostream>
using namespace std;
struct PairHash {
    template <class T1, class T2>
    std::size_t operator() (const std::pair<T1, T2>& pair) const {
        auto hash1 = std::hash<T1>{}(pair.first);
        auto hash2 = std::hash<T2>{}(pair.second);
        return hash1 ^ (hash2 << 1); 
    }
};
struct PairEqual {
    template <class T1, class T2>
    bool operator() (const std::pair<T1, T2>& lhs, const std::pair<T1, T2>& rhs) const {
        return lhs.first == rhs.first && lhs.second == rhs.second;
    }
};
//begin to write code
",685,"#include <vector>
#include <string>
#include <algorithm>
#include <unordered_map>
#include <cassert>
#include <utility> // for std::pair
#include <iostream>

using namespace std;


struct PairHash {
    template <class T1, class T2>
    std::size_t operator() (const std::pair<T1, T2>& pair) const {
        auto hash1 = std::hash<T1>{}(pair.first);
        auto hash2 = std::hash<T2>{}(pair.second);
        return hash1 ^ (hash2 << 1); 
    }
};

struct PairEqual {
    template <class T1, class T2>
    bool operator() (const std::pair<T1, T2>& lhs, const std::pair<T1, T2>& rhs) const {
        return lhs.first == rhs.first && lhs.second == rhs.second;
    }
};

vector<pair<string, string>> remove_matching_tuple(const vector<pair<string, string>>& test_list1, const vector<pair<string, string>>& test_list2) {
    vector<pair<string, string>> res;

    unordered_map<pair<string,string>,int,PairHash, PairEqual> counter2;
    for(const auto& one:test_list2)
    {
        counter2[one]++;
    }

    for (const auto& sub : test_list1) {
        if(counter2.find(sub) == counter2.end())
        {
            res.push_back(sub);
        }
    }
    
    return res;
}","
#include <vector>
#include <string>
#include <algorithm>
#include <unordered_map>
#include <cassert>
#include <utility> // for std::pair
#include <iostream>

using namespace std;
struct PairHash {
    template <class T1, class T2>
    std::size_t operator() (const std::pair<T1, T2>& pair) const {
        auto hash1 = std::hash<T1>{}(pair.first);
        auto hash2 = std::hash<T2>{}(pair.second);
        return hash1 ^ (hash2 << 1); 
    }
};
struct PairEqual {
    template <class T1, class T2>
    bool operator() (const std::pair<T1, T2>& lhs, const std::pair<T1, T2>& rhs) const {
        return lhs.first == rhs.first && lhs.second == rhs.second;
    }
};

// Function to remove matching tuples from two tuples
std::vector<std::pair<int, int>> removeMatchingTuples(const std::vector<std::pair<int, int>>& tuple1, const std::vector<std::pair<int, int>>& tuple2) {
    std::vector<std::pair<int,",,,,-2,1,0.23365717728932697,code_expression_exchange:None,0.0,0.0,
474,"#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;
bool is_palindrome(int n) {
    int divisor = 1;
    while (n / divisor >= 10) {
        divisor *= 10;
    }
    while (n != 0) {
        int leading = n / divisor;
        int trailing = n % 10;
        if (leading != trailing) {
            return false;
        }
        n = (n % divisor) / 10;
//begin to write code
",420,"#include<iostream>
    

#include <vector>
#include <algorithm>
#include <cassert>

using namespace std;

bool is_palindrome(int n) {
    int divisor = 1;
    while (n / divisor >= 10) {
        divisor *= 10;
    }
    while (n != 0) {
        int leading = n / divisor;
        int trailing = n % 10;
        if (leading != trailing) {
            return false;
        }
        n = (n % divisor) / 10;
        divisor /= 100;
    }
    return true;
}

int largest_palindrome(vector<int>& A, int n) {
    sort(A.begin(), A.end());
    for (int i = n - 1; i >= 0; --i) {
        if (is_palindrome(A[i])) {
            return A[i];
        }
    }
    return -1;
}


","
#include<iostream>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;

bool is_palindrome(int n) {
    int divisor = 1;
    while (n / divisor >= 10) {
        divisor *= 10;
    }
    while (n!= 0) {
        int leading = n / divisor;
        int trailing = n % 10;
        if (leading!= trailing) {
            return false;
        }
        n = (n % divisor) / 10;
    }
    return true;
}

int largest_palindrome(vector<int>& nums) {
    int max_palindrome = 0;
    for (int num : nums) {
        if (is_palindrome(num)) {
            if (num > max_palindrome) {
                max_palindrome = num;
            }
        }
    }
    return max_palindrome;
}

",,,,-2,1,0.23445387283960978,code_expression_exchange:None,0.0,0.0,
475,"#include <iostream>
#include <cmath>
#include <cassert>
double nCr(int n, int r) {
    if (r > n / 2) {
        r = n - r;
    }
    double answer = 1;
    for (int i = 1; i <= r; i++) {
        answer *= (n - r + i);
//begin to write code
",240,"
#include <iostream>
#include <cmath>
#include <cassert>

double nCr(int n, int r) {
    if (r > n / 2) {
        r = n - r;
    }
    double answer = 1;
    for (int i = 1; i <= r; i++) {
        answer *= (n - r + i);
        answer /= i;
    }
    return answer;
}

double binomial_probability(int n, int k, double p) {
    return nCr(n, k) * pow(p, k) * pow(1 - p, n - k);
}


","
using namespace std;
#include <cmath>
#include <cassert>

double nCr(int n, int r) {
    if (r > n / 2) {
        r = n - r;
    }
    double answer = 1;
    for (int i = 1; i <= r; i++) {
        answer *= (n - r + i);
    }
    return answer;
}

",,,,-2,1,0.218309223651886,code_expression_exchange:None,0.0,0.0,
476,"#include <iostream>
#include <vector>
#include <utility>
#include <cassert>
std::vector<std::pair<int, int>> sort_tuple(std::vector<std::pair<int, int>>& tup) {
    int lst = tup.size();
    for (int i = 0; i < lst; ++i) {
        for (int j = 0; j < lst - i - 1; ++j) {
            if (tup[j].second > tup[j + 1].second) {
                std::pair<int, int> temp = tup[j];
//begin to write code
",397,"
#include <iostream>
#include <vector>
#include <utility>
#include <cassert>

std::vector<std::pair<int, int>> sort_tuple(std::vector<std::pair<int, int>>& tup) {
    int lst = tup.size();
    for (int i = 0; i < lst; ++i) {
        for (int j = 0; j < lst - i - 1; ++j) {
            if (tup[j].second > tup[j + 1].second) {
                std::pair<int, int> temp = tup[j];
                tup[j] = tup[j + 1];
                tup[j + 1] = temp;
            }
        }
    }
    return tup;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <utility>
#include <cassert>

std::vector<std::pair<int, int>> sort_tuple(std::vector<std::pair<int, int>>& tup) {
    int lst = tup.size();
    for (int i = 0; i < lst; ++i) {
        for (int j = 0; j < lst - i - 1; ++j) {
            if (tup[j].second > tup[j + 1].second) {
                std::pair<int, int> temp = tup[j];
                tup[j] = tup[j + 1];
                tup[j + 1] = temp;
            }
        }
    }
    return tup;
}

","#include <iostream>
#include <vector>
#include <utility>
#include <cassert>
std::vector<std::pair<int, int>> sort_tuple(std::vector<std::pair<int, long>>& tup) {
    int lst = tup.size();
    for (int i = 0; i < lst; i = i + 1) {
        for (int j = 0; j < lst - i - 1; j = j + 1) {
            if (tup[j].second > tup[1 + j].second) {
                std::pair<int, int> temp = tup[j];
//begin to write code
","
#include <iostream>
#include <vector>
#include <utility>
#include <cassert>

std::vector<std::pair<int, int>> sort_tuple(std::vector<std::pair<int, long>>& tup) {
    int lst = tup.size();
    for (int i = 0; i < lst; i = i + 1) {
        for (int j = 0; j < lst - i - 1; j = j + 1) {
            if (tup[j].second > tup[1 + j].second) {
                std::pair<int, int> temp = tup[j];
                tup[j] = tup[1 + j];
                tup[1 + j] = temp;
            }
        }
    }
    return tup;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <utility>
#include <cassert>

std::vector<std::pair<int, int>> sort_tuple(std::vector<std::pair<int, long>>& tup) {
    int lst = tup.size();
    for (int i = 0; i < lst; i = i + 1) {
        for (int j = 0; j < lst - i - 1; j = j + 1) {
            if (tup[j].second > tup[1 + j].second) {
                std::pair<int, int> temp = tup[j];
                tup[j] = tup[1 + j];
                tup[1 + j] = temp;
            }
        }
    }
    return tup;
}

",1,7,1.0622121294339497,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <cassert>\n\nstd::vector<std::pair<int, int>> sort_tuple(std::vector<std::pair<int, long>>& tup) {\n    int lst = tup.size();\n    for (int i = 0; i < lst; i = i + 1) {\n        for (int j = 0; j < lst - i - 1; j = j + 1) {\n            if (tup[j].second > tup[1 + j].second) {\n                std::pair<int, int> temp = tup[j];\n                tup[j] = tup[1 + j];\n                tup[1 + j] = temp;\n            }\n        }\n    }\n    return tup;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <utility>\n#include <cassert>\nstd::vector<std::pair<int, int>> sort_tuple(std::vector<std::pair<int, int>>& tup) {\n    int lst = tup.size();\n    for (int i = 0; i < lst; ++i) {\n        for (int j = 0; j < lst - i - 1; ++j) {\n            if (tup[j].second > tup[1 + j].second) {\n                std::pair<int, int> temp = tup[j];\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <cassert>\n\nstd::vector<std::pair<int, int>> sort_tuple(std::vector<std::pair<int, int>>& tup) {\n    int lst = tup.size();\n    for (int i = 0; i < lst; ++i) {\n        for (int j = 0; j < lst - i - 1; ++j) {\n            if (tup[j].second > tup[1 + j].second) {\n                std::pair<int, int> temp = tup[j];\n                tup[j] = tup[1 + j];\n                tup[1 + j] = temp;\n            }\n        }\n    }\n    return tup;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <utility>\n#include <cassert>\nstd::vector<std::pair<int, int>> sort_tuple(std::vector<std::pair<int, int>>& tup) {\n    int lst = tup.size();\n    for (int i = 0; i < lst; i = i + 1) {\n        for (int j = 0; j < lst - i - 1; j = j + 1) {\n            if (tup[j].second > tup[1 + j].second) {\n                std::pair<int, int> temp = tup[j];\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <cassert>\nstd::vector<std::pair<int, int>> sort_tuple(std::vector<std::pair<int, int>>& tup) {\n    int lst = tup.size();\n    for (int i = 0; i < lst; i = i + 1) {\n        for (int j = 0; j < lst - i - 1; j = j + 1) {\n            if (tup[j].second > tup[1 + j].second) {\n                std::pair<int, int> temp = tup[j];\n                tup[j] = tup[1 + j];\n                tup[1 + j] = temp;\n            }\n        }\n    }\n    return tup;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <utility>\n#include <cassert>\nstd::vector<std::pair<int, int>> sort_tuple(std::vector<std::pair<int, long>>& tup) {\n    int lst = tup.size();\n    for (int i = 0; i < lst; i = i + 1) {\n        for (int j = 0; j < lst - i - 1; j = j + 1) {\n            if (tup[j].second > tup[1 + j].second) {\n                std::pair<int, int> temp = tup[j];\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <cassert>\n\nstd::vector<std::pair<int, int>> sort_tuple(std::vector<std::pair<int, long>>& tup) {\n    int lst = tup.size();\n    for (int i = 0; i < lst; i = i + 1) {\n        for (int j = 0; j < lst - i - 1; j = j + 1) {\n            if (tup[j].second > tup[1 + j].second) {\n                std::pair<int, int> temp = tup[j];\n                tup[j] = tup[1 + j];\n                tup[1 + j] = temp;\n            }\n        }\n    }\n    return tup;\n}\n\n', 'more_universe_var_type')]}"
477,"#include <iostream>
#include <cmath>
#include <cassert>
double area_pentagon(double a) {
  double area = (sqrt(5 * (5 + 2 * sqrt(5))) * pow(a, 2)) / 4.0;
//begin to write code
",176,"
#include <iostream>
#include <cmath>
#include <cassert>

double area_pentagon(double a) {
  double area = (sqrt(5 * (5 + 2 * sqrt(5))) * pow(a, 2)) / 4.0;
  return area;
}


","
#include <iostream>
#include <cmath>
#include <cassert>

double area_pentagon(double a) {
  double area = (sqrt(5 * (5 + 2 * sqrt(5))) * pow(a, 2)) / 4.0;
  return area;
}

","#include <iostream>
#include <cmath>
#include <cassert>
double area_pentagon(double a) {
  double area = (sqrt(5 * (5 + 2 * sqrt(5))) * pow(a, 2)) / 4.0;
//begin to write code
","
#include <iostream>
#include <cmath>
#include <cassert>

double area_pentagon(double a) {
  double area = (sqrt(5 * (5 + 2 * sqrt(5))) * pow(a, 2)) / 4.0;
  return area;
}


","
#include <iostream>
#include <cmath>
#include <cassert>

// Function to calculate the area of a pentagon
double area_pentagon(double a) {
  // Calculate the semi-perimeter
  double s = (a + a + a + a) / 2.0;
  
  // Calculate the area using Heron's formula
  double area = std::sqrt(s * (s - a) * (s - a) * (s - a));
  
  return area;
}

",1,3,0.5105471014976501,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\ndouble area_pentagon(double a) {\n  double area = (sqrt(5 * (5 + 2 * sqrt(5))) * pow(a, 2)) / 4.0;\n  return area;\n}\n\n\n': [('#include <iostream>\n#include <cmath>\n#include <cassert>\ndouble area_pentagon(double a) {\n  double area = (sqrt(5 * (5 + 2 * sqrt(5))) * pow(a, 2)) / 4.0;\n//begin to write code\n', ""\n#include <iostream>\n#include <cmath>\n#include <cassert>\n\n// Function to calculate the area of a pentagon\ndouble area_pentagon(double a) {\n  // Calculate the semi-perimeter\n  double s = (a + a + a + a) / 2.0;\n  \n  // Calculate the area using Heron's formula\n  double area = std::sqrt(s * (s - a) * (s - a) * (s - a));\n  \n  return area;\n}\n\n"", 'more_universe_var_type')]}"
478,"#include <iostream>
#include <vector>
#include <cassert>
int frequency_Of_Largest(int n, std::vector<int> arr) {
    int mn = arr[0];
    int freq = 1;
    for (int i = 1; i < n; i++) {
        if (arr[i] > mn) {
            mn = arr[i];
//begin to write code
",260,"
#include <iostream>
#include <vector>
#include <cassert>

int frequency_Of_Largest(int n, std::vector<int> arr) {
    int mn = arr[0];
    int freq = 1;
    for (int i = 1; i < n; i++) {
        if (arr[i] > mn) {
            mn = arr[i];
            freq = 1;
        } else if (arr[i] == mn) {
            freq++;
        }
    }
    return freq;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

int frequency_Of_Largest(int n, std::vector<int> arr) {
    int mn = arr[0];
    int freq = 1;
    for (int i = 1; i < n; i++) {
        if (arr[i] > mn) {
            mn = arr[i];
            freq = 1;
        } else if (arr[i] == mn) {
            freq++;
        }
    }
    return freq;
}

","#include <iostream>
#include <vector>
#include <cassert>
int frequency_Of_Largest(int n, std::vector<int> arr) {
    long mn = arr[0];
    int freq = 1;
    for (int i = 1; i < n; i++) {
        if (arr[i] > mn) {
            mn = arr[i];
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

int frequency_Of_Largest(int n, std::vector<int> arr) {
    long mn = arr[0];
    int freq = 1;
    for (int i = 1; i < n; i++) {
        if (arr[i] > mn) {
            mn = arr[i];
            freq = 1;
        } else if (arr[i] == mn) {
            freq++;
        }
    }
    return freq;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

int frequency_Of_Largest(int n, std::vector<int> arr) {
    long mn = arr[0];
    int freq = 1;
    for (int i = 1; i < n; i++) {
        if (arr[i] > mn) {
            mn = arr[i];
            freq = 1;
        } else if (arr[i] == mn) {
            freq++;
        }
    }
    return freq;
}

void test_frequency_Of_Largest() {
    assert(frequency_Of_Largest(5, {1, 2, 2, 3, 3, 3}) == 3);
    assert(frequency_Of_Largest(3, {1, 2, 3}) == 1);
    assert(frequency_Of_Largest(0, {1, 2, 3}) == 0);
    assert(frequency_Of_Largest(6, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == 10);
    cout << ""All tests passed successfully",1,3,0.5524385650952657,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint frequency_Of_Largest(int n, std::vector<int> arr) {\n    long mn = arr[0];\n    int freq = 1;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > mn) {\n            mn = arr[i];\n            freq = 1;\n        } else if (arr[i] == mn) {\n            freq++;\n        }\n    }\n    return freq;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nint frequency_Of_Largest(int n, std::vector<int> arr) {\n    long mn = arr[0];\n    int freq = 1;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > mn) {\n            mn = arr[i];\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint frequency_Of_Largest(int n, std::vector<int> arr) {\n    long mn = arr[0];\n    int freq = 1;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > mn) {\n            mn = arr[i];\n            freq = 1;\n        } else if (arr[i] == mn) {\n            freq++;\n        }\n    }\n    return freq;\n}\n\nvoid test_frequency_Of_Largest() {\n    assert(frequency_Of_Largest(5, {1, 2, 2, 3, 3, 3}) == 3);\n    assert(frequency_Of_Largest(3, {1, 2, 3}) == 1);\n    assert(frequency_Of_Largest(0, {1, 2, 3}) == 0);\n    assert(frequency_Of_Largest(6, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == 10);\n    cout << ""All tests passed successfully', 'more_universe_var_type')]}"
479,"#include <iostream>
#include <vector>
#include <set>
#include <cassert>
using namespace std;
set<pair<int, int>> extract_symmetric(vector<pair<int, int>> test_list) {
    set<pair<int, int>> temp;
    for (auto& p : test_list) {
        temp.insert(p);
    }
    set<pair<int, int>> res;
//begin to write code
",310,"
#include <iostream>
#include <vector>
#include <set>
#include <cassert>
using namespace std;

set<pair<int, int>> extract_symmetric(vector<pair<int, int>> test_list) {
    set<pair<int, int>> temp;
    for (auto& p : test_list) {
        temp.insert(p);
    }
    set<pair<int, int>> res;
    for (auto& p : temp) {
        if (temp.find({p.second, p.first}) != temp.end() && p.first < p.second) {
            res.insert(p);
        }
    }
    return res;
}


","
#include <iostream>
#include <vector>
#include <set>
#include <cassert>
using namespace std;
set<pair<int, int>> extract_symmetric(vector<pair<int, int>> test_list) {
    set<pair<int, int>> temp;
    for (auto& p : test_list) {
        temp.insert(p);
    }
    set<pair<int, int>> res;
    // Iterate over the original set and insert symmetric pairs
    for (const auto& p : temp) {
        res.insert({p.second, p.first});
    }
    return res;
}

",,,,-2,1,0.2335621476173401,code_expression_exchange:None,0.0,0.0,
480,"#include<iostream>
#include <cmath>
#include <cassert>
using namespace std;
double sum_gp(double a, int n, double r) {
    double total = (a * (1 - pow(r, n))) / (1 - r);
//begin to write code
",193,"#include<iostream>
    

#include <cmath>
#include <cassert>

using namespace std;

double sum_gp(double a, int n, double r) {
    double total = (a * (1 - pow(r, n))) / (1 - r);
    return total;
}


","
#include<iostream>
#include <cmath>
#include <cassert>
using namespace std;

// Function to calculate the sum of a geometric progression series
double sum_gp(double a, int n, double r) {
    double total = (a * (1 - pow(r, n))) / (1 - r);
    return total;
}

// Test function to verify the correctness of the sum_gp function
void test_sum_gp() {
    assert(abs(sum_gp(1, 5, 2) - 30.0) < 1e-9);
    assert(abs(sum_gp(2, 3, 3) - 15.0) < 1e-9);
    assert(abs(sum_gp(5, 6, 4) - 85.0) < 1e-9);
    cout << ""All test cases passed!"" << endl;
}

",,,,-2,1,0.227811066309611,code_expression_exchange:None,0.0,0.0,
481,"#include <iostream>
#include <vector>
#include <cassert>
bool binary_search(const std::vector<int>& item_list, int item) {
    int first = 0;
    int last = item_list.size() - 1;
    bool found = false;
    while (first <= last && !found) {
        int mid = (first + last) / 2;
        if (item_list[mid] == item) {
            found = true;
        } else {
//begin to write code
",382,"
#include <iostream>
#include <vector>
#include <cassert>

bool binary_search(const std::vector<int>& item_list, int item) {
    int first = 0;
    int last = item_list.size() - 1;
    bool found = false;

    while (first <= last && !found) {
        int mid = (first + last) / 2;
        if (item_list[mid] == item) {
            found = true;
        } else {
            if (item < item_list[mid]) {
                last = mid - 1;
            } else {
                first = mid + 1;
            }
        }
    }

    return found;
}


","
#include <iostream>
#include <vector>
#include <cassert>

bool binary_search(const std::vector<int>& item_list, int item) {
    int first = 0;
    int last = item_list.size() - 1;
    bool found = false;
    while (first <= last &&!found) {
        int mid = (first + last) / 2;
        if (item_list[mid] == item) {
            found = true;
        } else if (item_list[mid] < item) {
            first = mid + 1;
        } else {
            last = mid - 1;
        }
    }
    return found;
}

","#include <iostream>
#include <vector>
#include <cassert>
bool binary_search(const std::vector<int>& item_list, long item) {
    int first = 0;
    int last = item_list.size() - 1;
    bool found = false;
    while (first <= last && !found) {
        int mid = (first + last) / 2;
        if (item == item_list[mid]) {
            found = true;
        } else {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

bool binary_search(const std::vector<int>& item_list, long item) {
    int first = 0;
    int last = item_list.size() - 1;
    bool found = false;

    while (first <= last && !found) {
        int mid = (first + last) / 2;
        if (item == item_list[mid]) {
            found = true;
        } else {
            if (item < item_list[mid]) {
                last = mid - 1;
            } else {
                first = 1 + mid;
            }
        }
    }

    return found;
}


","
#include <iostream>
#include <string>
#include <cassert>

bool is_palindrome(const std::string& str) {
    int left = 0;
    int right = str.length() - 1;
    while (left < right) {
        if (str[left]!= str[right]) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}

",1,5,0.7904953797658284,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool binary_search(const std::vector<int>& item_list, long item) {\n    int first = 0;\n    int last = item_list.size() - 1;\n    bool found = false;\n\n    while (first <= last && !found) {\n        int mid = (first + last) / 2;\n        if (item == item_list[mid]) {\n            found = true;\n        } else {\n            if (item < item_list[mid]) {\n                last = mid - 1;\n            } else {\n                first = 1 + mid;\n            }\n        }\n    }\n\n    return found;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nbool binary_search(const std::vector<int>& item_list, int item) {\n    int first = 0;\n    int last = item_list.size() - 1;\n    bool found = false;\n    while (first <= last && !found) {\n        int mid = (first + last) / 2;\n        if (item == item_list[mid]) {\n            found = true;\n        } else {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nbool binary_search(const std::vector<int>& item_list, int item) {\n    int first = 0;\n    int last = item_list.size() - 1;\n    bool found = false;\n    while (first <= last &&!found) {\n        int mid = (first + last) / 2;\n        if (item == item_list[mid]) {\n            found = true;\n        } else {\n            // Begin to write code\n            if (item_list[mid] < item) {\n                first = mid + 1;\n            } else {\n                last = mid - 1;\n            }\n        }\n    }\n    return found;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nbool binary_search(const std::vector<int>& item_list, long item) {\n    int first = 0;\n    int last = item_list.size() - 1;\n    bool found = false;\n    while (first <= last && !found) {\n        int mid = (first + last) / 2;\n        if (item == item_list[mid]) {\n            found = true;\n        } else {\n//begin to write code\n', '\n#include <iostream>\n#include <string>\n#include <cassert>\n\nbool is_palindrome(const std::string& str) {\n    int left = 0;\n    int right = str.length() - 1;\n    while (left < right) {\n        if (str[left]!= str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\n', 'more_universe_var_type')]}"
482,"#include <iostream>
#include <vector>
#include <cmath>
#include <cassert>
typedef std::vector<std::pair<double, double>> Polygon;
std::vector<Polygon> calculate_polygons(double startx, double starty, double endx, double endy, double radius)
{
    double sl = (2 * radius) * std::tan(M_PI / 6);
    double p = sl * 0.5;
    double b = sl * std::cos(30 * M_PI / 180.0);
    double w = b * 2;
    double h = 2 * sl;
    startx = startx - w;
    starty = starty - h;
    endx = endx + w;
    endy = endy + h;
    double origx = startx;
    double origy = starty;
    double xoffset = b;
    double yoffset = 3 * p;
    std::vector<Polygon> polygons;
    int row = 1;
    int counter = 0;
    while (starty < endy)
    {
        if (row % 2 == 0)
        {
            startx = origx + xoffset;
        }
        else
        {
            startx = origx;
        }
        while (startx < endx)
//begin to write code
",913,"
#include <iostream>
#include <vector>
#include <cmath>
#include <cassert>

typedef std::vector<std::pair<double, double>> Polygon;

std::vector<Polygon> calculate_polygons(double startx, double starty, double endx, double endy, double radius)
{
    double sl = (2 * radius) * std::tan(M_PI / 6);
    double p = sl * 0.5;
    double b = sl * std::cos(30 * M_PI / 180.0);
    double w = b * 2;
    double h = 2 * sl;
    startx = startx - w;
    starty = starty - h;
    endx = endx + w;
    endy = endy + h;
    double origx = startx;
    double origy = starty;
    double xoffset = b;
    double yoffset = 3 * p;
    std::vector<Polygon> polygons;
    int row = 1;
    int counter = 0;
    while (starty < endy)
    {
        if (row % 2 == 0)
        {
            startx = origx + xoffset;
        }
        else
        {
            startx = origx;
        }
        while (startx < endx)
        {
            double p1x = startx;
            double p1y = starty + p;
            double p2x = startx;
            double p2y = starty + (3 * p);
            double p3x = startx + b;
            double p3y = starty + h;
            double p4x = startx + w;
            double p4y = starty + (3 * p);
            double p5x = startx + w;
            double p5y = starty + p;
            double p6x = startx + b;
            double p6y = starty;
            Polygon poly = {
                {p1x, p1y},
                {p2x, p2y},
                {p3x, p3y},
                {p4x, p4y},
                {p5x, p5y},
                {p6x, p6y},
                {p1x, p1y}
            };
            polygons.push_back(poly);
            counter += 1;
            startx += w;
        }
        starty += yoffset;
        row += 1;
    }
    return polygons;
}


","
#include <iostream>
#include <vector>
#include <cmath>
#include <cassert>
typedef std::vector<std::pair<double, double>> Polygon;

std::vector<Polygon> calculate_polygons(double startx, double starty, double endx, double endy, double radius)
{
    double sl = (2 * radius) * std::tan(M_PI / 6);
    double p = sl * 0.5;
    double b = sl * std::cos(30 * M_PI / 180.0);
    double w = b * 2;
    double h = 2 * sl;
    startx = startx - w;
    starty = starty - h;
    endx = endx + w;
    endy = endy + h;
    double origx = startx;
    double origy = starty;
    double xoffset = b;
    double yoffset = 3 * p;
    std::vector<Polygon> polygons;
    int row = 1;
    int counter = 0;
    while (starty < endy)
    {
        if (row % 2 == 0)
        {
            startx =",,,,-2,1,0.23313726981480917,code_expression_exchange:None,0.0,0.0,
483,"#include<cassert>
#include <iostream>
#include <vector>
#include <string>
#include <bitset>
std::string binary_to_integer(const std::vector<int>& test_vec) {
    std::string bin_str = """";
    for (int num : test_vec) {
        bin_str += std::to_string(num);
//begin to write code
",281,"#include<cassert>
#include <iostream>
#include <vector>
#include <string>
#include <bitset>

std::string binary_to_integer(const std::vector<int>& test_vec) {
    std::string bin_str = """";
    for (int num : test_vec) {
        bin_str += std::to_string(num);
    }
    int decimal = std::stoi(bin_str, nullptr, 2);
    return std::to_string(decimal);
}


","
#include<cassert>
#include <iostream>
#include <vector>
#include <string>
#include <bitset>
#include <sstream>

std::string binary_to_integer(const std::vector<int>& test_vec) {
    std::stringstream ss;
    for (int num : test_vec) {
        ss << num;
    }
    return ss.str();
}

",,,,-2,1,0.23664029041926066,code_expression_exchange:None,0.0,0.0,
484,"#include<cassert>
#include <iostream>
#include <string>
#include <cctype>
std::string remove_lowercase(const std::string& str1) {
    std::string result;
    for (char ch : str1) {
        if (!std::islower(ch)) {
//begin to write code
",236,"#include<cassert>
#include <iostream>
#include <string>
#include <cctype>

std::string remove_lowercase(const std::string& str1) {
    std::string result;
    for (char ch : str1) {
        if (!std::islower(ch)) {
            result += ch;
        }
    }
    return result;
}


","using namespace std;

#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>
#include<iostream>
#include<cctype>

std::string remove_lowercase(const std::string& str1) {
    std::string result;
    for (char ch : str1) {
        if (!std::islower(ch)) {
            result += ch;
        }
    }
    return result;
}
",,,,-2,1,0.19368374745051067,code_expression_exchange:None,0.0,0.0,
485,"#include <vector>
#include <algorithm>
#include <cassert>
#include <iostream>
std::vector<int> heap_queue_smallest(std::vector<int> nums, int n) {
    std::vector<int> smallest_nums(n);
//begin to write code
",208,"
#include <vector>
#include <algorithm>
#include <cassert>
#include <iostream>

std::vector<int> heap_queue_smallest(std::vector<int> nums, int n) {
    std::vector<int> smallest_nums(n);
    std::partial_sort_copy(nums.begin(), nums.end(), smallest_nums.begin(), smallest_nums.end());
    return smallest_nums;
}


","
#include <vector>
#include <algorithm>
#include <cassert>
#include <iostream>
std::vector<int> heap_queue_smallest(std::vector<int> nums, int n) {
    // Create a min-heap
    std::priority_queue<int> min_heap(nums.begin(), nums.end());
    // Extract the smallest n elements
    std::vector<int> smallest_nums(n);
    for (int i = 0; i < n; ++i) {
        smallest_nums[i] = min_heap.top();
        min_heap.pop();
    }
    return smallest_nums;
}

",,,,-2,1,0.24473829666773478,code_expression_exchange:None,0.0,0.0,
486,"#include <cmath>
#include <cassert>
#include <iostream>
double surfacearea_cone(double r, double h) {
    double l = sqrt(r * r + h * h);
//begin to write code
",160,"
#include <cmath>
#include <cassert>
#include <iostream>

double surfacearea_cone(double r, double h) {
    double l = sqrt(r * r + h * h);
    double SA = M_PI * r * (r + l);
    return SA;
}


","
#include <cmath>
#include <cassert>
#include <iostream>

double surfacearea_cone(double r, double h) {
    double l = sqrt(r * r + h * h);
    return 2 * M_PI * l;
}

",,,,-2,1,0.21754641930262247,code_expression_exchange:None,0.0,0.0,
487,"#include <iostream>
#include <cassert>
int gcd(int x, int y) {
    int gcd = 1;
    if (x % y == 0) {
        return y;
    }
    for (int k = y / 2; k > 0; k--) {
//begin to write code
",186,"
#include <iostream>
#include <cassert>

int gcd(int x, int y) {
    int gcd = 1;
    if (x % y == 0) {
        return y;
    }
    for (int k = y / 2; k > 0; k--) {
        if (x % k == 0 && y % k == 0) {
            gcd = k;
            break;
        }
    }
    return gcd;
}


","
#include <iostream>
#include <cassert>

int gcd(int x, int y) {
    int gcd = 1;
    while (y!= 0) {
        int temp = y;
        y = x % y;
        x = temp;
        gcd = std::max(gcd, x);
    }
    return gcd;
}

",,,,-2,1,0.2613598108291626,code_expression_exchange:None,0.0,0.0,
488,"#include<iostream>
#include<cassert>
//
int diameter_circle(int r) {
//begin to write code
",95,"
#include<iostream>
#include<cassert>

//
int diameter_circle(int r) {
    int diameter = 2 * r;
    return diameter;
}


","
#include <iostream>
#include <cmath>

// Function to calculate the diameter of a circle
int diameter_circle(int r) {
    return 2 * r;
}

// Test function to verify the correctness of the diameter_circle function
void test_diameter_circle() {
    assert(diameter_circle(0) == 0);
    assert(diameter_circle(1) == 2);
    assert(diameter_circle(2) == 4);
    assert(diameter_circle(3) == 6);
    std::cout << ""All test cases passed successfully."" << std::endl;
}

",,,,-2,1,0.19191978375116983,code_expression_exchange:None,0.0,0.0,
489,"#include <iostream>
#include <vector>
#include <string>
#include <cassert>
std::string concatenate_elements(const std::vector<std::string>& list) {
    std::string ans = "" "";
    for (const auto& i : list) {
//begin to write code
",230,"
#include <iostream>
#include <vector>
#include <string>
#include <cassert>

std::string concatenate_elements(const std::vector<std::string>& list) {
    std::string ans = "" "";
    for (const auto& i : list) {
        ans += "" "" + i;
    }
    return ans;
}


","
#include <iostream>
#include <vector>
#include <string>
#include <cassert>
std::string concatenate_elements(const std::vector<std::string>& list) {
    std::string ans = """";
    for (const auto& i : list) {
        ans += i;
    }
    return ans;
}

",,,,-2,1,0.19453444480895996,code_expression_exchange:None,0.0,0.0,
490,"#include <iostream>
#include <cmath>
#include <cassert>
int ngcd(int x, int y) {
    int i = 1;
    int gcd = 1;
    while(i <= x && i <= y) {
        if(x % i == 0 && y % i == 0) {
            gcd = i;
        }
        i += 1;
    }
    return gcd;
}
int num_comm_div(int x, int y) {
    int n = ngcd(x, y);
//begin to write code
",332,"
#include <iostream>
#include <cmath>
#include <cassert>

int ngcd(int x, int y) {
    int i = 1;
    int gcd = 1;
    while(i <= x && i <= y) {
        if(x % i == 0 && y % i == 0) {
            gcd = i;
        }
        i += 1;
    }
    return gcd;
}

int num_comm_div(int x, int y) {
    int n = ngcd(x, y);
    int result = 0;
    int z = int(sqrt(n));
    int i = 1;
    while(i <= z) {
        if(n % i == 0) {
            result += 2;
            if(i == n / i) {
                result -= 1;
            }
        }
        i += 1;
    }
    return result;
}


","
using namespace std;

#include <iostream>
#include <cmath>
#include <cassert>

int ngcd(int x, int y) {
    int i = 1;
    int gcd = 1;
    while(i <= x && i <= y) {
        if(x % i == 0 && y % i == 0) {
            gcd = i;
        }
        i += 1;
    }
    return gcd;
}

int num_comm_div(int x, int y) {
    int n = ngcd(x, y);
    return n;
}

",,,,-2,1,0.2216091473897298,code_expression_exchange:None,0.0,0.0,
491,"#include <iostream>
#include <cassert>
int find(int n, int m) {
    int r = n % m;
//begin to write code
",105,"
#include <iostream>
#include <cassert>

int find(int n, int m) {
    int r = n % m;
    return r;
}


","
#include <iostream>
#include <cassert>

int find(int n, int m) {
    int r = n % m;
    return r;
}

","#include <iostream>
#include <cassert>
int find(int n, long m) {
    int r = n % m;
//begin to write code
","
#include <iostream>
#include <cassert>

int find(int n, long m) {
    int r = n % m;
    return r;
}


","
using namespace std;
#include <iostream>

int find(int n, long m) {
    int r = n % m;
    return r;
}

",1,7,0.9723482688268026,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nint find(int n, long m) {\n    int r = n % m;\n    return r;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint find(int n, int m) {\n    int r = n % m;\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint find(int n, int m) {\n    return n % m;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cassert>\nint find(int n, int m) {\n    int r = n % m;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <cassert>\n\nint find(int n, int m) {\n    int r = n % m;\n    return r;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cassert>\nint find(int n, long m) {\n    int r = n % m;\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n\nint find(int n, long m) {\n    int r = n % m;\n    return r;\n}\n\n', 'more_universe_var_type')]}"
492,"#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> add_consecutive_nums(const std::vector<int>& nums) {
    std::vector<int> result;
    for (size_t i = 0; i < nums.size() - 1; ++i) {
//begin to write code
",229,"
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> add_consecutive_nums(const std::vector<int>& nums) {
    std::vector<int> result;
    for (size_t i = 0; i < nums.size() - 1; ++i) {
        result.push_back(nums[i] + nums[i + 1]);
    }
    return result;
}


","
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> add_consecutive_nums(const std::vector<int>& nums) {
    std::vector<int> result;
    for (size_t i = 0; i < nums.size() - 1; ++i) {
        result.push_back(nums[i] + nums[i + 1]);
    }
    return result;
}

","#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> add_consecutive_nums(const std::vector<int>& nums) {
    std::vector<long> result;
    for (size_t i = 0; i < nums.size() - 1; ++i) {
//begin to write code
","
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> add_consecutive_nums(const std::vector<int>& nums) {
    std::vector<long> result;
    for (size_t i = 0; i < nums.size() - 1; ++i) {
        result.push_back(nums[i] + nums[i + 1]);
    }
    return result;
}


","
using namespace std;
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> add_consecutive_nums(const std::vector<int>& nums) {
    std::vector<long> result;
    for (size_t i = 0; i < nums.size() - 1; ++i) {
        result.push_back(nums[i] + nums[i + 1]);
    }
    return result;
}

",1,5,0.773097030321757,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> add_consecutive_nums(const std::vector<int>& nums) {\n    std::vector<long> result;\n    for (size_t i = 0; i < nums.size() - 1; ++i) {\n        result.push_back(nums[i] + nums[i + 1]);\n    }\n    return result;\n}\n\n\n': [('#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> add_consecutive_nums(const std::vector<int>& nums) {\n    std::vector<int> result;\n    for (size_t i = 0; i < nums.size() - 1; ++i) {\n//begin to write code\n', '\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> add_consecutive_nums(const std::vector<int>& nums) {\n    std::vector<int> result;\n    for (size_t i = 0; i < nums.size() - 1; ++i) {\n        result.push_back(nums[i] + nums[i + 1]);\n    }\n    return result;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <vector>\n#include <cassert>\nstd::vector<int> add_consecutive_nums(const std::vector<int>& nums) {\n    std::vector<long> result;\n    for (size_t i = 0; i < nums.size() - 1; ++i) {\n//begin to write code\n', '\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nstd::vector<int> add_consecutive_nums(const std::vector<int>& nums) {\n    std::vector<long> result;\n    for (size_t i = 0; i < nums.size() - 1; ++i) {\n        result.push_back(nums[i] + nums[i + 1]);\n    }\n    return result;\n}\n\n', 'more_universe_var_type')]}"
493,"#include <iostream>
#include <cassert>
int sum_Of_Series(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
//begin to write code
",140,"
#include <iostream>
#include <cassert>

int sum_Of_Series(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i * i * i;
    }
    return sum;
}


","
using namespace std;

#include <iostream>
#include <cassert>

int sum_Of_Series(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i * i * i;
    }
    return sum;
}

","#include <iostream>
#include <cassert>
int sum_Of_Series(int n) {
    int sum = 0;
    for (long i = 1; i <= n; i = i + 1) {
//begin to write code
","
#include <iostream>
#include <cassert>

int sum_Of_Series(int n) {
    int sum = 0;
    for (long i = 1; i <= n; i = i + 1) {
        sum = sum + (i * i * i);
    }
    return sum;
}


","
using namespace std;
#include<stdlib.h>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<string>

int sum_Of_Series(int n) {
    int sum = 0;
    for (long i = 1; i <= n; i = i + 1) {
        sum += i * i * i;
    }
    return sum;
}

",1,15,1.980817989508311,code_expression_exchange:more_universe_var_type,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nint sum_Of_Series(int n) {\n    int sum = 0;\n    for (long i = 1; i <= n; i = i + 1) {\n        sum = sum + (i * i * i);\n    }\n    return sum;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint sum_Of_Series(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nint sum_Of_Series(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i * i * i;\n    }\n    return sum;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cassert>\nint sum_Of_Series(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint sum_Of_Series(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i * i * i;\n    }\n    return sum;\n}\n\n', 'exchange_operators'), ('#include <iostream>\n#include <cassert>\nint sum_Of_Series(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nint sum_Of_Series(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n        sum += i * i * i;\n    }\n    return sum;\n}\n\n', 'equal_expression_transformation'), ('#include <iostream>\n#include <cassert>\nint sum_Of_Series(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint sum_Of_Series(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n        sum += i * i * i;\n    }\n    return sum;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cassert>\nint sum_Of_Series(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint sum_Of_Series(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n        sum += i * i * i;\n    }\n    return sum;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cassert>\nint sum_Of_Series(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n//begin to write code\n', '\nusing namespace std;\n\n#include <iostream>\n#include <cassert>\n\nint sum_Of_Series(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i = i + 1) {\n        sum += i * i * i;\n    }\n    return sum;\n}\n\n', 'bool2int'), ('#include <iostream>\n#include <cassert>\nint sum_Of_Series(int n) {\n    int sum = 0;\n    for (long i = 1; i <= n; i = i + 1) {\n//begin to write code\n', '\nusing namespace std;\n#include<stdlib.h>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#include<string>\n\nint sum_Of_Series(int n) {\n    int sum = 0;\n    for (long i = 1; i <= n; i = i + 1) {\n        sum += i * i * i;\n    }\n    return sum;\n}\n\n', 'more_universe_var_type')]}"
494,"#include <iostream>
#include <vector>
#include <cassert>
std::vector<int> re_order(std::vector<int>& A) {
    int k = 0;
    for (int i : A) {
        if (i != 0) {
            A[k] = i;
            k++;
//begin to write code
",226,"
#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> re_order(std::vector<int>& A) {
    int k = 0;
    for (int i : A) {
        if (i != 0) {
            A[k] = i;
            k++;
        }
    }
    for (int i = k; i < A.size(); i++) {
        A[i] = 0;
    }
    return A;
}


","
using namespace std;

#include <iostream>
#include <vector>
#include <cassert>

std::vector<int> re_order(std::vector<int>& A) {
    int k = 0;
    for (int i : A) {
        if (i!= 0) {
            A[k] = i;
            k++;
        }
    }
    return A;
}

",,,,-2,1,0.2269831657409668,code_expression_exchange:None,0.0,0.0,
495,"#include<iostream>
#include <vector>
#include <cassert>
using namespace std;
int permutation_coefficient(int n, int k) {
    vector<vector<int>> P(n + 1, vector<int>(k + 1, 0));
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= min(i, k); j++) {
            if (j == 0)
                P[i][j] = 1;
            else
//begin to write code
",352,"#include<iostream>
    

#include <vector>
#include <cassert>
using namespace std;

int permutation_coefficient(int n, int k) {
    vector<vector<int>> P(n + 1, vector<int>(k + 1, 0));
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= min(i, k); j++) {
            if (j == 0)
                P[i][j] = 1;
            else
                P[i][j] = P[i - 1][j] + j * P[i - 1][j - 1];
            if (j < k)
                P[i][j + 1] = 0;
        }
    }
    return P[n][k];
}


","
#include<iostream>
#include <vector>
#include <cassert>
using namespace std;

int permutation_coefficient(int n, int k) {
    // Initialize the first row of the Pascal's triangle
    for (int i = 0; i <= n; i++) {
        P[i][0] = 1;
    }

    // Fill the Pascal's triangle
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= min(i, k); j++) {
            P[i][j] = P[i - 1][j - 1] + P[i - 1][j];
        }
    }

    return P[n][k];
}

",,,,-2,1,0.2313172976175944,code_expression_exchange:None,0.0,0.0,
496,"#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
std::vector<std::string> remove_words(std::vector<std::string>& list1, const std::vector<std::string>& removewords) {
    for (const auto& word : removewords) {
        list1.erase(std::remove(list1.begin(), list1.end(), word), list1.end());
//begin to write code
",342,"
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::vector<std::string> remove_words(std::vector<std::string>& list1, const std::vector<std::string>& removewords) {
    for (const auto& word : removewords) {
        list1.erase(std::remove(list1.begin(), list1.end(), word), list1.end());
    }
    return list1;
}


","
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
std::vector<std::string> remove_words(std::vector<std::string>& list1, const std::vector<std::string>& removewords) {
    // Remove all occurrences of each word in removewords from list1
    std::vector<std::string> result;
    for (const auto& word : list1) {
        if (!removewords.empty() && word == removewords.front()) {
            // Skip the first occurrence of the word
            removewords.erase(removewords.begin());
        } else {
            result.push_back(word);
        }
    }
    return result;
}

",,,,-2,1,0.2317348519961039,code_expression_exchange:None,0.0,0.0,
497,"#include<cassert>
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
bool same_order(const std::vector<std::string>& l1, const std::vector<std::string>& l2) {
    std::set<std::string> s1(l1.begin(), l1.end());
    std::set<std::string> s2(l2.begin(), l2.end());
    std::vector<std::string> common_elements;
    std::set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), std::back_inserter(common_elements));
    std::vector<std::string> filtered_l1;
    for (auto &item : l1) {
        if (std::find(common_elements.begin(), common_elements.end(), item) != common_elements.end()) {
            filtered_l1.push_back(item);
//begin to write code
",677,"#include<cassert>
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>

bool same_order(const std::vector<std::string>& l1, const std::vector<std::string>& l2) {
    std::set<std::string> s1(l1.begin(), l1.end());
    std::set<std::string> s2(l2.begin(), l2.end());
    std::vector<std::string> common_elements;

    std::set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), std::back_inserter(common_elements));

    std::vector<std::string> filtered_l1;
    for (auto &item : l1) {
        if (std::find(common_elements.begin(), common_elements.end(), item) != common_elements.end()) {
            filtered_l1.push_back(item);
        }
    }

    std::vector<std::string> filtered_l2;
    for (auto &item : l2) {
        if (std::find(common_elements.begin(), common_elements.end(), item) != common_elements.end()) {
            filtered_l2.push_back(item);
        }
    }

    return filtered_l1 == filtered_l2;
}


","#include <cassert>
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>

bool same_order(const std::vector<std::string>& l1, const std::vector<std::string>& l2) {
    std::set<std::string> s1(l1.begin(), l1.end());
    std::set<std::string> s2(l2.begin(), l2.end());
    std::vector<std::string> common_elements;
    std::set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), std::back_inserter(common_elements));
    std::vector<std::string> filtered_l1;
    for (auto &item : l1) {
        if (std::find(common_elements.begin(), common_elements.end(), item)!= common_elements.end()) {
            filtered_l1.push_back(item);
        }
    }
    return filtered_l1 == l2;
}
",,,,-2,1,0.22198723951975505,code_expression_exchange:None,0.0,0.0,
498,"#include <iostream>
#include <cassert>
int average_Odd(int n) {
    if (n % 2 == 0) {
        std::cerr << ""Invalid Input"" << std::endl;
        return -1;
    }
    int sm = 0;
    int count = 0;
//begin to write code
",219,"
#include <iostream>
#include <cassert>

int average_Odd(int n) {
    if (n % 2 == 0) {
        std::cerr << ""Invalid Input"" << std::endl;
        return -1;
    }
    int sm = 0;
    int count = 0;
    while (n >= 1) {
        count += 1;
        sm += n;
        n -= 2;
    }
    return sm / count;
}


","
#include <iostream>
#include <cassert>

int average_Odd(int n) {
    if (n % 2 == 0) {
        std::cerr << ""Invalid Input"" << std::endl;
        return -1;
    }
    int sm = 0;
    int count = 0;
    for (int i = 1; i <= n; i += 2) {
        sm += i;
        count++;
    }
    return static_cast<int>(sm / count);
}

","#include <iostream>
#include <cassert>
int average_Odd(int n) {
    if (n % 2 == 0) {
        std::cerr << ""Invalid Input"" << std::endl;
        return -1;
    }
    int sm = 0;
    int count = 0;
//begin to write code
","
#include <iostream>
#include <cassert>

int average_Odd(int n) {
    if (n % 2 == 0) {
        std::cerr << ""Invalid Input"" << std::endl;
        return -1;
    }
    int sm = 0;
    int count = 0;
    while (n >= 1) {
        count = count + (1);
        sm = sm + (n);
        n = n - (2);
    }
    return sm / count;
}


","
#include <iostream>
#include <cassert>

int average_Odd(int n) {
    if (n % 2 == 0) {
        std::cerr << ""Invalid Input"" << std::endl;
        return -1;
    }
    int sm = 0;
    int count = 0;
    while (count < n) {
        if (count % 2!= 0) {
            sm += count;
        }
        count++;
    }
    return sm / n;
}

",1,3,0.4664185365041097,code_expression_exchange:equal_expression_transformation,1.0,0.0,"{'\n#include <iostream>\n#include <cassert>\n\nint average_Odd(int n) {\n    if (n % 2 == 0) {\n        std::cerr << ""Invalid Input"" << std::endl;\n        return -1;\n    }\n    int sm = 0;\n    int count = 0;\n    while (n >= 1) {\n        count = count + (1);\n        sm = sm + (n);\n        n = n - (2);\n    }\n    return sm / count;\n}\n\n\n': [('#include <iostream>\n#include <cassert>\nint average_Odd(int n) {\n    if (n % 2 == 0) {\n        std::cerr << ""Invalid Input"" << std::endl;\n        return -1;\n    }\n    int sm = 0;\n    int count = 0;\n//begin to write code\n', '\n#include <iostream>\n#include <cassert>\n\nint average_Odd(int n) {\n    if (n % 2 == 0) {\n        std::cerr << ""Invalid Input"" << std::endl;\n        return -1;\n    }\n    int sm = 0;\n    int count = 0;\n    while (count < n) {\n        if (count % 2!= 0) {\n            sm += count;\n        }\n        count++;\n    }\n    return sm / n;\n}\n\n', 'equal_expression_transformation')]}"
499,"#include<iostream>
#include <vector>
#include <cassert>
using namespace std;
int no_of_subsequences(vector<int> arr, int k) {
    int n = arr.size();
    vector<vector<int>> dp(k + 1, vector<int>(n + 1, 0));
    for (int i = 1; i <= k; i++) {
        for (int j = 1; j <= n; j++) {
            dp[i][j] = dp[i][j - 1];
//begin to write code
",341,"#include<iostream>
    

#include <vector>
#include <cassert>

using namespace std;

int no_of_subsequences(vector<int> arr, int k) {
    int n = arr.size();
    vector<vector<int>> dp(k + 1, vector<int>(n + 1, 0));
    
    for (int i = 1; i <= k; i++) {
        for (int j = 1; j <= n; j++) {
            dp[i][j] = dp[i][j - 1];
            if (arr[j - 1] <= i && arr[j - 1] > 0) {
                dp[i][j] += dp[i / arr[j - 1]][j - 1] + 1;
            }
        }
    }
    return dp[k][n];
}


","
#include<iostream>
#include <vector>
#include <cassert>
using namespace std;

int no_of_subsequences(vector<int> arr, int k) {
    int n = arr.size();
    vector<vector<int>> dp(k + 1, vector<int>(n + 1, 0));
    for (int i = 1; i <= k; i++) {
        for (int j = 1; j <= n; j++) {
            if (arr[j - 1] * arr[j - 1] >= k) {
                dp[i][j] = 0;
            } else {
                dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1];
            }
        }
    }
    return dp[k][n];
}

",,,,-2,1,0.23876497745513917,code_expression_exchange:None,0.0,0.0,
